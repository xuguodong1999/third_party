# qtnodes
function(xgd_link_qtnodes TARGET)
    add_dependencies(${TARGET} QtNodes)
    target_link_libraries(${TARGET} PRIVATE QtNodes)
endfunction()

# yoga
function(xgd_link_yoga TARGET)
    add_dependencies(${TARGET} yoga)
    target_link_libraries(${TARGET} PRIVATE yoga)
endfunction()

# spdlog
function(xgd_link_spdlog TARGET)
    add_dependencies(${TARGET} spdlog)
    target_link_libraries(${TARGET} PRIVATE spdlog)
endfunction()

# Threads::Threads
function(xgd_link_threads TARGET)
    cmake_parse_arguments(param "PUBLIC" "" "" ${ARGN})
    if (param_PUBLIC)
        target_link_libraries(${TARGET} PUBLIC Threads::Threads)
    else ()
        target_link_libraries(${TARGET} PRIVATE Threads::Threads)
    endif ()
endfunction()

# gtest
function(xgd_link_gtest TARGET)
    cmake_parse_arguments(param "NO_MAIN" "" "" ${ARGN})
    add_dependencies(${TARGET} gtest)
    target_link_libraries(${TARGET} PRIVATE gtest)
    if (NOT param_NO_MAIN)
        target_sources(
                ${TARGET}
                PRIVATE ${XGD_EXTERNAL_DIR}/cpp/gtest-src/gtest/googletest/src/gtest_main.cc
        )
    endif ()
    set(TEST_COMMAND "${TARGET}")
    get_target_property(RUNTIME_OUTPUT_DIRECTORY ${TARGET} RUNTIME_OUTPUT_DIRECTORY)
    if (NOT RUNTIME_OUTPUT_DIRECTORY)
        if (CMAKE_RUNTIME_OUTPUT_DIRECTORY)
            set(RUNTIME_OUTPUT_DIRECTORY ${CMAKE_RUNTIME_OUTPUT_DIRECTORY})
        else ()
            set(RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})
        endif ()
    endif ()
    if (EMSCRIPTEN AND NODEJS_RUNTIME)
        set(OUTPUT_JS ${RUNTIME_OUTPUT_DIRECTORY}/${TARGET}.js)
        if (CMAKE_HOST_WIN32)
            set(OUTPUT_JS "file://${OUTPUT_JS}")
        endif ()
        set(TEST_COMMAND
                "${NODEJS_RUNTIME}"
                "--experimental-wasm-threads"
                "-e"
                "import('${OUTPUT_JS}').then(m => ('function' === typeof m?.default) ? m.default() : 0)")
    elseif (XGD_WINE64_RUNTIME)
        set(TEST_COMMAND
                "${XGD_WINE64_RUNTIME}"
                "${RUNTIME_OUTPUT_DIRECTORY}/${TARGET}.exe")
    endif ()
    add_test(NAME ${TARGET} COMMAND ${TEST_COMMAND} WORKING_DIRECTORY ${CMAKE_SOURCE_DIR})
    if (NOT TARGET gtest_programs_all)
        add_custom_target(gtest_programs_all)
    endif ()
    add_dependencies(gtest_programs_all ${TARGET})
endfunction()

# benchmark
function(xgd_link_benchmark TARGET)
    cmake_parse_arguments(param "NO_MAIN" "" "" ${ARGN})
    add_dependencies(${TARGET} benchmark)
    target_link_libraries(${TARGET} PRIVATE benchmark)
    if (NOT param_NO_MAIN)
        target_sources(
                ${TARGET}
                PRIVATE ${XGD_EXTERNAL_DIR}/cpp/benchmark-src/benchmark/src/benchmark_main.cc
        )
    endif ()
    if (NOT TARGET benchmark_programs_all)
        add_custom_target(benchmark_programs_all)
    endif ()
    add_dependencies(benchmark_programs_all ${TARGET})
endfunction()

# zlib
function(xgd_link_zlib TARGET)
    cmake_parse_arguments(param "PUBLIC" "" "" ${ARGN})
    add_dependencies(${TARGET} zlib)
    if (param_PUBLIC)
        target_link_libraries(${TARGET} PUBLIC zlib)
    else ()
        target_link_libraries(${TARGET} PRIVATE zlib)
    endif ()
endfunction()

# libxml2
function(xgd_link_xml2 TARGET)
    add_dependencies(${TARGET} xml2)
    target_link_libraries(${TARGET} PRIVATE xml2)
endfunction()

# libpng
function(xgd_link_png TARGET)
    cmake_parse_arguments(param "PUBLIC" "" "" ${ARGN})
    if (param_PUBLIC)
        target_link_libraries(${TARGET} PUBLIC png)
    else ()
        target_link_libraries(${TARGET} PRIVATE png)
    endif ()
    if (WIN32 AND BUILD_SHARED_LIBS)
        target_compile_definitions(${TARGET} PRIVATE PNG_USE_DLL)
    endif ()
endfunction()

# boost
function(xgd_link_boost TARGET)
    # usage: xgd_link_boost(your-awesome-target PRIVATE [iostreams json ...])
    cmake_parse_arguments(param "" "" "PRIVATE;PUBLIC" ${ARGN})
    if ((NOT param_PRIVATE) AND (NOT param_PUBLIC))
        message(FATAL "xgd_link_boost: no components given")
    endif ()
    foreach (COMPONENT ${param_PRIVATE})
        if (NOT TARGET Boost::${COMPONENT})
            message(STATUS "boost: use Boost::${COMPONENT} as an interface")
            xgd_use_header(${TARGET} PRIVATE boost)
            continue()
        endif ()
        add_dependencies(${TARGET} Boost::${COMPONENT})
        target_link_libraries(${TARGET} PRIVATE Boost::${COMPONENT})
    endforeach ()
    foreach (COMPONENT ${param_PUBLIC})
        if (NOT TARGET Boost::${COMPONENT})
            message(STATUS "boost: use Boost::${COMPONENT} as an interface")
            xgd_use_header(${TARGET} PUBLIC boost)
            continue()
        endif ()
        add_dependencies(${TARGET} Boost::${COMPONENT})
        target_link_libraries(${TARGET} PUBLIC Boost::${COMPONENT})
    endforeach ()
endfunction()

# qt
function(xgd_link_qt TARGET)
    # usage: xgd_link_qt(your-awesome-target COMPONENTS [Core Widgets ...])
    cmake_parse_arguments(param "" "" "PUBLIC;PRIVATE" ${ARGN})
    if ((NOT param_PRIVATE) AND (NOT param_PUBLIC))
        message(FATAL "xgd_link_qt: no components given")
    endif ()
    foreach (COMPONENT ${param_PRIVATE})
        target_link_libraries(${TARGET} PRIVATE Qt${QT_VERSION_MAJOR}::${COMPONENT})
    endforeach ()
    foreach (COMPONENT ${param_PUBLIC})
        target_link_libraries(${TARGET} PUBLIC Qt${QT_VERSION_MAJOR}::${COMPONENT})
    endforeach ()
    target_compile_definitions(
            ${TARGET}
            PRIVATE QT_DISABLE_DEPRECATED_BEFORE=0x060000
            QT_NO_KEYWORDS
    )
    set_target_properties(${TARGET} PROPERTIES AUTOUIC ON AUTOMOC ON AUTORCC ON)
endfunction()

# vulkan
function(xgd_link_vulkan TARGET)
    if (TARGET Vulkan::Vulkan)
        target_link_libraries(${TARGET} PRIVATE Vulkan::Vulkan)
    else ()
        target_include_directories(${TARGET} PRIVATE ${Vulkan_INCLUDE_DIR})
        target_link_libraries(${TARGET} PRIVATE ${Vulkan_LIBRARIES})
    endif ()
    if (TARGET Vulkan::shaderc_combined)
        target_link_libraries(${TARGET} PRIVATE Vulkan::shaderc_combined)
    else ()
        target_include_directories(${TARGET} PRIVATE ${Vulkan_INCLUDE_DIR})
        target_link_libraries(${TARGET} PRIVATE ${Vulkan_shaderc_combined_LIBRARY})
    endif ()
    if (ANDROID)
        target_include_directories(${TARGET} PRIVATE ${Vulkan_ANDROID_INCLUDE_DIR})
    endif ()
endfunction()

# inchi
function(xgd_link_inchi TARGET)
    add_dependencies(${TARGET} inchi)
    target_link_libraries(${TARGET} PRIVATE inchi)
endfunction()

# maeparser
function(xgd_link_maeparser TARGET)
    add_dependencies(${TARGET} maeparser)
    target_link_libraries(${TARGET} PRIVATE maeparser)
endfunction()

# coordgenlibs
function(xgd_link_coordgenlibs TARGET)
    add_dependencies(${TARGET} coordgenlibs)
    target_link_libraries(${TARGET} PRIVATE coordgenlibs)
endfunction()

# openbabel
function(xgd_link_openbabel TARGET)
    add_dependencies(${TARGET} openbabel)
    target_link_libraries(${TARGET} PRIVATE openbabel)
endfunction()

# yaehmop
function(xgd_link_yaehmop TARGET)
    add_dependencies(${TARGET} yaehmop)
    target_link_libraries(${TARGET} PRIVATE yaehmop)
endfunction()

# avalontoolkit
function(xgd_link_avalontoolkit TARGET)
    add_dependencies(${TARGET} avalontoolkit)
    target_link_libraries(${TARGET} PRIVATE avalontoolkit)
endfunction()

# freesasa
function(xgd_link_freesasa TARGET)
    add_dependencies(${TARGET} freesasa)
    target_link_libraries(${TARGET} PRIVATE freesasa)
endfunction()

# ringdecomposerlib
function(xgd_link_ringdecomposerlib TARGET)
    cmake_parse_arguments(param "PUBLIC" "" "" ${ARGN})
    add_dependencies(${TARGET} ringdecomposerlib)
    if (param_PUBLIC)
        target_link_libraries(${TARGET} PUBLIC ringdecomposerlib)
    else ()
        target_link_libraries(${TARGET} PRIVATE ringdecomposerlib)
    endif ()
endfunction()

# rdkit
function(xgd_link_rdkit TARGET)
    cmake_parse_arguments(param "" "" "PRIVATE;PUBLIC" ${ARGN})
    if ((NOT param_PRIVATE) AND (NOT param_PUBLIC))
        message(FATAL "xgd_link_rdkit: no components given")
    endif ()
    foreach (RDKIT_COMPONENT ${param_PRIVATE})
        # string(TOLOWER ${RDKIT_COMPONENT} RDKIT_COMPONENT_TARGET)
        set(RDKIT_COMPONENT_TARGET ${RDKIT_COMPONENT})
        set(RDKIT_COMPONENT_TARGET rdkit_${RDKIT_COMPONENT_TARGET})
        add_dependencies(${TARGET} ${RDKIT_COMPONENT_TARGET})
        target_link_libraries(${TARGET} PRIVATE ${RDKIT_COMPONENT_TARGET})
    endforeach ()
    foreach (RDKIT_COMPONENT ${param_PUBLIC})
        # string(TOLOWER ${RDKIT_COMPONENT} RDKIT_COMPONENT_TARGET)
        set(RDKIT_COMPONENT_TARGET ${RDKIT_COMPONENT})
        set(RDKIT_COMPONENT_TARGET rdkit_${RDKIT_COMPONENT_TARGET})
        add_dependencies(${TARGET} ${RDKIT_COMPONENT_TARGET})
        target_link_libraries(${TARGET} PUBLIC ${RDKIT_COMPONENT_TARGET})
    endforeach ()
endfunction()

# ncnn
function(xgd_link_ncnn TARGET)
    add_dependencies(${TARGET} ncnn)
    target_link_libraries(${TARGET} PRIVATE ncnn)
endfunction()

# openmp
function(xgd_link_omp TARGET)
    get_target_property(XGD_OMP_TRY_LINKED ${TARGET} XGD_OMP_TRY_LINKED)
    if (XGD_OMP_TRY_LINKED)
        return()
    endif ()
    if (ANDROID)
        target_link_libraries(${TARGET} PRIVATE -static-openmp)
        set_target_properties(${TARGET} PROPERTIES XGD_OMP_LINKED 1)
    elseif (OpenMP_CXX_FOUND)
        target_link_libraries(${TARGET} PRIVATE OpenMP::OpenMP_CXX)
        set_target_properties(${TARGET} PROPERTIES XGD_OMP_LINKED 1)
    else ()
        message(STATUS "openmp: OpenMP_CXX not found for ${TARGET}")
        set_target_properties(${TARGET} PROPERTIES XGD_OMP_LINKED 0)
    endif ()
    set_target_properties(${TARGET} PROPERTIES XGD_OMP_TRY_LINKED 1)
endfunction()

function(xgd_link_ncnn_omp TARGET)
    get_target_property(XGD_OMP_LINKED ${TARGET} XGD_OMP_LINKED)
    if (XGD_OMP_LINKED)
        return()
    endif ()
    if (TARGET ncnn_omp)
        add_dependencies(${TARGET} ncnn_omp)
        target_link_libraries(${TARGET} PRIVATE ncnn_omp)
        message(STATUS "openmp: link ${TARGET} to ncnn simpleomp")
    endif ()
endfunction()

function(xgd_use_header TARGET)
    cmake_parse_arguments(param "" "" "PUBLIC;PRIVATE" ${ARGN})
    macro(xgd_internal_include_header HEADER PUBLIC)
        string(TOLOWER ${HEADER} HEADER_DIR)
        set(HEADER_DIRS)
        if (${HEADER_DIR} STREQUAL "boost")
            list(APPEND HEADER_DIRS ${XGD_EXTERNAL_DIR}/cpp/boost-src/boost)
        elseif (${HEADER_DIR} STREQUAL "cutlass")
            list(APPEND HEADER_DIRS ${XGD_EXTERNAL_DIR}/cpp/cutlass-src/cutlass/include)
            list(APPEND HEADER_DIRS ${XGD_EXTERNAL_DIR}/cpp/cutlass-src/cutlass/tools/util/include)
        elseif (${HEADER_DIR} STREQUAL "eigen")
            list(APPEND HEADER_DIRS ${XGD_EXTERNAL_DIR}/cpp/eigen-src/eigen)
        elseif (${HEADER_DIR} STREQUAL "lbfgs")
            list(APPEND HEADER_DIRS ${XGD_EXTERNAL_DIR}/cpp/lbfgs-src/lbfgs/include)
        elseif (${HEADER_DIR} STREQUAL "rapidjson")
            list(APPEND HEADER_DIRS ${XGD_EXTERNAL_DIR}/cpp/rapidjson-src/rapidjson/include)
        elseif (${HEADER_DIR} STREQUAL "taskflow")
            list(APPEND HEADER_DIRS ${XGD_EXTERNAL_DIR}/cpp/taskflow-src/taskflow)
        else ()
            message(FATAL_ERROR "${HEADER_DIR} is not a valid 3rdparty header library")
        endif ()
        if (${PUBLIC})
            target_include_directories(${TARGET} PUBLIC ${HEADER_DIRS})
        else ()
            target_include_directories(${TARGET} PRIVATE ${HEADER_DIRS})
        endif ()
    endmacro()
    macro(xgd_internal_link_header_deps HEADER)
        string(TOLOWER ${HEADER} HEADER_DIR)
        if (${HEADER_DIR} STREQUAL "armadillo")
            target_compile_definitions(${TARGET} PRIVATE ARMA_DONT_USE_LAPACK ARMA_DONT_USE_BLAS)
            xgd_link_omp(${TARGET})
            if (MSVC)
                # enable openmp 3.0, which fix C3016
                target_compile_options(${TARGET} PRIVATE /openmp:llvm)
            endif ()
        elseif (${HEADER_DIR} STREQUAL "boost")
            target_compile_definitions(${TARGET} PRIVATE "_HAS_AUTO_PTR_ETC=0")
        elseif (${HEADER_DIR} STREQUAL "cutlass")
            xgd_link_cuda(${TARGET} PRIVATE cudart)
        elseif (${HEADER_DIR} STREQUAL "eigen")
            target_compile_definitions(${TARGET} PRIVATE EIGEN_USE_THREADS)
            xgd_link_omp(${TARGET})
        elseif (${HEADER_DIR} STREQUAL "taskflow")
            xgd_link_threads(${TARGET})
        endif ()
    endmacro()
    foreach (HEADER ${param_PUBLIC})
        xgd_internal_include_header(${HEADER} 1)
    endforeach ()
    foreach (HEADER ${param_PRIVATE})
        xgd_internal_include_header(${HEADER} 0)
    endforeach ()
    foreach (HEADER ${param_PUBLIC} ${param_PRIVATE})
        xgd_internal_link_header_deps(${HEADER})
    endforeach ()
endfunction()

function(xgd_link_cuda TARGET)
    cmake_parse_arguments(param "" "" "PRIVATE;PUBLIC" ${ARGN})
    if (param_PUBLIC)
        target_include_directories(${TARGET} PUBLIC ${CMAKE_CUDA_TOOLKIT_INCLUDE_DIRECTORIES})
    else ()
        target_include_directories(${TARGET} PRIVATE ${CMAKE_CUDA_TOOLKIT_INCLUDE_DIRECTORIES})
    endif ()
    foreach (COMPONENT ${param_PUBLIC})
        target_link_libraries(${TARGET} PUBLIC CUDA::${COMPONENT})
    endforeach ()
    foreach (COMPONENT ${param_PRIVATE})
        target_link_libraries(${TARGET} PRIVATE CUDA::${COMPONENT})
    endforeach ()
endfunction()
