Subject: [PATCH] third_party-changes
---
Index: openssl-src/openssl/crypto/bn_conf.h.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openssl-src/openssl/crypto/bn_conf.h.cmake b/openssl-src/openssl/crypto/bn_conf.h.cmake
new file mode 100644
--- /dev/null	(date 1689048276014)
+++ b/openssl-src/openssl/crypto/bn_conf.h.cmake	(date 1689048276014)
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2016 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://www.openssl.org/source/license.html
+ */
+
+#ifndef OSSL_CRYPTO_BN_CONF_H
+# define OSSL_CRYPTO_BN_CONF_H
+
+/*
+ * The contents of this file are not used in the UEFI build, as
+ * both 32-bit and 64-bit builds are supported from a single run
+ * of the Configure script.
+ */
+
+/* Should we define BN_DIV2W here? */
+
+/* Only one for the following should be defined */
+#cmakedefine SIXTY_FOUR_BIT_LONG
+#cmakedefine SIXTY_FOUR_BIT
+#cmakedefine THIRTY_TWO_BIT
+
+#endif
Index: opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_block.simd.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_block.simd.hpp b/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_block.simd.hpp
--- a/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_block.simd.hpp	(revision f9a59f2592993d3dcc080e495f4f5e02dd8ec7ef)
+++ b/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_block.simd.hpp	(date 1689048275942)
@@ -125,635 +125,4 @@
 
 CV_CPU_OPTIMIZATION_NAMESPACE_END
 
-// NEON code work around.
-namespace opt_NEON
-{
-#if !defined(CV_CPU_OPTIMIZATION_DECLARATIONS_ONLY) && CV_NEON
-
-void convBlock(int np, const float* a, const float* b, float* c, int ldc, bool init_c, int width, const int convMR, const int convNR)
-{
-#if CV_NEON_AARCH64
-    if (convMR == 4 && convNR == 28) // AARCH64
-    {
-        float32x4_t c00 = vdupq_n_f32(0.f), c01 = c00, c02 = c00, c03 = c00, c04 = c00, c05 = c00, c06 = c00;
-        float32x4_t c10 = vdupq_n_f32(0.f), c11 = c10, c12 = c10, c13 = c10, c14 = c10, c15 = c10, c16 = c10;
-        float32x4_t c20 = vdupq_n_f32(0.f), c21 = c20, c22 = c20, c23 = c20, c24 = c20, c25 = c20, c26 = c20;
-        float32x4_t c30 = vdupq_n_f32(0.f), c31 = c30, c32 = c30, c33 = c30, c34 = c30, c35 = c30, c36 = c30;
-
-        if (width > 16)
-        {
-            for( int p = 0; p < np; p++, a += convMR, b += convNR )
-            {
-                float32x4_t a0 = vld1q_f32(a), b0, b1, b2;
-                b0 = vld1q_f32(b); b1 = vld1q_f32(b + 4); b2 = vld1q_f32(b + 8);
-
-                c00 = vfmaq_laneq_f32(c00, b0, a0, 0);
-                c01 = vfmaq_laneq_f32(c01, b1, a0, 0);
-                c02 = vfmaq_laneq_f32(c02, b2, a0, 0);
-                c10 = vfmaq_laneq_f32(c10, b0, a0, 1);
-                c11 = vfmaq_laneq_f32(c11, b1, a0, 1);
-                c12 = vfmaq_laneq_f32(c12, b2, a0, 1);
-                c20 = vfmaq_laneq_f32(c20, b0, a0, 2);
-                c21 = vfmaq_laneq_f32(c21, b1, a0, 2);
-                c22 = vfmaq_laneq_f32(c22, b2, a0, 2);
-                c30 = vfmaq_laneq_f32(c30, b0, a0, 3);
-                c31 = vfmaq_laneq_f32(c31, b1, a0, 3);
-                c32 = vfmaq_laneq_f32(c32, b2, a0, 3);
-
-                b0 = vld1q_f32(b + 12); b1 = vld1q_f32(b + 16); b2 = vld1q_f32(b + 20);
-
-                c03 = vfmaq_laneq_f32(c03, b0, a0, 0);
-                c04 = vfmaq_laneq_f32(c04, b1, a0, 0);
-                c05 = vfmaq_laneq_f32(c05, b2, a0, 0);
-                c13 = vfmaq_laneq_f32(c13, b0, a0, 1);
-                c14 = vfmaq_laneq_f32(c14, b1, a0, 1);
-                c15 = vfmaq_laneq_f32(c15, b2, a0, 1);
-                c23 = vfmaq_laneq_f32(c23, b0, a0, 2);
-                c24 = vfmaq_laneq_f32(c24, b1, a0, 2);
-                c25 = vfmaq_laneq_f32(c25, b2, a0, 2);
-                c33 = vfmaq_laneq_f32(c33, b0, a0, 3);
-                c34 = vfmaq_laneq_f32(c34, b1, a0, 3);
-                c35 = vfmaq_laneq_f32(c35, b2, a0, 3);
-
-                b0 = vld1q_f32(b + 24);
-                c06 = vfmaq_laneq_f32(c06, b0, a0, 0);
-                c16 = vfmaq_laneq_f32(c16, b0, a0, 1);
-                c26 = vfmaq_laneq_f32(c26, b0, a0, 2);
-                c36 = vfmaq_laneq_f32(c36, b0, a0, 3);
-            }
-        }
-        else if (width > 8)
-        {
-            for( int p = 0; p < np; p++, a += convMR, b += convNR )
-            {
-                float32x4_t a0 = vld1q_f32(a), b0, b1, b2;
-                b0 = vld1q_f32(b); b1 = vld1q_f32(b + 4); b2 = vld1q_f32(b + 8);
-
-                c00 = vfmaq_laneq_f32(c00, b0, a0, 0);
-                c01 = vfmaq_laneq_f32(c01, b1, a0, 0);
-                c02 = vfmaq_laneq_f32(c02, b2, a0, 0);
-                c10 = vfmaq_laneq_f32(c10, b0, a0, 1);
-                c11 = vfmaq_laneq_f32(c11, b1, a0, 1);
-                c12 = vfmaq_laneq_f32(c12, b2, a0, 1);
-                c20 = vfmaq_laneq_f32(c20, b0, a0, 2);
-                c21 = vfmaq_laneq_f32(c21, b1, a0, 2);
-                c22 = vfmaq_laneq_f32(c22, b2, a0, 2);
-                c30 = vfmaq_laneq_f32(c30, b0, a0, 3);
-                c31 = vfmaq_laneq_f32(c31, b1, a0, 3);
-                c32 = vfmaq_laneq_f32(c32, b2, a0, 3);
-
-                b0 = vld1q_f32(b + 12);
-
-                c03 = vfmaq_laneq_f32(c03, b0, a0, 0);
-                c13 = vfmaq_laneq_f32(c13, b0, a0, 1);
-                c23 = vfmaq_laneq_f32(c23, b0, a0, 2);
-                c33 = vfmaq_laneq_f32(c33, b0, a0, 3);
-            }
-        }
-        else if (width > 4)
-        {
-            for( int p = 0; p < np; p++, a += convMR, b += convNR )
-            {
-                float32x4_t a0 = vld1q_f32(a), b0, b1;
-                b0 = vld1q_f32(b); b1 = vld1q_f32(b + 4);
-
-                c00 = vfmaq_laneq_f32(c00, b0, a0, 0);
-                c01 = vfmaq_laneq_f32(c01, b1, a0, 0);
-                c10 = vfmaq_laneq_f32(c10, b0, a0, 1);
-                c11 = vfmaq_laneq_f32(c11, b1, a0, 1);
-                c20 = vfmaq_laneq_f32(c20, b0, a0, 2);
-                c21 = vfmaq_laneq_f32(c21, b1, a0, 2);
-                c30 = vfmaq_laneq_f32(c30, b0, a0, 3);
-                c31 = vfmaq_laneq_f32(c31, b1, a0, 3);
-            }
-        }
-        else
-        {
-            for( int p = 0; p < np; p++, a += convMR, b += convNR )
-            {
-                float32x4_t a0 = vld1q_f32(a), b0;
-                b0 = vld1q_f32(b);
-
-                c00 = vfmaq_laneq_f32(c00, b0, a0, 0);
-                c10 = vfmaq_laneq_f32(c10, b0, a0, 1);
-                c20 = vfmaq_laneq_f32(c20, b0, a0, 2);
-                c30 = vfmaq_laneq_f32(c30, b0, a0, 3);
-            }
-        }
-
-        if (!init_c)
-        {
-            c00 = vaddq_f32(c00, vld1q_f32(c));
-            c01 = vaddq_f32(c01, vld1q_f32(c + 4));
-            c02 = vaddq_f32(c02, vld1q_f32(c + 8));
-            c03 = vaddq_f32(c03, vld1q_f32(c + 12));
-            c04 = vaddq_f32(c04, vld1q_f32(c + 16));
-            c05 = vaddq_f32(c05, vld1q_f32(c + 20));
-            c06 = vaddq_f32(c06, vld1q_f32(c + 24));
-
-            c10 = vaddq_f32(c10, vld1q_f32(c + ldc));
-            c11 = vaddq_f32(c11, vld1q_f32(c + ldc + 4));
-            c12 = vaddq_f32(c12, vld1q_f32(c + ldc + 8));
-            c13 = vaddq_f32(c13, vld1q_f32(c + ldc + 12));
-            c14 = vaddq_f32(c14, vld1q_f32(c + ldc + 16));
-            c15 = vaddq_f32(c15, vld1q_f32(c + ldc + 20));
-            c16 = vaddq_f32(c16, vld1q_f32(c + ldc + 24));
-
-            c20 = vaddq_f32(c20, vld1q_f32(c + ldc*2));
-            c21 = vaddq_f32(c21, vld1q_f32(c + ldc*2 + 4));
-            c22 = vaddq_f32(c22, vld1q_f32(c + ldc*2 + 8));
-            c23 = vaddq_f32(c23, vld1q_f32(c + ldc*2 + 12));
-            c24 = vaddq_f32(c24, vld1q_f32(c + ldc*2 + 16));
-            c25 = vaddq_f32(c25, vld1q_f32(c + ldc*2 + 20));
-            c26 = vaddq_f32(c26, vld1q_f32(c + ldc*2 + 24));
-
-            c30 = vaddq_f32(c30, vld1q_f32(c + ldc*3));
-            c31 = vaddq_f32(c31, vld1q_f32(c + ldc*3 + 4));
-            c32 = vaddq_f32(c32, vld1q_f32(c + ldc*3 + 8));
-            c33 = vaddq_f32(c33, vld1q_f32(c + ldc*3 + 12));
-            c34 = vaddq_f32(c34, vld1q_f32(c + ldc*3 + 16));
-            c35 = vaddq_f32(c35, vld1q_f32(c + ldc*3 + 20));
-            c36 = vaddq_f32(c36, vld1q_f32(c + ldc*3 + 24));
-        }
-
-        vst1q_f32(c, c00); vst1q_f32(c+4, c01);
-        vst1q_f32(c+8, c02); vst1q_f32(c+12, c03);
-        vst1q_f32(c+16, c04); vst1q_f32(c+20, c05);
-        vst1q_f32(c+24, c06);
-
-        vst1q_f32(c+ldc, c10); vst1q_f32(c+ldc+4, c11);
-        vst1q_f32(c+ldc+8, c12); vst1q_f32(c+ldc+12, c13);
-        vst1q_f32(c+ldc+16, c14); vst1q_f32(c+ldc+20, c15);
-        vst1q_f32(c+ldc+24, c16);
-
-        vst1q_f32(c+ldc*2, c20); vst1q_f32(c+ldc*2+4, c21);
-        vst1q_f32(c+ldc*2+8, c22); vst1q_f32(c+ldc*2+12, c23);
-        vst1q_f32(c+ldc*2+16, c24); vst1q_f32(c+ldc*2+20, c25);
-        vst1q_f32(c+ldc*2+24, c26);
-
-        vst1q_f32(c+ldc*3, c30); vst1q_f32(c+ldc*3+4, c31);
-        vst1q_f32(c+ldc*3+8, c32); vst1q_f32(c+ldc*3+12, c33);
-        vst1q_f32(c+ldc*3+16, c34); vst1q_f32(c+ldc*3+20, c35);
-        vst1q_f32(c+ldc*3+24, c36);
-    }
-    else
-#endif
-    if (convMR == 4 && convNR == 12) // ARMv7
-    {
-        float32x4_t c0 = vdupq_n_f32(0.f), c1 = c0, c2 = c0;
-        float32x4_t c3 = vdupq_n_f32(0.f), c4 = c3, c5 = c3;
-        float32x4_t c6 = vdupq_n_f32(0.f), c7 = c6, c8 = c6;
-        float32x4_t c9 = vdupq_n_f32(0.f), c10 = c9, c11 = c9;
-
-        float32x2_t a0 = vdup_n_f32(0.0f), a1 = a0;
-        float32x4_t b0 = vdupq_n_f32(0.0f), b1 = vdupq_n_f32(0.0f), b2 = vdupq_n_f32(0.0f);
-
-        if (width > 8)
-        {
-            for (int p = 0; p < np; p++, a += convMR, b += convNR)
-            {
-                a0 = vld1_f32(a), a1 = vld1_f32(a+2);
-                b0 = vld1q_f32(b), b1 = vld1q_f32(b + 4), b2 = vld1q_f32(b + 8);
-
-                c0 = vmlaq_lane_f32(c0, b0, a0, 0);
-                c1 = vmlaq_lane_f32(c1, b1, a0, 0);
-                c2 = vmlaq_lane_f32(c2, b2, a0, 0);
-
-                c3 = vmlaq_lane_f32(c3, b0, a0, 1);
-                c4 = vmlaq_lane_f32(c4, b1, a0, 1);
-                c5 = vmlaq_lane_f32(c5, b2, a0, 1);
-
-                c6 = vmlaq_lane_f32(c6, b0, a1, 0);
-                c7 = vmlaq_lane_f32(c7, b1, a1, 0);
-                c8 = vmlaq_lane_f32(c8, b2, a1, 0);
-
-                c9  = vmlaq_lane_f32(c9 , b0, a1, 1);
-                c10 = vmlaq_lane_f32(c10, b1, a1, 1);
-                c11 = vmlaq_lane_f32(c11, b2, a1, 1);
-            }
-        }
-        else if (width > 4)
-        {
-            for (int p = 0; p < np; p++, a += convMR, b += convNR)
-            {
-                a0 = vld1_f32(a), a1 = vld1_f32(a+2);
-                b0 = vld1q_f32(b), b1 = vld1q_f32(b + 4);
-
-                c0 = vmlaq_lane_f32(c0, b0, a0, 0);
-                c1 = vmlaq_lane_f32(c1, b1, a0, 0);
-
-                c3 = vmlaq_lane_f32(c3, b0, a0, 1);
-                c4 = vmlaq_lane_f32(c4, b1, a0, 1);
-
-                c6 = vmlaq_lane_f32(c6, b0, a1, 0);
-                c7 = vmlaq_lane_f32(c7, b1, a1, 0);
-
-                c9  = vmlaq_lane_f32(c9 , b0, a1, 1);
-                c10 = vmlaq_lane_f32(c10, b1, a1, 1);
-            }
-        }
-        else
-        {
-            for (int p = 0; p < np; p++, a += convMR, b += convNR)
-            {
-                a0 = vld1_f32(a), a1 = vld1_f32(a+2);
-                b0 = vld1q_f32(b);
-
-                c0 = vmlaq_lane_f32(c0, b0, a0, 0);
-                c3 = vmlaq_lane_f32(c3, b0, a0, 1);
-                c6 = vmlaq_lane_f32(c6, b0, a1, 0);
-                c9  = vmlaq_lane_f32(c9 , b0, a1, 1);
-            }
-        }
-
-        if (!init_c)
-        {
-            c0 = vaddq_f32(c0, vld1q_f32(c));
-            c1 = vaddq_f32(c1, vld1q_f32(c + 4));
-            c2 = vaddq_f32(c2, vld1q_f32(c + 8));
-
-            c3 = vaddq_f32(c3, vld1q_f32(c + ldc));
-            c4 = vaddq_f32(c4, vld1q_f32(c + ldc + 4));
-            c5 = vaddq_f32(c5, vld1q_f32(c + ldc + 8));
-
-            c6 = vaddq_f32(c6, vld1q_f32(c + ldc * 2));
-            c7 = vaddq_f32(c7, vld1q_f32(c + ldc * 2 + 4));
-            c8 = vaddq_f32(c8, vld1q_f32(c + ldc * 2 + 8));
-
-            c9  = vaddq_f32(c9 , vld1q_f32(c + ldc * 3));
-            c10 = vaddq_f32(c10, vld1q_f32(c + ldc * 3 + 4));
-            c11 = vaddq_f32(c11, vld1q_f32(c + ldc * 3 + 8));
-        }
-
-        vst1q_f32(c, c0), vst1q_f32(c+4, c1), vst1q_f32(c+8, c2);
-        vst1q_f32(c + ldc, c3), vst1q_f32(c + ldc + 4, c4), vst1q_f32(c + ldc + 8, c5);
-        vst1q_f32(c + ldc*2, c6), vst1q_f32(c + ldc*2 + 4, c7), vst1q_f32(c + ldc*2 + 8, c8);
-        vst1q_f32(c + ldc*3, c9), vst1q_f32(c + ldc*3 + 4, c10), vst1q_f32(c + ldc*3 + 8, c11);
-    }
-    else
-        CV_Error(Error::StsNotImplemented, "Unsupported convMR and/or convNR in opt_NEON::convBlock");
-}
-
-void convBlockMR1_F32(int np, const float * a, const float * b, float *c, const float bias, bool init_c,
-                  const float minval, const float maxval, bool ifMinMaxAct, const int width, const int convNR)
-{
-    CV_Assert(convNR == 28);
-    float32x4_t c0 = vdupq_n_f32(bias), c1 = c0, c2 = c0;
-    float32x4_t c3 = c0, c4 = c0, c5 = c0, c6 = c0;
-
-    if (width > 16)
-    {
-        for (int p = 0; p < np; p++, a++, b += convNR)
-        {
-            float32x4_t b0 = vld1q_f32(b), b1 = vld1q_f32(b + 4), b2 = vld1q_f32(b + 8);
-            float32x4_t b3 = vld1q_f32(b + 12), b4 = vld1q_f32(b + 16), b5 = vld1q_f32(b + 20);
-            float32x4_t b6 = vld1q_f32(b + 24);
-
-            c0 = vmlaq_n_f32(c0, b0, a[0]);
-            c1 = vmlaq_n_f32(c1, b1, a[0]);
-            c2 = vmlaq_n_f32(c2, b2, a[0]);
-            c3 = vmlaq_n_f32(c3, b3, a[0]);
-            c4 = vmlaq_n_f32(c4, b4, a[0]);
-            c5 = vmlaq_n_f32(c5, b5, a[0]);
-            c6 = vmlaq_n_f32(c6, b6, a[0]);
-        }
-    }
-    else if (width > 8)
-    {
-        for (int p = 0; p < np; p++, a++, b += convNR)
-        {
-            float32x4_t b0 = vld1q_f32(b), b1 = vld1q_f32(b + 4), b2 = vld1q_f32(b + 8);
-            float32x4_t b3 = vld1q_f32(b + 12);
-
-            c0 = vmlaq_n_f32(c0, b0, a[0]);
-            c1 = vmlaq_n_f32(c1, b1, a[0]);
-            c2 = vmlaq_n_f32(c2, b2, a[0]);
-            c3 = vmlaq_n_f32(c3, b3, a[0]);
-        }
-    }
-    else if (width > 4)
-    {
-        for (int p = 0; p < np; p++, a++, b += convNR)
-        {
-            float32x4_t b0 = vld1q_f32(b), b1 = vld1q_f32(b + 4);
-
-            c0 = vmlaq_n_f32(c0, b0, a[0]);
-            c1 = vmlaq_n_f32(c1, b1, a[0]);
-        }
-    }
-    else
-    {
-        for (int p = 0; p < np; p++, a++, b += convNR)
-        {
-            float32x4_t b0 = vld1q_f32(b);
-            c0 = vmlaq_n_f32(c0, b0, a[0]);
-        }
-    }
-
-    if (init_c)
-    {
-        c0 += vld1q_f32(c);
-        c1 += vld1q_f32(c + 4);
-        c2 += vld1q_f32(c + 8);
-        c3 += vld1q_f32(c + 12);
-        c4 += vld1q_f32(c + 16);
-        c5 += vld1q_f32(c + 20);
-        c6 += vld1q_f32(c + 24);
-    }
-
-    if (ifMinMaxAct)
-    {
-        float32x4_t v_minval = vdupq_n_f32(minval), v_maxval = vdupq_n_f32(maxval);
-
-        c0 = vminq_f32(vmaxq_f32(c0, v_minval), v_maxval);
-        c1 = vminq_f32(vmaxq_f32(c1, v_minval), v_maxval);
-        c2 = vminq_f32(vmaxq_f32(c2, v_minval), v_maxval);
-        c3 = vminq_f32(vmaxq_f32(c3, v_minval), v_maxval);
-        c4 = vminq_f32(vmaxq_f32(c4, v_minval), v_maxval);
-        c5 = vminq_f32(vmaxq_f32(c5, v_minval), v_maxval);
-        c6 = vminq_f32(vmaxq_f32(c6, v_minval), v_maxval);
-    }
-
-    vst1q_f32(c, c0);
-    vst1q_f32(c + 4, c1);
-    vst1q_f32(c + 8, c2);
-    vst1q_f32(c + 12, c3);
-    vst1q_f32(c + 16, c4);
-    vst1q_f32(c + 20, c5);
-    vst1q_f32(c + 24, c6);
-}
-
-#if CV_NEON_AARCH64 && defined(__ARM_FEATURE_FP16_VECTOR_ARITHMETIC)
-// Fix conflict between float16_t in arm_neon.h and float16_t in cvdef.h.
-typedef __fp16 float16_t;
-
-#ifndef __ARM_FEATURE_FMA // Work around without FMA support.
-#define vfmaq_f16(a, b, c) (a + b * c)
-#endif
-void convBlock_FP16(int np, const char * _a, const char * _b, char * _c, int ldc, bool init_c, int width,
-                    const int convMR_fp16, const int convNR_fp16)
-{
-#if 1
-    const float16_t* a = (const float16_t*)_a;
-    const float16_t* b = (const float16_t*)_b;
-    float16_t* c = (float16_t*)_c;
-
-    CV_Assert(convMR_fp16 == 8 && convNR_fp16 == 24);
-
-    float16x8_t c00 = vdupq_n_f16(0), c01 = c00, c02 = c00;
-    float16x8_t c10 = c00, c11 = c00, c12 = c00;
-    float16x8_t c20 = c00, c21 = c00, c22 = c00;
-    float16x8_t c30 = c00, c31 = c00, c32 = c00;
-    float16x8_t c40 = c00, c41 = c00, c42 = c00;
-    float16x8_t c50 = c00, c51 = c00, c52 = c00;
-    float16x8_t c60 = c00, c61 = c00, c62 = c00;
-    float16x8_t c70 = c00, c71 = c00, c72 = c00;
-
-    float16x8_t b0 = c00, b1 = c00, b2 = c00;
-
-    if (width > 16)
-    {
-        for (int p = 0; p < np; p++, a += convMR_fp16, b += convNR_fp16)
-        {
-            float16x4_t a0 = vld1_f16(a), a1 = vld1_f16(a + 4);
-            b0 = vld1q_f16(b), b1 = vld1q_f16(b + 8), b2 = vld1q_f16(b + 16);
-
-            c00 = vfmaq_lane_f16(c00, b0, a0, 0);
-            c01 = vfmaq_lane_f16(c01, b1, a0, 0);
-            c02 = vfmaq_lane_f16(c02, b2, a0, 0);
-
-            c10 = vfmaq_lane_f16(c10, b0, a0, 1);
-            c11 = vfmaq_lane_f16(c11, b1, a0, 1);
-            c12 = vfmaq_lane_f16(c12, b2, a0, 1);
-
-            c20 = vfmaq_lane_f16(c20, b0, a0, 2);
-            c21 = vfmaq_lane_f16(c21, b1, a0, 2);
-            c22 = vfmaq_lane_f16(c22, b2, a0, 2);
-
-            c30 = vfmaq_lane_f16(c30, b0, a0, 3);
-            c31 = vfmaq_lane_f16(c31, b1, a0, 3);
-            c32 = vfmaq_lane_f16(c32, b2, a0, 3);
-
-            c40 = vfmaq_lane_f16(c40, b0, a1, 0);
-            c41 = vfmaq_lane_f16(c41, b1, a1, 0);
-            c42 = vfmaq_lane_f16(c42, b2, a1, 0);
-
-            c50 = vfmaq_lane_f16(c50, b0, a1, 1);
-            c51 = vfmaq_lane_f16(c51, b1, a1, 1);
-            c52 = vfmaq_lane_f16(c52, b2, a1, 1);
-
-            c60 = vfmaq_lane_f16(c60, b0, a1, 2);
-            c61 = vfmaq_lane_f16(c61, b1, a1, 2);
-            c62 = vfmaq_lane_f16(c62, b2, a1, 2);
-
-            c70 = vfmaq_lane_f16(c70, b0, a1, 3);
-            c71 = vfmaq_lane_f16(c71, b1, a1, 3);
-            c72 = vfmaq_lane_f16(c72, b2, a1, 3);
-        }
-    }
-    else if (width > 8)
-    {
-        for( int p = 0; p < np; p++, a += convMR_fp16, b += convNR_fp16)
-        {
-            float16x4_t a0 = vld1_f16(a), a1 = vld1_f16(a + 4);
-            float16x8_t b0 = vld1q_f16(b), b1 = vld1q_f16(b + 8);
-
-            c00 = vfmaq_lane_f16(c00, b0, a0, 0);
-            c01 = vfmaq_lane_f16(c01, b1, a0, 0);
-
-            c10 = vfmaq_lane_f16(c10, b0, a0, 1);
-            c11 = vfmaq_lane_f16(c11, b1, a0, 1);
-
-            c20 = vfmaq_lane_f16(c20, b0, a0, 2);
-            c21 = vfmaq_lane_f16(c21, b1, a0, 2);
-
-            c30 = vfmaq_lane_f16(c30, b0, a0, 3);
-            c31 = vfmaq_lane_f16(c31, b1, a0, 3);
-
-            c40 = vfmaq_lane_f16(c40, b0, a1, 0);
-            c41 = vfmaq_lane_f16(c41, b1, a1, 0);
-
-            c50 = vfmaq_lane_f16(c50, b0, a1, 1);
-            c51 = vfmaq_lane_f16(c51, b1, a1, 1);
-
-            c60 = vfmaq_lane_f16(c60, b0, a1, 2);
-            c61 = vfmaq_lane_f16(c61, b1, a1, 2);
-
-            c70 = vfmaq_lane_f16(c70, b0, a1, 3);
-            c71 = vfmaq_lane_f16(c71, b1, a1, 3);
-        }
-    }
-    else
-    {
-        for( int p = 0; p < np; p++, a += convMR_fp16, b += convNR_fp16)
-        {
-            float16x4_t a0 = vld1_f16(a), a1 = vld1_f16(a + 4);
-            float16x8_t b0 = vld1q_f16(b);
-
-            c00 = vfmaq_lane_f16(c00, b0, a0, 0);
-            c10 = vfmaq_lane_f16(c10, b0, a0, 1);
-            c20 = vfmaq_lane_f16(c20, b0, a0, 2);
-            c30 = vfmaq_lane_f16(c30, b0, a0, 3);
-            c40 = vfmaq_lane_f16(c40, b0, a1, 0);
-            c50 = vfmaq_lane_f16(c50, b0, a1, 1);
-            c60 = vfmaq_lane_f16(c60, b0, a1, 2);
-            c70 = vfmaq_lane_f16(c70, b0, a1, 3);
-        }
-    }
-
-    if (!init_c)
-    {
-#undef _FX_UPDATE_CBUF_ROW
-#define _FX_UPDATE_CBUF_ROW(row) \
-        c##row##0 = c##row##0 + vld1q_f16(c + row*ldc); \
-        c##row##1 = c##row##1 + vld1q_f16(c + row*ldc + 8); \
-        c##row##2 = c##row##2 + vld1q_f16(c + row*ldc + 16)
-
-        _FX_UPDATE_CBUF_ROW(0);
-        _FX_UPDATE_CBUF_ROW(1);
-        _FX_UPDATE_CBUF_ROW(2);
-        _FX_UPDATE_CBUF_ROW(3);
-        _FX_UPDATE_CBUF_ROW(4);
-        _FX_UPDATE_CBUF_ROW(5);
-        _FX_UPDATE_CBUF_ROW(6);
-        _FX_UPDATE_CBUF_ROW(7);
-    }
-
-#undef _FX_STORE_CBUF_ROW
-#define _FX_STORE_CBUF_ROW(row) \
-    vst1q_f16(c + row*ldc, c##row##0); \
-    vst1q_f16(c + row*ldc + 8, c##row##1); \
-    vst1q_f16(c + row*ldc + 16, c##row##2)
-
-    _FX_STORE_CBUF_ROW(0);
-    _FX_STORE_CBUF_ROW(1);
-    _FX_STORE_CBUF_ROW(2);
-    _FX_STORE_CBUF_ROW(3);
-    _FX_STORE_CBUF_ROW(4);
-    _FX_STORE_CBUF_ROW(5);
-    _FX_STORE_CBUF_ROW(6);
-    _FX_STORE_CBUF_ROW(7);
-#else
-    // reference only.
-    const float16_t* a = (const float16_t*)_a;
-    const float16_t* b = (const float16_t*)_b;
-    float16_t* c = (float16_t*)_c;
-    float cbuf[convMR_fp16*convNR_fp16];
-    memset(cbuf, 0, sizeof(cbuf));
-
-    for( int p = 0; p < np; p++ )
-    {
-        for( int i = 0; i < convMR_fp16; i++ )
-        {
-            float ai = float(a[convMR_fp16*p + i]);
-                for( int j = 0; j < convNR_fp16; j++ )
-                    cbuf[i*convNR_fp16+j] += float(b[convNR_fp16*p + j]) * ai;
-        }
-    }
-
-    if (!init_c)
-    {
-    for(int i = 0; i < convMR_fp16; i++)
-        {
-            for(int j = 0; j < convNR_fp16; j++)
-                c[i*ldc + j] = float16_t(float(c[i*ldc + j]) + cbuf[i*convNR_fp16 + j]);
-        }
-    }
-    else
-    {
-        for(int i = 0; i < convMR_fp16; i++)
-        {
-            for(int j = 0; j < convNR_fp16; j++)
-                c[i*ldc + j] = (float16_t)(cbuf[i*convNR_fp16 + j]);
-        }
-    }
-#endif
-}
-
-void convBlockMR1_FP16(int np, const char* _a, const char* _b, float *c, const float _bias, bool init_c,
-                            const float minval, const float maxval, bool ifMinMaxAct, const int width, const int convNR_FP16)
-{
-    CV_Assert(convNR_FP16 == 24); // CONV_NR_FP16 = 24
-    const float16_t* a = (const float16_t*)_a;
-    const float16_t* b = (const float16_t*)_b;
-
-    const float16_t bias = (float16_t)_bias;
-
-    float16x8_t c0 = vdupq_n_f16(bias), c1 = c0, c2 = c0;
-
-    if (width > 16)
-    {
-        for (int p = 0; p < np; p++, a++, b += convNR_FP16)
-        {
-            float16x8_t a0= vdupq_n_f16(a[0]);
-            float16x8_t b0 = vld1q_f16(b), b1 = vld1q_f16(b + 8), b2 = vld1q_f16(b + 16);
-
-            c0 = vfmaq_f16(c0, a0, b0);
-            c1 = vfmaq_f16(c1, a0, b1);
-            c2 = vfmaq_f16(c2, a0, b2);
-        }
-    }
-    else if (width > 8)
-    {
-        for (int p = 0; p < np; p++, a++, b += convNR_FP16)
-        {
-            float16x8_t a0= vdupq_n_f16(a[0]);
-            float16x8_t b0 = vld1q_f16(b), b1 = vld1q_f16(b + 8);
-
-            c0 = vfmaq_f16(c0, a0, b0);
-            c1 = vfmaq_f16(c1, a0, b1);
-        }
-    }
-    else
-    {
-        for (int p = 0; p < np; p++, a++, b += convNR_FP16)
-        {
-            float16x8_t a0= vdupq_n_f16(a[0]);
-            float16x8_t b0 = vld1q_f16(b);
-
-            c0 = vfmaq_f16(c0, a0, b0);
-        }
-    }
-
-    // convert FP 16 to FP 32.
-    float32x4_t c00 = vcvt_f32_f16(vget_low_f16(c0));
-    float32x4_t c01 = vcvt_f32_f16(vget_high_f16(c0));
-    float32x4_t c10 = vcvt_f32_f16(vget_low_f16(c1));
-    float32x4_t c11 = vcvt_f32_f16(vget_high_f16(c1));
-    float32x4_t c20 = vcvt_f32_f16(vget_low_f16(c2));
-    float32x4_t c21 = vcvt_f32_f16(vget_high_f16(c2));
-
-    if (init_c)
-    {
-        c00 += vld1q_f32(c);
-        c01 += vld1q_f32(c + 4);
-        c10 += vld1q_f32(c + 8);
-        c11 += vld1q_f32(c + 12);
-        c20 += vld1q_f32(c + 16);
-        c21 += vld1q_f32(c + 20);
-    }
-
-    if (ifMinMaxAct)
-    {
-        float32x4_t v_minval = vdupq_n_f32(minval), v_maxval = vdupq_n_f32(maxval);
-
-        c00 = vminq_f32(vmaxq_f32(c00, v_minval), v_maxval);
-        c01 = vminq_f32(vmaxq_f32(c01, v_minval), v_maxval);
-        c10 = vminq_f32(vmaxq_f32(c10, v_minval), v_maxval);
-        c11 = vminq_f32(vmaxq_f32(c11, v_minval), v_maxval);
-        c20 = vminq_f32(vmaxq_f32(c20, v_minval), v_maxval);
-        c21 = vminq_f32(vmaxq_f32(c21, v_minval), v_maxval);
-    }
-
-    vst1q_f32(c, c00);
-    vst1q_f32(c + 4, c01);
-    vst1q_f32(c + 8, c10);
-    vst1q_f32(c + 12, c11);
-    vst1q_f32(c + 16, c20);
-    vst1q_f32(c + 20, c21);
-}
-#endif
-
-#endif
-}
 }} // namespace cv::dnn
Index: libpng-src/libpng/arm/arm_init.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/arm/arm_init.c b/libpng-src/libpng/arm/arm_init.c
--- a/libpng-src/libpng/arm/arm_init.c	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/arm/arm_init.c	(date 1690795574118)
@@ -1,17 +1,16 @@
 
 /* arm_init.c - NEON optimised filter functions
  *
+ * Copyright (c) 2018-2022 Cosmin Truta
  * Copyright (c) 2014,2016 Glenn Randers-Pehrson
  * Written by Mans Rullgard, 2011.
- * Last changed in libpng 1.6.22 [May 26, 2016]
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
  * and license in png.h
  */
-/* Below, after checking __linux__, various non-C90 POSIX 1003.1 functions are
- * called.
- */
+
+/* This module requires POSIX 1003.1 functions. */
 #define _POSIX_SOURCE 1
 
 #include "../pngpriv.h"
@@ -32,21 +31,26 @@
  * has partial support is contrib/arm-neon/linux.c - a generic Linux
  * implementation which reads /proc/cpufino.
  */
+#include <signal.h> /* for sig_atomic_t */
+
 #ifndef PNG_ARM_NEON_FILE
-#  ifdef __linux__
-#     define PNG_ARM_NEON_FILE "contrib/arm-neon/linux.c"
+#  if defined(__aarch64__) || defined(_M_ARM64)
+     /* ARM Neon is expected to be unconditionally available on ARM64. */
+#    error "PNG_ARM_NEON_CHECK_SUPPORTED must not be defined on ARM64"
+#  elif defined(__ARM_NEON__) || defined(__ARM_NEON)
+     /* ARM Neon is expected to be available on the target CPU architecture. */
+#    error "PNG_ARM_NEON_CHECK_SUPPORTED must not be defined on this CPU arch"
+#  elif defined(__linux__)
+#    define PNG_ARM_NEON_FILE "contrib/arm-neon/linux.c"
+#  else
+#    error "No support for run-time ARM Neon checking; use compile-time options"
 #  endif
 #endif
 
+static int png_have_neon(png_structp png_ptr);
 #ifdef PNG_ARM_NEON_FILE
-
-#include <signal.h> /* for sig_atomic_t */
-static int png_have_neon(png_structp png_ptr);
-#include PNG_ARM_NEON_FILE
-
-#else  /* PNG_ARM_NEON_FILE */
-#  error "PNG_ARM_NEON_FILE undefined: no support for run-time ARM NEON checks"
-#endif /* PNG_ARM_NEON_FILE */
+#  include PNG_ARM_NEON_FILE
+#endif
 #endif /* PNG_ARM_NEON_CHECK_SUPPORTED */
 
 #ifndef PNG_ALIGNED_MEMORY_SUPPORTED
Index: libpng-src/libpng/arm/filter_neon_intrinsics.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/arm/filter_neon_intrinsics.c b/libpng-src/libpng/arm/filter_neon_intrinsics.c
--- a/libpng-src/libpng/arm/filter_neon_intrinsics.c	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/arm/filter_neon_intrinsics.c	(date 1690795574118)
@@ -1,12 +1,11 @@
 
 /* filter_neon_intrinsics.c - NEON optimised filter functions
  *
+ * Copyright (c) 2018 Cosmin Truta
  * Copyright (c) 2014,2016 Glenn Randers-Pehrson
  * Written by James Yu <james.yu at linaro.org>, October 2013.
  * Based on filter_neon.S, written by Mans Rullgard, 2011.
  *
- * Last changed in libpng 1.6.22 [May 26, 2016]
- *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
  * and license in png.h
@@ -19,7 +18,11 @@
 /* This code requires -mfpu=neon on the command line: */
 #if PNG_ARM_NEON_IMPLEMENTATION == 1 /* intrinsics code from pngpriv.h */
 
-#include <arm_neon.h>
+#if defined(_MSC_VER) && !defined(__clang__) && defined(_M_ARM64)
+#  include <arm64_neon.h>
+#else
+#  include <arm_neon.h>
+#endif
 
 /* libpng row pointers are not necessarily aligned to any particular boundary,
  * however this code will only work with appropriate alignment.  arm/arm_init.c
@@ -33,6 +36,11 @@
  * 'type'.  This is written this way just to hide the GCC strict aliasing
  * warning; note that the code is safe because there never is an alias between
  * the input and output pointers.
+ *
+ * When compiling with MSVC ARM64, the png_ldr macro can't be passed directly
+ * to vst4_lane_u32, because of an internal compiler error inside MSVC.
+ * To avoid this compiler bug, we use a temporary variable (vdest_val) to store
+ * the result of png_ldr.
  */
 #define png_ldr(type,pointer)\
    (temp_pointer = png_ptr(type,pointer), *temp_pointer)
@@ -125,12 +133,15 @@
       uint8x8x4_t *vrpt = png_ptr(uint8x8x4_t,&vtmp);
       uint8x8x4_t vrp = *vrpt;
       uint32x2x4_t *temp_pointer;
+      uint32x2x4_t vdest_val;
 
       vdest.val[0] = vadd_u8(vdest.val[3], vrp.val[0]);
       vdest.val[1] = vadd_u8(vdest.val[0], vrp.val[1]);
       vdest.val[2] = vadd_u8(vdest.val[1], vrp.val[2]);
       vdest.val[3] = vadd_u8(vdest.val[2], vrp.val[3]);
-      vst4_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2x4_t,&vdest), 0);
+
+      vdest_val = png_ldr(uint32x2x4_t, &vdest);
+      vst4_lane_u32(png_ptr(uint32_t,rp), vdest_val, 0);
    }
 
    PNG_UNUSED(prev_row)
@@ -223,6 +234,7 @@
       uint8x8x4_t *vrpt, *vppt;
       uint8x8x4_t vrp, vpp;
       uint32x2x4_t *temp_pointer;
+      uint32x2x4_t vdest_val;
 
       vtmp = vld4_u32(png_ptr(uint32_t,rp));
       vrpt = png_ptr(uint8x8x4_t,&vtmp);
@@ -240,7 +252,8 @@
       vdest.val[3] = vhadd_u8(vdest.val[2], vpp.val[3]);
       vdest.val[3] = vadd_u8(vdest.val[3], vrp.val[3]);
 
-      vst4_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2x4_t,&vdest), 0);
+      vdest_val = png_ldr(uint32x2x4_t, &vdest);
+      vst4_lane_u32(png_ptr(uint32_t,rp), vdest_val, 0);
    }
 }
 
@@ -359,6 +372,7 @@
       uint8x8x4_t *vrpt, *vppt;
       uint8x8x4_t vrp, vpp;
       uint32x2x4_t *temp_pointer;
+      uint32x2x4_t vdest_val;
 
       vtmp = vld4_u32(png_ptr(uint32_t,rp));
       vrpt = png_ptr(uint8x8x4_t,&vtmp);
@@ -378,7 +392,8 @@
 
       vlast = vpp.val[3];
 
-      vst4_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2x4_t,&vdest), 0);
+      vdest_val = png_ldr(uint32x2x4_t, &vdest);
+      vst4_lane_u32(png_ptr(uint32_t,rp), vdest_val, 0);
    }
 }
 
Index: rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.h b/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.h
--- a/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.h	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.h	(date 1689048276130)
@@ -36,10 +36,7 @@
 class RDKIT_MOLSTANDARDIZE_EXPORT TautomerCatalogParams
     : public RDCatalog::CatalogParams {
  public:
-  TautomerCatalogParams() {
-    d_typeStr = "Tautomer Catalog Parameters";
-    d_transforms.clear();
-  }
+  TautomerCatalogParams();
 
   TautomerCatalogParams(const std::string &tautomerFile);
   TautomerCatalogParams(const TautomerTransformDefs &data);
Index: libpng-src/libpng/arm/filter_neon.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/arm/filter_neon.S b/libpng-src/libpng/arm/filter_neon.S
--- a/libpng-src/libpng/arm/filter_neon.S	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/arm/filter_neon.S	(date 1690795574118)
@@ -1,9 +1,9 @@
 
 /* filter_neon.S - NEON optimised filter functions
  *
- * Copyright (c) 2014 Glenn Randers-Pehrson
+ * Copyright (c) 2018 Cosmin Truta
+ * Copyright (c) 2014,2017 Glenn Randers-Pehrson
  * Written by Mans Rullgard, 2011.
- * Last changed in libpng 1.6.16 [December 22, 2014]
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
@@ -16,7 +16,7 @@
 #define PNG_VERSION_INFO_ONLY
 #include "../pngpriv.h"
 
-#if defined(__linux__) && defined(__ELF__)
+#if (defined(__linux__) || defined(__FreeBSD__)) && defined(__ELF__)
 .section .note.GNU-stack,"",%progbits /* mark stack as non-executable */
 #endif
 
Index: rdkit-src/rdkit/Code/RDGeneral/RDLog.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/RDGeneral/RDLog.cpp b/rdkit-src/rdkit/Code/RDGeneral/RDLog.cpp
--- a/rdkit-src/rdkit/Code/RDGeneral/RDLog.cpp	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/RDGeneral/RDLog.cpp	(date 1690852232727)
@@ -25,9 +25,7 @@
 namespace RDLog {
 
 namespace {
-const std::vector<RDLogger *> allLogs = {&rdAppLog,     &rdDebugLog,
-                                         &rdInfoLog,    &rdErrorLog,
-                                         &rdWarningLog, &rdStatusLog};
+std::vector<RDLogger *> allLogs;
 }
 
 LogStateSetter::LogStateSetter() {
@@ -147,13 +145,18 @@
   rdInfoLog->df_enabled = false;
   rdWarningLog = std::make_shared<boost::logging::rdLogger>(&std::cerr);
   rdErrorLog = std::make_shared<boost::logging::rdLogger>(&std::cerr);
+  rdAppLog = rdInfoLog;
+  rdStatusLog = rdInfoLog;
+  allLogs = {&rdAppLog,     &rdDebugLog,
+             &rdInfoLog,    &rdErrorLog,
+             &rdWarningLog, &rdStatusLog};
 }
 
 std::ostream &toStream(std::ostream &logstrm) {
   char buffer[16];
   time_t t = time(nullptr);
 // localtime() is thread safe on windows, but not on *nix
-#ifdef WIN32
+#if defined(WIN32) || defined(__MINGW32__)
   strftime(buffer, 16, "[%T] ", localtime(&t));
 #else
   struct tm buf;
Index: libpng-src/libpng/pngstruct.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/pngstruct.h b/libpng-src/libpng/pngstruct.h
--- a/libpng-src/libpng/pngstruct.h	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/pngstruct.h	(date 1690795574122)
@@ -1,10 +1,10 @@
 
 /* pngstruct.h - header file for PNG reference library
  *
- * Last changed in libpng 1.6.24 [August 4, 2016]
- * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ * Copyright (c) 2018-2022 Cosmin Truta
+ * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson
+ * Copyright (c) 1996-1997 Andreas Dilger
+ * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
@@ -47,7 +47,7 @@
 /* zlib.h declares a magic type 'uInt' that limits the amount of data that zlib
  * can handle at once.  This type need be no larger than 16 bits (so maximum of
  * 65535), this define allows us to discover how big it is, but limited by the
- * maximuum for png_size_t.  The value can be overriden in a library build
+ * maximum for size_t.  The value can be overridden in a library build
  * (pngusr.h, or set it in CPPFLAGS) and it works to set it to a considerably
  * lower value (e.g. 255 works).  A lower value may help memory usage (slightly)
  * and may even improve performance on some systems (and degrade it on others.)
@@ -214,7 +214,7 @@
    png_uint_32 height;        /* height of image in pixels */
    png_uint_32 num_rows;      /* number of rows in current pass */
    png_uint_32 usr_width;     /* width of row at start of write */
-   png_size_t rowbytes;       /* size of row in bytes */
+   size_t rowbytes;           /* size of row in bytes */
    png_uint_32 iwidth;        /* width of current interlaced row in pixels */
    png_uint_32 row_number;    /* current row in interlace pass */
    png_uint_32 chunk_name;    /* PNG_CHUNK() id of current chunk */
@@ -232,7 +232,7 @@
    png_bytep try_row;    /* buffer to save trial row when filtering */
    png_bytep tst_row;    /* buffer to save best trial row when filtering */
 #endif
-   png_size_t info_rowbytes;  /* Added in 1.5.4: cache of updated row bytes */
+   size_t info_rowbytes;      /* Added in 1.5.4: cache of updated row bytes */
 
    png_uint_32 idat_size;     /* current IDAT size for read */
    png_uint_32 crc;           /* current chunk CRC value */
@@ -263,7 +263,7 @@
                               /* pixel depth used for the row buffers */
    png_byte transformed_pixel_depth;
                               /* pixel depth after read/write transforms */
-#if PNG_ZLIB_VERNUM >= 0x1240
+#if ZLIB_VERNUM >= 0x1240
    png_byte zstream_start;    /* at start of an input zlib stream */
 #endif /* Zlib >= 1.2.4 */
 #if defined(PNG_READ_FILLER_SUPPORTED) || defined(PNG_WRITE_FILLER_SUPPORTED)
@@ -307,7 +307,7 @@
 #endif
 
 #if defined(PNG_READ_SHIFT_SUPPORTED) || defined(PNG_WRITE_SHIFT_SUPPORTED)
-   png_color_8 shift;         /* shift for significant bit tranformation */
+   png_color_8 shift;         /* shift for significant bit transformation */
 #endif
 
 #if defined(PNG_tRNS_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED) \
@@ -328,24 +328,14 @@
    png_bytep current_buffer;         /* buffer for recently used data */
    png_uint_32 push_length;          /* size of current input chunk */
    png_uint_32 skip_length;          /* bytes to skip in input data */
-   png_size_t save_buffer_size;      /* amount of data now in save_buffer */
-   png_size_t save_buffer_max;       /* total size of save_buffer */
-   png_size_t buffer_size;           /* total amount of available input data */
-   png_size_t current_buffer_size;   /* amount of data now in current_buffer */
+   size_t save_buffer_size;          /* amount of data now in save_buffer */
+   size_t save_buffer_max;           /* total size of save_buffer */
+   size_t buffer_size;               /* total amount of available input data */
+   size_t current_buffer_size;       /* amount of data now in current_buffer */
    int process_mode;                 /* what push library is currently doing */
    int cur_palette;                  /* current push library palette index */
-
 #endif /* PROGRESSIVE_READ */
 
-#if defined(__TURBOC__) && !defined(_Windows) && !defined(__FLAT__)
-/* For the Borland special 64K segment handler */
-   png_bytepp offset_table_ptr;
-   png_bytep offset_table;
-   png_uint_16 offset_table_number;
-   png_uint_16 offset_table_count;
-   png_uint_16 offset_table_count_free;
-#endif
-
 #ifdef PNG_READ_QUANTIZE_SUPPORTED
    png_bytep palette_lookup; /* lookup table for quantizing */
    png_bytep quantize_index; /* index translation for palette files */
@@ -353,7 +343,7 @@
 
 /* Options */
 #ifdef PNG_SET_OPTION_SUPPORTED
-   png_byte options;           /* On/off state (up to 4 options) */
+   png_uint_32 options;           /* On/off state (up to 16 options) */
 #endif
 
 #if PNG_LIBPNG_VER < 10700
@@ -392,6 +382,12 @@
    /* deleted in 1.5.5: rgb_to_gray_blue_coeff; */
 #endif
 
+/* New member added in libpng-1.6.36 */
+#if defined(PNG_READ_EXPAND_SUPPORTED) && \
+    defined(PNG_ARM_NEON_IMPLEMENTATION)
+   png_bytep riffled_palette; /* buffer for accelerated palette expansion */
+#endif
+
 /* New member added in libpng-1.0.4 (renamed in 1.0.9) */
 #if defined(PNG_MNG_FEATURES_SUPPORTED)
 /* Changed from png_byte to png_uint_32 at version 1.2.0 */
@@ -451,7 +447,7 @@
 #endif
 
 /* New member added in libpng-1.2.26 */
-  png_size_t old_big_row_buf_size;
+   size_t old_big_row_buf_size;
 
 #ifdef PNG_READ_SUPPORTED
 /* New member added in libpng-1.2.30 */
Index: libpng-src/libpng/mips/filter_msa_intrinsics.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/mips/filter_msa_intrinsics.c b/libpng-src/libpng/mips/filter_msa_intrinsics.c
--- a/libpng-src/libpng/mips/filter_msa_intrinsics.c	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/mips/filter_msa_intrinsics.c	(date 1690795574118)
@@ -1,14 +1,15 @@
 
 /* filter_msa_intrinsics.c - MSA optimised filter functions
  *
+ * Copyright (c) 2018 Cosmin Truta
  * Copyright (c) 2016 Glenn Randers-Pehrson
  * Written by Mandar Sahastrabuddhe, August 2016.
- * Last changed in libpng 1.6.25 [September 1, 2016]
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
  * and license in png.h
  */
+
 #include <stdio.h>
 #include <stdint.h>
 #include "../pngpriv.h"
@@ -366,8 +367,8 @@
 void png_read_filter_row_up_msa(png_row_infop row_info, png_bytep row,
                                 png_const_bytep prev_row)
 {
-   png_size_t i, cnt, cnt16, cnt32;
-   png_size_t istop = row_info->rowbytes;
+   size_t i, cnt, cnt16, cnt32;
+   size_t istop = row_info->rowbytes;
    png_bytep rp = row;
    png_const_bytep pp = prev_row;
    v16u8 src0, src1, src2, src3, src4, src5, src6, src7;
@@ -457,8 +458,8 @@
 void png_read_filter_row_sub4_msa(png_row_infop row_info, png_bytep row,
                                   png_const_bytep prev_row)
 {
-   png_size_t count;
-   png_size_t istop = row_info->rowbytes;
+   size_t count;
+   size_t istop = row_info->rowbytes;
    png_bytep src = row;
    png_bytep nxt = row + 4;
    int32_t inp0;
@@ -496,8 +497,8 @@
 void png_read_filter_row_sub3_msa(png_row_infop row_info, png_bytep row,
                                   png_const_bytep prev_row)
 {
-   png_size_t count;
-   png_size_t istop = row_info->rowbytes;
+   size_t count;
+   size_t istop = row_info->rowbytes;
    png_bytep src = row;
    png_bytep nxt = row + 3;
    int64_t out0;
@@ -541,11 +542,11 @@
 void png_read_filter_row_avg4_msa(png_row_infop row_info, png_bytep row,
                                   png_const_bytep prev_row)
 {
-   png_size_t i;
+   size_t i;
    png_bytep src = row;
    png_bytep nxt = row;
    png_const_bytep pp = prev_row;
-   png_size_t istop = row_info->rowbytes - 4;
+   size_t istop = row_info->rowbytes - 4;
    int32_t inp0, inp1, out0;
    v16u8 src0, src1, src2, src3, src4, src5, src6, src7, src8, src9, dst0, dst1;
    v16u8 zero = { 0 };
@@ -592,11 +593,11 @@
 void png_read_filter_row_avg3_msa(png_row_infop row_info, png_bytep row,
                                   png_const_bytep prev_row)
 {
-   png_size_t i;
+   size_t i;
    png_bytep src = row;
    png_bytep nxt = row;
    png_const_bytep pp = prev_row;
-   png_size_t istop = row_info->rowbytes - 3;
+   size_t istop = row_info->rowbytes - 3;
    int64_t out0;
    int32_t inp0, inp1, out1;
    int16_t out2;
Index: libpng-src/libpng/mips/mips_init.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/mips/mips_init.c b/libpng-src/libpng/mips/mips_init.c
--- a/libpng-src/libpng/mips/mips_init.c	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/mips/mips_init.c	(date 1690795574118)
@@ -1,14 +1,15 @@
 
 /* mips_init.c - MSA optimised filter functions
  *
+ * Copyright (c) 2018 Cosmin Truta
  * Copyright (c) 2016 Glenn Randers-Pehrson
  * Written by Mandar Sahastrabuddhe, 2016.
- * Last changed in libpng 1.6.25 [September 1, 2016]
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
  * and license in png.h
  */
+
 /* Below, after checking __linux__, various non-C90 POSIX 1003.1 functions are
  * called.
  */
Index: libpng-src/libpng/arm/palette_neon_intrinsics.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/arm/palette_neon_intrinsics.c b/libpng-src/libpng/arm/palette_neon_intrinsics.c
new file mode 100644
--- /dev/null	(date 1690795574118)
+++ b/libpng-src/libpng/arm/palette_neon_intrinsics.c	(date 1690795574118)
@@ -0,0 +1,151 @@
+
+/* palette_neon_intrinsics.c - NEON optimised palette expansion functions
+ *
+ * Copyright (c) 2018-2019 Cosmin Truta
+ * Copyright (c) 2017-2018 Arm Holdings. All rights reserved.
+ * Written by Richard Townsend <Richard.Townsend@arm.com>, February 2017.
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ */
+
+#include "../pngpriv.h"
+
+#if PNG_ARM_NEON_IMPLEMENTATION == 1
+
+#if defined(_MSC_VER) && !defined(__clang__) && defined(_M_ARM64)
+#  include <arm64_neon.h>
+#else
+#  include <arm_neon.h>
+#endif
+
+/* Build an RGBA8 palette from the separate RGB and alpha palettes. */
+void
+png_riffle_palette_neon(png_structrp png_ptr)
+{
+   png_const_colorp palette = png_ptr->palette;
+   png_bytep riffled_palette = png_ptr->riffled_palette;
+   png_const_bytep trans_alpha = png_ptr->trans_alpha;
+   int num_trans = png_ptr->num_trans;
+   int i;
+
+   /* Initially black, opaque. */
+   uint8x16x4_t w = {{
+      vdupq_n_u8(0x00),
+      vdupq_n_u8(0x00),
+      vdupq_n_u8(0x00),
+      vdupq_n_u8(0xff),
+   }};
+
+   png_debug(1, "in png_riffle_palette_neon");
+
+   /* First, riffle the RGB colours into an RGBA8 palette.
+    * The alpha component is set to opaque for now.
+    */
+   for (i = 0; i < 256; i += 16)
+   {
+      uint8x16x3_t v = vld3q_u8((png_const_bytep)(palette + i));
+      w.val[0] = v.val[0];
+      w.val[1] = v.val[1];
+      w.val[2] = v.val[2];
+      vst4q_u8(riffled_palette + (i << 2), w);
+   }
+
+   /* Fix up the missing transparency values. */
+   for (i = 0; i < num_trans; i++)
+      riffled_palette[(i << 2) + 3] = trans_alpha[i];
+}
+
+/* Expands a palettized row into RGBA8. */
+int
+png_do_expand_palette_rgba8_neon(png_structrp png_ptr, png_row_infop row_info,
+    png_const_bytep row, png_bytepp ssp, png_bytepp ddp)
+{
+   png_uint_32 row_width = row_info->width;
+   const png_uint_32 *riffled_palette =
+      (const png_uint_32 *)png_ptr->riffled_palette;
+   const png_uint_32 pixels_per_chunk = 4;
+   png_uint_32 i;
+
+   png_debug(1, "in png_do_expand_palette_rgba8_neon");
+
+   PNG_UNUSED(row)
+   if (row_width < pixels_per_chunk)
+      return 0;
+
+   /* This function originally gets the last byte of the output row.
+    * The NEON part writes forward from a given position, so we have
+    * to seek this back by 4 pixels x 4 bytes.
+    */
+   *ddp = *ddp - ((pixels_per_chunk * sizeof(png_uint_32)) - 1);
+
+   for (i = 0; i < row_width; i += pixels_per_chunk)
+   {
+      uint32x4_t cur;
+      png_bytep sp = *ssp - i, dp = *ddp - (i << 2);
+      cur = vld1q_dup_u32 (riffled_palette + *(sp - 3));
+      cur = vld1q_lane_u32(riffled_palette + *(sp - 2), cur, 1);
+      cur = vld1q_lane_u32(riffled_palette + *(sp - 1), cur, 2);
+      cur = vld1q_lane_u32(riffled_palette + *(sp - 0), cur, 3);
+      vst1q_u32((void *)dp, cur);
+   }
+   if (i != row_width)
+   {
+      /* Remove the amount that wasn't processed. */
+      i -= pixels_per_chunk;
+   }
+
+   /* Decrement output pointers. */
+   *ssp = *ssp - i;
+   *ddp = *ddp - (i << 2);
+   return i;
+}
+
+/* Expands a palettized row into RGB8. */
+int
+png_do_expand_palette_rgb8_neon(png_structrp png_ptr, png_row_infop row_info,
+    png_const_bytep row, png_bytepp ssp, png_bytepp ddp)
+{
+   png_uint_32 row_width = row_info->width;
+   png_const_bytep palette = (png_const_bytep)png_ptr->palette;
+   const png_uint_32 pixels_per_chunk = 8;
+   png_uint_32 i;
+
+   png_debug(1, "in png_do_expand_palette_rgb8_neon");
+
+   PNG_UNUSED(row)
+   if (row_width <= pixels_per_chunk)
+      return 0;
+
+   /* Seeking this back by 8 pixels x 3 bytes. */
+   *ddp = *ddp - ((pixels_per_chunk * sizeof(png_color)) - 1);
+
+   for (i = 0; i < row_width; i += pixels_per_chunk)
+   {
+      uint8x8x3_t cur;
+      png_bytep sp = *ssp - i, dp = *ddp - ((i << 1) + i);
+      cur = vld3_dup_u8(palette + sizeof(png_color) * (*(sp - 7)));
+      cur = vld3_lane_u8(palette + sizeof(png_color) * (*(sp - 6)), cur, 1);
+      cur = vld3_lane_u8(palette + sizeof(png_color) * (*(sp - 5)), cur, 2);
+      cur = vld3_lane_u8(palette + sizeof(png_color) * (*(sp - 4)), cur, 3);
+      cur = vld3_lane_u8(palette + sizeof(png_color) * (*(sp - 3)), cur, 4);
+      cur = vld3_lane_u8(palette + sizeof(png_color) * (*(sp - 2)), cur, 5);
+      cur = vld3_lane_u8(palette + sizeof(png_color) * (*(sp - 1)), cur, 6);
+      cur = vld3_lane_u8(palette + sizeof(png_color) * (*(sp - 0)), cur, 7);
+      vst3_u8((void *)dp, cur);
+   }
+
+   if (i != row_width)
+   {
+      /* Remove the amount that wasn't processed. */
+      i -= pixels_per_chunk;
+   }
+
+   /* Decrement output pointers. */
+   *ssp = *ssp - i;
+   *ddp = *ddp - ((i << 1) + i);
+   return i;
+}
+
+#endif /* PNG_ARM_NEON_IMPLEMENTATION */
Index: ncnn-src/ncnn/src/modelbin.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/src/modelbin.cpp b/ncnn-src/ncnn/src/modelbin.cpp
--- a/ncnn-src/ncnn/src/modelbin.cpp	(revision 903ec7c2c9417e1ee11cb667d2198cc3607458ed)
+++ b/ncnn-src/ncnn/src/modelbin.cpp	(date 1689048275854)
@@ -92,7 +92,6 @@
 
 Mat ModelBinFromDataReader::load(int w, int type) const
 {
-    Mat m;
 
     if (type == 0)
     {
@@ -124,15 +123,6 @@
             // half-precision data
             size_t align_data_size = alignSize(w * sizeof(unsigned short), 4);
 
-            // try reference data
-            const void* refbuf = 0;
-            nread = d->dr.reference(align_data_size, &refbuf);
-            if (nread == align_data_size)
-            {
-                m = Mat::from_float16((const unsigned short*)refbuf, w);
-            }
-            else
-            {
                 std::vector<unsigned short> float16_weights;
                 float16_weights.resize(align_data_size);
                 nread = d->dr.read(&float16_weights[0], align_data_size);
@@ -142,25 +132,12 @@
                     return Mat();
                 }
 
-                m = Mat::from_float16(&float16_weights[0], w);
-            }
-
-            return m;
+                return Mat::from_float16(float16_weights.data(), w);
         }
         else if (flag_struct.tag == 0x000D4B38)
         {
             // int8 data
             size_t align_data_size = alignSize(w, 4);
-
-            // try reference data
-            const void* refbuf = 0;
-            nread = d->dr.reference(align_data_size, &refbuf);
-            if (nread == align_data_size)
-            {
-                m = Mat(w, (void*)refbuf, (size_t)1u);
-            }
-            else
-            {
                 std::vector<signed char> int8_weights;
                 int8_weights.resize(align_data_size);
                 nread = d->dr.read(&int8_weights[0], align_data_size);
@@ -170,27 +147,17 @@
                     return Mat();
                 }
 
-                m.create(w, (size_t)1u);
+                Mat m(w, (size_t)1u);
                 if (m.empty())
                     return m;
 
                 memcpy(m.data, &int8_weights[0], w);
-            }
 
             return m;
         }
         else if (flag_struct.tag == 0x0002C056)
         {
-            // try reference data
-            const void* refbuf = 0;
-            nread = d->dr.reference(w * sizeof(float), &refbuf);
-            if (nread == w * sizeof(float))
-            {
-                m = Mat(w, (void*)refbuf);
-            }
-            else
-            {
-                m.create(w);
+            Mat m(w);
                 if (m.empty())
                     return m;
 
@@ -201,17 +168,14 @@
                     NCNN_LOGE("ModelBin read weight_data failed %zd", nread);
                     return Mat();
                 }
-            }
 
             return m;
         }
-
-        if (flag != 0)
-        {
-            m.create(w);
+        Mat m(w);
             if (m.empty())
                 return m;
-
+        if (flag != 0)
+        {
             // quantized data
             float quantization_value[256];
             nread = d->dr.read(quantization_value, 256 * sizeof(float));
@@ -239,19 +203,6 @@
         }
         else if (flag_struct.f0 == 0)
         {
-            // try reference data
-            const void* refbuf = 0;
-            nread = d->dr.reference(w * sizeof(float), &refbuf);
-            if (nread == w * sizeof(float))
-            {
-                m = Mat(w, (void*)refbuf);
-            }
-            else
-            {
-                m.create(w);
-                if (m.empty())
-                    return m;
-
                 // raw data
                 nread = d->dr.read(m, w * sizeof(float));
                 if (nread != w * sizeof(float))
@@ -260,22 +211,11 @@
                     return Mat();
                 }
             }
-        }
-
         return m;
     }
     else if (type == 1)
     {
-        // try reference data
-        const void* refbuf = 0;
-        size_t nread = d->dr.reference(w * sizeof(float), &refbuf);
-        if (nread == w * sizeof(float))
-        {
-            m = Mat(w, (void*)refbuf);
-        }
-        else
-        {
-            m.create(w);
+            Mat m(w);
             if (m.empty())
                 return m;
 
@@ -286,8 +226,6 @@
                 NCNN_LOGE("ModelBin read weight_data failed %zd", nread);
                 return Mat();
             }
-        }
-
         return m;
     }
     else
Index: inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.h b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.h
--- a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.h	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.h	(date 1689048275414)
@@ -35,7 +35,7 @@
 #ifndef __INCHI_DLL_A_H__
 #define __INCHI_DLL_A_H__
 
-#include "../../../INCHI_BASE/src/ichicant.h"
+#include "ichicant.h"
 
 typedef struct tagCOMPONENT_TREAT_INFO
 {
@@ -128,25 +128,6 @@
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
 
 
-#if (defined( _WIN32 ) && defined( _MSC_VER ) && defined(BUILD_LINK_AS_DLL) )
-    /* Win32 & MS VC ++, compile and link as a DLL */
-#ifdef _USRDLL
-    /* InChI library dll */
-#define INCHI_API __declspec(dllexport)
-#define EXPIMP_TEMPLATE
-#define INCHI_DECL
-#else
-   /* calling the InChI dll program */
-#define INCHI_API __declspec(dllimport)
-#define EXPIMP_TEMPLATE extern
-#define INCHI_DECL
-#endif
-#else
-    /* create a statically linked InChI library or link to an executable */
-#define INCHI_API
-#define EXPIMP_TEMPLATE
-#define INCHI_DECL
-#endif
 
 
 
Index: boost-src/boost/libs/serialization/src/xml_wiarchive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/xml_wiarchive.cpp b/boost-src/boost/libs/serialization/src/xml_wiarchive.cpp
--- a/boost-src/boost/libs/serialization/src/xml_wiarchive.cpp	(revision 0ca603daf99888bf059c01ae1bab1b27dbc35ebe)
+++ b/boost-src/boost/libs/serialization/src/xml_wiarchive.cpp	(date 1689048275194)
@@ -17,6 +17,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/xml_wiarchive.hpp>
Index: boost-src/boost/libs/serialization/src/basic_text_woprimitive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/basic_text_woprimitive.cpp b/boost-src/boost/libs/serialization/src/basic_text_woprimitive.cpp
--- a/boost-src/boost/libs/serialization/src/basic_text_woprimitive.cpp	(revision 0ca603daf99888bf059c01ae1bab1b27dbc35ebe)
+++ b/boost-src/boost/libs/serialization/src/basic_text_woprimitive.cpp	(date 1689048275190)
@@ -20,6 +20,7 @@
 #  pragma warning (disable : 4786) // too long name, harmless warning
 #endif
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/detail/auto_link_warchive.hpp>
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.h b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.h
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.h	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.h	(date 1689048275414)
@@ -35,7 +35,7 @@
 #ifndef __IXA_MOL_H__
 #define __IXA_MOL_H__
 
-#include "../../../../INCHI_BASE/src/ixa.h"
+#include "ixa.h"
 
 typedef struct
 {
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.h b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.h
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.h	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.h	(date 1689048275414)
@@ -35,7 +35,7 @@
 #ifndef __IXA_STATUS_H__
 #define __IXA_STATUS_H__
 
-#include "../../../../INCHI_BASE/src/ixa.h"
+#include "ixa.h"
 
 void STATUS_PushMessage( IXA_STATUS_HANDLE hStatus,
                         IXA_STATUS        vSeverity,
Index: boost-src/boost/libs/serialization/src/binary_woarchive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/binary_woarchive.cpp b/boost-src/boost/libs/serialization/src/binary_woarchive.cpp
--- a/boost-src/boost/libs/serialization/src/binary_woarchive.cpp	(revision 0ca603daf99888bf059c01ae1bab1b27dbc35ebe)
+++ b/boost-src/boost/libs/serialization/src/binary_woarchive.cpp	(date 1689048275190)
@@ -14,6 +14,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/archive/binary_woarchive.hpp>
 
Index: boost-src/boost/libs/serialization/src/basic_text_wiprimitive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/basic_text_wiprimitive.cpp b/boost-src/boost/libs/serialization/src/basic_text_wiprimitive.cpp
--- a/boost-src/boost/libs/serialization/src/basic_text_wiprimitive.cpp	(revision 0ca603daf99888bf059c01ae1bab1b27dbc35ebe)
+++ b/boost-src/boost/libs/serialization/src/basic_text_wiprimitive.cpp	(date 1689048275190)
@@ -20,6 +20,7 @@
 #  pragma warning (disable : 4786) // too long name, harmless warning
 #endif
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/detail/auto_link_warchive.hpp>
Index: boost-src/boost/libs/serialization/src/text_wiarchive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/text_wiarchive.cpp b/boost-src/boost/libs/serialization/src/text_wiarchive.cpp
--- a/boost-src/boost/libs/serialization/src/text_wiarchive.cpp	(revision 0ca603daf99888bf059c01ae1bab1b27dbc35ebe)
+++ b/boost-src/boost/libs/serialization/src/text_wiarchive.cpp	(date 1689048275194)
@@ -14,6 +14,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/text_wiarchive.hpp>
Index: boost-src/boost/libs/serialization/src/text_woarchive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/text_woarchive.cpp b/boost-src/boost/libs/serialization/src/text_woarchive.cpp
--- a/boost-src/boost/libs/serialization/src/text_woarchive.cpp	(revision 0ca603daf99888bf059c01ae1bab1b27dbc35ebe)
+++ b/boost-src/boost/libs/serialization/src/text_woarchive.cpp	(date 1689048275194)
@@ -13,6 +13,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/text_woarchive.hpp>
Index: boost-src/boost/libs/serialization/src/xml_wgrammar.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/xml_wgrammar.cpp b/boost-src/boost/libs/serialization/src/xml_wgrammar.cpp
--- a/boost-src/boost/libs/serialization/src/xml_wgrammar.cpp	(revision 0ca603daf99888bf059c01ae1bab1b27dbc35ebe)
+++ b/boost-src/boost/libs/serialization/src/xml_wgrammar.cpp	(date 1689048275194)
@@ -14,6 +14,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/impl/basic_xml_grammar.hpp>
Index: ncnn-src/ncnn/src/datareader.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/src/datareader.cpp b/ncnn-src/ncnn/src/datareader.cpp
--- a/ncnn-src/ncnn/src/datareader.cpp	(revision 903ec7c2c9417e1ee11cb667d2198cc3607458ed)
+++ b/ncnn-src/ncnn/src/datareader.cpp	(date 1689048275794)
@@ -38,11 +38,6 @@
     return 0;
 }
 
-size_t DataReader::reference(size_t /*size*/, const void** /*buf*/) const
-{
-    return 0;
-}
-
 #if NCNN_STDIO
 class DataReaderFromStdioPrivate
 {
@@ -141,13 +136,6 @@
     d->mem += size;
     return size;
 }
-
-size_t DataReaderFromMemory::reference(size_t size, const void** buf) const
-{
-    *buf = d->mem;
-    d->mem += size;
-    return size;
-}
 
 #if NCNN_PLATFORM_API
 #if __ANDROID_API__ >= 9
Index: ncnn-src/ncnn/cmake/ncnn_add_shader.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/cmake/ncnn_add_shader.cmake b/ncnn-src/ncnn/cmake/ncnn_add_shader.cmake
--- a/ncnn-src/ncnn/cmake/ncnn_add_shader.cmake	(revision 903ec7c2c9417e1ee11cb667d2198cc3607458ed)
+++ b/ncnn-src/ncnn/cmake/ncnn_add_shader.cmake	(date 1689048275794)
@@ -1,14 +1,14 @@
-
+set(_CURRENT_DIR ${CMAKE_CURRENT_LIST_DIR})
 macro(ncnn_add_shader NCNN_SHADER_SRC)
     get_filename_component(NCNN_SHADER_SRC_NAME_WE ${NCNN_SHADER_SRC} NAME_WE)
-    set(NCNN_SHADER_COMP_HEADER ${CMAKE_CURRENT_BINARY_DIR}/${NCNN_SHADER_SRC_NAME_WE}.comp.hex.h)
+    set(NCNN_SHADER_COMP_HEADER ${CMAKE_CURRENT_BINARY_DIR}/generated/ncnn/include/ncnn/layer/vulkan/shader/${NCNN_SHADER_SRC_NAME_WE}.comp.hex.h)
 
     add_custom_command(
-        OUTPUT ${NCNN_SHADER_COMP_HEADER}
-        COMMAND ${CMAKE_COMMAND} -DSHADER_SRC=${NCNN_SHADER_SRC} -DSHADER_COMP_HEADER=${NCNN_SHADER_COMP_HEADER} -P "${CMAKE_CURRENT_SOURCE_DIR}/../cmake/ncnn_generate_shader_comp_header.cmake"
-        DEPENDS ${NCNN_SHADER_SRC}
-        COMMENT "Preprocessing shader source ${NCNN_SHADER_SRC_NAME_WE}.comp"
-        VERBATIM
+            OUTPUT ${NCNN_SHADER_COMP_HEADER}
+            COMMAND ${CMAKE_COMMAND} -DSHADER_SRC=${NCNN_SHADER_SRC} -DSHADER_COMP_HEADER=${NCNN_SHADER_COMP_HEADER} -P "${_CURRENT_DIR}/ncnn_generate_shader_comp_header.cmake"
+            DEPENDS ${NCNN_SHADER_SRC}
+            COMMENT "Preprocessing shader source ${NCNN_SHADER_SRC_NAME_WE}.comp"
+            VERBATIM
     )
     set_source_files_properties(${NCNN_SHADER_COMP_HEADER} PROPERTIES GENERATED TRUE)
 
Index: boost-src/boost/libs/serialization/src/xml_woarchive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/xml_woarchive.cpp b/boost-src/boost/libs/serialization/src/xml_woarchive.cpp
--- a/boost-src/boost/libs/serialization/src/xml_woarchive.cpp	(revision 0ca603daf99888bf059c01ae1bab1b27dbc35ebe)
+++ b/boost-src/boost/libs/serialization/src/xml_woarchive.cpp	(date 1689048275194)
@@ -17,6 +17,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/xml_woarchive.hpp>
Index: yaehmop-src/yaehmop/tightbind/lovlap.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/yaehmop-src/yaehmop/tightbind/lovlap.c b/yaehmop-src/yaehmop/tightbind/lovlap.c
--- a/yaehmop-src/yaehmop/tightbind/lovlap.c	(revision c81f41694bcffccf38e17a63627a862628294613)
+++ b/yaehmop-src/yaehmop/tightbind/lovlap.c	(date 1689048276198)
@@ -2,7 +2,7 @@
 Produced by gmFortran V30.59(10/26/17) on 9/17/18 at 9:45:37
 */
 #define LPROTOTYPE
-#include "fortran.h"
+#include <math.h>
 /*
 */
 void lovlap(double *strad,double *a,double *b,double *sk1,double *sk2,double *r,
Index: ncnn-src/ncnn/cmake/ncnn_add_layer.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/cmake/ncnn_add_layer.cmake b/ncnn-src/ncnn/cmake/ncnn_add_layer.cmake
--- a/ncnn-src/ncnn/cmake/ncnn_add_layer.cmake	(revision 903ec7c2c9417e1ee11cb667d2198cc3607458ed)
+++ b/ncnn-src/ncnn/cmake/ncnn_add_layer.cmake	(date 1689048275794)
@@ -1,28 +1,28 @@
-
+set(_CURRENT_DIR ${CMAKE_CURRENT_LIST_DIR})
 macro(ncnn_add_arch_opt_layer class NCNN_TARGET_ARCH_OPT NCNN_TARGET_ARCH_OPT_CFLAGS)
-    set(NCNN_${NCNN_TARGET_ARCH}_HEADER ${CMAKE_CURRENT_SOURCE_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.h)
-    set(NCNN_${NCNN_TARGET_ARCH}_SOURCE ${CMAKE_CURRENT_SOURCE_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.cpp)
+    set(NCNN_${NCNN_TARGET_ARCH}_HEADER ${_CURRENT_DIR}/../src/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.h)
+    set(NCNN_${NCNN_TARGET_ARCH}_SOURCE ${_CURRENT_DIR}/../src/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.cpp)
 
-    if(WITH_LAYER_${name} AND EXISTS ${NCNN_${NCNN_TARGET_ARCH}_HEADER} AND EXISTS ${NCNN_${NCNN_TARGET_ARCH}_SOURCE})
+    if (WITH_LAYER_${name} AND EXISTS ${NCNN_${NCNN_TARGET_ARCH}_HEADER} AND EXISTS ${NCNN_${NCNN_TARGET_ARCH}_SOURCE})
 
-        set(NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER ${CMAKE_CURRENT_BINARY_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.h)
-        set(NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE ${CMAKE_CURRENT_BINARY_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.cpp)
+        set(NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER ${CMAKE_CURRENT_BINARY_DIR}/generated/ncnn/include/ncnn/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.h)
+        set(NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE ${CMAKE_CURRENT_BINARY_DIR}/generated/ncnn/src/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.cpp)
 
         add_custom_command(
-            OUTPUT ${NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER}
-            COMMAND ${CMAKE_COMMAND} -DSRC=${NCNN_${NCNN_TARGET_ARCH}_HEADER} -DDST=${NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER} -DCLASS=${class} -P "${CMAKE_CURRENT_SOURCE_DIR}/../cmake/ncnn_generate_${NCNN_TARGET_ARCH_OPT}_source.cmake"
-            DEPENDS ${NCNN_${NCNN_TARGET_ARCH}_HEADER}
-            COMMENT "Generating source ${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.h"
-            VERBATIM
+                OUTPUT ${NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER}
+                COMMAND ${CMAKE_COMMAND} -DSRC=${NCNN_${NCNN_TARGET_ARCH}_HEADER} -DDST=${NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER} -DCLASS=${class} -P "${_CURRENT_DIR}/ncnn_generate_${NCNN_TARGET_ARCH_OPT}_source.cmake"
+                DEPENDS ${NCNN_${NCNN_TARGET_ARCH}_HEADER}
+                COMMENT "Generating source ${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.h"
+                VERBATIM
         )
         set_source_files_properties(${NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER} PROPERTIES GENERATED TRUE)
 
         add_custom_command(
-            OUTPUT ${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE}
-            COMMAND ${CMAKE_COMMAND} -DSRC=${NCNN_${NCNN_TARGET_ARCH}_SOURCE} -DDST=${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE} -DCLASS=${class} -P "${CMAKE_CURRENT_SOURCE_DIR}/../cmake/ncnn_generate_${NCNN_TARGET_ARCH_OPT}_source.cmake"
-            DEPENDS ${NCNN_${NCNN_TARGET_ARCH}_SOURCE}
-            COMMENT "Generating source ${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.cpp"
-            VERBATIM
+                OUTPUT ${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE}
+                COMMAND ${CMAKE_COMMAND} -DSRC=${NCNN_${NCNN_TARGET_ARCH}_SOURCE} -DDST=${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE} -DCLASS=${class} -P "${_CURRENT_DIR}/ncnn_generate_${NCNN_TARGET_ARCH_OPT}_source.cmake"
+                DEPENDS ${NCNN_${NCNN_TARGET_ARCH}_SOURCE}
+                COMMENT "Generating source ${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.cpp"
+                VERBATIM
         )
         set_source_files_properties(${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE} PROPERTIES GENERATED TRUE)
 
@@ -67,7 +67,7 @@
 endmacro()
 
 macro(ncnn_add_arch_opt_source class NCNN_TARGET_ARCH_OPT NCNN_TARGET_ARCH_OPT_CFLAGS)
-    set(NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE ${CMAKE_CURRENT_SOURCE_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.cpp)
+    set(NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE ${_CURRENT_DIR}/../src/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.cpp)
 
     if(WITH_LAYER_${name} AND EXISTS ${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE})
         set_source_files_properties(${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE} PROPERTIES COMPILE_FLAGS ${NCNN_TARGET_ARCH_OPT_CFLAGS})
@@ -80,9 +80,9 @@ macro(ncnn_add_layer class)
 
     # WITH_LAYER_xxx option
     if(${ARGC} EQUAL 2)
-        option(WITH_LAYER_${name} "build with layer ${name}" ${ARGV1})
+        set(WITH_LAYER_${name} ${ARGV1})
     else()
-        option(WITH_LAYER_${name} "build with layer ${name}" ON)
+        set(WITH_LAYER_${name} ON)
     endif()
 
     if(NCNN_CMAKE_VERBOSE)
@@ -90,17 +90,17 @@
     endif()
 
     if(WITH_LAYER_${name})
-        list(APPEND ncnn_SRCS ${CMAKE_CURRENT_SOURCE_DIR}/layer/${name}.cpp)
+        list(APPEND ncnn_SRCS ${_CURRENT_DIR}/../src/layer/${name}.cpp)
 
         # look for arch specific implementation and append source
         # optimized implementation for armv7, aarch64 or x86
-        set(LAYER_ARCH_SRC ${CMAKE_CURRENT_SOURCE_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.cpp)
+        set(LAYER_ARCH_SRC ${_CURRENT_DIR}/../src/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.cpp)
         if(EXISTS ${LAYER_ARCH_SRC})
             set(WITH_LAYER_${name}_${NCNN_TARGET_ARCH} 1)
             list(APPEND ncnn_SRCS ${LAYER_ARCH_SRC})
         endif()
 
-        set(LAYER_VULKAN_SRC ${CMAKE_CURRENT_SOURCE_DIR}/layer/vulkan/${name}_vulkan.cpp)
+        set(LAYER_VULKAN_SRC ${_CURRENT_DIR}/../src/layer/vulkan/${name}_vulkan.cpp)
         if(NCNN_VULKAN AND EXISTS ${LAYER_VULKAN_SRC})
             set(WITH_LAYER_${name}_vulkan 1)
             list(APPEND ncnn_SRCS ${LAYER_VULKAN_SRC})
@@ -114,7 +114,7 @@
         set(create_pipeline_content "        { int ret = ${class}::create_pipeline(opt); if (ret) return ret; }\n")
         set(destroy_pipeline_content "        { int ret = ${class}::destroy_pipeline(opt); if (ret) return ret; }\n")
 
-        source_group ("sources\\\\layers" FILES "${CMAKE_CURRENT_SOURCE_DIR}/layer/${name}.cpp")
+        source_group("sources\\\\layers" FILES "${_CURRENT_DIR}/../src/layer/${name}.cpp")
     endif()
 
     if(WITH_LAYER_${name}_vulkan)
@@ -123,14 +123,14 @@
         set(create_pipeline_content "${create_pipeline_content}        if (vkdev) { int ret = ${class}_vulkan::create_pipeline(opt); if (ret) return ret; }\n")
         set(destroy_pipeline_content "        if (vkdev) { int ret = ${class}_vulkan::destroy_pipeline(opt); if (ret) return ret; }\n${destroy_pipeline_content}")
 
-        file(GLOB_RECURSE NCNN_SHADER_SRCS "layer/vulkan/shader/${name}.comp")
-        file(GLOB_RECURSE NCNN_SHADER_SUBSRCS "layer/vulkan/shader/${name}_*.comp")
+        file(GLOB_RECURSE NCNN_SHADER_SRCS "${_CURRENT_DIR}/../src/layer/vulkan/shader/${name}.comp")
+        file(GLOB_RECURSE NCNN_SHADER_SUBSRCS "${_CURRENT_DIR}/../src/layer/vulkan/shader/${name}_*.comp")
         list(APPEND NCNN_SHADER_SRCS ${NCNN_SHADER_SUBSRCS})
-        foreach(NCNN_SHADER_SRC ${NCNN_SHADER_SRCS})
+        foreach (NCNN_SHADER_SRC ${NCNN_SHADER_SRCS})
             ncnn_add_shader(${NCNN_SHADER_SRC})
-        endforeach()
+        endforeach ()
 
-        source_group ("sources\\\\layers\\\\vulkan" FILES "${CMAKE_CURRENT_SOURCE_DIR}/layer/vulkan/${name}_vulkan.cpp")
+        source_group("sources\\\\layers\\\\vulkan" FILES "${_CURRENT_DIR}/../src/layer/vulkan/${name}_vulkan.cpp")
     endif()
 
     if(WITH_LAYER_${name}_${NCNN_TARGET_ARCH})
@@ -139,7 +139,7 @@
         set(create_pipeline_content "${create_pipeline_content}        { int ret = ${class}_${NCNN_TARGET_ARCH}::create_pipeline(opt); if (ret) return ret; }\n")
         set(destroy_pipeline_content "        { int ret = ${class}_${NCNN_TARGET_ARCH}::destroy_pipeline(opt); if (ret) return ret; }\n${destroy_pipeline_content}")
 
-        source_group ("sources\\\\layers\\\\${NCNN_TARGET_ARCH}" FILES "${CMAKE_CURRENT_SOURCE_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.cpp")
+        source_group("sources\\\\layers\\\\${NCNN_TARGET_ARCH}" FILES "${_CURRENT_DIR}/../src/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.cpp")
     endif()
 
     if(WITH_LAYER_${name})
Index: cairo-src/cairo/boilerplate/cairo-boilerplate.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cairo-src/cairo/boilerplate/cairo-boilerplate.c b/cairo-src/cairo/boilerplate/cairo-boilerplate.c
--- a/cairo-src/cairo/boilerplate/cairo-boilerplate.c	(revision c3b672634f0635af1ad0ffa8c15b34fc7c1035cf)
+++ b/cairo-src/cairo/boilerplate/cairo-boilerplate.c	(date 1689048275286)
@@ -498,6 +498,10 @@
 #endif
 }
 
+void
+_cairo_boilerplate_register_all (void)
+{}
+
 void
 _cairo_boilerplate_register_backend (const cairo_boilerplate_target_t *targets,
 				     unsigned int		       count)
Index: yaehmop-src/yaehmop/tightbind/postprocess.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/yaehmop-src/yaehmop/tightbind/postprocess.c b/yaehmop-src/yaehmop/tightbind/postprocess.c
--- a/yaehmop-src/yaehmop/tightbind/postprocess.c	(revision c81f41694bcffccf38e17a63627a862628294613)
+++ b/yaehmop-src/yaehmop/tightbind/postprocess.c	(date 1689048276198)
@@ -739,7 +739,7 @@
 
     /* this stores the reduced charge matrix */
     if( details->Rchg_mat_PRT ){
-      reduced_charge_mat(cell->num_atoms,num_orbs,orbital_lookup_table,
+      reduced_charge_matrix(cell->num_atoms,num_orbs,orbital_lookup_table,
                        properties->chg_mat,properties->Rchg_mat);
     }
 
Index: boost-src/boost/libs/serialization/src/binary_wiarchive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/binary_wiarchive.cpp b/boost-src/boost/libs/serialization/src/binary_wiarchive.cpp
--- a/boost-src/boost/libs/serialization/src/binary_wiarchive.cpp	(revision 0ca603daf99888bf059c01ae1bab1b27dbc35ebe)
+++ b/boost-src/boost/libs/serialization/src/binary_wiarchive.cpp	(date 1689048275190)
@@ -14,6 +14,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/archive/binary_wiarchive.hpp>
 #include <boost/archive/detail/archive_serializer_map.hpp>
Index: yaehmop-src/yaehmop/tightbind/abfns.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/yaehmop-src/yaehmop/tightbind/abfns.c b/yaehmop-src/yaehmop/tightbind/abfns.c
--- a/yaehmop-src/yaehmop/tightbind/abfns.c	(revision c81f41694bcffccf38e17a63627a862628294613)
+++ b/yaehmop-src/yaehmop/tightbind/abfns.c	(date 1689048276194)
@@ -2,7 +2,15 @@
 Produced by gmFortran V30.59(10/26/17) on 9/17/18 at 9:45:37
 */
 #define LPROTOTYPE
-#include "fortran.h"
+#include <math.h>
+#include <stdlib.h>
+#ifndef min
+#define min(x, y) ({				\
+	typeof(x) _min1 = (x);			\
+	typeof(y) _min2 = (y);			\
+	(void) (&_min1 == &_min2);		\
+	_min1 < _min2 ? _min1 : _min2; })
+#endif
 /*
 */
 void abfns(double *a,double *b,double *sk1,double *sk2,double *rr,int *l1,
@@ -55,7 +63,7 @@
     }
     ix = j;
     ir = fabs(2.e0*rho2);
-    is = fifmin0(ir+1,19);
+    is = min(ir+1,19);
     if(rho2 == 0) goto S35;
     d = exp(rho2);
     h = 1.e0/d;
Index: boost-src/boost/libs/serialization/src/codecvt_null.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/codecvt_null.cpp b/boost-src/boost/libs/serialization/src/codecvt_null.cpp
--- a/boost-src/boost/libs/serialization/src/codecvt_null.cpp	(revision 0ca603daf99888bf059c01ae1bab1b27dbc35ebe)
+++ b/boost-src/boost/libs/serialization/src/codecvt_null.cpp	(date 1689048275194)
@@ -7,6 +7,7 @@
 // License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
 // http://www.boost.org/LICENSE_1_0.txt)
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/codecvt_null.hpp>
Index: openbabel-src/openbabel/src/builder.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/builder.cpp b/openbabel-src/openbabel/src/builder.cpp
--- a/openbabel-src/openbabel/src/builder.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/builder.cpp	(date 1689048275862)
@@ -97,7 +97,7 @@
 
   void OBBuilder::LoadFragments()  {
     // open data/fragments.txt
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "rigid-fragments-index.txt").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open ring-fragments-index.txt", obError);
       return;
@@ -171,7 +171,7 @@
       return coords;
     }
 
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "rigid-fragments.txt").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open rigid-fragments.txt", obError);
       return coords;
Index: rdkit-src/rdkit/Code/GraphMol/SubstructLibrary/SubstructLibrary.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/SubstructLibrary/SubstructLibrary.h b/rdkit-src/rdkit/Code/GraphMol/SubstructLibrary/SubstructLibrary.h
--- a/rdkit-src/rdkit/Code/GraphMol/SubstructLibrary/SubstructLibrary.h	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/GraphMol/SubstructLibrary/SubstructLibrary.h	(date 1689048276138)
@@ -412,7 +412,7 @@
       const std::vector<unsigned int> &indices) const override {
     std::vector<std::string> res;
     std::transform(indices.begin(), indices.end(), std::back_inserter(res),
-                   [=](unsigned idx) { return keys.at(idx); });
+                   [=, this](unsigned idx) { return keys.at(idx); });
     return res;
   }
   unsigned int size() const override { return keys.size(); }
Index: openbabel-src/openbabel/src/rotor.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/rotor.cpp b/openbabel-src/openbabel/src/rotor.cpp
--- a/openbabel-src/openbabel/src/rotor.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/rotor.cpp	(date 1689048275890)
@@ -31,8 +31,6 @@
 #include <set>
 #include <assert.h>
 
-// private data headers with default parameters
-#include "torlib.h"
 
 #ifndef M_PI
 #define M_PI 3.14159265358979323846
@@ -806,7 +804,7 @@
     _envvar = "BABEL_DATADIR";
     _filename = "torlib.txt";
     _subdir = "data";
-    _dataptr = TorsionDefaults;
+    _dataptr = nullptr;
   }
 
   void OBRotorRules::ParseLine(const char *buffer)
Index: openbabel-src/openbabel/src/format.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/format.cpp b/openbabel-src/openbabel/src/format.cpp
--- a/openbabel-src/openbabel/src/format.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/format.cpp	(date 1689048275866)
@@ -23,11 +23,6 @@
 using namespace std;
 namespace OpenBabel
 {
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-  // macro to implement static OBPlugin::PluginMapType& Map()
-  PLUGIN_CPP_FILE(OBFormat)
-#endif
-
 int OBFormat::RegisterFormat(const char* ID, const char* MIME)
 {
   GetMap()[ID] = this;
Index: libxml2-src/libxml2/include/libxml/xmlexports.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libxml2-src/libxml2/include/libxml/xmlexports.h b/libxml2-src/libxml2/include/libxml/xmlexports.h
--- a/libxml2-src/libxml2/include/libxml/xmlexports.h	(revision 2e9f7860a9cb8be29eca90b7409ef0278d30ef10)
+++ b/libxml2-src/libxml2/include/libxml/xmlexports.h	(date 1690938866074)
@@ -8,18 +8,11 @@
 #ifndef __XML_EXPORTS_H__
 #define __XML_EXPORTS_H__
 
-/** DOC_DISABLE */
-#if defined(_WIN32) || defined(__CYGWIN__)
-  #ifdef LIBXML_STATIC
-    #define XMLPUBLIC
-  #elif defined(IN_LIBXML)
-    #define XMLPUBLIC __declspec(dllexport)
-  #else
-    #define XMLPUBLIC __declspec(dllimport)
-  #endif
-#else /* not Windows */
-  #define XMLPUBLIC
-#endif /* platform switch */
+#include "xml2_export.h"
+#ifndef XMLPUBLIC
+#define XMLPUBLIC XML2_EXPORT
+#endif
+
 /** DOC_ENABLE */
 
 /*
Index: openbabel-src/openbabel/src/confsearch.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/confsearch.cpp b/openbabel-src/openbabel/src/confsearch.cpp
--- a/openbabel-src/openbabel/src/confsearch.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/confsearch.cpp	(date 1689048275866)
@@ -131,7 +131,7 @@
 
     const double arr[] = {3.0, 2.0, 1.5, 1.0, 0.5, 0.25};
     std::vector<double> vec (arr, arr + sizeof(arr) / sizeof(arr[0]) );
-    vec.erase(std::remove_if(vec.begin(), vec.end(), std::bind2nd(std::less<double>(), (cutoff + 0.1) )), vec.end());
+    vec.erase(std::remove_if(vec.begin(), vec.end(), std::bind(std::less<double>(), std::placeholders::_1, (cutoff + 0.1) )), vec.end());
     vec.push_back(cutoff);
 
     levels = vec;
@@ -293,7 +293,7 @@
   std::vector <OBDiversePoses::PosePair> confs, newconfs;
 
   // The leaf iterator will (in effect) iterate over the nodes just at the loweset level
-  for (OBDiversePoses::Tree::leaf_iterator node = poses->begin(); node != poses->end(); ++node)
+  for (auto node = poses->begin(); node != poses->end(); ++node)
     if (node->first.size() > 0) // Don't include the dummy head node
       confs.push_back(*node);
 
@@ -441,7 +441,7 @@
     UpdateConformersFromTree(&_mol, _energies, &divposes, verbose);
 
     // Add back the energy offset
-    transform(_energies.begin(), _energies.end(), _energies.begin(), bind2nd(std::plus<double>(), energy_offset));
+    transform(_energies.begin(), _energies.end(), _energies.begin(), std::bind(std::plus<double>(), std::placeholders::_1, energy_offset));
 
     // Clean up
     delete [] store_initial;
Index: indigo-src/indigo/api/c/indigo/indigo.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/indigo.h b/indigo-src/indigo/api/c/indigo/indigo.h
--- a/indigo-src/indigo/api/c/indigo/indigo.h	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/indigo.h	(date 1690938866070)
@@ -20,36 +20,22 @@
 #define __indigo__
 
 #include <stdint.h>
+#include "indigo_export.h"
 
 #if defined(_WIN32) && !defined(__MINGW32__)
 #define qword unsigned __int64
 #else
 #define qword unsigned long long
 #endif
-
-#ifndef EXPORT_SYMBOL
-#ifdef _WIN32
-#define EXPORT_SYMBOL __declspec(dllexport)
-#elif (defined __GNUC__ || defined __APPLE__)
-#define EXPORT_SYMBOL __attribute__((visibility("default")))
-#else
-#define EXPORT_SYMBOL
-#endif
-#endif
-
-#ifndef CEXPORT
-#ifndef __cplusplus
-#define CEXPORT EXPORT_SYMBOL
-#else
-#define CEXPORT extern "C" EXPORT_SYMBOL
-#endif
-#endif
 
 #ifndef __byte_typedef__
 #define __byte_typedef__
 typedef unsigned char byte;
 #endif
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 /* All integer and float functions return -1 on error. */
 /* All string functions return zero pointer on error. */
 
@@ -58,54 +44,54 @@
 
 /* System */
 
-CEXPORT const char* indigoVersion();
+INDIGO_EXPORT const char *indigoVersion();
 
 // Allocate a new session. Each session has its own
 // set of objects created and options set up.
-CEXPORT qword indigoAllocSessionId();
+INDIGO_EXPORT qword indigoAllocSessionId();
 // Switch to another session. The session, if was not allocated
 // previously, is allocated automatically and initialized with
 // empty set of objects and default options.
-CEXPORT void indigoSetSessionId(qword id);
+INDIGO_EXPORT void indigoSetSessionId(qword id);
 // Release session. The memory used by the released session
 // is not freed, but the number will be reused on
 // further allocations.
-CEXPORT void indigoReleaseSessionId(qword id);
+INDIGO_EXPORT void indigoReleaseSessionId(qword id);
 
 // Get the last error message
-CEXPORT const char* indigoGetLastError(void);
+INDIGO_EXPORT const char *indigoGetLastError(void);
 
-typedef void (*INDIGO_ERROR_HANDLER)(const char* message, void* context);
-CEXPORT void indigoSetErrorHandler(INDIGO_ERROR_HANDLER handler, void* context);
+typedef void (*INDIGO_ERROR_HANDLER)(const char *message, void *context);
+INDIGO_EXPORT void indigoSetErrorHandler(INDIGO_ERROR_HANDLER handler, void *context);
 
 // Free an object
-CEXPORT int indigoFree(int handle);
+INDIGO_EXPORT int indigoFree(int handle);
 // Clone an object
-CEXPORT int indigoClone(int object);
+INDIGO_EXPORT int indigoClone(int object);
 // Count object currently allocated
-CEXPORT int indigoCountReferences(void);
+INDIGO_EXPORT int indigoCountReferences(void);
 
 // Deallocate all the objects in the current session
-CEXPORT int indigoFreeAllObjects();
+INDIGO_EXPORT int indigoFreeAllObjects();
 
 /* Options */
 
-CEXPORT int indigoSetOption(const char* name, const char* value);
-CEXPORT int indigoSetOptionInt(const char* name, int value);
-CEXPORT int indigoSetOptionBool(const char* name, int value);
-CEXPORT int indigoSetOptionFloat(const char* name, float value);
-CEXPORT int indigoSetOptionColor(const char* name, float r, float g, float b);
-CEXPORT int indigoSetOptionXY(const char* name, int x, int y);
-CEXPORT int indigoResetOptions();
+INDIGO_EXPORT int indigoSetOption(const char *name, const char *value);
+INDIGO_EXPORT int indigoSetOptionInt(const char *name, int value);
+INDIGO_EXPORT int indigoSetOptionBool(const char *name, int value);
+INDIGO_EXPORT int indigoSetOptionFloat(const char *name, float value);
+INDIGO_EXPORT int indigoSetOptionColor(const char *name, float r, float g, float b);
+INDIGO_EXPORT int indigoSetOptionXY(const char *name, int x, int y);
+INDIGO_EXPORT int indigoResetOptions();
 
-CEXPORT const char* indigoGetOption(const char* name);
-CEXPORT int indigoGetOptionInt(const char* name, int* value);
-CEXPORT int indigoGetOptionBool(const char* name, int* value);
-CEXPORT int indigoGetOptionFloat(const char* name, float* value);
-CEXPORT int indigoGetOptionColor(const char* name, float* r, float* g, float* b);
-CEXPORT int indigoGetOptionXY(const char* name, int* x, int* y);
+INDIGO_EXPORT const char *indigoGetOption(const char *name);
+INDIGO_EXPORT int indigoGetOptionInt(const char *name, int *value);
+INDIGO_EXPORT int indigoGetOptionBool(const char *name, int *value);
+INDIGO_EXPORT int indigoGetOptionFloat(const char *name, float *value);
+INDIGO_EXPORT int indigoGetOptionColor(const char *name, float *r, float *g, float *b);
+INDIGO_EXPORT int indigoGetOptionXY(const char *name, int *x, int *y);
 
-CEXPORT const char* indigoGetOptionType(const char* name);
+INDIGO_EXPORT const char *indigoGetOptionType(const char *name);
 
 /* Basic input-output */
 
@@ -115,19 +101,19 @@
 // string/buffer. All these functions are low-level and
 // rarely needed to anyone.
 
-CEXPORT int indigoReadFile(const char* filename);
-CEXPORT int indigoReadString(const char* str);
-CEXPORT int indigoLoadString(const char* str);
-CEXPORT int indigoReadBuffer(const char* buffer, int size);
-CEXPORT int indigoLoadBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoReadFile(const char *filename);
+INDIGO_EXPORT int indigoReadString(const char *str);
+INDIGO_EXPORT int indigoLoadString(const char *str);
+INDIGO_EXPORT int indigoReadBuffer(const char *buffer, int size);
+INDIGO_EXPORT int indigoLoadBuffer(const char *buffer, int size);
 
 // indigoWrite*** return a new writer object.
 
-CEXPORT int indigoWriteFile(const char* filename);
-CEXPORT int indigoWriteBuffer(void);
+INDIGO_EXPORT int indigoWriteFile(const char *filename);
+INDIGO_EXPORT int indigoWriteBuffer(void);
 
 // Closes the file output stream but does not delete the object
-CEXPORT int indigoClose(int output);
+INDIGO_EXPORT int indigoClose(int output);
 
 /* Iterators */
 
@@ -159,68 +145,68 @@
  */
 
 // Obtains the next element, returns zero if there is no next element
-CEXPORT int indigoNext(int iter);
+INDIGO_EXPORT int indigoNext(int iter);
 // Does not obtain the next element, just tells if there is one
-CEXPORT int indigoHasNext(int iter);
+INDIGO_EXPORT int indigoHasNext(int iter);
 // Returns the index of the element
-CEXPORT int indigoIndex(int item);
+INDIGO_EXPORT int indigoIndex(int item);
 
 // Removes the item from its container (usually a molecule)
-CEXPORT int indigoRemove(int item);
+INDIGO_EXPORT int indigoRemove(int item);
 
 /* Molecules, query molecules, SMARTS */
 
-CEXPORT int indigoCreateMolecule(void);
-CEXPORT int indigoCreateQueryMolecule(void);
+INDIGO_EXPORT int indigoCreateMolecule(void);
+INDIGO_EXPORT int indigoCreateQueryMolecule(void);
 
-CEXPORT int indigoLoadStructureFromString(const char* string, const char* params);
-CEXPORT int indigoLoadStructureFromBuffer(const byte* string, int bufferSize, const char* params);
-CEXPORT int indigoLoadStructureFromFile(const char* filename, const char* params);
+INDIGO_EXPORT int indigoLoadStructureFromString(const char *string, const char *params);
+INDIGO_EXPORT int indigoLoadStructureFromBuffer(const byte *string, int bufferSize, const char *params);
+INDIGO_EXPORT int indigoLoadStructureFromFile(const char *filename, const char *params);
 
-CEXPORT int indigoLoadMolecule(int source);
-CEXPORT int indigoLoadMoleculeFromString(const char* string);
-CEXPORT int indigoLoadMoleculeFromFile(const char* filename);
-CEXPORT int indigoLoadMoleculeFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadMolecule(int source);
+INDIGO_EXPORT int indigoLoadMoleculeFromString(const char *string);
+INDIGO_EXPORT int indigoLoadMoleculeFromFile(const char *filename);
+INDIGO_EXPORT int indigoLoadMoleculeFromBuffer(const char *buffer, int size);
 
-CEXPORT int indigoLoadQueryMolecule(int source);
-CEXPORT int indigoLoadQueryMoleculeFromString(const char* string);
-CEXPORT int indigoLoadQueryMoleculeFromFile(const char* filename);
-CEXPORT int indigoLoadQueryMoleculeFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadQueryMolecule(int source);
+INDIGO_EXPORT int indigoLoadQueryMoleculeFromString(const char *string);
+INDIGO_EXPORT int indigoLoadQueryMoleculeFromFile(const char *filename);
+INDIGO_EXPORT int indigoLoadQueryMoleculeFromBuffer(const char *buffer, int size);
 
-CEXPORT int indigoLoadSmarts(int source);
-CEXPORT int indigoLoadSmartsFromString(const char* string);
-CEXPORT int indigoLoadSmartsFromFile(const char* filename);
-CEXPORT int indigoLoadSmartsFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadSmarts(int source);
+INDIGO_EXPORT int indigoLoadSmartsFromString(const char *string);
+INDIGO_EXPORT int indigoLoadSmartsFromFile(const char *filename);
+INDIGO_EXPORT int indigoLoadSmartsFromBuffer(const char *buffer, int size);
 
-CEXPORT int indigoSaveMolfile(int molecule, int output);
-CEXPORT int indigoSaveMolfileToFile(int molecule, const char* filename);
-CEXPORT const char* indigoMolfile(int molecule);
+INDIGO_EXPORT int indigoSaveMolfile(int molecule, int output);
+INDIGO_EXPORT int indigoSaveMolfileToFile(int molecule, const char *filename);
+INDIGO_EXPORT const char *indigoMolfile(int molecule);
 
-CEXPORT int indigoSaveJsonToFile(int item, const char* filename);
-CEXPORT int indigoSaveJson(int item, int output);
+INDIGO_EXPORT int indigoSaveJsonToFile(int item, const char *filename);
+INDIGO_EXPORT int indigoSaveJson(int item, int output);
 
 // accepts molecules and reactions (but not query ones)
-CEXPORT int indigoSaveCml(int object, int output);
-CEXPORT int indigoSaveCmlToFile(int object, const char* filename);
-CEXPORT const char* indigoCml(int object);
-CEXPORT const char* indigoCdxBase64(int object);
+INDIGO_EXPORT int indigoSaveCml(int object, int output);
+INDIGO_EXPORT int indigoSaveCmlToFile(int object, const char *filename);
+INDIGO_EXPORT const char *indigoCml(int object);
+INDIGO_EXPORT const char *indigoCdxBase64(int object);
 
 // accepts molecules and reactions
-CEXPORT int indigoSaveCdxml(int object, int output);
-CEXPORT int indigoSaveCdx(int item, int output);
+INDIGO_EXPORT int indigoSaveCdxml(int object, int output);
+INDIGO_EXPORT int indigoSaveCdx(int item, int output);
 
-CEXPORT const char* indigoCdxml(int item);
+INDIGO_EXPORT const char *indigoCdxml(int item);
 
-CEXPORT int indigoSaveCdxmlToFile(int object, const char* filename);
-CEXPORT int indigoSaveCdxToFile(int item, const char* filename);
+INDIGO_EXPORT int indigoSaveCdxmlToFile(int object, const char *filename);
+INDIGO_EXPORT int indigoSaveCdxToFile(int item, const char *filename);
 
-CEXPORT const char* indigoCdxml(int object);
+INDIGO_EXPORT const char *indigoCdxml(int object);
 
 // the output must be a file or a buffer, but not a string
 // (because MDLCT data usually contains zeroes)
-CEXPORT int indigoSaveMDLCT(int item, int output);
+INDIGO_EXPORT int indigoSaveMDLCT(int item, int output);
 
-CEXPORT const char* indigoJson(int object);
+INDIGO_EXPORT const char *indigoJson(int object);
 
 /*
 Converts a chemical name into a corresponding structure
@@ -229,14 +215,13 @@
    name - a name to parse
    params - a string containing parsing options or nullptr if no options are changed
 */
-CEXPORT int indigoNameToStructure(const char* name, const char* params);
+INDIGO_EXPORT int indigoNameToStructure(const char *name, const char *params);
 
 /* Reactions, query reactions */
 /*
  * Reaction centers
  */
-enum
-{
+enum {
     INDIGO_RC_NOT_CENTER = -1,
     INDIGO_RC_UNMARKED = 0,
     INDIGO_RC_CENTER = 1,
@@ -244,66 +229,66 @@
     INDIGO_RC_MADE_OR_BROKEN = 4,
     INDIGO_RC_ORDER_CHANGED = 8
 };
-CEXPORT int indigoLoadReaction(int source);
-CEXPORT int indigoLoadReactionFromString(const char* string);
-CEXPORT int indigoLoadReactionFromFile(const char* filename);
-CEXPORT int indigoLoadReactionFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadReaction(int source);
+INDIGO_EXPORT int indigoLoadReactionFromString(const char *string);
+INDIGO_EXPORT int indigoLoadReactionFromFile(const char *filename);
+INDIGO_EXPORT int indigoLoadReactionFromBuffer(const char *buffer, int size);
 
-CEXPORT int indigoLoadQueryReaction(int source);
-CEXPORT int indigoLoadQueryReactionFromString(const char* string);
-CEXPORT int indigoLoadQueryReactionFromFile(const char* filename);
-CEXPORT int indigoLoadQueryReactionFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadQueryReaction(int source);
+INDIGO_EXPORT int indigoLoadQueryReactionFromString(const char *string);
+INDIGO_EXPORT int indigoLoadQueryReactionFromFile(const char *filename);
+INDIGO_EXPORT int indigoLoadQueryReactionFromBuffer(const char *buffer, int size);
 
-CEXPORT int indigoLoadReactionSmarts(int source);
-CEXPORT int indigoLoadReactionSmartsFromString(const char* string);
-CEXPORT int indigoLoadReactionSmartsFromFile(const char* filename);
-CEXPORT int indigoLoadReactionSmartsFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadReactionSmarts(int source);
+INDIGO_EXPORT int indigoLoadReactionSmartsFromString(const char *string);
+INDIGO_EXPORT int indigoLoadReactionSmartsFromFile(const char *filename);
+INDIGO_EXPORT int indigoLoadReactionSmartsFromBuffer(const char *buffer, int size);
 
-CEXPORT int indigoCreateReaction(void);
-CEXPORT int indigoCreateQueryReaction(void);
+INDIGO_EXPORT int indigoCreateReaction(void);
+INDIGO_EXPORT int indigoCreateQueryReaction(void);
 
-CEXPORT int indigoAddReactant(int reaction, int molecule);
-CEXPORT int indigoAddProduct(int reaction, int molecule);
-CEXPORT int indigoAddCatalyst(int reaction, int molecule);
+INDIGO_EXPORT int indigoAddReactant(int reaction, int molecule);
+INDIGO_EXPORT int indigoAddProduct(int reaction, int molecule);
+INDIGO_EXPORT int indigoAddCatalyst(int reaction, int molecule);
 
-CEXPORT int indigoCountReactants(int reaction);
-CEXPORT int indigoCountProducts(int reaction);
-CEXPORT int indigoCountCatalysts(int reaction);
+INDIGO_EXPORT int indigoCountReactants(int reaction);
+INDIGO_EXPORT int indigoCountProducts(int reaction);
+INDIGO_EXPORT int indigoCountCatalysts(int reaction);
 // Counts reactants, products, and catalysts.
-CEXPORT int indigoCountMolecules(int reaction);
-CEXPORT int indigoGetMolecule(int reaction, int index);
+INDIGO_EXPORT int indigoCountMolecules(int reaction);
+INDIGO_EXPORT int indigoGetMolecule(int reaction, int index);
 
-CEXPORT int indigoIterateReactants(int reaction);
-CEXPORT int indigoIterateProducts(int reaction);
-CEXPORT int indigoIterateCatalysts(int reaction);
+INDIGO_EXPORT int indigoIterateReactants(int reaction);
+INDIGO_EXPORT int indigoIterateProducts(int reaction);
+INDIGO_EXPORT int indigoIterateCatalysts(int reaction);
 // Returns an iterator for reactants, products, and catalysts.
-CEXPORT int indigoIterateMolecules(int reaction);
+INDIGO_EXPORT int indigoIterateMolecules(int reaction);
 
-CEXPORT int indigoSaveRxnfile(int reaction, int output);
-CEXPORT int indigoSaveRxnfileToFile(int reaction, const char* filename);
-CEXPORT const char* indigoRxnfile(int reaction);
+INDIGO_EXPORT int indigoSaveRxnfile(int reaction, int output);
+INDIGO_EXPORT int indigoSaveRxnfileToFile(int reaction, const char *filename);
+INDIGO_EXPORT const char *indigoRxnfile(int reaction);
 
 // Method for query optimizations for faster substructure search
 // (works for both query molecules and query reactions)
-CEXPORT int indigoOptimize(int query, const char* options);
+INDIGO_EXPORT int indigoOptimize(int query, const char *options);
 
 // Methods for structure normalization
 // It neutrailzes charges, resolves 5-valence Nitrogen, removes hydrogens and etc.
 // Default options is empty.
-CEXPORT int indigoNormalize(int structure, const char* options);
+INDIGO_EXPORT int indigoNormalize(int structure, const char *options);
 
 // Method for molecule and query standardizing
 // It stadrdize charges, stereo and etc.
-CEXPORT int indigoStandardize(int item);
+INDIGO_EXPORT int indigoStandardize(int item);
 
 // Method for structure ionization at specified pH and pH tollerance
-CEXPORT int indigoIonize(int item, float pH, float pH_toll);
+INDIGO_EXPORT int indigoIonize(int item, float pH, float pH_toll);
 
 // Method for building PKA model
-CEXPORT int indigoBuildPkaModel(int max_level, float threshold, const char* filename);
+INDIGO_EXPORT int indigoBuildPkaModel(int max_level, float threshold, const char *filename);
 
-CEXPORT float* indigoGetAcidPkaValue(int item, int atom, int level, int min_level);
-CEXPORT float* indigoGetBasicPkaValue(int item, int atom, int level, int min_level);
+INDIGO_EXPORT float *indigoGetAcidPkaValue(int item, int atom, int level, int min_level);
+INDIGO_EXPORT float *indigoGetBasicPkaValue(int item, int atom, int level, int min_level);
 
 // Automatic reaction atom-to-atom mapping
 // mode is one of the following (separated by a space):
@@ -318,28 +303,27 @@
 //    "ignore_isotopes" : do not consider atom isotopes while searching
 //    "ignore_valence" : do not consider atom valence while searching
 //    "ignore_radicals" : do not consider atom radicals while searching
-CEXPORT int indigoAutomap(int reaction, const char* mode);
+INDIGO_EXPORT int indigoAutomap(int reaction, const char *mode);
 
 // Returns mapping number. It might appear that there is more them
 // one atom with the same number in AAM
 // Value 0 means no mapping number has been specified.
-CEXPORT int indigoGetAtomMappingNumber(int reaction, int reaction_atom);
-CEXPORT int indigoSetAtomMappingNumber(int reaction, int reaction_atom, int number);
+INDIGO_EXPORT int indigoGetAtomMappingNumber(int reaction, int reaction_atom);
+INDIGO_EXPORT int indigoSetAtomMappingNumber(int reaction, int reaction_atom, int number);
 
 // Getters and setters for reacting centers
-CEXPORT int indigoGetReactingCenter(int reaction, int reaction_bond, int* rc);
-CEXPORT int indigoSetReactingCenter(int reaction, int reaction_bond, int rc);
+INDIGO_EXPORT int indigoGetReactingCenter(int reaction, int reaction_bond, int *rc);
+INDIGO_EXPORT int indigoSetReactingCenter(int reaction, int reaction_bond, int rc);
 
 // Clears all reaction AAM information
-CEXPORT int indigoClearAAM(int reaction);
+INDIGO_EXPORT int indigoClearAAM(int reaction);
 
 // Corrects reacting centers according to AAM
-CEXPORT int indigoCorrectReactingCenters(int reaction);
+INDIGO_EXPORT int indigoCorrectReactingCenters(int reaction);
 
 /* Accessing a molecule */
 
-enum
-{
+enum {
     INDIGO_ABS = 1,
     INDIGO_OR = 2,
     INDIGO_AND = 3,
@@ -359,60 +343,60 @@
 
 // Returns an iterator for all atoms of the given
 // molecule, including r-sites and pseudoatoms.
-CEXPORT int indigoIterateAtoms(int molecule);
-CEXPORT int indigoIteratePseudoatoms(int molecule);
-CEXPORT int indigoIterateRSites(int molecule);
-CEXPORT int indigoIterateStereocenters(int molecule);
-CEXPORT int indigoIterateAlleneCenters(int molecule);
-CEXPORT int indigoIterateRGroups(int molecule);
+INDIGO_EXPORT int indigoIterateAtoms(int molecule);
+INDIGO_EXPORT int indigoIteratePseudoatoms(int molecule);
+INDIGO_EXPORT int indigoIterateRSites(int molecule);
+INDIGO_EXPORT int indigoIterateStereocenters(int molecule);
+INDIGO_EXPORT int indigoIterateAlleneCenters(int molecule);
+INDIGO_EXPORT int indigoIterateRGroups(int molecule);
 
-CEXPORT int indigoCountRGroups(int molecule);
+INDIGO_EXPORT int indigoCountRGroups(int molecule);
 
-CEXPORT int indigoIsPseudoatom(int atom);
-CEXPORT int indigoIsRSite(int atom);
-CEXPORT int indigoIsTemplateAtom(int atom);
+INDIGO_EXPORT int indigoIsPseudoatom(int atom);
+INDIGO_EXPORT int indigoIsRSite(int atom);
+INDIGO_EXPORT int indigoIsTemplateAtom(int atom);
 
 // returns INDIGO_{ABS,OR,AND,EITHER}
 // or zero if the atom is not a stereoatom
-CEXPORT int indigoStereocenterType(int atom);
-CEXPORT int indigoChangeStereocenterType(int atom, int type);
+INDIGO_EXPORT int indigoStereocenterType(int atom);
+INDIGO_EXPORT int indigoChangeStereocenterType(int atom, int type);
 
-CEXPORT int indigoStereocenterGroup(int atom);
-CEXPORT int indigoSetStereocenterGroup(int atom, int group);
+INDIGO_EXPORT int indigoStereocenterGroup(int atom);
+INDIGO_EXPORT int indigoSetStereocenterGroup(int atom, int group);
 
 // returns 4 integers with atom indices that defines stereocenter pyramid
-CEXPORT const int* indigoStereocenterPyramid(int atom);
+INDIGO_EXPORT const int *indigoStereocenterPyramid(int atom);
 
-CEXPORT int indigoSingleAllowedRGroup(int rsite);
+INDIGO_EXPORT int indigoSingleAllowedRGroup(int rsite);
 
-CEXPORT int indigoAddStereocenter(int atom, int type, int v1, int v2, int v3, int v4);
+INDIGO_EXPORT int indigoAddStereocenter(int atom, int type, int v1, int v2, int v3, int v4);
 
 // Applicable to an R-Group, but not to a molecule
-CEXPORT int indigoIterateRGroupFragments(int rgroup);
+INDIGO_EXPORT int indigoIterateRGroupFragments(int rgroup);
 // Applicable to an R-Group and to a molecule
 // Returns maximal order of attachment points
-CEXPORT int indigoCountAttachmentPoints(int item);
-CEXPORT int indigoIterateAttachmentPoints(int item, int order);
+INDIGO_EXPORT int indigoCountAttachmentPoints(int item);
+INDIGO_EXPORT int indigoIterateAttachmentPoints(int item, int order);
 
-CEXPORT const char* indigoSymbol(int atom);
-CEXPORT int indigoDegree(int atom);
+INDIGO_EXPORT const char *indigoSymbol(int atom);
+INDIGO_EXPORT int indigoDegree(int atom);
 
 // Returns zero if the charge is ambiguous
 // If the charge is nonambiguous, returns 1 and writes *charge
-CEXPORT int indigoGetCharge(int atom, int* charge);
+INDIGO_EXPORT int indigoGetCharge(int atom, int *charge);
 // Same as indigoGetCharge
-CEXPORT int indigoGetExplicitValence(int atom, int* valence);
+INDIGO_EXPORT int indigoGetExplicitValence(int atom, int *valence);
 
-CEXPORT int indigoSetExplicitValence(int atom, int valence);
+INDIGO_EXPORT int indigoSetExplicitValence(int atom, int valence);
 
 // Returns a number of element from the periodic table.
 // Returns zero on ambiguous atom.
 // Can not be applied to pseudo-atoms and R-sites.
-CEXPORT int indigoAtomicNumber(int atom);
+INDIGO_EXPORT int indigoAtomicNumber(int atom);
 // Returns zero on unspecified or ambiguous isotope
-CEXPORT int indigoIsotope(int atom);
+INDIGO_EXPORT int indigoIsotope(int atom);
 // Not applicable to query molecules.
-CEXPORT int indigoValence(int atom);
+INDIGO_EXPORT int indigoValence(int atom);
 // Return atom hybridization
 // S = 1,
 // SP = 2,
@@ -423,324 +407,328 @@
 // SP3D3 = 7,
 // SP3D4 = 8,
 // SP2D = 9
-CEXPORT int indigoGetHybridization(int atom);
+INDIGO_EXPORT int indigoGetHybridization(int atom);
 // Returns zero if valence of the atom is wrong
-CEXPORT int indigoCheckValence(int atom);
+INDIGO_EXPORT int indigoCheckValence(int atom);
 
 // Returns one if atom or bond belongs Query or has any query feature
-CEXPORT int indigoCheckQuery(int item);
+INDIGO_EXPORT int indigoCheckQuery(int item);
 
 // Returns one if structure contains RGroup features (RSites, RGroups or attachment points
-CEXPORT int indigoCheckRGroups(int item);
+INDIGO_EXPORT int indigoCheckRGroups(int item);
 
 // Returns check result for Indigo object as text file for requested properties as JSON
-CEXPORT const char* indigoCheck(const char* item, const char* check_flags, const char* load_params);
+INDIGO_EXPORT const char *indigoCheck(const char *item, const char *check_flags, const char *load_params);
 
 // Returns check result for Indigo object for requested properties as JSON
-CEXPORT const char* indigoCheckObj(int item, const char* check_flags);
+INDIGO_EXPORT const char *indigoCheckObj(int item, const char *check_flags);
 
 // Returns check result for structure against requested properties
-CEXPORT const char* indigoCheckStructure(const char* structure, const char* props);
+INDIGO_EXPORT const char *indigoCheckStructure(const char *structure, const char *props);
 
 // Applicable to atoms, query atoms, and molecules. Can fail
 // (return zero) on query atoms where the number of hydrogens
 // is not definitely known. Otherwise, returns one and writes *hydro.
-CEXPORT int indigoCountHydrogens(int item, int* hydro);
+INDIGO_EXPORT int indigoCountHydrogens(int item, int *hydro);
 
 // Applicable to non-query molecules and atoms.
-CEXPORT int indigoCountImplicitHydrogens(int item);
+INDIGO_EXPORT int indigoCountImplicitHydrogens(int item);
 
 // On success, returns always the same pointer to a 3-element array;
 // you should not free() it, but rather memcpy() it if you want to keep it.
-CEXPORT float* indigoXYZ(int atom);
+INDIGO_EXPORT float *indigoXYZ(int atom);
 
-CEXPORT int indigoSetXYZ(int atom, float x, float y, float z);
+INDIGO_EXPORT int indigoSetXYZ(int atom, float x, float y, float z);
 
-CEXPORT int indigoCountSuperatoms(int molecule);
-CEXPORT int indigoCountDataSGroups(int molecule);
-CEXPORT int indigoCountRepeatingUnits(int molecule);
-CEXPORT int indigoCountMultipleGroups(int molecule);
-CEXPORT int indigoCountGenericSGroups(int molecule);
-CEXPORT int indigoIterateDataSGroups(int molecule);
-CEXPORT int indigoIterateSuperatoms(int molecule);
-CEXPORT int indigoIterateGenericSGroups(int molecule);
-CEXPORT int indigoIterateRepeatingUnits(int molecule);
-CEXPORT int indigoIterateMultipleGroups(int molecule);
+INDIGO_EXPORT int indigoCountSuperatoms(int molecule);
+INDIGO_EXPORT int indigoCountDataSGroups(int molecule);
+INDIGO_EXPORT int indigoCountRepeatingUnits(int molecule);
+INDIGO_EXPORT int indigoCountMultipleGroups(int molecule);
+INDIGO_EXPORT int indigoCountGenericSGroups(int molecule);
+INDIGO_EXPORT int indigoIterateDataSGroups(int molecule);
+INDIGO_EXPORT int indigoIterateSuperatoms(int molecule);
+INDIGO_EXPORT int indigoIterateGenericSGroups(int molecule);
+INDIGO_EXPORT int indigoIterateRepeatingUnits(int molecule);
+INDIGO_EXPORT int indigoIterateMultipleGroups(int molecule);
 
-CEXPORT int indigoIterateTGroups(int molecule);
-CEXPORT int indigoIterateSGroups(int molecule);
+INDIGO_EXPORT int indigoIterateTGroups(int molecule);
+INDIGO_EXPORT int indigoIterateSGroups(int molecule);
 
-CEXPORT int indigoGetSuperatom(int molecule, int index);
-CEXPORT int indigoGetDataSGroup(int molecule, int index);
-CEXPORT int indigoGetGenericSGroup(int molecule, int index);
-CEXPORT int indigoGetMultipleGroup(int molecule, int index);
-CEXPORT int indigoGetRepeatingUnit(int molecule, int index);
+INDIGO_EXPORT int indigoGetSuperatom(int molecule, int index);
+INDIGO_EXPORT int indigoGetDataSGroup(int molecule, int index);
+INDIGO_EXPORT int indigoGetGenericSGroup(int molecule, int index);
+INDIGO_EXPORT int indigoGetMultipleGroup(int molecule, int index);
+INDIGO_EXPORT int indigoGetRepeatingUnit(int molecule, int index);
 
-CEXPORT const char* indigoDescription(int data_sgroup);
-CEXPORT const char* indigoData(int data_sgroup);
+INDIGO_EXPORT const char *indigoDescription(int data_sgroup);
+INDIGO_EXPORT const char *indigoData(int data_sgroup);
 
-CEXPORT int indigoAddDataSGroup(int molecule, int natoms, int* atoms, int nbonds, int* bonds, const char* description, const char* data);
+INDIGO_EXPORT int
+indigoAddDataSGroup(int molecule, int natoms, int *atoms, int nbonds, int *bonds, const char *description,
+                    const char *data);
 
-CEXPORT int indigoAddSuperatom(int molecule, int natoms, int* atoms, const char* name);
+INDIGO_EXPORT int indigoAddSuperatom(int molecule, int natoms, int *atoms, const char *name);
 
-CEXPORT int indigoSetDataSGroupXY(int sgroup, float x, float y, const char* options);
+INDIGO_EXPORT int indigoSetDataSGroupXY(int sgroup, float x, float y, const char *options);
 
-CEXPORT int indigoSetSGroupData(int sgroup, const char* data);
-CEXPORT int indigoSetSGroupCoords(int sgroup, float x, float y);
-CEXPORT int indigoSetSGroupDescription(int sgroup, const char* description);
-CEXPORT int indigoSetSGroupFieldName(int sgroup, const char* name);
-CEXPORT int indigoSetSGroupQueryCode(int sgroup, const char* querycode);
-CEXPORT int indigoSetSGroupQueryOper(int sgroup, const char* queryoper);
-CEXPORT int indigoSetSGroupDisplay(int sgroup, const char* option);
-CEXPORT int indigoSetSGroupLocation(int sgroup, const char* option);
-CEXPORT int indigoSetSGroupTag(int sgroup, const char* tag);
-CEXPORT int indigoSetSGroupTagAlign(int sgroup, int tag_align);
-CEXPORT int indigoSetSGroupDataType(int sgroup, const char* type);
-CEXPORT int indigoSetSGroupXCoord(int sgroup, float x);
-CEXPORT int indigoSetSGroupYCoord(int sgroup, float y);
+INDIGO_EXPORT int indigoSetSGroupData(int sgroup, const char *data);
+INDIGO_EXPORT int indigoSetSGroupCoords(int sgroup, float x, float y);
+INDIGO_EXPORT int indigoSetSGroupDescription(int sgroup, const char *description);
+INDIGO_EXPORT int indigoSetSGroupFieldName(int sgroup, const char *name);
+INDIGO_EXPORT int indigoSetSGroupQueryCode(int sgroup, const char *querycode);
+INDIGO_EXPORT int indigoSetSGroupQueryOper(int sgroup, const char *queryoper);
+INDIGO_EXPORT int indigoSetSGroupDisplay(int sgroup, const char *option);
+INDIGO_EXPORT int indigoSetSGroupLocation(int sgroup, const char *option);
+INDIGO_EXPORT int indigoSetSGroupTag(int sgroup, const char *tag);
+INDIGO_EXPORT int indigoSetSGroupTagAlign(int sgroup, int tag_align);
+INDIGO_EXPORT int indigoSetSGroupDataType(int sgroup, const char *type);
+INDIGO_EXPORT int indigoSetSGroupXCoord(int sgroup, float x);
+INDIGO_EXPORT int indigoSetSGroupYCoord(int sgroup, float y);
 
-CEXPORT int indigoCreateSGroup(const char* type, int mapping, const char* name);
-CEXPORT const char* indigoGetSGroupClass(int sgroup);
-CEXPORT const char* indigoGetSGroupName(int sgroup);
-CEXPORT int indigoSetSGroupClass(int sgroup, const char* sgclass);
-CEXPORT int indigoSetSGroupName(int sgroup, const char* sgname);
-CEXPORT int indigoGetSGroupNumCrossBonds(int sgroup);
+INDIGO_EXPORT int indigoCreateSGroup(const char *type, int mapping, const char *name);
+INDIGO_EXPORT const char *indigoGetSGroupClass(int sgroup);
+INDIGO_EXPORT const char *indigoGetSGroupName(int sgroup);
+INDIGO_EXPORT int indigoSetSGroupClass(int sgroup, const char *sgclass);
+INDIGO_EXPORT int indigoSetSGroupName(int sgroup, const char *sgname);
+INDIGO_EXPORT int indigoGetSGroupNumCrossBonds(int sgroup);
 
-CEXPORT int indigoAddSGroupAttachmentPoint(int sgroup, int aidx, int lvidx, const char* apid);
-CEXPORT int indigoDeleteSGroupAttachmentPoint(int sgroup, int index);
-CEXPORT int indigoGetSGroupDisplayOption(int sgroup);
-CEXPORT int indigoSetSGroupDisplayOption(int sgroup, int option);
-CEXPORT int indigoGetSGroupSeqId(int sgroup);
-CEXPORT float* indigoGetSGroupCoords(int sgroup);
+INDIGO_EXPORT int indigoAddSGroupAttachmentPoint(int sgroup, int aidx, int lvidx, const char *apid);
+INDIGO_EXPORT int indigoDeleteSGroupAttachmentPoint(int sgroup, int index);
+INDIGO_EXPORT int indigoGetSGroupDisplayOption(int sgroup);
+INDIGO_EXPORT int indigoSetSGroupDisplayOption(int sgroup, int option);
+INDIGO_EXPORT int indigoGetSGroupSeqId(int sgroup);
+INDIGO_EXPORT float *indigoGetSGroupCoords(int sgroup);
 
-CEXPORT int indigoGetSGroupMultiplier(int sgroup);
-CEXPORT int indigoSetSGroupMultiplier(int sgroup, int multiplier);
+INDIGO_EXPORT int indigoGetSGroupMultiplier(int sgroup);
+INDIGO_EXPORT int indigoSetSGroupMultiplier(int sgroup, int multiplier);
 
-CEXPORT const char* indigoGetRepeatingUnitSubscript(int sgroup);
-CEXPORT int indigoGetRepeatingUnitConnectivity(int sgroup);
+INDIGO_EXPORT const char *indigoGetRepeatingUnitSubscript(int sgroup);
+INDIGO_EXPORT int indigoGetRepeatingUnitConnectivity(int sgroup);
 
-CEXPORT int indigoSetSGroupBrackets(int sgroup, int brk_style, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);
+INDIGO_EXPORT int
+indigoSetSGroupBrackets(int sgroup, int brk_style, float x1, float y1, float x2, float y2, float x3, float y3, float x4,
+                        float y4);
 
-CEXPORT int indigoFindSGroups(int item, const char* property, const char* value);
+INDIGO_EXPORT int indigoFindSGroups(int item, const char *property, const char *value);
 
-CEXPORT int indigoGetSGroupType(int item);
-CEXPORT int indigoGetSGroupIndex(int item);
+INDIGO_EXPORT int indigoGetSGroupType(int item);
+INDIGO_EXPORT int indigoGetSGroupIndex(int item);
 
-CEXPORT int indigoGetSGroupOriginalId(int sgroup);
-CEXPORT int indigoSetSGroupOriginalId(int sgroup, int original);
-CEXPORT int indigoGetSGroupParentId(int sgroup);
-CEXPORT int indigoSetSGroupParentId(int sgroup, int parent);
+INDIGO_EXPORT int indigoGetSGroupOriginalId(int sgroup);
+INDIGO_EXPORT int indigoSetSGroupOriginalId(int sgroup, int original);
+INDIGO_EXPORT int indigoGetSGroupParentId(int sgroup);
+INDIGO_EXPORT int indigoSetSGroupParentId(int sgroup, int parent);
 
-CEXPORT int indigoAddTemplate(int molecule, int templates, const char* tname);
-CEXPORT int indigoRemoveTemplate(int molecule, const char* tname);
-CEXPORT int indigoFindTemplate(int molecule, const char* tname);
+INDIGO_EXPORT int indigoAddTemplate(int molecule, int templates, const char *tname);
+INDIGO_EXPORT int indigoRemoveTemplate(int molecule, const char *tname);
+INDIGO_EXPORT int indigoFindTemplate(int molecule, const char *tname);
 
-CEXPORT const char* indigoGetTGroupClass(int tgroup);
-CEXPORT const char* indigoGetTGroupName(int tgroup);
-CEXPORT const char* indigoGetTGroupAlias(int tgroup);
+INDIGO_EXPORT const char *indigoGetTGroupClass(int tgroup);
+INDIGO_EXPORT const char *indigoGetTGroupName(int tgroup);
+INDIGO_EXPORT const char *indigoGetTGroupAlias(int tgroup);
 
-CEXPORT int indigoTransformSCSRtoCTAB(int item);
-CEXPORT int indigoTransformCTABtoSCSR(int molecule, int templates);
+INDIGO_EXPORT int indigoTransformSCSRtoCTAB(int item);
+INDIGO_EXPORT int indigoTransformCTABtoSCSR(int molecule, int templates);
 
-CEXPORT int indigoResetCharge(int atom);
-CEXPORT int indigoResetExplicitValence(int atom);
-CEXPORT int indigoResetIsotope(int atom);
+INDIGO_EXPORT int indigoResetCharge(int atom);
+INDIGO_EXPORT int indigoResetExplicitValence(int atom);
+INDIGO_EXPORT int indigoResetIsotope(int atom);
 
-CEXPORT int indigoSetAttachmentPoint(int atom, int order);
-CEXPORT int indigoClearAttachmentPoints(int item);
+INDIGO_EXPORT int indigoSetAttachmentPoint(int atom, int order);
+INDIGO_EXPORT int indigoClearAttachmentPoints(int item);
 
-CEXPORT int indigoRemoveConstraints(int item, const char* type);
-CEXPORT int indigoAddConstraint(int item, const char* type, const char* value);
-CEXPORT int indigoAddConstraintNot(int item, const char* type, const char* value);
-CEXPORT int indigoAddConstraintOr(int atom, const char* type, const char* value);
+INDIGO_EXPORT int indigoRemoveConstraints(int item, const char *type);
+INDIGO_EXPORT int indigoAddConstraint(int item, const char *type, const char *value);
+INDIGO_EXPORT int indigoAddConstraintNot(int item, const char *type, const char *value);
+INDIGO_EXPORT int indigoAddConstraintOr(int atom, const char *type, const char *value);
 
-CEXPORT int indigoResetStereo(int item);
-CEXPORT int indigoInvertStereo(int item);
+INDIGO_EXPORT int indigoResetStereo(int item);
+INDIGO_EXPORT int indigoInvertStereo(int item);
 
-CEXPORT int indigoCountAtoms(int molecule);
-CEXPORT int indigoCountBonds(int molecule);
-CEXPORT int indigoCountPseudoatoms(int molecule);
-CEXPORT int indigoCountRSites(int molecule);
+INDIGO_EXPORT int indigoCountAtoms(int molecule);
+INDIGO_EXPORT int indigoCountBonds(int molecule);
+INDIGO_EXPORT int indigoCountPseudoatoms(int molecule);
+INDIGO_EXPORT int indigoCountRSites(int molecule);
 
-CEXPORT int indigoIterateBonds(int molecule);
+INDIGO_EXPORT int indigoIterateBonds(int molecule);
 // Returns 1/2/3 if the bond is a single/double/triple bond
 // Returns 4 if the bond is an aromatic bond
 // Returns zero if the bond is ambiguous (query bond)
-CEXPORT int indigoBondOrder(int bond);
+INDIGO_EXPORT int indigoBondOrder(int bond);
 
 // Returns INDIGO_{UP/DOWN/EITHER/CIS/TRANS},
 // or zero if the bond is not a stereobond
-CEXPORT int indigoBondStereo(int bond);
+INDIGO_EXPORT int indigoBondStereo(int bond);
 
 // Returns INDIGO_{CHAIN/RING},
-CEXPORT int indigoTopology(int bond);
+INDIGO_EXPORT int indigoTopology(int bond);
 
 // Returns an iterator whose elements can be treated as atoms.
 // At the same time, they support indigoBond() call.
-CEXPORT int indigoIterateNeighbors(int atom);
+INDIGO_EXPORT int indigoIterateNeighbors(int atom);
 
 // Applicable exclusively to the "atom neighbors iterator".
 // Returns a bond to the neighbor atom.
-CEXPORT int indigoBond(int nei);
+INDIGO_EXPORT int indigoBond(int nei);
 
 // Accessing atoms and bonds by index
-CEXPORT int indigoGetAtom(int molecule, int idx);
-CEXPORT int indigoGetBond(int molecule, int idx);
+INDIGO_EXPORT int indigoGetAtom(int molecule, int idx);
+INDIGO_EXPORT int indigoGetBond(int molecule, int idx);
 
-CEXPORT int indigoSource(int bond);
-CEXPORT int indigoDestination(int bond);
+INDIGO_EXPORT int indigoSource(int bond);
+INDIGO_EXPORT int indigoDestination(int bond);
 
-CEXPORT int indigoClearCisTrans(int handle);
-CEXPORT int indigoClearStereocenters(int handle);
-CEXPORT int indigoCountStereocenters(int molecule);
-CEXPORT int indigoClearAlleneCenters(int molecule);
-CEXPORT int indigoCountAlleneCenters(int molecule);
+INDIGO_EXPORT int indigoClearCisTrans(int handle);
+INDIGO_EXPORT int indigoClearStereocenters(int handle);
+INDIGO_EXPORT int indigoCountStereocenters(int molecule);
+INDIGO_EXPORT int indigoClearAlleneCenters(int molecule);
+INDIGO_EXPORT int indigoCountAlleneCenters(int molecule);
 
-CEXPORT int indigoResetSymmetricCisTrans(int handle);
-CEXPORT int indigoResetSymmetricStereocenters(int handle);
-CEXPORT int indigoMarkEitherCisTrans(int handle);
-CEXPORT int indigoMarkStereobonds(int handle);
+INDIGO_EXPORT int indigoResetSymmetricCisTrans(int handle);
+INDIGO_EXPORT int indigoResetSymmetricStereocenters(int handle);
+INDIGO_EXPORT int indigoMarkEitherCisTrans(int handle);
+INDIGO_EXPORT int indigoMarkStereobonds(int handle);
 
-CEXPORT int indigoValidateChirality(int handle);
+INDIGO_EXPORT int indigoValidateChirality(int handle);
 
 // Accepts a symbol from the periodic table (like "C" or "Br"),
 // or a pseudoatom symbol, like "Pol". Returns the added atom.
-CEXPORT int indigoAddAtom(int molecule, const char* symbol);
+INDIGO_EXPORT int indigoAddAtom(int molecule, const char *symbol);
 // Set a new atom instead of specified
-CEXPORT int indigoResetAtom(int atom, const char* symbol);
+INDIGO_EXPORT int indigoResetAtom(int atom, const char *symbol);
 
-CEXPORT const char* indigoGetTemplateAtomClass(int atom);
-CEXPORT int indigoSetTemplateAtomClass(int atom, const char* name);
+INDIGO_EXPORT const char *indigoGetTemplateAtomClass(int atom);
+INDIGO_EXPORT int indigoSetTemplateAtomClass(int atom, const char *name);
 
 // Accepts Rsite name "R" (or just ""), "R1", "R2" or list with names "R1 R3"
-CEXPORT int indigoAddRSite(int molecule, const char* name);
-CEXPORT int indigoSetRSite(int atom, const char* name);
+INDIGO_EXPORT int indigoAddRSite(int molecule, const char *name);
+INDIGO_EXPORT int indigoSetRSite(int atom, const char *name);
 
-CEXPORT int indigoSetCharge(int atom, int charge);
-CEXPORT int indigoSetIsotope(int atom, int isotope);
+INDIGO_EXPORT int indigoSetCharge(int atom, int charge);
+INDIGO_EXPORT int indigoSetIsotope(int atom, int isotope);
 
 // If the radical is nonambiguous, returns 1 and writes *electrons
-CEXPORT int indigoGetRadicalElectrons(int atom, int* electrons);
+INDIGO_EXPORT int indigoGetRadicalElectrons(int atom, int *electrons);
 // If the radical is nonambiguous, returns 1 and writes *radical
-CEXPORT int indigoGetRadical(int atom, int* radical);
-CEXPORT int indigoSetRadical(int atom, int radical);
-CEXPORT int indigoResetRadical(int atom);
+INDIGO_EXPORT int indigoGetRadical(int atom, int *radical);
+INDIGO_EXPORT int indigoSetRadical(int atom, int radical);
+INDIGO_EXPORT int indigoResetRadical(int atom);
 
 // Used for hacks with aromatic molecules; not recommended to use
 // in other situations
-CEXPORT int indigoSetImplicitHCount(int atom, int impl_h);
+INDIGO_EXPORT int indigoSetImplicitHCount(int atom, int impl_h);
 
 // Accepts two atoms (source and destination) and the order of the new bond
 // (1/2/3/4 = single/double/triple/aromatic). Returns the added bond.
-CEXPORT int indigoAddBond(int source, int destination, int order);
+INDIGO_EXPORT int indigoAddBond(int source, int destination, int order);
 
-CEXPORT int indigoSetBondOrder(int bond, int order);
+INDIGO_EXPORT int indigoSetBondOrder(int bond, int order);
 
-CEXPORT int indigoMerge(int where_to, int what);
+INDIGO_EXPORT int indigoMerge(int where_to, int what);
 
 /* Highlighting */
 
 // Access atoms and bonds
-CEXPORT int indigoHighlight(int item);
+INDIGO_EXPORT int indigoHighlight(int item);
 
 // Access atoms, bonds, molecules, and reactions
-CEXPORT int indigoUnhighlight(int item);
+INDIGO_EXPORT int indigoUnhighlight(int item);
 
 // Access atoms and bonds
-CEXPORT int indigoIsHighlighted(int item);
+INDIGO_EXPORT int indigoIsHighlighted(int item);
 
 /* Selection */
 
 // Access atoms and bonds
-CEXPORT int indigoSelect(int item);
+INDIGO_EXPORT int indigoSelect(int item);
 
 // Access atoms, bonds, molecules, and reactions
-CEXPORT int indigoUnselect(int item);
+INDIGO_EXPORT int indigoUnselect(int item);
 
 // Access atoms and bonds
-CEXPORT int indigoIsSelected(int item);
+INDIGO_EXPORT int indigoIsSelected(int item);
 
 /* Connected components of molecules */
 
-CEXPORT int indigoCountComponents(int molecule);
-CEXPORT int indigoComponentIndex(int atom);
-CEXPORT int indigoIterateComponents(int molecule);
+INDIGO_EXPORT int indigoCountComponents(int molecule);
+INDIGO_EXPORT int indigoComponentIndex(int atom);
+INDIGO_EXPORT int indigoIterateComponents(int molecule);
 
 // Returns a 'molecule component' object, which can not be used as a
 // [query] molecule, but supports the indigo{Count,Iterate}{Atoms,Bonds} calls,
 // and also the indigoClone() call, which returns a [query] molecule.
-CEXPORT int indigoComponent(int molecule, int index);
+INDIGO_EXPORT int indigoComponent(int molecule, int index);
 
 /* Smallest Set of Smallest Rings */
 
-CEXPORT int indigoCountSSSR(int molecule);
-CEXPORT int indigoIterateSSSR(int molecule);
+INDIGO_EXPORT int indigoCountSSSR(int molecule);
+INDIGO_EXPORT int indigoIterateSSSR(int molecule);
 
-CEXPORT int indigoIterateSubtrees(int molecule, int min_atoms, int max_atoms);
-CEXPORT int indigoIterateRings(int molecule, int min_atoms, int max_atoms);
-CEXPORT int indigoIterateEdgeSubmolecules(int molecule, int min_bonds, int max_bonds);
+INDIGO_EXPORT int indigoIterateSubtrees(int molecule, int min_atoms, int max_atoms);
+INDIGO_EXPORT int indigoIterateRings(int molecule, int min_atoms, int max_atoms);
+INDIGO_EXPORT int indigoIterateEdgeSubmolecules(int molecule, int min_bonds, int max_bonds);
 
 /* Calculation on molecules */
 
-CEXPORT int indigoCountHeavyAtoms(int molecule);
-CEXPORT int indigoGrossFormula(int molecule);
-CEXPORT double indigoMolecularWeight(int molecule);
-CEXPORT double indigoMostAbundantMass(int molecule);
-CEXPORT double indigoMonoisotopicMass(int molecule);
-CEXPORT const char* indigoMassComposition(int molecule);
-CEXPORT double indigoTPSA(int molecule, int includeSP);
-CEXPORT int indigoNumRotatableBonds(int molecule);
-CEXPORT int indigoNumHydrogenBondAcceptors(int molecule);
-CEXPORT int indigoNumHydrogenBondDonors(int molecule);
-CEXPORT double indigoLogP(int molecule);
-CEXPORT double indigoMolarRefractivity(int molecule);
-CEXPORT double indigoPka(int molecule);
+INDIGO_EXPORT int indigoCountHeavyAtoms(int molecule);
+INDIGO_EXPORT int indigoGrossFormula(int molecule);
+INDIGO_EXPORT double indigoMolecularWeight(int molecule);
+INDIGO_EXPORT double indigoMostAbundantMass(int molecule);
+INDIGO_EXPORT double indigoMonoisotopicMass(int molecule);
+INDIGO_EXPORT const char *indigoMassComposition(int molecule);
+INDIGO_EXPORT double indigoTPSA(int molecule, int includeSP);
+INDIGO_EXPORT int indigoNumRotatableBonds(int molecule);
+INDIGO_EXPORT int indigoNumHydrogenBondAcceptors(int molecule);
+INDIGO_EXPORT int indigoNumHydrogenBondDonors(int molecule);
+INDIGO_EXPORT double indigoLogP(int molecule);
+INDIGO_EXPORT double indigoMolarRefractivity(int molecule);
+INDIGO_EXPORT double indigoPka(int molecule);
 
-CEXPORT const char* indigoCanonicalSmiles(int molecule);
-CEXPORT const char* indigoLayeredCode(int molecule);
+INDIGO_EXPORT const char *indigoCanonicalSmiles(int molecule);
+INDIGO_EXPORT const char *indigoLayeredCode(int molecule);
 
-CEXPORT int64_t indigoHash(int chemicalObject);
+INDIGO_EXPORT int64_t indigoHash(int chemicalObject);
 
-CEXPORT const int* indigoSymmetryClasses(int molecule, int* count_out);
+INDIGO_EXPORT const int *indigoSymmetryClasses(int molecule, int *count_out);
 
-CEXPORT int indigoHasCoord(int molecule);
-CEXPORT int indigoHasZCoord(int molecule);
-CEXPORT int indigoIsChiral(int molecule);
-CEXPORT int indigoCheckChirality(int molecule);
-CEXPORT int indigoCheck3DStereo(int molecule);
-CEXPORT int indigoCheckStereo(int molecule);
+INDIGO_EXPORT int indigoHasCoord(int molecule);
+INDIGO_EXPORT int indigoHasZCoord(int molecule);
+INDIGO_EXPORT int indigoIsChiral(int molecule);
+INDIGO_EXPORT int indigoCheckChirality(int molecule);
+INDIGO_EXPORT int indigoCheck3DStereo(int molecule);
+INDIGO_EXPORT int indigoCheckStereo(int molecule);
 
-CEXPORT int indigoIsPossibleFischerProjection(int molecule, const char* options);
+INDIGO_EXPORT int indigoIsPossibleFischerProjection(int molecule, const char *options);
 
-CEXPORT int indigoCreateSubmolecule(int molecule, int nvertices, int* vertices);
-CEXPORT int indigoCreateEdgeSubmolecule(int molecule, int nvertices, int* vertices, int nedges, int* edges);
+INDIGO_EXPORT int indigoCreateSubmolecule(int molecule, int nvertices, int *vertices);
+INDIGO_EXPORT int indigoCreateEdgeSubmolecule(int molecule, int nvertices, int *vertices, int nedges, int *edges);
 
-CEXPORT int indigoGetSubmolecule(int molecule, int nvertices, int* vertices);
+INDIGO_EXPORT int indigoGetSubmolecule(int molecule, int nvertices, int *vertices);
 
-CEXPORT int indigoRemoveAtoms(int molecule, int nvertices, int* vertices);
-CEXPORT int indigoRemoveBonds(int molecule, int nbonds, int* bonds);
+INDIGO_EXPORT int indigoRemoveAtoms(int molecule, int nvertices, int *vertices);
+INDIGO_EXPORT int indigoRemoveBonds(int molecule, int nbonds, int *bonds);
 
 // Determines and applies the best transformation to the given molecule
 // so that the specified atoms move as close as possible to the desired
 // positions. The size of desired_xyz is equal to 3 * natoms.
 // The return value is the root-mean-square measure of the difference
 // between the desired and obtained positions.
-CEXPORT float indigoAlignAtoms(int molecule, int natoms, int* atom_ids, float* desired_xyz);
+INDIGO_EXPORT float indigoAlignAtoms(int molecule, int natoms, int *atom_ids, float *desired_xyz);
 
 /* Things that work for both molecules and reactions */
 
-CEXPORT int indigoAromatize(int item);
-CEXPORT int indigoDearomatize(int item);
+INDIGO_EXPORT int indigoAromatize(int item);
+INDIGO_EXPORT int indigoDearomatize(int item);
 
-CEXPORT int indigoFoldHydrogens(int item);
-CEXPORT int indigoUnfoldHydrogens(int item);
+INDIGO_EXPORT int indigoFoldHydrogens(int item);
+INDIGO_EXPORT int indigoUnfoldHydrogens(int item);
 
-CEXPORT int indigoLayout(int object);
-CEXPORT int indigoClean2d(int object);
+INDIGO_EXPORT int indigoLayout(int object);
+INDIGO_EXPORT int indigoClean2d(int object);
 
-CEXPORT const char* indigoSmiles(int item);
-CEXPORT const char* indigoSmarts(int item);
-CEXPORT const char* indigoCanonicalSmarts(int item);
+INDIGO_EXPORT const char *indigoSmiles(int item);
+INDIGO_EXPORT const char *indigoSmarts(int item);
+INDIGO_EXPORT const char *indigoCanonicalSmarts(int item);
 
 // Returns a "mapping" if there is an exact match, zero otherwise
 // The flags string consists of space-separated flags.
@@ -751,55 +739,55 @@
 // "FRA": Connected fragments: disallows match of separate ions in salts
 // "ALL": All of the above
 // By default (with null or empty flags string) all flags are on.
-CEXPORT int indigoExactMatch(int item1, int item2, const char* flags);
+INDIGO_EXPORT int indigoExactMatch(int item1, int item2, const char *flags);
 
 // "beg" and "end" refer to the two ends of the tautomeric chain. Allowed
 // elements are separated by commas. '1' at the beginning means an aromatic
 // atom, while '0' means an aliphatic atom.
-CEXPORT int indigoSetTautomerRule(int id, const char* beg, const char* end);
+INDIGO_EXPORT int indigoSetTautomerRule(int id, const char *beg, const char *end);
 
-CEXPORT int indigoRemoveTautomerRule(int id);
+INDIGO_EXPORT int indigoRemoveTautomerRule(int id);
 
-CEXPORT int indigoClearTautomerRules();
+INDIGO_EXPORT int indigoClearTautomerRules();
 
-CEXPORT const char* indigoName(int handle);
-CEXPORT int indigoSetName(int handle, const char* name);
+INDIGO_EXPORT const char *indigoName(int handle);
+INDIGO_EXPORT int indigoSetName(int handle, const char *name);
 
 // You should not free() the obtained buffer, but rather memcpy() it if you want to keep it
-CEXPORT int indigoSerialize(int handle, byte** buf, int* size);
+INDIGO_EXPORT int indigoSerialize(int handle, byte **buf, int *size);
 
-CEXPORT int indigoUnserialize(const byte* buf, int size);
+INDIGO_EXPORT int indigoUnserialize(const byte *buf, int size);
 
 // Applicable to molecules/reactions obtained from SDF or RDF files,
 // and to their clones, and to their R-Group deconvolutions.
-CEXPORT int indigoHasProperty(int handle, const char* prop);
-CEXPORT const char* indigoGetProperty(int handle, const char* prop);
+INDIGO_EXPORT int indigoHasProperty(int handle, const char *prop);
+INDIGO_EXPORT const char *indigoGetProperty(int handle, const char *prop);
 
 // Applicable to newly created or cloned molecules/reactions,
 // and also to molecules/reactions obtained from SDF or RDF files.
 // If the property with the given name does not exist, it is created automatically.
-CEXPORT int indigoSetProperty(int item, const char* prop, const char* value);
+INDIGO_EXPORT int indigoSetProperty(int item, const char *prop, const char *value);
 
 // Does not raise an error if the given property does not exist
-CEXPORT int indigoRemoveProperty(int item, const char* prop);
+INDIGO_EXPORT int indigoRemoveProperty(int item, const char *prop);
 
 // Returns an iterator that one can pass to indigoName() to
 // know the name of the property. The value of the property can be
 // obtained via indigoGetProperty() call to the object
-CEXPORT int indigoIterateProperties(int handle);
+INDIGO_EXPORT int indigoIterateProperties(int handle);
 
 // Clears all properties of the molecule
-CEXPORT int indigoClearProperties(int handle);
+INDIGO_EXPORT int indigoClearProperties(int handle);
 
 // Accepts a molecule or reaction (but not query molecule or query reaction).
 // Returns a string describing the first encountered mistake with valence.
 // Returns an empty string if the input molecule/reaction is fine.
-CEXPORT const char* indigoCheckBadValence(int handle);
+INDIGO_EXPORT const char *indigoCheckBadValence(int handle);
 
 // Accepts a molecule or reaction (but not query molecule or query reaction).
 // Returns a string describing the first encountered mistake with ambiguous H counter.
 // Returns an empty string if the input molecule/reaction is fine.
-CEXPORT const char* indigoCheckAmbiguousH(int handle);
+INDIGO_EXPORT const char *indigoCheckAmbiguousH(int handle);
 
 /* Fingerprints */
 
@@ -817,119 +805,119 @@
 //                 substructure screening
 //   "full"    -- "Full fingerprint", which has all the mentioned
 //                 fingerprint types included
-CEXPORT int indigoFingerprint(int item, const char* type);
+INDIGO_EXPORT int indigoFingerprint(int item, const char *type);
 
 // Counts the nonzero (i.e. one) bits in a fingerprint
-CEXPORT int indigoCountBits(int fingerprint);
+INDIGO_EXPORT int indigoCountBits(int fingerprint);
 
 // Counts the number of the coinincident in two fingerprints
-CEXPORT int indigoCommonBits(int fingerprint1, int fingerprint2);
+INDIGO_EXPORT int indigoCommonBits(int fingerprint1, int fingerprint2);
 
 // Return one bits string for the fingerprint object
-CEXPORT const char* indigoOneBitsList(int fingerprint);
+INDIGO_EXPORT const char *indigoOneBitsList(int fingerprint);
 
 // Returns a 'fingerprint' object with data from 'buffer'
-CEXPORT int indigoLoadFingerprintFromBuffer(const byte* buffer, int size);
+INDIGO_EXPORT int indigoLoadFingerprintFromBuffer(const byte *buffer, int size);
 
 // Constructs a 'fingerprint' object from a normalized array of double descriptors
-CEXPORT int indigoLoadFingerprintFromDescriptors(const double* arr, int arr_len, int size, double density);
+INDIGO_EXPORT int indigoLoadFingerprintFromDescriptors(const double *arr, int arr_len, int size, double density);
 
 // Accepts two molecules, two reactions, or two fingerprints.
 // Returns the similarity measure between them.
 // Metrics: "tanimoto", "tversky", "tversky <alpha> <beta>", "euclid-sub" or "normalized-edit"
 // Zero pointer or empty string defaults to "tanimoto".
 // "tversky" without numbers defaults to alpha = beta = 0.5
-CEXPORT float indigoSimilarity(int item1, int item2, const char* metrics);
+INDIGO_EXPORT float indigoSimilarity(int item1, int item2, const char *metrics);
 
 /* Working with SDF/RDF/SMILES/CML/CDX files  */
 
-CEXPORT int indigoIterateSDF(int reader);
-CEXPORT int indigoIterateRDF(int reader);
-CEXPORT int indigoIterateSmiles(int reader);
-CEXPORT int indigoIterateCML(int reader);
-CEXPORT int indigoIterateCDX(int reader);
+INDIGO_EXPORT int indigoIterateSDF(int reader);
+INDIGO_EXPORT int indigoIterateRDF(int reader);
+INDIGO_EXPORT int indigoIterateSmiles(int reader);
+INDIGO_EXPORT int indigoIterateCML(int reader);
+INDIGO_EXPORT int indigoIterateCDX(int reader);
 
-CEXPORT int indigoIterateSDFile(const char* filename);
-CEXPORT int indigoIterateRDFile(const char* filename);
-CEXPORT int indigoIterateSmilesFile(const char* filename);
-CEXPORT int indigoIterateCMLFile(const char* filename);
-CEXPORT int indigoIterateCDXFile(const char* filename);
+INDIGO_EXPORT int indigoIterateSDFile(const char *filename);
+INDIGO_EXPORT int indigoIterateRDFile(const char *filename);
+INDIGO_EXPORT int indigoIterateSmilesFile(const char *filename);
+INDIGO_EXPORT int indigoIterateCMLFile(const char *filename);
+INDIGO_EXPORT int indigoIterateCDXFile(const char *filename);
 
 // Applicable to items returned by SDF/RDF iterators.
 // Returns the content of SDF/RDF item.
-CEXPORT const char* indigoRawData(int item);
+INDIGO_EXPORT const char *indigoRawData(int item);
 
 // Applicable to items returned by SDF/RDF iterators.
 // Returns the offset in the SDF/RDF file.
-CEXPORT int indigoTell(int handle);
-CEXPORT long long indigoTell64(int handle);
+INDIGO_EXPORT int indigoTell(int handle);
+INDIGO_EXPORT long long indigoTell64(int handle);
 
 // Saves the molecule to an SDF output stream
-CEXPORT int indigoSdfAppend(int output, int item);
+INDIGO_EXPORT int indigoSdfAppend(int output, int item);
 // Saves the molecule to a multiline SMILES output stream
-CEXPORT int indigoSmilesAppend(int output, int item);
+INDIGO_EXPORT int indigoSmilesAppend(int output, int item);
 
 // Similarly for RDF files, except that the header should be written first
-CEXPORT int indigoRdfHeader(int output);
-CEXPORT int indigoRdfAppend(int output, int item);
+INDIGO_EXPORT int indigoRdfHeader(int output);
+INDIGO_EXPORT int indigoRdfAppend(int output, int item);
 
 // Similarly for CML files, except that they have both header and footer
-CEXPORT int indigoCmlHeader(int output);
-CEXPORT int indigoCmlAppend(int output, int item);
-CEXPORT int indigoCmlFooter(int output);
+INDIGO_EXPORT int indigoCmlHeader(int output);
+INDIGO_EXPORT int indigoCmlAppend(int output, int item);
+INDIGO_EXPORT int indigoCmlFooter(int output);
 
 // Create saver objects that can be used to save molecules or reactions
 // Supported formats: 'sdf', 'smi' or 'smiles', 'cml', 'rdf'
 // Format argument is case-insensitive
 // Saver should be closed with indigoClose function
-CEXPORT int indigoCreateSaver(int output, const char* format);
-CEXPORT int indigoCreateFileSaver(const char* filename, const char* format);
+INDIGO_EXPORT int indigoCreateSaver(int output, const char *format);
+INDIGO_EXPORT int indigoCreateFileSaver(const char *filename, const char *format);
 
 // Append object to a specified saver stream
-CEXPORT int indigoAppend(int saver, int object);
+INDIGO_EXPORT int indigoAppend(int saver, int object);
 
 /* Arrays */
 
-CEXPORT int indigoCreateArray();
+INDIGO_EXPORT int indigoCreateArray();
 // Note: a clone of the object is added, not the object itself
-CEXPORT int indigoArrayAdd(int arr, int object);
-CEXPORT int indigoAt(int item, int index);
-CEXPORT int indigoCount(int item);
-CEXPORT int indigoClear(int arr);
-CEXPORT int indigoIterateArray(int arr);
+INDIGO_EXPORT int indigoArrayAdd(int arr, int object);
+INDIGO_EXPORT int indigoAt(int item, int index);
+INDIGO_EXPORT int indigoCount(int item);
+INDIGO_EXPORT int indigoClear(int arr);
+INDIGO_EXPORT int indigoIterateArray(int arr);
 
 /* Substructure matching */
 
 // Returns a new 'matcher' object
 // 'mode' is reserved for future use; currently its value is ignored
-CEXPORT int indigoSubstructureMatcher(int target, const char* mode);
+INDIGO_EXPORT int indigoSubstructureMatcher(int target, const char *mode);
 
 // Ignore target atom in the substructure matcher
-CEXPORT int indigoIgnoreAtom(int matcher, int atom_object);
+INDIGO_EXPORT int indigoIgnoreAtom(int matcher, int atom_object);
 
 // Ignore target atom in the substructure matcher
-CEXPORT int indigoUnignoreAtom(int matcher, int atom_object);
+INDIGO_EXPORT int indigoUnignoreAtom(int matcher, int atom_object);
 
 // Clear list of ignored target atoms in the substructure matcher
-CEXPORT int indigoUnignoreAllAtoms(int matcher);
+INDIGO_EXPORT int indigoUnignoreAllAtoms(int matcher);
 
 // Returns a new 'match' object on success, zero on fail
 //    matcher is an matcher object returned by indigoSubstructureMatcher
-CEXPORT int indigoMatch(int matcher, int query);
+INDIGO_EXPORT int indigoMatch(int matcher, int query);
 
 // Counts the number of embeddings of the query structure into the target
-CEXPORT int indigoCountMatches(int matcher, int query);
+INDIGO_EXPORT int indigoCountMatches(int matcher, int query);
 
 // Counts the number of embeddings of the query structure into the target
 // If number of embeddings is more then limit then limit is returned
-CEXPORT int indigoCountMatchesWithLimit(int matcher, int query, int embeddings_limit);
+INDIGO_EXPORT int indigoCountMatchesWithLimit(int matcher, int query, int embeddings_limit);
 
 // Returns substructure matches iterator
-CEXPORT int indigoIterateMatches(int matcher, int query);
+INDIGO_EXPORT int indigoIterateMatches(int matcher, int query);
 
 // Accepts a 'match' object obtained from indigoMatchSubstructure.
 // Returns a new molecule which has the query highlighted.
-CEXPORT int indigoHighlightedTarget(int match);
+INDIGO_EXPORT int indigoHighlightedTarget(int match);
 
 // Accepts an atom from the query, not an atom index.
 //   You can use indigoGetAtom() to obtain the atom by its index.
@@ -937,7 +925,7 @@
 // atom doesn't match particular atom in the target (R-group or explicit
 // hydrogen) then return value is zero.
 //   You can use indigoIndex() to obtain the index of the returned atom.
-CEXPORT int indigoMapAtom(int handle, int atom);
+INDIGO_EXPORT int indigoMapAtom(int handle, int atom);
 
 // Accepts a bond from the query, not a bond index.
 //   You can use indigoGetBond() to obtain the bond by its index.
@@ -945,7 +933,7 @@
 // bond doesn't match particular bond in the target (R-group or explicit
 // hydrogen) then return value is zero.
 //   You can use indigoIndex() to obtain the index of the returned bond.
-CEXPORT int indigoMapBond(int handle, int bond);
+INDIGO_EXPORT int indigoMapBond(int handle, int bond);
 
 // Accepts a molecule from the query reaction, not a molecule index.
 //   You can use indigoGetMolecule() to obtain the bond by its index.
@@ -953,11 +941,11 @@
 // molecule doesn't match particular molecule in the target then return
 // value is zero.
 //   You can use indigoIndex() to obtain the index of the returned molecule.
-CEXPORT int indigoMapMolecule(int handle, int molecule);
+INDIGO_EXPORT int indigoMapMolecule(int handle, int molecule);
 
 // Accepts a molecule and options for tautomer enumeration algorithms
 // Returns an iterator object over the molecules that are tautomers of this molecule.
-CEXPORT int indigoIterateTautomers(int molecule, const char* options);
+INDIGO_EXPORT int indigoIterateTautomers(int molecule, const char *options);
 
 /* Scaffold detection */
 
@@ -966,91 +954,93 @@
 //   (i) treated as a structure: the maximum (by the number of rings) common
 //       substructure of the given structures.
 //  (ii) passed to indigoAllScaffolds()
-CEXPORT int indigoExtractCommonScaffold(int structures, const char* options);
+INDIGO_EXPORT int indigoExtractCommonScaffold(int structures, const char *options);
 
 // Returns an array of all possible scaffolds.
 // The input parameter is the value returned by indigoExtractCommonScaffold().
-CEXPORT int indigoAllScaffolds(int extracted);
+INDIGO_EXPORT int indigoAllScaffolds(int extracted);
 
 /* R-Group deconvolution */
 
 // Returns a ``decomposition'' object that can be passed to
 // indigoDecomposedMoleculeScaffold() and
 // indigoIterateDecomposedMolecules()
-CEXPORT int indigoDecomposeMolecules(int scaffold, int structures);
+INDIGO_EXPORT int indigoDecomposeMolecules(int scaffold, int structures);
 
 // Returns a scaffold molecule with r-sites marking the place
 // for substituents to add to form the structures given above.
-CEXPORT int indigoDecomposedMoleculeScaffold(int decomp);
+INDIGO_EXPORT int indigoDecomposedMoleculeScaffold(int decomp);
 
 // Returns an iterator which corresponds to the given collection of structures.
 // indigoDecomposedMoleculeHighlighted() and
 // indigoDecomposedMoleculeWithRGroups() are applicable to the
 // values returned by the iterator.
-CEXPORT int indigoIterateDecomposedMolecules(int decomp);
+INDIGO_EXPORT int indigoIterateDecomposedMolecules(int decomp);
 
 // Returns a molecule with highlighted scaffold
-CEXPORT int indigoDecomposedMoleculeHighlighted(int decomp);
+INDIGO_EXPORT int indigoDecomposedMoleculeHighlighted(int decomp);
 
 // Returns a query molecule with r-sites and "R1=...", "R2=..."
 // substituents defined. The 'scaffold' part of the molecule
 // is identical to the indigoDecomposedMoleculeScaffold()
-CEXPORT int indigoDecomposedMoleculeWithRGroups(int decomp);
+INDIGO_EXPORT int indigoDecomposedMoleculeWithRGroups(int decomp);
 
 /*
  * Decomposition Iteration API
  */
 // Returns a 'decomposition' object
-CEXPORT int indigoCreateDecomposer(int scaffold);
+INDIGO_EXPORT int indigoCreateDecomposer(int scaffold);
 // Returns a 'decomposition' item
-CEXPORT int indigoDecomposeMolecule(int decomp, int mol);
+INDIGO_EXPORT int indigoDecomposeMolecule(int decomp, int mol);
 // Returns decomposition iterator
-CEXPORT int indigoIterateDecompositions(int deco_item);
+INDIGO_EXPORT int indigoIterateDecompositions(int deco_item);
 // Adds the input decomposition to a full scaffold
-CEXPORT int indigoAddDecomposition(int decomp, int q_match);
+INDIGO_EXPORT int indigoAddDecomposition(int decomp, int q_match);
 
 /* R-Group convolution */
 
-CEXPORT int indigoGetFragmentedMolecule(int elem, const char* options);
-CEXPORT int indigoRGroupComposition(int molecule, const char* options);
+INDIGO_EXPORT int indigoGetFragmentedMolecule(int elem, const char *options);
+INDIGO_EXPORT int indigoRGroupComposition(int molecule, const char *options);
 
 /*
  * Abbreviations
  */
-CEXPORT int indigoExpandAbbreviations(int molecule);
+INDIGO_EXPORT int indigoExpandAbbreviations(int molecule);
 
 /* Other */
 
-CEXPORT const char* indigoToString(int handle);
-CEXPORT const char* indigoToBase64String(int handle);
-CEXPORT int indigoToBuffer(int handle, char** buf, int* size);
+INDIGO_EXPORT const char *indigoToString(int handle);
+INDIGO_EXPORT const char *indigoToBase64String(int handle);
+INDIGO_EXPORT int indigoToBuffer(int handle, char **buf, int *size);
 
 /* Reaction products enumeration */
 
 // Accepts a query reaction with markd R-sites, and array of arrays
 // of substituents corresponding to the R-Sites. Returns an array of
 // reactions with R-Sites replaced by the actual substituents.
-CEXPORT int indigoReactionProductEnumerate(int reaction, int monomers);
+INDIGO_EXPORT int indigoReactionProductEnumerate(int reaction, int monomers);
 
-CEXPORT int indigoTransform(int reaction, int monomers);
+INDIGO_EXPORT int indigoTransform(int reaction, int monomers);
 
-CEXPORT int indigoTransformHELMtoSCSR(int monomer);
+INDIGO_EXPORT int indigoTransformHELMtoSCSR(int monomer);
 
 /* Debug functionality */
 
 // Returns internal type of an object
-CEXPORT const char* indigoDbgInternalType(int object);
+INDIGO_EXPORT const char *indigoDbgInternalType(int object);
 
 // Internal breakpoint
-CEXPORT void indigoDbgBreakpoint(void);
+INDIGO_EXPORT void indigoDbgBreakpoint(void);
 
 // Methods that returns profiling infromation in a human readable format
-CEXPORT const char* indigoDbgProfiling(int /*bool*/ whole_session);
+INDIGO_EXPORT const char *indigoDbgProfiling(int /*bool*/ whole_session);
 
 // Reset profiling counters either for the current state or for the whole session
-CEXPORT int indigoDbgResetProfiling(int /*bool*/ whole_session);
+INDIGO_EXPORT int indigoDbgResetProfiling(int /*bool*/ whole_session);
 
 // Methods that returns profiling counter value for a particular counter
-CEXPORT qword indigoDbgProfilingGetCounter(const char* name, int /*bool*/ whole_session);
-
+INDIGO_EXPORT qword indigoDbgProfilingGetCounter(const char *name, int /*bool*/ whole_session);
+#ifdef __cplusplus
+}
+#endif
 #endif
Index: openbabel-src/openbabel/src/RDKitConv.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/RDKitConv.cpp b/openbabel-src/openbabel/src/RDKitConv.cpp
--- a/openbabel-src/openbabel/src/RDKitConv.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/RDKitConv.cpp	(date 1689048275862)
@@ -23,6 +23,9 @@
 ***********************************************************************/
 
 #include <openbabel/babelconfig.h>
+#include <openbabel/oberror.h>
+#include <openbabel/bond.h>
+#include <openbabel/bondtyper.h>
 #include <RDKitConv.h>
 
 using OpenBabel::OBMolAtomIter;
@@ -45,7 +48,7 @@
   {
     //bond order >3 needs doing properly
     //assume RDKit atom indices start at 0
-    RDMol.addBond(b->GetBeginAtomIdx()-1, b->GetEndAtomIdx()-1, (RDKit::Bond::BondType)b->GetBO());
+    RDMol.addBond(b->GetBeginAtomIdx()-1, b->GetEndAtomIdx()-1, (RDKit::Bond::BondType)b->GetBondOrder());
   }
   std::string msg("RWMol made from ");
   if(pOBMol->GetTitle())
Index: yaehmop-src/yaehmop/tightbind/charge_mat.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/yaehmop-src/yaehmop/tightbind/charge_mat.c b/yaehmop-src/yaehmop/tightbind/charge_mat.c
--- a/yaehmop-src/yaehmop/tightbind/charge_mat.c	(revision c81f41694bcffccf38e17a63627a862628294613)
+++ b/yaehmop-src/yaehmop/tightbind/charge_mat.c	(date 1689048276198)
@@ -159,7 +159,7 @@
  *     num_atoms * num_orbs
  *
  ****************************************************************************/
-void reduced_charge_mat(num_atoms,num_orbs,orbital_lookup_table,Chg_matrix,RChg_matrix)
+void reduced_charge_matrix(num_atoms,num_orbs,orbital_lookup_table,Chg_matrix,RChg_matrix)
   int num_atoms,num_orbs,*orbital_lookup_table;
   real *Chg_matrix;
   real *RChg_matrix;
Index: openbabel-src/openbabel/src/phmodel.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/phmodel.cpp b/openbabel-src/openbabel/src/phmodel.cpp
--- a/openbabel-src/openbabel/src/phmodel.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/phmodel.cpp	(date 1689048275890)
@@ -28,8 +28,6 @@
 
 #include <cstdlib>
 
-// private data header with default parameters
-#include "phmodeldata.h"
 
 #ifdef WIN32
 #pragma warning (disable : 4786)
@@ -50,7 +48,7 @@
     _envvar = "BABEL_DATADIR";
     _filename = "phmodel.txt";
     _subdir = "data";
-    _dataptr = PhModelData;
+    _dataptr = nullptr;
   }
 
   OBPhModel::~OBPhModel()
Index: openbabel-src/openbabel/src/forcefield.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/forcefield.cpp b/openbabel-src/openbabel/src/forcefield.cpp
--- a/openbabel-src/openbabel/src/forcefield.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/forcefield.cpp	(date 1689048275866)
@@ -40,11 +40,6 @@
 
 namespace OpenBabel
 {
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-  // macro to implement static OBPlugin::PluginMapType& Map()
-  PLUGIN_CPP_FILE(OBForceField)
-#endif
-
   /** \class OBForceField forcefield.h <openbabel/forcefield.h>
       \brief Base class for molecular mechanics force fields
 
Index: indigo-src/indigo/api/c/indigo/src/indigo_io.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_io.h b/indigo-src/indigo/api/c/indigo/src/indigo_io.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_io.h	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_io.h	(date 1690767117645)
@@ -27,7 +27,7 @@
 #pragma warning(disable : 4251)
 #endif
 
-class DLLEXPORT IndigoScanner : public IndigoObject
+class INDIGO_EXPORT IndigoScanner : public IndigoObject
 {
 public:
     IndigoScanner(Scanner* scanner);
@@ -44,7 +44,7 @@
     Array<char> _buf;
 };
 
-class DLLEXPORT IndigoOutput : public IndigoObject
+class INDIGO_EXPORT IndigoOutput : public IndigoObject
 {
 public:
     IndigoOutput();
Index: inchi-src/inchi/INCHI_BASE/src/ichicomp.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_BASE/src/ichicomp.h b/inchi-src/inchi/INCHI_BASE/src/ichicomp.h
--- a/inchi-src/inchi/INCHI_BASE/src/ichicomp.h	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_BASE/src/ichicomp.h	(date 1689048275418)
@@ -54,9 +54,6 @@
 
 /*  ANSI redefinitions */
 #ifdef COMPILE_ANSI_ONLY  /* { */
-#ifndef __isascii
-#define __isascii(val)  ((unsigned)(val) <= 0x7F)
-#endif
 
 /* #ifndef __GNUC__ */
 /* these non-ANSI functions are implemented in gcc */
Index: yaehmop-src/yaehmop/tightbind/diag.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/yaehmop-src/yaehmop/tightbind/diag.c b/yaehmop-src/yaehmop/tightbind/diag.c
--- a/yaehmop-src/yaehmop/tightbind/diag.c	(revision c81f41694bcffccf38e17a63627a862628294613)
+++ b/yaehmop-src/yaehmop/tightbind/diag.c	(date 1689048276198)
@@ -2,7 +2,9 @@
 Produced by gmFortran V30.59(10/26/17) on 9/18/18 at 9:02:32
 */
 #define LPROTOTYPE
-#include "fortran.h"
+#include "bind.h"
+#include <math.h>
+
 void cchol(int *n,int *nd,double *a,int *fail)
 {
 static int i,ia,j,k,ka;
@@ -431,7 +433,7 @@
 */
         p = (d[l]-d[l-1])/(2.0e0*e[l-1]);
         r = sqrt(1.0e0+p*p);
-        h = d[l-1]-e[l-1]/(p+fdsign(r,p));
+        h = d[l-1]-e[l-1]/(p+d_sign(r,p));
 /*
 */
         for(i=l; i<=*n; i++) {
Index: indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.h b/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.h	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.h	(date 1690767117645)
@@ -26,7 +26,7 @@
 #pragma warning(disable : 4251)
 #endif
 
-class DLLEXPORT IndigoFingerprint : public IndigoObject
+class INDIGO_EXPORT IndigoFingerprint : public IndigoObject
 {
 public:
     IndigoFingerprint();
Index: indigo-src/indigo/api/c/indigo/src/indigo_structure_checker.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_structure_checker.h b/indigo-src/indigo/api/c/indigo/src/indigo_structure_checker.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_structure_checker.h	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_structure_checker.h	(date 1690767117645)
@@ -28,7 +28,7 @@
 namespace indigo
 {
 
-    class DLLEXPORT IndigoStructureChecker : public StructureChecker
+    class INDIGO_EXPORT IndigoStructureChecker : public StructureChecker
     {
     public:
         IndigoStructureChecker();
Index: yaehmop-src/yaehmop/tightbind/cboris.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/yaehmop-src/yaehmop/tightbind/cboris.c b/yaehmop-src/yaehmop/tightbind/cboris.c
--- a/yaehmop-src/yaehmop/tightbind/cboris.c	(revision c81f41694bcffccf38e17a63627a862628294613)
+++ b/yaehmop-src/yaehmop/tightbind/cboris.c	(date 1689048276198)
@@ -2,7 +2,7 @@
 Produced by gmFortran V30.59(10/26/17) on 9/18/18 at 9:02:32
 */
 #define LPROTOTYPE
-#include "fortran.h"
+#include <math.h>
 void cboris(int *n,int *nd,double *a,double *b,double *c,double *d,double *e,
     double *f,int *fail)
 {
Index: indigo-src/indigo/api/c/indigo/src/indigo_match.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_match.h b/indigo-src/indigo/api/c/indigo/src/indigo_match.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_match.h	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_match.h	(date 1690767117645)
@@ -101,7 +101,7 @@
 };
 
 // Matcher class for matching queries on a specified target molecule
-class DLLEXPORT IndigoMoleculeSubstructureMatcher : public IndigoObject
+class INDIGO_EXPORT IndigoMoleculeSubstructureMatcher : public IndigoObject
 {
 public:
     enum
@@ -145,7 +145,7 @@
     MoleculeAtomNeighbourhoodCounters _nei_counters, _nei_counters_h_unfolded;
 };
 
-class DLLEXPORT IndigoReactionSubstructureMatcher : public IndigoObject
+class INDIGO_EXPORT IndigoReactionSubstructureMatcher : public IndigoObject
 {
 public:
     IndigoReactionSubstructureMatcher(Reaction& target);
@@ -164,8 +164,8 @@
     Array<int> mol_mapping;
 };
 
-DLLEXPORT bool _indigoParseTautomerFlags(const char* flags, IndigoTautomerParams& params);
-DLLEXPORT int _indigoParseExactFlags(const char* flags, bool reaction, float* rms_threshold);
+INDIGO_EXPORT bool _indigoParseTautomerFlags(const char* flags, IndigoTautomerParams& params);
+INDIGO_EXPORT int _indigoParseExactFlags(const char* flags, bool reaction, float* rms_threshold);
 
 #ifdef _WIN32
 #pragma warning(pop)
Index: indigo-src/indigo/api/c/indigo/src/indigo_properties.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_properties.h b/indigo-src/indigo/api/c/indigo/src/indigo_properties.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_properties.h	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_properties.h	(date 1690767117645)
@@ -25,7 +25,7 @@
     class PropertiesMap;
 }
 
-class DLLEXPORT IndigoProperty : public IndigoObject
+class INDIGO_EXPORT IndigoProperty : public IndigoObject
 {
 public:
     IndigoProperty(indigo::PropertiesMap& props, int idx);
Index: indigo-src/indigo/api/c/indigo/src/indigo_internal.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_internal.h b/indigo-src/indigo/api/c/indigo/src/indigo_internal.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_internal.h	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_internal.h	(date 1690767117645)
@@ -67,9 +67,7 @@
     typedef ObjArray<PropertiesMap> MonomersProperties;
 } // namespace indigo
 
-extern DLLEXPORT sf::safe_shared_hide_obj<IndigoOptionManager>& indigoGetOptionManager(const qword id = TL_GET_SESSION_ID());
-
-class DLLEXPORT IndigoObject
+class INDIGO_EXPORT IndigoObject
 {
 public:
     explicit IndigoObject(int type_);
@@ -228,7 +226,7 @@
     std::unique_ptr<std::pair<PtrArray<GROSS_UNITS>, PtrArray<GROSS_UNITS>>> gross;
 };
 
-struct DLLEXPORT ProductEnumeratorParams
+struct INDIGO_EXPORT ProductEnumeratorParams
 {
     ProductEnumeratorParams()
     {
@@ -255,7 +253,7 @@
     int max_product_count;
 };
 
-class DLLEXPORT Indigo
+class INDIGO_EXPORT Indigo
 {
 public:
     Indigo();
@@ -375,7 +373,7 @@
     int _indigo_id;
 };
 
-class DLLEXPORT IndigoPluginContext
+class INDIGO_EXPORT IndigoPluginContext
 {
 public:
     IndigoPluginContext();
@@ -414,9 +412,9 @@
     return fail;                                                                                                                                               \
     }
 
-DLLEXPORT Indigo& indigoGetInstance();
+INDIGO_EXPORT Indigo& indigoGetInstance();
 
-class DLLEXPORT IndigoError : public Exception
+class INDIGO_EXPORT IndigoError : public Exception
 {
 public:
     explicit IndigoError(const char* format, ...);
Index: yaehmop-src/yaehmop/tightbind/Zmat.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/yaehmop-src/yaehmop/tightbind/Zmat.c b/yaehmop-src/yaehmop/tightbind/Zmat.c
--- a/yaehmop-src/yaehmop/tightbind/Zmat.c	(revision c81f41694bcffccf38e17a63627a862628294613)
+++ b/yaehmop-src/yaehmop/tightbind/Zmat.c	(date 1689048276194)
@@ -60,6 +60,7 @@
   sprintf(err_string,"Can't find atom %d (of %d) in find_atom.\n",
           which,num_atoms);
   FATAL_BUG(err_string);
+  return -1;
 }
 
 
Index: openbabel-src/openbabel/src/fingerprints/finger3.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/fingerprints/finger3.cpp b/openbabel-src/openbabel/src/fingerprints/finger3.cpp
--- a/openbabel-src/openbabel/src/fingerprints/finger3.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/fingerprints/finger3.cpp	(date 1689048275866)
@@ -159,7 +159,7 @@
   bool ReadPatternFile(string& ver)
   {
     //Reads three types of file. See below
-    ifstream ifs;
+    istringstream ifs;
 	  stringstream errorMsg;
 
     if (OpenDatafile(ifs, _patternsfile).length() == 0)
@@ -238,8 +238,6 @@
       }
     }while(getline(ifs,line));
 
-    if (ifs)
-      ifs.close();
     return true;
   }
 
@@ -255,7 +253,8 @@
       int num =  ppat->numbits, div = ppat->numoccurrences+1, ngrp;
       while(num) //for each group of bits
       {
-        ngrp = (num + div -1)/div--; //rounds up
+        ngrp = (num + div -1)/div; //rounds up
+        --div;
         num -= ngrp;
         if(GetBit(fp, n) == bSet)
         {
Index: indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.h b/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.h	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.h	(date 1690767117645)
@@ -37,7 +37,7 @@
 class IndigoDeconvolutionElem;
 class IndigoDecompositionMatch;
 
-class DLLEXPORT IndigoDeconvolution : public IndigoObject
+class INDIGO_EXPORT IndigoDeconvolution : public IndigoObject
 {
 private:
     enum
@@ -143,7 +143,7 @@
     ObjArray<IndigoDeconvolutionElem> _deconvolutionElems;
 };
 
-class DLLEXPORT IndigoDeconvolutionElem : public IndigoObject
+class INDIGO_EXPORT IndigoDeconvolutionElem : public IndigoObject
 {
 public:
     IndigoDeconvolutionElem(Molecule& mol);
@@ -169,7 +169,7 @@
     indigo::PropertiesMap _properties;
 };
 
-class DLLEXPORT IndigoDecompositionMatch : public IndigoObject
+class INDIGO_EXPORT IndigoDecompositionMatch : public IndigoObject
 {
 public:
     IndigoDecompositionMatch();
@@ -205,7 +205,7 @@
     bool _completeScaffold;
 };
 
-class DLLEXPORT IndigoDeconvolutionIter : public IndigoObject
+class INDIGO_EXPORT IndigoDeconvolutionIter : public IndigoObject
 {
 public:
     IndigoDeconvolutionIter(ObjArray<IndigoDeconvolutionElem>& items);
@@ -218,7 +218,7 @@
     int _index;
     ObjArray<IndigoDeconvolutionElem>& _items;
 };
-class DLLEXPORT IndigoDecompositionMatchIter : public IndigoObject
+class INDIGO_EXPORT IndigoDecompositionMatchIter : public IndigoObject
 {
 public:
     IndigoDecompositionMatchIter(ObjArray<IndigoDecompositionMatch>& matches);
Index: indigo-src/indigo/api/c/indigo/src/indigo_savers.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_savers.h b/indigo-src/indigo/api/c/indigo/src/indigo_savers.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_savers.h	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_savers.h	(date 1690767117645)
@@ -26,7 +26,7 @@
 
 #include "indigo_internal.h"
 
-class DLLEXPORT IndigoSaver : public IndigoObject
+class INDIGO_EXPORT IndigoSaver : public IndigoObject
 {
 public:
     IndigoSaver(Output& output);
Index: yaehmop-src/yaehmop/tightbind/prototypes.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/yaehmop-src/yaehmop/tightbind/prototypes.h b/yaehmop-src/yaehmop/tightbind/prototypes.h
--- a/yaehmop-src/yaehmop/tightbind/prototypes.h	(revision c81f41694bcffccf38e17a63627a862628294613)
+++ b/yaehmop-src/yaehmop/tightbind/prototypes.h	(date 1689048276198)
@@ -136,7 +136,7 @@
 extern void eval_charge_matrix PROTO((cell_type *, eigenset_type,
                                       hermetian_matrix_type, int, int *, real *,
                                       real *));
-extern void reduced_charge_mat PROTO((int, int, int *, real *, real *));
+extern void reduced_charge_matrix PROTO((int, int, int *, real *, real *));
 extern void check_a_cell PROTO((atom_type *, point_type, int, real, char *));
 extern void check_nn_contacts PROTO((cell_type *, detail_type *details));
 extern void build_distance_matrix PROTO((cell_type *, detail_type *details));
Index: indigo-src/indigo/api/c/indigo/src/option_manager.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/option_manager.h b/indigo-src/indigo/api/c/indigo/src/option_manager.h
--- a/indigo-src/indigo/api/c/indigo/src/option_manager.h	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/option_manager.h	(date 1690767117645)
@@ -21,12 +21,13 @@
 
 #include "base_cpp/os_sync_wrapper.h"
 #include "base_cpp/red_black.h"
+#include "indigo.h"
 
 #include <sstream>
 
 using namespace indigo;
 
-#define DECL_SET_OPT_HANDLER(suffix, ftype, type, map) DLLEXPORT void setOptionHandler##suffix(const char* name, ftype func);
+#define DECL_SET_OPT_HANDLER(suffix, ftype, type, map) INDIGO_EXPORT void setOptionHandler##suffix(const char* name, ftype func);
 
 #define DEF_HANDLER(suffix, ftype, type, map)                                                                                                                  \
     void setOptionHandler##suffix(const char* name, ftype func)                                                                                                \
@@ -84,7 +85,7 @@
         value.push(0);                                                                                                                                         \
     }
 
-class DLLEXPORT IndigoOptionManager
+class INDIGO_EXPORT IndigoOptionManager
 {
 public:
     IndigoOptionManager() = default;
@@ -186,4 +187,7 @@
     IndigoOptionManager(const IndigoOptionManager&);
 };
 
+INDIGO_EXPORT sf::safe_shared_hide_obj<IndigoOptionManager> &
+indigoGetOptionManager(const qword id = TL_GET_SESSION_ID());
+
 #endif //__otion_manager_h__
Index: indigo-src/indigo/api/c/indigo/src/indigo_array.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_array.h b/indigo-src/indigo/api/c/indigo/src/indigo_array.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_array.h	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_array.h	(date 1690767117645)
@@ -26,7 +26,7 @@
 #pragma warning(disable : 4251)
 #endif
 
-class DLLEXPORT IndigoArray : public IndigoObject
+class INDIGO_EXPORT IndigoArray : public IndigoObject
 {
 public:
     IndigoArray();
@@ -41,7 +41,7 @@
     PtrArray<IndigoObject> objects;
 };
 
-class DLLEXPORT IndigoArrayElement : public IndigoObject
+class INDIGO_EXPORT IndigoArrayElement : public IndigoObject
 {
 public:
     IndigoArrayElement(IndigoArray& arr, int idx_);
Index: openbabel-src/openbabel/src/charges/eqeq.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/charges/eqeq.cpp b/openbabel-src/openbabel/src/charges/eqeq.cpp
--- a/openbabel-src/openbabel/src/charges/eqeq.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/charges/eqeq.cpp	(date 1689048275862)
@@ -15,7 +15,7 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 ***********************************************************************/
-
+#include <openbabel/babelconfig.h>
 #ifdef HAVE_EIGEN3
 
 #include "eqeq.h"
@@ -52,7 +52,7 @@
     char buffer[BUFF_SIZE];
 
     // open data/eqeqIonizations.txt
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "eqeqIonizations.txt").length() == 0)
     {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open eqeqIonizations.txt", obError);
Index: indigo-src/indigo/api/c/indigo/src/indigo_reaction.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_reaction.h b/indigo-src/indigo/api/c/indigo/src/indigo_reaction.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_reaction.h	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_reaction.h	(date 1690767117645)
@@ -29,7 +29,7 @@
 #pragma warning(disable : 4251)
 #endif
 
-class DLLEXPORT IndigoBaseReaction : public IndigoObject
+class INDIGO_EXPORT IndigoBaseReaction : public IndigoObject
 {
 public:
     explicit IndigoBaseReaction(int type_);
@@ -59,7 +59,7 @@
     indigo::PropertiesMap _properties;
 };
 
-class DLLEXPORT IndigoReaction : public IndigoBaseReaction
+class INDIGO_EXPORT IndigoReaction : public IndigoBaseReaction
 {
 public:
     IndigoReaction();
@@ -78,7 +78,7 @@
     Reaction rxn;
 };
 
-class DLLEXPORT IndigoQueryReaction : public IndigoBaseReaction
+class INDIGO_EXPORT IndigoQueryReaction : public IndigoBaseReaction
 {
 public:
     IndigoQueryReaction();
Index: openbabel-src/openbabel/src/charges/qtpie.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/charges/qtpie.cpp b/openbabel-src/openbabel/src/charges/qtpie.cpp
--- a/openbabel-src/openbabel/src/charges/qtpie.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/charges/qtpie.cpp	(date 1689048275866)
@@ -15,7 +15,7 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 ***********************************************************************/
-
+#include <openbabel/babelconfig.h>
 #ifdef HAVE_EIGEN
 
 #include "qtpie.h"
@@ -117,7 +117,7 @@
     char buffer[BUFF_SIZE];
 
     // open data/qeq.txt
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "qeq.txt").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open qeq.txt", obError);
       return;
Index: indigo-src/indigo/api/c/indigo/src/indigo_molecule.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_molecule.h b/indigo-src/indigo/api/c/indigo/src/indigo_molecule.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_molecule.h	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_molecule.h	(date 1690767117645)
@@ -33,7 +33,7 @@
 #include "molecule/molecule_neighbourhood_counters.h"
 #include "molecule/query_molecule.h"
 
-class DLLEXPORT IndigoBaseMolecule : public IndigoObject
+class INDIGO_EXPORT IndigoBaseMolecule : public IndigoObject
 {
 public:
     explicit IndigoBaseMolecule(int type_);
@@ -52,7 +52,7 @@
     indigo::PropertiesMap _properties;
 };
 
-class DLLEXPORT IndigoQueryMolecule : public IndigoBaseMolecule
+class INDIGO_EXPORT IndigoQueryMolecule : public IndigoBaseMolecule
 {
 public:
     IndigoQueryMolecule();
@@ -80,7 +80,7 @@
     int _nei_counters_edit_revision;
 };
 
-class DLLEXPORT IndigoMolecule : public IndigoBaseMolecule
+class INDIGO_EXPORT IndigoMolecule : public IndigoBaseMolecule
 {
 public:
     IndigoMolecule();
@@ -102,7 +102,7 @@
     Molecule mol;
 };
 
-class DLLEXPORT IndigoAtom : public IndigoObject
+class INDIGO_EXPORT IndigoAtom : public IndigoObject
 {
 public:
     IndigoAtom(BaseMolecule& mol_, int idx_);
@@ -122,7 +122,7 @@
     const char* debugInfo() const override;
 };
 
-class DLLEXPORT IndigoRGroup : public IndigoObject
+class INDIGO_EXPORT IndigoRGroup : public IndigoObject
 {
 public:
     IndigoRGroup();
@@ -136,7 +136,7 @@
     int idx;
 };
 
-class DLLEXPORT IndigoRGroupFragment : public IndigoObject
+class INDIGO_EXPORT IndigoRGroupFragment : public IndigoObject
 {
 public:
     IndigoRGroupFragment(IndigoRGroup& rgp, int idx);
@@ -156,7 +156,7 @@
     int frag_idx;
 };
 
-class DLLEXPORT IndigoBond : public IndigoObject
+class INDIGO_EXPORT IndigoBond : public IndigoObject
 {
 public:
     IndigoBond(BaseMolecule& mol_, int idx_);
Index: eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h b/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h
--- a/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	(revision 3147391d946bb4b6c68edd901f2add6ac1f31f8c)
+++ b/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	(date 1690172759590)
@@ -207,7 +207,11 @@
     // block_count leaves that do actual computations.
     Barrier barrier(static_cast<unsigned int>(block.count));
     std::function<void(Index, Index)> handleRange;
+#if __cplusplus >= 202002L
+    handleRange = [=, &handleRange, &barrier, &f, this](Index firstIdx,
+#else
     handleRange = [=, &handleRange, &barrier, &f](Index firstIdx,
+#endif
                                                   Index lastIdx) {
       while (lastIdx - firstIdx > block.size) {
         // Split into halves and schedule the second half on a different thread.
Index: inchi-src/inchi/INCHI_BASE/src/inchi_api.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_BASE/src/inchi_api.h b/inchi-src/inchi/INCHI_BASE/src/inchi_api.h
--- a/inchi-src/inchi/INCHI_BASE/src/inchi_api.h	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_BASE/src/inchi_api.h	(date 1690938866070)
@@ -681,23 +681,17 @@
  *************************************************/
 
 
-#if (defined( _WIN32 ) && defined( _MSC_VER ) && defined(BUILD_LINK_AS_DLL) )
-    /* Win32 & MS VC ++, compile and link as a DLL */
-#ifdef _USRDLL
-    /* InChI library dll */
-#define INCHI_API __declspec(dllexport)
-#define EXPIMP_TEMPLATE
-#define INCHI_DECL
-#else
-   /* calling the InChI dll program */
-#define INCHI_API __declspec(dllimport)
+#include "inchi_export.h"
+
+#ifdef _MSC_VER
 #define EXPIMP_TEMPLATE extern
-#define INCHI_DECL
-#endif
 #else
-    /* create a statically linked InChI library or link to an executable */
-#define INCHI_API
 #define EXPIMP_TEMPLATE
+#endif
+#ifndef INCHI_API
+#define INCHI_API INCHI_EXPORT
+#endif
+#ifndef INCHI_DECL
 #define INCHI_DECL
 #endif
 
Index: openbabel-src/openbabel/src/charges/eem.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/charges/eem.cpp b/openbabel-src/openbabel/src/charges/eem.cpp
--- a/openbabel-src/openbabel/src/charges/eem.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/charges/eem.cpp	(date 1689048275862)
@@ -92,7 +92,7 @@
 
   void EEMCharges::_loadParameters()
   {
-    std::ifstream ifs;
+    std::istringstream ifs;
     if (!OpenDatafile(ifs, _parameters_file).length()) {
       obErrorLog.ThrowError(__FUNCTION__, std::string("Cannot open file with parameters: ").append(_parameters_file), obError);
       return;
Index: pixman-src/pixman/pixman/pixman-version.h.in
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pixman-src/pixman/pixman/pixman-version.h.in b/pixman-src/pixman/pixman/pixman-version.h.in
--- a/pixman-src/pixman/pixman/pixman-version.h.in	(revision 37216a32839f59e8dcaa4c3951b3fcfc3f07852c)
+++ b/pixman-src/pixman/pixman/pixman-version.h.in	(date 1689048276054)
@@ -27,6 +27,7 @@
 #ifndef PIXMAN_VERSION_H__
 #define PIXMAN_VERSION_H__
 
+#include "pixman_export.h"
 #ifndef PIXMAN_H__
 #  error pixman-version.h should only be included by pixman.h
 #endif
@@ -48,7 +49,7 @@
 	PIXMAN_VERSION_MICRO)
 
 #ifndef PIXMAN_API
-# define PIXMAN_API
+# define PIXMAN_API PIXMAN_EXPORT
 #endif
 
 #endif /* PIXMAN_VERSION_H__ */
Index: indigo-src/indigo/api/c/bingo-nosql/bingo-nosql.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/bingo-nosql/bingo-nosql.h b/indigo-src/indigo/api/c/bingo-nosql/bingo-nosql.h
--- a/indigo-src/indigo/api/c/bingo-nosql/bingo-nosql.h	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/bingo-nosql/bingo-nosql.h	(date 1690938866070)
@@ -20,63 +20,64 @@
 #define __indigo_bingo__
 
 #include "indigo.h"
+#include "bingo_nosql_export.h"
 
-CEXPORT const char* bingoVersion();
+BINGO_NOSQL_EXPORT const char* bingoVersion();
 
 // options = "id: <property-name>"
-CEXPORT int bingoCreateDatabaseFile(const char* location, const char* type, const char* options);
-CEXPORT int bingoLoadDatabaseFile(const char* location, const char* options);
-CEXPORT int bingoCloseDatabase(int db);
+BINGO_NOSQL_EXPORT int bingoCreateDatabaseFile(const char* location, const char* type, const char* options);
+BINGO_NOSQL_EXPORT int bingoLoadDatabaseFile(const char* location, const char* options);
+BINGO_NOSQL_EXPORT int bingoCloseDatabase(int db);
 
 //
 // Record insertion/deletion
 //
-CEXPORT int bingoInsertRecordObj(int db, int obj);
-CEXPORT int bingoInsertIteratorObj(int db, int iterator_obj_id);
-CEXPORT int bingoInsertRecordObjWithId(int db, int obj, int id);
-CEXPORT int bingoInsertRecordObjWithExtFP(int db, int obj, int fp);
-CEXPORT int bingoInsertRecordObjWithIdAndExtFP(int db, int obj, int id, int fp);
-CEXPORT int bingoDeleteRecord(int db, int id);
-CEXPORT int bingoGetRecordObj(int db, int id);
+BINGO_NOSQL_EXPORT int bingoInsertRecordObj(int db, int obj);
+BINGO_NOSQL_EXPORT int bingoInsertIteratorObj(int db, int iterator_obj_id);
+BINGO_NOSQL_EXPORT int bingoInsertRecordObjWithId(int db, int obj, int id);
+BINGO_NOSQL_EXPORT int bingoInsertRecordObjWithExtFP(int db, int obj, int fp);
+BINGO_NOSQL_EXPORT int bingoInsertRecordObjWithIdAndExtFP(int db, int obj, int id, int fp);
+BINGO_NOSQL_EXPORT int bingoDeleteRecord(int db, int id);
+BINGO_NOSQL_EXPORT int bingoGetRecordObj(int db, int id);
 
-CEXPORT int bingoOptimize(int db);
+BINGO_NOSQL_EXPORT int bingoOptimize(int db);
 
 // Search methods that returns search object
 // Search object is an iterator
-CEXPORT int bingoSearchSub(int db, int query_obj, const char* options);
-CEXPORT int bingoSearchExact(int db, int query_obj, const char* options);
-CEXPORT int bingoSearchMolFormula(int db, const char* query, const char* options);
-CEXPORT int bingoSearchSim(int db, int query_obj, float min, float max, const char* options);
-CEXPORT int bingoSearchSimWithExtFP(int db, int query_obj, float min, float max, int fp, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchSub(int db, int query_obj, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchExact(int db, int query_obj, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchMolFormula(int db, const char* query, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchSim(int db, int query_obj, float min, float max, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchSimWithExtFP(int db, int query_obj, float min, float max, int fp, const char* options);
 
-CEXPORT int bingoSearchSimTopN(int db, int query_obj, int limit, float min, const char* options);
-CEXPORT int bingoSearchSimTopNWithExtFP(int db, int query_obj, int limit, float min, int fp, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchSimTopN(int db, int query_obj, int limit, float min, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchSimTopNWithExtFP(int db, int query_obj, int limit, float min, int fp, const char* options);
 
-CEXPORT int bingoEnumerateId(int db);
+BINGO_NOSQL_EXPORT int bingoEnumerateId(int db);
 
 //
 // Search object methods
 //
-CEXPORT int bingoNext(int search_obj);
-CEXPORT int bingoGetCurrentId(int search_obj);
-CEXPORT float bingoGetCurrentSimilarityValue(int search_obj);
+BINGO_NOSQL_EXPORT int bingoNext(int search_obj);
+BINGO_NOSQL_EXPORT int bingoGetCurrentId(int search_obj);
+BINGO_NOSQL_EXPORT float bingoGetCurrentSimilarityValue(int search_obj);
 
 // Estimation methods
-CEXPORT int bingoEstimateRemainingResultsCount(int search_obj);
-CEXPORT int bingoEstimateRemainingResultsCountError(int search_obj);
-CEXPORT int bingoEstimateRemainingTime(int search_obj, float* time_sec);
-CEXPORT int bingoContainersCount(int search_obj);
-CEXPORT int bingoCellsCount(int search_obj);
-CEXPORT int bingoCurrentCell(int search_obj);
-CEXPORT int bingoMinCell(int search_obj);
-CEXPORT int bingoMaxCell(int search_obj);
+BINGO_NOSQL_EXPORT int bingoEstimateRemainingResultsCount(int search_obj);
+BINGO_NOSQL_EXPORT int bingoEstimateRemainingResultsCountError(int search_obj);
+BINGO_NOSQL_EXPORT int bingoEstimateRemainingTime(int search_obj, float* time_sec);
+BINGO_NOSQL_EXPORT int bingoContainersCount(int search_obj);
+BINGO_NOSQL_EXPORT int bingoCellsCount(int search_obj);
+BINGO_NOSQL_EXPORT int bingoCurrentCell(int search_obj);
+BINGO_NOSQL_EXPORT int bingoMinCell(int search_obj);
+BINGO_NOSQL_EXPORT int bingoMaxCell(int search_obj);
 
 // This method return IndigoObject that represents current object.
 // After calling bingoNext this object automatically points to the next found result
-CEXPORT int bingoGetObject(int search_obj);
+BINGO_NOSQL_EXPORT int bingoGetObject(int search_obj);
 
-CEXPORT int bingoEndSearch(int search_obj);
+BINGO_NOSQL_EXPORT int bingoEndSearch(int search_obj);
 
-CEXPORT const char* bingoProfilingGetStatistics(int for_session);
+BINGO_NOSQL_EXPORT const char* bingoProfilingGetStatistics(int for_session);
 
 #endif // __indigo_bingo__
Index: openbabel-src/openbabel/src/charges/qeq.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/charges/qeq.cpp b/openbabel-src/openbabel/src/charges/qeq.cpp
--- a/openbabel-src/openbabel/src/charges/qeq.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/charges/qeq.cpp	(date 1689048275866)
@@ -15,7 +15,7 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 ***********************************************************************/
-
+#include <openbabel/babelconfig.h>
 #ifdef HAVE_EIGEN
 
 #include "qeq.h"
@@ -125,7 +125,7 @@
     char buffer[BUFF_SIZE];
 
     // open data/qeq.txt
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "qeq.txt").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open qeq.txt", obError);
       return;
Index: openbabel-src/openbabel/src/ops/unique.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/ops/unique.cpp b/openbabel-src/openbabel/src/ops/unique.cpp
--- a/openbabel-src/openbabel/src/ops/unique.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/ops/unique.cpp	(date 1689048275890)
@@ -39,7 +39,7 @@
   #ifdef _LIBCPP_VERSION
     using std::unordered_map;
   #else
-    using std::tr1::unordered_map;
+    using std::unordered_map;
   #endif
 #endif
 namespace OpenBabel
Index: rdkit-src/rdkit/Contrib/PBF/PBFRDKit.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Contrib/PBF/PBFRDKit.cpp b/rdkit-src/rdkit/Contrib/PBF/PBFRDKit.cpp
--- a/rdkit-src/rdkit/Contrib/PBF/PBFRDKit.cpp	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Contrib/PBF/PBFRDKit.cpp	(date 1689048276162)
@@ -114,7 +114,7 @@
   if (eigensolver.info() != Eigen::Success) {
     BOOST_LOG(rdErrorLog) << "eigenvalue calculation did not converge"
                           << std::endl;
-    return 0.0;
+    return false;
   }
   RDGeom::Point3D normal;
   normal.x = eigensolver.eigenvectors()(0, 0);
@@ -125,6 +125,7 @@
   plane[1] = normal.y;
   plane[2] = normal.z;
   plane[3] = -1 * normal.dotProduct(origin);
+  return true;
 }
 
 double PBFRD(ROMol &mol, int confId) {
Index: openbabel-src/openbabel/src/ops/op2d.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/ops/op2d.cpp b/openbabel-src/openbabel/src/ops/op2d.cpp
--- a/openbabel-src/openbabel/src/ops/op2d.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/ops/op2d.cpp	(date 1689048275890)
@@ -25,12 +25,13 @@
 #include <openbabel/babelconfig.h>
 #include <iostream>
 #include<openbabel/op.h>
+#include<openbabel/atom.h>
 #include<openbabel/mol.h>
+#include<openbabel/oberror.h>
 #include <RDKitConv.h>
 #include <GraphMol/Depictor/RDDepictor.h>
 #include <Geometry/point.h>
-#include <GraphMol/conformer.h>
-#include <GraphMol/molops.h>
+#include <GraphMol/MolOps.h>
 
 #ifndef OBERROR
  #define OBERROR
@@ -49,13 +50,13 @@
   }
   virtual bool WorksWith(OBBase* pOb)const{ return dynamic_cast<OBMol*>(pOb)!=NULL; }
 
-  virtual bool Do(OBBase* pOb, OpMap*, const char* OptionText);
+  virtual bool Do(OBBase* pOb, const char*, OpMap*, OBConversion*);
 };
 
 Op2D theOp2D("2D"); //Global instance
 
 /////////////////////////////////////////////////////////////////
-bool Op2D::Do(OBBase* pOb, OpMap*, const char* OptionText)
+bool Op2D::Do(OBBase* pOb, const char*, OpMap*, OBConversion*)
 {
   OBMol* pmol = dynamic_cast<OBMol*>(pOb);
   if(!pmol)
Index: openbabel-src/openbabel/src/ops/loader.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/ops/loader.cpp b/openbabel-src/openbabel/src/ops/loader.cpp
--- a/openbabel-src/openbabel/src/ops/loader.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/ops/loader.cpp	(date 1689048275890)
@@ -35,11 +35,6 @@
   const char* TypeID(){return "loaders";};
 };
 
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-// macro to implement static OBPlugin::PluginMapType& Map()
-PLUGIN_CPP_FILE(OBLoader)
-#endif
-
 //*********************************************************
 ///Class which makes instances of plugin classes from information in text file.
 ///This allows the commandline and GUI interfaces to be extended without recompiling.
@@ -55,7 +50,7 @@
   OBDefine(const char* ID, const char* filename)
     : OBLoader(ID, false), _filename(filename)
   {
-    ifstream ifs;
+    istringstream ifs;
     bool filefound = !OpenDatafile(ifs, filename).empty();
     if(!ifs)
     {
Index: rdkit-src/rdkit/External/GA/util/Util.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/External/GA/util/Util.cpp b/rdkit-src/rdkit/External/GA/util/Util.cpp
--- a/rdkit-src/rdkit/External/GA/util/Util.cpp	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/External/GA/util/Util.cpp	(date 1689048276162)
@@ -40,18 +40,7 @@
 }
 
 string getUserName() {
-#ifdef WIN32
-  return "UNKNOWN";
-#else
-  const int bufsize = 100;
-  char buffer[bufsize];
-
-  if (!getlogin_r(buffer, bufsize)) {
-    return string(buffer);
-  } else {
-    return string("");
-  }
-#endif
+    return "UNKNOWN";
 }
 
 string &removeTrailingLF(string &line) {
Index: rdkit-src/rdkit/External/GA/ga/GaBase.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/External/GA/ga/GaBase.cpp b/rdkit-src/rdkit/External/GA/ga/GaBase.cpp
new file mode 100644
--- /dev/null	(date 1689048276162)
+++ b/rdkit-src/rdkit/External/GA/ga/GaBase.cpp	(date 1689048276162)
@@ -0,0 +1,9 @@
+#include "GaBase.h"
+
+using namespace GapeGa;
+
+GaBase::GaBase() {
+};
+
+GaBase::~GaBase() {
+};
\ No newline at end of file
Index: openbabel-src/openbabel/src/ops/sort.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/ops/sort.cpp b/openbabel-src/openbabel/src/ops/sort.cpp
--- a/openbabel-src/openbabel/src/ops/sort.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/ops/sort.cpp	(date 1689048275890)
@@ -29,7 +29,7 @@
 {
 
 template<class T>
-struct Order : public std::binary_function<std::pair<OBBase*,T>, std::pair<OBBase*,T>, bool>
+struct Order
 {
   Order(OBDescriptor* pDesc, bool rev) : _pDesc(pDesc), _rev(rev){}
   bool operator()(std::pair<OBBase*,T> p1, std::pair<OBBase*,T> p2) const
Index: openbabel-src/openbabel/src/ops/optransform.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/ops/optransform.cpp b/openbabel-src/openbabel/src/ops/optransform.cpp
--- a/openbabel-src/openbabel/src/ops/optransform.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/ops/optransform.cpp	(date 1689048275890)
@@ -40,9 +40,7 @@
 {
   _dataLoaded=true;
   _transforms.clear();
-  ifstream ifs;
-  if(ifs.is_open())
-    ifs.close();
+  istringstream ifs;
   char charBuffer[BUFF_SIZE];
 
   // Set the locale for number parsing to avoid locale issues: PR#1785463
Index: maeparser-src/maeparser/MaeParserConfig.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/maeparser-src/maeparser/MaeParserConfig.hpp b/maeparser-src/maeparser/MaeParserConfig.hpp
--- a/maeparser-src/maeparser/MaeParserConfig.hpp	(revision bfa41f087a92b72370893c9b36758487a18dc6a0)
+++ b/maeparser-src/maeparser/MaeParserConfig.hpp	(date 1689048275794)
@@ -1,21 +1,7 @@
 #pragma once
 
-#ifndef STATIC_MAEPARSER
-
-#ifdef WIN32
-#ifdef IN_MAEPARSER
-#define EXPORT_MAEPARSER __declspec(dllexport)
-#else
-#define EXPORT_MAEPARSER __declspec(dllimport)
-#endif // IN_MAEPARSER
+#include <maeparser_export.hpp>
 
-#else
-
-#define EXPORT_MAEPARSER __attribute__((visibility("default")))
-#endif // WIN32
-
-#else
-
-#define EXPORT_MAEPARSER
-
-#endif // STATIC_MAEPARSER
+#ifndef EXPORT_MAEPARSER
+#define EXPORT_MAEPARSER MAEPARSER_EXPORT
+#endif
Index: openbabel-src/openbabel/src/plugin.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/plugin.cpp b/openbabel-src/openbabel/src/plugin.cpp
--- a/openbabel-src/openbabel/src/plugin.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/plugin.cpp	(date 1690877942623)
@@ -285,6 +285,8 @@
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theHINFormat)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theJaguarOutputFormat)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theJaguarInputFormat)->GetID());
+  plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theChemDoodleJSONFormat)->GetID());
+  plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&thePubChemJSONFormat)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theLMPDATFormat)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theMCDLFormat)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theMOLFormat)->GetID());
@@ -315,6 +317,7 @@
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&thePDBQTFormat)->GetID());
 #ifdef HAVE_LIBZ
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&thePNGFormat)->GetID());
+  plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&thePNG2Format)->GetID());
 #endif
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&thePointCloudFormat)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&thePovrayFormat)->GetID());
@@ -354,6 +357,8 @@
 #endif
 #ifdef HAVE_STATIC_INCHI
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theInChIFormat)->GetID());
+  plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theInChICompareFormat)->GetID());
+  plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theInChIKeyFormat)->GetID());
 #endif
 #ifdef HAVE_RPC_XDR_H
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theXTCFormat)->GetID());
@@ -413,6 +418,7 @@
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOpFillUC)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOpEnergy)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOpMinimize)->GetID());
+  plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOp2D)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOpGen2D)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOpGen3D)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOpNewS)->GetID());
Index: openbabel-src/openbabel/src/ops/gen3d.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/ops/gen3d.cpp b/openbabel-src/openbabel/src/ops/gen3d.cpp
--- a/openbabel-src/openbabel/src/ops/gen3d.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/ops/gen3d.cpp	(date 1689048275890)
@@ -70,8 +70,10 @@
   bool useDistGeom = false;
 
   // first try converting OptionText to an integer
-  char *endptr;
-  speed = strtol(OptionText, &endptr, 10);
+  char *endptr = nullptr;
+  if (OptionText) {
+    speed = strtol(OptionText, &endptr, 10);
+  }
   if (endptr == OptionText) { // not a number
     speed = 3; // we'll default to balanced
     // but let's also check if it's words like "fast" or "best"
@@ -131,12 +133,12 @@
       return true; // done
 
     // All other speed levels do some FF cleanup
-    // Try MMFF94 first and UFF if that doesn't work
-    OBForceField* pFF = OBForceField::FindForceField("MMFF94");
+    // Try UFF first and MMFF94 if that doesn't work
+    OBForceField* pFF = OBForceField::FindForceField("UFF");
     if (!pFF)
       return true;
     if (!pFF->Setup(molCopy)) {
-      pFF = OBForceField::FindForceField("UFF");
+      pFF = OBForceField::FindForceField("MMFF94");
       if (!pFF || !pFF->Setup(molCopy)) return true; // can't use either MMFF94 or UFF
     }
 
Index: indigo-src/indigo/api/c/indigo-renderer/indigo-renderer.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo-renderer/indigo-renderer.h b/indigo-src/indigo/api/c/indigo-renderer/indigo-renderer.h
--- a/indigo-src/indigo/api/c/indigo-renderer/indigo-renderer.h	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo-renderer/indigo-renderer.h	(date 1690938866070)
@@ -20,34 +20,35 @@
 #define __indigo_render__
 
 #include "indigo.h"
+#include "indigo_renderer_export.h"
 
-CEXPORT int indigoRendererInit(qword id);
-CEXPORT int indigoRendererDispose(qword id);
+INDIGO_RENDERER_EXPORT int indigoRendererInit(qword id);
+INDIGO_RENDERER_EXPORT int indigoRendererDispose(qword id);
 
 /* Rendering */
 
 // Returns an 'output' object for the given HDC
-CEXPORT int indigoRenderWriteHDC(void* hdc, int printingHdc);
+INDIGO_RENDERER_EXPORT int indigoRenderWriteHDC(void* hdc, int printingHdc);
 
 // output is either a file output obtained via indigoWriteFile(), or
 //        a buffer obtained via indigoWriteBuffer(), or
 //        an HDC obtained via indigoRenderWriteHDC
-CEXPORT int indigoRender(int object, int output);
+INDIGO_RENDERER_EXPORT int indigoRender(int object, int output);
 
 // objects  is an array of molecules created with indigoCreateArray)
 // refAtoms is an array of integers, whose size must be equal to the number
 //          of molecules if the array
 // nColumns is the number of columns in the grid
 // output -- see the comment for indigoRender
-CEXPORT int indigoRenderGrid(int objects, int* refAtoms, int nColumns, int output);
+INDIGO_RENDERER_EXPORT int indigoRenderGrid(int objects, int* refAtoms, int nColumns, int output);
 
 // Works like indigoRender(), but renders directly to file
-CEXPORT int indigoRenderToFile(int object, const char* filename);
+INDIGO_RENDERER_EXPORT int indigoRenderToFile(int object, const char* filename);
 
 // Works like indigoRenderGrid(), but renders directly to file
-CEXPORT int indigoRenderGridToFile(int objects, int* refAtoms, int nColumns, const char* filename);
+INDIGO_RENDERER_EXPORT int indigoRenderGridToFile(int objects, int* refAtoms, int nColumns, const char* filename);
 
 // Resets all the rendering settings
-CEXPORT int indigoRenderReset();
+INDIGO_RENDERER_EXPORT int indigoRenderReset();
 
 #endif
Index: indigo-src/indigo/api/c/indigo-inchi/indigo-inchi.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo-inchi/indigo-inchi.h b/indigo-src/indigo/api/c/indigo-inchi/indigo-inchi.h
--- a/indigo-src/indigo/api/c/indigo-inchi/indigo-inchi.h	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo-inchi/indigo-inchi.h	(date 1690938866070)
@@ -20,24 +20,25 @@
 #define __indigo_inchi__
 
 #include "indigo.h"
+#include "indigo_inchi_export.h"
 
-CEXPORT const char* indigoInchiVersion();
+INDIGO_INCHI_EXPORT const char *indigoInchiVersion();
 
-CEXPORT int indigoInchiInit(qword id);
-CEXPORT int indigoInchiDispose(qword id);
+INDIGO_INCHI_EXPORT int indigoInchiInit(qword id);
+INDIGO_INCHI_EXPORT int indigoInchiDispose(qword id);
 
-CEXPORT int indigoInchiResetOptions();
+INDIGO_INCHI_EXPORT int indigoInchiResetOptions();
 
-CEXPORT int indigoInchiLoadMolecule(const char* inchi_string);
+INDIGO_INCHI_EXPORT int indigoInchiLoadMolecule(const char *inchi_string);
 
-CEXPORT const char* indigoInchiGetInchi(int molecule);
+INDIGO_INCHI_EXPORT const char *indigoInchiGetInchi(int molecule);
 
-CEXPORT const char* indigoInchiGetInchiKey(const char* inchi_string);
+INDIGO_INCHI_EXPORT const char *indigoInchiGetInchiKey(const char *inchi_string);
 
-CEXPORT const char* indigoInchiGetWarning();
+INDIGO_INCHI_EXPORT const char *indigoInchiGetWarning();
 
-CEXPORT const char* indigoInchiGetLog();
+INDIGO_INCHI_EXPORT const char *indigoInchiGetLog();
 
-CEXPORT const char* indigoInchiGetAuxInfo();
+INDIGO_INCHI_EXPORT const char *indigoInchiGetAuxInfo();
 
 #endif // __indigo_inchi__
Index: openbabel-src/openbabel/src/distgeom.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/distgeom.cpp b/openbabel-src/openbabel/src/distgeom.cpp
--- a/openbabel-src/openbabel/src/distgeom.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/distgeom.cpp	(date 1689048275866)
@@ -16,7 +16,7 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 ***********************************************************************/
-
+#include <openbabel/babelconfig.h>
 #ifdef HAVE_EIGEN
 
 #include <openbabel/distgeom.h>
Index: coordgen-src/coordgen/CoordgenConfig.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/coordgen-src/coordgen/CoordgenConfig.hpp b/coordgen-src/coordgen/CoordgenConfig.hpp
--- a/coordgen-src/coordgen/CoordgenConfig.hpp	(revision c4dd5b0e1f1971c06c7ab85725c185e47211814e)
+++ b/coordgen-src/coordgen/CoordgenConfig.hpp	(date 1689048275306)
@@ -1,22 +1,7 @@
 #pragma once
 
-#ifndef STATIC_COORDGEN
-
-#ifdef WIN32
-#ifdef IN_COORDGEN
-#define EXPORT_COORDGEN __declspec(dllexport)
-#else
-#define EXPORT_COORDGEN __declspec(dllimport)
-#endif // IN_COORDGEN
-
-#else
-
-#define EXPORT_COORDGEN __attribute__((visibility("default")))
-
-#endif // WIN32
+#include <coordgenlibs_export.hpp>
 
-#else
-
-#define EXPORT_COORDGEN
-
-#endif // STATIC_COORDGEN
+#ifndef EXPORT_COORDGEN
+#define EXPORT_COORDGEN COORDGENLIBS_EXPORT
+#endif
Index: openbabel-src/openbabel/src/stereo/perception.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/stereo/perception.cpp b/openbabel-src/openbabel/src/stereo/perception.cpp
--- a/openbabel-src/openbabel/src/stereo/perception.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/stereo/perception.cpp	(date 1689048275890)
@@ -2969,9 +2969,6 @@
   }
 
   void StereoRefToImplicit(OBMol& mol, OBStereo::Ref atomId) {
-    // The following is for use in replace_if(...) below
-    const std::binder1st<std::equal_to<OBStereo::Ref> > equal_to_atomId = std::bind1st (equal_to<OBStereo::Ref>(), atomId);
-
     std::vector<OBGenericData*> vdata = mol.GetAllData(OBGenericDataType::StereoData);
     for (std::vector<OBGenericData*>::iterator data = vdata.begin(); data != vdata.end(); ++data) {
       OBStereo::Type datatype = ((OBStereoBase*)*data)->GetType();
@@ -2987,23 +2984,20 @@
       if (datatype == OBStereo::CisTrans) {
         OBCisTransStereo *ct = dynamic_cast<OBCisTransStereo*>(*data);
         OBCisTransStereo::Config ct_cfg = ct->GetConfig();
-        replace_if(ct_cfg.refs.begin(), ct_cfg.refs.end(), equal_to_atomId, (OBStereo::Ref) OBStereo::ImplicitRef);
+        replace(ct_cfg.refs.begin(), ct_cfg.refs.end(), atomId, (OBStereo::Ref) OBStereo::ImplicitRef);
         ct->SetConfig(ct_cfg);
       }
       else if (datatype == OBStereo::Tetrahedral) {
         OBTetrahedralStereo *ts = dynamic_cast<OBTetrahedralStereo*>(*data);
         OBTetrahedralStereo::Config ts_cfg = ts->GetConfig();
         if (ts_cfg.from == atomId) ts_cfg.from = OBStereo::ImplicitRef;
-        replace_if(ts_cfg.refs.begin(), ts_cfg.refs.end(), equal_to_atomId, (OBStereo::Ref) OBStereo::ImplicitRef);
+        replace(ts_cfg.refs.begin(), ts_cfg.refs.end(), atomId, (OBStereo::Ref) OBStereo::ImplicitRef);
         ts->SetConfig(ts_cfg);
       }
     }
   }
 
   void ImplicitRefToStereo(OBMol& mol, OBStereo::Ref centerId, OBStereo::Ref newId) {
-    // The following is for use in replace_if(...) below
-    const std::binder1st<std::equal_to<OBStereo::Ref> > equal_to_implicitRef = std::bind1st (equal_to<OBStereo::Ref>(), (OBStereo::Ref) OBStereo::ImplicitRef);
-
     std::vector<OBGenericData*> vdata = mol.GetAllData(OBGenericDataType::StereoData);
     for (std::vector<OBGenericData*>::iterator data = vdata.begin(); data != vdata.end(); ++data) {
       OBStereo::Type datatype = ((OBStereoBase*)*data)->GetType();
@@ -3022,9 +3016,9 @@
         if (ct_cfg.begin == centerId || ct_cfg.end == centerId) {
           // Assumption: the first two refs are on the begin atom, the last two on the end atom
           if (ct_cfg.begin == centerId)
-            replace_if(ct_cfg.refs.begin(), ct_cfg.refs.begin()+2, equal_to_implicitRef, (OBStereo::Ref) newId);
+            replace(ct_cfg.refs.begin(), ct_cfg.refs.begin()+2, (OBStereo::Ref) OBStereo::ImplicitRef, (OBStereo::Ref) newId);
           if (ct_cfg.end == centerId)
-            replace_if(ct_cfg.refs.begin()+2, ct_cfg.refs.end(), equal_to_implicitRef, (OBStereo::Ref) newId);
+            replace(ct_cfg.refs.begin()+2, ct_cfg.refs.end(), (OBStereo::Ref) OBStereo::ImplicitRef, (OBStereo::Ref) newId);
           ct->SetConfig(ct_cfg);
         }
       }
@@ -3033,7 +3027,7 @@
         OBTetrahedralStereo::Config ts_cfg = ts->GetConfig();
         if (ts_cfg.center == centerId) {
           if (ts_cfg.from == OBStereo::ImplicitRef) ts_cfg.from = newId;
-          replace_if(ts_cfg.refs.begin(), ts_cfg.refs.end(), equal_to_implicitRef, (OBStereo::Ref) newId);
+          replace(ts_cfg.refs.begin(), ts_cfg.refs.end(), (OBStereo::Ref) OBStereo::ImplicitRef, (OBStereo::Ref) newId);
           ts->SetConfig(ts_cfg);
         }
       }
Index: eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h b/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h
--- a/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	(revision 3147391d946bb4b6c68edd901f2add6ac1f31f8c)
+++ b/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	(date 1690172759598)
@@ -1006,7 +1006,11 @@
       } else {
         eigen_assert(!use_thread_local);
         device_.enqueueNoNotification(
+#if __cplusplus >= 202002L
+            [=, this]() { kernel(m, n, k, use_thread_local); });
+#else
             [=]() { kernel(m, n, k, use_thread_local); });
+#endif
       }
     }
 
@@ -1060,7 +1064,11 @@
         while (end - start > 1) {
           Index mid = (start + end) / 2;
           device_.enqueueNoNotification(
+#if __cplusplus >= 202002L
+              [=, this]() { enqueue_packing_helper(mid, end, k, rhs); });
+#else
               [=]() { enqueue_packing_helper(mid, end, k, rhs); });
+#endif
           end = mid;
         }
 
@@ -1079,7 +1087,11 @@
 
         if (pack_async) {
           device_.enqueueNoNotification(
+#if __cplusplus >= 202002L
+              [=, this]() { enqueue_packing_helper(start, end, k, rhs); });
+#else
               [=]() { enqueue_packing_helper(start, end, k, rhs); });
+#endif
         } else {
           enqueue_packing_helper(start, end, k, rhs);
         }
Index: openbabel-src/openbabel/src/math/matrix3x3.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/math/matrix3x3.cpp b/openbabel-src/openbabel/src/math/matrix3x3.cpp
--- a/openbabel-src/openbabel/src/math/matrix3x3.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/math/matrix3x3.cpp	(date 1689048275886)
@@ -545,7 +545,7 @@
     eigenvectors. The eigenvectors are normalized and mutually
     orthogonal.
   */
-  void matrix3x3::jacobi(unsigned int n, double *a, double *d, double *v)
+  void matrix3x3::jacobi(int n, double *a, double *d, double *v)
   {
     double onorm, dnorm;
     double b, dma, q, t, c, s;
@@ -557,9 +557,9 @@
 
     // Set v to the identity matrix, set the vector d to contain the
     // diagonal elements of the matrix a
-    for (j = 0; j < static_cast<int>(n); j++)
+    for (j = 0; j < n; j++)
       {
-        for (i = 0; i < static_cast<int>(n); i++)
+        for (i = 0; i < n; i++)
           v[n*i+j] = 0.0;
         v[n*j+j] = 1.0;
         d[j] = a[n*j+j];
@@ -572,7 +572,7 @@
         // onorm to the maximum norm of the off-diagonal elements
         dnorm = 0.0;
         onorm = 0.0;
-        for (j = 0; j < static_cast<int>(n); j++)
+        for (j = 0; j < n; j++)
           {
             dnorm += (double)fabs(d[j]);
             for (i = 0; i < j; i++)
@@ -582,7 +582,7 @@
         if((onorm/dnorm) <= 1.0e-12)
           goto Exit_now;
 
-        for (j = 1; j < static_cast<int>(n); j++)
+        for (j = 1; j < n; j++)
           {
             for (i = 0; i <= j - 1; i++)
               {
@@ -619,14 +619,14 @@
                         a[n*i+k] = atemp;
                       }
 
-                    for (k = j+1; k < static_cast<int>(n); k++)
+                    for (k = j+1; k < n; k++)
                       {
                         atemp = c * a[n*i+k] - s * a[n*j+k];
                         a[n*j+k] = s * a[n*i+k] + c * a[n*j+k];
                         a[n*i+k] = atemp;
                       }
 
-                    for (k = 0; k < static_cast<int>(n); k++)
+                    for (k = 0; k < n; k++)
                       {
                         vtemp = c * v[n*k+i] - s * v[n*k+j];
                         v[n*k+j] = s * v[n*k+i] + c * v[n*k+j];
@@ -647,11 +647,11 @@
     // smallest eigenvalues come first.
     nrot = l;
 
-    for (j = 0; j < static_cast<int>(n)-1; j++)
+    for (j = 0; j < n-1; j++)
       {
         k = j;
         dtemp = d[k];
-        for (i = j+1; i < static_cast<int>(n); i++)
+        for (i = j+1; i < n; i++)
           if(d[i] < dtemp)
             {
               k = i;
@@ -662,7 +662,7 @@
           {
             d[k] = d[j];
             d[j] = dtemp;
-            for (i = 0; i < static_cast<int>(n); i++)
+            for (i = 0; i < n; i++)
               {
                 dtemp = v[n*i+k];
                 v[n*i+k] = v[n*i+j];
Index: openssl-src/openssl/opensslconf.h.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openssl-src/openssl/opensslconf.h.cmake b/openssl-src/openssl/opensslconf.h.cmake
new file mode 100644
--- /dev/null	(date 1689048276046)
+++ b/openssl-src/openssl/opensslconf.h.cmake	(date 1689048276046)
@@ -0,0 +1,203 @@
+/*
+ * Copyright 2016-2020 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://www.openssl.org/source/license.html
+ */
+
+#include <openssl/opensslv.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#ifdef OPENSSL_ALGORITHM_DEFINES
+# error OPENSSL_ALGORITHM_DEFINES no longer supported
+#endif
+
+/*
+ * OpenSSL was configured with the following options:
+ */
+
+#ifndef OPENSSL_NO_MD2
+# define OPENSSL_NO_MD2
+#endif
+#ifndef OPENSSL_NO_RC5
+# define OPENSSL_NO_RC5
+#endif
+#ifndef OPENSSL_THREADS
+# define OPENSSL_THREADS
+#endif
+#ifndef OPENSSL_RAND_SEED_OS
+# define OPENSSL_RAND_SEED_OS
+#endif
+#ifndef OPENSSL_NO_ASAN
+# define OPENSSL_NO_ASAN
+#endif
+#ifndef OPENSSL_NO_ASM
+# define OPENSSL_NO_ASM
+#endif
+#ifndef OPENSSL_NO_CRYPTO_MDEBUG
+# define OPENSSL_NO_CRYPTO_MDEBUG
+#endif
+#ifndef OPENSSL_NO_CRYPTO_MDEBUG_BACKTRACE
+# define OPENSSL_NO_CRYPTO_MDEBUG_BACKTRACE
+#endif
+#ifndef OPENSSL_NO_DEVCRYPTOENG
+# define OPENSSL_NO_DEVCRYPTOENG
+#endif
+#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128
+# define OPENSSL_NO_EC_NISTP_64_GCC_128
+#endif
+#ifndef OPENSSL_NO_EGD
+# define OPENSSL_NO_EGD
+#endif
+#ifndef OPENSSL_NO_EXTERNAL_TESTS
+# define OPENSSL_NO_EXTERNAL_TESTS
+#endif
+#ifndef OPENSSL_NO_FUZZ_AFL
+# define OPENSSL_NO_FUZZ_AFL
+#endif
+#ifndef OPENSSL_NO_FUZZ_LIBFUZZER
+# define OPENSSL_NO_FUZZ_LIBFUZZER
+#endif
+#ifndef OPENSSL_NO_HEARTBEATS
+# define OPENSSL_NO_HEARTBEATS
+#endif
+#ifndef OPENSSL_NO_MSAN
+# define OPENSSL_NO_MSAN
+#endif
+#ifndef OPENSSL_NO_SCTP
+# define OPENSSL_NO_SCTP
+#endif
+#ifndef OPENSSL_NO_SSL_TRACE
+# define OPENSSL_NO_SSL_TRACE
+#endif
+#ifndef OPENSSL_NO_SSL3
+# define OPENSSL_NO_SSL3
+#endif
+#ifndef OPENSSL_NO_SSL3_METHOD
+# define OPENSSL_NO_SSL3_METHOD
+#endif
+#ifndef OPENSSL_NO_UBSAN
+# define OPENSSL_NO_UBSAN
+#endif
+#ifndef OPENSSL_NO_UNIT_TEST
+# define OPENSSL_NO_UNIT_TEST
+#endif
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
+# define OPENSSL_NO_WEAK_SSL_CIPHERS
+#endif
+#ifndef OPENSSL_NO_STATIC_ENGINE
+# define OPENSSL_NO_STATIC_ENGINE
+#endif
+#ifndef OPENSSL_NO_AFALGENG
+# define OPENSSL_NO_AFALGENG
+#endif
+
+/*
+ * Sometimes OPENSSSL_NO_xxx ends up with an empty file and some compilers
+ * don't like that.  This will hopefully silence them.
+ */
+#define NON_EMPTY_TRANSLATION_UNIT static void *dummy = &dummy;
+
+/*
+ * Applications should use -DOPENSSL_API_COMPAT=<version> to suppress the
+ * declarations of functions deprecated in or before <version>. Otherwise, they
+ * still won't see them if the library has been built to disable deprecated
+ * functions.
+ */
+#ifndef DECLARE_DEPRECATED
+# define DECLARE_DEPRECATED(f)   f;
+# ifdef __GNUC__
+#  if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 0)
+#   undef DECLARE_DEPRECATED
+#   define DECLARE_DEPRECATED(f)    f __attribute__ ((deprecated));
+#  endif
+# elif defined(__SUNPRO_C)
+#  if (__SUNPRO_C >= 0x5130)
+#   undef DECLARE_DEPRECATED
+#   define DECLARE_DEPRECATED(f)    f __attribute__ ((deprecated));
+#  endif
+# endif
+#endif
+
+#ifndef OPENSSL_FILE
+# ifdef OPENSSL_NO_FILENAMES
+#  define OPENSSL_FILE ""
+#  define OPENSSL_LINE 0
+# else
+#  define OPENSSL_FILE __FILE__
+#  define OPENSSL_LINE __LINE__
+# endif
+#endif
+
+#ifndef OPENSSL_MIN_API
+# define OPENSSL_MIN_API 0
+#endif
+
+#if !defined(OPENSSL_API_COMPAT) || OPENSSL_API_COMPAT < OPENSSL_MIN_API
+# undef OPENSSL_API_COMPAT
+# define OPENSSL_API_COMPAT OPENSSL_MIN_API
+#endif
+
+/*
+ * Do not deprecate things to be deprecated in version 1.2.0 before the
+ * OpenSSL version number matches.
+ */
+#if OPENSSL_VERSION_NUMBER < 0x10200000L
+# define DEPRECATEDIN_1_2_0(f)   f;
+#elif OPENSSL_API_COMPAT < 0x10200000L
+# define DEPRECATEDIN_1_2_0(f)   DECLARE_DEPRECATED(f)
+#else
+# define DEPRECATEDIN_1_2_0(f)
+#endif
+
+#if OPENSSL_API_COMPAT < 0x10100000L
+# define DEPRECATEDIN_1_1_0(f)   DECLARE_DEPRECATED(f)
+#else
+# define DEPRECATEDIN_1_1_0(f)
+#endif
+
+#if OPENSSL_API_COMPAT < 0x10000000L
+# define DEPRECATEDIN_1_0_0(f)   DECLARE_DEPRECATED(f)
+#else
+# define DEPRECATEDIN_1_0_0(f)
+#endif
+
+#if OPENSSL_API_COMPAT < 0x00908000L
+# define DEPRECATEDIN_0_9_8(f)   DECLARE_DEPRECATED(f)
+#else
+# define DEPRECATEDIN_0_9_8(f)
+#endif
+
+/* Generate 80386 code? */
+#undef I386_ONLY
+
+#undef OPENSSL_UNISTD
+#define OPENSSL_UNISTD <unistd.h>
+
+#undef OPENSSL_EXPORT_VAR_AS_FUNCTION
+#cmakedefine OPENSSL_EXPORT_VAR_AS_FUNCTION
+
+/*
+ * The following are cipher-specific, but are part of the public API.
+ */
+#if !defined(OPENSSL_SYS_UEFI)
+#undef BN_LLONG
+/* Only one for the following should be defined */
+#undef SIXTY_FOUR_BIT_LONG
+#cmakedefine SIXTY_FOUR_BIT_LONG
+#undef SIXTY_FOUR_BIT
+#cmakedefine SIXTY_FOUR_BIT
+#undef THIRTY_TWO_BIT
+#cmakedefine THIRTY_TWO_BIT
+#endif
+
+#define RC4_INT unsigned int
+
+#ifdef  __cplusplus
+}
+#endif
Index: rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTreeUtils.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTreeUtils.cpp b/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTreeUtils.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTreeUtils.cpp	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTreeUtils.cpp	(date 1689048276102)
@@ -16,7 +16,7 @@
 #include "FeatTree.h"
 
 #include <boost/graph/biconnected_components.hpp>
-#include <boost/property_map.hpp>
+#include <boost/property_map/property_map.hpp>
 #include <map>
 #include <set>
 
Index: openbabel-src/openbabel/src/forcefields/forcefieldmm2.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/forcefields/forcefieldmm2.cpp b/openbabel-src/openbabel/src/forcefields/forcefieldmm2.cpp
--- a/openbabel-src/openbabel/src/forcefields/forcefieldmm2.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/forcefields/forcefieldmm2.cpp	(date 1689048275866)
@@ -18,6 +18,10 @@
 #include <openbabel/babelconfig.h>
 #include <openbabel/mol.h>
 #include <openbabel/locale.h>
+#include <openbabel/obiter.h>
+#include <openbabel/bond.h>
+#include <openbabel/oberror.h>
+#include <openbabel/data.h>
 #include "forcefieldmm2.h"
 
 using namespace std;
@@ -498,8 +502,8 @@
     {
       _mol = src._mol;
       _init = src._init;
-      return *this;
-    }
+    }
+    return *this;
   }
 
   bool OBForceFieldMM2::Setup(OBMol &mol)
@@ -522,7 +526,7 @@
     OBFFParameter parameter;
 
     // open data/mm2.prm
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "mm2.prm").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mm2.prm", obError);
       return false;
@@ -667,8 +671,6 @@
       }
     }
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
Index: boost-src/boost/libs/url/include/boost/url/impl/segments_view.ipp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/url/include/boost/url/impl/segments_view.ipp b/boost-src/boost/libs/url/include/boost/url/impl/segments_view.ipp
--- a/boost-src/boost/libs/url/include/boost/url/impl/segments_view.ipp	(revision e549f40c8ba14aac07634caeb86ad45b8e01e610)
+++ b/boost-src/boost/libs/url/include/boost/url/impl/segments_view.ipp	(date 1689048275266)
@@ -27,7 +27,7 @@
 segments_view::
 segments_view(
     string_view s)
-    : segments_view(
+    : segments_base(
         parse_path(s).value(
             BOOST_URL_POS))
 {
Index: rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.h b/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.h
--- a/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.h	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.h	(date 1689048276134)
@@ -16,11 +16,11 @@
 #include <map>
 #include <chrono>
 
-#include "../../../External/GA/ga/StringChromosome.h"
-#include "../../../External/GA/ga/GaBase.h"
-#include "../../../External/GA/ga/GaOperation.h"
-#include "../../../External/GA/ga/LinkedPopLinearSel.h"
-#include "../../../External/GA/ga/IntegerStringChromosomePolicy.h"
+#include "GA/ga/StringChromosome.h"
+#include "GA/ga/GaBase.h"
+#include "GA/ga/GaOperation.h"
+#include "GA/ga/LinkedPopLinearSel.h"
+#include "GA/ga/IntegerStringChromosomePolicy.h"
 #include "RGroupFingerprintScore.h"
 #include "RGroupScore.h"
 
Index: openbabel-src/openbabel/src/forcefields/forcefielduff.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/forcefields/forcefielduff.cpp b/openbabel-src/openbabel/src/forcefields/forcefielduff.cpp
--- a/openbabel-src/openbabel/src/forcefields/forcefielduff.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/forcefields/forcefielduff.cpp	(date 1689048275866)
@@ -1614,7 +1614,7 @@
     OBFFParameter parameter;
 
     // open data/UFF.prm
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "UFF.prm").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open UFF.prm", obError);
       return false;
@@ -1647,7 +1647,10 @@
         parameter.b = 0; // used for tracking number of angles in 5-coordinate
         parameter.c = 0;
 
-        char coord = vs[1][2]; // 3rd character of atom type
+        char coord = '\0';
+        if (vs[1].size() > 2) {
+          coord = vs[1][2]; // 3rd character of atom type
+        }
         switch (coord) {
         case '1': // linear
           parameter._ipar.push_back(1);
@@ -1680,8 +1683,6 @@
       }
     }
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
@@ -1702,7 +1703,7 @@
     _mol.SetAtomTypesPerceived();
 
     // open data/UFF.prm
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "UFF.prm").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open UFF.prm", obError);
       return false;
@@ -1771,8 +1772,6 @@
 
     }
 
-    if (ifs)
-      ifs.close();
 
     // Free memory
     for (i = _vexttyp.begin();i != _vexttyp.end();++i) {
Index: openbabel-src/openbabel/src/forcefields/forcefieldghemical.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/forcefields/forcefieldghemical.cpp b/openbabel-src/openbabel/src/forcefields/forcefieldghemical.cpp
--- a/openbabel-src/openbabel/src/forcefields/forcefieldghemical.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/forcefields/forcefieldghemical.cpp	(date 1689048275866)
@@ -858,7 +858,7 @@
     OBFFParameter parameter;
 
     // open data/ghemical.prm
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "ghemical.prm").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open ghemical.prm", obError);
       return false;
@@ -942,8 +942,6 @@
       }
     }
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
@@ -964,7 +962,7 @@
     _mol.SetAtomTypesPerceived();
 
     // open data/ghemical.prm
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "ghemical.prm").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open ghemical.prm", obError);
       return false;
@@ -1026,8 +1024,6 @@
     //  else
     //    cout << "ATOMTYPE " << a->GetType() << endl;
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
Index: openbabel-src/openbabel/src/op.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/op.cpp b/openbabel-src/openbabel/src/op.cpp
--- a/openbabel-src/openbabel/src/op.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/op.cpp	(date 1689048275890)
@@ -22,10 +22,6 @@
 using namespace std;
 namespace OpenBabel
 {
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-  // macro to implement static OBPlugin::PluginMapType& Map()
-  PLUGIN_CPP_FILE(OBOp)
-#endif
 }
 
 
Index: openbabel-src/openbabel/src/obmolecformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/obmolecformat.cpp b/openbabel-src/openbabel/src/obmolecformat.cpp
--- a/openbabel-src/openbabel/src/obmolecformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/obmolecformat.cpp	(date 1689048275890)
@@ -500,12 +500,12 @@
 
     NameIndexType::iterator itr;
 
-    ifstream indexstream;
+    istringstream indexstream;
     OpenDatafile(indexstream, datafilename + ".obindx");
     if(!indexstream)
       {
         //Need to prepare the index
-        ifstream datastream;
+        istringstream datastream;
         string datafilepath = OpenDatafile(datastream, datafilename);
         if(!datastream)
           {
Index: rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.h b/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.h
--- a/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.h	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.h	(date 1689048276110)
@@ -77,12 +77,14 @@
 #ifdef DUP_SUBSTRUCT_CACHE
   DuplicatedSeedCache::TKey DupCacheKey;
 #endif
-  std::vector<TargetMatch> MatchResult;  // for each target
+  std::vector<std::shared_ptr<TargetMatch>> MatchResult;  // for each target
  public:
   Seed()
 
   {}
 
+  void resizeMatchResult(const std::size_t& size);
+
   void setMoleculeFragment(const Seed& src) {
     MoleculeFragment = src.MoleculeFragment;
   }
Index: openbabel-src/openbabel/src/forcefields/forcefieldmmff94.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/forcefields/forcefieldmmff94.cpp b/openbabel-src/openbabel/src/forcefields/forcefieldmmff94.cpp
--- a/openbabel-src/openbabel/src/forcefields/forcefieldmmff94.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/forcefields/forcefieldmmff94.cpp	(date 1689048275866)
@@ -874,7 +874,7 @@
     char buffer[80];
 
     // open data/_parFile
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, _parFile).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open parameter file", obError);
       return false;
@@ -913,8 +913,6 @@
         ParseParamVDW(vs[1]);
     }
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
@@ -929,7 +927,7 @@
     OBFFParameter parameter;
 
     // open data/mmffbond.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffbond.par", obError);
       return false;
@@ -950,8 +948,6 @@
       _ffbondparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -964,7 +960,7 @@
     OBFFParameter parameter;
 
     // open data/mmffbndk.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffbndk.par", obError);
       return false;
@@ -984,8 +980,6 @@
       _ffbndkparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -998,7 +992,7 @@
     OBFFParameter parameter;
 
     // open data/mmffang.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffang.par", obError);
       return false;
@@ -1020,8 +1014,6 @@
       _ffangleparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1034,7 +1026,7 @@
     OBFFParameter parameter;
 
     // open data/mmffstbn.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffstbn.par", obError);
       return false;
@@ -1056,8 +1048,6 @@
       _ffstrbndparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1070,7 +1060,7 @@
     OBFFParameter parameter;
 
     // open data/mmffdfsb.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffdfsb.par", obError);
       return false;
@@ -1091,8 +1081,6 @@
       _ffdfsbparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1105,7 +1093,7 @@
     OBFFParameter parameter;
 
     // open data/mmffoop.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffoop.par", obError);
       return false;
@@ -1126,8 +1114,6 @@
       _ffoopparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1140,7 +1126,7 @@
     OBFFParameter parameter;
 
     // open data/mmfftor.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmfftor.par", obError);
       return false;
@@ -1164,8 +1150,6 @@
       _fftorsionparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1178,7 +1162,7 @@
     OBFFParameter parameter;
 
     // open data/mmffvdw.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffvdw.par", obError);
       return false;
@@ -1205,8 +1189,6 @@
       _ffvdwparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1219,7 +1201,7 @@
     OBFFParameter parameter;
 
     // open data/mmffchg.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffchg.par", obError);
       return false;
@@ -1239,8 +1221,6 @@
       _ffchgparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1253,7 +1233,7 @@
     OBFFParameter parameter;
 
     // open data/mmffpbci.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffpbci", obError);
       return false;
@@ -1272,8 +1252,6 @@
       _ffpbciparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1286,7 +1264,7 @@
     OBFFParameter parameter;
 
     // open data/mmffprop.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffprop.par", obError);
       return false;
@@ -1321,8 +1299,6 @@
       _ffpropparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1335,7 +1311,7 @@
     OBFFParameter parameter;
 
     // open data/mmffdef.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffdef.par", obError);
       return false;
@@ -1356,8 +1332,6 @@
       _ffdefparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
Index: openbabel-src/openbabel/src/forcefields/forcefieldgaff.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/forcefields/forcefieldgaff.cpp b/openbabel-src/openbabel/src/forcefields/forcefieldgaff.cpp
--- a/openbabel-src/openbabel/src/forcefields/forcefieldgaff.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/forcefields/forcefieldgaff.cpp	(date 1689048275866)
@@ -1081,7 +1081,7 @@
     OBFFParameter parameter;
 
     // open data/gaff.dat
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "gaff.dat").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open gaff.dat", obError);
       return false;
@@ -1204,8 +1204,6 @@
 	    ifs.getline(buffer, BUFF_SIZE);
       }
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
@@ -1230,7 +1228,7 @@
     _mol.SetAtomTypesPerceived();
 
     // open data/gaff.prm
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "gaff.prm").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open gaff.prm", obError);
       return false;
@@ -1412,8 +1410,6 @@
     }
 
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
Index: rdkit-src/rdkit/Code/GraphMol/SLNParse/lex.yysln.cpp.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/SLNParse/lex.yysln.cpp.cmake b/rdkit-src/rdkit/Code/GraphMol/SLNParse/lex.yysln.cpp.cmake
--- a/rdkit-src/rdkit/Code/GraphMol/SLNParse/lex.yysln.cpp.cmake	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/GraphMol/SLNParse/lex.yysln.cpp.cmake	(date 1690852232727)
@@ -727,8 +727,8 @@
 #endif
 
 #include <cstdio>
-#ifdef WIN32
-#include <io.h> 	 
+#if defined(WIN32) || defined(__MINGW32__)
+#include <io.h>
 #endif
 
 #include <RDGeneral/Exceptions.h>
Index: openbabel-src/openbabel/src/mcdlutil.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/mcdlutil.cpp b/openbabel-src/openbabel/src/mcdlutil.cpp
--- a/openbabel-src/openbabel/src/mcdlutil.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/mcdlutil.cpp	(date 1689048275886)
@@ -5033,7 +5033,7 @@
 
     if (bondLabel != nullptr && nBonds() > 0) {
       bondLabel->resize(molecule1->nBonds());
-      if (test2) for (j=0; j<molecule1->nBonds(); j++) if (bSTested[j]>=0) (*bondLabel)[j]=1; else (*bondLabel)[j]=0;
+      if (test2) for (j=0; j<molecule1->nBonds(); j++) { if (bSTested[j]>=0) (*bondLabel)[j]=1; else (*bondLabel)[j]=0; }
     };
     result=test2;
 
@@ -5102,7 +5102,7 @@
   std::vector<TEditedMolecule *> TemplateRedraw::queryData;
 
   bool TemplateRedraw::loadTemplates() {
-    std::ifstream ifs;
+    std::istringstream ifs;
     string filename("templates.sdf");//("e:\\templates.sdf");
     TEditedMolecule sm;
     TEditedMolecule * em;
Index: openbabel-src/openbabel/src/tokenst.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/tokenst.cpp b/openbabel-src/openbabel/src/tokenst.cpp
--- a/openbabel-src/openbabel/src/tokenst.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/tokenst.cpp	(date 1689048275890)
@@ -24,7 +24,7 @@
 #include <limits>
 #include <cstring>
 #include <openbabel/tokenst.h>
-
+#include "text_assets.hpp"
 using namespace std;
 
 namespace OpenBabel
@@ -180,7 +180,7 @@
      or "BABEL_DATADIR" if @p envvar is not specified, or the compiled-in
      macro BABEL_DATADIR if the environment variable is not set
 
-     \param ifs        Stream to load
+     \param iss        Stream to load
      \param filename   Name of the data file to load
      \param envvar     Name of the environment variable
 
@@ -188,51 +188,16 @@
      unless it is in current directory
 
   **/
-  std::string OpenDatafile(std::ifstream& ifs, const std::string& filename,
+  std::string OpenDatafile(std::istringstream& iss, const std::string& filename,
                            const std::string& envvar)
   {
-    ios_base::openmode imode = ios_base::in;
-    #ifdef ALL_READS_BINARY //Makes unix files compatible with VC++6
-      imode = ios_base::in|ios_base::binary;
-    #endif
-
-    // check the current directory
-    ifs.close();
-    ifs.clear();
-    ifs.open(filename.c_str(),imode);
-    if(ifs)
-      return filename;
-
-    string file;
-    const char* datadir = getenv(envvar.c_str());
-    if(!datadir)
-      datadir = BABEL_DATADIR;
-
-    // check the subdirectory for this version number
-    file = datadir;
-    file += FILE_SEP_CHAR;
-    file += BABEL_VERSION;
-    file += FILE_SEP_CHAR + filename;
-
-    ifs.clear();
-    ifs.open(file.c_str(),imode);
-    if(ifs)
-      return file;
-
-    // couldn't find it with the version built in, so try the parent
-    file = datadir;
-    file += FILE_SEP_CHAR;
-    file += filename;
-
-    ifs.clear();
-    ifs.open(file.c_str(),imode);
-
-    if (ifs)
-      return file;
-
-    ifs.clear();
-    ifs.close();
-    return(""); // error
+    auto it = openbabel::OPENBABEL_ASSET_MAP.find(filename);
+    if(it==openbabel::OPENBABEL_ASSET_MAP.end()) {
+        return "";
+    }
+    iss.clear();
+    iss.str(it->second);
+    return filename;
   }
 
 
Index: opencv-src/opencv/modules/imgproc/src/spatialgradient.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/imgproc/src/spatialgradient.cpp b/opencv-src/opencv/modules/imgproc/src/spatialgradient.cpp
--- a/opencv-src/opencv/modules/imgproc/src/spatialgradient.cpp	(revision f9a59f2592993d3dcc080e495f4f5e02dd8ec7ef)
+++ b/opencv-src/opencv/modules/imgproc/src/spatialgradient.cpp	(date 1689048275986)
@@ -58,7 +58,14 @@
  *           1  2  1
  */
 template <typename T>
-static inline void spatialGradientKernel( T& vx, T& vy,
+    static
+#if _MSC_VER >= 1930 && _MSC_VER < 1940 // FIXME: MSVC 2022, static build, got fatal error C1001
+    __declspec(noinline)
+#else
+    inline
+#endif
+    void spatialGradientKernel( T& vx, T& vy,
+
                                           const T& v00, const T& v01, const T& v02,
                                           const T& v10,               const T& v12,
                                           const T& v20, const T& v21, const T& v22 )
Index: rdkit-src/rdkit/Code/GraphMol/Descriptors/PMI.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/Descriptors/PMI.h b/rdkit-src/rdkit/Code/GraphMol/Descriptors/PMI.h
--- a/rdkit-src/rdkit/Code/GraphMol/Descriptors/PMI.h	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/GraphMol/Descriptors/PMI.h	(date 1689048276110)
@@ -37,7 +37,7 @@
                                      bool force = false);
 const std::string PMI1Version = "1.0.0";
 //! second principal moment of inertia
-RDKIT_DESCRIPTORS_EXPORT RDKIT_DESCRIPTORS_EXPORT double PMI2(
+RDKIT_DESCRIPTORS_EXPORT double PMI2(
     const ROMol&, int confId = -1, bool useAtomicMasses = true,
     bool force = false);
 const std::string PMI2Version = "1.0.0";
Index: rdkit-src/rdkit/Code/ML/Cluster/Murtagh/f2c.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/ML/Cluster/Murtagh/f2c.h b/rdkit-src/rdkit/Code/ML/Cluster/Murtagh/f2c.h
--- a/rdkit-src/rdkit/Code/ML/Cluster/Murtagh/f2c.h	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/ML/Cluster/Murtagh/f2c.h	(date 1689048276146)
@@ -4,7 +4,6 @@
 
         - From The Shogakukan DICTIONARY OF NEW ENGLISH (Second edition) */
 
-#include <RDGeneral/export.h>
 #ifndef F2C_INCLUDE
 #define F2C_INCLUDE
 
Index: opencv-src/opencv/modules/imgproc/src/generalized_hough.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/imgproc/src/generalized_hough.cpp b/opencv-src/opencv/modules/imgproc/src/generalized_hough.cpp
--- a/opencv-src/opencv/modules/imgproc/src/generalized_hough.cpp	(revision f9a59f2592993d3dcc080e495f4f5e02dd8ec7ef)
+++ b/opencv-src/opencv/modules/imgproc/src/generalized_hough.cpp	(date 1689048275978)
@@ -692,7 +692,7 @@
         getContourPoints(edges, dx, dy, points);
 
         features.resize(levels_ + 1);
-        std::for_each(features.begin(), features.end(), [=](std::vector<Feature>& e) { e.clear(); e.reserve(maxBufferSize_); });
+        std::for_each(features.begin(), features.end(), [=, this](std::vector<Feature>& e) { e.clear(); e.reserve(maxBufferSize_); });
 
         for (size_t i = 0; i < points.size(); ++i)
         {
Index: indigo-src/indigo/core/indigo-core/common/base_c/defs.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/common/base_c/defs.h b/indigo-src/indigo/core/indigo-core/common/base_c/defs.h
--- a/indigo-src/indigo/core/indigo-core/common/base_c/defs.h	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/core/indigo-core/common/base_c/defs.h	(date 1689048275434)
@@ -19,9 +19,7 @@
 #ifndef __defs_h__
 #define __defs_h__
 
-#if !defined(__sign)
-#define __sign(a) (a > 0 ? 1 : (a < 0 ? -1 : 0))
-#endif
+#include "indigo_core_export.h"
 
 #if defined(_WIN32) && !defined(__MINGW32__)
 //#define vsnprintf _vsnprintf
@@ -52,26 +50,12 @@
 #endif
 
 #ifndef EXPORT_SYMBOL
-#ifdef _WIN32
-#define EXPORT_SYMBOL __declspec(dllexport)
-#elif (defined __GNUC__ || defined __APPLE__)
-#define EXPORT_SYMBOL __attribute__((visibility("default")))
-#else
-#define EXPORT_SYMBOL
-#endif
+#define EXPORT_SYMBOL INDIGO_CORE_EXPORT
 #endif
 
 #ifndef DLLEXPORT
-#ifdef _WIN32
-#ifdef INDIGO_PLUGIN
-#define DLLEXPORT __declspec(dllimport)
-#else
-#define DLLEXPORT EXPORT_SYMBOL
-#endif
-#else
 #define DLLEXPORT EXPORT_SYMBOL
 #endif
-#endif
 
 #ifndef CEXPORT
 #ifndef __cplusplus
Index: openbabel-src/openbabel/src/formats/gamessukformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/gamessukformat.cpp b/openbabel-src/openbabel/src/formats/gamessukformat.cpp
--- a/openbabel-src/openbabel/src/formats/gamessukformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/gamessukformat.cpp	(date 1689048275870)
@@ -23,12 +23,7 @@
 
 #include <algorithm>
 #include <cmath>
-
-#ifdef _MSC_VER
 #include <regex>
-#else
-#include <regex.h>
-#endif
 
 using namespace std;
 
@@ -797,20 +792,15 @@
     //                     ------label--------   -------charge-------- < seems enough for a match
     string pattern(" *\\* *[a-zA-Z]{1,2}[0-9]* *[0-9]{1,3}\\.[0-9]{1}");
     bool iok;
-#ifdef _MSC_VER
-    std::tr1::regex myregex;
+    std::regex myregex;
     try {
       myregex.assign(pattern,
-                     std::tr1::regex_constants::extended |
-                     std::tr1::regex_constants::nosubs);
+                     std::regex_constants::extended |
+                     std::regex_constants::nosubs);
       iok = true;
-    } catch (std::tr1::regex_error ex) {
+    } catch (std::regex_error ex) {
       iok = false;
     }
-#else
-    regex_t *myregex = new regex_t;
-    iok = regcomp(myregex, pattern.c_str(), REG_EXTENDED | REG_NOSUB)==0;
-#endif
     if (!iok) cerr << "Error compiling regex in GUK OUTPUT!\n";
 
     // Read in the coordinates - we process them directly rather
@@ -820,11 +810,7 @@
 
       // End of geometry block
       if (strstr(buffer, "*************************") != nullptr) break;
-#ifdef _MSC_VER
-      if (std::tr1::regex_search(buffer, myregex)) {
-#else
-        if (regexec(myregex, buffer, 0, nullptr, 0) == 0) {
-#endif
+      if (std::regex_search(buffer, myregex)) {
           //cerr << "Got Coord line: " << buffer << endl;
           OBAtom *atom = mol.NewAtom();
           tokenize(tokens,buffer," ");
@@ -841,9 +827,6 @@
         }
       }
       mol.EndModify();
-#ifndef _MSC_VER
-      regfree(myregex);
-#endif
       return true;
     } // End ReadInitalCartesian
 
Index: openbabel-src/openbabel/src/formats/chemkinformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/chemkinformat.cpp b/openbabel-src/openbabel/src/formats/chemkinformat.cpp
--- a/openbabel-src/openbabel/src/formats/chemkinformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/chemkinformat.cpp	(date 1689048275870)
@@ -726,7 +726,7 @@
 
   string missing; // list of molecules which do not have thermodata
   OBConversion StdThermConv;
-  ifstream stdthermo;
+  istringstream stdthermo;
   OpenDatafile(stdthermo, datafilename);
   if(!stdthermo)
   {
Index: eigen-src/eigen/Eigen/src/Core/util/DisableStupidWarnings.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/eigen-src/eigen/Eigen/src/Core/util/DisableStupidWarnings.h b/eigen-src/eigen/Eigen/src/Core/util/DisableStupidWarnings.h
--- a/eigen-src/eigen/Eigen/src/Core/util/DisableStupidWarnings.h	(revision 3147391d946bb4b6c68edd901f2add6ac1f31f8c)
+++ b/eigen-src/eigen/Eigen/src/Core/util/DisableStupidWarnings.h	(date 1689048275354)
@@ -74,25 +74,25 @@
 #endif
 
 #if defined __NVCC__
-  #pragma diag_suppress boolean_controlling_expr_is_constant
+  #pragma nv_diag_suppress boolean_controlling_expr_is_constant
   // Disable the "statement is unreachable" message
-  #pragma diag_suppress code_is_unreachable
+  #pragma nv_diag_suppress code_is_unreachable
   // Disable the "dynamic initialization in unreachable code" message
-  #pragma diag_suppress initialization_not_reachable
+  #pragma nv_diag_suppress initialization_not_reachable
   // Disable the "invalid error number" message that we get with older versions of nvcc
-  #pragma diag_suppress 1222
+  #pragma nv_diag_suppress 1222
   // Disable the "calling a __host__ function from a __host__ __device__ function is not allowed" messages (yes, there are many of them and they seem to change with every version of the compiler)
-  #pragma diag_suppress 2527
-  #pragma diag_suppress 2529
-  #pragma diag_suppress 2651
-  #pragma diag_suppress 2653
-  #pragma diag_suppress 2668
-  #pragma diag_suppress 2669
-  #pragma diag_suppress 2670
-  #pragma diag_suppress 2671
-  #pragma diag_suppress 2735
-  #pragma diag_suppress 2737
-  #pragma diag_suppress 2739
+  #pragma nv_diag_suppress 2527
+  #pragma nv_diag_suppress 2529
+  #pragma nv_diag_suppress 2651
+  #pragma nv_diag_suppress 2653
+  #pragma nv_diag_suppress 2668
+  #pragma nv_diag_suppress 2669
+  #pragma nv_diag_suppress 2670
+  #pragma nv_diag_suppress 2671
+  #pragma nv_diag_suppress 2735
+  #pragma nv_diag_suppress 2737
+  #pragma nv_diag_suppress 2739
 #endif
 
 #else
Index: eigen-src/eigen/Eigen/src/Core/util/Macros.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/eigen-src/eigen/Eigen/src/Core/util/Macros.h b/eigen-src/eigen/Eigen/src/Core/util/Macros.h
--- a/eigen-src/eigen/Eigen/src/Core/util/Macros.h	(revision 3147391d946bb4b6c68edd901f2add6ac1f31f8c)
+++ b/eigen-src/eigen/Eigen/src/Core/util/Macros.h	(date 1689048275354)
@@ -59,7 +59,7 @@
 //------------------------------------------------------------------------------------------
 
 /// \internal EIGEN_COMP_GNUC set to 1 for all compilers compatible with GCC
-#ifdef __GNUC__
+#if defined(__GNUC__) && !defined(EMSCRIPTEN)
   #define EIGEN_COMP_GNUC (__GNUC__*10+__GNUC_MINOR__)
 #else
   #define EIGEN_COMP_GNUC 0
Index: rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.cpp b/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.cpp	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.cpp	(date 1689048276134)
@@ -7,7 +7,7 @@
 //  which is included in the file license.txt, found at the root
 //  of the RDKit source tree.
 //
-
+#include <RDGeneral/export.h>
 #include <ctime>
 #include <limits>
 #ifdef RDK_BUILD_THREADSAFE_SSS
@@ -18,7 +18,7 @@
 #include "RGroupDecompData.h"
 #include "RGroupDecomp.h"
 #include "RGroupFingerprintScore.h"
-#include "../../../External/GA/util/Util.h"
+#include "GA/util/Util.h"
 
 // #define DEBUG
 
@@ -327,7 +327,7 @@
     tasks.reserve(numberRuns);
     for (int n = 0; n < numberRuns; n++) {
       auto future = async(launch::async, &RDKit::RGroupGa::run, this, n + 1);
-      tasks.push_back(move(future));
+      tasks.push_back(std::move(future));
     }
 
     std::transform(tasks.begin(), tasks.end(), back_inserter(results),
Index: eigen-src/eigen/Eigen/src/Core/util/ConfigureVectorization.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/eigen-src/eigen/Eigen/src/Core/util/ConfigureVectorization.h b/eigen-src/eigen/Eigen/src/Core/util/ConfigureVectorization.h
--- a/eigen-src/eigen/Eigen/src/Core/util/ConfigureVectorization.h	(revision 3147391d946bb4b6c68edd901f2add6ac1f31f8c)
+++ b/eigen-src/eigen/Eigen/src/Core/util/ConfigureVectorization.h	(date 1689048275354)
@@ -339,7 +339,7 @@
     extern "C" {
       // In theory we should only include immintrin.h and not the other *mmintrin.h header files directly.
       // Doing so triggers some issues with ICC. However old gcc versions seems to not have this file, thus:
-      #if EIGEN_COMP_ICC >= 1110
+      #if EIGEN_COMP_ICC >= 1110 || EIGEN_COMP_EMSCRIPTEN
         #include <immintrin.h>
       #else
         #include <mmintrin.h>
Index: openbabel-src/openbabel/src/formats/pdbqtformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/pdbqtformat.cpp b/openbabel-src/openbabel/src/formats/pdbqtformat.cpp
--- a/openbabel-src/openbabel/src/formats/pdbqtformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/pdbqtformat.cpp	(date 1689048275882)
@@ -483,7 +483,7 @@
     return mol.DeleteNonPolarHydrogens();
   }
 
-  bool OutputTree(OBConversion* pConv, OBMol& mol, ostream& ofs, map <unsigned int, branch> & tree, unsigned int depth, bool moves_many, bool preserve_original_index)
+  bool OutputTree(OBConversion* pConv, OBMol& mol, ostream& ofs, map <size_t, branch> & tree, unsigned int depth, bool moves_many, bool preserve_original_index)
   {
     if (tree.empty()) {return false;}
     if (depth>= tree.size()-1) {depth=tree.size()-1;}
@@ -607,7 +607,7 @@
     return true;
   }
 
-  void ConstructTree (map <unsigned int, branch>& tree, vector <vector <int> > rigid_fragments, unsigned int root_piece, const OBMol& mol, bool flexible)
+  void ConstructTree (map <size_t, branch>& tree, vector <vector <int> > rigid_fragments, unsigned int root_piece, const OBMol& mol, bool flexible)
   {
     unsigned int first_atom = 0;
     unsigned int second_atom = 0;
@@ -651,7 +651,7 @@
             sprog.rigid_with.insert(sprog.index);
 
             (*tree.find(position)).second.children.insert(tree.size()); //tells the current parent it has an extra child
-                        tree.insert(pair<unsigned int, branch> (tree.size(), sprog)); //adds the current branch to the tree
+                        tree.insert(std::make_pair(tree.size(), sprog)); //adds the current branch to the tree
 
             rigid_fragments.erase(rigid_fragments.begin() + i);
             sterile=false;
@@ -747,7 +747,7 @@
     return false;
   }
 
-  unsigned int AtomsSoFar(const map <unsigned int, branch> & tree, unsigned int depth)
+  unsigned int AtomsSoFar(const map <size_t, branch> & tree, unsigned int depth)
   {
     if (depth > tree.size()) {return 0;}
     unsigned int numberAtoms=0;
@@ -985,7 +985,7 @@
 
       vector <vector <int> > rigid_fragments; //the vector of all the rigid molecule fragments, using atom indexes
       unsigned int best_root_atom=1;
-      map <unsigned int, branch> tree;
+      map <size_t, branch> tree;
       unsigned int torsdof=0;
       unsigned int root_piece=0;
       unsigned int rotatable_bonds=0;
Index: rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupFingerprintScore.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupFingerprintScore.cpp b/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupFingerprintScore.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupFingerprintScore.cpp	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupFingerprintScore.cpp	(date 1689048276134)
@@ -12,7 +12,7 @@
 #include "GraphMol/Fingerprints/Fingerprints.h"
 #include "GraphMol//Fingerprints/MorganFingerprints.h"
 #include <GraphMol/SmilesParse/SmilesParse.h>
-#include "../../../External/GA/util/Util.h"
+#include "GA/util/Util.h"
 #include <memory>
 #include <utility>
 #include <vector>
Index: openbabel-src/openbabel/src/formats/svgformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/svgformat.cpp b/openbabel-src/openbabel/src/formats/svgformat.cpp
--- a/openbabel-src/openbabel/src/formats/svgformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/svgformat.cpp	(date 1689048275886)
@@ -513,7 +513,7 @@
 //returns true if the file "svgformat.script" was inserted into the output
 bool SVGFormat::EmbedScript(ostream& ofs)
 {
-  ifstream ifs;
+  istringstream ifs;
   if(!ifs || OpenDatafile(ifs, "svgformat.script").empty())
     return false;
   ofs << ifs.rdbuf(); //copy whole file
Index: openbabel-src/openbabel/src/formats/orcaformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/orcaformat.cpp b/openbabel-src/openbabel/src/formats/orcaformat.cpp
--- a/openbabel-src/openbabel/src/formats/orcaformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/orcaformat.cpp	(date 1689048275882)
@@ -24,11 +24,7 @@
 #include <openbabel/generic.h>
 #include <cstdlib>
 
-#ifdef _MSC_VER
 #include <regex>
-#else
-#include <regex.h>
-#endif
 
 #include <iomanip>
 
@@ -696,38 +692,22 @@
 
 // small function to avoid wrong parsing
 // if there is no whitespace between the numbers in the column structure
-#ifdef _MSC_VER
   string OrcaOutputFormat::checkColumns(string checkBuffer)
   {
     string pattern ("[0-9]-");
-    std::tr1::regex myregex;
-    std::tr1::smatch pm;
+    std::regex myregex;
+    std::smatch pm;
     try {
       myregex.assign(pattern,
-                     std::tr1::regex_constants::extended);
+                     std::regex_constants::extended);
       //iok = true;
-    } catch (std::tr1::regex_error ex) {
+    } catch (std::regex_error ex) {
         return (checkBuffer); // do nothing
       //iok = false;
     }
-    while (std::tr1::regex_search (checkBuffer,pm,myregex)) {
+    while (std::regex_search (checkBuffer,pm,myregex)) {
         checkBuffer.insert(pm.position(0)+1, " ");
     }
     return (checkBuffer);
   }
-#else
-  string OrcaOutputFormat::checkColumns(string checkBuffer)
-  {
-      string pattern ("[0-9]-");
-      regmatch_t pm;
-      regex_t myregex;
-      int pos = regcomp(&myregex, pattern.c_str(), REG_EXTENDED);
-      if (pos !=0) return (checkBuffer); // do nothing
-
-      while (regexec(&myregex, checkBuffer.c_str(), 1, &pm, REG_EXTENDED) == 0) {
-          checkBuffer.insert(pm.rm_eo-1, " ");  // insert whitespace to separate the columns
-      }
-      return (checkBuffer);
-  }
-#endif
 } //namespace OpenBabel
Index: opencv-src/opencv/modules/gapi/src/backends/common/serialization.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/gapi/src/backends/common/serialization.cpp b/opencv-src/opencv/modules/gapi/src/backends/common/serialization.cpp
--- a/opencv-src/opencv/modules/gapi/src/backends/common/serialization.cpp	(revision f9a59f2592993d3dcc080e495f4f5e02dd8ec7ef)
+++ b/opencv-src/opencv/modules/gapi/src/backends/common/serialization.cpp	(date 1689048275962)
@@ -8,7 +8,9 @@
 #include <map> // map
 #include <ade/util/zip_range.hpp> // indexed
 
+#ifndef NOMINMAX
 #define NOMINMAX
+#endif
 
 #ifdef _WIN32
 #include <winsock.h>      // htonl, ntohl
Index: openbabel-src/openbabel/src/formats/vaspformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/vaspformat.cpp b/openbabel-src/openbabel/src/formats/vaspformat.cpp
--- a/openbabel-src/openbabel/src/formats/vaspformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/vaspformat.cpp	(date 1689048275886)
@@ -532,7 +532,7 @@
             for (size_t natom = 0; natom < pmol->NumAtoms(); ++natom) {
               const vector3 dxyz = currXyz[natom] - prevXyz[natom];
               vector3::const_iterator iter = std::find_if(dxyz.begin(), dxyz.end(),
-                      std::bind2nd(std::not_equal_to<double>(), 0.0));
+                      std::bind(std::not_equal_to<double>(), std::placeholders::_1, 0.0));
               if (iter != dxyz.end()) dipGrad[natom].SetRow(iter - dxyz.begin(),
                                                             (currDm - prevDm) / *iter);
             }
@@ -586,7 +586,7 @@
       if (max != 0.0) {
         // Normalize
         std::transform(Intensities.begin(), Intensities.end(), Intensities.begin(),
-                       std::bind2nd(std::divides<double>(), max / 100.0));
+                       std::bind(std::divides<double>(), std::placeholders::_1, max / 100.0));
       } else {
         Intensities.clear();
       }
Index: rdkit-src/rdkit/External/GA/ga/GaBase.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/External/GA/ga/GaBase.h b/rdkit-src/rdkit/External/GA/ga/GaBase.h
--- a/rdkit-src/rdkit/External/GA/ga/GaBase.h	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/External/GA/ga/GaBase.h	(date 1689048276162)
@@ -34,8 +34,8 @@
   GaBase& operator=(const GaBase& other) = delete;
 
  public:
-  GaBase(){};
-  virtual ~GaBase(){};
+  GaBase();
+  virtual ~GaBase();
 
   double getSelectionPressure() const { return selectionPressure; }
 
Index: openbabel-src/openbabel/src/zipstreamimpl.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/zipstreamimpl.h b/openbabel-src/openbabel/src/zipstreamimpl.h
--- a/openbabel-src/openbabel/src/zipstreamimpl.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/zipstreamimpl.h	(date 1689048275890)
@@ -176,8 +176,7 @@
     }
     while(_err == Z_OK);
 
-    if(&_ostream)
-			_ostream.flush();
+    _ostream.flush();
 
     return total_written_byte_size;
 }
Index: indigo-src/indigo/core/indigo-core/layout/molecule_layout_macrocycles.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/layout/molecule_layout_macrocycles.h b/indigo-src/indigo/core/indigo-core/layout/molecule_layout_macrocycles.h
--- a/indigo-src/indigo/core/indigo-core/layout/molecule_layout_macrocycles.h	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/core/indigo-core/layout/molecule_layout_macrocycles.h	(date 1689048275438)
@@ -283,9 +283,9 @@
     public:
         TriangleLattice();
 
-        TriangleLattice(rectangle rec, int rem, byte* data_link);
+        TriangleLattice(rectangle rec, int rem, ::byte* data_link);
 
-        void init(rectangle rec, int rem, byte* data_link);
+        void init(rectangle rec, int rem, ::byte* data_link);
         void init_void();
 
         unsigned short& getCell(int x, int y);
@@ -337,7 +337,7 @@
 
         int length;
 
-        byte* _hidden_data_field;
+        ::byte* _hidden_data_field;
         ObjArray<Array<rectangle>> border_array;
         Array<rectangle*> border;
 
@@ -347,7 +347,7 @@
         TL_CP_DECL(Array<int>, _rotation_parity);
         TL_CP_DECL(Array<int>, _coord_diff_reminder); // (x - y) % 3
         TL_CP_DECL(ObjArray<ObjArray<ObjArray<TriangleLattice>>>, _lattices);
-        TL_CP_DECL(Array<byte>, _hidden_data_field_array);
+        TL_CP_DECL(Array<::byte>, _hidden_data_field_array);
 
         TriangleLattice _sink_lattice;
     };
Index: rdkit-src/rdkit/External/GA/util/export.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/External/GA/util/export.h b/rdkit-src/rdkit/External/GA/util/export.h
--- a/rdkit-src/rdkit/External/GA/util/export.h	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/External/GA/util/export.h	(date 1689048276162)
@@ -10,6 +10,6 @@
 
 #pragma once
 
-#include <RDGeneral/RDExportMacros.h>
+#include <RDGeneral/export.h>
 
-#define GA_EXPORT RDKIT_EXPORT_API
+#define GA_EXPORT RDKIT_GA_EXPORT
Index: openbabel-src/openbabel/src/formats/nwchemformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/nwchemformat.cpp b/openbabel-src/openbabel/src/formats/nwchemformat.cpp
--- a/openbabel-src/openbabel/src/formats/nwchemformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/nwchemformat.cpp	(date 1689048275882)
@@ -303,10 +303,11 @@
         blank_line = false;
         if (vs[0][0] == '0')
             charge = atoi(vs[4].c_str());
-        else if (vs[0][0] == '1')
+        else if (vs[0][0] == '1') {
             for (unsigned int i = 0; i < 3; i++)
                 if (vs[i+1][0] == '1')
                     dipole[i] = atof(vs[4].c_str());
+        }
         else if (vs[0][0] == '2')
         {
             double value = atof(vs[4].c_str());
Index: rdkit-src/rdkit/Code/GraphMol/FileParsers/MolSGroupParsing.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/FileParsers/MolSGroupParsing.h b/rdkit-src/rdkit/Code/GraphMol/FileParsers/MolSGroupParsing.h
--- a/rdkit-src/rdkit/Code/GraphMol/FileParsers/MolSGroupParsing.h	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/GraphMol/FileParsers/MolSGroupParsing.h	(date 1689048276114)
@@ -131,7 +131,7 @@
 template <class T>
 RDKIT_FILEPARSERS_EXPORT std::vector<T> ParseV3000Array(
     std::stringstream &stream, int maxV = -1, bool strictParsing = false);
-#if defined(_MSC_VER) && defined(RDKIT_DYN_LINK)
+#if defined(_MSC_VER)
 template RDKIT_FILEPARSERS_EXPORT std::vector<int> ParseV3000Array(
     std::stringstream &, int, bool);
 template RDKIT_FILEPARSERS_EXPORT std::vector<unsigned int> ParseV3000Array(
Index: openbabel-src/openbabel/src/formats/fchkformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/fchkformat.cpp b/openbabel-src/openbabel/src/formats/fchkformat.cpp
--- a/openbabel-src/openbabel/src/formats/fchkformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/fchkformat.cpp	(date 1689048275870)
@@ -665,16 +665,16 @@
            no atom numbers < 0 or > Natoms */
         if (NBond.end() != find_if(NBond.begin(),
                                    NBond.end(),
-                                   bind2nd(less_equal<int>(), 0)) ||
+                                   bind(less_equal<int>(), std::placeholders::_1, 0)) ||
             NBond.end() != find_if(NBond.begin(),
                                    NBond.end(),
-                                   bind2nd(greater<int>(), MxBond)) ||
+                                   bind(greater<int>(), std::placeholders::_1, MxBond)) ||
             IBond.end() != find_if(IBond.begin(),
                                    IBond.end(),
-                                   bind2nd(less<int>(), 0)) ||
+                                   bind(less<int>(), std::placeholders::_1, 0)) ||
             IBond.end() != find_if(IBond.begin(),
                                    IBond.end(),
-                                   bind2nd(greater<int>(), Natoms)))
+                                   bind(greater<int>(), std::placeholders::_1, Natoms)))
           {
             error_msg << "Invalid connectivity : check the \"NBond\" and/or"
                       << " \"IBond\" section(s).";
Index: rdkit-src/rdkit/Code/GraphMol/FileParsers/PNGParser.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/FileParsers/PNGParser.cpp b/rdkit-src/rdkit/Code/GraphMol/FileParsers/PNGParser.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/FileParsers/PNGParser.cpp	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/GraphMol/FileParsers/PNGParser.cpp	(date 1689048276114)
@@ -22,7 +22,6 @@
 
 #include "FileParsers.h"
 #ifdef RDK_USE_BOOST_IOSTREAMS
-#include <zlib.h>
 #include <boost/iostreams/filtering_streambuf.hpp>
 #include <boost/iostreams/copy.hpp>
 #include <boost/iostreams/filter/zlib.hpp>
Index: openbabel-src/openbabel/src/formats/mdffformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/mdffformat.cpp b/openbabel-src/openbabel/src/formats/mdffformat.cpp
--- a/openbabel-src/openbabel/src/formats/mdffformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/mdffformat.cpp	(date 1689048275882)
@@ -30,9 +30,13 @@
 #include <algorithm>
 
 #ifdef _MSC_VER
+#ifndef INFINITY
 #define INFINITY (DBL_MAX+DBL_MAX)
+#endif
+#ifndef NAN
 #define NAN (INFINITY-INFINITY)
 #endif
+#endif
 
 using namespace std;
 namespace OpenBabel {
@@ -133,7 +137,7 @@
     //    path = buffer;
     string full_path = pConv->GetInFilename();
     size_t found = full_path.rfind("/");
-    string path = (found == string::npos) ? "" : path.substr(0, found);
+    string path = (found == string::npos) ? "" : full_path.substr(0, found);
     string short_fn = full_path.substr(path.length(), string::npos);
 
     // Open files
Index: boost-src/boost/libs/gil/include/boost/gil/extension/rasterization/ellipse.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/gil/include/boost/gil/extension/rasterization/ellipse.hpp b/boost-src/boost/libs/gil/include/boost/gil/extension/rasterization/ellipse.hpp
--- a/boost-src/boost/libs/gil/include/boost/gil/extension/rasterization/ellipse.hpp	(revision 8994c2ff8ed8b88e0ffef9658a4c603c4a001fad)
+++ b/boost-src/boost/libs/gil/include/boost/gil/extension/rasterization/ellipse.hpp	(date 1689048274926)
@@ -37,8 +37,8 @@
     /// center respectively.
     /// \param semi_axes - Point containing positive integer lengths of horizontal semi-axis
     /// and vertical semi-axis respectively.
-    midpoint_ellipse_rasterizer(point<unsigned int> center_point,
-        point<unsigned int> semi_axes_values)
+    midpoint_ellipse_rasterizer(point_t center_point,
+        point_t semi_axes_values)
         : center(center_point)
         , semi_axes(semi_axes_values)
     {}
@@ -130,7 +130,7 @@
         }
 
         // mutable center copy
-        point<unsigned int> center2(center);
+        point_t center2(center);
         --center2[0], --center2[1]; // For converting center co-ordinate values to zero based indexing.
         for (point_t pnt : trajectory_points)
         {
@@ -186,8 +186,8 @@
         draw_curve(view, pixel, obtain_trajectory());
     }
 
-    point<unsigned int> center;
-    point<unsigned int> semi_axes;
+    point_t center;
+    point_t semi_axes;
 };
 
 namespace detail {
Index: openbabel-src/openbabel/src/formats/xtcformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/xtcformat.cpp b/openbabel-src/openbabel/src/formats/xtcformat.cpp
--- a/openbabel-src/openbabel/src/formats/xtcformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/xtcformat.cpp	(date 1689048275886)
@@ -29,7 +29,7 @@
 #include <vector>
 
 #define MAXID 20
-#define MAXABS INT_MAX-2
+#define MAXABS float(INT_MAX-2)
 
 #ifndef MIN
 #define MIN(x,y) ((x) < (y) ? (x):(y))
Index: openbabel-src/openbabel/src/formats/exampleformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/exampleformat.cpp b/openbabel-src/openbabel/src/formats/exampleformat.cpp
--- a/openbabel-src/openbabel/src/formats/exampleformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/exampleformat.cpp	(date 1689048275870)
@@ -32,6 +32,7 @@
 
 #include <openbabel/babelconfig.h>
 #include <openbabel/obmolecformat.h>
+#include <openbabel/mol.h>
 
 using namespace std;
 namespace OpenBabel
Index: openbabel-src/openbabel/src/formats/json/pubchemjsonformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/json/pubchemjsonformat.cpp b/openbabel-src/openbabel/src/formats/json/pubchemjsonformat.cpp
--- a/openbabel-src/openbabel/src/formats/json/pubchemjsonformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/json/pubchemjsonformat.cpp	(date 1689048275870)
@@ -760,7 +760,7 @@
       // Coordinates
       // TODO: An option to round coordinates to n decimal places?
       xcoords.PushBack(rapidjson::Value(patom->GetX()).Move(), al);
-      ycoords.PushBack(rapidjson::Value(patom->GetX()).Move(), al);
+      ycoords.PushBack(rapidjson::Value(patom->GetY()).Move(), al);
       if (pmol->GetDimension() == 3) {
         zcoords.PushBack(rapidjson::Value(patom->GetZ()).Move(), al);
       }
Index: rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTree.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTree.h b/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTree.h
--- a/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTree.h	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTree.h	(date 1689048276102)
@@ -13,7 +13,7 @@
 #define _RD_FEATTREE_H_
 
 #include <boost/graph/adjacency_list.hpp>
-#include <boost/property_map.hpp>
+#include <boost/property_map/property_map.hpp>
 #include <boost/shared_ptr.hpp>
 #include <set>
 
Index: inchi-src/inchi/INCHI_BASE/src/util.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_BASE/src/util.c b/inchi-src/inchi/INCHI_BASE/src/util.c
--- a/inchi-src/inchi/INCHI_BASE/src/util.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_BASE/src/util.c	(date 1689048275434)
@@ -38,10 +38,6 @@
 
 #include "mode.h"
 
-#if defined(COMPILE_ANSI_ONLY) && defined(__APPLE__)
-/*    For build under OSX, advice from Burt Leland */
-#include "ichicomp.h"    /* Needed for __isascii define */
-#endif
 
 #include "util.h"
 #include "extr_ct.h"
@@ -1741,13 +1737,13 @@
 
     if (p && ( len = (int) strlen( p ) ))
     {
-        for (i = 0; i < len && __isascii( p[i] ) && isspace( p[i] ); i++)
+        for (i = 0; i < len && isascii( p[i] ) && isspace( p[i] ); i++)
         {
             ;
         }
         if (i)
             (memmove) ( p, p + i, ( len -= i ) + 1 );
-        for (; 0 < len && __isascii( p[len - 1] ) && isspace( p[len - 1] ); len--)
+        for (; 0 < len && isascii( p[len - 1] ) && isspace( p[len - 1] ); len--)
         {
             ;
         }
Index: inchi-src/inchi/INCHI_BASE/src/ichicano.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_BASE/src/ichicano.c b/inchi-src/inchi/INCHI_BASE/src/ichicano.c
--- a/inchi-src/inchi/INCHI_BASE/src/ichicano.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_BASE/src/ichicano.c	(date 1689048275418)
@@ -37,7 +37,6 @@
 #include <string.h>
 #include <ctype.h>
 #include <time.h>
-#include <sys/timeb.h>
 
 #include "mode.h"
 #include "ichicano.h"
Index: openbabel-src/openbabel/src/formats/povrayformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/povrayformat.cpp b/openbabel-src/openbabel/src/formats/povrayformat.cpp
--- a/openbabel-src/openbabel/src/formats/povrayformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/povrayformat.cpp	(date 1689048275882)
@@ -523,7 +523,7 @@
 
         /* ---- Add a pigment - statement for start-atom of bond ---- */
         bond_type = bond->GetBeginAtom() -> GetType();
-        bond_type.erase(remove_if(bond_type.begin(), bond_type.end(), bind1st(equal_to<char>(), '.')), bond_type.end());
+        bond_type.erase(remove(bond_type.begin(), bond_type.end(), '.'), bond_type.end());
         ofs << "\t    pigment{color Color_"
             << bond_type
             << "}" << endl;
@@ -584,7 +584,7 @@
 
         /* ---- Add a pigment - statement for end-atom of bond i ---- */
         bond_type = bond->GetEndAtom() -> GetType();
-        bond_type.erase(remove_if(bond_type.begin(), bond_type.end(), bind1st(equal_to<char>(), '.')), bond_type.end());
+        bond_type.erase(remove(bond_type.begin(), bond_type.end(), '.'), bond_type.end());
 
         ofs << "\t    pigment{color Color_"
             << bond_type
Index: opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/convolution.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/convolution.cpp b/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/convolution.cpp
--- a/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/convolution.cpp	(revision f9a59f2592993d3dcc080e495f4f5e02dd8ec7ef)
+++ b/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/convolution.cpp	(date 1689048275942)
@@ -16,6 +16,638 @@
 #include "layers/cpu_kernels/conv_block.simd_declarations.hpp" // defines CV_CPU_DISPATCH_MODES_ALL=AVX2,...,BASELINE based on CMakeLists.txt content
 
 namespace cv { namespace dnn {
+
+// NEON code work around.
+namespace opt_NEON
+{
+#if CV_NEON
+
+void convBlock(int np, const float* a, const float* b, float* c, int ldc, bool init_c, int width, const int convMR, const int convNR)
+{
+#if CV_NEON_AARCH64
+    if (convMR == 4 && convNR == 28) // AARCH64
+    {
+        float32x4_t c00 = vdupq_n_f32(0.f), c01 = c00, c02 = c00, c03 = c00, c04 = c00, c05 = c00, c06 = c00;
+        float32x4_t c10 = vdupq_n_f32(0.f), c11 = c10, c12 = c10, c13 = c10, c14 = c10, c15 = c10, c16 = c10;
+        float32x4_t c20 = vdupq_n_f32(0.f), c21 = c20, c22 = c20, c23 = c20, c24 = c20, c25 = c20, c26 = c20;
+        float32x4_t c30 = vdupq_n_f32(0.f), c31 = c30, c32 = c30, c33 = c30, c34 = c30, c35 = c30, c36 = c30;
+
+        if (width > 16)
+        {
+            for( int p = 0; p < np; p++, a += convMR, b += convNR )
+            {
+                float32x4_t a0 = vld1q_f32(a), b0, b1, b2;
+                b0 = vld1q_f32(b); b1 = vld1q_f32(b + 4); b2 = vld1q_f32(b + 8);
+
+                c00 = vfmaq_laneq_f32(c00, b0, a0, 0);
+                c01 = vfmaq_laneq_f32(c01, b1, a0, 0);
+                c02 = vfmaq_laneq_f32(c02, b2, a0, 0);
+                c10 = vfmaq_laneq_f32(c10, b0, a0, 1);
+                c11 = vfmaq_laneq_f32(c11, b1, a0, 1);
+                c12 = vfmaq_laneq_f32(c12, b2, a0, 1);
+                c20 = vfmaq_laneq_f32(c20, b0, a0, 2);
+                c21 = vfmaq_laneq_f32(c21, b1, a0, 2);
+                c22 = vfmaq_laneq_f32(c22, b2, a0, 2);
+                c30 = vfmaq_laneq_f32(c30, b0, a0, 3);
+                c31 = vfmaq_laneq_f32(c31, b1, a0, 3);
+                c32 = vfmaq_laneq_f32(c32, b2, a0, 3);
+
+                b0 = vld1q_f32(b + 12); b1 = vld1q_f32(b + 16); b2 = vld1q_f32(b + 20);
+
+                c03 = vfmaq_laneq_f32(c03, b0, a0, 0);
+                c04 = vfmaq_laneq_f32(c04, b1, a0, 0);
+                c05 = vfmaq_laneq_f32(c05, b2, a0, 0);
+                c13 = vfmaq_laneq_f32(c13, b0, a0, 1);
+                c14 = vfmaq_laneq_f32(c14, b1, a0, 1);
+                c15 = vfmaq_laneq_f32(c15, b2, a0, 1);
+                c23 = vfmaq_laneq_f32(c23, b0, a0, 2);
+                c24 = vfmaq_laneq_f32(c24, b1, a0, 2);
+                c25 = vfmaq_laneq_f32(c25, b2, a0, 2);
+                c33 = vfmaq_laneq_f32(c33, b0, a0, 3);
+                c34 = vfmaq_laneq_f32(c34, b1, a0, 3);
+                c35 = vfmaq_laneq_f32(c35, b2, a0, 3);
+
+                b0 = vld1q_f32(b + 24);
+                c06 = vfmaq_laneq_f32(c06, b0, a0, 0);
+                c16 = vfmaq_laneq_f32(c16, b0, a0, 1);
+                c26 = vfmaq_laneq_f32(c26, b0, a0, 2);
+                c36 = vfmaq_laneq_f32(c36, b0, a0, 3);
+            }
+        }
+        else if (width > 8)
+        {
+            for( int p = 0; p < np; p++, a += convMR, b += convNR )
+            {
+                float32x4_t a0 = vld1q_f32(a), b0, b1, b2;
+                b0 = vld1q_f32(b); b1 = vld1q_f32(b + 4); b2 = vld1q_f32(b + 8);
+
+                c00 = vfmaq_laneq_f32(c00, b0, a0, 0);
+                c01 = vfmaq_laneq_f32(c01, b1, a0, 0);
+                c02 = vfmaq_laneq_f32(c02, b2, a0, 0);
+                c10 = vfmaq_laneq_f32(c10, b0, a0, 1);
+                c11 = vfmaq_laneq_f32(c11, b1, a0, 1);
+                c12 = vfmaq_laneq_f32(c12, b2, a0, 1);
+                c20 = vfmaq_laneq_f32(c20, b0, a0, 2);
+                c21 = vfmaq_laneq_f32(c21, b1, a0, 2);
+                c22 = vfmaq_laneq_f32(c22, b2, a0, 2);
+                c30 = vfmaq_laneq_f32(c30, b0, a0, 3);
+                c31 = vfmaq_laneq_f32(c31, b1, a0, 3);
+                c32 = vfmaq_laneq_f32(c32, b2, a0, 3);
+
+                b0 = vld1q_f32(b + 12);
+
+                c03 = vfmaq_laneq_f32(c03, b0, a0, 0);
+                c13 = vfmaq_laneq_f32(c13, b0, a0, 1);
+                c23 = vfmaq_laneq_f32(c23, b0, a0, 2);
+                c33 = vfmaq_laneq_f32(c33, b0, a0, 3);
+            }
+        }
+        else if (width > 4)
+        {
+            for( int p = 0; p < np; p++, a += convMR, b += convNR )
+            {
+                float32x4_t a0 = vld1q_f32(a), b0, b1;
+                b0 = vld1q_f32(b); b1 = vld1q_f32(b + 4);
+
+                c00 = vfmaq_laneq_f32(c00, b0, a0, 0);
+                c01 = vfmaq_laneq_f32(c01, b1, a0, 0);
+                c10 = vfmaq_laneq_f32(c10, b0, a0, 1);
+                c11 = vfmaq_laneq_f32(c11, b1, a0, 1);
+                c20 = vfmaq_laneq_f32(c20, b0, a0, 2);
+                c21 = vfmaq_laneq_f32(c21, b1, a0, 2);
+                c30 = vfmaq_laneq_f32(c30, b0, a0, 3);
+                c31 = vfmaq_laneq_f32(c31, b1, a0, 3);
+            }
+        }
+        else
+        {
+            for( int p = 0; p < np; p++, a += convMR, b += convNR )
+            {
+                float32x4_t a0 = vld1q_f32(a), b0;
+                b0 = vld1q_f32(b);
+
+                c00 = vfmaq_laneq_f32(c00, b0, a0, 0);
+                c10 = vfmaq_laneq_f32(c10, b0, a0, 1);
+                c20 = vfmaq_laneq_f32(c20, b0, a0, 2);
+                c30 = vfmaq_laneq_f32(c30, b0, a0, 3);
+            }
+        }
+
+        if (!init_c)
+        {
+            c00 = vaddq_f32(c00, vld1q_f32(c));
+            c01 = vaddq_f32(c01, vld1q_f32(c + 4));
+            c02 = vaddq_f32(c02, vld1q_f32(c + 8));
+            c03 = vaddq_f32(c03, vld1q_f32(c + 12));
+            c04 = vaddq_f32(c04, vld1q_f32(c + 16));
+            c05 = vaddq_f32(c05, vld1q_f32(c + 20));
+            c06 = vaddq_f32(c06, vld1q_f32(c + 24));
+
+            c10 = vaddq_f32(c10, vld1q_f32(c + ldc));
+            c11 = vaddq_f32(c11, vld1q_f32(c + ldc + 4));
+            c12 = vaddq_f32(c12, vld1q_f32(c + ldc + 8));
+            c13 = vaddq_f32(c13, vld1q_f32(c + ldc + 12));
+            c14 = vaddq_f32(c14, vld1q_f32(c + ldc + 16));
+            c15 = vaddq_f32(c15, vld1q_f32(c + ldc + 20));
+            c16 = vaddq_f32(c16, vld1q_f32(c + ldc + 24));
+
+            c20 = vaddq_f32(c20, vld1q_f32(c + ldc*2));
+            c21 = vaddq_f32(c21, vld1q_f32(c + ldc*2 + 4));
+            c22 = vaddq_f32(c22, vld1q_f32(c + ldc*2 + 8));
+            c23 = vaddq_f32(c23, vld1q_f32(c + ldc*2 + 12));
+            c24 = vaddq_f32(c24, vld1q_f32(c + ldc*2 + 16));
+            c25 = vaddq_f32(c25, vld1q_f32(c + ldc*2 + 20));
+            c26 = vaddq_f32(c26, vld1q_f32(c + ldc*2 + 24));
+
+            c30 = vaddq_f32(c30, vld1q_f32(c + ldc*3));
+            c31 = vaddq_f32(c31, vld1q_f32(c + ldc*3 + 4));
+            c32 = vaddq_f32(c32, vld1q_f32(c + ldc*3 + 8));
+            c33 = vaddq_f32(c33, vld1q_f32(c + ldc*3 + 12));
+            c34 = vaddq_f32(c34, vld1q_f32(c + ldc*3 + 16));
+            c35 = vaddq_f32(c35, vld1q_f32(c + ldc*3 + 20));
+            c36 = vaddq_f32(c36, vld1q_f32(c + ldc*3 + 24));
+        }
+
+        vst1q_f32(c, c00); vst1q_f32(c+4, c01);
+        vst1q_f32(c+8, c02); vst1q_f32(c+12, c03);
+        vst1q_f32(c+16, c04); vst1q_f32(c+20, c05);
+        vst1q_f32(c+24, c06);
+
+        vst1q_f32(c+ldc, c10); vst1q_f32(c+ldc+4, c11);
+        vst1q_f32(c+ldc+8, c12); vst1q_f32(c+ldc+12, c13);
+        vst1q_f32(c+ldc+16, c14); vst1q_f32(c+ldc+20, c15);
+        vst1q_f32(c+ldc+24, c16);
+
+        vst1q_f32(c+ldc*2, c20); vst1q_f32(c+ldc*2+4, c21);
+        vst1q_f32(c+ldc*2+8, c22); vst1q_f32(c+ldc*2+12, c23);
+        vst1q_f32(c+ldc*2+16, c24); vst1q_f32(c+ldc*2+20, c25);
+        vst1q_f32(c+ldc*2+24, c26);
+
+        vst1q_f32(c+ldc*3, c30); vst1q_f32(c+ldc*3+4, c31);
+        vst1q_f32(c+ldc*3+8, c32); vst1q_f32(c+ldc*3+12, c33);
+        vst1q_f32(c+ldc*3+16, c34); vst1q_f32(c+ldc*3+20, c35);
+        vst1q_f32(c+ldc*3+24, c36);
+    }
+    else
+#endif
+    if (convMR == 4 && convNR == 12) // ARMv7
+    {
+        float32x4_t c0 = vdupq_n_f32(0.f), c1 = c0, c2 = c0;
+        float32x4_t c3 = vdupq_n_f32(0.f), c4 = c3, c5 = c3;
+        float32x4_t c6 = vdupq_n_f32(0.f), c7 = c6, c8 = c6;
+        float32x4_t c9 = vdupq_n_f32(0.f), c10 = c9, c11 = c9;
+
+        float32x2_t a0 = vdup_n_f32(0.0f), a1 = a0;
+        float32x4_t b0 = vdupq_n_f32(0.0f), b1 = vdupq_n_f32(0.0f), b2 = vdupq_n_f32(0.0f);
+
+        if (width > 8)
+        {
+            for (int p = 0; p < np; p++, a += convMR, b += convNR)
+            {
+                a0 = vld1_f32(a), a1 = vld1_f32(a+2);
+                b0 = vld1q_f32(b), b1 = vld1q_f32(b + 4), b2 = vld1q_f32(b + 8);
+
+                c0 = vmlaq_lane_f32(c0, b0, a0, 0);
+                c1 = vmlaq_lane_f32(c1, b1, a0, 0);
+                c2 = vmlaq_lane_f32(c2, b2, a0, 0);
+
+                c3 = vmlaq_lane_f32(c3, b0, a0, 1);
+                c4 = vmlaq_lane_f32(c4, b1, a0, 1);
+                c5 = vmlaq_lane_f32(c5, b2, a0, 1);
+
+                c6 = vmlaq_lane_f32(c6, b0, a1, 0);
+                c7 = vmlaq_lane_f32(c7, b1, a1, 0);
+                c8 = vmlaq_lane_f32(c8, b2, a1, 0);
+
+                c9  = vmlaq_lane_f32(c9 , b0, a1, 1);
+                c10 = vmlaq_lane_f32(c10, b1, a1, 1);
+                c11 = vmlaq_lane_f32(c11, b2, a1, 1);
+            }
+        }
+        else if (width > 4)
+        {
+            for (int p = 0; p < np; p++, a += convMR, b += convNR)
+            {
+                a0 = vld1_f32(a), a1 = vld1_f32(a+2);
+                b0 = vld1q_f32(b), b1 = vld1q_f32(b + 4);
+
+                c0 = vmlaq_lane_f32(c0, b0, a0, 0);
+                c1 = vmlaq_lane_f32(c1, b1, a0, 0);
+
+                c3 = vmlaq_lane_f32(c3, b0, a0, 1);
+                c4 = vmlaq_lane_f32(c4, b1, a0, 1);
+
+                c6 = vmlaq_lane_f32(c6, b0, a1, 0);
+                c7 = vmlaq_lane_f32(c7, b1, a1, 0);
+
+                c9  = vmlaq_lane_f32(c9 , b0, a1, 1);
+                c10 = vmlaq_lane_f32(c10, b1, a1, 1);
+            }
+        }
+        else
+        {
+            for (int p = 0; p < np; p++, a += convMR, b += convNR)
+            {
+                a0 = vld1_f32(a), a1 = vld1_f32(a+2);
+                b0 = vld1q_f32(b);
+
+                c0 = vmlaq_lane_f32(c0, b0, a0, 0);
+                c3 = vmlaq_lane_f32(c3, b0, a0, 1);
+                c6 = vmlaq_lane_f32(c6, b0, a1, 0);
+                c9  = vmlaq_lane_f32(c9 , b0, a1, 1);
+            }
+        }
+
+        if (!init_c)
+        {
+            c0 = vaddq_f32(c0, vld1q_f32(c));
+            c1 = vaddq_f32(c1, vld1q_f32(c + 4));
+            c2 = vaddq_f32(c2, vld1q_f32(c + 8));
+
+            c3 = vaddq_f32(c3, vld1q_f32(c + ldc));
+            c4 = vaddq_f32(c4, vld1q_f32(c + ldc + 4));
+            c5 = vaddq_f32(c5, vld1q_f32(c + ldc + 8));
+
+            c6 = vaddq_f32(c6, vld1q_f32(c + ldc * 2));
+            c7 = vaddq_f32(c7, vld1q_f32(c + ldc * 2 + 4));
+            c8 = vaddq_f32(c8, vld1q_f32(c + ldc * 2 + 8));
+
+            c9  = vaddq_f32(c9 , vld1q_f32(c + ldc * 3));
+            c10 = vaddq_f32(c10, vld1q_f32(c + ldc * 3 + 4));
+            c11 = vaddq_f32(c11, vld1q_f32(c + ldc * 3 + 8));
+        }
+
+        vst1q_f32(c, c0), vst1q_f32(c+4, c1), vst1q_f32(c+8, c2);
+        vst1q_f32(c + ldc, c3), vst1q_f32(c + ldc + 4, c4), vst1q_f32(c + ldc + 8, c5);
+        vst1q_f32(c + ldc*2, c6), vst1q_f32(c + ldc*2 + 4, c7), vst1q_f32(c + ldc*2 + 8, c8);
+        vst1q_f32(c + ldc*3, c9), vst1q_f32(c + ldc*3 + 4, c10), vst1q_f32(c + ldc*3 + 8, c11);
+    }
+    else
+        CV_Error(Error::StsNotImplemented, "Unsupported convMR and/or convNR in opt_NEON::convBlock");
+}
+
+void convBlockMR1_F32(int np, const float * a, const float * b, float *c, const float bias, bool init_c,
+                  const float minval, const float maxval, bool ifMinMaxAct, const int width, const int convNR)
+{
+    CV_Assert(convNR == 28);
+    float32x4_t c0 = vdupq_n_f32(bias), c1 = c0, c2 = c0;
+    float32x4_t c3 = c0, c4 = c0, c5 = c0, c6 = c0;
+
+    if (width > 16)
+    {
+        for (int p = 0; p < np; p++, a++, b += convNR)
+        {
+            float32x4_t b0 = vld1q_f32(b), b1 = vld1q_f32(b + 4), b2 = vld1q_f32(b + 8);
+            float32x4_t b3 = vld1q_f32(b + 12), b4 = vld1q_f32(b + 16), b5 = vld1q_f32(b + 20);
+            float32x4_t b6 = vld1q_f32(b + 24);
+
+            c0 = vmlaq_n_f32(c0, b0, a[0]);
+            c1 = vmlaq_n_f32(c1, b1, a[0]);
+            c2 = vmlaq_n_f32(c2, b2, a[0]);
+            c3 = vmlaq_n_f32(c3, b3, a[0]);
+            c4 = vmlaq_n_f32(c4, b4, a[0]);
+            c5 = vmlaq_n_f32(c5, b5, a[0]);
+            c6 = vmlaq_n_f32(c6, b6, a[0]);
+        }
+    }
+    else if (width > 8)
+    {
+        for (int p = 0; p < np; p++, a++, b += convNR)
+        {
+            float32x4_t b0 = vld1q_f32(b), b1 = vld1q_f32(b + 4), b2 = vld1q_f32(b + 8);
+            float32x4_t b3 = vld1q_f32(b + 12);
+
+            c0 = vmlaq_n_f32(c0, b0, a[0]);
+            c1 = vmlaq_n_f32(c1, b1, a[0]);
+            c2 = vmlaq_n_f32(c2, b2, a[0]);
+            c3 = vmlaq_n_f32(c3, b3, a[0]);
+        }
+    }
+    else if (width > 4)
+    {
+        for (int p = 0; p < np; p++, a++, b += convNR)
+        {
+            float32x4_t b0 = vld1q_f32(b), b1 = vld1q_f32(b + 4);
+
+            c0 = vmlaq_n_f32(c0, b0, a[0]);
+            c1 = vmlaq_n_f32(c1, b1, a[0]);
+        }
+    }
+    else
+    {
+        for (int p = 0; p < np; p++, a++, b += convNR)
+        {
+            float32x4_t b0 = vld1q_f32(b);
+            c0 = vmlaq_n_f32(c0, b0, a[0]);
+        }
+    }
+
+    if (init_c)
+    {
+        c0 += vld1q_f32(c);
+        c1 += vld1q_f32(c + 4);
+        c2 += vld1q_f32(c + 8);
+        c3 += vld1q_f32(c + 12);
+        c4 += vld1q_f32(c + 16);
+        c5 += vld1q_f32(c + 20);
+        c6 += vld1q_f32(c + 24);
+    }
+
+    if (ifMinMaxAct)
+    {
+        float32x4_t v_minval = vdupq_n_f32(minval), v_maxval = vdupq_n_f32(maxval);
+
+        c0 = vminq_f32(vmaxq_f32(c0, v_minval), v_maxval);
+        c1 = vminq_f32(vmaxq_f32(c1, v_minval), v_maxval);
+        c2 = vminq_f32(vmaxq_f32(c2, v_minval), v_maxval);
+        c3 = vminq_f32(vmaxq_f32(c3, v_minval), v_maxval);
+        c4 = vminq_f32(vmaxq_f32(c4, v_minval), v_maxval);
+        c5 = vminq_f32(vmaxq_f32(c5, v_minval), v_maxval);
+        c6 = vminq_f32(vmaxq_f32(c6, v_minval), v_maxval);
+    }
+
+    vst1q_f32(c, c0);
+    vst1q_f32(c + 4, c1);
+    vst1q_f32(c + 8, c2);
+    vst1q_f32(c + 12, c3);
+    vst1q_f32(c + 16, c4);
+    vst1q_f32(c + 20, c5);
+    vst1q_f32(c + 24, c6);
+}
+
+#if CV_NEON_AARCH64 && defined(__ARM_FEATURE_FP16_VECTOR_ARITHMETIC)
+// Fix conflict between float16_t in arm_neon.h and float16_t in cvdef.h.
+typedef __fp16 float16_t;
+
+#ifndef __ARM_FEATURE_FMA // Work around without FMA support.
+#define vfmaq_f16(a, b, c) (a + b * c)
+#endif
+void convBlock_FP16(int np, const char * _a, const char * _b, char * _c, int ldc, bool init_c, int width,
+                    const int convMR_fp16, const int convNR_fp16)
+{
+#if 1
+    const float16_t* a = (const float16_t*)_a;
+    const float16_t* b = (const float16_t*)_b;
+    float16_t* c = (float16_t*)_c;
+
+    CV_Assert(convMR_fp16 == 8 && convNR_fp16 == 24);
+
+    float16x8_t c00 = vdupq_n_f16(0), c01 = c00, c02 = c00;
+    float16x8_t c10 = c00, c11 = c00, c12 = c00;
+    float16x8_t c20 = c00, c21 = c00, c22 = c00;
+    float16x8_t c30 = c00, c31 = c00, c32 = c00;
+    float16x8_t c40 = c00, c41 = c00, c42 = c00;
+    float16x8_t c50 = c00, c51 = c00, c52 = c00;
+    float16x8_t c60 = c00, c61 = c00, c62 = c00;
+    float16x8_t c70 = c00, c71 = c00, c72 = c00;
+
+    float16x8_t b0 = c00, b1 = c00, b2 = c00;
+
+    if (width > 16)
+    {
+        for (int p = 0; p < np; p++, a += convMR_fp16, b += convNR_fp16)
+        {
+            float16x4_t a0 = vld1_f16(a), a1 = vld1_f16(a + 4);
+            b0 = vld1q_f16(b), b1 = vld1q_f16(b + 8), b2 = vld1q_f16(b + 16);
+
+            c00 = vfmaq_lane_f16(c00, b0, a0, 0);
+            c01 = vfmaq_lane_f16(c01, b1, a0, 0);
+            c02 = vfmaq_lane_f16(c02, b2, a0, 0);
+
+            c10 = vfmaq_lane_f16(c10, b0, a0, 1);
+            c11 = vfmaq_lane_f16(c11, b1, a0, 1);
+            c12 = vfmaq_lane_f16(c12, b2, a0, 1);
+
+            c20 = vfmaq_lane_f16(c20, b0, a0, 2);
+            c21 = vfmaq_lane_f16(c21, b1, a0, 2);
+            c22 = vfmaq_lane_f16(c22, b2, a0, 2);
+
+            c30 = vfmaq_lane_f16(c30, b0, a0, 3);
+            c31 = vfmaq_lane_f16(c31, b1, a0, 3);
+            c32 = vfmaq_lane_f16(c32, b2, a0, 3);
+
+            c40 = vfmaq_lane_f16(c40, b0, a1, 0);
+            c41 = vfmaq_lane_f16(c41, b1, a1, 0);
+            c42 = vfmaq_lane_f16(c42, b2, a1, 0);
+
+            c50 = vfmaq_lane_f16(c50, b0, a1, 1);
+            c51 = vfmaq_lane_f16(c51, b1, a1, 1);
+            c52 = vfmaq_lane_f16(c52, b2, a1, 1);
+
+            c60 = vfmaq_lane_f16(c60, b0, a1, 2);
+            c61 = vfmaq_lane_f16(c61, b1, a1, 2);
+            c62 = vfmaq_lane_f16(c62, b2, a1, 2);
+
+            c70 = vfmaq_lane_f16(c70, b0, a1, 3);
+            c71 = vfmaq_lane_f16(c71, b1, a1, 3);
+            c72 = vfmaq_lane_f16(c72, b2, a1, 3);
+        }
+    }
+    else if (width > 8)
+    {
+        for( int p = 0; p < np; p++, a += convMR_fp16, b += convNR_fp16)
+        {
+            float16x4_t a0 = vld1_f16(a), a1 = vld1_f16(a + 4);
+            float16x8_t b0 = vld1q_f16(b), b1 = vld1q_f16(b + 8);
+
+            c00 = vfmaq_lane_f16(c00, b0, a0, 0);
+            c01 = vfmaq_lane_f16(c01, b1, a0, 0);
+
+            c10 = vfmaq_lane_f16(c10, b0, a0, 1);
+            c11 = vfmaq_lane_f16(c11, b1, a0, 1);
+
+            c20 = vfmaq_lane_f16(c20, b0, a0, 2);
+            c21 = vfmaq_lane_f16(c21, b1, a0, 2);
+
+            c30 = vfmaq_lane_f16(c30, b0, a0, 3);
+            c31 = vfmaq_lane_f16(c31, b1, a0, 3);
+
+            c40 = vfmaq_lane_f16(c40, b0, a1, 0);
+            c41 = vfmaq_lane_f16(c41, b1, a1, 0);
+
+            c50 = vfmaq_lane_f16(c50, b0, a1, 1);
+            c51 = vfmaq_lane_f16(c51, b1, a1, 1);
+
+            c60 = vfmaq_lane_f16(c60, b0, a1, 2);
+            c61 = vfmaq_lane_f16(c61, b1, a1, 2);
+
+            c70 = vfmaq_lane_f16(c70, b0, a1, 3);
+            c71 = vfmaq_lane_f16(c71, b1, a1, 3);
+        }
+    }
+    else
+    {
+        for( int p = 0; p < np; p++, a += convMR_fp16, b += convNR_fp16)
+        {
+            float16x4_t a0 = vld1_f16(a), a1 = vld1_f16(a + 4);
+            float16x8_t b0 = vld1q_f16(b);
+
+            c00 = vfmaq_lane_f16(c00, b0, a0, 0);
+            c10 = vfmaq_lane_f16(c10, b0, a0, 1);
+            c20 = vfmaq_lane_f16(c20, b0, a0, 2);
+            c30 = vfmaq_lane_f16(c30, b0, a0, 3);
+            c40 = vfmaq_lane_f16(c40, b0, a1, 0);
+            c50 = vfmaq_lane_f16(c50, b0, a1, 1);
+            c60 = vfmaq_lane_f16(c60, b0, a1, 2);
+            c70 = vfmaq_lane_f16(c70, b0, a1, 3);
+        }
+    }
+
+    if (!init_c)
+    {
+#undef _FX_UPDATE_CBUF_ROW
+#define _FX_UPDATE_CBUF_ROW(row) \
+        c##row##0 = c##row##0 + vld1q_f16(c + row*ldc); \
+        c##row##1 = c##row##1 + vld1q_f16(c + row*ldc + 8); \
+        c##row##2 = c##row##2 + vld1q_f16(c + row*ldc + 16)
+
+        _FX_UPDATE_CBUF_ROW(0);
+        _FX_UPDATE_CBUF_ROW(1);
+        _FX_UPDATE_CBUF_ROW(2);
+        _FX_UPDATE_CBUF_ROW(3);
+        _FX_UPDATE_CBUF_ROW(4);
+        _FX_UPDATE_CBUF_ROW(5);
+        _FX_UPDATE_CBUF_ROW(6);
+        _FX_UPDATE_CBUF_ROW(7);
+    }
+
+#undef _FX_STORE_CBUF_ROW
+#define _FX_STORE_CBUF_ROW(row) \
+    vst1q_f16(c + row*ldc, c##row##0); \
+    vst1q_f16(c + row*ldc + 8, c##row##1); \
+    vst1q_f16(c + row*ldc + 16, c##row##2)
+
+    _FX_STORE_CBUF_ROW(0);
+    _FX_STORE_CBUF_ROW(1);
+    _FX_STORE_CBUF_ROW(2);
+    _FX_STORE_CBUF_ROW(3);
+    _FX_STORE_CBUF_ROW(4);
+    _FX_STORE_CBUF_ROW(5);
+    _FX_STORE_CBUF_ROW(6);
+    _FX_STORE_CBUF_ROW(7);
+#else
+    // reference only.
+    const float16_t* a = (const float16_t*)_a;
+    const float16_t* b = (const float16_t*)_b;
+    float16_t* c = (float16_t*)_c;
+    float cbuf[convMR_fp16*convNR_fp16];
+    memset(cbuf, 0, sizeof(cbuf));
+
+    for( int p = 0; p < np; p++ )
+    {
+        for( int i = 0; i < convMR_fp16; i++ )
+        {
+            float ai = float(a[convMR_fp16*p + i]);
+                for( int j = 0; j < convNR_fp16; j++ )
+                    cbuf[i*convNR_fp16+j] += float(b[convNR_fp16*p + j]) * ai;
+        }
+    }
+
+    if (!init_c)
+    {
+    for(int i = 0; i < convMR_fp16; i++)
+        {
+            for(int j = 0; j < convNR_fp16; j++)
+                c[i*ldc + j] = float16_t(float(c[i*ldc + j]) + cbuf[i*convNR_fp16 + j]);
+        }
+    }
+    else
+    {
+        for(int i = 0; i < convMR_fp16; i++)
+        {
+            for(int j = 0; j < convNR_fp16; j++)
+                c[i*ldc + j] = (float16_t)(cbuf[i*convNR_fp16 + j]);
+        }
+    }
+#endif
+}
+
+void convBlockMR1_FP16(int np, const char* _a, const char* _b, float *c, const float _bias, bool init_c,
+                            const float minval, const float maxval, bool ifMinMaxAct, const int width, const int convNR_FP16)
+{
+    CV_Assert(convNR_FP16 == 24); // CONV_NR_FP16 = 24
+    const float16_t* a = (const float16_t*)_a;
+    const float16_t* b = (const float16_t*)_b;
+
+    const float16_t bias = (float16_t)_bias;
+
+    float16x8_t c0 = vdupq_n_f16(bias), c1 = c0, c2 = c0;
+
+    if (width > 16)
+    {
+        for (int p = 0; p < np; p++, a++, b += convNR_FP16)
+        {
+            float16x8_t a0= vdupq_n_f16(a[0]);
+            float16x8_t b0 = vld1q_f16(b), b1 = vld1q_f16(b + 8), b2 = vld1q_f16(b + 16);
+
+            c0 = vfmaq_f16(c0, a0, b0);
+            c1 = vfmaq_f16(c1, a0, b1);
+            c2 = vfmaq_f16(c2, a0, b2);
+        }
+    }
+    else if (width > 8)
+    {
+        for (int p = 0; p < np; p++, a++, b += convNR_FP16)
+        {
+            float16x8_t a0= vdupq_n_f16(a[0]);
+            float16x8_t b0 = vld1q_f16(b), b1 = vld1q_f16(b + 8);
+
+            c0 = vfmaq_f16(c0, a0, b0);
+            c1 = vfmaq_f16(c1, a0, b1);
+        }
+    }
+    else
+    {
+        for (int p = 0; p < np; p++, a++, b += convNR_FP16)
+        {
+            float16x8_t a0= vdupq_n_f16(a[0]);
+            float16x8_t b0 = vld1q_f16(b);
+
+            c0 = vfmaq_f16(c0, a0, b0);
+        }
+    }
+
+    // convert FP 16 to FP 32.
+    float32x4_t c00 = vcvt_f32_f16(vget_low_f16(c0));
+    float32x4_t c01 = vcvt_f32_f16(vget_high_f16(c0));
+    float32x4_t c10 = vcvt_f32_f16(vget_low_f16(c1));
+    float32x4_t c11 = vcvt_f32_f16(vget_high_f16(c1));
+    float32x4_t c20 = vcvt_f32_f16(vget_low_f16(c2));
+    float32x4_t c21 = vcvt_f32_f16(vget_high_f16(c2));
+
+    if (init_c)
+    {
+        c00 += vld1q_f32(c);
+        c01 += vld1q_f32(c + 4);
+        c10 += vld1q_f32(c + 8);
+        c11 += vld1q_f32(c + 12);
+        c20 += vld1q_f32(c + 16);
+        c21 += vld1q_f32(c + 20);
+    }
+
+    if (ifMinMaxAct)
+    {
+        float32x4_t v_minval = vdupq_n_f32(minval), v_maxval = vdupq_n_f32(maxval);
+
+        c00 = vminq_f32(vmaxq_f32(c00, v_minval), v_maxval);
+        c01 = vminq_f32(vmaxq_f32(c01, v_minval), v_maxval);
+        c10 = vminq_f32(vmaxq_f32(c10, v_minval), v_maxval);
+        c11 = vminq_f32(vmaxq_f32(c11, v_minval), v_maxval);
+        c20 = vminq_f32(vmaxq_f32(c20, v_minval), v_maxval);
+        c21 = vminq_f32(vmaxq_f32(c21, v_minval), v_maxval);
+    }
+
+    vst1q_f32(c, c00);
+    vst1q_f32(c + 4, c01);
+    vst1q_f32(c + 8, c10);
+    vst1q_f32(c + 12, c11);
+    vst1q_f32(c + 16, c20);
+    vst1q_f32(c + 20, c21);
+}
+#endif
+
+#endif
+}
 enum { VEC_ALIGN = 32, DFT_TYPE = CV_32F }; // Memory alignment.
 
 void convBlock(int np, const float* a, const float* b, float* c, int ldc, bool init_c, const int outLen,
Index: openbabel-src/openbabel/src/formats/chemdrawcdx.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/chemdrawcdx.cpp b/openbabel-src/openbabel/src/formats/chemdrawcdx.cpp
--- a/openbabel-src/openbabel/src/formats/chemdrawcdx.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/chemdrawcdx.cpp	(date 1689048275870)
@@ -810,7 +810,7 @@
 ///////////////////////////////////////////////////////////////////////
 bool CDXReader::ParseEnums(map<CDXTag, string>& enummap, const string& filename)
 {
-  ifstream ihs;
+  istringstream ihs;
   if(OpenDatafile(ihs, filename).empty())
   {
     obErrorLog.ThrowError(__FUNCTION__, 
Index: openbabel-src/openbabel/include/RDKitConv.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/RDKitConv.h b/openbabel-src/openbabel/include/RDKitConv.h
--- a/openbabel-src/openbabel/include/RDKitConv.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/RDKitConv.h	(date 1689048275858)
@@ -1,7 +1,7 @@
 #include <openbabel/mol.h>
 #include <openbabel/obiter.h>
-#include <graphmol/RWMol.h>
-#include <graphmol/Atom.h>
+#include <GraphMol/RWMol.h>
+#include <GraphMol/Atom.h>
 
 ///Convert OpenBabel OBMol to and from RGKit molecules
 RDKit::RWMol OBMolToRWMol(OpenBabel::OBMol* pOBMol);
Index: opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_winograd_f63.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_winograd_f63.cpp b/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_winograd_f63.cpp
--- a/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_winograd_f63.cpp	(revision f9a59f2592993d3dcc080e495f4f5e02dd8ec7ef)
+++ b/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_winograd_f63.cpp	(date 1689048275942)
@@ -17,6 +17,479 @@
 
 namespace cv { namespace dnn {
 
+// NEON code work around.
+namespace opt_NEON
+{
+
+#if CV_NEON && CV_NEON_AARCH64
+/* Accumulate */
+void winofunc_accum_f32(const float* inwptr, const float* wptr, float* outbuf, int Cg, int iblock,
+                        const int winoIblock, const int winoKblock, const int winoAtomF32, const int winoNatomF32);
+
+/*Input transform*/
+void winofunc_BtXB_8x8_f32(const float* inptr, int inpstep,
+                            float* outptr, int Cg, const int winoIblock, const int winoAtomF32);
+
+/*Output transform*/
+void winofunc_AtXA_8x8_f32(const float* inptr, int inpstep,
+                            float* bpptr, int bpstep, float* outptr, int outstep,
+                            float bias, float minval, float maxval, bool ifMinMaxAct);
+
+void winofunc_accum_f32(const float* inwptr, const float* wptr, float* outbuf, int Cg, int iblock,
+                            const int winoIblock, const int winoKblock, const int winoAtomF32, const int winoNatomF32)
+{
+    CV_Assert(winoIblock == 6 && winoKblock == 4 && winoAtomF32 == 4);
+    if (iblock > 3)
+    {
+        for (int atom_id = 0; atom_id < winoNatomF32; atom_id++,
+                outbuf += winoAtomF32)
+        {
+            float32x4_t s00 = vdupq_n_f32(0.f), s01 = s00, s02 = s00, s03 = s00, s04 = s00, s05 = s00;
+            float32x4_t s10 = vdupq_n_f32(0.f), s11 = s00, s12 = s00, s13 = s00, s14 = s00, s15 = s00;
+            float32x4_t s20 = vdupq_n_f32(0.f), s21 = s00, s22 = s00, s23 = s00, s24 = s00, s25 = s00;
+            float32x4_t s30 = vdupq_n_f32(0.f), s31 = s00, s32 = s00, s33 = s00, s34 = s00, s35 = s00;
+            for (int c = 0; c < Cg; c++, inwptr += winoIblock*winoAtomF32,
+                                         wptr += winoKblock*winoAtomF32) {
+                float32x4_t w0 = vld1q_f32(wptr), w1 = vld1q_f32(wptr + 4);
+                float32x4_t w2 = vld1q_f32(wptr + 8), w3 = vld1q_f32(wptr + 12);
+                float32x4_t x0, x1;
+                x0 = vld1q_f32(inwptr);
+                x1 = vld1q_f32(inwptr + 4);
+                s00 = vfmaq_f32(s00, w0, x0);
+                s01 = vfmaq_f32(s01, w0, x1);
+                s10 = vfmaq_f32(s10, w1, x0);
+                s11 = vfmaq_f32(s11, w1, x1);
+                s20 = vfmaq_f32(s20, w2, x0);
+                s21 = vfmaq_f32(s21, w2, x1);
+                s30 = vfmaq_f32(s30, w3, x0);
+                s31 = vfmaq_f32(s31, w3, x1);
+                x0 = vld1q_f32(inwptr + 8);
+                x1 = vld1q_f32(inwptr + 12);
+                s02 = vfmaq_f32(s02, w0, x0);
+                s03 = vfmaq_f32(s03, w0, x1);
+                s12 = vfmaq_f32(s12, w1, x0);
+                s13 = vfmaq_f32(s13, w1, x1);
+                s22 = vfmaq_f32(s22, w2, x0);
+                s23 = vfmaq_f32(s23, w2, x1);
+                s32 = vfmaq_f32(s32, w3, x0);
+                s33 = vfmaq_f32(s33, w3, x1);
+                x0 = vld1q_f32(inwptr + 16);
+                x1 = vld1q_f32(inwptr + 20);
+                s04 = vfmaq_f32(s04, w0, x0);
+                s05 = vfmaq_f32(s05, w0, x1);
+                s14 = vfmaq_f32(s14, w1, x0);
+                s15 = vfmaq_f32(s15, w1, x1);
+                s24 = vfmaq_f32(s24, w2, x0);
+                s25 = vfmaq_f32(s25, w2, x1);
+                s34 = vfmaq_f32(s34, w3, x0);
+                s35 = vfmaq_f32(s35, w3, x1);
+            }
+
+            vst1q_f32(outbuf, s00);
+            vst1q_f32(outbuf + 1*64, s01);
+            vst1q_f32(outbuf + 2*64, s02);
+            vst1q_f32(outbuf + 3*64, s03);
+            vst1q_f32(outbuf + 4*64, s04);
+            vst1q_f32(outbuf + 5*64, s05);
+
+            vst1q_f32(outbuf + 6*64, s10);
+            vst1q_f32(outbuf + 7*64, s11);
+            vst1q_f32(outbuf + 8*64, s12);
+            vst1q_f32(outbuf + 9*64, s13);
+            vst1q_f32(outbuf + 10*64, s14);
+            vst1q_f32(outbuf + 11*64, s15);
+
+            vst1q_f32(outbuf + 12*64, s20);
+            vst1q_f32(outbuf + 13*64, s21);
+            vst1q_f32(outbuf + 14*64, s22);
+            vst1q_f32(outbuf + 15*64, s23);
+            vst1q_f32(outbuf + 16*64, s24);
+            vst1q_f32(outbuf + 17*64, s25);
+
+            vst1q_f32(outbuf + 18*64, s30);
+            vst1q_f32(outbuf + 19*64, s31);
+            vst1q_f32(outbuf + 20*64, s32);
+            vst1q_f32(outbuf + 21*64, s33);
+            vst1q_f32(outbuf + 22*64, s34);
+            vst1q_f32(outbuf + 23*64, s35);
+        }
+    }
+    else
+    {
+        for (int atom_id = 0; atom_id < winoNatomF32; atom_id++,
+                outbuf += winoAtomF32)
+        {
+            float32x4_t s00 = vdupq_n_f32(0.f), s01 = s00, s02 = s00;
+            float32x4_t s10 = vdupq_n_f32(0.f), s11 = s00, s12 = s00;
+            float32x4_t s20 = vdupq_n_f32(0.f), s21 = s00, s22 = s00;
+            float32x4_t s30 = vdupq_n_f32(0.f), s31 = s00, s32 = s00;
+            for (int c = 0; c < Cg; c++, inwptr += winoIblock*winoAtomF32,
+                                         wptr += winoKblock*winoAtomF32) {
+                float32x4_t w0 = vld1q_f32(wptr), w1 = vld1q_f32(wptr + 4);
+                float32x4_t w2 = vld1q_f32(wptr + 8), w3 = vld1q_f32(wptr + 12);
+                float32x4_t x0, x1, x2;
+                x0 = vld1q_f32(inwptr);
+                x1 = vld1q_f32(inwptr + 4);
+                x2 = vld1q_f32(inwptr + 8);
+                s00 = vfmaq_f32(s00, w0, x0);
+                s01 = vfmaq_f32(s01, w0, x1);
+                s02 = vfmaq_f32(s02, w0, x2);
+                s10 = vfmaq_f32(s10, w1, x0);
+                s11 = vfmaq_f32(s11, w1, x1);
+                s12 = vfmaq_f32(s12, w1, x2);
+                s20 = vfmaq_f32(s20, w2, x0);
+                s21 = vfmaq_f32(s21, w2, x1);
+                s22 = vfmaq_f32(s22, w2, x2);
+                s30 = vfmaq_f32(s30, w3, x0);
+                s31 = vfmaq_f32(s31, w3, x1);
+                s32 = vfmaq_f32(s32, w3, x2);
+            }
+
+            vst1q_f32(outbuf, s00);
+            vst1q_f32(outbuf + 1*64, s01);
+            vst1q_f32(outbuf + 2*64, s02);
+            vst1q_f32(outbuf + 6*64, s10);
+            vst1q_f32(outbuf + 7*64, s11);
+            vst1q_f32(outbuf + 8*64, s12);
+            vst1q_f32(outbuf + 12*64, s20);
+            vst1q_f32(outbuf + 13*64, s21);
+            vst1q_f32(outbuf + 14*64, s22);
+            vst1q_f32(outbuf + 18*64, s30);
+            vst1q_f32(outbuf + 19*64, s31);
+            vst1q_f32(outbuf + 20*64, s32);
+        }
+    }
+}
+
+#define T4x4(a, b, c, d, tr0, tr1) \
+    tr0 = vtrnq_f32(a, b); \
+    tr1 = vtrnq_f32(c, d); \
+    a = vcombine_f32(vget_low_f32(tr0.val[0]), vget_low_f32(tr1.val[0])); \
+    b = vcombine_f32(vget_low_f32(tr0.val[1]), vget_low_f32(tr1.val[1])); \
+    c = vcombine_f32(vget_high_f32(tr0.val[0]), vget_high_f32(tr1.val[0])); \
+    d = vcombine_f32(vget_high_f32(tr0.val[1]), vget_high_f32(tr1.val[1]))
+
+/*Input transform*/
+void winofunc_BtXB_8x8_f32(const float* inptr, int inpstep,
+                          float* outptr, int Cg, const int winoIblock, const int winoAtomF32)
+{
+    float32x4_t x00 = vld1q_f32(inptr), x01 = vld1q_f32(inptr + 4);
+    float32x4_t x10 = vld1q_f32(inptr + inpstep), x11 = vld1q_f32(inptr + inpstep + 4);
+    float32x4_t x20 = vld1q_f32(inptr + inpstep*2), x21 = vld1q_f32(inptr + inpstep*2 + 4);
+    float32x4_t x30 = vld1q_f32(inptr + inpstep*3), x31 = vld1q_f32(inptr + inpstep*3 + 4);
+    float32x4_t x40 = vld1q_f32(inptr + inpstep*4), x41 = vld1q_f32(inptr + inpstep*4 + 4);
+    float32x4_t x50 = vld1q_f32(inptr + inpstep*5), x51 = vld1q_f32(inptr + inpstep*5 + 4);
+    float32x4_t x60 = vld1q_f32(inptr + inpstep*6), x61 = vld1q_f32(inptr + inpstep*6 + 4);
+    float32x4_t x70 = vld1q_f32(inptr + inpstep*7), x71 = vld1q_f32(inptr + inpstep*7 + 4);
+
+    float32x4_t z00, z01, z10, z11, z20, z21, z30, z31, z40, z41, z50, z51, z60, z61, z70, z71;
+
+    {
+        /* Y[0] = [1.f, 0.f, -5.25f, 0.f, 5.25f, 0.f, -1.f, 0.f]*X */
+        /* Y[7] = [0.f, -1.f, 0.f, 5.25f, 0.f, -5.25f, 0.f, 1.f]*X */
+        float32x4_t q5_25 = vdupq_n_f32(5.25f), t00, t01, t10, t11;
+        t00 = vsubq_f32(x40, x20);
+        t01 = vsubq_f32(x41, x21);
+        t10 = vsubq_f32(x30, x50);
+        t11 = vsubq_f32(x31, x51);
+        float32x4_t y00 = vfmaq_f32(vsubq_f32(x00, x60), t00, q5_25);
+        float32x4_t y01 = vfmaq_f32(vsubq_f32(x01, x61), t01, q5_25);
+        float32x4_t y70 = vfmaq_f32(vsubq_f32(x70, x10), t10, q5_25);
+        float32x4_t y71 = vfmaq_f32(vsubq_f32(x71, x11), t11, q5_25);
+
+        /* Y[1] = [0.f, 1.f, 1.f, -4.25f, -4.25f, 1.f, 1.f, 0.f]*X */
+        /* Y[2] = [0.f, -1.f, 1.f, 4.25f, -4.25f, -1.f, 1.f, 0.f]*X */
+        float32x4_t qm4_25 = vdupq_n_f32(-4.25f);
+        t00 = vfmaq_f32(vaddq_f32(x10, x50), x30, qm4_25);
+        t01 = vfmaq_f32(vaddq_f32(x11, x51), x31, qm4_25);
+        t10 = vfmaq_f32(vaddq_f32(x20, x60), x40, qm4_25);
+        t11 = vfmaq_f32(vaddq_f32(x21, x61), x41, qm4_25);
+
+        float32x4_t y10 = vaddq_f32(t00, t10), y11 = vaddq_f32(t01, t11);
+        float32x4_t y20 = vsubq_f32(t10, t00), y21 = vsubq_f32(t11, t01);
+
+        /* Y[3] = [0.f, 0.5f, 0.25f, -2.5f, -1.25f, 2.f, 1.f, 0.f]*X */
+        /* Y[4] = [0.f, -0.5f, 0.25f, 2.5f, -1.25f, -2.f, 1.f, 0.f]*X */
+        float32x4_t q0_5 = vdupq_n_f32(0.5f), q0_25 = vdupq_n_f32(0.25f);
+        float32x4_t qm2_5 = vdupq_n_f32(-2.5f), qm1_25 = vdupq_n_f32(-1.25f);
+        t00 = vfmaq_f32(vaddq_f32(x50, x50), x10, q0_5);
+        t01 = vfmaq_f32(vaddq_f32(x51, x51), x11, q0_5);
+        t10 = vfmaq_f32(x60, x20, q0_25);
+        t11 = vfmaq_f32(x61, x21, q0_25);
+        t00 = vfmaq_f32(t00, x30, qm2_5);
+        t01 = vfmaq_f32(t01, x31, qm2_5);
+        t10 = vfmaq_f32(t10, x40, qm1_25);
+        t11 = vfmaq_f32(t11, x41, qm1_25);
+
+        float32x4_t y30 = vaddq_f32(t00, t10), y31 = vaddq_f32(t01, t11);
+        float32x4_t y40 = vsubq_f32(t10, t00), y41 = vsubq_f32(t11, t01);
+
+        /* Y[5] = [0.f, 2.f, 4.f, -2.5f, -5.f, 0.5f, 1.f, 0.f]*X */
+        /* Y[6] = [0.f, -2.f, 4.f, 2.5f, -5.f, -0.5f, 1.f, 0.f]*X */
+        float32x4_t q4 = vdupq_n_f32(4.f), qm5 = vdupq_n_f32(-5.f);
+        t00 = vfmaq_f32(vaddq_f32(x10, x10), x50, q0_5);
+        t01 = vfmaq_f32(vaddq_f32(x11, x11), x51, q0_5);
+        t10 = vfmaq_f32(x60, x20, q4);
+        t11 = vfmaq_f32(x61, x21, q4);
+        t00 = vfmaq_f32(t00, x30, qm2_5);
+        t01 = vfmaq_f32(t01, x31, qm2_5);
+        t10 = vfmaq_f32(t10, x40, qm5);
+        t11 = vfmaq_f32(t11, x41, qm5);
+
+        float32x4_t y50 = vaddq_f32(t00, t10), y51 = vaddq_f32(t01, t11);
+        float32x4_t y60 = vsubq_f32(t10, t00), y61 = vsubq_f32(t11, t01);
+
+        /* transpose 8x8 matrix in-place with some renumeration of the elements: */
+        /* Y:              */
+        /*        y00 y01  */
+        /*        y10 y11  */
+        /*        ...      */
+        /*        y70 y71  */
+        /*   Y':           */
+        /*        y00 y40  */
+        /*        y10 y50  */
+        /*        y20 y60  */
+        /*        y30 y70  */
+        /*        y01 y41  */
+        /*        y11 y51  */
+        /*        y21 y61  */
+        /*        y31 y71  */
+        /*    in other words, y40 <-> y01, y50 <-> y11, y60 <-> y21, y70 <-> y31 */
+        float32x4x2_t tr0, tr1;
+
+        T4x4(y00, y10, y20, y30, tr0, tr1);
+        T4x4(y01, y11, y21, y31, tr0, tr1);
+        T4x4(y40, y50, y60, y70, tr0, tr1);
+        T4x4(y41, y51, y61, y71, tr0, tr1);
+
+        /* Z[0] = [1.f, 0.f, -5.25f, 0.f, 5.25f, 0.f, -1.f, 0.f]*Y */
+        /* Z[7] = [0.f, -1.f, 0.f, 5.25f, 0.f, -5.25f, 0.f, 1.f]*Y */
+        t00 = vsubq_f32(y01, y20);
+        t01 = vsubq_f32(y41, y60);
+        t10 = vsubq_f32(y30, y11);
+        t11 = vsubq_f32(y70, y51);
+        z00 = vfmaq_f32(vsubq_f32(y00, y21), t00, q5_25);
+        z01 = vfmaq_f32(vsubq_f32(y40, y61), t01, q5_25);
+        z70 = vfmaq_f32(vsubq_f32(y31, y10), t10, q5_25);
+        z71 = vfmaq_f32(vsubq_f32(y71, y50), t11, q5_25);
+
+        /* Z[1] = [0.f, 1.f, 1.f, -4.25f, -4.25f, 1.f, 1.f, 0.f]*Y */
+        /* Z[2] = [0.f, -1.f, 1.f, 4.25f, -4.25f, -1.f, 1.f, 0.f]*Y */
+        t00 = vfmaq_f32(vaddq_f32(y10, y11), y30, qm4_25);
+        t01 = vfmaq_f32(vaddq_f32(y50, y51), y70, qm4_25);
+        t10 = vfmaq_f32(vaddq_f32(y20, y21), y01, qm4_25);
+        t11 = vfmaq_f32(vaddq_f32(y60, y61), y41, qm4_25);
+
+        z10 = vaddq_f32(t00, t10); z11 = vaddq_f32(t01, t11);
+        z20 = vsubq_f32(t10, t00); z21 = vsubq_f32(t11, t01);
+
+        /* Z[3] = [0.f, 0.5f, 0.25f, -2.5f, -1.25f, 2.f, 1.f, 0.f]*Y */
+        /* Z[4] = [0.f, -0.5f, 0.25f, 2.5f, -1.25f, -2.f, 1.f, 0.f]*Y */
+        t00 = vfmaq_f32(vaddq_f32(y11, y11), y10, q0_5);
+        t01 = vfmaq_f32(vaddq_f32(y51, y51), y50, q0_5);
+        t10 = vfmaq_f32(y21, y20, q0_25);
+        t11 = vfmaq_f32(y61, y60, q0_25);
+        t00 = vfmaq_f32(t00, y30, qm2_5);
+        t01 = vfmaq_f32(t01, y70, qm2_5);
+        t10 = vfmaq_f32(t10, y01, qm1_25);
+        t11 = vfmaq_f32(t11, y41, qm1_25);
+
+        z30 = vaddq_f32(t00, t10); z31 = vaddq_f32(t01, t11);
+        z40 = vsubq_f32(t10, t00); z41 = vsubq_f32(t11, t01);
+
+        /* Z[5] = [0.f, 2.f, 4.f, -2.5f, -5.f, 0.5f, 1.f, 0.f]*Y */
+        /* Z[6] = [0.f, -2.f, 4.f, 2.5f, -5.f, -0.5f, 1.f, 0.f]*Y */
+        t00 = vfmaq_f32(vaddq_f32(y10, y10), y11, q0_5);
+        t01 = vfmaq_f32(vaddq_f32(y50, y50), y51, q0_5);
+        t10 = vfmaq_f32(y21, y20, q4);
+        t11 = vfmaq_f32(y61, y60, q4);
+        t00 = vfmaq_f32(t00, y30, qm2_5);
+        t01 = vfmaq_f32(t01, y70, qm2_5);
+        t10 = vfmaq_f32(t10, y01, qm5);
+        t11 = vfmaq_f32(t11, y41, qm5);
+
+        z50 = vaddq_f32(t00, t10); z51 = vaddq_f32(t01, t11);
+        z60 = vsubq_f32(t10, t00); z61 = vsubq_f32(t11, t01);
+    }
+
+    const int outstep = winoIblock*winoAtomF32*Cg;
+
+    vst1q_f32(outptr, z00);
+    vst1q_f32(outptr + outstep, z01);
+    vst1q_f32(outptr + outstep*2, z10);
+    vst1q_f32(outptr + outstep*3, z11);
+    vst1q_f32(outptr + outstep*4, z20);
+    vst1q_f32(outptr + outstep*5, z21);
+    vst1q_f32(outptr + outstep*6, z30);
+    vst1q_f32(outptr + outstep*7, z31);
+    vst1q_f32(outptr + outstep*8, z40);
+    vst1q_f32(outptr + outstep*9, z41);
+    vst1q_f32(outptr + outstep*10, z50);
+    vst1q_f32(outptr + outstep*11, z51);
+    vst1q_f32(outptr + outstep*12, z60);
+    vst1q_f32(outptr + outstep*13, z61);
+    vst1q_f32(outptr + outstep*14, z70);
+    vst1q_f32(outptr + outstep*15, z71);
+}
+
+/*Output transform*/
+void winofunc_AtXA_8x8_f32(const float* inptr, int inpstep,
+                          float* bpptr, int bpstep, float* outptr, int outstep,
+                          float bias, float minval, float maxval, bool ifMinMaxAct)
+{
+    float32x4_t x00 = vld1q_f32(inptr), x01 = vld1q_f32(inptr + 4);
+    float32x4_t x10 = vld1q_f32(inptr + inpstep), x11 = vld1q_f32(inptr + inpstep + 4);
+    float32x4_t x20 = vld1q_f32(inptr + inpstep*2), x21 = vld1q_f32(inptr + inpstep*2 + 4);
+    float32x4_t x30 = vld1q_f32(inptr + inpstep*3), x31 = vld1q_f32(inptr + inpstep*3 + 4);
+    float32x4_t x40 = vld1q_f32(inptr + inpstep*4), x41 = vld1q_f32(inptr + inpstep*4 + 4);
+    float32x4_t x50 = vld1q_f32(inptr + inpstep*5), x51 = vld1q_f32(inptr + inpstep*5 + 4);
+    float32x4_t x60 = vld1q_f32(inptr + inpstep*6), x61 = vld1q_f32(inptr + inpstep*6 + 4);
+    float32x4_t x70 = vld1q_f32(inptr + inpstep*7), x71 = vld1q_f32(inptr + inpstep*7 + 4);
+    float32x4_t z00, z01, z10, z11, z20, z21, z30, z31, z40, z41, z50, z51;
+
+    {
+        float32x4_t s12_0, s12_1, s34_0, s34_1, s56_0, s56_1;
+        s12_0 = vaddq_f32(x10, x20); s12_1 = vaddq_f32(x11, x21);
+        s34_0 = vaddq_f32(x30, x40); s34_1 = vaddq_f32(x31, x41);
+        s56_0 = vaddq_f32(x50, x60); s56_1 = vaddq_f32(x51, x61);
+
+        float32x4_t y00 = vaddq_f32(vaddq_f32(vaddq_f32(x00, s12_0), s34_0), s56_0);
+        float32x4_t y01 = vaddq_f32(vaddq_f32(vaddq_f32(x01, s12_1), s34_1), s56_1);
+        float32x4_t y20 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 4.0f), s56_0, 0.25f);
+        float32x4_t y21 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 4.0f), s56_1, 0.25f);
+        float32x4_t y40 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 16.0f), s56_0, 1.f/16);
+        float32x4_t y41 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 16.0f), s56_1, 1.f/16);
+
+        s12_0 = vsubq_f32(x10, x20); s12_1 = vsubq_f32(x11, x21);
+        s34_0 = vsubq_f32(x30, x40); s34_1 = vsubq_f32(x31, x41);
+        s56_0 = vsubq_f32(x50, x60); s56_1 = vsubq_f32(x51, x61);
+
+        float32x4_t y50 = vfmaq_n_f32(vfmaq_n_f32(vaddq_f32(x70, s12_0),
+                                      s34_0, 32.f), s56_0, 1.f/32);
+        float32x4_t y51 = vfmaq_n_f32(vfmaq_n_f32(vaddq_f32(x71, s12_1),
+                                      s34_1, 32.f), s56_1, 1.f/32);
+        float32x4_t y10 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 2.0f), s56_0, 0.5f);
+        float32x4_t y11 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 2.0f), s56_1, 0.5f);
+        float32x4_t y30 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 8.0f), s56_0, 0.125f);
+        float32x4_t y31 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 8.0f), s56_1, 0.125f);
+        float32x4_t y60 = vdupq_n_f32(0.f), y61 = y60, y70 = y60, y71 = y60;
+
+        /* transpose 8x8 matrix in-place with some renumeration of the elements: */
+        /*  Y: */
+        /*        y00 y01 */
+        /*        y10 y11 */
+        /*        ... */
+        /*        y50 y51 */
+        /*        0   0 */
+        /*        0   0 */
+        /*   Y': */
+        /*        y00 y40 */
+        /*        y10 y50 */
+        /*        y20 y60 */
+        /*        y30 y70 */
+        /*        y01 y41 */
+        /*        y11 y51 */
+        /*        y21 y61 */
+        /*        y31 y71 */
+        /*    in other words, y40 <-> y01, y50 <-> y11, y60 <-> y21, y70 <-> y31 */
+        float32x4x2_t tr0, tr1;
+
+        T4x4(y00, y10, y20, y30, tr0, tr1);
+        T4x4(y01, y11, y21, y31, tr0, tr1);
+        T4x4(y40, y50, y60, y70, tr0, tr1);
+        T4x4(y41, y51, y61, y71, tr0, tr1);
+
+        s12_0 = vaddq_f32(y10, y20); s12_1 = vaddq_f32(y50, y60);
+        s34_0 = vaddq_f32(y30, y01); s34_1 = vaddq_f32(y70, y41);
+        s56_0 = vaddq_f32(y11, y21); s56_1 = vaddq_f32(y51, y61);
+
+        z00 = vaddq_f32(vaddq_f32(vaddq_f32(y00, s12_0), s34_0), s56_0);
+        z01 = vaddq_f32(vaddq_f32(vaddq_f32(y40, s12_1), s34_1), s56_1);
+        z20 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 4.0f), s56_0, 0.25f);
+        z21 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 4.0f), s56_1, 0.25f);
+        z40 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 16.0f), s56_0, 1.f/16);
+        z41 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 16.0f), s56_1, 1.f/16);
+
+        s12_0 = vsubq_f32(y10, y20); s12_1 = vsubq_f32(y50, y60);
+        s34_0 = vsubq_f32(y30, y01); s34_1 = vsubq_f32(y70, y41);
+        s56_0 = vsubq_f32(y11, y21); s56_1 = vsubq_f32(y51, y61);
+
+        z50 = vfmaq_n_f32(vfmaq_n_f32(vaddq_f32(y31, s12_0),
+                          s34_0, 32.f), s56_0, 1.f/32);
+        z51 = vfmaq_n_f32(vfmaq_n_f32(vaddq_f32(y71, s12_1),
+                          s34_1, 32.f), s56_1, 1.f/32);
+        z10 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 2.0f), s56_0, 0.5f);
+        z11 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 2.0f), s56_1, 0.5f);
+        z30 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 8.0f), s56_0, 0.125f);
+        z31 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 8.0f), s56_1, 0.125f);
+        float32x4_t vbias = vdupq_n_f32(bias);
+
+        z00 = vaddq_f32(z00, vbias);
+        z01 = vaddq_f32(z01, vbias);
+        z10 = vaddq_f32(z10, vbias);
+        z11 = vaddq_f32(z11, vbias);
+        z20 = vaddq_f32(z20, vbias);
+        z21 = vaddq_f32(z21, vbias);
+        z30 = vaddq_f32(z30, vbias);
+        z31 = vaddq_f32(z31, vbias);
+        z40 = vaddq_f32(z40, vbias);
+        z41 = vaddq_f32(z41, vbias);
+        z50 = vaddq_f32(z50, vbias);
+        z51 = vaddq_f32(z51, vbias);
+    }
+
+    if (bpptr)
+    {
+        float32x2_t zhalf = vdup_n_f32(0.f);
+        z00 = vaddq_f32(z00, vld1q_f32(bpptr));
+        z01 = vaddq_f32(z01, vcombine_f32(vld1_f32(bpptr + 4), zhalf));
+        z10 = vaddq_f32(z10, vld1q_f32(bpptr + bpstep));
+        z11 = vaddq_f32(z11, vcombine_f32(vld1_f32(bpptr + bpstep + 4), zhalf));
+        z20 = vaddq_f32(z20, vld1q_f32(bpptr + bpstep*2));
+        z21 = vaddq_f32(z21, vcombine_f32(vld1_f32(bpptr + bpstep*2 + 4), zhalf));
+        z30 = vaddq_f32(z30, vld1q_f32(bpptr + bpstep*3));
+        z31 = vaddq_f32(z31, vcombine_f32(vld1_f32(bpptr + bpstep*3 + 4), zhalf));
+        z40 = vaddq_f32(z40, vld1q_f32(bpptr + bpstep*4));
+        z41 = vaddq_f32(z41, vcombine_f32(vld1_f32(bpptr + bpstep*4 + 4), zhalf));
+        z50 = vaddq_f32(z50, vld1q_f32(bpptr + bpstep*5));
+        z51 = vaddq_f32(z51, vcombine_f32(vld1_f32(bpptr + bpstep*5 + 4), zhalf));
+    }
+
+    if (ifMinMaxAct)
+    {
+        float32x4_t vmax = vdupq_n_f32(maxval);
+        float32x4_t vmin = vdupq_n_f32(minval);
+
+        z00 = vminq_f32(vmaxq_f32(z00, vmin), vmax);
+        z01 = vminq_f32(vmaxq_f32(z01, vmin), vmax);
+        z10 = vminq_f32(vmaxq_f32(z10, vmin), vmax);
+        z11 = vminq_f32(vmaxq_f32(z11, vmin), vmax);
+        z20 = vminq_f32(vmaxq_f32(z20, vmin), vmax);
+        z21 = vminq_f32(vmaxq_f32(z21, vmin), vmax);
+        z30 = vminq_f32(vmaxq_f32(z30, vmin), vmax);
+        z31 = vminq_f32(vmaxq_f32(z31, vmin), vmax);
+        z40 = vminq_f32(vmaxq_f32(z40, vmin), vmax);
+        z41 = vminq_f32(vmaxq_f32(z41, vmin), vmax);
+        z50 = vminq_f32(vmaxq_f32(z50, vmin), vmax);
+        z51 = vminq_f32(vmaxq_f32(z51, vmin), vmax);
+    }
+
+    vst1q_f32(outptr, z00);
+    vst1_f32(outptr + 4, vget_low_f32(z01));
+    vst1q_f32(outptr + outstep, z10);
+    vst1_f32(outptr + outstep + 4, vget_low_f32(z11));
+    vst1q_f32(outptr + outstep*2, z20);
+    vst1_f32(outptr + outstep*2 + 4, vget_low_f32(z21));
+    vst1q_f32(outptr + outstep*3, z30);
+    vst1_f32(outptr + outstep*3 + 4, vget_low_f32(z31));
+    vst1q_f32(outptr + outstep*4, z40);
+    vst1_f32(outptr + outstep*4 + 4, vget_low_f32(z41));
+    vst1q_f32(outptr + outstep*5, z50);
+    vst1_f32(outptr + outstep*5 + 4, vget_low_f32(z51));
+}
+
+#endif
+}
 #if CV_NEON || CV_SIMD128 || CV_TRY_AVX2
 enum { VEC_ALIGN = 32, DFT_TYPE = CV_32F }; // Memory alignment.
 
Index: ncnn-src/ncnn/src/datareader.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/src/datareader.h b/ncnn-src/ncnn/src/datareader.h
--- a/ncnn-src/ncnn/src/datareader.h	(revision 903ec7c2c9417e1ee11cb667d2198cc3607458ed)
+++ b/ncnn-src/ncnn/src/datareader.h	(date 1689048275794)
@@ -44,10 +44,6 @@
     // read binary param and model data
     // return bytes read
     virtual size_t read(void* buf, size_t size) const;
-
-    // get model data reference
-    // return bytes referenced
-    virtual size_t reference(size_t size, const void** buf) const;
 };
 
 #if NCNN_STDIO
@@ -83,7 +79,6 @@
     virtual int scan(const char* format, void* p) const;
 #endif // NCNN_STRING
     virtual size_t read(void* buf, size_t size) const;
-    virtual size_t reference(size_t size, const void** buf) const;
 
 private:
     DataReaderFromMemory(const DataReaderFromMemory&);
Index: opencv-src/opencv/modules/highgui/src/window_QT.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/highgui/src/window_QT.h b/opencv-src/opencv/modules/highgui/src/window_QT.h
--- a/opencv-src/opencv/modules/highgui/src/window_QT.h	(revision f9a59f2592993d3dcc080e495f4f5e02dd8ec7ef)
+++ b/opencv-src/opencv/modules/highgui/src/window_QT.h	(date 1689048275970)
@@ -68,7 +68,7 @@
 #include <QBoxLayout>
 #include <QSettings>
 #include <qtimer.h>
-#include <QtConcurrentRun>
+#include <QtConcurrent/QtConcurrentRun>
 #include <QWaitCondition>
 #include <QKeyEvent>
 #include <QMetaObject>
@@ -96,17 +96,17 @@
 enum { CV_MODE_NORMAL = 0, CV_MODE_OPENGL = 1 };
 
 //we can change the keyboard shortcuts from here !
-enum {	shortcut_zoom_normal 	= Qt::CTRL + Qt::Key_Z,
-        shortcut_zoom_imgRegion = Qt::CTRL + Qt::Key_X,
-        shortcut_save_img		= Qt::CTRL + Qt::Key_S,
-        shortcut_copy_clipbrd   = Qt::CTRL + Qt::Key_C,
-        shortcut_properties_win	= Qt::CTRL + Qt::Key_P,
-        shortcut_zoom_in 		= Qt::CTRL + Qt::Key_Plus,//QKeySequence(QKeySequence::ZoomIn),
-        shortcut_zoom_out		= Qt::CTRL + Qt::Key_Minus,//QKeySequence(QKeySequence::ZoomOut),
-        shortcut_panning_left 	= Qt::CTRL + Qt::Key_Left,
-        shortcut_panning_right 	= Qt::CTRL + Qt::Key_Right,
-        shortcut_panning_up 	= Qt::CTRL + Qt::Key_Up,
-        shortcut_panning_down 	= Qt::CTRL + Qt::Key_Down
+enum {	shortcut_zoom_normal 	= (int)Qt::CTRL + Qt::Key_Z,
+        shortcut_zoom_imgRegion = (int)Qt::CTRL + Qt::Key_X,
+        shortcut_save_img		= (int)Qt::CTRL + Qt::Key_S,
+        shortcut_copy_clipbrd   = (int)Qt::CTRL + Qt::Key_C,
+        shortcut_properties_win	= (int)Qt::CTRL + Qt::Key_P,
+        shortcut_zoom_in 		= (int)Qt::CTRL + Qt::Key_Plus,//QKeySequence(QKeySequence::ZoomIn),
+        shortcut_zoom_out		= (int)Qt::CTRL + Qt::Key_Minus,//QKeySequence(QKeySequence::ZoomOut),
+        shortcut_panning_left 	= (int)Qt::CTRL + Qt::Key_Left,
+        shortcut_panning_right 	= (int)Qt::CTRL + Qt::Key_Right,
+        shortcut_panning_up 	= (int)Qt::CTRL + Qt::Key_Up,
+        shortcut_panning_down 	= (int)Qt::CTRL + Qt::Key_Down
     };
 //end enum
 
@@ -128,7 +128,7 @@
     bool bTimeOut;
     QTimer* timer;
 
-public slots:
+public Q_SLOTS:
     void createWindow( QString name, int flags = 0 );
     void destroyWindow(QString name);
     void destroyAllWindow();
@@ -204,7 +204,7 @@
     CvButtonCallback callback;
     void* userdata;
 
-private slots:
+private Q_SLOTS:
     void callCallBack(bool);
 };
 
@@ -221,7 +221,7 @@
     CvButtonCallback callback;
     void* userdata;
 
-private slots:
+private Q_SLOTS:
     void callCallBack(bool);
 };
 
@@ -238,7 +238,7 @@
     CvButtonCallback callback;
     void* userdata;
 
-private slots:
+private Q_SLOTS:
     void callCallBack(bool);
 };
 
@@ -252,7 +252,7 @@
 
     QPointer<QSlider> slider;
 
-private slots:
+private Q_SLOTS:
     void createDialog();
     void update(int myvalue);
 
@@ -377,7 +377,7 @@
     void showTools();
     QSize getAvailableSize();
 
-private slots:
+private Q_SLOTS:
     void displayPropertiesWin();
 };
 
@@ -518,7 +518,7 @@
 
     void setSize(QSize size_) CV_OVERRIDE;
 
-public slots:
+public Q_SLOTS:
     //reference:
     //http://www.qtcentre.org/wiki/index.php?title=QGraphicsView:_Smooth_Panning_and_Zooming
     //http://doc.qt.nokia.com/4.6/gestures-imagegestures-imagewidget-cpp.html
@@ -585,7 +585,7 @@
 
     void icvmouseProcessing(QPointF pt, int cv_event, int flags) CV_OVERRIDE;
 
-private slots:
+private Q_SLOTS:
     void stopDisplayInfo();
 };
 
Index: openbabel-src/openbabel/src/depict/depict.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/depict/depict.cpp b/openbabel-src/openbabel/src/depict/depict.cpp
--- a/openbabel-src/openbabel/src/depict/depict.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/depict/depict.cpp	(date 1689048275866)
@@ -1235,7 +1235,7 @@
                       end.x() - offset.x(), end.y() - offset.y());
 
     static const float dashpattern[] = {5., 5.};
-    static const vector<double> pat = vector<double>(dashpattern,dashpattern + sizeof(dashpattern)/sizeof(double));
+    static const vector<double> pat = vector<double>(dashpattern, dashpattern + sizeof(dashpattern)/sizeof(float));
     painter->DrawLine(begin.x() + offset.x(), begin.y() + offset.y(),
                       end.x() + offset.x(), end.y() + offset.y(), pat);
   }
Index: cairo-src/cairo/src/cairoint.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cairo-src/cairo/src/cairoint.h b/cairo-src/cairo/src/cairoint.h
--- a/cairo-src/cairo/src/cairoint.h	(revision c3b672634f0635af1ad0ffa8c15b34fc7c1035cf)
+++ b/cairo-src/cairo/src/cairoint.h	(date 1690943671790)
@@ -48,8 +48,10 @@
 
 #include "config.h"
 
-#ifdef _MSC_VER
-#define cairo_public __declspec(dllexport)
+#include "cairo_export.h"
+
+#ifndef cairo_public
+#define cairo_public CAIRO_EXPORT
 #endif
 
 #include <assert.h>
Index: openbabel-src/openbabel/src/typer.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/typer.cpp b/openbabel-src/openbabel/src/typer.cpp
--- a/openbabel-src/openbabel/src/typer.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/typer.cpp	(date 1689048275890)
@@ -27,8 +27,6 @@
 #include <openbabel/typer.h>
 #include <openbabel/elements.h>
 
-// private data headers with default parameters
-#include "atomtyp.h"
 
 #ifdef WIN32
 #pragma warning (disable : 4786)
@@ -64,7 +62,7 @@
     _envvar = "BABEL_DATADIR";
     _filename = "atomtyp.txt";
     _subdir = "data";
-    _dataptr = AtomTypeData;
+    _dataptr = nullptr;
   }
 
   void OBAtomTyper::ParseLine(const char *buffer)
Index: ncnn-src/ncnn/src/gpu.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/src/gpu.h b/ncnn-src/ncnn/src/gpu.h
--- a/ncnn-src/ncnn/src/gpu.h	(revision 903ec7c2c9417e1ee11cb667d2198cc3607458ed)
+++ b/ncnn-src/ncnn/src/gpu.h	(date 1690442200984)
@@ -214,7 +214,7 @@
     GpuInfo& operator=(const GpuInfo&);
 
 private:
-    friend int create_gpu_instance();
+    friend NCNN_EXPORT int create_gpu_instance();
     GpuInfoPrivate* const d;
 };
 
Index: libpng-src/libpng/powerpc/powerpc_init.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/powerpc/powerpc_init.c b/libpng-src/libpng/powerpc/powerpc_init.c
new file mode 100644
--- /dev/null	(date 1690795574122)
+++ b/libpng-src/libpng/powerpc/powerpc_init.c	(date 1690795574122)
@@ -0,0 +1,126 @@
+
+/* powerpc_init.c - POWERPC optimised filter functions
+ *
+ * Copyright (c) 2018 Cosmin Truta
+ * Copyright (c) 2017 Glenn Randers-Pehrson
+ * Written by Vadim Barkov, 2017.
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ */
+
+/* Below, after checking __linux__, various non-C90 POSIX 1003.1 functions are
+ * called.
+ */
+#define _POSIX_SOURCE 1
+
+#include <stdio.h>
+#include "../pngpriv.h"
+
+#ifdef PNG_READ_SUPPORTED
+
+#if PNG_POWERPC_VSX_OPT > 0
+#ifdef PNG_POWERPC_VSX_CHECK_SUPPORTED /* Do run-time checks */
+/* WARNING: it is strongly recommended that you do not build libpng with
+ * run-time checks for CPU features if at all possible.  In the case of the PowerPC
+ * VSX instructions there is no processor-specific way of detecting the
+ * presence of the required support, therefore run-time detection is extremely
+ * OS specific.
+ *
+ * You may set the macro PNG_POWERPC_VSX_FILE to the file name of file containing
+ * a fragment of C source code which defines the png_have_vsx function.  There
+ * are a number of implementations in contrib/powerpc-vsx, but the only one that
+ * has partial support is contrib/powerpc-vsx/linux.c - a generic Linux
+ * implementation which reads /proc/cpufino.
+ */
+#ifndef PNG_POWERPC_VSX_FILE
+#  ifdef __linux__
+#     define  PNG_POWERPC_VSX_FILE "contrib/powerpc-vsx/linux_aux.c"
+#  endif
+#endif
+
+#ifdef PNG_POWERPC_VSX_FILE
+
+#include <signal.h> /* for sig_atomic_t */
+static int png_have_vsx(png_structp png_ptr);
+#include PNG_POWERPC_VSX_FILE
+
+#else  /* PNG_POWERPC_VSX_FILE */
+#  error "PNG_POWERPC_VSX_FILE undefined: no support for run-time POWERPC VSX checks"
+#endif /* PNG_POWERPC_VSX_FILE */
+#endif /* PNG_POWERPC_VSX_CHECK_SUPPORTED */
+
+void
+png_init_filter_functions_vsx(png_structp pp, unsigned int bpp)
+{
+   /* The switch statement is compiled in for POWERPC_VSX_API, the call to
+    * png_have_vsx is compiled in for POWERPC_VSX_CHECK. If both are defined
+    * the check is only performed if the API has not set the PowerPC option on
+    * or off explicitly. In this case the check controls what happens.
+    */
+
+#ifdef PNG_POWERPC_VSX_API_SUPPORTED
+   switch ((pp->options >> PNG_POWERPC_VSX) & 3)
+   {
+      case PNG_OPTION_UNSET:
+         /* Allow the run-time check to execute if it has been enabled -
+          * thus both API and CHECK can be turned on.  If it isn't supported
+          * this case will fall through to the 'default' below, which just
+          * returns.
+          */
+#endif /* PNG_POWERPC_VSX_API_SUPPORTED */
+#ifdef PNG_POWERPC_VSX_CHECK_SUPPORTED
+         {
+            static volatile sig_atomic_t no_vsx = -1; /* not checked */
+
+            if (no_vsx < 0)
+               no_vsx = !png_have_vsx(pp);
+
+            if (no_vsx)
+               return;
+         }
+#ifdef PNG_POWERPC_VSX_API_SUPPORTED
+         break;
+#endif
+#endif /* PNG_POWERPC_VSX_CHECK_SUPPORTED */
+
+#ifdef PNG_POWERPC_VSX_API_SUPPORTED
+      default: /* OFF or INVALID */
+         return;
+
+      case PNG_OPTION_ON:
+         /* Option turned on */
+         break;
+   }
+#endif
+
+   /* IMPORTANT: any new internal functions used here must be declared using
+    * PNG_INTERNAL_FUNCTION in ../pngpriv.h.  This is required so that the
+    * 'prefix' option to configure works:
+    *
+    *    ./configure --with-libpng-prefix=foobar_
+    *
+    * Verify you have got this right by running the above command, doing a build
+    * and examining pngprefix.h; it must contain a #define for every external
+    * function you add.  (Notice that this happens automatically for the
+    * initialization function.)
+    */
+   pp->read_filter[PNG_FILTER_VALUE_UP-1] = png_read_filter_row_up_vsx;
+
+   if (bpp == 3)
+   {
+      pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub3_vsx;
+      pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg3_vsx;
+      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] = png_read_filter_row_paeth3_vsx;
+   }
+
+   else if (bpp == 4)
+   {
+      pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub4_vsx;
+      pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg4_vsx;
+      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] = png_read_filter_row_paeth4_vsx;
+   }
+}
+#endif /* PNG_POWERPC_VSX_OPT > 0 */
+#endif /* READ */
Index: openbabel-src/openbabel/src/data.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/data.cpp b/openbabel-src/openbabel/src/data.cpp
--- a/openbabel-src/openbabel/src/data.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/data.cpp	(date 1689048275866)
@@ -31,9 +31,6 @@
 #include <openbabel/oberror.h>
 #include <openbabel/elements.h>
 
-// data headers with default parameters
-#include "types.h"
-#include "resdata.h"
 
 
 #if !HAVE_STRNCASECMP
@@ -250,7 +247,7 @@
     _envvar = "BABEL_DATADIR";
     _filename = "types.txt";
     _subdir = "data";
-    _dataptr = TypesData;
+    _dataptr = nullptr;
     _linecount = 0;
     _from = _to = -1;
   }
@@ -434,7 +431,7 @@
     _envvar = "BABEL_DATADIR";
     _filename = "resdata.txt";
     _subdir = "data";
-    _dataptr = ResidueData;
+    _dataptr = nullptr;
   }
 
   bool OBResidueData::AssignBonds(OBMol &mol)
@@ -669,7 +666,7 @@
       return;
     _init = true;
 
-    ifstream ifs;
+    istringstream ifs;
     char charBuffer[BUFF_SIZE];
 
     // Set the locale for number parsing to avoid locale issues: PR#1785463
@@ -716,8 +713,6 @@
     // return the locale to the original one
     obLocale.RestoreLocale();
 
-    if (ifs)
-      ifs.close();
 
     if (GetSize() == 0)
       {
Index: openbabel-src/openbabel/src/alias.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/alias.cpp b/openbabel-src/openbabel/src/alias.cpp
--- a/openbabel-src/openbabel/src/alias.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/alias.cpp	(date 1689048275862)
@@ -222,7 +222,7 @@
 bool AliasData::LoadFile(SuperAtomTable& table)
 {
   //In table: key=alias left-form; value=pair<alias right-form, SMILES>
-  ifstream ifs;
+  istringstream ifs;
   if (OpenDatafile(ifs, "superatom.txt").length() == 0)
   {
     obErrorLog.ThrowError(__FUNCTION__, "Cannot open superatom.txt", obError);
@@ -250,7 +250,7 @@
 bool AliasData::LoadFile(SmartsTable& smtable)
 {
   //Re-parse the datafile. Seems simpler than trying to extract from the map.
-  ifstream ifs;
+  istringstream ifs;
   if (OpenDatafile(ifs, "superatom.txt").length() == 0)
   {
     obErrorLog.ThrowError(__FUNCTION__, "Cannot open superatom.txt", obError);
Index: openbabel-src/openbabel/src/config.h.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/config.h.cmake b/openbabel-src/openbabel/src/config.h.cmake
--- a/openbabel-src/openbabel/src/config.h.cmake	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/config.h.cmake	(date 1689048275866)
@@ -16,23 +16,12 @@
 /* The file extension used for shared modules */
 #define MODULE_EXTENSION "@MODULE_EXTENSION@"
 
+#include <openbabel_export.hpp>
 // If we are using a recent GCC version with visibility support use it
-#ifdef HAVE_GCC_VISIBILITY
-  #define OB_EXPORT __attribute__ ((visibility("default")))
-  #define OB_IMPORT __attribute__ ((visibility("default")))
-  #define OB_HIDDEN __attribute__ ((visibility("hidden")))
-#elif defined(WIN32) && defined(USING_DYNAMIC_LIBS) && !defined(__MINGW32__)
- #define OB_EXPORT __declspec(dllexport)
- #define OB_IMPORT __declspec(dllimport)
- #define OB_HIDDEN
-#else
- #define OB_EXPORT
- #define OB_IMPORT
- #define OB_HIDDEN
+#ifndef OB_EXPORT
+#define OB_EXPORT OPENBABEL_EXPORT
 #endif
 
-/* Used to export symbols for DLL / shared library builds */
-#if defined(MAKE_OBDLL) // e.g. in src/main.cpp
  #ifndef OB_EXTERN
   #define OB_EXTERN   OB_EXPORT extern
  #endif
@@ -60,39 +49,6 @@
  #ifndef OBDEPICT
   #define OBDEPICT OB_EXPORT
  #endif
-
-#else   // defined(MAKE_OBDLL)
-
- #ifndef OB_EXTERN
-  #define OB_EXTERN   OB_IMPORT extern
- #endif
- #ifndef OBAPI
-  #define OBAPI    OB_IMPORT
- #endif
- #ifndef OBCOMMON
-  #define OBCOMMON OB_IMPORT
- #endif
- #ifndef OBCONV
-  #define OBCONV   OB_IMPORT
- #endif
- #ifndef OBERROR
-  #define OBERROR  OB_IMPORT
- #endif
- #ifndef OBFPRT
-  #define OBFPRT   OB_IMPORT
- #endif
- #ifndef OBFPTR
-  #define OBFPTR   OB_IMPORT
- #endif
- #ifndef OBMCDL
- #define OBMCDL    OB_IMPORT
-  #ifndef OBDEPICT
- #define OBDEPICT  OB_IMPORT
- #endif
-
- #endif
-
-#endif
 
 #ifdef _MSC_VER
  // Suppress warning on deprecated functions
@@ -149,6 +105,22 @@
 /* have struct clock_t */
 #cmakedefine HAVE_CLOCK_T 1
 
+#cmakedefine HAVE_REGEX_H 1
+
+#cmakedefine HAVE_SHARED_POINTER 1
+
+#cmakedefine HAVE_EIGEN 1
+
+#cmakedefine HAVE_EIGEN3 1
+
+#cmakedefine HAVE_STATIC_INCHI 1
+
+#cmakedefine HAVE_LIBZ 1
+
+#cmakedefine HAVE_STATIC_LIBXML 1
+
+#cmakedefine HAVE_RPC_XDR_H 1
+
 /* shared pointer implementation to be used */
 #cmakedefine OB_SHARED_PTR_IMPLEMENTATION @OB_SHARED_PTR_IMPLEMENTATION@
 
Index: inchi-src/inchi/INCHI_BASE/src/runichi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_BASE/src/runichi.c b/inchi-src/inchi/INCHI_BASE/src/runichi.c
--- a/inchi-src/inchi/INCHI_BASE/src/runichi.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_BASE/src/runichi.c	(date 1689048275430)
@@ -3083,7 +3083,9 @@
         (i.e., delete a whole connected component(s) comprising original atoms)
         */
         int natnums = 0;
-        atnums = (int *)inchi_calloc(max_atoms, sizeof(int));
+        if (max_atoms > 0) {
+            atnums = (int *) inchi_calloc(max_atoms, sizeof(int));
+        }
         if (!atnums)
         {
             return _IS_ERROR;
Index: openbabel-src/openbabel/src/bondtyper.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/bondtyper.cpp b/openbabel-src/openbabel/src/bondtyper.cpp
--- a/openbabel-src/openbabel/src/bondtyper.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/bondtyper.cpp	(date 1689048275862)
@@ -24,8 +24,6 @@
 #include <openbabel/bondtyper.h>
 #include <openbabel/elements.h>
 
-// data header with default parameters
-#include "bondtyp.h"
 
 using namespace std;
 
@@ -54,7 +52,7 @@
     _envvar = "BABEL_DATADIR";
     _filename = "bondtyp.txt";
     _subdir = "data";
-    _dataptr = BondTypeData;
+    _dataptr = nullptr;
   }
 
   void OBBondTyper::ParseLine(const char *buffer)
Index: libpng-src/libpng/powerpc/filter_vsx_intrinsics.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/powerpc/filter_vsx_intrinsics.c b/libpng-src/libpng/powerpc/filter_vsx_intrinsics.c
new file mode 100644
--- /dev/null	(date 1690795574122)
+++ b/libpng-src/libpng/powerpc/filter_vsx_intrinsics.c	(date 1690795574122)
@@ -0,0 +1,768 @@
+/* filter_vsx_intrinsics.c - PowerPC optimised filter functions
+ *
+ * Copyright (c) 2018 Cosmin Truta
+ * Copyright (c) 2017 Glenn Randers-Pehrson
+ * Written by Vadim Barkov, 2017.
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ */
+
+#include <stdio.h>
+#include <stdint.h>
+#include "../pngpriv.h"
+
+#ifdef PNG_READ_SUPPORTED
+
+/* This code requires -maltivec and -mvsx on the command line: */
+#if PNG_POWERPC_VSX_IMPLEMENTATION == 1 /* intrinsics code from pngpriv.h */
+
+#include <altivec.h>
+
+#if PNG_POWERPC_VSX_OPT > 0
+
+#ifndef __VSX__
+#  error "This code requires VSX support (POWER7 and later). Please provide -mvsx compiler flag."
+#endif
+
+#define vec_ld_unaligned(vec,data) vec = vec_vsx_ld(0,data)
+#define vec_st_unaligned(vec,data) vec_vsx_st(vec,0,data)
+
+
+/* Functions in this file look at most 3 pixels (a,b,c) to predict the 4th (d).
+ * They're positioned like this:
+ *    prev:  c b
+ *    row:   a d
+ * The Sub filter predicts d=a, Avg d=(a+b)/2, and Paeth predicts d to be
+ * whichever of a, b, or c is closest to p=a+b-c.
+ * ( this is taken from ../intel/filter_sse2_intrinsics.c )
+ */
+
+#define vsx_declare_common_vars(row_info,row,prev_row,offset) \
+   png_byte i;\
+   png_bytep rp = row + offset;\
+   png_const_bytep pp = prev_row;\
+   size_t unaligned_top = 16 - (((size_t)rp % 16));\
+   size_t istop;\
+   if(unaligned_top == 16)\
+      unaligned_top = 0;\
+   istop = row_info->rowbytes;\
+   if((unaligned_top < istop))\
+      istop -= unaligned_top;\
+   else{\
+      unaligned_top = istop;\
+      istop = 0;\
+   }
+
+void png_read_filter_row_up_vsx(png_row_infop row_info, png_bytep row,
+                                png_const_bytep prev_row)
+{
+   vector unsigned char rp_vec;
+   vector unsigned char pp_vec;
+   vsx_declare_common_vars(row_info,row,prev_row,0)
+
+   /* Altivec operations require 16-byte aligned data
+    * but input can be unaligned. So we calculate
+    * unaligned part as usual.
+    */
+   for (i = 0; i < unaligned_top; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
+      rp++;
+   }
+
+   /* Using SIMD while we can */
+   while( istop >= 16 )
+   {
+      rp_vec = vec_ld(0,rp);
+      vec_ld_unaligned(pp_vec,pp);
+
+      rp_vec = vec_add(rp_vec,pp_vec);
+
+      vec_st(rp_vec,0,rp);
+
+      pp += 16;
+      rp += 16;
+      istop -= 16;
+   }
+
+   if(istop > 0)
+   {
+      /* If byte count of row is not divisible by 16
+       * we will process remaining part as usual
+       */
+      for (i = 0; i < istop; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
+         rp++;
+      }
+}
+
+}
+
+static const vector unsigned char VSX_LEFTSHIFTED1_4 = {16,16,16,16, 0, 1, 2, 3,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_LEFTSHIFTED2_4 = {16,16,16,16,16,16,16,16, 4, 5, 6, 7,16,16,16,16};
+static const vector unsigned char VSX_LEFTSHIFTED3_4 = {16,16,16,16,16,16,16,16,16,16,16,16, 8, 9,10,11};
+
+static const vector unsigned char VSX_LEFTSHIFTED1_3 = {16,16,16, 0, 1, 2,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_LEFTSHIFTED2_3 = {16,16,16,16,16,16, 3, 4, 5,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_LEFTSHIFTED3_3 = {16,16,16,16,16,16,16,16,16, 6, 7, 8,16,16,16,16};
+static const vector unsigned char VSX_LEFTSHIFTED4_3 = {16,16,16,16,16,16,16,16,16,16,16,16, 9,10,11,16};
+
+static const vector unsigned char VSX_NOT_SHIFTED1_4 = {16,16,16,16, 4, 5, 6, 7,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_NOT_SHIFTED2_4 = {16,16,16,16,16,16,16,16, 8, 9,10,11,16,16,16,16};
+static const vector unsigned char VSX_NOT_SHIFTED3_4 = {16,16,16,16,16,16,16,16,16,16,16,16,12,13,14,15};
+
+static const vector unsigned char VSX_NOT_SHIFTED1_3 = {16,16,16, 3, 4, 5,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_NOT_SHIFTED2_3 = {16,16,16,16,16,16, 6, 7, 8,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_NOT_SHIFTED3_3 = {16,16,16,16,16,16,16,16,16, 9,10,11,16,16,16,16};
+static const vector unsigned char VSX_NOT_SHIFTED4_3 = {16,16,16,16,16,16,16,16,16,16,16,16,12,13,14,16};
+
+static const vector unsigned char VSX_CHAR_ZERO = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+#ifdef __LITTLE_ENDIAN__
+
+static const vector unsigned char VSX_CHAR_TO_SHORT1_4 = { 4,16, 5,16, 6,16, 7,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT2_4 = { 8,16, 9,16,10,16,11,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT3_4 = {12,16,13,16,14,16,15,16,16,16,16,16,16,16,16,16};
+
+static const vector unsigned char VSX_SHORT_TO_CHAR1_4 = {16,16,16,16, 0, 2, 4, 6,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR2_4 = {16,16,16,16,16,16,16,16, 0, 2, 4, 6,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR3_4 = {16,16,16,16,16,16,16,16,16,16,16,16, 0, 2, 4, 6};
+
+static const vector unsigned char VSX_CHAR_TO_SHORT1_3 = { 3,16, 4,16, 5,16,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT2_3 = { 6,16, 7,16, 8,16,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT3_3 = { 9,16,10,16,11,16,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT4_3 = {12,16,13,16,14,16,16,16,16,16,16,16,16,16,16,16};
+
+static const vector unsigned char VSX_SHORT_TO_CHAR1_3 = {16,16,16, 0, 2, 4,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR2_3 = {16,16,16,16,16,16, 0, 2, 4,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR3_3 = {16,16,16,16,16,16,16,16,16, 0, 2, 4,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR4_3 = {16,16,16,16,16,16,16,16,16,16,16,16, 0, 2, 4,16};
+
+#elif defined(__BIG_ENDIAN__)
+
+static const vector unsigned char VSX_CHAR_TO_SHORT1_4 = {16, 4,16, 5,16, 6,16, 7,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT2_4 = {16, 8,16, 9,16,10,16,11,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT3_4 = {16,12,16,13,16,14,16,15,16,16,16,16,16,16,16,16};
+
+static const vector unsigned char VSX_SHORT_TO_CHAR1_4 = {16,16,16,16, 1, 3, 5, 7,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR2_4 = {16,16,16,16,16,16,16,16, 1, 3, 5, 7,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR3_4 = {16,16,16,16,16,16,16,16,16,16,16,16, 1, 3, 5, 7};
+
+static const vector unsigned char VSX_CHAR_TO_SHORT1_3 = {16, 3,16, 4,16, 5,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT2_3 = {16, 6,16, 7,16, 8,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT3_3 = {16, 9,16,10,16,11,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT4_3 = {16,12,16,13,16,14,16,16,16,16,16,16,16,16,16,16};
+
+static const vector unsigned char VSX_SHORT_TO_CHAR1_3 = {16,16,16, 1, 3, 5,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR2_3 = {16,16,16,16,16,16, 1, 3, 5,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR3_3 = {16,16,16,16,16,16,16,16,16, 1, 3, 5,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR4_3 = {16,16,16,16,16,16,16,16,16,16,16,16, 1, 3, 5,16};
+
+#endif
+
+#define vsx_char_to_short(vec,offset,bpp) (vector unsigned short)vec_perm((vec),VSX_CHAR_ZERO,VSX_CHAR_TO_SHORT##offset##_##bpp)
+#define vsx_short_to_char(vec,offset,bpp) vec_perm(((vector unsigned char)(vec)),VSX_CHAR_ZERO,VSX_SHORT_TO_CHAR##offset##_##bpp)
+
+#ifdef PNG_USE_ABS
+#  define vsx_abs(number) abs(number)
+#else
+#  define vsx_abs(number) (number > 0) ? (number) : -(number)
+#endif
+
+void png_read_filter_row_sub4_vsx(png_row_infop row_info, png_bytep row,
+                                  png_const_bytep prev_row)
+{
+   png_byte bpp = 4;
+
+   vector unsigned char rp_vec;
+   vector unsigned char part_vec;
+
+   vsx_declare_common_vars(row_info,row,prev_row,bpp)
+
+   PNG_UNUSED(pp)
+
+   /* Altivec operations require 16-byte aligned data
+    * but input can be unaligned. So we calculate
+    * unaligned part as usual.
+    */
+   for (i = 0; i < unaligned_top; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
+      rp++;
+   }
+
+   /* Using SIMD while we can */
+   while( istop >= 16 )
+   {
+      for(i=0;i < bpp ; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
+         rp++;
+      }
+      rp -= bpp;
+
+      rp_vec = vec_ld(0,rp);
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED1_4);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED2_4);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED3_4);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      vec_st(rp_vec,0,rp);
+
+      rp += 16;
+      istop -= 16;
+   }
+
+   if(istop > 0)
+      for (i = 0; i < istop % 16; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) + (int)(*(rp - bpp))) & 0xff);
+         rp++;
+      }
+
+}
+
+void png_read_filter_row_sub3_vsx(png_row_infop row_info, png_bytep row,
+                                  png_const_bytep prev_row)
+{
+   png_byte bpp = 3;
+
+   vector unsigned char rp_vec;
+   vector unsigned char part_vec;
+
+   vsx_declare_common_vars(row_info,row,prev_row,bpp)
+
+   PNG_UNUSED(pp)
+
+   /* Altivec operations require 16-byte aligned data
+    * but input can be unaligned. So we calculate
+    * unaligned part as usual.
+    */
+   for (i = 0; i < unaligned_top; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
+      rp++;
+   }
+
+   /* Using SIMD while we can */
+   while( istop >= 16 )
+   {
+      for(i=0;i < bpp ; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
+         rp++;
+      }
+      rp -= bpp;
+
+      rp_vec = vec_ld(0,rp);
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED1_3);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED2_3);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED3_3);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED4_3);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      vec_st(rp_vec,0,rp);
+      rp += 15;
+      istop -= 16;
+
+      /* Since 16 % bpp = 16 % 3 = 1, last element of array must
+       * be proceeded manually
+       */
+      *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
+      rp++;
+   }
+
+   if(istop > 0)
+      for (i = 0; i < istop % 16; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
+         rp++;
+      }
+}
+
+void png_read_filter_row_avg4_vsx(png_row_infop row_info, png_bytep row,
+                                  png_const_bytep prev_row)
+{
+   png_byte bpp = 4;
+
+   vector unsigned char rp_vec;
+   vector unsigned char pp_vec;
+   vector unsigned char pp_part_vec;
+   vector unsigned char rp_part_vec;
+   vector unsigned char avg_vec;
+
+   vsx_declare_common_vars(row_info,row,prev_row,bpp)
+   rp -= bpp;
+   if(istop >= bpp)
+      istop -= bpp;
+
+   for (i = 0; i < bpp; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) +
+         ((int)(*pp++) / 2 )) & 0xff);
+
+      rp++;
+   }
+
+   /* Altivec operations require 16-byte aligned data
+    * but input can be unaligned. So we calculate
+    * unaligned part as usual.
+    */
+   for (i = 0; i < unaligned_top; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) +
+         (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+
+      rp++;
+   }
+
+   /* Using SIMD while we can */
+   while( istop >= 16 )
+   {
+      for(i=0;i < bpp ; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) +
+            (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+
+         rp++;
+      }
+      rp -= bpp;
+      pp -= bpp;
+
+      vec_ld_unaligned(pp_vec,pp);
+      rp_vec = vec_ld(0,rp);
+
+      rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED1_4);
+      pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED1_4);
+      avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+      avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+      rp_vec = vec_add(rp_vec,avg_vec);
+
+      rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED2_4);
+      pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED2_4);
+      avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+      avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+      rp_vec = vec_add(rp_vec,avg_vec);
+
+      rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED3_4);
+      pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED3_4);
+      avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+      avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+      rp_vec = vec_add(rp_vec,avg_vec);
+
+      vec_st(rp_vec,0,rp);
+
+      rp += 16;
+      pp += 16;
+      istop -= 16;
+   }
+
+   if(istop  > 0)
+      for (i = 0; i < istop % 16; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) +
+            (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+
+         rp++;
+      }
+}
+
+void png_read_filter_row_avg3_vsx(png_row_infop row_info, png_bytep row,
+                                  png_const_bytep prev_row)
+{
+  png_byte bpp = 3;
+
+  vector unsigned char rp_vec;
+  vector unsigned char pp_vec;
+  vector unsigned char pp_part_vec;
+  vector unsigned char rp_part_vec;
+  vector unsigned char avg_vec;
+
+  vsx_declare_common_vars(row_info,row,prev_row,bpp)
+  rp -= bpp;
+  if(istop >= bpp)
+     istop -= bpp;
+
+  for (i = 0; i < bpp; i++)
+  {
+     *rp = (png_byte)(((int)(*rp) +
+        ((int)(*pp++) / 2 )) & 0xff);
+
+     rp++;
+  }
+
+  /* Altivec operations require 16-byte aligned data
+   * but input can be unaligned. So we calculate
+   * unaligned part as usual.
+   */
+  for (i = 0; i < unaligned_top; i++)
+  {
+     *rp = (png_byte)(((int)(*rp) +
+        (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+
+     rp++;
+  }
+
+  /* Using SIMD while we can */
+  while( istop >= 16 )
+  {
+     for(i=0;i < bpp ; i++)
+     {
+        *rp = (png_byte)(((int)(*rp) +
+           (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+
+        rp++;
+     }
+     rp -= bpp;
+     pp -= bpp;
+
+     vec_ld_unaligned(pp_vec,pp);
+     rp_vec = vec_ld(0,rp);
+
+     rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED1_3);
+     pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED1_3);
+     avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+     avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+     rp_vec = vec_add(rp_vec,avg_vec);
+
+     rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED2_3);
+     pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED2_3);
+     avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+     avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+     rp_vec = vec_add(rp_vec,avg_vec);
+
+     rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED3_3);
+     pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED3_3);
+     avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+     avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+     rp_vec = vec_add(rp_vec,avg_vec);
+
+     rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED4_3);
+     pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED4_3);
+     avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+     avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+     rp_vec = vec_add(rp_vec,avg_vec);
+
+     vec_st(rp_vec,0,rp);
+
+     rp += 15;
+     pp += 15;
+     istop -= 16;
+
+     /* Since 16 % bpp = 16 % 3 = 1, last element of array must
+      * be proceeded manually
+      */
+     *rp = (png_byte)(((int)(*rp) +
+        (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+     rp++;
+  }
+
+  if(istop  > 0)
+     for (i = 0; i < istop % 16; i++)
+     {
+        *rp = (png_byte)(((int)(*rp) +
+           (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+
+        rp++;
+     }
+}
+
+/* Bytewise c ? t : e. */
+#define if_then_else(c,t,e) vec_sel(e,t,c)
+
+#define vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp) {\
+      c = *(pp - bpp);\
+      a = *(rp - bpp);\
+      b = *pp++;\
+      p = b - c;\
+      pc = a - c;\
+      pa = vsx_abs(p);\
+      pb = vsx_abs(pc);\
+      pc = vsx_abs(p + pc);\
+      if (pb < pa) pa = pb, a = b;\
+      if (pc < pa) a = c;\
+      a += *rp;\
+      *rp++ = (png_byte)a;\
+      }
+
+void png_read_filter_row_paeth4_vsx(png_row_infop row_info, png_bytep row,
+   png_const_bytep prev_row)
+{
+   png_byte bpp = 4;
+
+   int a, b, c, pa, pb, pc, p;
+   vector unsigned char rp_vec;
+   vector unsigned char pp_vec;
+   vector unsigned short a_vec,b_vec,c_vec,nearest_vec;
+   vector signed short pa_vec,pb_vec,pc_vec,smallest_vec;
+
+   vsx_declare_common_vars(row_info,row,prev_row,bpp)
+   rp -= bpp;
+   if(istop >= bpp)
+      istop -= bpp;
+
+   /* Process the first pixel in the row completely (this is the same as 'up'
+    * because there is only one candidate predictor for the first row).
+    */
+   for(i = 0; i < bpp ; i++)
+   {
+      *rp = (png_byte)( *rp + *pp);
+      rp++;
+      pp++;
+   }
+
+   for(i = 0; i < unaligned_top ; i++)
+   {
+      vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+   }
+
+   while( istop >= 16)
+   {
+      for(i = 0; i < bpp ; i++)
+      {
+         vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+      }
+
+      rp -= bpp;
+      pp -= bpp;
+      rp_vec = vec_ld(0,rp);
+      vec_ld_unaligned(pp_vec,pp);
+
+      a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED1_4),1,4);
+      b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED1_4),1,4);
+      c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED1_4),1,4);
+      pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+      pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+      pc_vec = vec_add(pa_vec,pb_vec);
+      pa_vec = vec_abs(pa_vec);
+      pb_vec = vec_abs(pb_vec);
+      pc_vec = vec_abs(pc_vec);
+      smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+      nearest_vec =  if_then_else(
+            vec_cmpeq(pa_vec,smallest_vec),
+            a_vec,
+            if_then_else(
+              vec_cmpeq(pb_vec,smallest_vec),
+              b_vec,
+              c_vec
+              )
+            );
+      rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,1,4)));
+
+      a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED2_4),2,4);
+      b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED2_4),2,4);
+      c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED2_4),2,4);
+      pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+      pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+      pc_vec = vec_add(pa_vec,pb_vec);
+      pa_vec = vec_abs(pa_vec);
+      pb_vec = vec_abs(pb_vec);
+      pc_vec = vec_abs(pc_vec);
+      smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+      nearest_vec =  if_then_else(
+            vec_cmpeq(pa_vec,smallest_vec),
+            a_vec,
+            if_then_else(
+              vec_cmpeq(pb_vec,smallest_vec),
+              b_vec,
+              c_vec
+              )
+            );
+      rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,2,4)));
+
+      a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED3_4),3,4);
+      b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED3_4),3,4);
+      c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED3_4),3,4);
+      pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+      pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+      pc_vec = vec_add(pa_vec,pb_vec);
+      pa_vec = vec_abs(pa_vec);
+      pb_vec = vec_abs(pb_vec);
+      pc_vec = vec_abs(pc_vec);
+      smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+      nearest_vec =  if_then_else(
+            vec_cmpeq(pa_vec,smallest_vec),
+            a_vec,
+            if_then_else(
+              vec_cmpeq(pb_vec,smallest_vec),
+              b_vec,
+              c_vec
+              )
+            );
+      rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,3,4)));
+
+      vec_st(rp_vec,0,rp);
+
+      rp += 16;
+      pp += 16;
+      istop -= 16;
+   }
+
+   if(istop > 0)
+      for (i = 0; i < istop % 16; i++)
+      {
+         vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+      }
+}
+
+void png_read_filter_row_paeth3_vsx(png_row_infop row_info, png_bytep row,
+   png_const_bytep prev_row)
+{
+  png_byte bpp = 3;
+
+  int a, b, c, pa, pb, pc, p;
+  vector unsigned char rp_vec;
+  vector unsigned char pp_vec;
+  vector unsigned short a_vec,b_vec,c_vec,nearest_vec;
+  vector signed short pa_vec,pb_vec,pc_vec,smallest_vec;
+
+  vsx_declare_common_vars(row_info,row,prev_row,bpp)
+  rp -= bpp;
+  if(istop >= bpp)
+     istop -= bpp;
+
+  /* Process the first pixel in the row completely (this is the same as 'up'
+   * because there is only one candidate predictor for the first row).
+   */
+  for(i = 0; i < bpp ; i++)
+  {
+     *rp = (png_byte)( *rp + *pp);
+     rp++;
+     pp++;
+  }
+
+  for(i = 0; i < unaligned_top ; i++)
+  {
+     vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+  }
+
+  while( istop >= 16)
+  {
+     for(i = 0; i < bpp ; i++)
+     {
+        vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+     }
+
+     rp -= bpp;
+     pp -= bpp;
+     rp_vec = vec_ld(0,rp);
+     vec_ld_unaligned(pp_vec,pp);
+
+     a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED1_3),1,3);
+     b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED1_3),1,3);
+     c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED1_3),1,3);
+     pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+     pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+     pc_vec = vec_add(pa_vec,pb_vec);
+     pa_vec = vec_abs(pa_vec);
+     pb_vec = vec_abs(pb_vec);
+     pc_vec = vec_abs(pc_vec);
+     smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+     nearest_vec =  if_then_else(
+           vec_cmpeq(pa_vec,smallest_vec),
+           a_vec,
+           if_then_else(
+             vec_cmpeq(pb_vec,smallest_vec),
+             b_vec,
+             c_vec
+             )
+           );
+     rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,1,3)));
+
+     a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED2_3),2,3);
+     b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED2_3),2,3);
+     c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED2_3),2,3);
+     pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+     pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+     pc_vec = vec_add(pa_vec,pb_vec);
+     pa_vec = vec_abs(pa_vec);
+     pb_vec = vec_abs(pb_vec);
+     pc_vec = vec_abs(pc_vec);
+     smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+     nearest_vec =  if_then_else(
+           vec_cmpeq(pa_vec,smallest_vec),
+           a_vec,
+           if_then_else(
+             vec_cmpeq(pb_vec,smallest_vec),
+             b_vec,
+             c_vec
+             )
+           );
+     rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,2,3)));
+
+     a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED3_3),3,3);
+     b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED3_3),3,3);
+     c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED3_3),3,3);
+     pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+     pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+     pc_vec = vec_add(pa_vec,pb_vec);
+     pa_vec = vec_abs(pa_vec);
+     pb_vec = vec_abs(pb_vec);
+     pc_vec = vec_abs(pc_vec);
+     smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+     nearest_vec =  if_then_else(
+           vec_cmpeq(pa_vec,smallest_vec),
+           a_vec,
+           if_then_else(
+             vec_cmpeq(pb_vec,smallest_vec),
+             b_vec,
+             c_vec
+             )
+           );
+     rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,3,3)));
+
+     a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED4_3),4,3);
+     b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED4_3),4,3);
+     c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED4_3),4,3);
+     pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+     pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+     pc_vec = vec_add(pa_vec,pb_vec);
+     pa_vec = vec_abs(pa_vec);
+     pb_vec = vec_abs(pb_vec);
+     pc_vec = vec_abs(pc_vec);
+     smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+     nearest_vec =  if_then_else(
+           vec_cmpeq(pa_vec,smallest_vec),
+           a_vec,
+           if_then_else(
+             vec_cmpeq(pb_vec,smallest_vec),
+             b_vec,
+             c_vec
+             )
+           );
+     rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,4,3)));
+
+     vec_st(rp_vec,0,rp);
+
+     rp += 15;
+     pp += 15;
+     istop -= 16;
+
+     /* Since 16 % bpp = 16 % 3 = 1, last element of array must
+      * be proceeded manually
+      */
+     vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+  }
+
+  if(istop > 0)
+     for (i = 0; i < istop % 16; i++)
+     {
+        vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+     }
+}
+
+#endif /* PNG_POWERPC_VSX_OPT > 0 */
+#endif /* PNG_POWERPC_VSX_IMPLEMENTATION == 1 (intrinsics) */
+#endif /* READ */
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_builder.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_builder.c b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_builder.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_builder.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_builder.c	(date 1689048275414)
@@ -32,9 +32,9 @@
  */
 
 
-#include "../../../../INCHI_BASE/src/mode.h"
-#include "../../../../INCHI_BASE/src/inchi_api.h"
-#include "../../../../INCHI_BASE/src/inpdef.h"
+#include "mode.h"
+#include "inchi_api.h"
+#include "inpdef.h"
 #include "ixa_status.h"
 #include "ixa_mol.h"
 #include <ctype.h>
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_mol.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_mol.c b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_mol.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_mol.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_mol.c	(date 1689048275414)
@@ -38,12 +38,12 @@
 #include <stdlib.h>
 #include <string.h>
 
-#include "../../../../INCHI_BASE/src/mode.h"
-#include "../../../../INCHI_BASE/src/inchi_api.h"
-#include "../../../../INCHI_BASE/src/ichicomp.h"
-#include "../../../../INCHI_BASE/src/util.h"
-#include "../../../../INCHI_BASE/src/mol_fmt.h"
-#include "../../../../INCHI_BASE/src/ichi_io.h"
+#include "mode.h"
+#include "inchi_api.h"
+#include "ichicomp.h"
+#include "util.h"
+#include "mol_fmt.h"
+#include "ichi_io.h"
 
 #include "ixa_status.h"
 #include "ixa_mol.h"
Index: rdkit-src/rdkit/Code/GraphMol/MolAlign/O3AAlignMolecules.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/MolAlign/O3AAlignMolecules.h b/rdkit-src/rdkit/Code/GraphMol/MolAlign/O3AAlignMolecules.h
--- a/rdkit-src/rdkit/Code/GraphMol/MolAlign/O3AAlignMolecules.h	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/GraphMol/MolAlign/O3AAlignMolecules.h	(date 1689048276122)
@@ -27,7 +27,7 @@
 
 namespace RDKit {
 namespace MolAlign {
-struct RDKIT_MOLALIGN_EXPORT O3AFuncData {
+struct RDKIT_O3AALIGN_EXPORT O3AFuncData {
   const Conformer *prbConf;
   const Conformer *refConf;
   void *prbProp;
@@ -46,7 +46,7 @@
 //! is defined by a pair of atom indexes (one for the probe,
 //! one for the reference) and a weight. Constraints can
 //! can be added via the O3AConstraintVect class.
-class RDKIT_MOLALIGN_EXPORT O3AConstraint {
+class RDKIT_O3AALIGN_EXPORT O3AConstraint {
   friend class O3AConstraintVect;
 
  public:
@@ -66,7 +66,7 @@
 //! method is invoked, the vector is sorted to make lookup faster.
 //! Hence, constraints are not necessarily stored in the same order
 //! they were appended.
-class RDKIT_MOLALIGN_EXPORT O3AConstraintVect {
+class RDKIT_O3AALIGN_EXPORT O3AConstraintVect {
  public:
   O3AConstraintVect() {}
   ~O3AConstraintVect() = default;
@@ -128,7 +128,7 @@
   O3_LOCAL_ONLY = (1 << 2)
 };
 
-class RDKIT_MOLALIGN_EXPORT MolHistogram {
+class RDKIT_O3AALIGN_EXPORT MolHistogram {
  public:
   MolHistogram(const ROMol &mol, const double *dmat, bool cleanupDmat = false);
   ~MolHistogram() = default;
@@ -142,7 +142,7 @@
   boost::multi_array<int, 2> d_h;
 };
 
-class RDKIT_MOLALIGN_EXPORT LAP {
+class RDKIT_O3AALIGN_EXPORT LAP {
  public:
   LAP(unsigned int dim)
       : d_rowSol(dim),
@@ -184,7 +184,7 @@
   boost::multi_array<int, 2> d_cost;
 };
 
-class RDKIT_MOLALIGN_EXPORT SDM {
+class RDKIT_O3AALIGN_EXPORT SDM {
  public:
   // constructor
   SDM(const Conformer *prbConf = nullptr, const Conformer *refConf = nullptr,
@@ -271,7 +271,7 @@
   }
 };
 
-class RDKIT_MOLALIGN_EXPORT O3A {
+class RDKIT_O3AALIGN_EXPORT O3A {
  public:
   //! pre-defined atom typing schemes
   typedef enum { MMFF94 = 0, CRIPPEN } AtomTypeScheme;
@@ -319,30 +319,30 @@
   double d_o3aScore;
 };
 
-RDKIT_MOLALIGN_EXPORT void randomTransform(ROMol &mol, const int cid = -1,
+RDKIT_O3AALIGN_EXPORT void randomTransform(ROMol &mol, const int cid = -1,
                                            const int seed = -1);
-RDKIT_MOLALIGN_EXPORT const RDGeom::POINT3D_VECT *reflect(
+RDKIT_O3AALIGN_EXPORT const RDGeom::POINT3D_VECT *reflect(
     const Conformer &conf);
-RDKIT_MOLALIGN_EXPORT int o3aMMFFCostFunc(const unsigned int prbIdx,
+RDKIT_O3AALIGN_EXPORT int o3aMMFFCostFunc(const unsigned int prbIdx,
                                           const unsigned int refIdx,
                                           double hSum, void *data);
-RDKIT_MOLALIGN_EXPORT double o3aMMFFWeightFunc(const unsigned int prbIdx,
+RDKIT_O3AALIGN_EXPORT double o3aMMFFWeightFunc(const unsigned int prbIdx,
                                                const unsigned int refIdx,
                                                void *data);
-RDKIT_MOLALIGN_EXPORT double o3aMMFFScoringFunc(const unsigned int prbIdx,
+RDKIT_O3AALIGN_EXPORT double o3aMMFFScoringFunc(const unsigned int prbIdx,
                                                 const unsigned int refIdx,
                                                 void *data);
-RDKIT_MOLALIGN_EXPORT int o3aCrippenCostFunc(const unsigned int prbIdx,
+RDKIT_O3AALIGN_EXPORT int o3aCrippenCostFunc(const unsigned int prbIdx,
                                              const unsigned int refIdx,
                                              double hSum, void *data);
-RDKIT_MOLALIGN_EXPORT double o3aCrippenWeightFunc(const unsigned int prbIdx,
+RDKIT_O3AALIGN_EXPORT double o3aCrippenWeightFunc(const unsigned int prbIdx,
                                                   const unsigned int refIdx,
                                                   void *data);
-RDKIT_MOLALIGN_EXPORT double o3aCrippenScoringFunc(const unsigned int prbIdx,
+RDKIT_O3AALIGN_EXPORT double o3aCrippenScoringFunc(const unsigned int prbIdx,
                                                    const unsigned int refIdx,
                                                    void *data);
 
-RDKIT_MOLALIGN_EXPORT void getO3AForProbeConfs(
+RDKIT_O3AALIGN_EXPORT void getO3AForProbeConfs(
     ROMol &prbMol, const ROMol &refMol, void *prbProp, void *refProp,
     std::vector<boost::shared_ptr<O3A>> &res, int numThreads = 1,
     O3A::AtomTypeScheme atomTypes = O3A::MMFF94, const int refCid = -1,
Index: inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll.c b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll.c	(date 1689048275414)
@@ -42,25 +42,25 @@
 #include <float.h>
 #include <math.h>
 
-#include "../../../INCHI_BASE/src/mode.h"
+#include "mode.h"
 
-#include "../../../INCHI_BASE/src/incomdef.h"
-#include "../../../INCHI_BASE/src/ichidrp.h"
-#include "../../../INCHI_BASE/src/inpdef.h"
-#include "../../../INCHI_BASE/src/ichi.h"
-#include "../../../INCHI_BASE/src/strutil.h"
-#include "../../../INCHI_BASE/src/util.h"
-#include "../../../INCHI_BASE/src/ichierr.h"
-#include "../../../INCHI_BASE/src/ichimain.h"
-#include "../../../INCHI_BASE/src/extr_ct.h"
-#include "../../../INCHI_BASE/src/ichi_io.h"
-#include "../../../INCHI_BASE/src/ichicomp.h"
-#include "../../../INCHI_BASE/src/inchi_api.h"
-#include "../../../INCHI_BASE/src/readinch.h"
+#include "incomdef.h"
+#include "ichidrp.h"
+#include "inpdef.h"
+#include "ichi.h"
+#include "strutil.h"
+#include "util.h"
+#include "ichierr.h"
+#include "ichimain.h"
+#include "extr_ct.h"
+#include "ichi_io.h"
+#include "ichicomp.h"
+#include "inchi_api.h"
+#include "readinch.h"
 
-#include "../../../INCHI_BASE/src/ichitaut.h"
-#include "../../../INCHI_BASE/src/ichicant.h"
-#include "../../../INCHI_BASE/src/ichitime.h"
+#include "ichitaut.h"
+#include "ichicant.h"
+#include "ichitime.h"
 
 #include "inchi_dll.h"
 
Index: openbabel-src/openbabel/src/descriptor.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/descriptor.cpp b/openbabel-src/openbabel/src/descriptor.cpp
--- a/openbabel-src/openbabel/src/descriptor.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/descriptor.cpp	(date 1689048275866)
@@ -25,11 +25,6 @@
 using namespace std;
 namespace OpenBabel
 {
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-  // macro to implement static OBPlugin::PluginMapType& Map()
-  PLUGIN_CPP_FILE(OBDescriptor)
-#endif
-
 /**
      Compare() is a virtual function and can be overridden to allow different
      comparison behaviour.
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.c b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.c	(date 1689048275414)
@@ -36,12 +36,12 @@
 #include <string.h>
 #include <limits.h>
 
-#include "../../../../INCHI_BASE/src/mode.h"
-#include "../../../../INCHI_BASE/src/ichierr.h"
-#include "../../../../INCHI_BASE/src/mol_fmt.h"
-#include "../../../../INCHI_BASE/src/inchi_api.h"
+#include "mode.h"
+#include "ichierr.h"
+#include "mol_fmt.h"
+#include "inchi_api.h"
 
-#include "../../../../INCHI_BASE/src/ichi_io.h"
+#include "ichi_io.h"
 
 #include "ixa_mol.h"
 #include "ixa_status.h"
Index: rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmarts.cpp.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmarts.cpp.cmake b/rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmarts.cpp.cmake
--- a/rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmarts.cpp.cmake	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmarts.cpp.cmake	(date 1690852232727)
@@ -809,7 +809,7 @@
 #endif
 
 #include <cstdio>
-#ifdef WIN32
+#if defined(WIN32) || defined(__MINGW32__)
 #include <io.h>
 #endif
 
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_inchi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_inchi.c b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_inchi.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_inchi.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_inchi.c	(date 1689048275414)
@@ -34,9 +34,9 @@
 
 #include "string.h"
 
-#include "../../../../INCHI_BASE/src/mode.h"
-#include "../../../../INCHI_BASE/src/inchi_api.h"
-#include "../../../../INCHI_BASE/src/util.h"
+#include "mode.h"
+#include "inchi_api.h"
+#include "util.h"
 #include "ixa_mol.h"
 #include "ixa_status.h"
 
Index: openbabel-src/openbabel/src/descriptors/groupcontrib.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/descriptors/groupcontrib.cpp b/openbabel-src/openbabel/src/descriptors/groupcontrib.cpp
--- a/openbabel-src/openbabel/src/descriptors/groupcontrib.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/descriptors/groupcontrib.cpp	(date 1689048275866)
@@ -55,7 +55,7 @@
     OBSmartsPattern *sp;
 
     // open data file
-    ifstream ifs;
+    istringstream ifs;
 
     if (OpenDatafile(ifs, _filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, " Could not find contribution data file.", obError);
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_inchikey_builder.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_inchikey_builder.c b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_inchikey_builder.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_inchikey_builder.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_inchikey_builder.c	(date 1689048275414)
@@ -32,8 +32,8 @@
  */
 
 
-#include "../../../../INCHI_BASE/src/mode.h"
-#include "../../../../INCHI_BASE/src/inchi_api.h"
+#include "mode.h"
+#include "inchi_api.h"
 #include "ixa_status.h"
 #include <stdlib.h>
 #include <string.h>
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.c b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.c	(date 1689048275414)
@@ -32,8 +32,8 @@
  */
 
 
-#include "../../../../INCHI_BASE/src/mode.h"
-#include "../../../../INCHI_BASE/src/inchi_api.h"
+#include "mode.h"
+#include "inchi_api.h"
 #include "ixa_status.h"
 #include <string.h>
 #include <stdarg.h>
Index: rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmiles.cpp.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmiles.cpp.cmake b/rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmiles.cpp.cmake
--- a/rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmiles.cpp.cmake	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmiles.cpp.cmake	(date 1690852232727)
@@ -816,7 +816,7 @@
 #endif
 
 #include <cstdio>
-#ifdef WIN32
+#if defined(WIN32) || defined(__MINGW32__)
 #include <io.h>
 #endif
 
Index: inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_b.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_b.c b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_b.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_b.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_b.c	(date 1689048275414)
@@ -42,22 +42,22 @@
 #include <float.h>
 #include <math.h>
 
-#include "../../../INCHI_BASE/src/mode.h"
-#include "../../../INCHI_BASE/src/inchi_api.h"
-#include "../../../INCHI_BASE/src/incomdef.h"
-#include "../../../INCHI_BASE/src/ichidrp.h"
-#include "../../../INCHI_BASE/src/inpdef.h"
-#include "../../../INCHI_BASE/src/ichi.h"
-#include "../../../INCHI_BASE/src/strutil.h"
-#include "../../../INCHI_BASE/src/util.h"
-#include "../../../INCHI_BASE/src/ichierr.h"
-#include "../../../INCHI_BASE/src/ichimain.h"
-#include "../../../INCHI_BASE/src/extr_ct.h"
-#include "../../../INCHI_BASE/src/ichi_io.h"
-#include "../../../INCHI_BASE/src/ichicomp.h"
-#include "../../../INCHI_BASE/src/ichitime.h"
-#include "../../../INCHI_BASE/src/ichicant.h"
-#include "../../../INCHI_BASE/src/readinch.h"
+#include "mode.h"
+#include "inchi_api.h"
+#include "incomdef.h"
+#include "ichidrp.h"
+#include "inpdef.h"
+#include "ichi.h"
+#include "strutil.h"
+#include "util.h"
+#include "ichierr.h"
+#include "ichimain.h"
+#include "extr_ct.h"
+#include "ichi_io.h"
+#include "ichicomp.h"
+#include "ichitime.h"
+#include "ichicant.h"
+#include "readinch.h"
 
 #include "inchi_dll.h"
 #include "inchi_dll_b.h"
Index: openbabel-src/openbabel/src/patty.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/patty.cpp b/openbabel-src/openbabel/src/patty.cpp
--- a/openbabel-src/openbabel/src/patty.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/patty.cpp	(date 1689048275890)
@@ -25,6 +25,7 @@
 
 #include <cstring>
 #include <cstdlib>
+#include <fstream>
 
 // Simple programmable atom typer
 // WPW - 070199
Index: inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.c b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.c	(date 1689048275414)
@@ -46,26 +46,26 @@
 #include <limits.h>
 #include <float.h>
 #include <math.h>
-#include "../../../INCHI_BASE/src/incomdef.h"
-#include "../../../INCHI_BASE/src/ichidrp.h"
-#include "../../../INCHI_BASE/src/inpdef.h"
-#include "../../../INCHI_BASE/src/ichi.h"
-#include "../../../INCHI_BASE/src/strutil.h"
-#include "../../../INCHI_BASE/src/util.h"
-#include "../../../INCHI_BASE/src/ichierr.h"
-#include "../../../INCHI_BASE/src/ichimain.h"
-#include "../../../INCHI_BASE/src/extr_ct.h"
-#include "../../../INCHI_BASE/src/ichi_io.h"
-#include "../../../INCHI_BASE/src/mol_fmt.h"
-#include "../../../INCHI_BASE/src/ichicomp.h"
-#include "../../../INCHI_BASE/src/ichitaut.h"
-#include "../../../INCHI_BASE/src/ichinorm.h"
+#include "incomdef.h"
+#include "ichidrp.h"
+#include "inpdef.h"
+#include "ichi.h"
+#include "strutil.h"
+#include "util.h"
+#include "ichierr.h"
+#include "ichimain.h"
+#include "extr_ct.h"
+#include "ichi_io.h"
+#include "mol_fmt.h"
+#include "ichicomp.h"
+#include "ichitaut.h"
+#include "ichinorm.h"
 
 
-#include "../../../INCHI_BASE/src/ichisize.h"
-#include "../../../INCHI_BASE/src/ichitime.h"
-#include "../../../INCHI_BASE/src/mode.h"
-#include "../../../INCHI_BASE/src/inchi_api.h"
+#include "ichisize.h"
+#include "ichitime.h"
+#include "mode.h"
+#include "inchi_api.h"
 
 #include "inchi_dll_a.h" /* not inchi_api.h as it hides internal data types */
 #include "inchi_dll.h"
Index: inchi-src/inchi/INCHI_API/libinchi/src/ichilnct.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ichilnct.c b/inchi-src/inchi/INCHI_API/libinchi/src/ichilnct.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ichilnct.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ichilnct.c	(date 1689048275414)
@@ -42,16 +42,16 @@
 
 /* for use in the InChI library */
 
-#include "../../../INCHI_BASE/src/mode.h"
+#include "mode.h"
 
-#include "../../../INCHI_BASE/src/incomdef.h"
-#include "../../../INCHI_BASE/src/ichidrp.h"
-#include "../../../INCHI_BASE/src/inpdef.h"
-#include "../../../INCHI_BASE/src/util.h"
-#include "../../../INCHI_BASE/src/ichierr.h"
-#include "../../../INCHI_BASE/src/ichicomp.h"
-#include "../../../INCHI_BASE/src/ichi_io.h"
-#include "../../../INCHI_BASE/src/inchi_api.h"
+#include "incomdef.h"
+#include "ichidrp.h"
+#include "inpdef.h"
+#include "util.h"
+#include "ichierr.h"
+#include "ichicomp.h"
+#include "ichi_io.h"
+#include "inchi_api.h"
 
 #include "inchi_dll_b.h"
 
@@ -63,7 +63,7 @@
                        int *err, char *pStrErr );
 
 /* This contains executable code. Included in lReadAux.c, e_ReadINCH.c, ReadINCH.c,  */
-#include "../../../INCHI_BASE/src/readinch.h"
+#include "readinch.h"
 
 
 
Index: inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_main.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_main.c b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_main.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_main.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_main.c	(date 1689048275414)
@@ -34,7 +34,7 @@
 
 /* inchi_dll_main.c : Defines the entry point for the DLL application. */
 
-#include "../../../INCHI_BASE/src/mode.h"
+#include "mode.h"
 
 #if defined(_WIN32) && defined(_USRDLL) && defined(_DEBUG) && !(defined(__STDC__) && __STDC__ == 1)
 #include "inchi_dll_main.h"
Index: openbabel-src/openbabel/src/chargemodel.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/chargemodel.cpp b/openbabel-src/openbabel/src/chargemodel.cpp
--- a/openbabel-src/openbabel/src/chargemodel.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/chargemodel.cpp	(date 1689048275862)
@@ -26,11 +26,6 @@
 using namespace std;
 namespace OpenBabel
 {
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-  // macro to implement static OBPlugin::PluginMapType& Map()
-  PLUGIN_CPP_FILE(OBChargeModel)
-#endif
-
   void OBChargeModel::FillChargeVectors(OBMol &mol)
   {
     OBAtom *atom;
Index: inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a2.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a2.c b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a2.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a2.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a2.c	(date 1689048275414)
@@ -43,31 +43,31 @@
 
 /*  */
 
-#include "../../../INCHI_BASE/src/mode.h"
-#include "../../../INCHI_BASE/src/ichitime.h"
-#include "../../../INCHI_BASE/src/incomdef.h"
-#include "../../../INCHI_BASE/src/ichidrp.h"
-#include "../../../INCHI_BASE/src/inpdef.h"
-#include "../../../INCHI_BASE/src/ichi.h"
-#include "../../../INCHI_BASE/src/strutil.h"
-#include "../../../INCHI_BASE/src/util.h"
-#include "../../../INCHI_BASE/src/ichidrp.h"
-#include "../../../INCHI_BASE/src/ichierr.h"
-#include "../../../INCHI_BASE/src/ichimain.h"
-#include "../../../INCHI_BASE/src/extr_ct.h"
-#include "../../../INCHI_BASE/src/ichitaut.h"
-#include "../../../INCHI_BASE/src/ichi_io.h"
-#include "../../../INCHI_BASE/src/ichinorm.h"
-#include "../../../INCHI_BASE/src/ichicant.h"
-#include "../../../INCHI_BASE/src/ichicano.h"
-#include "../../../INCHI_BASE/src/ichicomn.h"
-#include "../../../INCHI_BASE/src/ichimake.h"
-#include "../../../INCHI_BASE/src/ichister.h"
+#include "mode.h"
+#include "ichitime.h"
+#include "incomdef.h"
+#include "ichidrp.h"
+#include "inpdef.h"
+#include "ichi.h"
+#include "strutil.h"
+#include "util.h"
+#include "ichidrp.h"
+#include "ichierr.h"
+#include "ichimain.h"
+#include "extr_ct.h"
+#include "ichitaut.h"
+#include "ichi_io.h"
+#include "ichinorm.h"
+#include "ichicant.h"
+#include "ichicano.h"
+#include "ichicomn.h"
+#include "ichimake.h"
+#include "ichister.h"
 /* */
 #ifdef INCHI_LIB
 #include "ichi_lib.h"
 #endif
-#include "../../../INCHI_BASE/src/ichicomp.h"
+#include "ichicomp.h"
 
 /* for DisplayTheWholeStructure() */
 #define COMP_ORIG_0_MAIN  0x0001
@@ -77,9 +77,9 @@
 #define COMP_ORIG_1_MAIN  0x0010
 #define COMP_ORIG_1_RECN  0x0020
 
-#include "../../../INCHI_BASE/src/ichisize.h"
-#include "../../../INCHI_BASE/src/mode.h"
-#include "../../../INCHI_BASE/src/inchi_api.h"
+#include "ichisize.h"
+#include "mode.h"
+#include "inchi_api.h"
 #include "inchi_dll_a.h" /* not inchi_api.h as it hides internal data types */
 
 
Index: openbabel-src/openbabel/src/locale.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/locale.cpp b/openbabel-src/openbabel/src/locale.cpp
--- a/openbabel-src/openbabel/src/locale.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/locale.cpp	(date 1689048275886)
@@ -16,33 +16,19 @@
 GNU General Public License for more details.
 ***********************************************************************/
 
-#include <stdlib.h>
-#include <string.h>
 #include <openbabel/locale.h>
-
-#if HAVE_XLOCALE_H
-#include <xlocale.h>
-#endif
-#if HAVE_LOCALE_H
-#include <locale.h>
-#endif
+#include <string>
+#include <clocale>
 
 namespace OpenBabel
 {
   class OBLocalePrivate {
   public:
-    char *old_locale_string;
-#if HAVE_USELOCALE
-    locale_t new_c_num_locale;
-    locale_t old_locale;
-#endif
+    std::string old_locale_string;
     unsigned int counter; // Reference counter -- ensures balance in SetLocale/RestoreLocale calls
 
     OBLocalePrivate(): counter(0)
     {
-#if HAVE_USELOCALE
-      new_c_num_locale = newlocale(LC_NUMERIC_MASK, NULL, NULL);
-#endif
     }
 
     ~OBLocalePrivate()
@@ -92,21 +78,8 @@
   void OBLocale::SetLocale()
   {
     if (d->counter == 0) {
-      // Set the locale for number parsing to avoid locale issues: PR#1785463
-#if HAVE_USELOCALE
-      // Extended per-thread interface
-      d->old_locale = uselocale(d->new_c_num_locale);
-#else
-#ifndef ANDROID
-      // Original global POSIX interface
-      // regular UNIX, no USELOCALE, no ANDROID
-      d->old_locale_string = strdup(setlocale(LC_NUMERIC, nullptr));
-#else
-      // ANDROID should stay as "C" -- Igor Filippov
-      d->old_locale_string = "C";
-#endif
+      d->old_locale_string = std::setlocale(LC_ALL, nullptr);
   	  setlocale(LC_NUMERIC, "C");
-#endif
     }
 
     ++d->counter;
@@ -117,15 +90,7 @@
     --d->counter;
     if(d->counter == 0) {
       // return the locale to the original one
-#ifdef HAVE_USELOCALE
-      uselocale(d->old_locale);
-#else
-      setlocale(LC_NUMERIC, d->old_locale_string);
-#ifndef ANDROID
-      // Don't free on Android because "C" is a static ctring constant
-      free (d->old_locale_string);
-#endif
-#endif
+      std::setlocale(LC_NUMERIC, d->old_locale_string.c_str());
     }
   }
 
Index: openbabel-src/openbabel/src/fingerprint.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/fingerprint.cpp b/openbabel-src/openbabel/src/fingerprint.cpp
--- a/openbabel-src/openbabel/src/fingerprint.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/fingerprint.cpp	(date 1689048275866)
@@ -30,11 +30,6 @@
 using namespace std;
 namespace OpenBabel
 {
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-  // macro to implement static OBPlugin::PluginMapType& Map()
-  PLUGIN_CPP_FILE(OBFingerprint)
-#endif
-
   const unsigned int OBFingerprint::bitsperint = 8 * sizeof(unsigned int);
 
   void OBFingerprint::SetBit(vector<unsigned int>& vec, const unsigned int n)
Index: rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.cpp b/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.cpp	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.cpp	(date 1689048276130)
@@ -45,6 +45,11 @@
 
 TautomerCatalogParams::~TautomerCatalogParams() {}
 
+TautomerCatalogParams::TautomerCatalogParams() {
+    d_typeStr = "Tautomer Catalog Parameters";
+    d_transforms.clear();
+}
+
 const std::vector<TautomerTransform> &TautomerCatalogParams::getTransforms()
     const {
   return d_transforms;
Index: openbabel-src/openbabel/data/ghemical.prm
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/data/ghemical.prm b/openbabel-src/openbabel/data/ghemical.prm
--- a/openbabel-src/openbabel/data/ghemical.prm	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/data/ghemical.prm	(date 1689124959089)
@@ -45,98 +45,98 @@
 // one is chosen. that is, choose normal parameters if there is any matching
 // one, and take wildcarded one only if there is no better choice...
 //
-// [opt] = �
-// [fc] = kcal/(mol * �^2)
+// [opt] = Å
+// [fc] = kcal/(mol * Å^2)
 
-bond 	0602 0602 T 1.204 1400.0
-bond 	0602 0602 S 1.380  700.0
-bond	2300 0601 S 1.890  500.0
-bond	0602 0601 S 1.440 1340.0
-bond	0602 0601 D 1.440 1340.0
-bond	0601 0601 D 1.335 1340.0
-bond	0601 0601 S 1.470  700.0
-bond	0602 0600 S 1.458  640.0
-bond	0601 0600 S 1.501  639.0
-bond	0600 0600 S 1.540  633.6
-bond	2300 0603 S 1.850  500.0
-bond	0602 0603 S 1.440 1340.0
-bond	0601 0603 S 1.510 1340.0
-bond	0600 0603 S 1.525  640.0
-bond	0603 0603 C 1.395 1400.0
-bond	0603 0603 S 1.480 1000.0
-bond	0601 1100 S 1.750  520.0
-bond	0600 1100 S 1.767  600.0
-bond	0603 1100 S 1.750  513.4
-bond	0601 2300 S 1.850  520.0
-bond	0600 2300 S 1.867  600.0
-bond	0603 2300 S 1.850  513.4
-bond	0601 0900 S 1.330 1200.0
-bond	0600 0900 S 1.360  600.0
-bond	0603 0900 S 1.330  500.0
-bond	0602 0100 S 1.056  700.0
-bond	0601 0100 S 1.089  692.0
-bond	0600 0100 S 1.100  662.4
-bond	0603 0100 S 1.084  692.0
-bond	0600 3500 S 2.050  490.0	//added 20050225
-bond	0601 3500 S 2.050  490.0	//added 20050225
-bond	0602 3500 S 2.050  490.0	//added 20050225
-bond	0603 3500 S 2.050  490.0
-bond	0602 0702 T 1.158 1600.0
-bond	0602 0701 S 1.330 1300.0
-bond	0602 0701 D 1.330 1300.0
-bond	0601 0701 D 1.270 1305.9
-bond	0601 0701 S 1.444 1300.0
-bond	0600 0701 S 1.440  760.2
-bond	0603 0701 S 1.346 1305.9
-bond	0701 0701 D 1.346 1305.9
-bond	0701 0701 S 1.418 1300.0
-bond	0601 0700 S 1.330 1300.0
-bond	0600 0700 S 1.470  760.0
-bond	0603 0700 S 1.410  720.0
-bond	0100 0700 S 1.080  692.0
-bond	0601 0704 S 1.330 1300.0
-bond	0600 0704 S 1.470  760.0
-bond	0603 0704 S 1.410  720.0
-bond	0601 0705 S 1.345  870.1
-bond	0600 0705 S 1.450  677.6
-bond	0603 0705 S 1.416 1090.1
-bond	0100 0705 S 1.000  700.0
-bond	0701 0705 S 1.440  667.6
-bond	0705 0705 S 1.450  744.5
-bond	0603 0703 C 1.346 1305.9
-bond	0703 0703 C 1.330 1400.0
-bond	0601 0801 D 1.220 1555.2
-bond	0705 0801 S 1.240 1120.0
-bond	0705 0801 D 1.210  680.0
-bond	0601 0800 S 1.330  699.8
-bond	0600 0800 S 1.430  618.9
-bond	0603 0800 S 1.390  700.0
-bond	0100 0800 S 0.950 1007.5
-bond	0701 0800 S 1.405 1200.0
-bond	0705 0800 S 1.400  620.0
-bond	0800 0800 S 1.480 1172.2
-bond	0600 0F00 S 1.830  407.6
-bond	0801 0F00 S 1.490 1400.0
-bond	0801 0F00 D 1.490 1400.0
-bond	0800 0F00 S 1.600  800.0
-bond	0601 1001 D 1.710  400.0
-bond	0600 1001 S 1.800  381.6
-bond	0603 1001 S 1.740  700.0
-bond	0601 1000 S 1.780  360.0
-bond	0600 1000 S 1.817  381.6
-bond	0603 1000 S 1.770  360.0
-bond	0700 1000 S 1.625  360.0
-bond	0704 1000 S 1.625  360.0
-bond	0801 1000 D 1.450  600.0
-bond	1000 1000 S 2.030  600.0
-bond	0601 1002 S 1.710  360.0
-bond	0600 1002 S 1.800  381.6
-bond	0801 1002 D 1.450  600.0
-bond	0800 1002 S 1.500  600.0
-bond	0600 1003 S 1.800  381.6
-bond	0801 1003 D 1.450  600.0
-bond	0800 1003 S 1.500  600.0
-bond	FFFF 0100 S 1.008  700.0
+bond    0602 0602 T 1.204 1400.0
+bond    0602 0602 S 1.380  700.0
+bond    2300 0601 S 1.890  500.0
+bond    0602 0601 S 1.440 1340.0
+bond    0602 0601 D 1.440 1340.0
+bond    0601 0601 D 1.335 1340.0
+bond    0601 0601 S 1.470  700.0
+bond    0602 0600 S 1.458  640.0
+bond    0601 0600 S 1.501  639.0
+bond    0600 0600 S 1.540  633.6
+bond    2300 0603 S 1.850  500.0
+bond    0602 0603 S 1.440 1340.0
+bond    0601 0603 S 1.510 1340.0
+bond    0600 0603 S 1.525  640.0
+bond    0603 0603 C 1.395 1400.0
+bond    0603 0603 S 1.480 1000.0
+bond    0601 1100 S 1.750  520.0
+bond    0600 1100 S 1.767  600.0
+bond    0603 1100 S 1.750  513.4
+bond    0601 2300 S 1.850  520.0
+bond    0600 2300 S 1.867  600.0
+bond    0603 2300 S 1.850  513.4
+bond    0601 0900 S 1.330 1200.0
+bond    0600 0900 S 1.360  600.0
+bond    0603 0900 S 1.330  500.0
+bond    0602 0100 S 1.056  700.0
+bond    0601 0100 S 1.089  692.0
+bond    0600 0100 S 1.100  662.4
+bond    0603 0100 S 1.084  692.0
+bond    0600 3500 S 2.050  490.0    //added 20050225
+bond    0601 3500 S 2.050  490.0    //added 20050225
+bond    0602 3500 S 2.050  490.0    //added 20050225
+bond    0603 3500 S 2.050  490.0
+bond    0602 0702 T 1.158 1600.0
+bond    0602 0701 S 1.330 1300.0
+bond    0602 0701 D 1.330 1300.0
+bond    0601 0701 D 1.270 1305.9
+bond    0601 0701 S 1.444 1300.0
+bond    0600 0701 S 1.440  760.2
+bond    0603 0701 S 1.346 1305.9
+bond    0701 0701 D 1.346 1305.9
+bond    0701 0701 S 1.418 1300.0
+bond    0601 0700 S 1.330 1300.0
+bond    0600 0700 S 1.470  760.0
+bond    0603 0700 S 1.410  720.0
+bond    0100 0700 S 1.080  692.0
+bond    0601 0704 S 1.330 1300.0
+bond    0600 0704 S 1.470  760.0
+bond    0603 0704 S 1.410  720.0
+bond    0601 0705 S 1.345  870.1
+bond    0600 0705 S 1.450  677.6
+bond    0603 0705 S 1.416 1090.1
+bond    0100 0705 S 1.000  700.0
+bond    0701 0705 S 1.440  667.6
+bond    0705 0705 S 1.450  744.5
+bond    0603 0703 C 1.346 1305.9
+bond    0703 0703 C 1.330 1400.0
+bond    0601 0801 D 1.220 1555.2
+bond    0705 0801 S 1.240 1120.0
+bond    0705 0801 D 1.210  680.0
+bond    0601 0800 S 1.330  699.8
+bond    0600 0800 S 1.430  618.9
+bond    0603 0800 S 1.390  700.0
+bond    0100 0800 S 0.950 1007.5
+bond    0701 0800 S 1.405 1200.0
+bond    0705 0800 S 1.400  620.0
+bond    0800 0800 S 1.480 1172.2
+bond    0600 0F00 S 1.830  407.6
+bond    0801 0F00 S 1.490 1400.0
+bond    0801 0F00 D 1.490 1400.0
+bond    0800 0F00 S 1.600  800.0
+bond    0601 1001 D 1.710  400.0
+bond    0600 1001 S 1.800  381.6
+bond    0603 1001 S 1.740  700.0
+bond    0601 1000 S 1.780  360.0
+bond    0600 1000 S 1.817  381.6
+bond    0603 1000 S 1.770  360.0
+bond    0700 1000 S 1.625  360.0
+bond    0704 1000 S 1.625  360.0
+bond    0801 1000 D 1.450  600.0
+bond    1000 1000 S 2.030  600.0
+bond    0601 1002 S 1.710  360.0
+bond    0600 1002 S 1.800  381.6
+bond    0801 1002 D 1.450  600.0
+bond    0800 1002 S 1.500  600.0
+bond    0600 1003 S 1.800  381.6
+bond    0801 1003 D 1.450  600.0
+bond    0800 1003 S 1.500  600.0
+bond    FFFF 0100 S 1.008  700.0
 
 // angle bending parameters 09.05.2000 (based on Tripos 5.2 and MMFF94)
 // [id #1] [id #2] [id #3] [bt12][bt23] [opt] [fc]
@@ -147,191 +147,191 @@
 // [opt] = deg
 // [fc] = kcal/(mol * deg^2)
 
-angle	0602 0602 0601 ?? 180.0 0.040
-angle	0601 0602 0702 ?? 180.0 0.040
-angle	0600 0602 0702 ?? 180.0 0.040
-angle	0603 0602 0702 ?? 180.0 0.040
-angle	0702 0602 0800 ?? 180.0 0.040
-angle	2300 0601 2300 ?? 120.0 0.020
-angle	2300 0601 0601 ?? 120.0 0.036
-angle	0601 0601 0601 ?? 121.7 0.018
-angle	0602 0601 0600 ?? 120.0 0.024
-angle	0601 0601 0600 ?? 121.0 0.024
-angle	0600 0601 0600 ?? 116.4 0.046
-angle	0602 0601 0603 ?? 120.0 0.024
-angle	0601 0601 0603 ?? 120.0 0.026
-angle	0600 0601 0603 ?? 120.0 0.024
-angle	0603 0601 0603 ?? 120.0 0.024
-angle	0601 0601 1100 ?? 120.0 0.036
-angle	0603 0601 1100 ?? 120.0 0.036
-angle	1100 0601 1100 ?? 122.0 0.030
-angle	0601 0601 2300 ?? 120.0 0.036
-angle	0603 0601 2300 ?? 120.0 0.036
-angle	2300 0601 2300 ?? 122.0 0.030
-angle	0602 0601 0701 ?? 123.0 0.070
-angle	0601 0601 0701 ?? 120.0 0.024
-angle	0600 0601 0701 ?? 118.0 0.020
-angle	0603 0601 0701 ?? 120.0 0.040
-angle	0601 0601 0700 ?? 120.0 0.024
-angle	0600 0601 0700 ?? 118.0 0.040
-angle	0701 0601 0700 ?? 121.8 0.030
-angle	0700 0601 0700 ?? 116.4 0.030
-angle	0601 0601 0705 ?? 120.0 0.024
-angle	0600 0601 0705 ?? 117.0 0.020
-angle	0603 0601 0705 ?? 120.0 0.040
-angle	0701 0601 0705 ?? 123.0 0.070
-angle	0705 0601 0705 ?? 120.0 0.030
-angle	0602 0601 0801 ?? 120.0 0.060
-angle	0601 0601 0801 ?? 120.0 0.026
-angle	0600 0601 0801 ?? 120.0 0.026
-angle	0603 0601 0801 ?? 120.0 0.026
-angle	0700 0601 0801 ?? 120.0 0.026
-angle	0705 0601 0801 ?? 123.0 0.030
-angle	0601 0601 0800 ?? 120.0 0.072
-angle	0600 0601 0800 ?? 114.0 0.030
-angle	0603 0601 0800 ?? 120.0 0.030
-angle	0705 0601 0800 ?? 110.5 0.014
-angle	0801 0601 0800 ?? 120.0 0.030
-angle	0701 0601 1000 ?? 125.6 0.028
-angle	0705 0601 1000 ?? 111.5 0.030
-angle	0801 0601 1000 ?? 125.0 0.016
-angle	0601 0600 0601 ?? 109.5 0.018
-angle	0602 0600 0600 ?? 109.5 0.024
-angle	0601 0600 0600 ?? 109.5 0.018
-angle	0600 0600 0600 ?? 109.5 0.024
-angle	0601 0600 0603 ?? 109.5 0.018
-angle	0600 0600 0603 ?? 109.5 0.024
-angle	0603 0600 0603 ?? 109.5 0.018
-angle	0600 0600 1100 ?? 109.5 0.020
-angle	1100 0600 1100 ?? 109.5 0.020
-angle	0600 0600 2300 ?? 109.5 0.020
-angle	2300 0600 2300 ?? 109.5 0.020
-angle	0603 0600 0900 ?? 110.0 0.024
-angle	0900 0600 0900 ?? 109.5 0.040
-angle	0601 0600 0100 ?? 110.0 0.016
-angle	0100 0600 0100 ?? 109.5 0.024
-angle	0600 0600 0701 ?? 109.5 0.018
-angle	0601 0600 0700 ?? 109.5 0.018
-angle	0600 0600 0700 ?? 109.5 0.024
-angle	0603 0600 0700 ?? 109.5 0.018
-angle	0601 0600 0705 ?? 109.5 0.022
-angle	0600 0600 0705 ?? 109.5 0.018
-angle	0603 0600 0705 ?? 109.5 0.020
-angle	0100 0600 0705 ?? 110.0 0.020
-angle	0701 0600 0705 ?? 109.5 0.020
-angle	0705 0600 0705 ?? 109.5 0.040
-angle	0900 0600 0703 ?? 109.5 0.040
-angle	0601 0600 0800 ?? 109.5 0.022
-angle	0600 0600 0800 ?? 109.5 0.022
-angle	0603 0600 0800 ?? 109.5 0.018
-angle	0705 0600 0800 ?? 109.5 0.020
-angle	0800 0600 0800 ?? 109.5 0.020
-angle	0600 0600 0F00 ?? 112.0 0.014
-angle	0601 0600 1001 ?? 109.5 0.018
-angle	0600 0600 1001 ?? 109.5 0.018
-angle	0705 0600 1001 ?? 109.5 0.040
-angle	0601 0600 1000 ?? 107.8 0.018
-angle	0600 0600 1000 ?? 107.8 0.018
-angle	0603 0600 1000 ?? 107.8 0.018
-angle	0705 0600 1000 ?? 109.5 0.024
-angle	0800 0600 1000 ?? 107.8 0.020
-angle	2300 0603 0603 ?? 120.0 0.036
-angle	0601 0603 0603 ?? 120.0 0.024
-angle	0600 0603 0603 ?? 120.0 0.024
-angle	0603 0603 0603 ?? 120.0 0.024
-angle	0603 0603 1100 ?? 120.0 0.036
-angle	0603 0603 2300 ?? 120.0 0.036
-angle	0603 0603 0900 ?? 120.0 0.036
-angle	0603 0603 3500 ?? 120.0 0.036
-angle	0600 0603 0701 ?? 120.0 0.040
-angle	0603 0603 0701 ?? 120.0 0.040
-angle	0701 0603 0701 ?? 120.0 0.040
-angle	0603 0603 0700 ?? 120.0 0.062
-angle	0600 0603 0705 ?? 120.0 0.040
-angle	0603 0603 0705 ?? 120.0 0.062
-angle	0701 0603 0705 ?? 118.0 0.040
-angle	0705 0603 0705 ?? 120.0 0.030
-angle	0601 0603 0703 ?? 120.0 0.040
-angle	0600 0603 0703 ?? 120.0 0.040
-angle	0603 0603 0703 ?? 120.0 0.024
-angle	0705 0603 0703 ?? 118.0 0.040
-angle	0600 0603 0800 ?? 120.0 0.040
-angle	0603 0603 0800 ?? 120.0 0.062
-angle	0603 0603 1001 ?? 120.0 0.062
-angle	0603 0603 1000 ?? 120.0 0.062
-angle	0602 0701 0601 ?? 120.0 0.040
-angle	0601 0701 0601 ?? 123.0 0.080
-angle	0601 0701 0600 ?? 110.0 0.082
-angle	0601 0701 0603 ?? 123.0 0.080
-angle	0600 0701 0603 ?? 110.0 0.082
-angle	0603 0701 0603 ?? 120.0 0.040
-angle	0601 0701 0701 ?? 112.0 0.044
-angle	0600 0701 0701 ?? 118.0 0.040
-angle	0603 0701 0701 ?? 118.0 0.040
-angle	0601 0701 0705 ?? 120.0 0.044
-angle	0601 0701 0800 ?? 105.0 0.044
-angle	0601 0700 0600 ?? 110.0 0.040
-angle	0600 0700 0600 ?? 109.5 0.018
-angle	0600 0700 0603 ?? 118.0 0.040
-angle	0603 0700 0603 ?? 118.0 0.040
-angle	0600 0700 1001 ?? 109.5 0.040
-angle	0600 0704 0600 ?? 109.5 0.018
-angle	0601 0705 0601 ?? 120.0 0.018
-angle	0601 0705 0600 ?? 118.0 0.044
-angle	0600 0705 0600 ?? 122.0 0.040
-angle	0601 0705 0603 ?? 120.0 0.052
-angle	0600 0705 0603 ?? 118.0 0.044
-angle	0603 0705 0603 ?? 120.0 0.044
-angle	0601 0705 0100 ?? 119.0 0.016
-angle	0600 0705 0100 ?? 117.0 0.020
-angle	0601 0705 0701 ?? 120.0 0.018
-angle	0600 0705 0701 ?? 120.0 0.024
-angle	0603 0705 0701 ?? 109.5 0.044
-angle	0601 0705 0705 ?? 120.0 0.018
-angle	0600 0705 0705 ?? 120.0 0.024
-angle	0603 0705 0705 ?? 120.0 0.052
-angle	0601 0705 0801 ?? 120.0 0.024
-angle	0600 0705 0801 ?? 120.0 0.020
-angle	0603 0705 0801 ?? 120.0 0.024
-angle	0801 0705 0801 ?? 120.0 0.020
-angle	0603 0703 0603 ?? 120.0 0.040
-angle	0601 0800 0601 ?? 110.0 0.020
-angle	0601 0800 0600 ?? 109.5 0.044
-angle	0600 0800 0600 ?? 109.5 0.044
-angle	0601 0800 0603 ?? 110.0 0.020
-angle	0600 0800 0603 ?? 110.0 0.020
-angle	0603 0800 0603 ?? 110.0 0.020
-angle	0601 0800 0701 ?? 108.5 0.044
-angle	0600 0800 0800 ?? 103.9 0.094
-angle	0600 0800 0F00 ?? 120.0 0.010
-angle	0801 0F00 0801 ?? 109.5 0.020
-angle	0801 0F00 0800 ?? 109.5 0.020
-angle	0800 0F00 0800 ?? 109.5 0.020
-angle	0600 1001 0700 ?? 111.0 0.040
-angle	0603 1001 0700 ?? 111.0 0.040
-angle	0601 1000 0600 ??  94.3 0.022
-angle	0600 1000 0600 ??  98.0 0.020
-angle	0603 1000 0603 ??  97.5 0.062
-angle	0603 1000 1000 ?? 102.9 0.060
-angle	0801 1003 0801 ?? 118.0 0.040
-angle	FFFF 0601 0100 ?? 120.0 0.012
-angle	FFFF 0600 0100 ?? 109.5 0.016
-angle	FFFF 1002 0801 ?? 107.0 0.040
-angle	FFFF 1003 0801 ?? 107.0 0.040
-angle	FFFF 0602 FFFF ?? 180.0 0.040
-angle	FFFF 0601 FFFF ?? 120.0 0.024
-angle	FFFF 0600 FFFF ?? 109.5 0.020
-angle	FFFF 0603 FFFF ?? 120.0 0.024
-angle	FFFF 0702 FFFF ?? 180.0 0.080
-angle	FFFF 0701 FFFF ?? 120.0 0.040
-angle	FFFF 0700 FFFF ?? 109.5 0.040
-angle	FFFF 0704 FFFF ?? 109.5 0.010
-angle	FFFF 0705 FFFF ?? 120.0 0.020
-angle	FFFF 0703 FFFF ?? 120.0 0.020
-angle	FFFF 0800 FFFF ?? 109.5 0.020
-angle	FFFF 0F00 FFFF ?? 109.5 0.020
-angle	FFFF 1001 FFFF ?? 110.5 0.040
-angle	FFFF 1000 FFFF ??  97.0 0.020
+angle    0602 0602 0601 ?? 180.0 0.040
+angle    0601 0602 0702 ?? 180.0 0.040
+angle    0600 0602 0702 ?? 180.0 0.040
+angle    0603 0602 0702 ?? 180.0 0.040
+angle    0702 0602 0800 ?? 180.0 0.040
+angle    2300 0601 2300 ?? 120.0 0.020
+angle    2300 0601 0601 ?? 120.0 0.036
+angle    0601 0601 0601 ?? 121.7 0.018
+angle    0602 0601 0600 ?? 120.0 0.024
+angle    0601 0601 0600 ?? 121.0 0.024
+angle    0600 0601 0600 ?? 116.4 0.046
+angle    0602 0601 0603 ?? 120.0 0.024
+angle    0601 0601 0603 ?? 120.0 0.026
+angle    0600 0601 0603 ?? 120.0 0.024
+angle    0603 0601 0603 ?? 120.0 0.024
+angle    0601 0601 1100 ?? 120.0 0.036
+angle    0603 0601 1100 ?? 120.0 0.036
+angle    1100 0601 1100 ?? 122.0 0.030
+angle    0601 0601 2300 ?? 120.0 0.036
+angle    0603 0601 2300 ?? 120.0 0.036
+angle    2300 0601 2300 ?? 122.0 0.030
+angle    0602 0601 0701 ?? 123.0 0.070
+angle    0601 0601 0701 ?? 120.0 0.024
+angle    0600 0601 0701 ?? 118.0 0.020
+angle    0603 0601 0701 ?? 120.0 0.040
+angle    0601 0601 0700 ?? 120.0 0.024
+angle    0600 0601 0700 ?? 118.0 0.040
+angle    0701 0601 0700 ?? 121.8 0.030
+angle    0700 0601 0700 ?? 116.4 0.030
+angle    0601 0601 0705 ?? 120.0 0.024
+angle    0600 0601 0705 ?? 117.0 0.020
+angle    0603 0601 0705 ?? 120.0 0.040
+angle    0701 0601 0705 ?? 123.0 0.070
+angle    0705 0601 0705 ?? 120.0 0.030
+angle    0602 0601 0801 ?? 120.0 0.060
+angle    0601 0601 0801 ?? 120.0 0.026
+angle    0600 0601 0801 ?? 120.0 0.026
+angle    0603 0601 0801 ?? 120.0 0.026
+angle    0700 0601 0801 ?? 120.0 0.026
+angle    0705 0601 0801 ?? 123.0 0.030
+angle    0601 0601 0800 ?? 120.0 0.072
+angle    0600 0601 0800 ?? 114.0 0.030
+angle    0603 0601 0800 ?? 120.0 0.030
+angle    0705 0601 0800 ?? 110.5 0.014
+angle    0801 0601 0800 ?? 120.0 0.030
+angle    0701 0601 1000 ?? 125.6 0.028
+angle    0705 0601 1000 ?? 111.5 0.030
+angle    0801 0601 1000 ?? 125.0 0.016
+angle    0601 0600 0601 ?? 109.5 0.018
+angle    0602 0600 0600 ?? 109.5 0.024
+angle    0601 0600 0600 ?? 109.5 0.018
+angle    0600 0600 0600 ?? 109.5 0.024
+angle    0601 0600 0603 ?? 109.5 0.018
+angle    0600 0600 0603 ?? 109.5 0.024
+angle    0603 0600 0603 ?? 109.5 0.018
+angle    0600 0600 1100 ?? 109.5 0.020
+angle    1100 0600 1100 ?? 109.5 0.020
+angle    0600 0600 2300 ?? 109.5 0.020
+angle    2300 0600 2300 ?? 109.5 0.020
+angle    0603 0600 0900 ?? 110.0 0.024
+angle    0900 0600 0900 ?? 109.5 0.040
+angle    0601 0600 0100 ?? 110.0 0.016
+angle    0100 0600 0100 ?? 109.5 0.024
+angle    0600 0600 0701 ?? 109.5 0.018
+angle    0601 0600 0700 ?? 109.5 0.018
+angle    0600 0600 0700 ?? 109.5 0.024
+angle    0603 0600 0700 ?? 109.5 0.018
+angle    0601 0600 0705 ?? 109.5 0.022
+angle    0600 0600 0705 ?? 109.5 0.018
+angle    0603 0600 0705 ?? 109.5 0.020
+angle    0100 0600 0705 ?? 110.0 0.020
+angle    0701 0600 0705 ?? 109.5 0.020
+angle    0705 0600 0705 ?? 109.5 0.040
+angle    0900 0600 0703 ?? 109.5 0.040
+angle    0601 0600 0800 ?? 109.5 0.022
+angle    0600 0600 0800 ?? 109.5 0.022
+angle    0603 0600 0800 ?? 109.5 0.018
+angle    0705 0600 0800 ?? 109.5 0.020
+angle    0800 0600 0800 ?? 109.5 0.020
+angle    0600 0600 0F00 ?? 112.0 0.014
+angle    0601 0600 1001 ?? 109.5 0.018
+angle    0600 0600 1001 ?? 109.5 0.018
+angle    0705 0600 1001 ?? 109.5 0.040
+angle    0601 0600 1000 ?? 107.8 0.018
+angle    0600 0600 1000 ?? 107.8 0.018
+angle    0603 0600 1000 ?? 107.8 0.018
+angle    0705 0600 1000 ?? 109.5 0.024
+angle    0800 0600 1000 ?? 107.8 0.020
+angle    2300 0603 0603 ?? 120.0 0.036
+angle    0601 0603 0603 ?? 120.0 0.024
+angle    0600 0603 0603 ?? 120.0 0.024
+angle    0603 0603 0603 ?? 120.0 0.024
+angle    0603 0603 1100 ?? 120.0 0.036
+angle    0603 0603 2300 ?? 120.0 0.036
+angle    0603 0603 0900 ?? 120.0 0.036
+angle    0603 0603 3500 ?? 120.0 0.036
+angle    0600 0603 0701 ?? 120.0 0.040
+angle    0603 0603 0701 ?? 120.0 0.040
+angle    0701 0603 0701 ?? 120.0 0.040
+angle    0603 0603 0700 ?? 120.0 0.062
+angle    0600 0603 0705 ?? 120.0 0.040
+angle    0603 0603 0705 ?? 120.0 0.062
+angle    0701 0603 0705 ?? 118.0 0.040
+angle   0705 0603 0705 ?? 120.0 0.030
+angle    0601 0603 0703 ?? 120.0 0.040
+angle    0600 0603 0703 ?? 120.0 0.040
+angle    0603 0603 0703 ?? 120.0 0.024
+angle    0705 0603 0703 ?? 118.0 0.040
+angle    0600 0603 0800 ?? 120.0 0.040
+angle    0603 0603 0800 ?? 120.0 0.062
+angle    0603 0603 1001 ?? 120.0 0.062
+angle    0603 0603 1000 ?? 120.0 0.062
+angle    0602 0701 0601 ?? 120.0 0.040
+angle    0601 0701 0601 ?? 123.0 0.080
+angle    0601 0701 0600 ?? 110.0 0.082
+angle    0601 0701 0603 ?? 123.0 0.080
+angle    0600 0701 0603 ?? 110.0 0.082
+angle    0603 0701 0603 ?? 120.0 0.040
+angle    0601 0701 0701 ?? 112.0 0.044
+angle    0600 0701 0701 ?? 118.0 0.040
+angle    0603 0701 0701 ?? 118.0 0.040
+angle    0601 0701 0705 ?? 120.0 0.044
+angle    0601 0701 0800 ?? 105.0 0.044
+angle    0601 0700 0600 ?? 110.0 0.040
+angle    0600 0700 0600 ?? 109.5 0.018
+angle    0600 0700 0603 ?? 118.0 0.040
+angle    0603 0700 0603 ?? 118.0 0.040
+angle    0600 0700 1001 ?? 109.5 0.040
+angle    0600 0704 0600 ?? 109.5 0.018
+angle    0601 0705 0601 ?? 120.0 0.018
+angle    0601 0705 0600 ?? 118.0 0.044
+angle    0600 0705 0600 ?? 122.0 0.040
+angle    0601 0705 0603 ?? 120.0 0.052
+angle    0600 0705 0603 ?? 118.0 0.044
+angle    0603 0705 0603 ?? 120.0 0.044
+angle    0601 0705 0100 ?? 119.0 0.016
+angle    0600 0705 0100 ?? 117.0 0.020
+angle    0601 0705 0701 ?? 120.0 0.018
+angle    0600 0705 0701 ?? 120.0 0.024
+angle    0603 0705 0701 ?? 109.5 0.044
+angle    0601 0705 0705 ?? 120.0 0.018
+angle    0600 0705 0705 ?? 120.0 0.024
+angle    0603 0705 0705 ?? 120.0 0.052
+angle    0601 0705 0801 ?? 120.0 0.024
+angle    0600 0705 0801 ?? 120.0 0.020
+angle    0603 0705 0801 ?? 120.0 0.024
+angle    0801 0705 0801 ?? 120.0 0.020
+angle    0603 0703 0603 ?? 120.0 0.040
+angle    0601 0800 0601 ?? 110.0 0.020
+angle    0601 0800 0600 ?? 109.5 0.044
+angle    0600 0800 0600 ?? 109.5 0.044
+angle    0601 0800 0603 ?? 110.0 0.020
+angle    0600 0800 0603 ?? 110.0 0.020
+angle    0603 0800 0603 ?? 110.0 0.020
+angle    0601 0800 0701 ?? 108.5 0.044
+angle    0600 0800 0800 ?? 103.9 0.094
+angle    0600 0800 0F00 ?? 120.0 0.010
+angle    0801 0F00 0801 ?? 109.5 0.020
+angle    0801 0F00 0800 ?? 109.5 0.020
+angle    0800 0F00 0800 ?? 109.5 0.020
+angle    0600 1001 0700 ?? 111.0 0.040
+angle    0603 1001 0700 ?? 111.0 0.040
+angle    0601 1000 0600 ??  94.3 0.022
+angle    0600 1000 0600 ??  98.0 0.020
+angle    0603 1000 0603 ??  97.5 0.062
+angle    0603 1000 1000 ?? 102.9 0.060
+angle    0801 1003 0801 ?? 118.0 0.040
+angle    FFFF 0601 0100 ?? 120.0 0.012
+angle    FFFF 0600 0100 ?? 109.5 0.016
+angle    FFFF 1002 0801 ?? 107.0 0.040
+angle    FFFF 1003 0801 ?? 107.0 0.040
+angle    FFFF 0602 FFFF ?? 180.0 0.040
+angle    FFFF 0601 FFFF ?? 120.0 0.024
+angle    FFFF 0600 FFFF ?? 109.5 0.020
+angle    FFFF 0603 FFFF ?? 120.0 0.024
+angle    FFFF 0702 FFFF ?? 180.0 0.080
+angle    FFFF 0701 FFFF ?? 120.0 0.040
+angle    FFFF 0700 FFFF ?? 109.5 0.040
+angle    FFFF 0704 FFFF ?? 109.5 0.010
+angle    FFFF 0705 FFFF ?? 120.0 0.020
+angle    FFFF 0703 FFFF ?? 120.0 0.020
+angle    FFFF 0800 FFFF ?? 109.5 0.020
+angle    FFFF 0F00 FFFF ?? 109.5 0.020
+angle    FFFF 1001 FFFF ?? 110.5 0.040
+angle    FFFF 1000 FFFF ??  97.0 0.020
 
 // torsion parameters 09.05.2000 (based on Tripos 5.2 and MMFF94)
 // [id #1] [id #2] [id #3] [id #4] [bt12][bt23][bt34] [k] [n] [s]
@@ -341,108 +341,108 @@
 //
 // [k] = kcal/mol (rotational barrier ???)
 
-torsion	0801 0601 0600 0600 ?S?  0.700 - 3.0
-torsion	0601 0600 0600 0601 ?S?  0.040 + 3.0
-torsion	0601 0600 0600 0600 ?S?  0.126 + 3.0
-torsion	0600 0600 0600 0600 ?S?  0.500 + 3.0
-torsion	0601 0601 0600 0601 ?S?  0.126 - 3.0
-torsion	0601 0601 0600 0100 ?S?  0.273 - 3.0
-torsion	0600 0601 0600 0601 ?S?  0.126 + 3.0
-torsion	0600 0601 0600 0600 ?S?  0.126 + 3.0
-torsion	0600 0601 0600 0100 ?S?  0.274 + 3.0
-torsion	0100 0601 0600 0601 ?S?  0.274 + 3.0
-torsion	0100 0601 0600 0600 ?S?  0.274 + 3.0
-torsion	0100 0601 0600 0100 ?S?  0.274 + 3.0
-torsion	0601 0601 0600 0600 ?S?  0.126 - 3.0
-torsion	FFFF 0601 0600 0601 ?S?  0.126 + 3.0
-torsion	FFFF 0601 0600 0600 ?S?  0.126 + 3.0
-torsion	FFFF 0601 0600 0100 ?S?  0.274 + 3.0
-torsion	FFFF 0600 0600 0100 ?S?  0.320 + 3.0
-torsion	0601 0601 0600 FFFF ?S?  0.126 - 3.0
-torsion	0600 0601 0600 FFFF ?S?  0.126 + 3.0
-torsion	0100 0601 0600 FFFF ?S?  0.274 + 3.0
-torsion	FFFF 0602 0602 FFFF ?T?  0.000 + 1.0
-torsion	FFFF 0602 0602 FFFF ?S?  0.000 + 1.0
-torsion	FFFF 0602 0601 FFFF ?S?  0.000 + 1.0
-torsion	FFFF 0602 0601 FFFF ?D?  0.000 + 1.0
-torsion	FFFF 0601 0601 FFFF ?D? 12.500 - 2.0
-torsion	FFFF 0601 0601 FFFF ?S?  1.424 - 2.0
-torsion	FFFF 0602 0600 FFFF ?S?  0.000 + 1.0
-torsion	FFFF 0601 0600 FFFF ?S?  0.120 - 3.0
-torsion	FFFF 0600 0600 FFFF ?S?  0.200 + 3.0
-torsion	FFFF 0602 0603 FFFF ?S?  0.000 + 1.0
-torsion	FFFF 0601 0603 FFFF ?S?  1.600 - 2.0
-torsion	FFFF 0600 0603 FFFF ?S?  0.120 - 3.0
-torsion	FFFF 0603 0603 FFFF ?C?  2.000 - 2.0
-torsion	FFFF 0603 0603 FFFF ?S?  0.600 - 2.0
-torsion	FFFF 0602 0701 FFFF ?S?  0.000 + 1.0
-torsion	FFFF 0602 0701 FFFF ?D?  0.000 + 1.0
-torsion	FFFF 0601 0701 FFFF ?D? 12.000 - 2.0
-torsion	FFFF 0601 0701 FFFF ?S? 12.000 - 2.0
-torsion	FFFF 0600 0701 FFFF ?S?  0.400 - 3.0
-torsion	FFFF 0603 0701 FFFF ?S?  1.600 - 2.0
-torsion	FFFF 0701 0701 FFFF ?D?  1.600 - 2.0
-torsion	FFFF 0701 0701 FFFF ?S?  1.600 - 2.0
-torsion	FFFF 0601 0700 FFFF ?S?  0.120 - 3.0
-torsion	FFFF 0600 0700 FFFF ?S?  0.200 + 3.0
-torsion	FFFF 0603 0700 FFFF ?S?  0.120 - 3.0
-torsion	FFFF 0700 0700 FFFF ?S?  0.200 + 3.0
-torsion	FFFF 0601 0705 FFFF ?S?  6.460 - 2.0
-torsion	FFFF 0600 0705 FFFF ?S?  0.200 + 3.0
-torsion	FFFF 0603 0705 FFFF ?S?  1.600 - 2.0
-torsion	FFFF 0701 0705 FFFF ?S?  1.600 - 2.0
-torsion	FFFF 0700 0705 FFFF ?S?  0.120 - 3.0
-torsion	FFFF 0705 0705 FFFF ?S?  1.600 - 2.0
-torsion	FFFF 0603 0703 FFFF ?C?  1.600 - 2.0
-torsion	FFFF 0601 0800 FFFF ?S?  5.800 - 2.0
-torsion	FFFF 0600 0800 FFFF ?S?  1.200 + 3.0
-torsion	FFFF 0603 0800 FFFF ?S?  1.200 - 2.0
-torsion	FFFF 0701 0800 FFFF ?S?  1.000 + 2.0
-torsion	FFFF 0700 0800 FFFF ?S?  0.200 + 3.0
-torsion	FFFF 0601 0F00 FFFF ?S?  1.000 - 2.0
-torsion	FFFF 0600 0F00 FFFF ?S?  0.400 + 3.0
-torsion	FFFF 0603 0F00 FFFF ?S?  1.000 + 3.0
-torsion	FFFF 0800 0F00 FFFF ?S?  0.400 + 3.0
-torsion	FFFF 0601 1001 FFFF ?D?  1.000 - 2.0
-torsion	FFFF 0600 1001 FFFF ?S?  0.400 + 3.0
-torsion	FFFF 0603 1001 FFFF ?S?  1.000 + 3.0
-torsion	FFFF 0700 1001 FFFF ?S?  0.400 + 3.0
-torsion	FFFF 0601 1000 FFFF ?S?  1.000 - 2.0
-torsion	FFFF 0600 1000 FFFF ?S?  0.400 + 3.0
-torsion	FFFF 0603 1000 FFFF ?S?  1.000 + 3.0
-torsion	FFFF 1000 1000 FFFF ?S?  4.000 + 3.0
+torsion    0801 0601 0600 0600 ?S?  0.700 - 3.0
+torsion    0601 0600 0600 0601 ?S?  0.040 + 3.0
+torsion    0601 0600 0600 0600 ?S?  0.126 + 3.0
+torsion    0600 0600 0600 0600 ?S?  0.500 + 3.0
+torsion    0601 0601 0600 0601 ?S?  0.126 - 3.0
+torsion    0601 0601 0600 0100 ?S?  0.273 - 3.0
+torsion    0600 0601 0600 0601 ?S?  0.126 + 3.0
+torsion    0600 0601 0600 0600 ?S?  0.126 + 3.0
+torsion    0600 0601 0600 0100 ?S?  0.274 + 3.0
+torsion    0100 0601 0600 0601 ?S?  0.274 + 3.0
+torsion    0100 0601 0600 0600 ?S?  0.274 + 3.0
+torsion    0100 0601 0600 0100 ?S?  0.274 + 3.0
+torsion    0601 0601 0600 0600 ?S?  0.126 - 3.0
+torsion    FFFF 0601 0600 0601 ?S?  0.126 + 3.0
+torsion    FFFF 0601 0600 0600 ?S?  0.126 + 3.0
+torsion    FFFF 0601 0600 0100 ?S?  0.274 + 3.0
+torsion    FFFF 0600 0600 0100 ?S?  0.320 + 3.0
+torsion    0601 0601 0600 FFFF ?S?  0.126 - 3.0
+torsion    0600 0601 0600 FFFF ?S?  0.126 + 3.0
+torsion    0100 0601 0600 FFFF ?S?  0.274 + 3.0
+torsion    FFFF 0602 0602 FFFF ?T?  0.000 + 1.0
+torsion    FFFF 0602 0602 FFFF ?S?  0.000 + 1.0
+torsion    FFFF 0602 0601 FFFF ?S?  0.000 + 1.0
+torsion    FFFF 0602 0601 FFFF ?D?  0.000 + 1.0
+torsion    FFFF 0601 0601 FFFF ?D? 12.500 - 2.0
+torsion    FFFF 0601 0601 FFFF ?S?  1.424 - 2.0
+torsion    FFFF 0602 0600 FFFF ?S?  0.000 + 1.0
+torsion    FFFF 0601 0600 FFFF ?S?  0.120 - 3.0
+torsion    FFFF 0600 0600 FFFF ?S?  0.200 + 3.0
+torsion    FFFF 0602 0603 FFFF ?S?  0.000 + 1.0
+torsion    FFFF 0601 0603 FFFF ?S?  1.600 - 2.0
+torsion    FFFF 0600 0603 FFFF ?S?  0.120 - 3.0
+torsion    FFFF 0603 0603 FFFF ?C?  2.000 - 2.0
+torsion    FFFF 0603 0603 FFFF ?S?  0.600 - 2.0
+torsion    FFFF 0602 0701 FFFF ?S?  0.000 + 1.0
+torsion    FFFF 0602 0701 FFFF ?D?  0.000 + 1.0
+torsion    FFFF 0601 0701 FFFF ?D? 12.000 - 2.0
+torsion    FFFF 0601 0701 FFFF ?S? 12.000 - 2.0
+torsion    FFFF 0600 0701 FFFF ?S?  0.400 - 3.0
+torsion    FFFF 0603 0701 FFFF ?S?  1.600 - 2.0
+torsion    FFFF 0701 0701 FFFF ?D?  1.600 - 2.0
+torsion    FFFF 0701 0701 FFFF ?S?  1.600 - 2.0
+torsion    FFFF 0601 0700 FFFF ?S?  0.120 - 3.0
+torsion    FFFF 0600 0700 FFFF ?S?  0.200 + 3.0
+torsion    FFFF 0603 0700 FFFF ?S?  0.120 - 3.0
+torsion    FFFF 0700 0700 FFFF ?S?  0.200 + 3.0
+torsion    FFFF 0601 0705 FFFF ?S?  6.460 - 2.0
+torsion    FFFF 0600 0705 FFFF ?S?  0.200 + 3.0
+torsion    FFFF 0603 0705 FFFF ?S?  1.600 - 2.0
+torsion    FFFF 0701 0705 FFFF ?S?  1.600 - 2.0
+torsion    FFFF 0700 0705 FFFF ?S?  0.120 - 3.0
+torsion    FFFF 0705 0705 FFFF ?S?  1.600 - 2.0
+torsion    FFFF 0603 0703 FFFF ?C?  1.600 - 2.0
+torsion    FFFF 0601 0800 FFFF ?S?  5.800 - 2.0
+torsion    FFFF 0600 0800 FFFF ?S?  1.200 + 3.0
+torsion    FFFF 0603 0800 FFFF ?S?  1.200 - 2.0
+torsion    FFFF 0701 0800 FFFF ?S?  1.000 + 2.0
+torsion    FFFF 0700 0800 FFFF ?S?  0.200 + 3.0
+torsion    FFFF 0601 0F00 FFFF ?S?  1.000 - 2.0
+torsion    FFFF 0600 0F00 FFFF ?S?  0.400 + 3.0
+torsion    FFFF 0603 0F00 FFFF ?S?  1.000 + 3.0
+torsion    FFFF 0800 0F00 FFFF ?S?  0.400 + 3.0
+torsion    FFFF 0601 1001 FFFF ?D?  1.000 - 2.0
+torsion    FFFF 0600 1001 FFFF ?S?  0.400 + 3.0
+torsion    FFFF 0603 1001 FFFF ?S?  1.000 + 3.0
+torsion    FFFF 0700 1001 FFFF ?S?  0.400 + 3.0
+torsion    FFFF 0601 1000 FFFF ?S?  1.000 - 2.0
+torsion    FFFF 0600 1000 FFFF ?S?  0.400 + 3.0
+torsion    FFFF 0603 1000 FFFF ?S?  1.000 + 3.0
+torsion    FFFF 1000 1000 FFFF ?S?  4.000 + 3.0
 
 // lenjon-parameters 09.05.2000 (based on Tripos 5.2 and MMFF94)
 // [id] [r] [k]
 //
-// [r] = �
+// [r] = Å
 // [k] = kcal/mol
 
-vdw	0100 1.50 0.042
-vdw	0600 1.70 0.107
-vdw	0601 1.70 0.107
-vdw	0602 1.70 0.107
-vdw	0603 1.70 0.107
-vdw	0604 1.70 0.107
-vdw	0605 1.70 0.107
-vdw	0700 1.55 0.095
-vdw	0701 1.55 0.095
-vdw	0702 1.55 0.095
-vdw	0703 1.55 0.095
-vdw	0704 1.55 0.095
-vdw	0705 1.55 0.095
-vdw	0800 1.52 0.116
-vdw	0801 1.52 0.116
-vdw	0900 1.47 0.109
-vdw	0F00 1.80 0.314
-vdw	1000 1.80 0.314
-vdw	1001 1.80 0.314
-vdw	1002 1.80 0.314
-vdw	1003 1.80 0.314
-vdw	1100 1.75 0.314
-vdw	2300 1.85 0.434
-vdw	3500 1.98 0.623
-vdw	FFFF 1.50 0.042
+vdw    0100 1.50 0.042
+vdw    0600 1.70 0.107
+vdw    0601 1.70 0.107
+vdw    0602 1.70 0.107
+vdw    0603 1.70 0.107
+vdw    0604 1.70 0.107
+vdw    0605 1.70 0.107
+vdw    0700 1.55 0.095
+vdw    0701 1.55 0.095
+vdw    0702 1.55 0.095
+vdw    0703 1.55 0.095
+vdw    0704 1.55 0.095
+vdw    0705 1.55 0.095
+vdw    0800 1.52 0.116
+vdw    0801 1.52 0.116
+vdw    0900 1.47 0.109
+vdw    0F00 1.80 0.314
+vdw    1000 1.80 0.314
+vdw    1001 1.80 0.314
+vdw    1002 1.80 0.314
+vdw    1003 1.80 0.314
+vdw    1100 1.75 0.314
+vdw    2300 1.85 0.434
+vdw    3500 1.98 0.623
+vdw    FFFF 1.50 0.042
 
 // atomic charge parameters 09.05.2000 (based on Tripos 5.2 and MMFF94)
 // [id #1] [id #2] [delta]
Index: ringdecomposerlib-src/ringdecomposerlib/src/RingDecomposerLib/RingDecomposerLib.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ringdecomposerlib-src/ringdecomposerlib/src/RingDecomposerLib/RingDecomposerLib.h b/ringdecomposerlib-src/ringdecomposerlib/src/RingDecomposerLib/RingDecomposerLib.h
--- a/ringdecomposerlib-src/ringdecomposerlib/src/RingDecomposerLib/RingDecomposerLib.h	(revision 7b1629781cfb7fda29716d1af14a6110bb553892)
+++ b/ringdecomposerlib-src/ringdecomposerlib/src/RingDecomposerLib/RingDecomposerLib.h	(date 1690938866074)
@@ -27,13 +27,10 @@
 #ifndef RING_DECOMPOSER_LIB_H
 #define RING_DECOMPOSER_LIB_H
 
-#if (defined( _WIN32 ) && defined( _MSC_VER ) )
-    /* Win32 & MS VC ++ */
-    #define RDL_API __declspec(dllexport)
-#elif __GNUC__ >= 4 || defined(__clang__)
-    #define RDL_API __attribute__((visibility("default")))
-#else
-    #define RDL_API
+#include "ringdecomposerlib_export.h"
+
+#ifndef RDL_API
+#define RDL_API RINGDECOMPOSERLIB_EXPORT
 #endif
 
 #ifdef __cplusplus
Index: openbabel-src/openbabel/data/gaff.prm
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/data/gaff.prm b/openbabel-src/openbabel/data/gaff.prm
--- a/openbabel-src/openbabel/data/gaff.prm	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/data/gaff.prm	(date 1689124959089)
@@ -91,7 +91,7 @@
 atom [#6X3;R](=*)-*=*   						    ca "sp2 C in aromatic ring"
 atom [#6X3;R](=[#6X3])([#6])[#1]					    ca "sp2 C in aromatic ring"	
 atom [#6X3;R](=[#6])([#6])[F,Cl,Br,I]   				    c2 "sp2 C in a ring with 1 electron-withdrawal group"
-atom [#6X3;R](=[#6X3])([#6X4])[#6]					    c2 "sp2 C in a ring"		
+atom [#6X3;R](=[#6X3])([#6X4])[#6]					    c2 "sp2 C in a ring"
 atom [#6X3;R](=*)-*#*   						    cc "sp2 C in a conjugated ring"
 atom [#6X3;R](#*)-*#*   						    cc "sp2 C in a conjugated ring"
 atom [#6X3;R]:[#7,#8,#16]     	     	      				    cc "sp2 C in a ring with 1 electron-withdrawal group"
Index: indigo-src/indigo/api/c/indigo/src/indigo_tautomer_enumerator.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_tautomer_enumerator.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_tautomer_enumerator.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_tautomer_enumerator.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_tautomer_enumerator.cpp	(date 1690767117645)
@@ -19,7 +19,7 @@
 #include "indigo_tautomer_enumerator.h"
 #include "indigo_molecule.h"
 
-CEXPORT int indigoIterateTautomers(int molecule, const char* options)
+int indigoIterateTautomers(int molecule, const char* options)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_loaders.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_loaders.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_loaders.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_loaders.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_loaders.cpp	(date 1690767117645)
@@ -510,7 +510,7 @@
     return next();
 }
 
-CEXPORT int indigoIterateSDF(int reader)
+int indigoIterateSDF(int reader)
 {
     INDIGO_BEGIN
     {
@@ -521,7 +521,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateRDF(int reader)
+int indigoIterateRDF(int reader)
 {
     INDIGO_BEGIN
     {
@@ -532,7 +532,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateSmiles(int reader)
+int indigoIterateSmiles(int reader)
 {
     INDIGO_BEGIN
     {
@@ -543,7 +543,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoTell(int handle)
+int indigoTell(int handle)
 {
     INDIGO_BEGIN
     {
@@ -584,7 +584,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT long long indigoTell64(int handle)
+long long indigoTell64(int handle)
 {
     INDIGO_BEGIN
     {
@@ -617,7 +617,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateSDFile(const char* filename)
+int indigoIterateSDFile(const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -626,7 +626,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateRDFile(const char* filename)
+int indigoIterateRDFile(const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -635,7 +635,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateSmilesFile(const char* filename)
+int indigoIterateSmilesFile(const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -774,7 +774,7 @@
         return new IndigoCmlMolecule(loader->data, counter, offset);
 }
 
-CEXPORT int indigoIterateCML(int reader)
+int indigoIterateCML(int reader)
 {
     INDIGO_BEGIN
     {
@@ -785,7 +785,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateCMLFile(const char* filename)
+int indigoIterateCMLFile(const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -936,7 +936,7 @@
         return new IndigoCdxMolecule(loader->data, loader->properties, index, 0);
 }
 
-CEXPORT int indigoIterateCDX(int reader)
+int indigoIterateCDX(int reader)
 {
     INDIGO_BEGIN
     {
@@ -947,7 +947,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateCDXFile(const char* filename)
+int indigoIterateCDXFile(const char* filename)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/core/indigo-core/layout/src/molecule_layout_macrocycle_lattice.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/layout/src/molecule_layout_macrocycle_lattice.cpp b/indigo-src/indigo/core/indigo-core/layout/src/molecule_layout_macrocycle_lattice.cpp
--- a/indigo-src/indigo/core/indigo-core/layout/src/molecule_layout_macrocycle_lattice.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/core/indigo-core/layout/src/molecule_layout_macrocycle_lattice.cpp	(date 1689048275438)
@@ -395,12 +395,12 @@
     _BORDER.set_empty();
 }
 
-TriangleLattice::TriangleLattice(rectangle rec, int rem, byte* data_link)
+TriangleLattice::TriangleLattice(rectangle rec, int rem, ::byte* data_link)
 {
     init(rec, rem, data_link);
 }
 
-void TriangleLattice::init(rectangle rec, int rem, byte* data_link)
+void TriangleLattice::init(rectangle rec, int rem, ::byte* data_link)
 {
     _BORDER = rec;
 
@@ -617,7 +617,7 @@
 
     _hidden_data_field_array.clear_resize(global_size);
 
-    byte* free_area = _hidden_data_field_array.ptr();
+    ::byte* free_area = _hidden_data_field_array.ptr();
 
     _lattices.clear();
 
Index: indigo-src/indigo/api/c/bingo-nosql/src/bingo-nosql.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/bingo-nosql/src/bingo-nosql.cpp b/indigo-src/indigo/api/c/bingo-nosql/src/bingo-nosql.cpp
--- a/indigo-src/indigo/api/c/bingo-nosql/src/bingo-nosql.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/bingo-nosql/src/bingo-nosql.cpp	(date 1690767117641)
@@ -349,12 +349,12 @@
     auto matcher_ptr = sf::xlock_safe_ptr(searches_data->searches.at(id));                                                                                     \
     auto& matcher = **matcher_ptr;
 
-CEXPORT const char* bingoVersion()
+const char* bingoVersion()
 {
     return BINGO_VERSION;
 }
 
-CEXPORT int bingoCreateDatabaseFile(const char* location, const char* type, const char* options)
+int bingoCreateDatabaseFile(const char* location, const char* type, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -363,7 +363,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int bingoLoadDatabaseFile(const char* location, const char* options)
+int bingoLoadDatabaseFile(const char* location, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -372,7 +372,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int bingoCloseDatabase(int db)
+int bingoCloseDatabase(int db)
 {
 #ifdef INDIGO_DEBUG
     std::stringstream ss;
@@ -389,7 +389,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoInsertRecordObj(int db, int obj)
+int bingoInsertRecordObj(int db, int obj)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -414,7 +414,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoInsertIteratorObj(int db, int iterator_obj_id)
+int bingoInsertIteratorObj(int db, int iterator_obj_id)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -437,7 +437,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoInsertRecordObjWithId(int db, int obj, int id)
+int bingoInsertRecordObjWithId(int db, int obj, int id)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -447,7 +447,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoInsertRecordObjWithExtFP(int db, int obj, int fp)
+int bingoInsertRecordObjWithExtFP(int db, int obj, int fp)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -473,7 +473,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoInsertRecordObjWithIdAndExtFP(int db, int obj, int id, int fp)
+int bingoInsertRecordObjWithIdAndExtFP(int db, int obj, int id, int fp)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -484,7 +484,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoDeleteRecord(int db, int id)
+int bingoDeleteRecord(int db, int id)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -496,7 +496,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoGetRecordObj(int db, int id)
+int bingoGetRecordObj(int db, int id)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -538,7 +538,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoOptimize(int db)
+int bingoOptimize(int db)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -550,7 +550,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchSub(int db, int query_obj, const char* options)
+int bingoSearchSub(int db, int query_obj, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -601,7 +601,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchExact(int db, int query_obj, const char* options)
+int bingoSearchExact(int db, int query_obj, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -650,7 +650,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchMolFormula(int db, const char* query, const char* options)
+int bingoSearchMolFormula(int db, const char* query, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -674,7 +674,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchSim(int db, int query_obj, float min, float max, const char* options)
+int bingoSearchSim(int db, int query_obj, float min, float max, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -725,7 +725,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchSimWithExtFP(int db, int query_obj, float min, float max, int fp, const char* options)
+int bingoSearchSimWithExtFP(int db, int query_obj, float min, float max, int fp, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -777,7 +777,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchSimTopN(int db, int query_obj, int limit, float min, const char* options)
+int bingoSearchSimTopN(int db, int query_obj, int limit, float min, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -828,7 +828,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchSimTopNWithExtFP(int db, int query_obj, int limit, float min, int fp, const char* options)
+int bingoSearchSimTopNWithExtFP(int db, int query_obj, int limit, float min, int fp, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -880,7 +880,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoEnumerateId(int db)
+int bingoEnumerateId(int db)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -900,7 +900,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoEndSearch(int search_obj)
+int bingoEndSearch(int search_obj)
 {
 #ifdef INDIGO_DEBUG
     std::stringstream ss;
@@ -916,7 +916,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoNext(int search_obj)
+int bingoNext(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -926,7 +926,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoGetCurrentId(int search_obj)
+int bingoGetCurrentId(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -936,7 +936,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT float bingoGetCurrentSimilarityValue(int search_obj)
+float bingoGetCurrentSimilarityValue(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -946,7 +946,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoEstimateRemainingResultsCount(int search_obj)
+int bingoEstimateRemainingResultsCount(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -957,7 +957,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoContainersCount(int search_obj)
+int bingoContainersCount(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -967,7 +967,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoCellsCount(int search_obj)
+int bingoCellsCount(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -977,7 +977,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoCurrentCell(int search_obj)
+int bingoCurrentCell(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -987,7 +987,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoMinCell(int search_obj)
+int bingoMinCell(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -997,7 +997,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoMaxCell(int search_obj)
+int bingoMaxCell(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -1007,7 +1007,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoEstimateRemainingResultsCountError(int search_obj)
+int bingoEstimateRemainingResultsCountError(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -1019,7 +1019,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoEstimateRemainingTime(int search_obj, float* time_sec)
+int bingoEstimateRemainingTime(int search_obj, float* time_sec)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -1031,7 +1031,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoGetObject(int search_obj)
+int bingoGetObject(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -1042,7 +1042,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT const char* bingoProfilingGetStatistics(int for_session)
+const char* bingoProfilingGetStatistics(int for_session)
 {
     INDIGO_BEGIN
     {
Index: openbabel-src/openbabel/data/patty.rules
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/data/patty.rules b/openbabel-src/openbabel/data/patty.rules
--- a/openbabel-src/openbabel/data/patty.rules	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/data/patty.rules	(date 1689124959089)
@@ -133,7 +133,7 @@
 # diaminopyrimidine (ring Ns are POL)
 #
 #        *==*
-#       /    \  
+#       /    \
 #     :N      C--NH2            (aromatic)
 #      \\    #  
 #        C--N:
@@ -186,7 +186,7 @@
 [#8,#16,#34;D1]C=[#8,#16,#34]           ANI
 [#8,#16,#34]=C[#8,#16,#34;D1]           ANI
 #        *==*
-#       /    \  
+#       /    \
 #      *      C==O              (aromatic)
 #      \\    /
 #        C--C                   And 4 Cs away
Index: zlib-src/zlib/zconf.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/zlib-src/zlib/zconf.h b/zlib-src/zlib/zconf.h
--- a/zlib-src/zlib/zconf.h	(revision 04f42ceca40f73e2978b50e93806c2a18c1281fc)
+++ b/zlib-src/zlib/zconf.h	(date 1690938866074)
@@ -8,6 +8,7 @@
 #ifndef ZCONF_H
 #define ZCONF_H
 
+#include "zlib_export.h"
 /*
  * If you *really* need a unique prefix for all types and library functions,
  * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
@@ -330,63 +331,15 @@
 #    endif
 #  endif
 #endif
-
-#if defined(WINDOWS) || defined(WIN32)
-   /* If building or using zlib as a DLL, define ZLIB_DLL.
-    * This is not mandatory, but it offers a little performance increase.
-    */
-#  ifdef ZLIB_DLL
-#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
-#      ifdef ZLIB_INTERNAL
-#        define ZEXTERN extern __declspec(dllexport)
-#      else
-#        define ZEXTERN extern __declspec(dllimport)
-#      endif
-#    endif
-#  endif  /* ZLIB_DLL */
-   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
-    * define ZLIB_WINAPI.
-    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
-    */
-#  ifdef ZLIB_WINAPI
-#    ifdef FAR
-#      undef FAR
-#    endif
-#    ifndef WIN32_LEAN_AND_MEAN
-#      define WIN32_LEAN_AND_MEAN
-#    endif
-#    include <windows.h>
-     /* No need for _export, use ZLIB.DEF instead. */
-     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
-#    define ZEXPORT WINAPI
-#    ifdef WIN32
-#      define ZEXPORTVA WINAPIV
-#    else
-#      define ZEXPORTVA FAR CDECL
-#    endif
-#  endif
-#endif
-
-#if defined (__BEOS__)
-#  ifdef ZLIB_DLL
-#    ifdef ZLIB_INTERNAL
-#      define ZEXPORT   __declspec(dllexport)
-#      define ZEXPORTVA __declspec(dllexport)
-#    else
-#      define ZEXPORT   __declspec(dllimport)
-#      define ZEXPORTVA __declspec(dllimport)
-#    endif
-#  endif
-#endif
 
 #ifndef ZEXTERN
-#  define ZEXTERN extern
+#define ZEXTERN extern ZLIB_EXPORT
 #endif
 #ifndef ZEXPORT
-#  define ZEXPORT
+#define ZEXPORT
 #endif
 #ifndef ZEXPORTVA
-#  define ZEXPORTVA
+#define ZEXPORTVA
 #endif
 
 #ifndef FAR
Index: rdkit-src/rdkit/Code/GraphMol/FMCS/MaximumCommonSubgraph.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/FMCS/MaximumCommonSubgraph.cpp b/rdkit-src/rdkit/Code/GraphMol/FMCS/MaximumCommonSubgraph.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/FMCS/MaximumCommonSubgraph.cpp	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/GraphMol/FMCS/MaximumCommonSubgraph.cpp	(date 1689048276110)
@@ -348,7 +348,7 @@
          ms != matching_substructs.end(); ms++) {
       Seed seed;
       seed.ExcludedBonds = excludedBonds;
-      seed.MatchResult.resize(Targets.size());
+      seed.resizeMatchResult(Targets.size());
 #ifdef VERBOSE_STATISTICS_ON
       {
         ++VerboseStatistics.Seed;
@@ -417,7 +417,7 @@
       // if(excludedBonds[(*bi)->getIdx()])
       //    continue;
       Seed seed;
-      seed.MatchResult.resize(Targets.size());
+      seed.resizeMatchResult(Targets.size());
 
 #ifdef VERBOSE_STATISTICS_ON
       {
@@ -1266,7 +1266,7 @@
     { ++VerboseStatistics.MatchCall; }
 #endif
     bool target_matched = false;
-    if (!seed.MatchResult.empty() && !seed.MatchResult[itarget].empty()) {
+    if (!seed.MatchResult.empty() && !seed.MatchResult[itarget]->empty()) {
       target_matched = matchIncrementalFast(seed, itarget);
     }
     if (!target_matched) {  // slow full match
@@ -1277,11 +1277,11 @@
       // save current match info
       if (target_matched) {
         if (seed.MatchResult.empty()) {
-          seed.MatchResult.resize(Targets.size());
+          seed.resizeMatchResult(Targets.size());
         }
-        seed.MatchResult[itarget].init(seed, match, *QueryMolecule, *tag);
+        seed.MatchResult[itarget]->init(seed, match, *QueryMolecule, *tag);
       } else if (!seed.MatchResult.empty()) {
-        seed.MatchResult[itarget].clear();  //.Empty = true; // == fast clear();
+        seed.MatchResult[itarget]->clear();  //.Empty = true; // == fast clear();
       }
 #ifdef VERBOSE_STATISTICS_ON
       if (target_matched) {
@@ -1316,7 +1316,7 @@
   { ++VerboseStatistics.FastMatchCall; }
 #endif
   const Target& target = Targets[itarget];
-  TargetMatch& match = seed.MatchResult[itarget];
+  TargetMatch& match = *(seed.MatchResult[itarget]);
   if (match.empty()) {
     return false;
   }
Index: zlib-src/zlib/gzguts.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/zlib-src/zlib/gzguts.h b/zlib-src/zlib/gzguts.h
--- a/zlib-src/zlib/gzguts.h	(revision 04f42ceca40f73e2978b50e93806c2a18c1281fc)
+++ b/zlib-src/zlib/gzguts.h	(date 1689048276202)
@@ -37,6 +37,8 @@
 
 #if defined(__TURBOC__) || defined(_MSC_VER) || defined(_WIN32)
 #  include <io.h>
+#else
+#  include <unistd.h>
 #endif
 
 #if defined(_WIN32)
Index: rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.cpp b/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.cpp	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.cpp	(date 1689048276110)
@@ -19,6 +19,14 @@
 namespace RDKit {
 namespace FMCS {
 
+void Seed::resizeMatchResult(const std::size_t& size) {
+  MatchResult.clear();
+  MatchResult.resize(size);
+  for(auto&p : MatchResult) {
+    p = std::make_shared<TargetMatch>();
+  }
+}
+
 unsigned Seed::addAtom(const Atom* atom) {
   unsigned i = MoleculeFragment.AtomsIdx.size();
   unsigned aqi = atom->getIdx();
Index: openssl-src/openssl/crypto/buildinf.h.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openssl-src/openssl/crypto/buildinf.h.cmake b/openssl-src/openssl/crypto/buildinf.h.cmake
new file mode 100644
--- /dev/null	(date 1689048276014)
+++ b/openssl-src/openssl/crypto/buildinf.h.cmake	(date 1689048276014)
@@ -0,0 +1,6 @@
+/* auto-generated for crypto/cversion.c */
+#define CFLAGS "compiler: @CMAKE_C_COMPILER_ID@ @CMAKE_C_FLAGS@"
+#define PLATFORM "platform: @CMAKE_SYSTEM_NAME@"
+#define DATE "built on: @BUILDINF_DATE@"
+static const char *compiler_flags = CFLAGS;
+
Index: indigo-src/indigo/api/c/indigo/src/indigo_stereo.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_stereo.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_stereo.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_stereo.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_stereo.cpp	(date 1690767117645)
@@ -22,7 +22,7 @@
 #include "molecule/molecule_exact_matcher.h"
 #include "reaction/reaction.h"
 
-CEXPORT int indigoStereocenterType(int atom)
+int indigoStereocenterType(int atom)
 {
     INDIGO_BEGIN
     {
@@ -65,7 +65,7 @@
     }
 }
 
-CEXPORT int indigoStereocenterGroup(int atom)
+int indigoStereocenterGroup(int atom)
 {
     INDIGO_BEGIN
     {
@@ -79,7 +79,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetStereocenterGroup(int atom, int group)
+int indigoSetStereocenterGroup(int atom, int group)
 {
     INDIGO_BEGIN
     {
@@ -94,7 +94,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoChangeStereocenterType(int atom, int type)
+int indigoChangeStereocenterType(int atom, int type)
 {
     INDIGO_BEGIN
     {
@@ -113,7 +113,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddStereocenter(int atom, int type, int v1, int v2, int v3, int v4)
+int indigoAddStereocenter(int atom, int type, int v1, int v2, int v3, int v4)
 {
     INDIGO_BEGIN
     {
@@ -145,7 +145,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const int* indigoStereocenterPyramid(int atom)
+const int* indigoStereocenterPyramid(int atom)
 {
     INDIGO_BEGIN
     {
@@ -159,7 +159,7 @@
     INDIGO_END(NULL);
 }
 
-CEXPORT int indigoCountStereocenters(int molecule)
+int indigoCountStereocenters(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -170,7 +170,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearAlleneCenters(int molecule)
+int indigoClearAlleneCenters(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -182,7 +182,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountAlleneCenters(int molecule)
+int indigoCountAlleneCenters(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -193,7 +193,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoBondStereo(int bond)
+int indigoBondStereo(int bond)
 {
     INDIGO_BEGIN
     {
@@ -220,7 +220,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoInvertStereo(int item)
+int indigoInvertStereo(int item)
 {
     INDIGO_BEGIN
     {
@@ -261,7 +261,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetStereo(int item)
+int indigoResetStereo(int item)
 {
     INDIGO_BEGIN
     {
@@ -290,7 +290,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearStereocenters(int object)
+int indigoClearStereocenters(int object)
 {
     INDIGO_BEGIN
     {
@@ -319,7 +319,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearCisTrans(int object)
+int indigoClearCisTrans(int object)
 {
     INDIGO_BEGIN
     {
@@ -433,7 +433,7 @@
     return sum;
 }
 
-CEXPORT int indigoResetSymmetricCisTrans(int handle)
+int indigoResetSymmetricCisTrans(int handle)
 {
     INDIGO_BEGIN
     {
@@ -455,7 +455,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetSymmetricStereocenters(int handle)
+int indigoResetSymmetricStereocenters(int handle)
 {
     INDIGO_BEGIN
     {
@@ -477,7 +477,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoMarkEitherCisTrans(int handle)
+int indigoMarkEitherCisTrans(int handle)
 {
     INDIGO_BEGIN
     {
@@ -499,7 +499,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoMarkStereobonds(int handle)
+int indigoMarkStereobonds(int handle)
 {
     INDIGO_BEGIN
     {
@@ -552,7 +552,7 @@
     }
 }
 
-CEXPORT int indigoValidateChirality(int handle)
+int indigoValidateChirality(int handle)
 {
     INDIGO_BEGIN
     {
Index: openbabel-src/openbabel/include/openbabel/obutil.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/obutil.h b/openbabel-src/openbabel/include/openbabel/obutil.h
--- a/openbabel-src/openbabel/include/openbabel/obutil.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/obutil.h	(date 1689048275862)
@@ -24,6 +24,7 @@
 
 #include <string>
 #include <iosfwd>
+#include <fstream>
 
 #if TIME_WITH_SYS_TIME
 #include <sys/time.h>
Index: indigo-src/indigo/api/c/indigo/src/indigo.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo.cpp b/indigo-src/indigo/api/c/indigo/src/indigo.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo.cpp	(date 1690797473226)
@@ -41,12 +41,12 @@
 
 static _SessionLocalContainer<Indigo> indigo_self;
 
-DLLEXPORT Indigo& indigoGetInstance()
+Indigo& indigoGetInstance()
 {
     return indigo_self.getLocalCopy();
 }
 
-CEXPORT const char* indigoVersion()
+const char* indigoVersion()
 {
     return INDIGO_VERSION "-" INDIGO_PLATFORM;
 }
@@ -257,7 +257,7 @@
     };
 }
 
-CEXPORT qword indigoAllocSessionId()
+qword indigoAllocSessionId()
 {
     qword id = TL_ALLOC_SESSION_ID();
     TL_SET_SESSION_ID(id);
@@ -275,12 +275,12 @@
     return id;
 }
 
-CEXPORT void indigoSetSessionId(qword id)
+void indigoSetSessionId(qword id)
 {
     TL_SET_SESSION_ID(id);
 }
 
-CEXPORT void indigoReleaseSessionId(qword id)
+void indigoReleaseSessionId(qword id)
 {
     TL_SET_SESSION_ID(id);
     indigoGetInstance().removeAllObjects();
@@ -294,17 +294,17 @@
 #endif
 }
 
-CEXPORT const char* indigoGetLastError(void)
+const char* indigoGetLastError(void)
 {
     return Indigo::getErrorMessage().ptr();
 }
 
-CEXPORT void indigoSetErrorHandler(INDIGO_ERROR_HANDLER handler, void* context)
+void indigoSetErrorHandler(INDIGO_ERROR_HANDLER handler, void* context)
 {
     Indigo::setErrorHandler(handler, context);
 }
 
-CEXPORT int indigoFree(int handle)
+int indigoFree(int handle)
 {
     // In some runtimes (e.g. Python) session could be removed before objects during resource releasing stage)
     if (indigo_self.hasLocalCopy())
@@ -321,13 +321,13 @@
     return 1;
 }
 
-CEXPORT int indigoFreeAllObjects()
+int indigoFreeAllObjects()
 {
     indigoGetInstance().removeAllObjects();
     return 1;
 }
 
-CEXPORT int indigoCountReferences(void)
+int indigoCountReferences(void)
 {
     INDIGO_BEGIN
     {
@@ -336,7 +336,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT void indigoSetErrorMessage(const char* message)
+void indigoSetErrorMessage(const char* message)
 {
     Indigo& self = indigoGetInstance();
     self.setErrorMessage(message);
@@ -456,9 +456,9 @@
 // Debug methods
 //
 
-#ifdef _WIN32
+#if defined(_WIN32) && !defined(__MINGW32__)
 #include <Windows.h>
-#elif defined(__linux__)
+#elif defined(__linux__) || defined(__MINGW32__)
 #include <fcntl.h>
 #include <unistd.h>
 #elif defined(__APPLE__)
@@ -472,7 +472,7 @@
 {
     void sleepMs(int ms)
     {
-#ifdef _WIN32
+#if defined(_WIN32) && !defined(__MINGW32__)
         Sleep(ms);
 #else
         sleep(ms * 1e-3);
@@ -481,7 +481,7 @@
 
     bool debuggerIsAttached()
     {
-#ifdef _WIN32
+#if defined(_WIN32) && !defined(__MINGW32__)
         return IsDebuggerPresent();
 #elif defined(__APPLE__)
         int mib[4];
@@ -514,9 +514,9 @@
     }
 }
 
-CEXPORT void indigoDbgBreakpoint(void)
+void indigoDbgBreakpoint(void)
 {
-#ifdef _WIN32
+#if defined(_WIN32) && !defined(__MINGW32__)
     if (!IsDebuggerPresent())
     {
         char msg[200];
@@ -539,7 +539,7 @@
 #endif
 }
 
-CEXPORT const char* indigoDbgProfiling(int whole_session)
+const char* indigoDbgProfiling(int whole_session)
 {
     INDIGO_BEGIN
     {
@@ -553,7 +553,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoDbgResetProfiling(int whole_session)
+int indigoDbgResetProfiling(int whole_session)
 {
     INDIGO_BEGIN
     {
@@ -567,7 +567,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT qword indigoDbgProfilingGetCounter(const char* name, int whole_session)
+qword indigoDbgProfilingGetCounter(const char* name, int whole_session)
 {
     INDIGO_BEGIN
     {
Index: rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/MolDraw2DQt.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/MolDraw2DQt.h b/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/MolDraw2DQt.h
--- a/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/MolDraw2DQt.h	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/MolDraw2DQt.h	(date 1689048276126)
@@ -10,10 +10,10 @@
 // This is a concrete class derived from MolDraw2D that uses RDKit to draw a
 // molecule into a QPainter.
 
-#include <RDGeneral/export.h>
 #ifndef MOLDRAW2DQT_H
 #define MOLDRAW2DQT_H
-
+#include <RDGeneral/export.h>
+#include <MolDraw2DQt/rdkit_export.hpp>
 #include <GraphMol/MolDraw2D/MolDraw2D.h>
 
 class QPainter;
Index: rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/DrawTextQt.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/DrawTextQt.h b/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/DrawTextQt.h
--- a/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/DrawTextQt.h	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/DrawTextQt.h	(date 1689048276126)
@@ -11,6 +11,7 @@
 #define RDKIT_DRAWTEXTQT_H
 
 #include <RDGeneral/export.h>
+#include <MolDraw2DQt/rdkit_export.hpp>
 #include <GraphMol/MolDraw2D/DrawTextNotFT.h>
 
 class QPainter;
Index: boost-src/boost/libs/stacktrace/src/noop.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/stacktrace/src/noop.cpp b/boost-src/boost/libs/stacktrace/src/noop.cpp
--- a/boost-src/boost/libs/stacktrace/src/noop.cpp	(revision 95065ca63883c0b1d6754bdb7bb106058c7532cb)
+++ b/boost-src/boost/libs/stacktrace/src/noop.cpp	(date 1689048275230)
@@ -6,6 +6,8 @@
 
 #define BOOST_STACKTRACE_INTERNAL_BUILD_LIBS
 #define BOOST_STACKTRACE_LINK
+#ifndef BOOST_STACKTRACE_USE_NOOP
 #define BOOST_STACKTRACE_USE_NOOP
+#endif
 #include <boost/stacktrace/detail/frame_noop.ipp>
 #include <boost/stacktrace/detail/safe_dump_noop.ipp>
Index: protobuf-src/protobuf/third_party/utf8_range/range2-sse.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/protobuf-src/protobuf/third_party/utf8_range/range2-sse.c b/protobuf-src/protobuf/third_party/utf8_range/range2-sse.c
--- a/protobuf-src/protobuf/third_party/utf8_range/range2-sse.c	(revision 4dd15db6eb3955745f379d28fb4a2fcfb6753de3)
+++ b/protobuf-src/protobuf/third_party/utf8_range/range2-sse.c	(date 1689048276090)
@@ -6,7 +6,7 @@
 
 #include <stdio.h>
 #include <stdint.h>
-#include <x86intrin.h>
+#include <smmintrin.h>
 
 int utf8_naive(const unsigned char *data, int len);
 
Index: libpng-src/libpng/pngwtran.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/pngwtran.c b/libpng-src/libpng/pngwtran.c
--- a/libpng-src/libpng/pngwtran.c	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/pngwtran.c	(date 1690795574122)
@@ -1,10 +1,10 @@
 
 /* pngwtran.c - transforms the data in a row for PNG writers
  *
- * Last changed in libpng 1.6.24 [August 4, 2016]
- * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ * Copyright (c) 2018 Cosmin Truta
+ * Copyright (c) 1998-2002,2004,2006-2016,2018 Glenn Randers-Pehrson
+ * Copyright (c) 1996-1997 Andreas Dilger
+ * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
@@ -177,7 +177,7 @@
    if (row_info->color_type != PNG_COLOR_TYPE_PALETTE)
    {
       int shift_start[4], shift_dec[4];
-      int channels = 0;
+      unsigned int channels = 0;
 
       if ((row_info->color_type & PNG_COLOR_MASK_COLOR) != 0)
       {
@@ -212,9 +212,9 @@
       if (row_info->bit_depth < 8)
       {
          png_bytep bp = row;
-         png_size_t i;
+         size_t i;
          unsigned int mask;
-         png_size_t row_bytes = row_info->rowbytes;
+         size_t row_bytes = row_info->rowbytes;
 
          if (bit_depth->gray == 1 && row_info->bit_depth == 2)
             mask = 0x55;
@@ -254,8 +254,7 @@
 
          for (i = 0; i < istop; i++, bp++)
          {
-
-            const unsigned int c = i%channels;
+            unsigned int c = i%channels;
             int j;
             unsigned int v, out;
 
@@ -283,7 +282,7 @@
 
          for (bp = row, i = 0; i < istop; i++)
          {
-            const unsigned int c = i%channels;
+            unsigned int c = i%channels;
             int j;
             unsigned int value, v;
 
@@ -514,7 +513,7 @@
              (png_ptr,  /* png_ptr */
              row_info,  /* row_info: */
                 /*  png_uint_32 width;       width of row */
-                /*  png_size_t rowbytes;     number of bytes in row */
+                /*  size_t rowbytes;         number of bytes in row */
                 /*  png_byte color_type;     color type of pixels */
                 /*  png_byte bit_depth;      bit depth of samples */
                 /*  png_byte channels;       number of channels (1-4) */
Index: indigo-src/indigo/api/c/indigo/src/indigo_io.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_io.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_io.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_io.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_io.cpp	(date 1690767117645)
@@ -86,7 +86,7 @@
     throw IndigoError("%s is not an output", obj.debugInfo());
 }
 
-CEXPORT int indigoReadFile(const char* filename)
+int indigoReadFile(const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -95,7 +95,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoReadString(const char* str)
+int indigoReadString(const char* str)
 {
     INDIGO_BEGIN
     {
@@ -104,7 +104,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoReadBuffer(const char* buffer, int size)
+int indigoReadBuffer(const char* buffer, int size)
 {
     INDIGO_BEGIN
     {
@@ -113,7 +113,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadString(const char* str)
+int indigoLoadString(const char* str)
 {
     INDIGO_BEGIN
     {
@@ -122,7 +122,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadBuffer(const char* buffer, int size)
+int indigoLoadBuffer(const char* buffer, int size)
 {
     INDIGO_BEGIN
     {
@@ -131,7 +131,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoWriteFile(const char* filename)
+int indigoWriteFile(const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -140,7 +140,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClose(int output)
+int indigoClose(int output)
 {
     INDIGO_BEGIN
     {
@@ -163,7 +163,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoWriteBuffer(void)
+int indigoWriteBuffer(void)
 {
     INDIGO_BEGIN
     {
@@ -172,7 +172,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoToString(int handle)
+const char* indigoToString(int handle)
 {
     INDIGO_BEGIN
     {
@@ -187,7 +187,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoToBase64String(int handle)
+const char* indigoToBase64String(int handle)
 {
     INDIGO_BEGIN
     {
@@ -200,7 +200,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoToBuffer(int handle, char** buf, int* size)
+int indigoToBuffer(int handle, char** buf, int* size)
 {
     INDIGO_BEGIN
     {
Index: libpng-src/libpng/pngmem.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/pngmem.c b/libpng-src/libpng/pngmem.c
--- a/libpng-src/libpng/pngmem.c	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/pngmem.c	(date 1690795574122)
@@ -1,10 +1,10 @@
 
 /* pngmem.c - stub functions for memory allocation
  *
- * Last changed in libpng 1.6.24 [August 4, 2016%]
+ * Copyright (c) 2018 Cosmin Truta
  * Copyright (c) 1998-2002,2004,2006-2014,2016 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ * Copyright (c) 1996-1997 Andreas Dilger
+ * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
@@ -109,7 +109,7 @@
 png_malloc_array_checked(png_const_structrp png_ptr, int nelements,
     size_t element_size)
 {
-   png_alloc_size_t req = nelements; /* known to be > 0 */
+   png_alloc_size_t req = (png_alloc_size_t)nelements; /* known to be > 0 */
 
    if (req <= PNG_SIZE_MAX/element_size)
       return png_malloc_base(png_ptr, req * element_size);
Index: rdkit-src/rdkit/Code/GraphMol/Descriptors/MORSE.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/Descriptors/MORSE.cpp b/rdkit-src/rdkit/Code/GraphMol/Descriptors/MORSE.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/Descriptors/MORSE.cpp	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/GraphMol/Descriptors/MORSE.cpp	(date 1689048276110)
@@ -115,6 +115,7 @@
     R7[i] = std::round(1000 * res7) / 1000;
   }
 
+  R1.reserve(R1.size() + R2.size() + R3.size() + R4.size() + R5.size() + R6.size() + R7.size());
   R1.insert(R1.end(), R2.begin(), R2.end());
   R1.insert(R1.end(), R3.begin(), R3.end());
   R1.insert(R1.end(), R4.begin(), R4.end());
Index: libpng-src/libpng/pngwrite.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/pngwrite.c b/libpng-src/libpng/pngwrite.c
--- a/libpng-src/libpng/pngwrite.c	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/pngwrite.c	(date 1690795574122)
@@ -1,10 +1,10 @@
 
 /* pngwrite.c - general routines to write a PNG file
  *
- * Last changed in libpng 1.6.24 [August 4, 2016]
- * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ * Copyright (c) 2018-2023 Cosmin Truta
+ * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson
+ * Copyright (c) 1996-1997 Andreas Dilger
+ * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
@@ -75,10 +75,10 @@
  * library.  If you have a new chunk to add, make a function to write it,
  * and put it in the correct location here.  If you want the chunk written
  * after the image data, put it in png_write_end().  I strongly encourage
- * you to supply a PNG_INFO_ flag, and check info_ptr->valid before writing
- * the chunk, as that will keep the code from breaking if you want to just
- * write a plain PNG file.  If you have long comments, I suggest writing
- * them in png_write_end(), and compressing them.
+ * you to supply a PNG_INFO_<chunk> flag, and check info_ptr->valid before
+ * writing the chunk, as that will keep the code from breaking if you want
+ * to just write a plain PNG file.  If you have long comments, I suggest
+ * writing them in png_write_end(), and compressing them.
  */
 void PNGAPI
 png_write_info_before_PLTE(png_structrp png_ptr, png_const_inforp info_ptr)
@@ -236,6 +236,14 @@
    if ((info_ptr->valid & PNG_INFO_bKGD) != 0)
       png_write_bKGD(png_ptr, &(info_ptr->background), info_ptr->color_type);
 #endif
+
+#ifdef PNG_WRITE_eXIf_SUPPORTED
+   if ((info_ptr->valid & PNG_INFO_eXIf) != 0)
+   {
+      png_write_eXIf(png_ptr, info_ptr->exif, info_ptr->num_exif);
+      png_ptr->mode |= PNG_WROTE_eXIf;
+   }
+#endif
 
 #ifdef PNG_WRITE_hIST_SUPPORTED
    if ((info_ptr->valid & PNG_INFO_hIST) != 0)
@@ -431,7 +439,14 @@
 #endif
          }
       }
+#endif
+
+#ifdef PNG_WRITE_eXIf_SUPPORTED
+      if ((info_ptr->valid & PNG_INFO_eXIf) != 0 &&
+          (png_ptr->mode & PNG_WROTE_eXIf) == 0)
+         png_write_eXIf(png_ptr, info_ptr->exif, info_ptr->num_exif);
 #endif
+
 #ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
       write_unknown_chunks(png_ptr, info_ptr, PNG_AFTER_IDAT);
 #endif
@@ -458,7 +473,7 @@
 
 #ifdef PNG_CONVERT_tIME_SUPPORTED
 void PNGAPI
-png_convert_from_struct_tm(png_timep ptime, PNG_CONST struct tm * ttime)
+png_convert_from_struct_tm(png_timep ptime, const struct tm * ttime)
 {
    png_debug(1, "in png_convert_from_struct_tm");
 
@@ -478,6 +493,16 @@
    png_debug(1, "in png_convert_from_time_t");
 
    tbuf = gmtime(&ttime);
+   if (tbuf == NULL)
+   {
+      /* TODO: add a safe function which takes a png_ptr argument and raises
+       * a png_error if the ttime argument is invalid and the call to gmtime
+       * fails as a consequence.
+       */
+      memset(ptime, 0, sizeof(*ptime));
+      return;
+   }
+
    png_convert_from_struct_tm(ptime, tbuf);
 }
 #endif
@@ -666,9 +691,9 @@
 
          for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
          {
-            png_uint_32 s0   = (*(rp    ) << 8) | *(rp + 1);
-            png_uint_32 s1   = (*(rp + 2) << 8) | *(rp + 3);
-            png_uint_32 s2   = (*(rp + 4) << 8) | *(rp + 5);
+            png_uint_32 s0   = (png_uint_32)(*(rp    ) << 8) | *(rp + 1);
+            png_uint_32 s1   = (png_uint_32)(*(rp + 2) << 8) | *(rp + 3);
+            png_uint_32 s2   = (png_uint_32)(*(rp + 4) << 8) | *(rp + 5);
             png_uint_32 red  = (png_uint_32)((s0 - s1) & 0xffffL);
             png_uint_32 blue = (png_uint_32)((s2 - s1) & 0xffffL);
             *(rp    ) = (png_byte)(red >> 8);
@@ -901,7 +926,7 @@
    if (png_ptr == NULL)
       return;
 
-   png_ptr->flush_dist = (nrows < 0 ? 0 : nrows);
+   png_ptr->flush_dist = (nrows < 0 ? 0 : (png_uint_32)nrows);
 }
 
 /* Flush the current output buffers now */
@@ -1007,8 +1032,8 @@
          case 5:
          case 6:
          case 7: png_app_error(png_ptr, "Unknown row filter for method 0");
-            /* FALL THROUGH */
 #endif /* WRITE_FILTER */
+            /* FALLTHROUGH */
          case PNG_FILTER_VALUE_NONE:
             png_ptr->do_filter = PNG_FILTER_NONE; break;
 
@@ -1525,7 +1550,8 @@
        display->first_row);
    png_uint_16p output_row = png_voidcast(png_uint_16p, display->local_row);
    png_uint_16p row_end;
-   const int channels = (image->format & PNG_FORMAT_FLAG_COLOR) != 0 ? 3 : 1;
+   unsigned int channels = (image->format & PNG_FORMAT_FLAG_COLOR) != 0 ?
+       3 : 1;
    int aindex = 0;
    png_uint_32 y = image->height;
 
@@ -1539,9 +1565,9 @@
          ++output_row;
       }
          else
-            aindex = channels;
+            aindex = (int)channels;
 #     else
-         aindex = channels;
+         aindex = (int)channels;
 #     endif
    }
 
@@ -1554,14 +1580,14 @@
     */
    row_end = output_row + image->width * (channels+1);
 
-   while (y-- > 0)
+   for (; y > 0; --y)
    {
       png_const_uint_16p in_ptr = input_row;
       png_uint_16p out_ptr = output_row;
 
       while (out_ptr < row_end)
       {
-         const png_uint_16 alpha = in_ptr[aindex];
+         png_uint_16 alpha = in_ptr[aindex];
          png_uint_32 reciprocal = 0;
          int c;
 
@@ -1575,7 +1601,7 @@
          if (alpha > 0 && alpha < 65535)
             reciprocal = ((0xffff<<15)+(alpha>>1))/alpha;
 
-         c = channels;
+         c = (int)channels;
          do /* always at least one channel */
          {
             png_uint_16 component = *in_ptr++;
@@ -1610,7 +1636,7 @@
       }
 
       png_write_row(png_ptr, png_voidcast(png_const_bytep, display->local_row));
-      input_row += display->row_bytes/(sizeof (png_uint_16));
+      input_row += (png_uint_16)display->row_bytes/(sizeof (png_uint_16));
    }
 
    return 1;
@@ -1624,7 +1650,7 @@
  * calculation can be done to 15 bits of accuracy; however, the output needs to
  * be scaled in the range 0..255*65535, so include that scaling here.
  */
-#   define UNP_RECIPROCAL(alpha) ((((0xffff*0xff)<<7)+(alpha>>1))/alpha)
+#   define UNP_RECIPROCAL(alpha) ((((0xffff*0xff)<<7)+((alpha)>>1))/(alpha))
 
 static png_byte
 png_unpremultiply(png_uint_32 component, png_uint_32 alpha,
@@ -1683,7 +1709,8 @@
        display->first_row);
    png_bytep output_row = png_voidcast(png_bytep, display->local_row);
    png_uint_32 y = image->height;
-   const int channels = (image->format & PNG_FORMAT_FLAG_COLOR) != 0 ? 3 : 1;
+   unsigned int channels = (image->format & PNG_FORMAT_FLAG_COLOR) != 0 ?
+       3 : 1;
 
    if ((image->format & PNG_FORMAT_FLAG_ALPHA) != 0)
    {
@@ -1700,12 +1727,12 @@
 
       else
 #   endif
-      aindex = channels;
+      aindex = (int)channels;
 
       /* Use row_end in place of a loop counter: */
       row_end = output_row + image->width * (channels+1);
 
-      while (y-- > 0)
+      for (; y > 0; --y)
       {
          png_const_uint_16p in_ptr = input_row;
          png_bytep out_ptr = output_row;
@@ -1723,7 +1750,7 @@
             if (alphabyte > 0 && alphabyte < 255)
                reciprocal = UNP_RECIPROCAL(alpha);
 
-            c = channels;
+            c = (int)channels;
             do /* always at least one channel */
                *out_ptr++ = png_unpremultiply(*in_ptr++, alpha, reciprocal);
             while (--c > 0);
@@ -1735,7 +1762,7 @@
 
          png_write_row(png_ptr, png_voidcast(png_const_bytep,
              display->local_row));
-         input_row += display->row_bytes/(sizeof (png_uint_16));
+         input_row += (png_uint_16)display->row_bytes/(sizeof (png_uint_16));
       } /* while y */
    }
 
@@ -1746,7 +1773,7 @@
        */
       png_bytep row_end = output_row + image->width * channels;
 
-      while (y-- > 0)
+      for (; y > 0; --y)
       {
          png_const_uint_16p in_ptr = input_row;
          png_bytep out_ptr = output_row;
@@ -1760,7 +1787,7 @@
          }
 
          png_write_row(png_ptr, output_row);
-         input_row += display->row_bytes/(sizeof (png_uint_16));
+         input_row += (png_uint_16)display->row_bytes/(sizeof (png_uint_16));
       }
    }
 
@@ -1770,25 +1797,25 @@
 static void
 png_image_set_PLTE(png_image_write_control *display)
 {
-   const png_imagep image = display->image;
+   png_imagep image = display->image;
    const void *cmap = display->colormap;
-   const int entries = image->colormap_entries > 256 ? 256 :
+   int entries = image->colormap_entries > 256 ? 256 :
        (int)image->colormap_entries;
 
    /* NOTE: the caller must check for cmap != NULL and entries != 0 */
-   const png_uint_32 format = image->format;
-   const int channels = PNG_IMAGE_SAMPLE_CHANNELS(format);
+   png_uint_32 format = image->format;
+   unsigned int channels = PNG_IMAGE_SAMPLE_CHANNELS(format);
 
 #   if defined(PNG_FORMAT_BGR_SUPPORTED) &&\
       defined(PNG_SIMPLIFIED_WRITE_AFIRST_SUPPORTED)
-      const int afirst = (format & PNG_FORMAT_FLAG_AFIRST) != 0 &&
+      int afirst = (format & PNG_FORMAT_FLAG_AFIRST) != 0 &&
           (format & PNG_FORMAT_FLAG_ALPHA) != 0;
 #   else
 #     define afirst 0
 #   endif
 
 #   ifdef PNG_FORMAT_BGR_SUPPORTED
-      const int bgr = (format & PNG_FORMAT_FLAG_BGR) != 0 ? 2 : 0;
+      int bgr = (format & PNG_FORMAT_FLAG_BGR) != 0 ? 2 : 0;
 #   else
 #     define bgr 0
 #   endif
@@ -1809,7 +1836,7 @@
       {
          png_const_uint_16p entry = png_voidcast(png_const_uint_16p, cmap);
 
-         entry += i * channels;
+         entry += (unsigned int)i * channels;
 
          if ((channels & 1) != 0) /* no alpha */
          {
@@ -1865,7 +1892,7 @@
       {
          png_const_bytep entry = png_voidcast(png_const_bytep, cmap);
 
-         entry += i * channels;
+         entry += (unsigned int)i * channels;
 
          switch (channels)
          {
@@ -1873,7 +1900,7 @@
                tRNS[i] = entry[afirst ? 0 : 3];
                if (tRNS[i] < 255)
                   num_trans = i+1;
-               /* FALL THROUGH */
+               /* FALLTHROUGH */
             case 3:
                palette[i].blue = entry[afirst + (2 ^ bgr)];
                palette[i].green = entry[afirst + 1];
@@ -1884,7 +1911,7 @@
                tRNS[i] = entry[1 ^ afirst];
                if (tRNS[i] < 255)
                   num_trans = i+1;
-               /* FALL THROUGH */
+               /* FALLTHROUGH */
             case 1:
                palette[i].blue = palette[i].red = palette[i].green =
                   entry[afirst];
@@ -1910,7 +1937,7 @@
       png_set_tRNS(image->opaque->png_ptr, image->opaque->info_ptr, tRNS,
           num_trans, NULL);
 
-   image->colormap_entries = entries;
+   image->colormap_entries = (png_uint_32)entries;
 }
 
 static int
@@ -1927,7 +1954,7 @@
    int colormap = (format & PNG_FORMAT_FLAG_COLORMAP);
    int linear = !colormap && (format & PNG_FORMAT_FLAG_LINEAR); /* input */
    int alpha = !colormap && (format & PNG_FORMAT_FLAG_ALPHA);
-   int write_16bit = linear && !colormap && (display->convert_to_8bit == 0);
+   int write_16bit = linear && (display->convert_to_8bit == 0);
 
 #   ifdef PNG_BENIGN_ERRORS_SUPPORTED
       /* Make sure we error out on any bad situation */
@@ -1938,21 +1965,21 @@
     * and total image size to ensure that they are within the system limits.
     */
    {
-      const unsigned int channels = PNG_IMAGE_PIXEL_CHANNELS(image->format);
+      unsigned int channels = PNG_IMAGE_PIXEL_CHANNELS(image->format);
 
-      if (image->width <= 0x7FFFFFFFU/channels) /* no overflow */
+      if (image->width <= 0x7fffffffU/channels) /* no overflow */
       {
          png_uint_32 check;
-         const png_uint_32 png_row_stride = image->width * channels;
+         png_uint_32 png_row_stride = image->width * channels;
 
          if (display->row_stride == 0)
             display->row_stride = (png_int_32)/*SAFE*/png_row_stride;
 
          if (display->row_stride < 0)
-            check = -display->row_stride;
+            check = (png_uint_32)(-display->row_stride);
 
          else
-            check = display->row_stride;
+            check = (png_uint_32)display->row_stride;
 
          if (check >= png_row_stride)
          {
@@ -1960,7 +1987,7 @@
              * limits the whole image size to 32 bits for API compatibility with
              * the current, 32-bit, PNG_IMAGE_BUFFER_SIZE macro.
              */
-            if (image->height > 0xFFFFFFFF/png_row_stride)
+            if (image->height > 0xffffffffU/png_row_stride)
                png_error(image->opaque->png_ptr, "memory image too large");
          }
 
@@ -2039,7 +2066,7 @@
     */
    if (write_16bit != 0)
    {
-      PNG_CONST png_uint_16 le = 0x0001;
+      png_uint_16 le = 0x0001;
 
       if ((*(png_const_bytep) & le) != 0)
          png_set_swap(png_ptr);
@@ -2136,7 +2163,7 @@
       ptrdiff_t row_bytes = display->row_bytes;
       png_uint_32 y = image->height;
 
-      while (y-- > 0)
+      for (; y > 0; --y)
       {
          png_write_row(png_ptr, row);
          row += row_bytes;
@@ -2149,12 +2176,11 @@
 
 
 static void (PNGCBAPI
-image_memory_write)(png_structp png_ptr, png_bytep/*const*/ data,
-    png_size_t size)
+image_memory_write)(png_structp png_ptr, png_bytep/*const*/ data, size_t size)
 {
    png_image_write_control *display = png_voidcast(png_image_write_control*,
        png_ptr->io_ptr/*backdoor: png_get_io_ptr(png_ptr)*/);
-   const png_alloc_size_t ob = display->output_bytes;
+   png_alloc_size_t ob = display->output_bytes;
 
    /* Check for overflow; this should never happen: */
    if (size <= ((png_alloc_size_t)-1) - ob)
Index: libpng-src/libpng/pngwutil.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/pngwutil.c b/libpng-src/libpng/pngwutil.c
--- a/libpng-src/libpng/pngwutil.c	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/pngwutil.c	(date 1690795574122)
@@ -1,10 +1,10 @@
 
 /* pngwutil.c - utilities to write a PNG file
  *
- * Last changed in libpng 1.6.24 [August 4, 2016]
- * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ * Copyright (c) 2018-2022 Cosmin Truta
+ * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson
+ * Copyright (c) 1996-1997 Andreas Dilger
+ * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
@@ -59,7 +59,7 @@
 
    /* Write the rest of the 8 byte signature */
    png_write_data(png_ptr, &png_signature[png_ptr->sig_bytes],
-       (png_size_t)(8 - png_ptr->sig_bytes));
+       (size_t)(8 - png_ptr->sig_bytes));
 
    if (png_ptr->sig_bytes < 3)
       png_ptr->mode |= PNG_HAVE_PNG_SIGNATURE;
@@ -124,8 +124,7 @@
  * given to png_write_chunk_header().
  */
 void PNGAPI
-png_write_chunk_data(png_structrp png_ptr, png_const_bytep data,
-    png_size_t length)
+png_write_chunk_data(png_structrp png_ptr, png_const_bytep data, size_t length)
 {
    /* Write the data, and run the CRC over it */
    if (png_ptr == NULL)
@@ -160,7 +159,7 @@
    /* Write the crc in a single operation */
    png_save_uint_32(buf, png_ptr->crc);
 
-   png_write_data(png_ptr, buf, (png_size_t)4);
+   png_write_data(png_ptr, buf, 4);
 }
 
 /* Write a PNG chunk all at once.  The type is an array of ASCII characters
@@ -174,7 +173,7 @@
  */
 static void
 png_write_complete_chunk(png_structrp png_ptr, png_uint_32 chunk_name,
-    png_const_bytep data, png_size_t length)
+    png_const_bytep data, size_t length)
 {
    if (png_ptr == NULL)
       return;
@@ -191,7 +190,7 @@
 /* This is the API that calls the internal function above. */
 void PNGAPI
 png_write_chunk(png_structrp png_ptr, png_const_bytep chunk_string,
-    png_const_bytep data, png_size_t length)
+    png_const_bytep data, size_t length)
 {
    png_write_complete_chunk(png_ptr, PNG_CHUNK_FROM_STRING(chunk_string), data,
        length);
@@ -408,7 +407,7 @@
       png_ptr->zstream.avail_out = 0;
 
       /* Now initialize if required, setting the new parameters, otherwise just
-       * to a simple reset to the previous parameters.
+       * do a simple reset to the previous parameters.
        */
       if ((png_ptr->flags & PNG_FLAG_ZSTREAM_INITIALIZED) != 0)
          ret = deflateReset(&png_ptr->zstream);
@@ -675,6 +674,7 @@
     int interlace_type)
 {
    png_byte buf[13]; /* Buffer to store the IHDR info */
+   int is_invalid_depth;
 
    png_debug(1, "in png_write_IHDR");
 
@@ -700,11 +700,11 @@
          break;
 
       case PNG_COLOR_TYPE_RGB:
+         is_invalid_depth = (bit_depth != 8);
 #ifdef PNG_WRITE_16BIT_SUPPORTED
-         if (bit_depth != 8 && bit_depth != 16)
-#else
-         if (bit_depth != 8)
+         is_invalid_depth = (is_invalid_depth && bit_depth != 16);
 #endif
+         if (is_invalid_depth)
             png_error(png_ptr, "Invalid bit depth for RGB image");
 
          png_ptr->channels = 3;
@@ -726,18 +726,22 @@
          break;
 
       case PNG_COLOR_TYPE_GRAY_ALPHA:
-         if (bit_depth != 8 && bit_depth != 16)
+         is_invalid_depth = (bit_depth != 8);
+#ifdef PNG_WRITE_16BIT_SUPPORTED
+         is_invalid_depth = (is_invalid_depth && bit_depth != 16);
+#endif
+         if (is_invalid_depth)
             png_error(png_ptr, "Invalid bit depth for grayscale+alpha image");
 
          png_ptr->channels = 2;
          break;
 
       case PNG_COLOR_TYPE_RGB_ALPHA:
+         is_invalid_depth = (bit_depth != 8);
 #ifdef PNG_WRITE_16BIT_SUPPORTED
-         if (bit_depth != 8 && bit_depth != 16)
-#else
-         if (bit_depth != 8)
+         is_invalid_depth = (is_invalid_depth && bit_depth != 16);
 #endif
+         if (is_invalid_depth)
             png_error(png_ptr, "Invalid bit depth for RGBA image");
 
          png_ptr->channels = 4;
@@ -815,7 +819,7 @@
    buf[12] = (png_byte)interlace_type;
 
    /* Write the chunk */
-   png_write_complete_chunk(png_ptr, png_IHDR, buf, (png_size_t)13);
+   png_write_complete_chunk(png_ptr, png_IHDR, buf, 13);
 
    if ((png_ptr->do_filter) == PNG_NO_FILTERS)
    {
@@ -884,7 +888,7 @@
       buf[0] = pal_ptr->red;
       buf[1] = pal_ptr->green;
       buf[2] = pal_ptr->blue;
-      png_write_chunk_data(png_ptr, buf, (png_size_t)3);
+      png_write_chunk_data(png_ptr, buf, 3);
    }
 
 #else
@@ -898,7 +902,7 @@
       buf[0] = pal_ptr[i].red;
       buf[1] = pal_ptr[i].green;
       buf[2] = pal_ptr[i].blue;
-      png_write_chunk_data(png_ptr, buf, (png_size_t)3);
+      png_write_chunk_data(png_ptr, buf, 3);
    }
 
 #endif
@@ -998,7 +1002,8 @@
                optimize_cmf(data, png_image_size(png_ptr));
 #endif
 
-         png_write_complete_chunk(png_ptr, png_IDAT, data, size);
+         if (size > 0)
+            png_write_complete_chunk(png_ptr, png_IDAT, data, size);
          png_ptr->mode |= PNG_HAVE_IDAT;
 
          png_ptr->zstream.next_out = data;
@@ -1044,7 +1049,8 @@
             optimize_cmf(data, png_image_size(png_ptr));
 #endif
 
-         png_write_complete_chunk(png_ptr, png_IDAT, data, size);
+         if (size > 0)
+            png_write_complete_chunk(png_ptr, png_IDAT, data, size);
          png_ptr->zstream.avail_out = 0;
          png_ptr->zstream.next_out = NULL;
          png_ptr->mode |= PNG_HAVE_IDAT | PNG_AFTER_IDAT;
@@ -1068,7 +1074,7 @@
 {
    png_debug(1, "in png_write_IEND");
 
-   png_write_complete_chunk(png_ptr, png_IEND, NULL, (png_size_t)0);
+   png_write_complete_chunk(png_ptr, png_IEND, NULL, 0);
    png_ptr->mode |= PNG_HAVE_IEND;
 }
 
@@ -1083,7 +1089,7 @@
 
    /* file_gamma is saved in 1/100,000ths */
    png_save_uint_32(buf, (png_uint_32)file_gamma);
-   png_write_complete_chunk(png_ptr, png_gAMA, buf, (png_size_t)4);
+   png_write_complete_chunk(png_ptr, png_gAMA, buf, 4);
 }
 #endif
 
@@ -1101,7 +1107,7 @@
           "Invalid sRGB rendering intent specified");
 
    buf[0]=(png_byte)srgb_intent;
-   png_write_complete_chunk(png_ptr, png_sRGB, buf, (png_size_t)1);
+   png_write_complete_chunk(png_ptr, png_sRGB, buf, 1);
 }
 #endif
 
@@ -1175,8 +1181,8 @@
    png_uint_32 name_len;
    png_byte new_name[80];
    png_byte entrybuf[10];
-   png_size_t entry_size = (spalette->depth == 8 ? 6 : 10);
-   png_size_t palette_size = entry_size * spalette->nentries;
+   size_t entry_size = (spalette->depth == 8 ? 6 : 10);
+   size_t palette_size = entry_size * (size_t)spalette->nentries;
    png_sPLT_entryp ep;
 #ifndef PNG_POINTER_INDEXING_SUPPORTED
    int i;
@@ -1193,10 +1199,9 @@
    png_write_chunk_header(png_ptr, png_sPLT,
        (png_uint_32)(name_len + 2 + palette_size));
 
-   png_write_chunk_data(png_ptr, (png_bytep)new_name,
-       (png_size_t)(name_len + 1));
+   png_write_chunk_data(png_ptr, (png_bytep)new_name, (size_t)(name_len + 1));
 
-   png_write_chunk_data(png_ptr, &spalette->depth, (png_size_t)1);
+   png_write_chunk_data(png_ptr, &spalette->depth, 1);
 
    /* Loop through each palette entry, writing appropriately */
 #ifdef PNG_POINTER_INDEXING_SUPPORTED
@@ -1258,7 +1263,7 @@
 png_write_sBIT(png_structrp png_ptr, png_const_color_8p sbit, int color_type)
 {
    png_byte buf[4];
-   png_size_t size;
+   size_t size;
 
    png_debug(1, "in png_write_sBIT");
 
@@ -1358,7 +1363,7 @@
 
       /* Write the chunk out as it is */
       png_write_complete_chunk(png_ptr, png_tRNS, trans_alpha,
-          (png_size_t)num_trans);
+          (size_t)num_trans);
    }
 
    else if (color_type == PNG_COLOR_TYPE_GRAY)
@@ -1373,7 +1378,7 @@
       }
 
       png_save_uint_16(buf, tran->gray);
-      png_write_complete_chunk(png_ptr, png_tRNS, buf, (png_size_t)2);
+      png_write_complete_chunk(png_ptr, png_tRNS, buf, 2);
    }
 
    else if (color_type == PNG_COLOR_TYPE_RGB)
@@ -1393,7 +1398,7 @@
          return;
       }
 
-      png_write_complete_chunk(png_ptr, png_tRNS, buf, (png_size_t)6);
+      png_write_complete_chunk(png_ptr, png_tRNS, buf, 6);
    }
 
    else
@@ -1426,7 +1431,7 @@
       }
 
       buf[0] = back->index;
-      png_write_complete_chunk(png_ptr, png_bKGD, buf, (png_size_t)1);
+      png_write_complete_chunk(png_ptr, png_bKGD, buf, 1);
    }
 
    else if ((color_type & PNG_COLOR_MASK_COLOR) != 0)
@@ -1447,7 +1452,7 @@
          return;
       }
 
-      png_write_complete_chunk(png_ptr, png_bKGD, buf, (png_size_t)6);
+      png_write_complete_chunk(png_ptr, png_bKGD, buf, 6);
    }
 
    else
@@ -1461,11 +1466,33 @@
       }
 
       png_save_uint_16(buf, back->gray);
-      png_write_complete_chunk(png_ptr, png_bKGD, buf, (png_size_t)2);
+      png_write_complete_chunk(png_ptr, png_bKGD, buf, 2);
    }
 }
 #endif
 
+#ifdef PNG_WRITE_eXIf_SUPPORTED
+/* Write the Exif data */
+void /* PRIVATE */
+png_write_eXIf(png_structrp png_ptr, png_bytep exif, int num_exif)
+{
+   int i;
+   png_byte buf[1];
+
+   png_debug(1, "in png_write_eXIf");
+
+   png_write_chunk_header(png_ptr, png_eXIf, (png_uint_32)(num_exif));
+
+   for (i = 0; i < num_exif; i++)
+   {
+      buf[0] = exif[i];
+      png_write_chunk_data(png_ptr, buf, 1);
+   }
+
+   png_write_chunk_end(png_ptr);
+}
+#endif
+
 #ifdef PNG_WRITE_hIST_SUPPORTED
 /* Write the histogram */
 void /* PRIVATE */
@@ -1490,7 +1517,7 @@
    for (i = 0; i < num_hist; i++)
    {
       png_save_uint_16(buf, hist[i]);
-      png_write_chunk_data(png_ptr, buf, (png_size_t)2);
+      png_write_chunk_data(png_ptr, buf, 2);
    }
 
    png_write_chunk_end(png_ptr);
@@ -1501,7 +1528,7 @@
 /* Write a tEXt chunk */
 void /* PRIVATE */
 png_write_tEXt(png_structrp png_ptr, png_const_charp key, png_const_charp text,
-    png_size_t text_len)
+    size_t text_len)
 {
    png_uint_32 key_len;
    png_byte new_key[80];
@@ -1598,7 +1625,7 @@
     png_const_charp lang, png_const_charp lang_key, png_const_charp text)
 {
    png_uint_32 key_len, prefix_len;
-   png_size_t lang_len, lang_key_len;
+   size_t lang_len, lang_key_len;
    png_byte new_key[82];
    compression_state comp;
 
@@ -1708,7 +1735,7 @@
    png_save_int_32(buf + 4, y_offset);
    buf[8] = (png_byte)unit_type;
 
-   png_write_complete_chunk(png_ptr, png_oFFs, buf, (png_size_t)9);
+   png_write_complete_chunk(png_ptr, png_oFFs, buf, 9);
 }
 #endif
 #ifdef PNG_WRITE_pCAL_SUPPORTED
@@ -1719,8 +1746,8 @@
     png_charpp params)
 {
    png_uint_32 purpose_len;
-   png_size_t units_len, total_len;
-   png_size_tp params_len;
+   size_t units_len, total_len;
+   size_t *params_len;
    png_byte buf[10];
    png_byte new_purpose[80];
    int i;
@@ -1742,8 +1769,8 @@
    png_debug1(3, "pCAL units length = %d", (int)units_len);
    total_len = purpose_len + units_len + 10;
 
-   params_len = (png_size_tp)png_malloc(png_ptr,
-       (png_alloc_size_t)(nparams * (sizeof (png_size_t))));
+   params_len = (size_t *)png_malloc(png_ptr,
+       (png_alloc_size_t)((png_alloc_size_t)nparams * (sizeof (size_t))));
 
    /* Find the length of each parameter, making sure we don't count the
     * null terminator for the last parameter.
@@ -1763,8 +1790,8 @@
    png_save_int_32(buf + 4, X1);
    buf[8] = (png_byte)type;
    buf[9] = (png_byte)nparams;
-   png_write_chunk_data(png_ptr, buf, (png_size_t)10);
-   png_write_chunk_data(png_ptr, (png_const_bytep)units, (png_size_t)units_len);
+   png_write_chunk_data(png_ptr, buf, 10);
+   png_write_chunk_data(png_ptr, (png_const_bytep)units, (size_t)units_len);
 
    for (i = 0; i < nparams; i++)
    {
@@ -1783,7 +1810,7 @@
     png_const_charp height)
 {
    png_byte buf[64];
-   png_size_t wlen, hlen, total_len;
+   size_t wlen, hlen, total_len;
 
    png_debug(1, "in png_write_sCAL_s");
 
@@ -1824,7 +1851,7 @@
    png_save_uint_32(buf + 4, y_pixels_per_unit);
    buf[8] = (png_byte)unit_type;
 
-   png_write_complete_chunk(png_ptr, png_pHYs, buf, (png_size_t)9);
+   png_write_complete_chunk(png_ptr, png_pHYs, buf, 9);
 }
 #endif
 
@@ -1854,7 +1881,7 @@
    buf[5] = mod_time->minute;
    buf[6] = mod_time->second;
 
-   png_write_complete_chunk(png_ptr, png_tIME, buf, (png_size_t)7);
+   png_write_complete_chunk(png_ptr, png_tIME, buf, 7);
 }
 #endif
 
@@ -1866,16 +1893,16 @@
    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
 
    /* Start of interlace block */
-   static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
+   static const png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
 
    /* Offset to next interlace block */
-   static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
+   static const png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
 
    /* Start of interlace block in the y direction */
-   static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
+   static const png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
 
    /* Offset to next interlace block in the y direction */
-   static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
+   static const png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
 #endif
 
    png_alloc_size_t buf_size;
@@ -1981,16 +2008,16 @@
    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
 
    /* Start of interlace block */
-   static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
+   static const png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
 
    /* Offset to next interlace block */
-   static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
+   static const png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
 
    /* Start of interlace block in the y direction */
-   static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
+   static const png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
 
    /* Offset to next interlace block in the y direction */
-   static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
+   static const png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
 #endif
 
    png_debug(1, "in png_write_finish_row");
@@ -2044,8 +2071,8 @@
       {
          if (png_ptr->prev_row != NULL)
             memset(png_ptr->prev_row, 0,
-                (png_size_t)(PNG_ROWBYTES(png_ptr->usr_channels*
-                png_ptr->usr_bit_depth, png_ptr->width)) + 1);
+                PNG_ROWBYTES(png_ptr->usr_channels *
+                png_ptr->usr_bit_depth, png_ptr->width) + 1);
 
          return;
       }
@@ -2071,10 +2098,10 @@
    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
 
    /* Start of interlace block */
-   static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
+   static const png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
 
    /* Offset to next interlace block */
-   static PNG_CONST png_byte  png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
+   static const png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
 
    png_debug(1, "in png_do_write_interlace");
 
@@ -2101,7 +2128,7 @@
             for (i = png_pass_start[pass]; i < row_width;
                i += png_pass_inc[pass])
             {
-               sp = row + (png_size_t)(i >> 3);
+               sp = row + (size_t)(i >> 3);
                value = (int)(*sp >> (7 - (int)(i & 0x07))) & 0x01;
                d |= (value << shift);
 
@@ -2139,7 +2166,7 @@
             for (i = png_pass_start[pass]; i < row_width;
                i += png_pass_inc[pass])
             {
-               sp = row + (png_size_t)(i >> 2);
+               sp = row + (size_t)(i >> 2);
                value = (*sp >> ((3 - (int)(i & 0x03)) << 1)) & 0x03;
                d |= (value << shift);
 
@@ -2175,7 +2202,7 @@
             for (i = png_pass_start[pass]; i < row_width;
                 i += png_pass_inc[pass])
             {
-               sp = row + (png_size_t)(i >> 1);
+               sp = row + (size_t)(i >> 1);
                value = (*sp >> ((1 - (int)(i & 0x01)) << 2)) & 0x0f;
                d |= (value << shift);
 
@@ -2201,7 +2228,7 @@
             png_bytep dp;
             png_uint_32 i;
             png_uint_32 row_width = row_info->width;
-            png_size_t pixel_bytes;
+            size_t pixel_bytes;
 
             /* Start at the beginning */
             dp = row;
@@ -2214,7 +2241,7 @@
                i += png_pass_inc[pass])
             {
                /* Find out where the original pixel is */
-               sp = row + (png_size_t)i * pixel_bytes;
+               sp = row + (size_t)i * pixel_bytes;
 
                /* Move the pixel */
                if (dp != sp)
@@ -2245,17 +2272,17 @@
  */
 static void /* PRIVATE */
 png_write_filtered_row(png_structrp png_ptr, png_bytep filtered_row,
-    png_size_t row_bytes);
+    size_t row_bytes);
 
 #ifdef PNG_WRITE_FILTER_SUPPORTED
-static png_size_t /* PRIVATE */
-png_setup_sub_row(png_structrp png_ptr, const png_uint_32 bpp,
-    const png_size_t row_bytes, const png_size_t lmins)
+static size_t /* PRIVATE */
+png_setup_sub_row(png_structrp png_ptr, png_uint_32 bpp,
+    size_t row_bytes, size_t lmins)
 {
    png_bytep rp, dp, lp;
-   png_size_t i;
-   png_size_t sum = 0;
-   int v;
+   size_t i;
+   size_t sum = 0;
+   unsigned int v;
 
    png_ptr->try_row[0] = PNG_FILTER_VALUE_SUB;
 
@@ -2264,7 +2291,7 @@
    {
       v = *dp = *rp;
 #ifdef PNG_USE_ABS
-      sum += 128 - abs(v - 128);
+      sum += 128 - abs((int)v - 128);
 #else
       sum += (v < 128) ? v : 256 - v;
 #endif
@@ -2275,7 +2302,7 @@
    {
       v = *dp = (png_byte)(((int)*rp - (int)*lp) & 0xff);
 #ifdef PNG_USE_ABS
-      sum += 128 - abs(v - 128);
+      sum += 128 - abs((int)v - 128);
 #else
       sum += (v < 128) ? v : 256 - v;
 #endif
@@ -2288,11 +2315,11 @@
 }
 
 static void /* PRIVATE */
-png_setup_sub_row_only(png_structrp png_ptr, const png_uint_32 bpp,
-    const png_size_t row_bytes)
+png_setup_sub_row_only(png_structrp png_ptr, png_uint_32 bpp,
+    size_t row_bytes)
 {
    png_bytep rp, dp, lp;
-   png_size_t i;
+   size_t i;
 
    png_ptr->try_row[0] = PNG_FILTER_VALUE_SUB;
 
@@ -2309,14 +2336,13 @@
    }
 }
 
-static png_size_t /* PRIVATE */
-png_setup_up_row(png_structrp png_ptr, const png_size_t row_bytes,
-    const png_size_t lmins)
+static size_t /* PRIVATE */
+png_setup_up_row(png_structrp png_ptr, size_t row_bytes, size_t lmins)
 {
    png_bytep rp, dp, pp;
-   png_size_t i;
-   png_size_t sum = 0;
-   int v;
+   size_t i;
+   size_t sum = 0;
+   unsigned int v;
 
    png_ptr->try_row[0] = PNG_FILTER_VALUE_UP;
 
@@ -2326,7 +2352,7 @@
    {
       v = *dp = (png_byte)(((int)*rp - (int)*pp) & 0xff);
 #ifdef PNG_USE_ABS
-      sum += 128 - abs(v - 128);
+      sum += 128 - abs((int)v - 128);
 #else
       sum += (v < 128) ? v : 256 - v;
 #endif
@@ -2338,10 +2364,10 @@
    return (sum);
 }
 static void /* PRIVATE */
-png_setup_up_row_only(png_structrp png_ptr, const png_size_t row_bytes)
+png_setup_up_row_only(png_structrp png_ptr, size_t row_bytes)
 {
    png_bytep rp, dp, pp;
-   png_size_t i;
+   size_t i;
 
    png_ptr->try_row[0] = PNG_FILTER_VALUE_UP;
 
@@ -2353,14 +2379,14 @@
    }
 }
 
-static png_size_t /* PRIVATE */
-png_setup_avg_row(png_structrp png_ptr, const png_uint_32 bpp,
-    const png_size_t row_bytes, const png_size_t lmins)
+static size_t /* PRIVATE */
+png_setup_avg_row(png_structrp png_ptr, png_uint_32 bpp,
+    size_t row_bytes, size_t lmins)
 {
    png_bytep rp, dp, pp, lp;
    png_uint_32 i;
-   png_size_t sum = 0;
-   int v;
+   size_t sum = 0;
+   unsigned int v;
 
    png_ptr->try_row[0] = PNG_FILTER_VALUE_AVG;
 
@@ -2370,7 +2396,7 @@
       v = *dp++ = (png_byte)(((int)*rp++ - ((int)*pp++ / 2)) & 0xff);
 
 #ifdef PNG_USE_ABS
-      sum += 128 - abs(v - 128);
+      sum += 128 - abs((int)v - 128);
 #else
       sum += (v < 128) ? v : 256 - v;
 #endif
@@ -2382,7 +2408,7 @@
           & 0xff);
 
 #ifdef PNG_USE_ABS
-      sum += 128 - abs(v - 128);
+      sum += 128 - abs((int)v - 128);
 #else
       sum += (v < 128) ? v : 256 - v;
 #endif
@@ -2394,8 +2420,8 @@
    return (sum);
 }
 static void /* PRIVATE */
-png_setup_avg_row_only(png_structrp png_ptr, const png_uint_32 bpp,
-    const png_size_t row_bytes)
+png_setup_avg_row_only(png_structrp png_ptr, png_uint_32 bpp,
+    size_t row_bytes)
 {
    png_bytep rp, dp, pp, lp;
    png_uint_32 i;
@@ -2415,14 +2441,14 @@
    }
 }
 
-static png_size_t /* PRIVATE */
-png_setup_paeth_row(png_structrp png_ptr, const png_uint_32 bpp,
-    const png_size_t row_bytes, const png_size_t lmins)
+static size_t /* PRIVATE */
+png_setup_paeth_row(png_structrp png_ptr, png_uint_32 bpp,
+    size_t row_bytes, size_t lmins)
 {
    png_bytep rp, dp, pp, cp, lp;
-   png_size_t i;
-   png_size_t sum = 0;
-   int v;
+   size_t i;
+   size_t sum = 0;
+   unsigned int v;
 
    png_ptr->try_row[0] = PNG_FILTER_VALUE_PAETH;
 
@@ -2432,7 +2458,7 @@
       v = *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);
 
 #ifdef PNG_USE_ABS
-      sum += 128 - abs(v - 128);
+      sum += 128 - abs((int)v - 128);
 #else
       sum += (v < 128) ? v : 256 - v;
 #endif
@@ -2465,7 +2491,7 @@
       v = *dp++ = (png_byte)(((int)*rp++ - p) & 0xff);
 
 #ifdef PNG_USE_ABS
-      sum += 128 - abs(v - 128);
+      sum += 128 - abs((int)v - 128);
 #else
       sum += (v < 128) ? v : 256 - v;
 #endif
@@ -2477,11 +2503,11 @@
    return (sum);
 }
 static void /* PRIVATE */
-png_setup_paeth_row_only(png_structrp png_ptr, const png_uint_32 bpp,
-    const png_size_t row_bytes)
+png_setup_paeth_row_only(png_structrp png_ptr, png_uint_32 bpp,
+    size_t row_bytes)
 {
    png_bytep rp, dp, pp, cp, lp;
-   png_size_t i;
+   size_t i;
 
    png_ptr->try_row[0] = PNG_FILTER_VALUE_PAETH;
 
@@ -2530,8 +2556,8 @@
    png_bytep row_buf;
    png_bytep best_row;
    png_uint_32 bpp;
-   png_size_t mins;
-   png_size_t row_bytes = row_info->rowbytes;
+   size_t mins;
+   size_t row_bytes = row_info->rowbytes;
 
    png_debug(1, "in png_write_find_filter");
 
@@ -2586,16 +2612,16 @@
        * 'none' filter.
        */
       png_bytep rp;
-      png_size_t sum = 0;
-      png_size_t i;
-      int v;
+      size_t sum = 0;
+      size_t i;
+      unsigned int v;
 
       {
          for (i = 0, rp = row_buf + 1; i < row_bytes; i++, rp++)
          {
             v = *rp;
 #ifdef PNG_USE_ABS
-            sum += 128 - abs(v - 128);
+            sum += 128 - abs((int)v - 128);
 #else
             sum += (v < 128) ? v : 256 - v;
 #endif
@@ -2615,8 +2641,8 @@
 
    else if ((filter_to_do & PNG_FILTER_SUB) != 0)
    {
-      png_size_t sum;
-      png_size_t lmins = mins;
+      size_t sum;
+      size_t lmins = mins;
 
       sum = png_setup_sub_row(png_ptr, bpp, row_bytes, lmins);
 
@@ -2641,8 +2667,8 @@
 
    else if ((filter_to_do & PNG_FILTER_UP) != 0)
    {
-      png_size_t sum;
-      png_size_t lmins = mins;
+      size_t sum;
+      size_t lmins = mins;
 
       sum = png_setup_up_row(png_ptr, row_bytes, lmins);
 
@@ -2667,8 +2693,8 @@
 
    else if ((filter_to_do & PNG_FILTER_AVG) != 0)
    {
-      png_size_t sum;
-      png_size_t lmins = mins;
+      size_t sum;
+      size_t lmins = mins;
 
       sum= png_setup_avg_row(png_ptr, bpp, row_bytes, lmins);
 
@@ -2693,8 +2719,8 @@
 
    else if ((filter_to_do & PNG_FILTER_PAETH) != 0)
    {
-      png_size_t sum;
-      png_size_t lmins = mins;
+      size_t sum;
+      size_t lmins = mins;
 
       sum = png_setup_paeth_row(png_ptr, bpp, row_bytes, lmins);
 
@@ -2719,7 +2745,7 @@
 /* Do the actual writing of a previously filtered row. */
 static void
 png_write_filtered_row(png_structrp png_ptr, png_bytep filtered_row,
-    png_size_t full_row_length/*includes filter byte*/)
+    size_t full_row_length/*includes filter byte*/)
 {
    png_debug(1, "in png_write_filtered_row");
 
Index: libpng-src/libpng/pngrutil.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/pngrutil.c b/libpng-src/libpng/pngrutil.c
--- a/libpng-src/libpng/pngrutil.c	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/pngrutil.c	(date 1690795574122)
@@ -1,10 +1,10 @@
 
 /* pngrutil.c - utilities to read a PNG file
  *
- * Last changed in libpng 1.6.25 [September 1, 2016]
- * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ * Copyright (c) 2018-2022 Cosmin Truta
+ * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson
+ * Copyright (c) 1996-1997 Andreas Dilger
+ * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
@@ -86,7 +86,7 @@
 {
    png_uint_32 uval = png_get_uint_32(buf);
    if ((uval & 0x80000000) == 0) /* non-negative */
-      return uval;
+      return (png_int_32)uval;
 
    uval = (uval ^ 0xffffffff) + 1;  /* 2's complement: -x = ~x+1 */
    if ((uval & 0x80000000) == 0) /* no overflow */
@@ -102,7 +102,7 @@
 png_uint_16 (PNGAPI
 png_get_uint_16)(png_const_bytep buf)
 {
-   /* ANSI-C requires an int value to accomodate at least 16 bits so this
+   /* ANSI-C requires an int value to accommodate at least 16 bits so this
     * works and allows the compiler not to worry about possible narrowing
     * on 32-bit systems.  (Pre-ANSI systems did not make integers smaller
     * than 16 bits either.)
@@ -120,7 +120,7 @@
 void /* PRIVATE */
 png_read_sig(png_structrp png_ptr, png_inforp info_ptr)
 {
-   png_size_t num_checked, num_to_check;
+   size_t num_checked, num_to_check;
 
    /* Exit if the user application does not expect a signature. */
    if (png_ptr->sig_bytes >= 8)
@@ -181,6 +181,9 @@
    /* Check to see if chunk name is valid. */
    png_check_chunk_name(png_ptr, png_ptr->chunk_name);
 
+   /* Check for too-large chunk length */
+   png_check_chunk_length(png_ptr, length);
+
 #ifdef PNG_IO_STATE_SUPPORTED
    png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_DATA;
 #endif
@@ -298,7 +301,6 @@
 
    if (buffer != NULL && new_size > png_ptr->read_buffer_size)
    {
-      png_ptr->read_buffer = NULL;
       png_ptr->read_buffer = NULL;
       png_ptr->read_buffer_size = 0;
       png_free(png_ptr, buffer);
@@ -311,6 +313,7 @@
 
       if (buffer != NULL)
       {
+         memset(buffer, 0, new_size); /* just in case */
          png_ptr->read_buffer = buffer;
          png_ptr->read_buffer_size = new_size;
       }
@@ -370,11 +373,10 @@
     */
    {
       int ret; /* zlib return code */
-#if PNG_ZLIB_VERNUM >= 0x1240
+#if ZLIB_VERNUM >= 0x1240
+      int window_bits = 0;
 
 # if defined(PNG_SET_OPTION_SUPPORTED) && defined(PNG_MAXIMUM_INFLATE_WINDOW)
-      int window_bits;
-
       if (((png_ptr->options >> PNG_MAXIMUM_INFLATE_WINDOW) & 3) ==
           PNG_OPTION_ON)
       {
@@ -384,13 +386,11 @@
 
       else
       {
-         window_bits = 0;
          png_ptr->zstream_start = 1;
       }
-# else
-#   define window_bits 0
 # endif
-#endif
+
+#endif /* ZLIB_VERNUM >= 0x1240 */
 
       /* Set this for safety, just in case the previous owner left pointers to
        * memory allocations.
@@ -402,25 +402,32 @@
 
       if ((png_ptr->flags & PNG_FLAG_ZSTREAM_INITIALIZED) != 0)
       {
-#if PNG_ZLIB_VERNUM < 0x1240
+#if ZLIB_VERNUM >= 0x1240
+         ret = inflateReset2(&png_ptr->zstream, window_bits);
+#else
          ret = inflateReset(&png_ptr->zstream);
-#else
-         ret = inflateReset2(&png_ptr->zstream, window_bits);
 #endif
       }
 
       else
       {
-#if PNG_ZLIB_VERNUM < 0x1240
-         ret = inflateInit(&png_ptr->zstream);
-#else
+#if ZLIB_VERNUM >= 0x1240
          ret = inflateInit2(&png_ptr->zstream, window_bits);
+#else
+         ret = inflateInit(&png_ptr->zstream);
 #endif
 
          if (ret == Z_OK)
             png_ptr->flags |= PNG_FLAG_ZSTREAM_INITIALIZED;
       }
 
+#if ZLIB_VERNUM >= 0x1290 && \
+   defined(PNG_SET_OPTION_SUPPORTED) && defined(PNG_IGNORE_ADLER32)
+      if (((png_ptr->options >> PNG_IGNORE_ADLER32) & 3) == PNG_OPTION_ON)
+         /* Turn off validation of the ADLER32 checksum in IDAT chunks */
+         ret = inflateValidate(&png_ptr->zstream, 0);
+#endif
+
       if (ret == Z_OK)
          png_ptr->zowner = owner;
 
@@ -435,7 +442,7 @@
 #endif
 }
 
-#if PNG_ZLIB_VERNUM >= 0x1240
+#if ZLIB_VERNUM >= 0x1240
 /* Handle the start of the inflate stream if we called inflateInit2(strm,0);
  * in this case some zlib versions skip validation of the CINFO field and, in
  * certain circumstances, libpng may end up displaying an invalid image, in
@@ -666,6 +673,8 @@
 
                if (text != NULL)
                {
+                  memset(text, 0, buffer_size);
+
                   ret = png_inflate(png_ptr, png_ptr->chunk_name, 1/*finish*/,
                       png_ptr->read_buffer + prefix_size, &lzsize,
                       text + prefix_size, newlength);
@@ -713,7 +722,7 @@
                    * the extra space may otherwise be used as a Trojan Horse.
                    */
                   if (ret == Z_STREAM_END &&
-                     chunklength - prefix_size != lzsize)
+                      chunklength - prefix_size != lzsize)
                      png_chunk_benign_error(png_ptr, "extra compressed data");
                }
 
@@ -729,9 +738,7 @@
             {
                /* inflateReset failed, store the error message */
                png_zstream_error(png_ptr, ret);
-
-               if (ret == Z_STREAM_END)
-                  ret = PNG_UNEXPECTED_ZLIB_RETURN;
+               ret = PNG_UNEXPECTED_ZLIB_RETURN;
             }
          }
 
@@ -823,7 +830,7 @@
       return Z_STREAM_ERROR;
    }
 }
-#endif
+#endif /* READ_iCCP */
 
 /* Read and check the IDHR chunk */
 
@@ -1011,7 +1018,7 @@
    if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
 #endif
    {
-      png_crc_finish(png_ptr, (int) length - num * 3);
+      png_crc_finish(png_ptr, (png_uint_32) (length - (unsigned int)num * 3));
    }
 
 #ifndef PNG_READ_OPT_PLTE_SUPPORTED
@@ -1373,11 +1380,13 @@
     * chunk is just ignored, so does not invalidate the color space.  An
     * alternative is to set the 'invalid' flags at the start of this routine
     * and only clear them in they were not set before and all the tests pass.
-    * The minimum 'deflate' stream is assumed to be just the 2 byte header and
-    * 4 byte checksum.  The keyword must be at least one character and there is
-    * a terminator (0) byte and the compression method.
     */
-   if (length < 9)
+
+   /* The keyword must be at least one character and there is a
+    * terminator (0) byte and the compression method byte, and the
+    * 'zlib' datastream is at least 11 bytes.
+    */
+   if (length < 14)
    {
       png_crc_finish(png_ptr, length);
       png_chunk_benign_error(png_ptr, "too short");
@@ -1409,6 +1418,16 @@
       png_crc_read(png_ptr, (png_bytep)keyword, read_length);
       length -= read_length;
 
+      /* The minimum 'zlib' stream is assumed to be just the 2 byte header,
+       * 5 bytes minimum 'deflate' stream, and the 4 byte checksum.
+       */
+      if (length < 11)
+      {
+         png_crc_finish(png_ptr, length);
+         png_chunk_benign_error(png_ptr, "too short");
+         return;
+      }
+
       keyword_length = 0;
       while (keyword_length < 80 && keyword_length < read_length &&
          keyword[keyword_length] != 0)
@@ -1427,7 +1446,7 @@
 
             if (png_inflate_claim(png_ptr, png_iCCP) == Z_OK)
             {
-               Byte profile_header[132];
+               Byte profile_header[132]={0};
                Byte local_buffer[PNG_INFLATE_BUF_SIZE];
                png_alloc_size_t size = (sizeof profile_header);
 
@@ -1441,8 +1460,7 @@
                {
                   /* We have the ICC profile header; do the basic header checks.
                    */
-                  const png_uint_32 profile_length =
-                     png_get_uint_32(profile_header);
+                  png_uint_32 profile_length = png_get_uint_32(profile_header);
 
                   if (png_icc_check_length(png_ptr, &png_ptr->colorspace,
                       keyword, profile_length) != 0)
@@ -1457,10 +1475,10 @@
                         /* Now read the tag table; a variable size buffer is
                          * needed at this point, allocate one for the whole
                          * profile.  The header check has already validated
-                         * that none of these stuff will overflow.
+                         * that none of this stuff will overflow.
                          */
-                        const png_uint_32 tag_count = png_get_uint_32(
-                            profile_header+128);
+                        png_uint_32 tag_count =
+                           png_get_uint_32(profile_header + 128);
                         png_bytep profile = png_read_buffer(png_ptr,
                             profile_length, 2/*silent*/);
 
@@ -1564,19 +1582,11 @@
                                        return;
                                     }
                                  }
-
-                                 else if (size > 0)
-                                    errmsg = "truncated";
-
-#ifndef __COVERITY__
-                                 else
+                                 if (errmsg == NULL)
                                     errmsg = png_ptr->zstream.msg;
-#endif
                               }
-
                               /* else png_icc_check_tag_table output an error */
                            }
-
                            else /* profile truncated */
                               errmsg = png_ptr->zstream.msg;
                         }
@@ -1636,7 +1646,7 @@
    int entry_size, i;
    png_uint_32 skip = 0;
    png_uint_32 dl;
-   png_size_t max_dl;
+   size_t max_dl;
 
    png_debug(1, "in png_handle_sPLT");
 
@@ -1717,13 +1727,13 @@
    data_length = length - (png_uint_32)(entry_start - buffer);
 
    /* Integrity-check the data length */
-   if ((data_length % entry_size) != 0)
+   if ((data_length % (unsigned int)entry_size) != 0)
    {
       png_warning(png_ptr, "sPLT chunk has bad length");
       return;
    }
 
-   dl = (png_int_32)(data_length / entry_size);
+   dl = (png_uint_32)(data_length / (unsigned int)entry_size);
    max_dl = PNG_SIZE_MAX / (sizeof (png_sPLT_entry));
 
    if (dl > max_dl)
@@ -1732,10 +1742,10 @@
       return;
    }
 
-   new_palette.nentries = (png_int_32)(data_length / entry_size);
+   new_palette.nentries = (png_int_32)(data_length / (unsigned int)entry_size);
 
-   new_palette.entries = (png_sPLT_entryp)png_malloc_warn(
-       png_ptr, new_palette.nentries * (sizeof (png_sPLT_entry)));
+   new_palette.entries = (png_sPLT_entryp)png_malloc_warn(png_ptr,
+       (png_alloc_size_t) new_palette.nentries * (sizeof (png_sPLT_entry)));
 
    if (new_palette.entries == NULL)
    {
@@ -1985,6 +1995,15 @@
 
    else if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) == 0) /* GRAY */
    {
+      if (png_ptr->bit_depth <= 8)
+      {
+         if (buf[0] != 0 || buf[1] >= (unsigned int)(1 << png_ptr->bit_depth))
+         {
+            png_chunk_benign_error(png_ptr, "invalid gray level");
+            return;
+         }
+      }
+
       background.index = 0;
       background.red =
       background.green =
@@ -1994,6 +2013,15 @@
 
    else
    {
+      if (png_ptr->bit_depth <= 8)
+      {
+         if (buf[0] != 0 || buf[2] != 0 || buf[4] != 0)
+         {
+            png_chunk_benign_error(png_ptr, "invalid color");
+            return;
+         }
+      }
+
       background.index = 0;
       background.red = png_get_uint_16(buf);
       background.green = png_get_uint_16(buf + 2);
@@ -2004,6 +2032,70 @@
    png_set_bKGD(png_ptr, info_ptr, &background);
 }
 #endif
+
+#ifdef PNG_READ_eXIf_SUPPORTED
+void /* PRIVATE */
+png_handle_eXIf(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
+{
+   unsigned int i;
+
+   png_debug(1, "in png_handle_eXIf");
+
+   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
+      png_chunk_error(png_ptr, "missing IHDR");
+
+   if (length < 2)
+   {
+      png_crc_finish(png_ptr, length);
+      png_chunk_benign_error(png_ptr, "too short");
+      return;
+   }
+
+   else if (info_ptr == NULL || (info_ptr->valid & PNG_INFO_eXIf) != 0)
+   {
+      png_crc_finish(png_ptr, length);
+      png_chunk_benign_error(png_ptr, "duplicate");
+      return;
+   }
+
+   info_ptr->free_me |= PNG_FREE_EXIF;
+
+   info_ptr->eXIf_buf = png_voidcast(png_bytep,
+             png_malloc_warn(png_ptr, length));
+
+   if (info_ptr->eXIf_buf == NULL)
+   {
+      png_crc_finish(png_ptr, length);
+      png_chunk_benign_error(png_ptr, "out of memory");
+      return;
+   }
+
+   for (i = 0; i < length; i++)
+   {
+      png_byte buf[1];
+      png_crc_read(png_ptr, buf, 1);
+      info_ptr->eXIf_buf[i] = buf[0];
+      if (i == 1)
+      {
+         if ((buf[0] != 'M' && buf[0] != 'I') ||
+             (info_ptr->eXIf_buf[0] != buf[0]))
+         {
+            png_crc_finish(png_ptr, length - 2);
+            png_chunk_benign_error(png_ptr, "incorrect byte-order specifier");
+            png_free(png_ptr, info_ptr->eXIf_buf);
+            info_ptr->eXIf_buf = NULL;
+            return;
+         }
+      }
+   }
+
+   if (png_crc_finish(png_ptr, 0) == 0)
+      png_set_eXIf_1(png_ptr, info_ptr, length, info_ptr->eXIf_buf);
+
+   png_free(png_ptr, info_ptr->eXIf_buf);
+   info_ptr->eXIf_buf = NULL;
+}
+#endif
 
 #ifdef PNG_READ_hIST_SUPPORTED
 void /* PRIVATE */
@@ -2034,8 +2126,9 @@
 
    num = length / 2 ;
 
-   if (num != (unsigned int) png_ptr->num_palette ||
-       num > (unsigned int) PNG_MAX_PALETTE_LENGTH)
+   if (length != num * 2 ||
+       num != (unsigned int)png_ptr->num_palette ||
+       num > (unsigned int)PNG_MAX_PALETTE_LENGTH)
    {
       png_crc_finish(png_ptr, length);
       png_chunk_benign_error(png_ptr, "invalid");
@@ -2284,7 +2377,7 @@
 png_handle_sCAL(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
 {
    png_bytep buffer;
-   png_size_t i;
+   size_t i;
    int state;
 
    png_debug(1, "in png_handle_sCAL");
@@ -2354,7 +2447,7 @@
 
    else
    {
-      png_size_t heighti = i;
+      size_t heighti = i;
 
       state = 0;
       if (png_check_fp_number((png_const_charp)buffer, length,
@@ -2533,6 +2626,9 @@
    if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)
       png_ptr->mode |= PNG_AFTER_IDAT;
 
+   /* Note, "length" is sufficient here; we won't be adding
+    * a null terminator later.
+    */
    buffer = png_read_buffer(png_ptr, length, 2/*silent*/);
 
    if (buffer == NULL)
@@ -2579,23 +2675,28 @@
       {
          png_text text;
 
-         /* It worked; png_ptr->read_buffer now looks like a tEXt chunk except
-          * for the extra compression type byte and the fact that it isn't
-          * necessarily '\0' terminated.
-          */
-         buffer = png_ptr->read_buffer;
-         buffer[uncompressed_length+(keyword_length+2)] = 0;
+         if (png_ptr->read_buffer == NULL)
+           errmsg="Read failure in png_handle_zTXt";
+         else
+         {
+            /* It worked; png_ptr->read_buffer now looks like a tEXt chunk
+             * except for the extra compression type byte and the fact that
+             * it isn't necessarily '\0' terminated.
+             */
+            buffer = png_ptr->read_buffer;
+            buffer[uncompressed_length+(keyword_length+2)] = 0;
 
-         text.compression = PNG_TEXT_COMPRESSION_zTXt;
-         text.key = (png_charp)buffer;
-         text.text = (png_charp)(buffer + keyword_length+2);
-         text.text_length = uncompressed_length;
-         text.itxt_length = 0;
-         text.lang = NULL;
-         text.lang_key = NULL;
+            text.compression = PNG_TEXT_COMPRESSION_zTXt;
+            text.key = (png_charp)buffer;
+            text.text = (png_charp)(buffer + keyword_length+2);
+            text.text_length = uncompressed_length;
+            text.itxt_length = 0;
+            text.lang = NULL;
+            text.lang_key = NULL;
 
-         if (png_set_text_2(png_ptr, info_ptr, &text, 1) != 0)
-            errmsg = "insufficient memory";
+            if (png_set_text_2(png_ptr, info_ptr, &text, 1) != 0)
+               errmsg = "insufficient memory";
+         }
       }
 
       else
@@ -2784,7 +2885,7 @@
    {
       PNG_CSTRING_FROM_CHUNK(png_ptr->unknown_chunk.name, png_ptr->chunk_name);
       /* The following is safe because of the PNG_SIZE_MAX init above */
-      png_ptr->unknown_chunk.size = (png_size_t)length/*SAFE*/;
+      png_ptr->unknown_chunk.size = (size_t)length/*SAFE*/;
       /* 'mode' is a flag array, only the bottom four bits matter here */
       png_ptr->unknown_chunk.location = (png_byte)png_ptr->mode/*SAFE*/;
 
@@ -2971,7 +3072,7 @@
          case 2:
             png_ptr->user_chunk_cache_max = 1;
             png_chunk_benign_error(png_ptr, "no space in chunk cache");
-            /* FALL THROUGH */
+            /* FALLTHROUGH */
          case 1:
             /* NOTE: prior to 1.6.0 this case resulted in an unknown critical
              * chunk being skipped, now there will be a hard error below.
@@ -2980,7 +3081,7 @@
 
          default: /* not at limit */
             --(png_ptr->user_chunk_cache_max);
-            /* FALL THROUGH */
+            /* FALLTHROUGH */
          case 0: /* no limit */
 #  endif /* USER_LIMITS */
             /* Here when the limit isn't reached or when limits are compiled
@@ -3031,20 +3132,61 @@
  */
 
 void /* PRIVATE */
-png_check_chunk_name(png_structrp png_ptr, png_uint_32 chunk_name)
+png_check_chunk_name(png_const_structrp png_ptr, png_uint_32 chunk_name)
 {
    int i;
+   png_uint_32 cn=chunk_name;
 
    png_debug(1, "in png_check_chunk_name");
 
    for (i=1; i<=4; ++i)
    {
-      int c = chunk_name & 0xff;
+      int c = cn & 0xff;
 
       if (c < 65 || c > 122 || (c > 90 && c < 97))
          png_chunk_error(png_ptr, "invalid chunk type");
 
-      chunk_name >>= 8;
+      cn >>= 8;
+   }
+}
+
+void /* PRIVATE */
+png_check_chunk_length(png_const_structrp png_ptr, png_uint_32 length)
+{
+   png_alloc_size_t limit = PNG_UINT_31_MAX;
+
+# ifdef PNG_SET_USER_LIMITS_SUPPORTED
+   if (png_ptr->user_chunk_malloc_max > 0 &&
+       png_ptr->user_chunk_malloc_max < limit)
+      limit = png_ptr->user_chunk_malloc_max;
+# elif PNG_USER_CHUNK_MALLOC_MAX > 0
+   if (PNG_USER_CHUNK_MALLOC_MAX < limit)
+      limit = PNG_USER_CHUNK_MALLOC_MAX;
+# endif
+   if (png_ptr->chunk_name == png_IDAT)
+   {
+      png_alloc_size_t idat_limit = PNG_UINT_31_MAX;
+      size_t row_factor =
+         (size_t)png_ptr->width
+         * (size_t)png_ptr->channels
+         * (png_ptr->bit_depth > 8? 2: 1)
+         + 1
+         + (png_ptr->interlaced? 6: 0);
+      if (png_ptr->height > PNG_UINT_32_MAX/row_factor)
+         idat_limit = PNG_UINT_31_MAX;
+      else
+         idat_limit = png_ptr->height * row_factor;
+      row_factor = row_factor > 32566? 32566 : row_factor;
+      idat_limit += 6 + 5*(idat_limit/row_factor+1); /* zlib+deflate overhead */
+      idat_limit=idat_limit < PNG_UINT_31_MAX? idat_limit : PNG_UINT_31_MAX;
+      limit = limit < idat_limit? idat_limit : limit;
+   }
+
+   if (length > limit)
+   {
+      png_debug2(0," length = %lu, limit = %lu",
+         (unsigned long)length,(unsigned long)limit);
+      png_benign_error(png_ptr, "chunk data is too large");
    }
 }
 
@@ -3099,7 +3241,7 @@
 #     ifdef PNG_READ_PACKSWAP_SUPPORTED
       if ((png_ptr->transformations & PNG_PACKSWAP) != 0)
          /* little-endian byte */
-         end_mask = 0xff << end_mask;
+         end_mask = (unsigned int)(0xff << end_mask);
 
       else /* big-endian byte */
 #     endif
@@ -3221,7 +3363,7 @@
          /* Hence the pre-compiled masks indexed by PACKSWAP (or not), depth and
           * then pass:
           */
-         static PNG_CONST png_uint_32 row_mask[2/*PACKSWAP*/][3/*depth*/][6] =
+         static const png_uint_32 row_mask[2/*PACKSWAP*/][3/*depth*/][6] =
          {
             /* Little-endian byte masks for PACKSWAP */
             { S_MASKS(1,0), S_MASKS(2,0), S_MASKS(4,0) },
@@ -3232,7 +3374,7 @@
          /* display_mask has only three entries for the odd passes, so index by
           * pass>>1.
           */
-         static PNG_CONST png_uint_32 display_mask[2][3][3] =
+         static const png_uint_32 display_mask[2][3][3] =
          {
             /* Little-endian byte masks for PACKSWAP */
             { B_MASKS(1,0), B_MASKS(2,0), B_MASKS(4,0) },
@@ -3373,7 +3515,7 @@
                 */
                do
                {
-                  dp[0] = sp[0], dp[1] = sp[1];
+                  dp[0] = sp[0]; dp[1] = sp[1];
 
                   if (row_width <= bytes_to_jump)
                      return;
@@ -3394,7 +3536,7 @@
                 */
                for (;;)
                {
-                  dp[0] = sp[0], dp[1] = sp[1], dp[2] = sp[2];
+                  dp[0] = sp[0]; dp[1] = sp[1]; dp[2] = sp[2];
 
                   if (row_width <= bytes_to_jump)
                      return;
@@ -3545,7 +3687,7 @@
 {
    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
    /* Offset to next interlace block */
-   static PNG_CONST int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
+   static const unsigned int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
 
    png_debug(1, "in png_do_read_interlace");
    if (row != NULL && row_info != NULL)
@@ -3558,11 +3700,12 @@
       {
          case 1:
          {
-            png_bytep sp = row + (png_size_t)((row_info->width - 1) >> 3);
-            png_bytep dp = row + (png_size_t)((final_width - 1) >> 3);
-            int sshift, dshift;
-            int s_start, s_end, s_inc;
-            int jstop = png_pass_inc[pass];
+            png_bytep sp = row + (size_t)((row_info->width - 1) >> 3);
+            png_bytep dp = row + (size_t)((final_width - 1) >> 3);
+            unsigned int sshift, dshift;
+            unsigned int s_start, s_end;
+            int s_inc;
+            int jstop = (int)png_pass_inc[pass];
             png_byte v;
             png_uint_32 i;
             int j;
@@ -3570,8 +3713,8 @@
 #ifdef PNG_READ_PACKSWAP_SUPPORTED
             if ((transformations & PNG_PACKSWAP) != 0)
             {
-                sshift = (int)((row_info->width + 7) & 0x07);
-                dshift = (int)((final_width + 7) & 0x07);
+                sshift = ((row_info->width + 7) & 0x07);
+                dshift = ((final_width + 7) & 0x07);
                 s_start = 7;
                 s_end = 0;
                 s_inc = -1;
@@ -3580,8 +3723,8 @@
             else
 #endif
             {
-                sshift = 7 - (int)((row_info->width + 7) & 0x07);
-                dshift = 7 - (int)((final_width + 7) & 0x07);
+                sshift = 7 - ((row_info->width + 7) & 0x07);
+                dshift = 7 - ((final_width + 7) & 0x07);
                 s_start = 0;
                 s_end = 7;
                 s_inc = 1;
@@ -3593,7 +3736,7 @@
                for (j = 0; j < jstop; j++)
                {
                   unsigned int tmp = *dp & (0x7f7f >> (7 - dshift));
-                  tmp |= v << dshift;
+                  tmp |= (unsigned int)(v << dshift);
                   *dp = (png_byte)(tmp & 0xff);
 
                   if (dshift == s_end)
@@ -3603,7 +3746,7 @@
                   }
 
                   else
-                     dshift += s_inc;
+                     dshift = (unsigned int)((int)dshift + s_inc);
                }
 
                if (sshift == s_end)
@@ -3613,7 +3756,7 @@
                }
 
                else
-                  sshift += s_inc;
+                  sshift = (unsigned int)((int)sshift + s_inc);
             }
             break;
          }
@@ -3622,16 +3765,17 @@
          {
             png_bytep sp = row + (png_uint_32)((row_info->width - 1) >> 2);
             png_bytep dp = row + (png_uint_32)((final_width - 1) >> 2);
-            int sshift, dshift;
-            int s_start, s_end, s_inc;
-            int jstop = png_pass_inc[pass];
+            unsigned int sshift, dshift;
+            unsigned int s_start, s_end;
+            int s_inc;
+            int jstop = (int)png_pass_inc[pass];
             png_uint_32 i;
 
 #ifdef PNG_READ_PACKSWAP_SUPPORTED
             if ((transformations & PNG_PACKSWAP) != 0)
             {
-               sshift = (int)(((row_info->width + 3) & 0x03) << 1);
-               dshift = (int)(((final_width + 3) & 0x03) << 1);
+               sshift = (((row_info->width + 3) & 0x03) << 1);
+               dshift = (((final_width + 3) & 0x03) << 1);
                s_start = 6;
                s_end = 0;
                s_inc = -2;
@@ -3640,8 +3784,8 @@
             else
 #endif
             {
-               sshift = (int)((3 - ((row_info->width + 3) & 0x03)) << 1);
-               dshift = (int)((3 - ((final_width + 3) & 0x03)) << 1);
+               sshift = ((3 - ((row_info->width + 3) & 0x03)) << 1);
+               dshift = ((3 - ((final_width + 3) & 0x03)) << 1);
                s_start = 0;
                s_end = 6;
                s_inc = 2;
@@ -3656,7 +3800,7 @@
                for (j = 0; j < jstop; j++)
                {
                   unsigned int tmp = *dp & (0x3f3f >> (6 - dshift));
-                  tmp |= v << dshift;
+                  tmp |= (unsigned int)(v << dshift);
                   *dp = (png_byte)(tmp & 0xff);
 
                   if (dshift == s_end)
@@ -3666,7 +3810,7 @@
                   }
 
                   else
-                     dshift += s_inc;
+                     dshift = (unsigned int)((int)dshift + s_inc);
                }
 
                if (sshift == s_end)
@@ -3676,25 +3820,26 @@
                }
 
                else
-                  sshift += s_inc;
+                  sshift = (unsigned int)((int)sshift + s_inc);
             }
             break;
          }
 
          case 4:
          {
-            png_bytep sp = row + (png_size_t)((row_info->width - 1) >> 1);
-            png_bytep dp = row + (png_size_t)((final_width - 1) >> 1);
-            int sshift, dshift;
-            int s_start, s_end, s_inc;
+            png_bytep sp = row + (size_t)((row_info->width - 1) >> 1);
+            png_bytep dp = row + (size_t)((final_width - 1) >> 1);
+            unsigned int sshift, dshift;
+            unsigned int s_start, s_end;
+            int s_inc;
             png_uint_32 i;
-            int jstop = png_pass_inc[pass];
+            int jstop = (int)png_pass_inc[pass];
 
 #ifdef PNG_READ_PACKSWAP_SUPPORTED
             if ((transformations & PNG_PACKSWAP) != 0)
             {
-               sshift = (int)(((row_info->width + 1) & 0x01) << 2);
-               dshift = (int)(((final_width + 1) & 0x01) << 2);
+               sshift = (((row_info->width + 1) & 0x01) << 2);
+               dshift = (((final_width + 1) & 0x01) << 2);
                s_start = 4;
                s_end = 0;
                s_inc = -4;
@@ -3703,8 +3848,8 @@
             else
 #endif
             {
-               sshift = (int)((1 - ((row_info->width + 1) & 0x01)) << 2);
-               dshift = (int)((1 - ((final_width + 1) & 0x01)) << 2);
+               sshift = ((1 - ((row_info->width + 1) & 0x01)) << 2);
+               dshift = ((1 - ((final_width + 1) & 0x01)) << 2);
                s_start = 0;
                s_end = 4;
                s_inc = 4;
@@ -3718,7 +3863,7 @@
                for (j = 0; j < jstop; j++)
                {
                   unsigned int tmp = *dp & (0xf0f >> (4 - dshift));
-                  tmp |= v << dshift;
+                  tmp |= (unsigned int)(v << dshift);
                   *dp = (png_byte)(tmp & 0xff);
 
                   if (dshift == s_end)
@@ -3728,7 +3873,7 @@
                   }
 
                   else
-                     dshift += s_inc;
+                     dshift = (unsigned int)((int)dshift + s_inc);
                }
 
                if (sshift == s_end)
@@ -3738,21 +3883,21 @@
                }
 
                else
-                  sshift += s_inc;
+                  sshift = (unsigned int)((int)sshift + s_inc);
             }
             break;
          }
 
          default:
          {
-            png_size_t pixel_bytes = (row_info->pixel_depth >> 3);
+            size_t pixel_bytes = (row_info->pixel_depth >> 3);
 
-            png_bytep sp = row + (png_size_t)(row_info->width - 1)
+            png_bytep sp = row + (size_t)(row_info->width - 1)
                 * pixel_bytes;
 
-            png_bytep dp = row + (png_size_t)(final_width - 1) * pixel_bytes;
+            png_bytep dp = row + (size_t)(final_width - 1) * pixel_bytes;
 
-            int jstop = png_pass_inc[pass];
+            int jstop = (int)png_pass_inc[pass];
             png_uint_32 i;
 
             for (i = 0; i < row_info->width; i++)
@@ -3787,8 +3932,8 @@
 png_read_filter_row_sub(png_row_infop row_info, png_bytep row,
     png_const_bytep prev_row)
 {
-   png_size_t i;
-   png_size_t istop = row_info->rowbytes;
+   size_t i;
+   size_t istop = row_info->rowbytes;
    unsigned int bpp = (row_info->pixel_depth + 7) >> 3;
    png_bytep rp = row + bpp;
 
@@ -3805,8 +3950,8 @@
 png_read_filter_row_up(png_row_infop row_info, png_bytep row,
     png_const_bytep prev_row)
 {
-   png_size_t i;
-   png_size_t istop = row_info->rowbytes;
+   size_t i;
+   size_t istop = row_info->rowbytes;
    png_bytep rp = row;
    png_const_bytep pp = prev_row;
 
@@ -3821,11 +3966,11 @@
 png_read_filter_row_avg(png_row_infop row_info, png_bytep row,
     png_const_bytep prev_row)
 {
-   png_size_t i;
+   size_t i;
    png_bytep rp = row;
    png_const_bytep pp = prev_row;
    unsigned int bpp = (row_info->pixel_depth + 7) >> 3;
-   png_size_t istop = row_info->rowbytes - bpp;
+   size_t istop = row_info->rowbytes - bpp;
 
    for (i = 0; i < bpp; i++)
    {
@@ -3880,7 +4025,10 @@
       /* Find the best predictor, the least of pa, pb, pc favoring the earlier
        * ones in the case of a tie.
        */
-      if (pb < pa) pa = pb, a = b;
+      if (pb < pa)
+      {
+         pa = pb; a = b;
+      }
       if (pc < pa) a = c;
 
       /* Calculate the current pixel in a, and move the previous row pixel to c
@@ -3896,7 +4044,7 @@
 png_read_filter_row_paeth_multibyte_pixel(png_row_infop row_info, png_bytep row,
     png_const_bytep prev_row)
 {
-   int bpp = (row_info->pixel_depth + 7) >> 3;
+   unsigned int bpp = (row_info->pixel_depth + 7) >> 3;
    png_bytep rp_end = row + bpp;
 
    /* Process the first pixel in the row completely (this is the same as 'up'
@@ -3909,7 +4057,7 @@
    }
 
    /* Remainder */
-   rp_end += row_info->rowbytes - bpp;
+   rp_end = rp_end + (row_info->rowbytes - bpp);
 
    while (row < rp_end)
    {
@@ -3932,7 +4080,10 @@
       pc = (p + pc) < 0 ? -(p + pc) : p + pc;
 #endif
 
-      if (pb < pa) pa = pb, a = b;
+      if (pb < pa)
+      {
+         pa = pb; a = b;
+      }
       if (pc < pa) a = c;
 
       a += *row;
@@ -4178,16 +4329,16 @@
    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
 
    /* Start of interlace block */
-   static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
+   static const png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
 
    /* Offset to next interlace block */
-   static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
+   static const png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
 
    /* Start of interlace block in the y direction */
-   static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
+   static const png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
 
    /* Offset to next interlace block in the y direction */
-   static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
+   static const png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
 
    png_debug(1, "in png_read_finish_row");
    png_ptr->row_number++;
@@ -4243,19 +4394,19 @@
    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
 
    /* Start of interlace block */
-   static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
+   static const png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
 
    /* Offset to next interlace block */
-   static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
+   static const png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
 
    /* Start of interlace block in the y direction */
-   static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
+   static const png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
 
    /* Offset to next interlace block in the y direction */
-   static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
+   static const png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
 
-   int max_pixel_depth;
-   png_size_t row_bytes;
+   unsigned int max_pixel_depth;
+   size_t row_bytes;
 
    png_debug(1, "in png_read_start_row");
 
@@ -4283,7 +4434,7 @@
       png_ptr->iwidth = png_ptr->width;
    }
 
-   max_pixel_depth = png_ptr->pixel_depth;
+   max_pixel_depth = (unsigned int)png_ptr->pixel_depth;
 
    /* WARNING: * png_read_transform_info (pngrtran.c) performs a simpler set of
     * calculations to calculate the final pixel depth, then
@@ -4418,7 +4569,7 @@
 defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
    if ((png_ptr->transformations & PNG_USER_TRANSFORM) != 0)
    {
-      int user_pixel_depth = png_ptr->user_transform_depth *
+      unsigned int user_pixel_depth = png_ptr->user_transform_depth *
          png_ptr->user_transform_channels;
 
       if (user_pixel_depth > max_pixel_depth)
@@ -4440,7 +4591,7 @@
     * for safety's sake
     */
    row_bytes = PNG_ROWBYTES(max_pixel_depth, row_bytes) +
-       1 + ((max_pixel_depth + 7) >> 3);
+       1 + ((max_pixel_depth + 7) >> 3U);
 
 #ifdef PNG_MAX_MALLOC_64K
    if (row_bytes > (png_uint_32)65536L)
@@ -4471,14 +4622,13 @@
        */
       {
          png_bytep temp = png_ptr->big_row_buf + 32;
-         int extra = (int)((temp - (png_bytep)0) & 0x0f);
+         size_t extra = (size_t)temp & 0x0f;
          png_ptr->row_buf = temp - extra - 1/*filter byte*/;
 
          temp = png_ptr->big_prev_row + 32;
-         extra = (int)((temp - (png_bytep)0) & 0x0f);
+         extra = (size_t)temp & 0x0f;
          png_ptr->prev_row = temp - extra - 1/*filter byte*/;
       }
-
 #else
       /* Use 31 bytes of padding before and 17 bytes after row_buf. */
       png_ptr->row_buf = png_ptr->big_row_buf + 31;
@@ -4509,7 +4659,7 @@
     * does not, so free the read buffer now regardless; the sequential reader
     * reallocates it on demand.
     */
-   if (png_ptr->read_buffer != 0)
+   if (png_ptr->read_buffer != NULL)
    {
       png_bytep buffer = png_ptr->read_buffer;
 
Index: libpng-src/libpng/png.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/png.c b/libpng-src/libpng/png.c
--- a/libpng-src/libpng/png.c	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/png.c	(date 1690795574122)
@@ -1,10 +1,10 @@
 
 /* png.c - location for general purpose libpng functions
  *
- * Last changed in libpng 1.6.25 [September 1, 2016]
- * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ * Copyright (c) 2018-2023 Cosmin Truta
+ * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson
+ * Copyright (c) 1996-1997 Andreas Dilger
+ * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
@@ -14,7 +14,27 @@
 #include "pngpriv.h"
 
 /* Generate a compiler error if there is an old png.h in the search path. */
-typedef png_libpng_version_1_6_25 Your_png_h_is_not_version_1_6_25;
+typedef png_libpng_version_1_6_40 Your_png_h_is_not_version_1_6_40;
+
+#ifdef __GNUC__
+/* The version tests may need to be added to, but the problem warning has
+ * consistently been fixed in GCC versions which obtain wide-spread release.
+ * The problem is that many versions of GCC rearrange comparison expressions in
+ * the optimizer in such a way that the results of the comparison will change
+ * if signed integer overflow occurs.  Such comparisons are not permitted in
+ * ANSI C90, however GCC isn't clever enough to work out that that do not occur
+ * below in png_ascii_from_fp and png_muldiv, so it produces a warning with
+ * -Wextra.  Unfortunately this is highly dependent on the optimizer and the
+ * machine architecture so the warning comes and goes unpredictably and is
+ * impossible to "fix", even were that a good idea.
+ */
+#if __GNUC__ == 7 && __GNUC_MINOR__ == 1
+#define GCC_STRICT_OVERFLOW 1
+#endif /* GNU 7.1.x */
+#endif /* GNU */
+#ifndef GCC_STRICT_OVERFLOW
+#define GCC_STRICT_OVERFLOW 0
+#endif
 
 /* Tells libpng that we have already handled the first "num_bytes" bytes
  * of the PNG file signature.  If the PNG data is embedded into another
@@ -51,7 +71,7 @@
  * PNG signature (this is the same behavior as strcmp, memcmp, etc).
  */
 int PNGAPI
-png_sig_cmp(png_const_bytep sig, png_size_t start, png_size_t num_to_check)
+png_sig_cmp(png_const_bytep sig, size_t start, size_t num_to_check)
 {
    png_byte png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};
 
@@ -116,7 +136,7 @@
  * trouble of calculating it.
  */
 void /* PRIVATE */
-png_calculate_crc(png_structrp png_ptr, png_const_bytep ptr, png_size_t length)
+png_calculate_crc(png_structrp png_ptr, png_const_bytep ptr, size_t length)
 {
    int need_crc = 1;
 
@@ -401,7 +421,7 @@
  * those cases where it does anything other than a memset.
  */
 PNG_FUNCTION(void,PNGAPI
-png_info_init_3,(png_infopp ptr_ptr, png_size_t png_info_struct_size),
+png_info_init_3,(png_infopp ptr_ptr, size_t png_info_struct_size),
     PNG_DEPRECATED)
 {
    png_inforp info_ptr = *ptr_ptr;
@@ -458,7 +478,7 @@
 
 #ifdef PNG_TEXT_SUPPORTED
    /* Free text item num or (if num == -1) all text items */
-   if (info_ptr->text != 0 &&
+   if (info_ptr->text != NULL &&
        ((mask & PNG_FREE_TEXT) & info_ptr->free_me) != 0)
    {
       if (num != -1)
@@ -477,6 +497,7 @@
          png_free(png_ptr, info_ptr->text);
          info_ptr->text = NULL;
          info_ptr->num_text = 0;
+         info_ptr->max_text = 0;
       }
    }
 #endif
@@ -541,7 +562,7 @@
 
 #ifdef PNG_sPLT_SUPPORTED
    /* Free a given sPLT entry, or (if num == -1) all sPLT entries */
-   if (info_ptr->splt_palettes != 0 &&
+   if (info_ptr->splt_palettes != NULL &&
        ((mask & PNG_FREE_SPLT) & info_ptr->free_me) != 0)
    {
       if (num != -1)
@@ -571,7 +592,7 @@
 #endif
 
 #ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
-   if (info_ptr->unknown_chunks != 0 &&
+   if (info_ptr->unknown_chunks != NULL &&
        ((mask & PNG_FREE_UNKN) & info_ptr->free_me) != 0)
    {
       if (num != -1)
@@ -594,6 +615,26 @@
    }
 #endif
 
+#ifdef PNG_eXIf_SUPPORTED
+   /* Free any eXIf entry */
+   if (((mask & PNG_FREE_EXIF) & info_ptr->free_me) != 0)
+   {
+# ifdef PNG_READ_eXIf_SUPPORTED
+      if (info_ptr->eXIf_buf)
+      {
+         png_free(png_ptr, info_ptr->eXIf_buf);
+         info_ptr->eXIf_buf = NULL;
+      }
+# endif
+      if (info_ptr->exif)
+      {
+         png_free(png_ptr, info_ptr->exif);
+         info_ptr->exif = NULL;
+      }
+      info_ptr->valid &= ~PNG_INFO_eXIf;
+   }
+#endif
+
 #ifdef PNG_hIST_SUPPORTED
    /* Free any hIST entry */
    if (((mask & PNG_FREE_HIST) & info_ptr->free_me) != 0)
@@ -617,7 +658,7 @@
    /* Free any image bits attached to the info structure */
    if (((mask & PNG_FREE_ROWS) & info_ptr->free_me) != 0)
    {
-      if (info_ptr->row_pointers != 0)
+      if (info_ptr->row_pointers != NULL)
       {
          png_uint_32 row;
          for (row = 0; row < info_ptr->height; row++)
@@ -679,12 +720,12 @@
  *
  * Where UNSIGNED_MAX is the appropriate maximum unsigned value, so when the
  * negative integral value is added the result will be an unsigned value
- * correspnding to the 2's complement representation.
+ * corresponding to the 2's complement representation.
  */
 void PNGAPI
 png_save_int_32(png_bytep buf, png_int_32 i)
 {
-   png_save_uint_32(buf, i);
+   png_save_uint_32(buf, (png_uint_32)i);
 }
 #  endif
 
@@ -695,7 +736,7 @@
 int PNGAPI
 png_convert_to_rfc1123_buffer(char out[29], png_const_timep ptime)
 {
-   static PNG_CONST char short_months[12][4] =
+   static const char short_months[12][4] =
         {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
          "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
 
@@ -773,20 +814,14 @@
 #ifdef PNG_STRING_COPYRIGHT
    return PNG_STRING_COPYRIGHT
 #else
-#  ifdef __STDC__
    return PNG_STRING_NEWLINE \
-      "libpng version 1.6.25 - September 1, 2016" PNG_STRING_NEWLINE \
-      "Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson" \
+      "libpng version 1.6.40" PNG_STRING_NEWLINE \
+      "Copyright (c) 2018-2023 Cosmin Truta" PNG_STRING_NEWLINE \
+      "Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson" \
       PNG_STRING_NEWLINE \
       "Copyright (c) 1996-1997 Andreas Dilger" PNG_STRING_NEWLINE \
       "Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc." \
       PNG_STRING_NEWLINE;
-#  else
-   return "libpng version 1.6.25 - September 1, 2016\
-      Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson\
-      Copyright (c) 1996-1997 Andreas Dilger\
-      Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.";
-#  endif
 #endif
 }
 
@@ -901,7 +936,7 @@
 
    /* The code is the fifth byte after each four byte string.  Historically this
     * code was always searched from the end of the list, this is no longer
-    * necessary because the 'set' routine handles duplicate entries correcty.
+    * necessary because the 'set' routine handles duplicate entries correctly.
     */
    do /* num_chunk_list > 0, so at least one */
    {
@@ -1080,7 +1115,7 @@
     png_colorspacerp colorspace, png_fixed_point gAMA)
 {
    /* Changed in libpng-1.5.4 to limit the values to ensure overflow can't
-    * occur.  Since the fixed point representation is asymetrical it is
+    * occur.  Since the fixed point representation is asymmetrical it is
     * possible for 1/gamma to overflow the limit of 21474 and this means the
     * gamma value must be at least 5/100000 and hence at most 20000.0.  For
     * safety the limits here are a little narrower.  The values are 0.00016 to
@@ -1808,12 +1843,12 @@
 #  ifdef PNG_WARNINGS_SUPPORTED
    else
       {
-         char number[PNG_NUMBER_BUFFER_SIZE]; /* +24 = 114*/
+         char number[PNG_NUMBER_BUFFER_SIZE]; /* +24 = 114 */
 
          pos = png_safecat(message, (sizeof message), pos,
              png_format_number(number, number+(sizeof number),
              PNG_NUMBER_FORMAT_x, value));
-         pos = png_safecat(message, (sizeof message), pos, "h: "); /*+2 = 116*/
+         pos = png_safecat(message, (sizeof message), pos, "h: "); /* +2 = 116 */
       }
 #  endif
    /* The 'reason' is an arbitrary message, allow +79 maximum 195 */
@@ -1872,12 +1907,12 @@
     */
    if (intent < 0 || intent >= PNG_sRGB_INTENT_LAST)
       return png_icc_profile_error(png_ptr, colorspace, "sRGB",
-          (unsigned)intent, "invalid sRGB rendering intent");
+          (png_alloc_size_t)intent, "invalid sRGB rendering intent");
 
    if ((colorspace->flags & PNG_COLORSPACE_HAVE_INTENT) != 0 &&
        colorspace->rendering_intent != intent)
       return png_icc_profile_error(png_ptr, colorspace, "sRGB",
-         (unsigned)intent, "inconsistent rendering intents");
+         (png_alloc_size_t)intent, "inconsistent rendering intents");
 
    if ((colorspace->flags & PNG_COLORSPACE_FROM_sRGB) != 0)
    {
@@ -1938,7 +1973,6 @@
    if (profile_length < 132)
       return png_icc_profile_error(png_ptr, colorspace, name, profile_length,
           "too short");
-
    return 1;
 }
 
@@ -2027,7 +2061,7 @@
     */
 
    /* Data checks (could be skipped).  These checks must be independent of the
-    * version number; however, the version number doesn't accomodate changes in
+    * version number; however, the version number doesn't accommodate changes in
     * the header fields (just the known tags and the interpretation of the
     * data.)
     */
@@ -2183,22 +2217,23 @@
        * being in range.  All defined tag types have an 8 byte header - a 4 byte
        * type signature then 0.
        */
+
+      /* This is a hard error; potentially it can cause read outside the
+       * profile.
+       */
+      if (tag_start > profile_length || tag_length > profile_length - tag_start)
+         return png_icc_profile_error(png_ptr, colorspace, name, tag_id,
+             "ICC profile tag outside profile");
+
       if ((tag_start & 3) != 0)
       {
-         /* CNHP730S.icc shipped with Microsoft Windows 64 violates this, it is
+         /* CNHP730S.icc shipped with Microsoft Windows 64 violates this; it is
           * only a warning here because libpng does not care about the
           * alignment.
           */
          (void)png_icc_profile_error(png_ptr, NULL, name, tag_id,
              "ICC profile tag start not a multiple of 4");
       }
-
-      /* This is a hard error; potentially it can cause read outside the
-       * profile.
-       */
-      if (tag_start > profile_length || tag_length > profile_length - tag_start)
-         return png_icc_profile_error(png_ptr, colorspace, name, tag_id,
-             "ICC profile tag outside profile");
    }
 
    return 1; /* success, maybe with warnings */
@@ -2529,7 +2564,7 @@
       error = 1;
    }
 
-   if (png_gt(((width + 7) & (~7)),
+   if (png_gt(((width + 7) & (~7U)),
        ((PNG_SIZE_MAX
            - 48        /* big_row_buf hack */
            - 1)        /* filter byte */
@@ -2666,7 +2701,7 @@
 
 #if defined(PNG_sCAL_SUPPORTED) || defined(PNG_pCAL_SUPPORTED)
 /* ASCII to fp functions */
-/* Check an ASCII formated floating point value, see the more detailed
+/* Check an ASCII formatted floating point value, see the more detailed
  * comments in pngpriv.h
  */
 /* The following is used internally to preserve the sticky flags */
@@ -2674,11 +2709,11 @@
 #define png_fp_set(state, value) ((state) = (value) | ((state) & PNG_FP_STICKY))
 
 int /* PRIVATE */
-png_check_fp_number(png_const_charp string, png_size_t size, int *statep,
-    png_size_tp whereami)
+png_check_fp_number(png_const_charp string, size_t size, int *statep,
+    size_t *whereami)
 {
    int state = *statep;
-   png_size_t i = *whereami;
+   size_t i = *whereami;
 
    while (i < size)
    {
@@ -2801,10 +2836,10 @@
 
 /* The same but for a complete string. */
 int
-png_check_fp_string(png_const_charp string, png_size_t size)
+png_check_fp_string(png_const_charp string, size_t size)
 {
    int        state=0;
-   png_size_t char_index=0;
+   size_t char_index=0;
 
    if (png_check_fp_number(string, size, &state, &char_index) != 0 &&
       (char_index == size || string[char_index] == 0))
@@ -2831,7 +2866,7 @@
    if (power < 0)
    {
       if (power < DBL_MIN_10_EXP) return 0;
-      recip = 1, power = -power;
+      recip = 1; power = -power;
    }
 
    if (power > 0)
@@ -2856,8 +2891,16 @@
 /* Function to format a floating point value in ASCII with a given
  * precision.
  */
+#if GCC_STRICT_OVERFLOW
+#pragma GCC diagnostic push
+/* The problem arises below with exp_b10, which can never overflow because it
+ * comes, originally, from frexp and is therefore limited to a range which is
+ * typically +/-710 (log2(DBL_MAX)/log2(DBL_MIN)).
+ */
+#pragma GCC diagnostic warning "-Wstrict-overflow=2"
+#endif /* GCC_STRICT_OVERFLOW */
 void /* PRIVATE */
-png_ascii_from_fp(png_const_structrp png_ptr, png_charp ascii, png_size_t size,
+png_ascii_from_fp(png_const_structrp png_ptr, png_charp ascii, size_t size,
     double fp, unsigned int precision)
 {
    /* We use standard functions from math.h, but not printf because
@@ -2909,7 +2952,9 @@
             double test = png_pow10(exp_b10+1);
 
             if (test <= DBL_MAX)
-               ++exp_b10, base = test;
+            {
+               ++exp_b10; base = test;
+            }
 
             else
                break;
@@ -2923,7 +2968,10 @@
           * test on DBL_MAX above.
           */
          fp /= base;
-         while (fp >= 1) fp /= 10, ++exp_b10;
+         while (fp >= 1)
+         {
+            fp /= 10; ++exp_b10;
+         }
 
          /* Because of the code above fp may, at this point, be
           * less than .1, this is ok because the code below can
@@ -2940,7 +2988,7 @@
              */
             if (exp_b10 < 0 && exp_b10 > -3) /* PLUS 3 TOTAL 4 */
             {
-               czero = -exp_b10; /* PLUS 2 digits: TOTAL 3 */
+               czero = 0U-exp_b10; /* PLUS 2 digits: TOTAL 3 */
                exp_b10 = 0;      /* Dot added below before first output. */
             }
             else
@@ -2974,7 +3022,7 @@
                      /* Rounding up to 10, handle that here. */
                      if (czero > 0)
                      {
-                        --czero, d = 1;
+                        --czero; d = 1;
                         if (cdigits == 0) --clead;
                      }
                      else
@@ -2988,7 +3036,7 @@
 
                            else if (ch == 46)
                            {
-                              ch = *--ascii, ++size;
+                              ch = *--ascii; ++size;
                               /* Advance exp_b10 to '1', so that the
                                * decimal point happens after the
                                * previous digit.
@@ -3015,7 +3063,9 @@
                               int ch = *--ascii;
 
                               if (ch == 46)
-                                 ++size, exp_b10 = 1;
+                              {
+                                 ++size; exp_b10 = 1;
+                              }
 
                               /* Else lost a leading zero, so 'exp_b10' is
                                * still ok at (-1)
@@ -3051,21 +3101,26 @@
                       */
                      if (exp_b10 != (-1))
                      {
-                        if (exp_b10 == 0) *ascii++ = 46, --size;
+                        if (exp_b10 == 0)
+                        {
+                           *ascii++ = 46; --size;
+                        }
                         /* PLUS 1: TOTAL 4 */
                         --exp_b10;
                      }
-                     *ascii++ = 48, --czero;
+                     *ascii++ = 48; --czero;
                   }
 
                   if (exp_b10 != (-1))
                   {
                      if (exp_b10 == 0)
-                        *ascii++ = 46, --size; /* counted above */
+                     {
+                        *ascii++ = 46; --size; /* counted above */
+                     }
 
                      --exp_b10;
                   }
-                  *ascii++ = (char)(48 + (int)d), ++cdigits;
+                  *ascii++ = (char)(48 + (int)d); ++cdigits;
                }
             }
             while (cdigits+czero < precision+clead && fp > DBL_MIN);
@@ -3073,11 +3128,11 @@
             /* The total output count (max) is now 4+precision */
 
             /* Check for an exponent, if we don't need one we are
-             * done and just need to terminate the string.  At
-             * this point exp_b10==(-1) is effectively if flag - it got
-             * to '-1' because of the decrement after outputting
-             * the decimal point above (the exponent required is
-             * *not* -1!)
+             * done and just need to terminate the string.  At this
+             * point, exp_b10==(-1) is effectively a flag: it got
+             * to '-1' because of the decrement, after outputting
+             * the decimal point above. (The exponent required is
+             * *not* -1.)
              */
             if (exp_b10 >= (-1) && exp_b10 <= 2)
             {
@@ -3088,7 +3143,7 @@
                 * zeros were *not* output, so this doesn't increase
                 * the output count.
                 */
-               while (--exp_b10 >= 0) *ascii++ = 48;
+               while (exp_b10-- > 0) *ascii++ = 48;
 
                *ascii = 0;
 
@@ -3106,7 +3161,7 @@
              */
             size -= cdigits;
 
-            *ascii++ = 69, --size;    /* 'E': PLUS 1 TOTAL 2+precision */
+            *ascii++ = 69; --size;    /* 'E': PLUS 1 TOTAL 2+precision */
 
             /* The following use of an unsigned temporary avoids ambiguities in
              * the signed arithmetic on exp_b10 and permits GCC at least to do
@@ -3117,12 +3172,12 @@
 
                if (exp_b10 < 0)
                {
-                  *ascii++ = 45, --size; /* '-': PLUS 1 TOTAL 3+precision */
-                  uexp_b10 = -exp_b10;
+                  *ascii++ = 45; --size; /* '-': PLUS 1 TOTAL 3+precision */
+                  uexp_b10 = 0U-exp_b10;
                }
 
                else
-                  uexp_b10 = exp_b10;
+                  uexp_b10 = 0U+exp_b10;
 
                cdigits = 0;
 
@@ -3165,6 +3220,9 @@
    /* Here on buffer too small. */
    png_error(png_ptr, "ASCII conversion buffer too small");
 }
+#if GCC_STRICT_OVERFLOW
+#pragma GCC diagnostic pop
+#endif /* GCC_STRICT_OVERFLOW */
 
 #  endif /* FLOATING_POINT */
 
@@ -3173,7 +3231,7 @@
  */
 void /* PRIVATE */
 png_ascii_from_fixed(png_const_structrp png_ptr, png_charp ascii,
-    png_size_t size, png_fixed_point fp)
+    size_t size, png_fixed_point fp)
 {
    /* Require space for 10 decimal digits, a decimal point, a minus sign and a
     * trailing \0, 13 characters:
@@ -3184,9 +3242,11 @@
 
       /* Avoid overflow here on the minimum integer. */
       if (fp < 0)
-         *ascii++ = 45, num = -fp;
+      {
+         *ascii++ = 45; num = (png_uint_32)(-fp);
+      }
       else
-         num = fp;
+         num = (png_uint_32)fp;
 
       if (num <= 0x80000000) /* else overflowed */
       {
@@ -3222,7 +3282,10 @@
                 * then ndigits digits to first:
                 */
                i = 5;
-               while (ndigits < i) *ascii++ = 48, --i;
+               while (ndigits < i)
+               {
+                  *ascii++ = 48; --i;
+               }
                while (ndigits >= first) *ascii++ = digits[--ndigits];
                /* Don't output the trailing zeros! */
             }
@@ -3273,6 +3336,15 @@
  * the nearest .00001).  Overflow and divide by zero are signalled in
  * the result, a boolean - true on success, false on overflow.
  */
+#if GCC_STRICT_OVERFLOW /* from above */
+/* It is not obvious which comparison below gets optimized in such a way that
+ * signed overflow would change the result; looking through the code does not
+ * reveal any tests which have the form GCC complains about, so presumably the
+ * optimizer is moving an add or subtract into the 'if' somewhere.
+ */
+#pragma GCC diagnostic push
+#pragma GCC diagnostic warning "-Wstrict-overflow=2"
+#endif /* GCC_STRICT_OVERFLOW */
 int
 png_muldiv(png_fixed_point_p res, png_fixed_point a, png_int_32 times,
     png_int_32 divisor)
@@ -3387,6 +3459,9 @@
 
    return 0;
 }
+#if GCC_STRICT_OVERFLOW
+#pragma GCC diagnostic pop
+#endif /* GCC_STRICT_OVERFLOW */
 #endif /* READ_GAMMA || INCH_CONVERSIONS */
 
 #if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_INCH_CONVERSIONS_SUPPORTED)
@@ -3680,7 +3755,7 @@
  * of getting this accuracy in practice.
  *
  * To deal with this the following exp() function works out the exponent of the
- * frational part of the logarithm by using an accurate 32-bit value from the
+ * fractional part of the logarithm by using an accurate 32-bit value from the
  * top four fractional bits then multiplying in the remaining bits.
  */
 static const png_uint_32
@@ -3895,18 +3970,18 @@
  */
 static void
 png_build_16bit_table(png_structrp png_ptr, png_uint_16pp *ptable,
-    PNG_CONST unsigned int shift, PNG_CONST png_fixed_point gamma_val)
+    unsigned int shift, png_fixed_point gamma_val)
 {
    /* Various values derived from 'shift': */
-   PNG_CONST unsigned int num = 1U << (8U - shift);
+   unsigned int num = 1U << (8U - shift);
 #ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
    /* CSE the division and work round wacky GCC warnings (see the comments
     * in png_gamma_8bit_correct for where these come from.)
     */
-   PNG_CONST double fmax = 1./(((png_int_32)1 << (16U - shift))-1);
+   double fmax = 1.0 / (((png_int_32)1 << (16U - shift)) - 1);
 #endif
-   PNG_CONST unsigned int max = (1U << (16U - shift))-1U;
-   PNG_CONST unsigned int max_by_2 = 1U << (15U-shift);
+   unsigned int max = (1U << (16U - shift)) - 1U;
+   unsigned int max_by_2 = 1U << (15U - shift);
    unsigned int i;
 
    png_uint_16pp table = *ptable =
@@ -3972,10 +4047,10 @@
  */
 static void
 png_build_16to8_table(png_structrp png_ptr, png_uint_16pp *ptable,
-    PNG_CONST unsigned int shift, PNG_CONST png_fixed_point gamma_val)
+    unsigned int shift, png_fixed_point gamma_val)
 {
-   PNG_CONST unsigned int num = 1U << (8U - shift);
-   PNG_CONST unsigned int max = (1U << (16U - shift))-1U;
+   unsigned int num = 1U << (8U - shift);
+   unsigned int max = (1U << (16U - shift))-1U;
    unsigned int i;
    png_uint_32 last;
 
@@ -4040,7 +4115,7 @@
  */
 static void
 png_build_8bit_table(png_structrp png_ptr, png_bytepp ptable,
-    PNG_CONST png_fixed_point gamma_val)
+    png_fixed_point gamma_val)
 {
    unsigned int i;
    png_bytep table = *ptable = (png_bytep)png_malloc(png_ptr, 256);
@@ -4259,13 +4334,13 @@
    if (png_ptr != NULL && option >= 0 && option < PNG_OPTION_NEXT &&
       (option & 1) == 0)
    {
-      int mask = 3 << option;
-      int setting = (2 + (onoff != 0)) << option;
-      int current = png_ptr->options;
+      png_uint_32 mask = 3U << option;
+      png_uint_32 setting = (2U + (onoff != 0)) << option;
+      png_uint_32 current = png_ptr->options;
 
-      png_ptr->options = (png_byte)(((current & ~mask) | setting) & 0xff);
+      png_ptr->options = (png_uint_32)((current & ~mask) | setting);
 
-      return (current & mask) >> option;
+      return (int)(current & mask) >> option;
    }
 
    return PNG_OPTION_INVALID;
@@ -4277,7 +4352,7 @@
    defined(PNG_SIMPLIFIED_WRITE_SUPPORTED)
 /* sRGB conversion tables; these are machine generated with the code in
  * contrib/tools/makesRGB.c.  The actual sRGB transfer curve defined in the
- * specification (see the article at http://en.wikipedia.org/wiki/SRGB)
+ * specification (see the article at https://en.wikipedia.org/wiki/SRGB)
  * is used, not the gamma=1/2.2 approximation use elsewhere in libpng.
  * The sRGB to linear table is exact (to the nearest 16-bit linear fraction).
  * The inverse (linear to sRGB) table has accuracies as follows:
@@ -4513,8 +4588,7 @@
    if (image != NULL && image->opaque != NULL &&
       image->opaque->error_buf == NULL)
    {
-      /* Ignore errors here: */
-      (void)png_safe_execute(image, png_image_free_function, image);
+      png_image_free_function(image);
       image->opaque = NULL;
    }
 }
Index: cairo-src/cairo/src/cairo.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cairo-src/cairo/src/cairo.h b/cairo-src/cairo/src/cairo.h
--- a/cairo-src/cairo/src/cairo.h	(revision c3b672634f0635af1ad0ffa8c15b34fc7c1035cf)
+++ b/cairo-src/cairo/src/cairo.h	(date 1690943504106)
@@ -38,6 +38,7 @@
 #ifndef CAIRO_H
 #define CAIRO_H
 
+#include "cairo_export.h"
 #include "cairo-version.h"
 #include "cairo-features.h"
 #include "cairo-deprecated.h"
@@ -51,11 +52,7 @@
 #endif
 
 #ifndef cairo_public
-# if defined (_MSC_VER) && ! defined (CAIRO_WIN32_STATIC_BUILD)
-#  define cairo_public __declspec(dllimport)
-# else
-#  define cairo_public
-# endif
+#define cairo_public CAIRO_EXPORT
 #endif
 
 CAIRO_BEGIN_DECLS
Index: libpng-src/libpng/intel/intel_init.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/intel/intel_init.c b/libpng-src/libpng/intel/intel_init.c
new file mode 100644
--- /dev/null	(date 1690795574118)
+++ b/libpng-src/libpng/intel/intel_init.c	(date 1690795574118)
@@ -0,0 +1,52 @@
+
+/* intel_init.c - SSE2 optimized filter functions
+ *
+ * Copyright (c) 2018 Cosmin Truta
+ * Copyright (c) 2016-2017 Glenn Randers-Pehrson
+ * Written by Mike Klein and Matt Sarett, Google, Inc.
+ * Derived from arm/arm_init.c
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ */
+
+#include "../pngpriv.h"
+
+#ifdef PNG_READ_SUPPORTED
+#if PNG_INTEL_SSE_IMPLEMENTATION > 0
+
+void
+png_init_filter_functions_sse2(png_structp pp, unsigned int bpp)
+{
+   /* The techniques used to implement each of these filters in SSE operate on
+    * one pixel at a time.
+    * So they generally speed up 3bpp images about 3x, 4bpp images about 4x.
+    * They can scale up to 6 and 8 bpp images and down to 2 bpp images,
+    * but they'd not likely have any benefit for 1bpp images.
+    * Most of these can be implemented using only MMX and 64-bit registers,
+    * but they end up a bit slower than using the equally-ubiquitous SSE2.
+   */
+   png_debug(1, "in png_init_filter_functions_sse2");
+   if (bpp == 3)
+   {
+      pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub3_sse2;
+      pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg3_sse2;
+      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =
+         png_read_filter_row_paeth3_sse2;
+   }
+   else if (bpp == 4)
+   {
+      pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub4_sse2;
+      pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg4_sse2;
+      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =
+          png_read_filter_row_paeth4_sse2;
+   }
+
+   /* No need optimize PNG_FILTER_VALUE_UP.  The compiler should
+    * autovectorize.
+    */
+}
+
+#endif /* PNG_INTEL_SSE_IMPLEMENTATION > 0 */
+#endif /* PNG_READ_SUPPORTED */
Index: cairo-src/cairo/src/cairo-ps-surface.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cairo-src/cairo/src/cairo-ps-surface.c b/cairo-src/cairo/src/cairo-ps-surface.c
--- a/cairo-src/cairo/src/cairo-ps-surface.c	(revision c3b672634f0635af1ad0ffa8c15b34fc7c1035cf)
+++ b/cairo-src/cairo/src/cairo-ps-surface.c	(date 1689048275294)
@@ -102,7 +102,7 @@
 #define DEBUG_FALLBACK(s)
 #endif
 
-#ifndef HAVE_CTIME_R
+#if !defined(HAVE_CTIME_R) && !defined(unix)
 static char *ctime_r(const time_t *timep, char *buf)
 {
     (void)buf;
Index: libpng-src/libpng/pngrtran.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/pngrtran.c b/libpng-src/libpng/pngrtran.c
--- a/libpng-src/libpng/pngrtran.c	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/pngrtran.c	(date 1690795574122)
@@ -1,10 +1,10 @@
 
 /* pngrtran.c - transforms the data in a row for PNG readers
  *
- * Last changed in libpng 1.6.24 [August 4, 2016]
- * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ * Copyright (c) 2018-2019 Cosmin Truta
+ * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson
+ * Copyright (c) 1996-1997 Andreas Dilger
+ * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
@@ -18,6 +18,17 @@
 
 #include "pngpriv.h"
 
+#ifdef PNG_ARM_NEON_IMPLEMENTATION
+#  if PNG_ARM_NEON_IMPLEMENTATION == 1
+#    define PNG_ARM_NEON_INTRINSICS_AVAILABLE
+#    if defined(_MSC_VER) && !defined(__clang__) && defined(_M_ARM64)
+#      include <arm64_neon.h>
+#    else
+#      include <arm_neon.h>
+#    endif
+#  endif
+#endif
+
 #ifdef PNG_READ_SUPPORTED
 
 /* Set the action on getting a CRC error for an ancillary or critical chunk. */
@@ -49,6 +60,7 @@
       case PNG_CRC_WARN_DISCARD:    /* Not a valid action for critical data */
          png_warning(png_ptr,
              "Can't discard critical data on CRC error");
+         /* FALLTHROUGH */
       case PNG_CRC_ERROR_QUIT:                                /* Error/quit */
 
       case PNG_CRC_DEFAULT:
@@ -291,7 +303,7 @@
     * who use the inverse of the gamma value accidentally!  Since some of these
     * values are reasonable this may have to be changed:
     *
-    * 1.6.x: changed from 0.07..3 to 0.01..100 (to accomodate the optimal 16-bit
+    * 1.6.x: changed from 0.07..3 to 0.01..100 (to accommodate the optimal 16-bit
     * gamma of 36, and its reciprocal.)
     */
    if (output_gamma < 1000 || output_gamma > 10000000)
@@ -429,7 +441,7 @@
       int i;
 
       png_ptr->quantize_index = (png_bytep)png_malloc(png_ptr,
-          (png_uint_32)(num_palette * (sizeof (png_byte))));
+          (png_alloc_size_t)((png_uint_32)num_palette * (sizeof (png_byte))));
       for (i = 0; i < num_palette; i++)
          png_ptr->quantize_index[i] = (png_byte)i;
    }
@@ -446,7 +458,7 @@
 
          /* Initialize an array to sort colors */
          png_ptr->quantize_sort = (png_bytep)png_malloc(png_ptr,
-             (png_uint_32)(num_palette * (sizeof (png_byte))));
+             (png_alloc_size_t)((png_uint_32)num_palette * (sizeof (png_byte))));
 
          /* Initialize the quantize_sort array */
          for (i = 0; i < num_palette; i++)
@@ -580,9 +592,11 @@
 
          /* Initialize palette index arrays */
          png_ptr->index_to_palette = (png_bytep)png_malloc(png_ptr,
-             (png_uint_32)(num_palette * (sizeof (png_byte))));
+             (png_alloc_size_t)((png_uint_32)num_palette *
+             (sizeof (png_byte))));
          png_ptr->palette_to_index = (png_bytep)png_malloc(png_ptr,
-             (png_uint_32)(num_palette * (sizeof (png_byte))));
+             (png_alloc_size_t)((png_uint_32)num_palette *
+             (sizeof (png_byte))));
 
          /* Initialize the sort array */
          for (i = 0; i < num_palette; i++)
@@ -591,7 +605,7 @@
             png_ptr->palette_to_index[i] = (png_byte)i;
          }
 
-         hash = (png_dsortpp)png_calloc(png_ptr, (png_uint_32)(769 *
+         hash = (png_dsortpp)png_calloc(png_ptr, (png_alloc_size_t)(769 *
              (sizeof (png_dsortp))));
 
          num_new_palette = num_palette;
@@ -622,7 +636,7 @@
                   {
 
                      t = (png_dsortp)png_malloc_warn(png_ptr,
-                         (png_uint_32)(sizeof (png_dsort)));
+                         (png_alloc_size_t)(sizeof (png_dsort)));
 
                      if (t == NULL)
                          break;
@@ -744,12 +758,12 @@
       int num_red = (1 << PNG_QUANTIZE_RED_BITS);
       int num_green = (1 << PNG_QUANTIZE_GREEN_BITS);
       int num_blue = (1 << PNG_QUANTIZE_BLUE_BITS);
-      png_size_t num_entries = ((png_size_t)1 << total_bits);
+      size_t num_entries = ((size_t)1 << total_bits);
 
       png_ptr->palette_lookup = (png_bytep)png_calloc(png_ptr,
-          (png_uint_32)(num_entries * (sizeof (png_byte))));
+          (png_alloc_size_t)(num_entries * (sizeof (png_byte))));
 
-      distance = (png_bytep)png_malloc(png_ptr, (png_uint_32)(num_entries *
+      distance = (png_bytep)png_malloc(png_ptr, (png_alloc_size_t)(num_entries *
           (sizeof (png_byte))));
 
       memset(distance, 0xff, num_entries * (sizeof (png_byte)));
@@ -1168,20 +1182,20 @@
              png_ptr->palette[png_ptr->background.index].blue;
 
 #ifdef PNG_READ_INVERT_ALPHA_SUPPORTED
-        if ((png_ptr->transformations & PNG_INVERT_ALPHA) != 0)
-        {
-           if ((png_ptr->transformations & PNG_EXPAND_tRNS) == 0)
-           {
-              /* Invert the alpha channel (in tRNS) unless the pixels are
-               * going to be expanded, in which case leave it for later
-               */
-              int i, istop = png_ptr->num_trans;
+         if ((png_ptr->transformations & PNG_INVERT_ALPHA) != 0)
+         {
+            if ((png_ptr->transformations & PNG_EXPAND_tRNS) == 0)
+            {
+               /* Invert the alpha channel (in tRNS) unless the pixels are
+                * going to be expanded, in which case leave it for later
+                */
+               int i, istop = png_ptr->num_trans;
 
-              for (i=0; i<istop; i++)
-                 png_ptr->trans_alpha[i] = (png_byte)(255 -
-                    png_ptr->trans_alpha[i]);
-           }
-        }
+               for (i = 0; i < istop; i++)
+                  png_ptr->trans_alpha[i] =
+                      (png_byte)(255 - png_ptr->trans_alpha[i]);
+            }
+         }
 #endif /* READ_INVERT_ALPHA */
       }
    } /* background expand and (therefore) no alpha association. */
@@ -1253,7 +1267,7 @@
             default:
 
             case 8:
-               /* FALL THROUGH (Already 8 bits) */
+               /* FALLTHROUGH */ /*  (Already 8 bits) */
 
             case 16:
                /* Already a full 16 bits */
@@ -1314,7 +1328,7 @@
 
       else if (png_ptr->screen_gamma != 0)
          /* The converse - assume the file matches the screen, note that this
-          * perhaps undesireable default can (from 1.5.4) be changed by calling
+          * perhaps undesirable default can (from 1.5.4) be changed by calling
           * png_set_alpha_mode (even if the alpha handling mode isn't required
           * or isn't changed from the default.)
           */
@@ -1882,7 +1896,7 @@
 
       png_ptr->transformations &= ~PNG_SHIFT;
 
-      /* significant bits can be in the range 1 to 7 for a meaninful result, if
+      /* significant bits can be in the range 1 to 7 for a meaningful result, if
        * the number of significant bits is 0 then no shift is done (this is an
        * error condition which is silently ignored.)
        */
@@ -2148,9 +2162,9 @@
       {
          case 1:
          {
-            png_bytep sp = row + (png_size_t)((row_width - 1) >> 3);
-            png_bytep dp = row + (png_size_t)row_width - 1;
-            png_uint_32 shift = 7 - (int)((row_width + 7) & 0x07);
+            png_bytep sp = row + (size_t)((row_width - 1) >> 3);
+            png_bytep dp = row + (size_t)row_width - 1;
+            png_uint_32 shift = 7U - ((row_width + 7U) & 0x07);
             for (i = 0; i < row_width; i++)
             {
                *dp = (png_byte)((*sp >> shift) & 0x01);
@@ -2172,9 +2186,9 @@
          case 2:
          {
 
-            png_bytep sp = row + (png_size_t)((row_width - 1) >> 2);
-            png_bytep dp = row + (png_size_t)row_width - 1;
-            png_uint_32 shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
+            png_bytep sp = row + (size_t)((row_width - 1) >> 2);
+            png_bytep dp = row + (size_t)row_width - 1;
+            png_uint_32 shift = ((3U - ((row_width + 3U) & 0x03)) << 1);
             for (i = 0; i < row_width; i++)
             {
                *dp = (png_byte)((*sp >> shift) & 0x03);
@@ -2195,9 +2209,9 @@
 
          case 4:
          {
-            png_bytep sp = row + (png_size_t)((row_width - 1) >> 1);
-            png_bytep dp = row + (png_size_t)row_width - 1;
-            png_uint_32 shift = (int)((1 - ((row_width + 1) & 0x01)) << 2);
+            png_bytep sp = row + (size_t)((row_width - 1) >> 1);
+            png_bytep dp = row + (size_t)row_width - 1;
+            png_uint_32 shift = ((1U - ((row_width + 1U) & 0x01)) << 2);
             for (i = 0; i < row_width; i++)
             {
                *dp = (png_byte)((*sp >> shift) & 0x0f);
@@ -2460,95 +2474,94 @@
 static void
 png_do_read_swap_alpha(png_row_infop row_info, png_bytep row)
 {
+   png_uint_32 row_width = row_info->width;
+
    png_debug(1, "in png_do_read_swap_alpha");
 
-   {
-      png_uint_32 row_width = row_info->width;
-      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
-      {
-         /* This converts from RGBA to ARGB */
-         if (row_info->bit_depth == 8)
-         {
-            png_bytep sp = row + row_info->rowbytes;
-            png_bytep dp = sp;
-            png_byte save;
-            png_uint_32 i;
+   if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
+   {
+      /* This converts from RGBA to ARGB */
+      if (row_info->bit_depth == 8)
+      {
+         png_bytep sp = row + row_info->rowbytes;
+         png_bytep dp = sp;
+         png_byte save;
+         png_uint_32 i;
 
-            for (i = 0; i < row_width; i++)
-            {
-               save = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = save;
-            }
-         }
+         for (i = 0; i < row_width; i++)
+         {
+            save = *(--sp);
+            *(--dp) = *(--sp);
+            *(--dp) = *(--sp);
+            *(--dp) = *(--sp);
+            *(--dp) = save;
+         }
+      }
 
 #ifdef PNG_READ_16BIT_SUPPORTED
-         /* This converts from RRGGBBAA to AARRGGBB */
-         else
-         {
-            png_bytep sp = row + row_info->rowbytes;
-            png_bytep dp = sp;
-            png_byte save[2];
-            png_uint_32 i;
+      /* This converts from RRGGBBAA to AARRGGBB */
+      else
+      {
+         png_bytep sp = row + row_info->rowbytes;
+         png_bytep dp = sp;
+         png_byte save[2];
+         png_uint_32 i;
 
-            for (i = 0; i < row_width; i++)
-            {
-               save[0] = *(--sp);
-               save[1] = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = save[0];
-               *(--dp) = save[1];
-            }
-         }
+         for (i = 0; i < row_width; i++)
+         {
+            save[0] = *(--sp);
+            save[1] = *(--sp);
+            *(--dp) = *(--sp);
+            *(--dp) = *(--sp);
+            *(--dp) = *(--sp);
+            *(--dp) = *(--sp);
+            *(--dp) = *(--sp);
+            *(--dp) = *(--sp);
+            *(--dp) = save[0];
+            *(--dp) = save[1];
+         }
+      }
 #endif
-      }
+   }
 
-      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
-      {
-         /* This converts from GA to AG */
-         if (row_info->bit_depth == 8)
-         {
-            png_bytep sp = row + row_info->rowbytes;
-            png_bytep dp = sp;
-            png_byte save;
-            png_uint_32 i;
+   else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
+   {
+      /* This converts from GA to AG */
+      if (row_info->bit_depth == 8)
+      {
+         png_bytep sp = row + row_info->rowbytes;
+         png_bytep dp = sp;
+         png_byte save;
+         png_uint_32 i;
 
-            for (i = 0; i < row_width; i++)
-            {
-               save = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = save;
-            }
-         }
+         for (i = 0; i < row_width; i++)
+         {
+            save = *(--sp);
+            *(--dp) = *(--sp);
+            *(--dp) = save;
+         }
+      }
 
 #ifdef PNG_READ_16BIT_SUPPORTED
-         /* This converts from GGAA to AAGG */
-         else
-         {
-            png_bytep sp = row + row_info->rowbytes;
-            png_bytep dp = sp;
-            png_byte save[2];
-            png_uint_32 i;
+      /* This converts from GGAA to AAGG */
+      else
+      {
+         png_bytep sp = row + row_info->rowbytes;
+         png_bytep dp = sp;
+         png_byte save[2];
+         png_uint_32 i;
 
-            for (i = 0; i < row_width; i++)
-            {
-               save[0] = *(--sp);
-               save[1] = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = *(--sp);
-               *(--dp) = save[0];
-               *(--dp) = save[1];
-            }
-         }
+         for (i = 0; i < row_width; i++)
+         {
+            save[0] = *(--sp);
+            save[1] = *(--sp);
+            *(--dp) = *(--sp);
+            *(--dp) = *(--sp);
+            *(--dp) = save[0];
+            *(--dp) = save[1];
+         }
+      }
 #endif
-      }
    }
 }
 #endif
@@ -2678,8 +2691,8 @@
          if ((flags & PNG_FLAG_FILLER_AFTER) != 0)
          {
             /* This changes the data from G to GX */
-            png_bytep sp = row + (png_size_t)row_width;
-            png_bytep dp =  sp + (png_size_t)row_width;
+            png_bytep sp = row + (size_t)row_width;
+            png_bytep dp =  sp + (size_t)row_width;
             for (i = 1; i < row_width; i++)
             {
                *(--dp) = lo_filler;
@@ -2694,8 +2707,8 @@
          else
          {
             /* This changes the data from G to XG */
-            png_bytep sp = row + (png_size_t)row_width;
-            png_bytep dp = sp  + (png_size_t)row_width;
+            png_bytep sp = row + (size_t)row_width;
+            png_bytep dp = sp  + (size_t)row_width;
             for (i = 0; i < row_width; i++)
             {
                *(--dp) = *(--sp);
@@ -2713,8 +2726,8 @@
          if ((flags & PNG_FLAG_FILLER_AFTER) != 0)
          {
             /* This changes the data from GG to GGXX */
-            png_bytep sp = row + (png_size_t)row_width * 2;
-            png_bytep dp = sp  + (png_size_t)row_width * 2;
+            png_bytep sp = row + (size_t)row_width * 2;
+            png_bytep dp = sp  + (size_t)row_width * 2;
             for (i = 1; i < row_width; i++)
             {
                *(--dp) = lo_filler;
@@ -2732,8 +2745,8 @@
          else
          {
             /* This changes the data from GG to XXGG */
-            png_bytep sp = row + (png_size_t)row_width * 2;
-            png_bytep dp = sp  + (png_size_t)row_width * 2;
+            png_bytep sp = row + (size_t)row_width * 2;
+            png_bytep dp = sp  + (size_t)row_width * 2;
             for (i = 0; i < row_width; i++)
             {
                *(--dp) = *(--sp);
@@ -2755,8 +2768,8 @@
          if ((flags & PNG_FLAG_FILLER_AFTER) != 0)
          {
             /* This changes the data from RGB to RGBX */
-            png_bytep sp = row + (png_size_t)row_width * 3;
-            png_bytep dp = sp  + (png_size_t)row_width;
+            png_bytep sp = row + (size_t)row_width * 3;
+            png_bytep dp = sp  + (size_t)row_width;
             for (i = 1; i < row_width; i++)
             {
                *(--dp) = lo_filler;
@@ -2773,8 +2786,8 @@
          else
          {
             /* This changes the data from RGB to XRGB */
-            png_bytep sp = row + (png_size_t)row_width * 3;
-            png_bytep dp = sp + (png_size_t)row_width;
+            png_bytep sp = row + (size_t)row_width * 3;
+            png_bytep dp = sp + (size_t)row_width;
             for (i = 0; i < row_width; i++)
             {
                *(--dp) = *(--sp);
@@ -2794,8 +2807,8 @@
          if ((flags & PNG_FLAG_FILLER_AFTER) != 0)
          {
             /* This changes the data from RRGGBB to RRGGBBXX */
-            png_bytep sp = row + (png_size_t)row_width * 6;
-            png_bytep dp = sp  + (png_size_t)row_width * 2;
+            png_bytep sp = row + (size_t)row_width * 6;
+            png_bytep dp = sp  + (size_t)row_width * 2;
             for (i = 1; i < row_width; i++)
             {
                *(--dp) = lo_filler;
@@ -2817,8 +2830,8 @@
          else
          {
             /* This changes the data from RRGGBB to XXRRGGBB */
-            png_bytep sp = row + (png_size_t)row_width * 6;
-            png_bytep dp = sp  + (png_size_t)row_width * 2;
+            png_bytep sp = row + (size_t)row_width * 6;
+            png_bytep dp = sp  + (size_t)row_width * 2;
             for (i = 0; i < row_width; i++)
             {
                *(--dp) = *(--sp);
@@ -2859,8 +2872,8 @@
          if (row_info->bit_depth == 8)
          {
             /* This changes G to RGB */
-            png_bytep sp = row + (png_size_t)row_width - 1;
-            png_bytep dp = sp  + (png_size_t)row_width * 2;
+            png_bytep sp = row + (size_t)row_width - 1;
+            png_bytep dp = sp  + (size_t)row_width * 2;
             for (i = 0; i < row_width; i++)
             {
                *(dp--) = *sp;
@@ -2872,8 +2885,8 @@
          else
          {
             /* This changes GG to RRGGBB */
-            png_bytep sp = row + (png_size_t)row_width * 2 - 1;
-            png_bytep dp = sp  + (png_size_t)row_width * 4;
+            png_bytep sp = row + (size_t)row_width * 2 - 1;
+            png_bytep dp = sp  + (size_t)row_width * 4;
             for (i = 0; i < row_width; i++)
             {
                *(dp--) = *sp;
@@ -2891,8 +2904,8 @@
          if (row_info->bit_depth == 8)
          {
             /* This changes GA to RGBA */
-            png_bytep sp = row + (png_size_t)row_width * 2 - 1;
-            png_bytep dp = sp  + (png_size_t)row_width * 2;
+            png_bytep sp = row + (size_t)row_width * 2 - 1;
+            png_bytep dp = sp  + (size_t)row_width * 2;
             for (i = 0; i < row_width; i++)
             {
                *(dp--) = *(sp--);
@@ -2905,8 +2918,8 @@
          else
          {
             /* This changes GGAA to RRGGBBAA */
-            png_bytep sp = row + (png_size_t)row_width * 4 - 1;
-            png_bytep dp = sp  + (png_size_t)row_width * 4;
+            png_bytep sp = row + (size_t)row_width * 4 - 1;
+            png_bytep dp = sp  + (size_t)row_width * 4;
             for (i = 0; i < row_width; i++)
             {
                *(dp--) = *(sp--);
@@ -2934,7 +2947,7 @@
  * using the equation given in Poynton's ColorFAQ of 1998-01-04 at
  * <http://www.inforamp.net/~poynton/>  (THIS LINK IS DEAD June 2008 but
  * versions dated 1998 through November 2002 have been archived at
- * http://web.archive.org/web/20000816232553/http://www.inforamp.net/
+ * https://web.archive.org/web/20000816232553/www.inforamp.net/
  * ~poynton/notes/colour_and_gamma/ColorFAQ.txt )
  * Charles Poynton poynton at poynton.com
  *
@@ -2977,14 +2990,13 @@
  *  values this results in an implicit assumption that the original PNG RGB
  *  values were linear.
  *
- *  Other integer coefficents can be used via png_set_rgb_to_gray().  Because
+ *  Other integer coefficients can be used via png_set_rgb_to_gray().  Because
  *  the API takes just red and green coefficients the blue coefficient is
  *  calculated to make the sum 32768.  This will result in different rounding
  *  to that used above.
  */
 static int
 png_do_rgb_to_gray(png_structrp png_ptr, png_row_infop row_info, png_bytep row)
-
 {
    int rgb_error = 0;
 
@@ -2993,12 +3005,11 @@
    if ((row_info->color_type & PNG_COLOR_MASK_PALETTE) == 0 &&
        (row_info->color_type & PNG_COLOR_MASK_COLOR) != 0)
    {
-      PNG_CONST png_uint_32 rc = png_ptr->rgb_to_gray_red_coeff;
-      PNG_CONST png_uint_32 gc = png_ptr->rgb_to_gray_green_coeff;
-      PNG_CONST png_uint_32 bc = 32768 - rc - gc;
-      PNG_CONST png_uint_32 row_width = row_info->width;
-      PNG_CONST int have_alpha =
-         (row_info->color_type & PNG_COLOR_MASK_ALPHA) != 0;
+      png_uint_32 rc = png_ptr->rgb_to_gray_red_coeff;
+      png_uint_32 gc = png_ptr->rgb_to_gray_green_coeff;
+      png_uint_32 bc = 32768 - rc - gc;
+      png_uint_32 row_width = row_info->width;
+      int have_alpha = (row_info->color_type & PNG_COLOR_MASK_ALPHA) != 0;
 
       if (row_info->bit_depth == 8)
       {
@@ -3206,715 +3217,718 @@
 
    png_debug(1, "in png_do_compose");
 
-   {
-      switch (row_info->color_type)
-      {
-         case PNG_COLOR_TYPE_GRAY:
-         {
-            switch (row_info->bit_depth)
-            {
-               case 1:
-               {
-                  sp = row;
-                  shift = 7;
-                  for (i = 0; i < row_width; i++)
-                  {
-                     if ((png_uint_16)((*sp >> shift) & 0x01)
-                        == png_ptr->trans_color.gray)
-                     {
-                        unsigned int tmp = *sp & (0x7f7f >> (7 - shift));
-                        tmp |= png_ptr->background.gray << shift;
-                        *sp = (png_byte)(tmp & 0xff);
-                     }
+   switch (row_info->color_type)
+   {
+      case PNG_COLOR_TYPE_GRAY:
+      {
+         switch (row_info->bit_depth)
+         {
+            case 1:
+            {
+               sp = row;
+               shift = 7;
+               for (i = 0; i < row_width; i++)
+               {
+                  if ((png_uint_16)((*sp >> shift) & 0x01)
+                     == png_ptr->trans_color.gray)
+                  {
+                     unsigned int tmp = *sp & (0x7f7f >> (7 - shift));
+                     tmp |=
+                         (unsigned int)(png_ptr->background.gray << shift);
+                     *sp = (png_byte)(tmp & 0xff);
+                  }
 
-                     if (shift == 0)
-                     {
-                        shift = 7;
-                        sp++;
-                     }
+                  if (shift == 0)
+                  {
+                     shift = 7;
+                     sp++;
+                  }
 
-                     else
-                        shift--;
-                  }
-                  break;
-               }
+                  else
+                     shift--;
+               }
+               break;
+            }
 
-               case 2:
-               {
+            case 2:
+            {
 #ifdef PNG_READ_GAMMA_SUPPORTED
-                  if (gamma_table != NULL)
-                  {
-                     sp = row;
-                     shift = 6;
-                     for (i = 0; i < row_width; i++)
-                     {
-                        if ((png_uint_16)((*sp >> shift) & 0x03)
-                            == png_ptr->trans_color.gray)
-                        {
-                           unsigned int tmp = *sp & (0x3f3f >> (6 - shift));
-                           tmp |= png_ptr->background.gray << shift;
-                           *sp = (png_byte)(tmp & 0xff);
-                        }
+               if (gamma_table != NULL)
+               {
+                  sp = row;
+                  shift = 6;
+                  for (i = 0; i < row_width; i++)
+                  {
+                     if ((png_uint_16)((*sp >> shift) & 0x03)
+                         == png_ptr->trans_color.gray)
+                     {
+                        unsigned int tmp = *sp & (0x3f3f >> (6 - shift));
+                        tmp |=
+                           (unsigned int)png_ptr->background.gray << shift;
+                        *sp = (png_byte)(tmp & 0xff);
+                     }
 
-                        else
-                        {
-                           unsigned int p = (*sp >> shift) & 0x03;
-                           unsigned int g = (gamma_table [p | (p << 2) |
-                               (p << 4) | (p << 6)] >> 6) & 0x03;
-                           unsigned int tmp = *sp & (0x3f3f >> (6 - shift));
-                           tmp |= g << shift;
-                           *sp = (png_byte)(tmp & 0xff);
-                        }
+                     else
+                     {
+                        unsigned int p = (*sp >> shift) & 0x03;
+                        unsigned int g = (gamma_table [p | (p << 2) |
+                            (p << 4) | (p << 6)] >> 6) & 0x03;
+                        unsigned int tmp = *sp & (0x3f3f >> (6 - shift));
+                        tmp |= (unsigned int)(g << shift);
+                        *sp = (png_byte)(tmp & 0xff);
+                     }
 
-                        if (shift == 0)
-                        {
-                           shift = 6;
-                           sp++;
-                        }
+                     if (shift == 0)
+                     {
+                        shift = 6;
+                        sp++;
+                     }
 
-                        else
-                           shift -= 2;
-                     }
-                  }
+                     else
+                        shift -= 2;
+                  }
+               }
 
-                  else
+               else
 #endif
-                  {
-                     sp = row;
-                     shift = 6;
-                     for (i = 0; i < row_width; i++)
-                     {
-                        if ((png_uint_16)((*sp >> shift) & 0x03)
-                            == png_ptr->trans_color.gray)
-                        {
-                           unsigned int tmp = *sp & (0x3f3f >> (6 - shift));
-                           tmp |= png_ptr->background.gray << shift;
-                           *sp = (png_byte)(tmp & 0xff);
-                        }
+               {
+                  sp = row;
+                  shift = 6;
+                  for (i = 0; i < row_width; i++)
+                  {
+                     if ((png_uint_16)((*sp >> shift) & 0x03)
+                         == png_ptr->trans_color.gray)
+                     {
+                        unsigned int tmp = *sp & (0x3f3f >> (6 - shift));
+                        tmp |=
+                            (unsigned int)png_ptr->background.gray << shift;
+                        *sp = (png_byte)(tmp & 0xff);
+                     }
 
-                        if (shift == 0)
-                        {
-                           shift = 6;
-                           sp++;
-                        }
+                     if (shift == 0)
+                     {
+                        shift = 6;
+                        sp++;
+                     }
 
-                        else
-                           shift -= 2;
-                     }
-                  }
-                  break;
-               }
+                     else
+                        shift -= 2;
+                  }
+               }
+               break;
+            }
 
-               case 4:
-               {
+            case 4:
+            {
 #ifdef PNG_READ_GAMMA_SUPPORTED
-                  if (gamma_table != NULL)
-                  {
-                     sp = row;
-                     shift = 4;
-                     for (i = 0; i < row_width; i++)
-                     {
-                        if ((png_uint_16)((*sp >> shift) & 0x0f)
-                            == png_ptr->trans_color.gray)
-                        {
-                           unsigned int tmp = *sp & (0x0f0f >> (4 - shift));
-                           tmp |= png_ptr->background.gray << shift;
-                           *sp = (png_byte)(tmp & 0xff);
-                        }
+               if (gamma_table != NULL)
+               {
+                  sp = row;
+                  shift = 4;
+                  for (i = 0; i < row_width; i++)
+                  {
+                     if ((png_uint_16)((*sp >> shift) & 0x0f)
+                         == png_ptr->trans_color.gray)
+                     {
+                        unsigned int tmp = *sp & (0x0f0f >> (4 - shift));
+                        tmp |=
+                           (unsigned int)(png_ptr->background.gray << shift);
+                        *sp = (png_byte)(tmp & 0xff);
+                     }
 
-                        else
-                        {
-                           unsigned int p = (*sp >> shift) & 0x0f;
-                           unsigned int g = (gamma_table[p | (p << 4)] >> 4) &
-                              0x0f;
-                           unsigned int tmp = *sp & (0x0f0f >> (4 - shift));
-                           tmp |= g << shift;
-                           *sp = (png_byte)(tmp & 0xff);
-                        }
+                     else
+                     {
+                        unsigned int p = (*sp >> shift) & 0x0f;
+                        unsigned int g = (gamma_table[p | (p << 4)] >> 4) &
+                           0x0f;
+                        unsigned int tmp = *sp & (0x0f0f >> (4 - shift));
+                        tmp |= (unsigned int)(g << shift);
+                        *sp = (png_byte)(tmp & 0xff);
+                     }
 
-                        if (shift == 0)
-                        {
-                           shift = 4;
-                           sp++;
-                        }
+                     if (shift == 0)
+                     {
+                        shift = 4;
+                        sp++;
+                     }
 
-                        else
-                           shift -= 4;
-                     }
-                  }
+                     else
+                        shift -= 4;
+                  }
+               }
 
-                  else
+               else
 #endif
-                  {
-                     sp = row;
-                     shift = 4;
-                     for (i = 0; i < row_width; i++)
-                     {
-                        if ((png_uint_16)((*sp >> shift) & 0x0f)
-                            == png_ptr->trans_color.gray)
-                        {
-                           unsigned int tmp = *sp & (0x0f0f >> (4 - shift));
-                           tmp |= png_ptr->background.gray << shift;
-                           *sp = (png_byte)(tmp & 0xff);
-                        }
+               {
+                  sp = row;
+                  shift = 4;
+                  for (i = 0; i < row_width; i++)
+                  {
+                     if ((png_uint_16)((*sp >> shift) & 0x0f)
+                         == png_ptr->trans_color.gray)
+                     {
+                        unsigned int tmp = *sp & (0x0f0f >> (4 - shift));
+                        tmp |=
+                           (unsigned int)(png_ptr->background.gray << shift);
+                        *sp = (png_byte)(tmp & 0xff);
+                     }
 
-                        if (shift == 0)
-                        {
-                           shift = 4;
-                           sp++;
-                        }
+                     if (shift == 0)
+                     {
+                        shift = 4;
+                        sp++;
+                     }
 
-                        else
-                           shift -= 4;
-                     }
-                  }
-                  break;
-               }
+                     else
+                        shift -= 4;
+                  }
+               }
+               break;
+            }
 
-               case 8:
-               {
+            case 8:
+            {
 #ifdef PNG_READ_GAMMA_SUPPORTED
-                  if (gamma_table != NULL)
-                  {
-                     sp = row;
-                     for (i = 0; i < row_width; i++, sp++)
-                     {
-                        if (*sp == png_ptr->trans_color.gray)
-                           *sp = (png_byte)png_ptr->background.gray;
+               if (gamma_table != NULL)
+               {
+                  sp = row;
+                  for (i = 0; i < row_width; i++, sp++)
+                  {
+                     if (*sp == png_ptr->trans_color.gray)
+                        *sp = (png_byte)png_ptr->background.gray;
 
-                        else
-                           *sp = gamma_table[*sp];
-                     }
-                  }
-                  else
+                     else
+                        *sp = gamma_table[*sp];
+                  }
+               }
+               else
 #endif
-                  {
-                     sp = row;
-                     for (i = 0; i < row_width; i++, sp++)
-                     {
-                        if (*sp == png_ptr->trans_color.gray)
-                           *sp = (png_byte)png_ptr->background.gray;
-                     }
-                  }
-                  break;
-               }
+               {
+                  sp = row;
+                  for (i = 0; i < row_width; i++, sp++)
+                  {
+                     if (*sp == png_ptr->trans_color.gray)
+                        *sp = (png_byte)png_ptr->background.gray;
+                  }
+               }
+               break;
+            }
 
-               case 16:
-               {
+            case 16:
+            {
 #ifdef PNG_READ_GAMMA_SUPPORTED
-                  if (gamma_16 != NULL)
-                  {
-                     sp = row;
-                     for (i = 0; i < row_width; i++, sp += 2)
-                     {
-                        png_uint_16 v;
+               if (gamma_16 != NULL)
+               {
+                  sp = row;
+                  for (i = 0; i < row_width; i++, sp += 2)
+                  {
+                     png_uint_16 v;
 
-                        v = (png_uint_16)(((*sp) << 8) + *(sp + 1));
+                     v = (png_uint_16)(((*sp) << 8) + *(sp + 1));
 
-                        if (v == png_ptr->trans_color.gray)
-                        {
-                           /* Background is already in screen gamma */
-                           *sp = (png_byte)((png_ptr->background.gray >> 8)
-                                & 0xff);
-                           *(sp + 1) = (png_byte)(png_ptr->background.gray
-                                & 0xff);
-                        }
+                     if (v == png_ptr->trans_color.gray)
+                     {
+                        /* Background is already in screen gamma */
+                        *sp = (png_byte)((png_ptr->background.gray >> 8)
+                             & 0xff);
+                        *(sp + 1) = (png_byte)(png_ptr->background.gray
+                             & 0xff);
+                     }
 
-                        else
-                        {
-                           v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
-                           *sp = (png_byte)((v >> 8) & 0xff);
-                           *(sp + 1) = (png_byte)(v & 0xff);
-                        }
-                     }
-                  }
-                  else
+                     else
+                     {
+                        v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
+                        *sp = (png_byte)((v >> 8) & 0xff);
+                        *(sp + 1) = (png_byte)(v & 0xff);
+                     }
+                  }
+               }
+               else
 #endif
-                  {
-                     sp = row;
-                     for (i = 0; i < row_width; i++, sp += 2)
-                     {
-                        png_uint_16 v;
+               {
+                  sp = row;
+                  for (i = 0; i < row_width; i++, sp += 2)
+                  {
+                     png_uint_16 v;
 
-                        v = (png_uint_16)(((*sp) << 8) + *(sp + 1));
+                     v = (png_uint_16)(((*sp) << 8) + *(sp + 1));
 
-                        if (v == png_ptr->trans_color.gray)
-                        {
-                           *sp = (png_byte)((png_ptr->background.gray >> 8)
-                                & 0xff);
-                           *(sp + 1) = (png_byte)(png_ptr->background.gray
-                                & 0xff);
-                        }
-                     }
-                  }
-                  break;
-               }
+                     if (v == png_ptr->trans_color.gray)
+                     {
+                        *sp = (png_byte)((png_ptr->background.gray >> 8)
+                             & 0xff);
+                        *(sp + 1) = (png_byte)(png_ptr->background.gray
+                             & 0xff);
+                     }
+                  }
+               }
+               break;
+            }
 
-               default:
-                  break;
-            }
-            break;
-         }
+            default:
+               break;
+         }
+         break;
+      }
 
-         case PNG_COLOR_TYPE_RGB:
-         {
-            if (row_info->bit_depth == 8)
-            {
+      case PNG_COLOR_TYPE_RGB:
+      {
+         if (row_info->bit_depth == 8)
+         {
 #ifdef PNG_READ_GAMMA_SUPPORTED
-               if (gamma_table != NULL)
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 3)
-                  {
-                     if (*sp == png_ptr->trans_color.red &&
-                         *(sp + 1) == png_ptr->trans_color.green &&
-                         *(sp + 2) == png_ptr->trans_color.blue)
-                     {
-                        *sp = (png_byte)png_ptr->background.red;
-                        *(sp + 1) = (png_byte)png_ptr->background.green;
-                        *(sp + 2) = (png_byte)png_ptr->background.blue;
-                     }
+            if (gamma_table != NULL)
+            {
+               sp = row;
+               for (i = 0; i < row_width; i++, sp += 3)
+               {
+                  if (*sp == png_ptr->trans_color.red &&
+                      *(sp + 1) == png_ptr->trans_color.green &&
+                      *(sp + 2) == png_ptr->trans_color.blue)
+                  {
+                     *sp = (png_byte)png_ptr->background.red;
+                     *(sp + 1) = (png_byte)png_ptr->background.green;
+                     *(sp + 2) = (png_byte)png_ptr->background.blue;
+                  }
 
-                     else
-                     {
-                        *sp = gamma_table[*sp];
-                        *(sp + 1) = gamma_table[*(sp + 1)];
-                        *(sp + 2) = gamma_table[*(sp + 2)];
-                     }
-                  }
-               }
-               else
+                  else
+                  {
+                     *sp = gamma_table[*sp];
+                     *(sp + 1) = gamma_table[*(sp + 1)];
+                     *(sp + 2) = gamma_table[*(sp + 2)];
+                  }
+               }
+            }
+            else
 #endif
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 3)
-                  {
-                     if (*sp == png_ptr->trans_color.red &&
-                         *(sp + 1) == png_ptr->trans_color.green &&
-                         *(sp + 2) == png_ptr->trans_color.blue)
-                     {
-                        *sp = (png_byte)png_ptr->background.red;
-                        *(sp + 1) = (png_byte)png_ptr->background.green;
-                        *(sp + 2) = (png_byte)png_ptr->background.blue;
-                     }
-                  }
-               }
-            }
-            else /* if (row_info->bit_depth == 16) */
-            {
+            {
+               sp = row;
+               for (i = 0; i < row_width; i++, sp += 3)
+               {
+                  if (*sp == png_ptr->trans_color.red &&
+                      *(sp + 1) == png_ptr->trans_color.green &&
+                      *(sp + 2) == png_ptr->trans_color.blue)
+                  {
+                     *sp = (png_byte)png_ptr->background.red;
+                     *(sp + 1) = (png_byte)png_ptr->background.green;
+                     *(sp + 2) = (png_byte)png_ptr->background.blue;
+                  }
+               }
+            }
+         }
+         else /* if (row_info->bit_depth == 16) */
+         {
 #ifdef PNG_READ_GAMMA_SUPPORTED
-               if (gamma_16 != NULL)
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 6)
-                  {
-                     png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));
+            if (gamma_16 != NULL)
+            {
+               sp = row;
+               for (i = 0; i < row_width; i++, sp += 6)
+               {
+                  png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));
 
-                     png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)
-                         + *(sp + 3));
+                  png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)
+                      + *(sp + 3));
 
-                     png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)
-                         + *(sp + 5));
+                  png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)
+                      + *(sp + 5));
 
-                     if (r == png_ptr->trans_color.red &&
-                         g == png_ptr->trans_color.green &&
-                         b == png_ptr->trans_color.blue)
-                     {
-                        /* Background is already in screen gamma */
-                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
-                        *(sp + 2) = (png_byte)((png_ptr->background.green >> 8)
-                                & 0xff);
-                        *(sp + 3) = (png_byte)(png_ptr->background.green
-                                & 0xff);
-                        *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8)
-                                & 0xff);
-                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
-                     }
+                  if (r == png_ptr->trans_color.red &&
+                      g == png_ptr->trans_color.green &&
+                      b == png_ptr->trans_color.blue)
+                  {
+                     /* Background is already in screen gamma */
+                     *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
+                     *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
+                     *(sp + 2) = (png_byte)((png_ptr->background.green >> 8)
+                             & 0xff);
+                     *(sp + 3) = (png_byte)(png_ptr->background.green
+                             & 0xff);
+                     *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8)
+                             & 0xff);
+                     *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
+                  }
 
-                     else
-                     {
-                        png_uint_16 v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
-                        *sp = (png_byte)((v >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(v & 0xff);
+                  else
+                  {
+                     png_uint_16 v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
+                     *sp = (png_byte)((v >> 8) & 0xff);
+                     *(sp + 1) = (png_byte)(v & 0xff);
 
-                        v = gamma_16[*(sp + 3) >> gamma_shift][*(sp + 2)];
-                        *(sp + 2) = (png_byte)((v >> 8) & 0xff);
-                        *(sp + 3) = (png_byte)(v & 0xff);
+                     v = gamma_16[*(sp + 3) >> gamma_shift][*(sp + 2)];
+                     *(sp + 2) = (png_byte)((v >> 8) & 0xff);
+                     *(sp + 3) = (png_byte)(v & 0xff);
 
-                        v = gamma_16[*(sp + 5) >> gamma_shift][*(sp + 4)];
-                        *(sp + 4) = (png_byte)((v >> 8) & 0xff);
-                        *(sp + 5) = (png_byte)(v & 0xff);
-                     }
-                  }
-               }
+                     v = gamma_16[*(sp + 5) >> gamma_shift][*(sp + 4)];
+                     *(sp + 4) = (png_byte)((v >> 8) & 0xff);
+                     *(sp + 5) = (png_byte)(v & 0xff);
+                  }
+               }
+            }
 
-               else
+            else
 #endif
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 6)
-                  {
-                     png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));
+            {
+               sp = row;
+               for (i = 0; i < row_width; i++, sp += 6)
+               {
+                  png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));
 
-                     png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)
-                         + *(sp + 3));
+                  png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)
+                      + *(sp + 3));
 
-                     png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)
-                         + *(sp + 5));
+                  png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)
+                      + *(sp + 5));
 
-                     if (r == png_ptr->trans_color.red &&
-                         g == png_ptr->trans_color.green &&
-                         b == png_ptr->trans_color.blue)
-                     {
-                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
-                        *(sp + 2) = (png_byte)((png_ptr->background.green >> 8)
-                                & 0xff);
-                        *(sp + 3) = (png_byte)(png_ptr->background.green
-                                & 0xff);
-                        *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8)
-                                & 0xff);
-                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
-                     }
-                  }
-               }
-            }
-            break;
-         }
+                  if (r == png_ptr->trans_color.red &&
+                      g == png_ptr->trans_color.green &&
+                      b == png_ptr->trans_color.blue)
+                  {
+                     *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
+                     *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
+                     *(sp + 2) = (png_byte)((png_ptr->background.green >> 8)
+                             & 0xff);
+                     *(sp + 3) = (png_byte)(png_ptr->background.green
+                             & 0xff);
+                     *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8)
+                             & 0xff);
+                     *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
+                  }
+               }
+            }
+         }
+         break;
+      }
 
-         case PNG_COLOR_TYPE_GRAY_ALPHA:
-         {
-            if (row_info->bit_depth == 8)
-            {
+      case PNG_COLOR_TYPE_GRAY_ALPHA:
+      {
+         if (row_info->bit_depth == 8)
+         {
 #ifdef PNG_READ_GAMMA_SUPPORTED
-               if (gamma_to_1 != NULL && gamma_from_1 != NULL &&
-                   gamma_table != NULL)
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 2)
-                  {
-                     png_uint_16 a = *(sp + 1);
+            if (gamma_to_1 != NULL && gamma_from_1 != NULL &&
+                gamma_table != NULL)
+            {
+               sp = row;
+               for (i = 0; i < row_width; i++, sp += 2)
+               {
+                  png_uint_16 a = *(sp + 1);
 
-                     if (a == 0xff)
-                        *sp = gamma_table[*sp];
+                  if (a == 0xff)
+                     *sp = gamma_table[*sp];
 
-                     else if (a == 0)
-                     {
-                        /* Background is already in screen gamma */
-                        *sp = (png_byte)png_ptr->background.gray;
-                     }
+                  else if (a == 0)
+                  {
+                     /* Background is already in screen gamma */
+                     *sp = (png_byte)png_ptr->background.gray;
+                  }
 
-                     else
-                     {
-                        png_byte v, w;
+                  else
+                  {
+                     png_byte v, w;
 
-                        v = gamma_to_1[*sp];
-                        png_composite(w, v, a, png_ptr->background_1.gray);
-                        if (optimize == 0)
-                           w = gamma_from_1[w];
-                        *sp = w;
-                     }
-                  }
-               }
-               else
+                     v = gamma_to_1[*sp];
+                     png_composite(w, v, a, png_ptr->background_1.gray);
+                     if (optimize == 0)
+                        w = gamma_from_1[w];
+                     *sp = w;
+                  }
+               }
+            }
+            else
 #endif
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 2)
-                  {
-                     png_byte a = *(sp + 1);
+            {
+               sp = row;
+               for (i = 0; i < row_width; i++, sp += 2)
+               {
+                  png_byte a = *(sp + 1);
 
-                     if (a == 0)
-                        *sp = (png_byte)png_ptr->background.gray;
+                  if (a == 0)
+                     *sp = (png_byte)png_ptr->background.gray;
 
-                     else if (a < 0xff)
-                        png_composite(*sp, *sp, a, png_ptr->background.gray);
-                  }
-               }
-            }
-            else /* if (png_ptr->bit_depth == 16) */
-            {
+                  else if (a < 0xff)
+                     png_composite(*sp, *sp, a, png_ptr->background.gray);
+               }
+            }
+         }
+         else /* if (png_ptr->bit_depth == 16) */
+         {
 #ifdef PNG_READ_GAMMA_SUPPORTED
-               if (gamma_16 != NULL && gamma_16_from_1 != NULL &&
-                   gamma_16_to_1 != NULL)
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 4)
-                  {
-                     png_uint_16 a = (png_uint_16)(((*(sp + 2)) << 8)
-                         + *(sp + 3));
+            if (gamma_16 != NULL && gamma_16_from_1 != NULL &&
+                gamma_16_to_1 != NULL)
+            {
+               sp = row;
+               for (i = 0; i < row_width; i++, sp += 4)
+               {
+                  png_uint_16 a = (png_uint_16)(((*(sp + 2)) << 8)
+                      + *(sp + 3));
 
-                     if (a == (png_uint_16)0xffff)
-                     {
-                        png_uint_16 v;
+                  if (a == (png_uint_16)0xffff)
+                  {
+                     png_uint_16 v;
 
-                        v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
-                        *sp = (png_byte)((v >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(v & 0xff);
-                     }
+                     v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
+                     *sp = (png_byte)((v >> 8) & 0xff);
+                     *(sp + 1) = (png_byte)(v & 0xff);
+                  }
 
-                     else if (a == 0)
-                     {
-                        /* Background is already in screen gamma */
-                        *sp = (png_byte)((png_ptr->background.gray >> 8)
-                                & 0xff);
-                        *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);
-                     }
+                  else if (a == 0)
+                  {
+                     /* Background is already in screen gamma */
+                     *sp = (png_byte)((png_ptr->background.gray >> 8)
+                             & 0xff);
+                     *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);
+                  }
 
-                     else
-                     {
-                        png_uint_16 g, v, w;
+                  else
+                  {
+                     png_uint_16 g, v, w;
 
-                        g = gamma_16_to_1[*(sp + 1) >> gamma_shift][*sp];
-                        png_composite_16(v, g, a, png_ptr->background_1.gray);
-                        if (optimize != 0)
-                           w = v;
-                        else
-                           w = gamma_16_from_1[(v & 0xff) >>
-                               gamma_shift][v >> 8];
-                        *sp = (png_byte)((w >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(w & 0xff);
-                     }
-                  }
-               }
-               else
+                     g = gamma_16_to_1[*(sp + 1) >> gamma_shift][*sp];
+                     png_composite_16(v, g, a, png_ptr->background_1.gray);
+                     if (optimize != 0)
+                        w = v;
+                     else
+                        w = gamma_16_from_1[(v & 0xff) >>
+                            gamma_shift][v >> 8];
+                     *sp = (png_byte)((w >> 8) & 0xff);
+                     *(sp + 1) = (png_byte)(w & 0xff);
+                  }
+               }
+            }
+            else
 #endif
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 4)
-                  {
-                     png_uint_16 a = (png_uint_16)(((*(sp + 2)) << 8)
-                         + *(sp + 3));
+            {
+               sp = row;
+               for (i = 0; i < row_width; i++, sp += 4)
+               {
+                  png_uint_16 a = (png_uint_16)(((*(sp + 2)) << 8)
+                      + *(sp + 3));
 
-                     if (a == 0)
-                     {
-                        *sp = (png_byte)((png_ptr->background.gray >> 8)
-                                & 0xff);
-                        *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);
-                     }
+                  if (a == 0)
+                  {
+                     *sp = (png_byte)((png_ptr->background.gray >> 8)
+                             & 0xff);
+                     *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);
+                  }
 
-                     else if (a < 0xffff)
-                     {
-                        png_uint_16 g, v;
+                  else if (a < 0xffff)
+                  {
+                     png_uint_16 g, v;
 
-                        g = (png_uint_16)(((*sp) << 8) + *(sp + 1));
-                        png_composite_16(v, g, a, png_ptr->background.gray);
-                        *sp = (png_byte)((v >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(v & 0xff);
-                     }
-                  }
-               }
-            }
-            break;
-         }
+                     g = (png_uint_16)(((*sp) << 8) + *(sp + 1));
+                     png_composite_16(v, g, a, png_ptr->background.gray);
+                     *sp = (png_byte)((v >> 8) & 0xff);
+                     *(sp + 1) = (png_byte)(v & 0xff);
+                  }
+               }
+            }
+         }
+         break;
+      }
 
-         case PNG_COLOR_TYPE_RGB_ALPHA:
-         {
-            if (row_info->bit_depth == 8)
-            {
+      case PNG_COLOR_TYPE_RGB_ALPHA:
+      {
+         if (row_info->bit_depth == 8)
+         {
 #ifdef PNG_READ_GAMMA_SUPPORTED
-               if (gamma_to_1 != NULL && gamma_from_1 != NULL &&
-                   gamma_table != NULL)
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 4)
-                  {
-                     png_byte a = *(sp + 3);
+            if (gamma_to_1 != NULL && gamma_from_1 != NULL &&
+                gamma_table != NULL)
+            {
+               sp = row;
+               for (i = 0; i < row_width; i++, sp += 4)
+               {
+                  png_byte a = *(sp + 3);
 
-                     if (a == 0xff)
-                     {
-                        *sp = gamma_table[*sp];
-                        *(sp + 1) = gamma_table[*(sp + 1)];
-                        *(sp + 2) = gamma_table[*(sp + 2)];
-                     }
+                  if (a == 0xff)
+                  {
+                     *sp = gamma_table[*sp];
+                     *(sp + 1) = gamma_table[*(sp + 1)];
+                     *(sp + 2) = gamma_table[*(sp + 2)];
+                  }
 
-                     else if (a == 0)
-                     {
-                        /* Background is already in screen gamma */
-                        *sp = (png_byte)png_ptr->background.red;
-                        *(sp + 1) = (png_byte)png_ptr->background.green;
-                        *(sp + 2) = (png_byte)png_ptr->background.blue;
-                     }
+                  else if (a == 0)
+                  {
+                     /* Background is already in screen gamma */
+                     *sp = (png_byte)png_ptr->background.red;
+                     *(sp + 1) = (png_byte)png_ptr->background.green;
+                     *(sp + 2) = (png_byte)png_ptr->background.blue;
+                  }
 
-                     else
-                     {
-                        png_byte v, w;
+                  else
+                  {
+                     png_byte v, w;
 
-                        v = gamma_to_1[*sp];
-                        png_composite(w, v, a, png_ptr->background_1.red);
-                        if (optimize == 0) w = gamma_from_1[w];
-                        *sp = w;
+                     v = gamma_to_1[*sp];
+                     png_composite(w, v, a, png_ptr->background_1.red);
+                     if (optimize == 0) w = gamma_from_1[w];
+                     *sp = w;
 
-                        v = gamma_to_1[*(sp + 1)];
-                        png_composite(w, v, a, png_ptr->background_1.green);
-                        if (optimize == 0) w = gamma_from_1[w];
-                        *(sp + 1) = w;
+                     v = gamma_to_1[*(sp + 1)];
+                     png_composite(w, v, a, png_ptr->background_1.green);
+                     if (optimize == 0) w = gamma_from_1[w];
+                     *(sp + 1) = w;
 
-                        v = gamma_to_1[*(sp + 2)];
-                        png_composite(w, v, a, png_ptr->background_1.blue);
-                        if (optimize == 0) w = gamma_from_1[w];
-                        *(sp + 2) = w;
-                     }
-                  }
-               }
-               else
+                     v = gamma_to_1[*(sp + 2)];
+                     png_composite(w, v, a, png_ptr->background_1.blue);
+                     if (optimize == 0) w = gamma_from_1[w];
+                     *(sp + 2) = w;
+                  }
+               }
+            }
+            else
 #endif
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 4)
-                  {
-                     png_byte a = *(sp + 3);
+            {
+               sp = row;
+               for (i = 0; i < row_width; i++, sp += 4)
+               {
+                  png_byte a = *(sp + 3);
 
-                     if (a == 0)
-                     {
-                        *sp = (png_byte)png_ptr->background.red;
-                        *(sp + 1) = (png_byte)png_ptr->background.green;
-                        *(sp + 2) = (png_byte)png_ptr->background.blue;
-                     }
+                  if (a == 0)
+                  {
+                     *sp = (png_byte)png_ptr->background.red;
+                     *(sp + 1) = (png_byte)png_ptr->background.green;
+                     *(sp + 2) = (png_byte)png_ptr->background.blue;
+                  }
 
-                     else if (a < 0xff)
-                     {
-                        png_composite(*sp, *sp, a, png_ptr->background.red);
+                  else if (a < 0xff)
+                  {
+                     png_composite(*sp, *sp, a, png_ptr->background.red);
 
-                        png_composite(*(sp + 1), *(sp + 1), a,
-                            png_ptr->background.green);
+                     png_composite(*(sp + 1), *(sp + 1), a,
+                         png_ptr->background.green);
 
-                        png_composite(*(sp + 2), *(sp + 2), a,
-                            png_ptr->background.blue);
-                     }
-                  }
-               }
-            }
-            else /* if (row_info->bit_depth == 16) */
-            {
+                     png_composite(*(sp + 2), *(sp + 2), a,
+                         png_ptr->background.blue);
+                  }
+               }
+            }
+         }
+         else /* if (row_info->bit_depth == 16) */
+         {
 #ifdef PNG_READ_GAMMA_SUPPORTED
-               if (gamma_16 != NULL && gamma_16_from_1 != NULL &&
-                   gamma_16_to_1 != NULL)
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 8)
-                  {
-                     png_uint_16 a = (png_uint_16)(((png_uint_16)(*(sp + 6))
-                         << 8) + (png_uint_16)(*(sp + 7)));
+            if (gamma_16 != NULL && gamma_16_from_1 != NULL &&
+                gamma_16_to_1 != NULL)
+            {
+               sp = row;
+               for (i = 0; i < row_width; i++, sp += 8)
+               {
+                  png_uint_16 a = (png_uint_16)(((png_uint_16)(*(sp + 6))
+                      << 8) + (png_uint_16)(*(sp + 7)));
 
-                     if (a == (png_uint_16)0xffff)
-                     {
-                        png_uint_16 v;
+                  if (a == (png_uint_16)0xffff)
+                  {
+                     png_uint_16 v;
 
-                        v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
-                        *sp = (png_byte)((v >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(v & 0xff);
+                     v = gamma_16[*(sp + 1) >> gamma_shift][*sp];
+                     *sp = (png_byte)((v >> 8) & 0xff);
+                     *(sp + 1) = (png_byte)(v & 0xff);
 
-                        v = gamma_16[*(sp + 3) >> gamma_shift][*(sp + 2)];
-                        *(sp + 2) = (png_byte)((v >> 8) & 0xff);
-                        *(sp + 3) = (png_byte)(v & 0xff);
+                     v = gamma_16[*(sp + 3) >> gamma_shift][*(sp + 2)];
+                     *(sp + 2) = (png_byte)((v >> 8) & 0xff);
+                     *(sp + 3) = (png_byte)(v & 0xff);
 
-                        v = gamma_16[*(sp + 5) >> gamma_shift][*(sp + 4)];
-                        *(sp + 4) = (png_byte)((v >> 8) & 0xff);
-                        *(sp + 5) = (png_byte)(v & 0xff);
-                     }
+                     v = gamma_16[*(sp + 5) >> gamma_shift][*(sp + 4)];
+                     *(sp + 4) = (png_byte)((v >> 8) & 0xff);
+                     *(sp + 5) = (png_byte)(v & 0xff);
+                  }
 
-                     else if (a == 0)
-                     {
-                        /* Background is already in screen gamma */
-                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
-                        *(sp + 2) = (png_byte)((png_ptr->background.green >> 8)
-                                & 0xff);
-                        *(sp + 3) = (png_byte)(png_ptr->background.green
-                                & 0xff);
-                        *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8)
-                                & 0xff);
-                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
-                     }
+                  else if (a == 0)
+                  {
+                     /* Background is already in screen gamma */
+                     *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
+                     *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
+                     *(sp + 2) = (png_byte)((png_ptr->background.green >> 8)
+                             & 0xff);
+                     *(sp + 3) = (png_byte)(png_ptr->background.green
+                             & 0xff);
+                     *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8)
+                             & 0xff);
+                     *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
+                  }
 
-                     else
-                     {
-                        png_uint_16 v, w;
+                  else
+                  {
+                     png_uint_16 v, w;
 
-                        v = gamma_16_to_1[*(sp + 1) >> gamma_shift][*sp];
-                        png_composite_16(w, v, a, png_ptr->background_1.red);
-                        if (optimize == 0)
-                           w = gamma_16_from_1[((w & 0xff) >> gamma_shift)][w >>
-                                8];
-                        *sp = (png_byte)((w >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(w & 0xff);
+                     v = gamma_16_to_1[*(sp + 1) >> gamma_shift][*sp];
+                     png_composite_16(w, v, a, png_ptr->background_1.red);
+                     if (optimize == 0)
+                        w = gamma_16_from_1[((w & 0xff) >> gamma_shift)][w >>
+                             8];
+                     *sp = (png_byte)((w >> 8) & 0xff);
+                     *(sp + 1) = (png_byte)(w & 0xff);
 
-                        v = gamma_16_to_1[*(sp + 3) >> gamma_shift][*(sp + 2)];
-                        png_composite_16(w, v, a, png_ptr->background_1.green);
-                        if (optimize == 0)
-                           w = gamma_16_from_1[((w & 0xff) >> gamma_shift)][w >>
-                                8];
+                     v = gamma_16_to_1[*(sp + 3) >> gamma_shift][*(sp + 2)];
+                     png_composite_16(w, v, a, png_ptr->background_1.green);
+                     if (optimize == 0)
+                        w = gamma_16_from_1[((w & 0xff) >> gamma_shift)][w >>
+                             8];
 
-                        *(sp + 2) = (png_byte)((w >> 8) & 0xff);
-                        *(sp + 3) = (png_byte)(w & 0xff);
+                     *(sp + 2) = (png_byte)((w >> 8) & 0xff);
+                     *(sp + 3) = (png_byte)(w & 0xff);
 
-                        v = gamma_16_to_1[*(sp + 5) >> gamma_shift][*(sp + 4)];
-                        png_composite_16(w, v, a, png_ptr->background_1.blue);
-                        if (optimize == 0)
-                           w = gamma_16_from_1[((w & 0xff) >> gamma_shift)][w >>
-                                8];
+                     v = gamma_16_to_1[*(sp + 5) >> gamma_shift][*(sp + 4)];
+                     png_composite_16(w, v, a, png_ptr->background_1.blue);
+                     if (optimize == 0)
+                        w = gamma_16_from_1[((w & 0xff) >> gamma_shift)][w >>
+                             8];
 
-                        *(sp + 4) = (png_byte)((w >> 8) & 0xff);
-                        *(sp + 5) = (png_byte)(w & 0xff);
-                     }
-                  }
-               }
+                     *(sp + 4) = (png_byte)((w >> 8) & 0xff);
+                     *(sp + 5) = (png_byte)(w & 0xff);
+                  }
+               }
+            }
 
-               else
+            else
 #endif
-               {
-                  sp = row;
-                  for (i = 0; i < row_width; i++, sp += 8)
-                  {
-                     png_uint_16 a = (png_uint_16)(((png_uint_16)(*(sp + 6))
-                         << 8) + (png_uint_16)(*(sp + 7)));
+            {
+               sp = row;
+               for (i = 0; i < row_width; i++, sp += 8)
+               {
+                  png_uint_16 a = (png_uint_16)(((png_uint_16)(*(sp + 6))
+                      << 8) + (png_uint_16)(*(sp + 7)));
 
-                     if (a == 0)
-                     {
-                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
-                        *(sp + 2) = (png_byte)((png_ptr->background.green >> 8)
-                                & 0xff);
-                        *(sp + 3) = (png_byte)(png_ptr->background.green
-                                & 0xff);
-                        *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8)
-                                & 0xff);
-                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
-                     }
+                  if (a == 0)
+                  {
+                     *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
+                     *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
+                     *(sp + 2) = (png_byte)((png_ptr->background.green >> 8)
+                             & 0xff);
+                     *(sp + 3) = (png_byte)(png_ptr->background.green
+                             & 0xff);
+                     *(sp + 4) = (png_byte)((png_ptr->background.blue >> 8)
+                             & 0xff);
+                     *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
+                  }
 
-                     else if (a < 0xffff)
-                     {
-                        png_uint_16 v;
+                  else if (a < 0xffff)
+                  {
+                     png_uint_16 v;
 
-                        png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));
-                        png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)
-                            + *(sp + 3));
-                        png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)
-                            + *(sp + 5));
+                     png_uint_16 r = (png_uint_16)(((*sp) << 8) + *(sp + 1));
+                     png_uint_16 g = (png_uint_16)(((*(sp + 2)) << 8)
+                         + *(sp + 3));
+                     png_uint_16 b = (png_uint_16)(((*(sp + 4)) << 8)
+                         + *(sp + 5));
 
-                        png_composite_16(v, r, a, png_ptr->background.red);
-                        *sp = (png_byte)((v >> 8) & 0xff);
-                        *(sp + 1) = (png_byte)(v & 0xff);
+                     png_composite_16(v, r, a, png_ptr->background.red);
+                     *sp = (png_byte)((v >> 8) & 0xff);
+                     *(sp + 1) = (png_byte)(v & 0xff);
 
-                        png_composite_16(v, g, a, png_ptr->background.green);
-                        *(sp + 2) = (png_byte)((v >> 8) & 0xff);
-                        *(sp + 3) = (png_byte)(v & 0xff);
+                     png_composite_16(v, g, a, png_ptr->background.green);
+                     *(sp + 2) = (png_byte)((v >> 8) & 0xff);
+                     *(sp + 3) = (png_byte)(v & 0xff);
 
-                        png_composite_16(v, b, a, png_ptr->background.blue);
-                        *(sp + 4) = (png_byte)((v >> 8) & 0xff);
-                        *(sp + 5) = (png_byte)(v & 0xff);
-                     }
-                  }
-               }
-            }
-            break;
-         }
+                     png_composite_16(v, b, a, png_ptr->background.blue);
+                     *(sp + 4) = (png_byte)((v >> 8) & 0xff);
+                     *(sp + 5) = (png_byte)(v & 0xff);
+                  }
+               }
+            }
+         }
+         break;
+      }
 
-         default:
-            break;
-      }
+      default:
+         break;
    }
 }
 #endif /* READ_BACKGROUND || READ_ALPHA_MODE */
@@ -4138,12 +4152,11 @@
    {
       if (row_info->bit_depth == 8)
       {
-         PNG_CONST png_bytep table = png_ptr->gamma_from_1;
+         png_bytep table = png_ptr->gamma_from_1;
 
          if (table != NULL)
          {
-            PNG_CONST int step =
-               (row_info->color_type & PNG_COLOR_MASK_COLOR) ? 4 : 2;
+            int step = (row_info->color_type & PNG_COLOR_MASK_COLOR) ? 4 : 2;
 
             /* The alpha channel is the last component: */
             row += step - 1;
@@ -4157,13 +4170,12 @@
 
       else if (row_info->bit_depth == 16)
       {
-         PNG_CONST png_uint_16pp table = png_ptr->gamma_16_from_1;
-         PNG_CONST int gamma_shift = png_ptr->gamma_shift;
+         png_uint_16pp table = png_ptr->gamma_16_from_1;
+         int gamma_shift = png_ptr->gamma_shift;
 
          if (table != NULL)
          {
-            PNG_CONST int step =
-               (row_info->color_type & PNG_COLOR_MASK_COLOR) ? 8 : 4;
+            int step = (row_info->color_type & PNG_COLOR_MASK_COLOR) ? 8 : 4;
 
             /* The alpha channel is the last component: */
             row += step - 2;
@@ -4194,8 +4206,9 @@
  * upon whether you supply trans and num_trans.
  */
 static void
-png_do_expand_palette(png_row_infop row_info, png_bytep row,
-    png_const_colorp palette, png_const_bytep trans_alpha, int num_trans)
+png_do_expand_palette(png_structrp png_ptr, png_row_infop row_info,
+    png_bytep row, png_const_colorp palette, png_const_bytep trans_alpha,
+    int num_trans)
 {
    int shift, value;
    png_bytep sp, dp;
@@ -4212,8 +4225,8 @@
          {
             case 1:
             {
-               sp = row + (png_size_t)((row_width - 1) >> 3);
-               dp = row + (png_size_t)row_width - 1;
+               sp = row + (size_t)((row_width - 1) >> 3);
+               dp = row + (size_t)row_width - 1;
                shift = 7 - (int)((row_width + 7) & 0x07);
                for (i = 0; i < row_width; i++)
                {
@@ -4239,8 +4252,8 @@
 
             case 2:
             {
-               sp = row + (png_size_t)((row_width - 1) >> 2);
-               dp = row + (png_size_t)row_width - 1;
+               sp = row + (size_t)((row_width - 1) >> 2);
+               dp = row + (size_t)row_width - 1;
                shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
                for (i = 0; i < row_width; i++)
                {
@@ -4262,8 +4275,8 @@
 
             case 4:
             {
-               sp = row + (png_size_t)((row_width - 1) >> 1);
-               dp = row + (png_size_t)row_width - 1;
+               sp = row + (size_t)((row_width - 1) >> 1);
+               dp = row + (size_t)row_width - 1;
                shift = (int)((row_width & 0x01) << 2);
                for (i = 0; i < row_width; i++)
                {
@@ -4296,17 +4309,30 @@
          {
             if (num_trans > 0)
             {
-               sp = row + (png_size_t)row_width - 1;
-               dp = row + (png_size_t)(row_width << 2) - 1;
+               sp = row + (size_t)row_width - 1;
+               dp = row + ((size_t)row_width << 2) - 1;
 
-               for (i = 0; i < row_width; i++)
+               i = 0;
+#ifdef PNG_ARM_NEON_INTRINSICS_AVAILABLE
+               if (png_ptr->riffled_palette != NULL)
+               {
+                  /* The RGBA optimization works with png_ptr->bit_depth == 8
+                   * but sometimes row_info->bit_depth has been changed to 8.
+                   * In these cases, the palette hasn't been riffled.
+                   */
+                  i = png_do_expand_palette_rgba8_neon(png_ptr, row_info, row,
+                      &sp, &dp);
+               }
+#else
+               PNG_UNUSED(png_ptr)
+#endif
+
+               for (; i < row_width; i++)
                {
                   if ((int)(*sp) >= num_trans)
                      *dp-- = 0xff;
-
                   else
                      *dp-- = trans_alpha[*sp];
-
                   *dp-- = palette[*sp].blue;
                   *dp-- = palette[*sp].green;
                   *dp-- = palette[*sp].red;
@@ -4321,10 +4347,17 @@
 
             else
             {
-               sp = row + (png_size_t)row_width - 1;
-               dp = row + (png_size_t)(row_width * 3) - 1;
+               sp = row + (size_t)row_width - 1;
+               dp = row + (size_t)(row_width * 3) - 1;
+               i = 0;
+#ifdef PNG_ARM_NEON_INTRINSICS_AVAILABLE
+               i = png_do_expand_palette_rgb8_neon(png_ptr, row_info, row,
+                   &sp, &dp);
+#else
+               PNG_UNUSED(png_ptr)
+#endif
 
-               for (i = 0; i < row_width; i++)
+               for (; i < row_width; i++)
                {
                   *dp-- = palette[*sp].blue;
                   *dp-- = palette[*sp].green;
@@ -4357,219 +4390,217 @@
 
    png_debug(1, "in png_do_expand");
 
-   {
-      if (row_info->color_type == PNG_COLOR_TYPE_GRAY)
-      {
-         unsigned int gray = trans_color != NULL ? trans_color->gray : 0;
+   if (row_info->color_type == PNG_COLOR_TYPE_GRAY)
+   {
+      unsigned int gray = trans_color != NULL ? trans_color->gray : 0;
 
-         if (row_info->bit_depth < 8)
-         {
-            switch (row_info->bit_depth)
-            {
-               case 1:
-               {
-                  gray = (gray & 0x01) * 0xff;
-                  sp = row + (png_size_t)((row_width - 1) >> 3);
-                  dp = row + (png_size_t)row_width - 1;
-                  shift = 7 - (int)((row_width + 7) & 0x07);
-                  for (i = 0; i < row_width; i++)
-                  {
-                     if ((*sp >> shift) & 0x01)
-                        *dp = 0xff;
+      if (row_info->bit_depth < 8)
+      {
+         switch (row_info->bit_depth)
+         {
+            case 1:
+            {
+               gray = (gray & 0x01) * 0xff;
+               sp = row + (size_t)((row_width - 1) >> 3);
+               dp = row + (size_t)row_width - 1;
+               shift = 7 - (int)((row_width + 7) & 0x07);
+               for (i = 0; i < row_width; i++)
+               {
+                  if ((*sp >> shift) & 0x01)
+                     *dp = 0xff;
 
-                     else
-                        *dp = 0;
+                  else
+                     *dp = 0;
 
-                     if (shift == 7)
-                     {
-                        shift = 0;
-                        sp--;
-                     }
+                  if (shift == 7)
+                  {
+                     shift = 0;
+                     sp--;
+                  }
 
-                     else
-                        shift++;
+                  else
+                     shift++;
 
-                     dp--;
-                  }
-                  break;
-               }
+                  dp--;
+               }
+               break;
+            }
 
-               case 2:
-               {
-                  gray = (gray & 0x03) * 0x55;
-                  sp = row + (png_size_t)((row_width - 1) >> 2);
-                  dp = row + (png_size_t)row_width - 1;
-                  shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
-                  for (i = 0; i < row_width; i++)
-                  {
-                     value = (*sp >> shift) & 0x03;
-                     *dp = (png_byte)(value | (value << 2) | (value << 4) |
-                        (value << 6));
-                     if (shift == 6)
-                     {
-                        shift = 0;
-                        sp--;
-                     }
+            case 2:
+            {
+               gray = (gray & 0x03) * 0x55;
+               sp = row + (size_t)((row_width - 1) >> 2);
+               dp = row + (size_t)row_width - 1;
+               shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
+               for (i = 0; i < row_width; i++)
+               {
+                  value = (*sp >> shift) & 0x03;
+                  *dp = (png_byte)(value | (value << 2) | (value << 4) |
+                     (value << 6));
+                  if (shift == 6)
+                  {
+                     shift = 0;
+                     sp--;
+                  }
 
-                     else
-                        shift += 2;
+                  else
+                     shift += 2;
 
-                     dp--;
-                  }
-                  break;
-               }
+                  dp--;
+               }
+               break;
+            }
 
-               case 4:
-               {
-                  gray = (gray & 0x0f) * 0x11;
-                  sp = row + (png_size_t)((row_width - 1) >> 1);
-                  dp = row + (png_size_t)row_width - 1;
-                  shift = (int)((1 - ((row_width + 1) & 0x01)) << 2);
-                  for (i = 0; i < row_width; i++)
-                  {
-                     value = (*sp >> shift) & 0x0f;
-                     *dp = (png_byte)(value | (value << 4));
-                     if (shift == 4)
-                     {
-                        shift = 0;
-                        sp--;
-                     }
+            case 4:
+            {
+               gray = (gray & 0x0f) * 0x11;
+               sp = row + (size_t)((row_width - 1) >> 1);
+               dp = row + (size_t)row_width - 1;
+               shift = (int)((1 - ((row_width + 1) & 0x01)) << 2);
+               for (i = 0; i < row_width; i++)
+               {
+                  value = (*sp >> shift) & 0x0f;
+                  *dp = (png_byte)(value | (value << 4));
+                  if (shift == 4)
+                  {
+                     shift = 0;
+                     sp--;
+                  }
 
-                     else
-                        shift = 4;
+                  else
+                     shift = 4;
 
-                     dp--;
-                  }
-                  break;
-               }
+                  dp--;
+               }
+               break;
+            }
 
-               default:
-                  break;
-            }
+            default:
+               break;
+         }
 
-            row_info->bit_depth = 8;
-            row_info->pixel_depth = 8;
-            row_info->rowbytes = row_width;
-         }
+         row_info->bit_depth = 8;
+         row_info->pixel_depth = 8;
+         row_info->rowbytes = row_width;
+      }
 
-         if (trans_color != NULL)
-         {
-            if (row_info->bit_depth == 8)
-            {
-               gray = gray & 0xff;
-               sp = row + (png_size_t)row_width - 1;
-               dp = row + (png_size_t)(row_width << 1) - 1;
+      if (trans_color != NULL)
+      {
+         if (row_info->bit_depth == 8)
+         {
+            gray = gray & 0xff;
+            sp = row + (size_t)row_width - 1;
+            dp = row + ((size_t)row_width << 1) - 1;
 
-               for (i = 0; i < row_width; i++)
-               {
-                  if ((*sp & 0xffU) == gray)
-                     *dp-- = 0;
+            for (i = 0; i < row_width; i++)
+            {
+               if ((*sp & 0xffU) == gray)
+                  *dp-- = 0;
 
-                  else
-                     *dp-- = 0xff;
+               else
+                  *dp-- = 0xff;
 
-                  *dp-- = *sp--;
-               }
-            }
+               *dp-- = *sp--;
+            }
+         }
 
-            else if (row_info->bit_depth == 16)
-            {
-               unsigned int gray_high = (gray >> 8) & 0xff;
-               unsigned int gray_low = gray & 0xff;
-               sp = row + row_info->rowbytes - 1;
-               dp = row + (row_info->rowbytes << 1) - 1;
-               for (i = 0; i < row_width; i++)
-               {
-                  if ((*(sp - 1) & 0xffU) == gray_high &&
-                      (*(sp) & 0xffU) == gray_low)
-                  {
-                     *dp-- = 0;
-                     *dp-- = 0;
-                  }
+         else if (row_info->bit_depth == 16)
+         {
+            unsigned int gray_high = (gray >> 8) & 0xff;
+            unsigned int gray_low = gray & 0xff;
+            sp = row + row_info->rowbytes - 1;
+            dp = row + (row_info->rowbytes << 1) - 1;
+            for (i = 0; i < row_width; i++)
+            {
+               if ((*(sp - 1) & 0xffU) == gray_high &&
+                   (*(sp) & 0xffU) == gray_low)
+               {
+                  *dp-- = 0;
+                  *dp-- = 0;
+               }
 
-                  else
-                  {
-                     *dp-- = 0xff;
-                     *dp-- = 0xff;
-                  }
+               else
+               {
+                  *dp-- = 0xff;
+                  *dp-- = 0xff;
+               }
 
-                  *dp-- = *sp--;
-                  *dp-- = *sp--;
-               }
-            }
+               *dp-- = *sp--;
+               *dp-- = *sp--;
+            }
+         }
 
-            row_info->color_type = PNG_COLOR_TYPE_GRAY_ALPHA;
-            row_info->channels = 2;
-            row_info->pixel_depth = (png_byte)(row_info->bit_depth << 1);
-            row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,
-                row_width);
-         }
-      }
-      else if (row_info->color_type == PNG_COLOR_TYPE_RGB &&
-          trans_color != NULL)
-      {
-         if (row_info->bit_depth == 8)
-         {
-            png_byte red = (png_byte)(trans_color->red & 0xff);
-            png_byte green = (png_byte)(trans_color->green & 0xff);
-            png_byte blue = (png_byte)(trans_color->blue & 0xff);
-            sp = row + (png_size_t)row_info->rowbytes - 1;
-            dp = row + (png_size_t)(row_width << 2) - 1;
-            for (i = 0; i < row_width; i++)
-            {
-               if (*(sp - 2) == red && *(sp - 1) == green && *(sp) == blue)
-                  *dp-- = 0;
+         row_info->color_type = PNG_COLOR_TYPE_GRAY_ALPHA;
+         row_info->channels = 2;
+         row_info->pixel_depth = (png_byte)(row_info->bit_depth << 1);
+         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,
+             row_width);
+      }
+   }
+   else if (row_info->color_type == PNG_COLOR_TYPE_RGB &&
+       trans_color != NULL)
+   {
+      if (row_info->bit_depth == 8)
+      {
+         png_byte red = (png_byte)(trans_color->red & 0xff);
+         png_byte green = (png_byte)(trans_color->green & 0xff);
+         png_byte blue = (png_byte)(trans_color->blue & 0xff);
+         sp = row + (size_t)row_info->rowbytes - 1;
+         dp = row + ((size_t)row_width << 2) - 1;
+         for (i = 0; i < row_width; i++)
+         {
+            if (*(sp - 2) == red && *(sp - 1) == green && *(sp) == blue)
+               *dp-- = 0;
 
-               else
-                  *dp-- = 0xff;
+            else
+               *dp-- = 0xff;
 
-               *dp-- = *sp--;
-               *dp-- = *sp--;
-               *dp-- = *sp--;
-            }
-         }
-         else if (row_info->bit_depth == 16)
-         {
-            png_byte red_high = (png_byte)((trans_color->red >> 8) & 0xff);
-            png_byte green_high = (png_byte)((trans_color->green >> 8) & 0xff);
-            png_byte blue_high = (png_byte)((trans_color->blue >> 8) & 0xff);
-            png_byte red_low = (png_byte)(trans_color->red & 0xff);
-            png_byte green_low = (png_byte)(trans_color->green & 0xff);
-            png_byte blue_low = (png_byte)(trans_color->blue & 0xff);
-            sp = row + row_info->rowbytes - 1;
-            dp = row + (png_size_t)(row_width << 3) - 1;
-            for (i = 0; i < row_width; i++)
-            {
-               if (*(sp - 5) == red_high &&
-                   *(sp - 4) == red_low &&
-                   *(sp - 3) == green_high &&
-                   *(sp - 2) == green_low &&
-                   *(sp - 1) == blue_high &&
-                   *(sp    ) == blue_low)
-               {
-                  *dp-- = 0;
-                  *dp-- = 0;
-               }
+            *dp-- = *sp--;
+            *dp-- = *sp--;
+            *dp-- = *sp--;
+         }
+      }
+      else if (row_info->bit_depth == 16)
+      {
+         png_byte red_high = (png_byte)((trans_color->red >> 8) & 0xff);
+         png_byte green_high = (png_byte)((trans_color->green >> 8) & 0xff);
+         png_byte blue_high = (png_byte)((trans_color->blue >> 8) & 0xff);
+         png_byte red_low = (png_byte)(trans_color->red & 0xff);
+         png_byte green_low = (png_byte)(trans_color->green & 0xff);
+         png_byte blue_low = (png_byte)(trans_color->blue & 0xff);
+         sp = row + row_info->rowbytes - 1;
+         dp = row + ((size_t)row_width << 3) - 1;
+         for (i = 0; i < row_width; i++)
+         {
+            if (*(sp - 5) == red_high &&
+                *(sp - 4) == red_low &&
+                *(sp - 3) == green_high &&
+                *(sp - 2) == green_low &&
+                *(sp - 1) == blue_high &&
+                *(sp    ) == blue_low)
+            {
+               *dp-- = 0;
+               *dp-- = 0;
+            }
 
-               else
-               {
-                  *dp-- = 0xff;
-                  *dp-- = 0xff;
-               }
+            else
+            {
+               *dp-- = 0xff;
+               *dp-- = 0xff;
+            }
 
-               *dp-- = *sp--;
-               *dp-- = *sp--;
-               *dp-- = *sp--;
-               *dp-- = *sp--;
-               *dp-- = *sp--;
-               *dp-- = *sp--;
-            }
-         }
-         row_info->color_type = PNG_COLOR_TYPE_RGB_ALPHA;
-         row_info->channels = 4;
-         row_info->pixel_depth = (png_byte)(row_info->bit_depth << 2);
-         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
-      }
+            *dp-- = *sp--;
+            *dp-- = *sp--;
+            *dp-- = *sp--;
+            *dp-- = *sp--;
+            *dp-- = *sp--;
+            *dp-- = *sp--;
+         }
+      }
+      row_info->color_type = PNG_COLOR_TYPE_RGB_ALPHA;
+      row_info->channels = 4;
+      row_info->pixel_depth = (png_byte)(row_info->bit_depth << 2);
+      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
    }
 }
 #endif
@@ -4596,7 +4627,9 @@
       png_byte *sp = row + row_info->rowbytes; /* source, last byte + 1 */
       png_byte *dp = sp + row_info->rowbytes;  /* destination, end + 1 */
       while (dp > sp)
-         dp[-2] = dp[-1] = *--sp, dp -= 2;
+      {
+         dp[-2] = dp[-1] = *--sp; dp -= 2;
+      }
 
       row_info->rowbytes *= 2;
       row_info->bit_depth = 16;
@@ -4738,7 +4771,19 @@
    {
       if (row_info->color_type == PNG_COLOR_TYPE_PALETTE)
       {
-         png_do_expand_palette(row_info, png_ptr->row_buf + 1,
+#ifdef PNG_ARM_NEON_INTRINSICS_AVAILABLE
+         if ((png_ptr->num_trans > 0) && (png_ptr->bit_depth == 8))
+         {
+            if (png_ptr->riffled_palette == NULL)
+            {
+               /* Initialize the accelerated palette expansion. */
+               png_ptr->riffled_palette =
+                   (png_bytep)png_malloc(png_ptr, 256 * 4);
+               png_riffle_palette_neon(png_ptr);
+            }
+         }
+#endif
+         png_do_expand_palette(png_ptr, row_info, png_ptr->row_buf + 1,
              png_ptr->palette, png_ptr->trans_alpha, png_ptr->num_trans);
       }
 
@@ -4750,8 +4795,7 @@
                 &(png_ptr->trans_color));
 
          else
-            png_do_expand(row_info, png_ptr->row_buf + 1,
-                NULL);
+            png_do_expand(row_info, png_ptr->row_buf + 1, NULL);
       }
    }
 #endif
@@ -4975,7 +5019,7 @@
              (png_ptr,     /* png_ptr */
              row_info,     /* row_info: */
                 /*  png_uint_32 width;       width of row */
-                /*  png_size_t rowbytes;     number of bytes in row */
+                /*  size_t rowbytes;         number of bytes in row */
                 /*  png_byte color_type;     color type of pixels */
                 /*  png_byte bit_depth;      bit depth of samples */
                 /*  png_byte channels;       number of channels (1-4) */
Index: pixman-src/pixman/pixman/pixman-compiler.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pixman-src/pixman/pixman/pixman-compiler.h b/pixman-src/pixman/pixman/pixman-compiler.h
--- a/pixman-src/pixman/pixman/pixman-compiler.h	(revision 37216a32839f59e8dcaa4c3951b3fcfc3f07852c)
+++ b/pixman-src/pixman/pixman/pixman-compiler.h	(date 1689048276054)
@@ -4,8 +4,6 @@
  * The features are:
  *
  *    FUNC	     must be defined to expand to the current function
- *    PIXMAN_EXPORT  should be defined to whatever is required to
- *                   export functions from a shared library
  *    limits	     limits for various types must be defined
  *    inline         must be defined
  *    force_inline   must be defined
@@ -88,18 +86,6 @@
 #      define noinline
 #   endif
 #endif
-
-/* GCC visibility */
-#if defined(__GNUC__) && __GNUC__ >= 4 && !defined(_WIN32)
-#   define PIXMAN_EXPORT __attribute__ ((visibility("default")))
-/* Sun Studio 8 visibility */
-#elif defined(__SUNPRO_C) && (__SUNPRO_C >= 0x550)
-#   define PIXMAN_EXPORT __global
-#elif defined (_MSC_VER) || defined(__MINGW32__)
-#   define PIXMAN_EXPORT PIXMAN_API
-#else
-#   define PIXMAN_EXPORT
-#endif
 
 /* member offsets */
 #define CONTAINER_OF(type, member, data)				\
Index: libpng-src/libpng/pngrio.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/pngrio.c b/libpng-src/libpng/pngrio.c
--- a/libpng-src/libpng/pngrio.c	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/pngrio.c	(date 1690795574122)
@@ -1,10 +1,10 @@
 
 /* pngrio.c - functions for data input
  *
- * Last changed in libpng 1.6.24 [August 4, 2016]
- * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ * Copyright (c) 2018 Cosmin Truta
+ * Copyright (c) 1998-2002,2004,2006-2016,2018 Glenn Randers-Pehrson
+ * Copyright (c) 1996-1997 Andreas Dilger
+ * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
@@ -29,7 +29,7 @@
  * to read more than 64K on a 16-bit machine.
  */
 void /* PRIVATE */
-png_read_data(png_structrp png_ptr, png_bytep data, png_size_t length)
+png_read_data(png_structrp png_ptr, png_bytep data, size_t length)
 {
    png_debug1(4, "reading %d bytes", (int)length);
 
@@ -47,14 +47,14 @@
  * than changing the library.
  */
 void PNGCBAPI
-png_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
+png_default_read_data(png_structp png_ptr, png_bytep data, size_t length)
 {
-   png_size_t check;
+   size_t check;
 
    if (png_ptr == NULL)
       return;
 
-   /* fread() returns 0 on error, so it is OK to store this in a png_size_t
+   /* fread() returns 0 on error, so it is OK to store this in a size_t
     * instead of an int, which is what fread() actually returns.
     */
    check = fread(data, 1, length, png_voidcast(png_FILE_p, png_ptr->io_ptr));
Index: libpng-src/libpng/pngget.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/pngget.c b/libpng-src/libpng/pngget.c
--- a/libpng-src/libpng/pngget.c	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/pngget.c	(date 1690795574122)
@@ -1,10 +1,10 @@
 
 /* pngget.c - retrieval of values from info struct
  *
- * Last changed in libpng 1.6.24 [August 4, 2016]
- * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ * Copyright (c) 2018-2023 Cosmin Truta
+ * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson
+ * Copyright (c) 1996-1997 Andreas Dilger
+ * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
@@ -21,12 +21,23 @@
     png_uint_32 flag)
 {
    if (png_ptr != NULL && info_ptr != NULL)
+   {
+#ifdef PNG_READ_tRNS_SUPPORTED
+      /* png_handle_PLTE() may have canceled a valid tRNS chunk but left the
+       * 'valid' flag for the detection of duplicate chunks. Do not report a
+       * valid tRNS chunk in this case.
+       */
+      if (flag == PNG_INFO_tRNS && png_ptr->num_trans == 0)
+         return(0);
+#endif
+
       return(info_ptr->valid & flag);
+   }
 
    return(0);
 }
 
-png_size_t PNGAPI
+size_t PNGAPI
 png_get_rowbytes(png_const_structrp png_ptr, png_const_inforp info_ptr)
 {
    if (png_ptr != NULL && info_ptr != NULL)
@@ -338,7 +349,7 @@
    png_fixed_point result;
    if (ppm <= PNG_UINT_31_MAX && png_muldiv(&result, (png_int_32)ppm, 127,
        5000) != 0)
-      return result;
+      return (png_uint_32)result;
 
    /* Overflow. */
    return 0;
@@ -367,7 +378,7 @@
 static png_fixed_point
 png_fixed_inches_from_microns(png_const_structrp png_ptr, png_int_32 microns)
 {
-   /* Convert from metres * 1,000,000 to inches * 100,000, meters to
+   /* Convert from meters * 1,000,000 to inches * 100,000, meters to
     * inches is simply *(100/2.54), so we want *(10/2.54) == 500/127.
     * Notice that this can overflow - a warning is output and 0 is
     * returned.
@@ -741,8 +752,7 @@
 
    if (png_ptr != NULL && info_ptr != NULL &&
        (info_ptr->valid & PNG_INFO_iCCP) != 0 &&
-       name != NULL && compression_type != NULL && profile != NULL &&
-           proflen != NULL)
+       name != NULL && profile != NULL && proflen != NULL)
    {
       *name = info_ptr->iccp_name;
       *profile = info_ptr->iccp_profile;
@@ -750,11 +760,13 @@
       /* This is somewhat irrelevant since the profile data returned has
        * actually been uncompressed.
        */
-      *compression_type = PNG_COMPRESSION_TYPE_BASE;
+      if (compression_type != NULL)
+         *compression_type = PNG_COMPRESSION_TYPE_BASE;
       return (PNG_INFO_iCCP);
    }
 
    return (0);
+
 }
 #endif
 
@@ -769,6 +781,35 @@
       return info_ptr->splt_palettes_num;
    }
 
+   return (0);
+}
+#endif
+
+#ifdef PNG_eXIf_SUPPORTED
+png_uint_32 PNGAPI
+png_get_eXIf(png_const_structrp png_ptr, png_inforp info_ptr,
+    png_bytep *exif)
+{
+  png_warning(png_ptr, "png_get_eXIf does not work; use png_get_eXIf_1");
+  PNG_UNUSED(info_ptr)
+  PNG_UNUSED(exif)
+  return 0;
+}
+
+png_uint_32 PNGAPI
+png_get_eXIf_1(png_const_structrp png_ptr, png_const_inforp info_ptr,
+    png_uint_32 *num_exif, png_bytep *exif)
+{
+   png_debug1(1, "in %s retrieval function", "eXIf");
+
+   if (png_ptr != NULL && info_ptr != NULL &&
+       (info_ptr->valid & PNG_INFO_eXIf) != 0 && exif != NULL)
+   {
+      *num_exif = info_ptr->num_exif;
+      *exif = info_ptr->exif;
+      return (PNG_INFO_eXIf);
+   }
+
    return (0);
 }
 #endif
@@ -1121,7 +1162,7 @@
 
 #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
 png_byte PNGAPI
-png_get_rgb_to_gray_status (png_const_structrp png_ptr)
+png_get_rgb_to_gray_status(png_const_structrp png_ptr)
 {
    return (png_byte)(png_ptr ? png_ptr->rgb_to_gray_status : 0);
 }
@@ -1135,7 +1176,7 @@
 }
 #endif
 
-png_size_t PNGAPI
+size_t PNGAPI
 png_get_compression_buffer_size(png_const_structrp png_ptr)
 {
    if (png_ptr == NULL)
@@ -1162,27 +1203,27 @@
 /* These functions were added to libpng 1.2.6 and were enabled
  * by default in libpng-1.4.0 */
 png_uint_32 PNGAPI
-png_get_user_width_max (png_const_structrp png_ptr)
+png_get_user_width_max(png_const_structrp png_ptr)
 {
    return (png_ptr ? png_ptr->user_width_max : 0);
 }
 
 png_uint_32 PNGAPI
-png_get_user_height_max (png_const_structrp png_ptr)
+png_get_user_height_max(png_const_structrp png_ptr)
 {
    return (png_ptr ? png_ptr->user_height_max : 0);
 }
 
 /* This function was added to libpng 1.4.0 */
 png_uint_32 PNGAPI
-png_get_chunk_cache_max (png_const_structrp png_ptr)
+png_get_chunk_cache_max(png_const_structrp png_ptr)
 {
    return (png_ptr ? png_ptr->user_chunk_cache_max : 0);
 }
 
 /* This function was added to libpng 1.4.1 */
 png_alloc_size_t PNGAPI
-png_get_chunk_malloc_max (png_const_structrp png_ptr)
+png_get_chunk_malloc_max(png_const_structrp png_ptr)
 {
    return (png_ptr ? png_ptr->user_chunk_malloc_max : 0);
 }
@@ -1191,13 +1232,13 @@
 /* These functions were added to libpng 1.4.0 */
 #ifdef PNG_IO_STATE_SUPPORTED
 png_uint_32 PNGAPI
-png_get_io_state (png_const_structrp png_ptr)
+png_get_io_state(png_const_structrp png_ptr)
 {
    return png_ptr->io_state;
 }
 
 png_uint_32 PNGAPI
-png_get_io_chunk_type (png_const_structrp png_ptr)
+png_get_io_chunk_type(png_const_structrp png_ptr)
 {
    return png_ptr->chunk_name;
 }
Index: indigo-src/indigo/api/c/indigo-renderer/src/indigo_render2d.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo-renderer/src/indigo_render2d.cpp b/indigo-src/indigo/api/c/indigo-renderer/src/indigo_render2d.cpp
--- a/indigo-src/indigo/api/c/indigo-renderer/src/indigo_render2d.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo-renderer/src/indigo_render2d.cpp	(date 1690767117645)
@@ -442,7 +442,7 @@
         value.readString("right", true);
 }
 
-CEXPORT int indigoRendererInit(qword id)
+int indigoRendererInit(qword id)
 {
 #ifdef INDIGO_DEBUG
     std::stringstream ss;
@@ -458,7 +458,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRendererDispose(const qword id)
+int indigoRendererDispose(const qword id)
 {
 #ifdef INDIGO_DEBUG
     std::stringstream ss;
@@ -473,7 +473,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRender(int object, int output)
+int indigoRender(int object, int output)
 {
     INDIGO_BEGIN
     {
@@ -529,7 +529,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRenderGrid(int objects, int* refAtoms, int nColumns, int output)
+int indigoRenderGrid(int objects, int* refAtoms, int nColumns, int output)
 {
     INDIGO_BEGIN
     {
@@ -653,7 +653,7 @@
     return indigoRenderMapOutputFormat(ext + 1);
 }
 
-CEXPORT int indigoRenderToFile(int object, const char* filename)
+int indigoRenderToFile(int object, const char* filename)
 {
     int f = indigoWriteFile(filename);
 
@@ -670,7 +670,7 @@
     return res;
 }
 
-CEXPORT int indigoRenderGridToFile(int objects, int* refAtoms, int nColumns, const char* filename)
+int indigoRenderGridToFile(int objects, int* refAtoms, int nColumns, const char* filename)
 {
     int f = indigoWriteFile(filename);
 
@@ -687,7 +687,7 @@
     return res;
 }
 
-CEXPORT int indigoRenderReset()
+int indigoRenderReset()
 {
     INDIGO_BEGIN
     {
@@ -698,13 +698,13 @@
     INDIGO_END(-1);
 }
 
-CEXPORT void indigoRenderResetOptions()
+void indigoRenderResetOptions()
 {
     indigoRendererGetInstance().init();
     getCdxmlContext().clear();
 }
 
-CEXPORT int indigoRenderWriteHDC(void* hdc, int printingHdc)
+int indigoRenderWriteHDC(void* hdc, int printingHdc)
 {
     INDIGO_BEGIN
     {
Index: libpng-src/libpng/pngerror.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/pngerror.c b/libpng-src/libpng/pngerror.c
--- a/libpng-src/libpng/pngerror.c	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/pngerror.c	(date 1690795574122)
@@ -1,10 +1,10 @@
 
 /* pngerror.c - stub functions for i/o and memory allocation
  *
- * Last changed in libpng 1.6.24 [August 4, 2016]
- * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ * Copyright (c) 2018 Cosmin Truta
+ * Copyright (c) 1998-2002,2004,2006-2017 Glenn Randers-Pehrson
+ * Copyright (c) 1996-1997 Andreas Dilger
+ * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
@@ -163,7 +163,7 @@
          case PNG_NUMBER_FORMAT_02u:
             /* Expects at least 2 digits. */
             mincount = 2;
-            /* FALL THROUGH */
+            /* FALLTHROUGH */
 
          case PNG_NUMBER_FORMAT_u:
             *--end = digits[number % 10];
@@ -173,7 +173,7 @@
          case PNG_NUMBER_FORMAT_02x:
             /* This format expects at least two digits */
             mincount = 2;
-            /* FALL THROUGH */
+            /* FALLTHROUGH */
 
          case PNG_NUMBER_FORMAT_x:
             *--end = digits[number & 0xf];
@@ -425,7 +425,7 @@
  * if the character is invalid.
  */
 #define isnonalpha(c) ((c) < 65 || (c) > 122 || ((c) > 90 && (c) < 97))
-static PNG_CONST char png_digit[16] = {
+static const char png_digit[16] = {
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    'A', 'B', 'C', 'D', 'E', 'F'
 };
@@ -573,7 +573,7 @@
 {
 #  define fixed_message "fixed point overflow in "
 #  define fixed_message_ln ((sizeof fixed_message)-1)
-   int  iin;
+   unsigned int  iin;
    char msg[fixed_message_ln+PNG_MAX_ERROR_TEXT];
    memcpy(msg, fixed_message, fixed_message_ln);
    iin = 0;
@@ -885,7 +885,7 @@
 png_safe_error),(png_structp png_nonconst_ptr, png_const_charp error_message),
     PNG_NORETURN)
 {
-   const png_const_structrp png_ptr = png_nonconst_ptr;
+   png_const_structrp png_ptr = png_nonconst_ptr;
    png_imagep image = png_voidcast(png_imagep, png_ptr->error_ptr);
 
    /* An error is always logged here, overwriting anything (typically a warning)
@@ -920,7 +920,7 @@
 void /* PRIVATE */ PNGCBAPI
 png_safe_warning(png_structp png_nonconst_ptr, png_const_charp warning_message)
 {
-   const png_const_structrp png_ptr = png_nonconst_ptr;
+   png_const_structrp png_ptr = png_nonconst_ptr;
    png_imagep image = png_voidcast(png_imagep, png_ptr->error_ptr);
 
    /* A warning is only logged if there is no prior warning or error. */
Index: taskflow-src/taskflow/taskflow/taskflow.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/taskflow-src/taskflow/taskflow/taskflow.hpp b/taskflow-src/taskflow/taskflow/taskflow.hpp
--- a/taskflow-src/taskflow/taskflow/taskflow.hpp	(revision 12f8bd4e970ab27fd3dee3bffa24b5b48b54ba39)
+++ b/taskflow-src/taskflow/taskflow/taskflow.hpp	(date 1689066180578)
@@ -3,6 +3,7 @@
 #include "core/executor.hpp"
 #include "core/async.hpp"
 #include "algorithm/critical.hpp"
+#include "algorithm/for_each.hpp"
 
 /**
 @dir taskflow
Index: libpng-src/libpng/intel/filter_sse2_intrinsics.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/intel/filter_sse2_intrinsics.c b/libpng-src/libpng/intel/filter_sse2_intrinsics.c
new file mode 100644
--- /dev/null	(date 1690795574118)
+++ b/libpng-src/libpng/intel/filter_sse2_intrinsics.c	(date 1690795574118)
@@ -0,0 +1,391 @@
+
+/* filter_sse2_intrinsics.c - SSE2 optimized filter functions
+ *
+ * Copyright (c) 2018 Cosmin Truta
+ * Copyright (c) 2016-2017 Glenn Randers-Pehrson
+ * Written by Mike Klein and Matt Sarett
+ * Derived from arm/filter_neon_intrinsics.c
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ */
+
+#include "../pngpriv.h"
+
+#ifdef PNG_READ_SUPPORTED
+
+#if PNG_INTEL_SSE_IMPLEMENTATION > 0
+
+#include <immintrin.h>
+
+/* Functions in this file look at most 3 pixels (a,b,c) to predict the 4th (d).
+ * They're positioned like this:
+ *    prev:  c b
+ *    row:   a d
+ * The Sub filter predicts d=a, Avg d=(a+b)/2, and Paeth predicts d to be
+ * whichever of a, b, or c is closest to p=a+b-c.
+ */
+
+static __m128i load4(const void* p) {
+   int tmp;
+   memcpy(&tmp, p, sizeof(tmp));
+   return _mm_cvtsi32_si128(tmp);
+}
+
+static void store4(void* p, __m128i v) {
+   int tmp = _mm_cvtsi128_si32(v);
+   memcpy(p, &tmp, sizeof(int));
+}
+
+static __m128i load3(const void* p) {
+   png_uint_32 tmp = 0;
+   memcpy(&tmp, p, 3);
+   return _mm_cvtsi32_si128(tmp);
+}
+
+static void store3(void* p, __m128i v) {
+   int tmp = _mm_cvtsi128_si32(v);
+   memcpy(p, &tmp, 3);
+}
+
+void png_read_filter_row_sub3_sse2(png_row_infop row_info, png_bytep row,
+   png_const_bytep prev)
+{
+   /* The Sub filter predicts each pixel as the previous pixel, a.
+    * There is no pixel to the left of the first pixel.  It's encoded directly.
+    * That works with our main loop if we just say that left pixel was zero.
+    */
+   size_t rb;
+
+   __m128i a, d = _mm_setzero_si128();
+
+   png_debug(1, "in png_read_filter_row_sub3_sse2");
+
+   rb = row_info->rowbytes;
+   while (rb >= 4) {
+      a = d; d = load4(row);
+      d = _mm_add_epi8(d, a);
+      store3(row, d);
+
+      row += 3;
+      rb  -= 3;
+   }
+   if (rb > 0) {
+      a = d; d = load3(row);
+      d = _mm_add_epi8(d, a);
+      store3(row, d);
+
+      row += 3;
+      rb  -= 3;
+   }
+   PNG_UNUSED(prev)
+}
+
+void png_read_filter_row_sub4_sse2(png_row_infop row_info, png_bytep row,
+   png_const_bytep prev)
+{
+   /* The Sub filter predicts each pixel as the previous pixel, a.
+    * There is no pixel to the left of the first pixel.  It's encoded directly.
+    * That works with our main loop if we just say that left pixel was zero.
+    */
+   size_t rb;
+
+   __m128i a, d = _mm_setzero_si128();
+
+   png_debug(1, "in png_read_filter_row_sub4_sse2");
+
+   rb = row_info->rowbytes+4;
+   while (rb > 4) {
+      a = d; d = load4(row);
+      d = _mm_add_epi8(d, a);
+      store4(row, d);
+
+      row += 4;
+      rb  -= 4;
+   }
+   PNG_UNUSED(prev)
+}
+
+void png_read_filter_row_avg3_sse2(png_row_infop row_info, png_bytep row,
+   png_const_bytep prev)
+{
+   /* The Avg filter predicts each pixel as the (truncated) average of a and b.
+    * There's no pixel to the left of the first pixel.  Luckily, it's
+    * predicted to be half of the pixel above it.  So again, this works
+    * perfectly with our loop if we make sure a starts at zero.
+    */
+
+   size_t rb;
+
+   const __m128i zero = _mm_setzero_si128();
+
+   __m128i    b;
+   __m128i a, d = zero;
+
+   png_debug(1, "in png_read_filter_row_avg3_sse2");
+   rb = row_info->rowbytes;
+   while (rb >= 4) {
+      __m128i avg;
+             b = load4(prev);
+      a = d; d = load4(row );
+
+      /* PNG requires a truncating average, so we can't just use _mm_avg_epu8 */
+      avg = _mm_avg_epu8(a,b);
+      /* ...but we can fix it up by subtracting off 1 if it rounded up. */
+      avg = _mm_sub_epi8(avg, _mm_and_si128(_mm_xor_si128(a,b),
+                                            _mm_set1_epi8(1)));
+      d = _mm_add_epi8(d, avg);
+      store3(row, d);
+
+      prev += 3;
+      row  += 3;
+      rb   -= 3;
+   }
+   if (rb > 0) {
+      __m128i avg;
+             b = load3(prev);
+      a = d; d = load3(row );
+
+      /* PNG requires a truncating average, so we can't just use _mm_avg_epu8 */
+      avg = _mm_avg_epu8(a,b);
+      /* ...but we can fix it up by subtracting off 1 if it rounded up. */
+      avg = _mm_sub_epi8(avg, _mm_and_si128(_mm_xor_si128(a,b),
+                                            _mm_set1_epi8(1)));
+
+      d = _mm_add_epi8(d, avg);
+      store3(row, d);
+
+      prev += 3;
+      row  += 3;
+      rb   -= 3;
+   }
+}
+
+void png_read_filter_row_avg4_sse2(png_row_infop row_info, png_bytep row,
+   png_const_bytep prev)
+{
+   /* The Avg filter predicts each pixel as the (truncated) average of a and b.
+    * There's no pixel to the left of the first pixel.  Luckily, it's
+    * predicted to be half of the pixel above it.  So again, this works
+    * perfectly with our loop if we make sure a starts at zero.
+    */
+   size_t rb;
+   const __m128i zero = _mm_setzero_si128();
+   __m128i    b;
+   __m128i a, d = zero;
+
+   png_debug(1, "in png_read_filter_row_avg4_sse2");
+
+   rb = row_info->rowbytes+4;
+   while (rb > 4) {
+      __m128i avg;
+             b = load4(prev);
+      a = d; d = load4(row );
+
+      /* PNG requires a truncating average, so we can't just use _mm_avg_epu8 */
+      avg = _mm_avg_epu8(a,b);
+      /* ...but we can fix it up by subtracting off 1 if it rounded up. */
+      avg = _mm_sub_epi8(avg, _mm_and_si128(_mm_xor_si128(a,b),
+                                            _mm_set1_epi8(1)));
+
+      d = _mm_add_epi8(d, avg);
+      store4(row, d);
+
+      prev += 4;
+      row  += 4;
+      rb   -= 4;
+   }
+}
+
+/* Returns |x| for 16-bit lanes. */
+static __m128i abs_i16(__m128i x) {
+#if PNG_INTEL_SSE_IMPLEMENTATION >= 2
+   return _mm_abs_epi16(x);
+#else
+   /* Read this all as, return x<0 ? -x : x.
+   * To negate two's complement, you flip all the bits then add 1.
+    */
+   __m128i is_negative = _mm_cmplt_epi16(x, _mm_setzero_si128());
+
+   /* Flip negative lanes. */
+   x = _mm_xor_si128(x, is_negative);
+
+   /* +1 to negative lanes, else +0. */
+   x = _mm_sub_epi16(x, is_negative);
+   return x;
+#endif
+}
+
+/* Bytewise c ? t : e. */
+static __m128i if_then_else(__m128i c, __m128i t, __m128i e) {
+#if PNG_INTEL_SSE_IMPLEMENTATION >= 3
+   return _mm_blendv_epi8(e,t,c);
+#else
+   return _mm_or_si128(_mm_and_si128(c, t), _mm_andnot_si128(c, e));
+#endif
+}
+
+void png_read_filter_row_paeth3_sse2(png_row_infop row_info, png_bytep row,
+   png_const_bytep prev)
+{
+   /* Paeth tries to predict pixel d using the pixel to the left of it, a,
+    * and two pixels from the previous row, b and c:
+    *   prev: c b
+    *   row:  a d
+    * The Paeth function predicts d to be whichever of a, b, or c is nearest to
+    * p=a+b-c.
+    *
+    * The first pixel has no left context, and so uses an Up filter, p = b.
+    * This works naturally with our main loop's p = a+b-c if we force a and c
+    * to zero.
+    * Here we zero b and d, which become c and a respectively at the start of
+    * the loop.
+    */
+   size_t rb;
+   const __m128i zero = _mm_setzero_si128();
+   __m128i c, b = zero,
+           a, d = zero;
+
+   png_debug(1, "in png_read_filter_row_paeth3_sse2");
+
+   rb = row_info->rowbytes;
+   while (rb >= 4) {
+      /* It's easiest to do this math (particularly, deal with pc) with 16-bit
+       * intermediates.
+       */
+      __m128i pa,pb,pc,smallest,nearest;
+      c = b; b = _mm_unpacklo_epi8(load4(prev), zero);
+      a = d; d = _mm_unpacklo_epi8(load4(row ), zero);
+
+      /* (p-a) == (a+b-c - a) == (b-c) */
+
+      pa = _mm_sub_epi16(b,c);
+
+      /* (p-b) == (a+b-c - b) == (a-c) */
+      pb = _mm_sub_epi16(a,c);
+
+      /* (p-c) == (a+b-c - c) == (a+b-c-c) == (b-c)+(a-c) */
+      pc = _mm_add_epi16(pa,pb);
+
+      pa = abs_i16(pa);  /* |p-a| */
+      pb = abs_i16(pb);  /* |p-b| */
+      pc = abs_i16(pc);  /* |p-c| */
+
+      smallest = _mm_min_epi16(pc, _mm_min_epi16(pa, pb));
+
+      /* Paeth breaks ties favoring a over b over c. */
+      nearest  = if_then_else(_mm_cmpeq_epi16(smallest, pa), a,
+                 if_then_else(_mm_cmpeq_epi16(smallest, pb), b,
+                                                             c));
+
+      /* Note `_epi8`: we need addition to wrap modulo 255. */
+      d = _mm_add_epi8(d, nearest);
+      store3(row, _mm_packus_epi16(d,d));
+
+      prev += 3;
+      row  += 3;
+      rb   -= 3;
+   }
+   if (rb > 0) {
+      /* It's easiest to do this math (particularly, deal with pc) with 16-bit
+       * intermediates.
+       */
+      __m128i pa,pb,pc,smallest,nearest;
+      c = b; b = _mm_unpacklo_epi8(load3(prev), zero);
+      a = d; d = _mm_unpacklo_epi8(load3(row ), zero);
+
+      /* (p-a) == (a+b-c - a) == (b-c) */
+      pa = _mm_sub_epi16(b,c);
+
+      /* (p-b) == (a+b-c - b) == (a-c) */
+      pb = _mm_sub_epi16(a,c);
+
+      /* (p-c) == (a+b-c - c) == (a+b-c-c) == (b-c)+(a-c) */
+      pc = _mm_add_epi16(pa,pb);
+
+      pa = abs_i16(pa);  /* |p-a| */
+      pb = abs_i16(pb);  /* |p-b| */
+      pc = abs_i16(pc);  /* |p-c| */
+
+      smallest = _mm_min_epi16(pc, _mm_min_epi16(pa, pb));
+
+      /* Paeth breaks ties favoring a over b over c. */
+      nearest  = if_then_else(_mm_cmpeq_epi16(smallest, pa), a,
+                         if_then_else(_mm_cmpeq_epi16(smallest, pb), b,
+                                                                     c));
+
+      /* Note `_epi8`: we need addition to wrap modulo 255. */
+      d = _mm_add_epi8(d, nearest);
+      store3(row, _mm_packus_epi16(d,d));
+
+      prev += 3;
+      row  += 3;
+      rb   -= 3;
+   }
+}
+
+void png_read_filter_row_paeth4_sse2(png_row_infop row_info, png_bytep row,
+   png_const_bytep prev)
+{
+   /* Paeth tries to predict pixel d using the pixel to the left of it, a,
+    * and two pixels from the previous row, b and c:
+    *   prev: c b
+    *   row:  a d
+    * The Paeth function predicts d to be whichever of a, b, or c is nearest to
+    * p=a+b-c.
+    *
+    * The first pixel has no left context, and so uses an Up filter, p = b.
+    * This works naturally with our main loop's p = a+b-c if we force a and c
+    * to zero.
+    * Here we zero b and d, which become c and a respectively at the start of
+    * the loop.
+    */
+   size_t rb;
+   const __m128i zero = _mm_setzero_si128();
+   __m128i pa,pb,pc,smallest,nearest;
+   __m128i c, b = zero,
+           a, d = zero;
+
+   png_debug(1, "in png_read_filter_row_paeth4_sse2");
+
+   rb = row_info->rowbytes+4;
+   while (rb > 4) {
+      /* It's easiest to do this math (particularly, deal with pc) with 16-bit
+       * intermediates.
+       */
+      c = b; b = _mm_unpacklo_epi8(load4(prev), zero);
+      a = d; d = _mm_unpacklo_epi8(load4(row ), zero);
+
+      /* (p-a) == (a+b-c - a) == (b-c) */
+      pa = _mm_sub_epi16(b,c);
+
+      /* (p-b) == (a+b-c - b) == (a-c) */
+      pb = _mm_sub_epi16(a,c);
+
+      /* (p-c) == (a+b-c - c) == (a+b-c-c) == (b-c)+(a-c) */
+      pc = _mm_add_epi16(pa,pb);
+
+      pa = abs_i16(pa);  /* |p-a| */
+      pb = abs_i16(pb);  /* |p-b| */
+      pc = abs_i16(pc);  /* |p-c| */
+
+      smallest = _mm_min_epi16(pc, _mm_min_epi16(pa, pb));
+
+      /* Paeth breaks ties favoring a over b over c. */
+      nearest  = if_then_else(_mm_cmpeq_epi16(smallest, pa), a,
+                         if_then_else(_mm_cmpeq_epi16(smallest, pb), b,
+                                                                     c));
+
+      /* Note `_epi8`: we need addition to wrap modulo 255. */
+      d = _mm_add_epi8(d, nearest);
+      store4(row, _mm_packus_epi16(d,d));
+
+      prev += 4;
+      row  += 4;
+      rb   -= 4;
+   }
+}
+
+#endif /* PNG_INTEL_SSE_IMPLEMENTATION > 0 */
+#endif /* READ */
Index: libpng-src/libpng/pngread.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/pngread.c b/libpng-src/libpng/pngread.c
--- a/libpng-src/libpng/pngread.c	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/pngread.c	(date 1690795574122)
@@ -1,10 +1,10 @@
 
 /* pngread.c - read a PNG file
  *
- * Last changed in libpng 1.6.24 [August 4, 2016]
- * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ * Copyright (c) 2018-2019 Cosmin Truta
+ * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson
+ * Copyright (c) 1996-1997 Andreas Dilger
+ * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
@@ -174,6 +174,11 @@
       else if (chunk_name == png_cHRM)
          png_handle_cHRM(png_ptr, info_ptr, length);
 #endif
+
+#ifdef PNG_READ_eXIf_SUPPORTED
+      else if (chunk_name == png_eXIf)
+         png_handle_eXIf(png_ptr, info_ptr, length);
+#endif
 
 #ifdef PNG_READ_gAMA_SUPPORTED
       else if (chunk_name == png_gAMA)
@@ -359,9 +364,9 @@
 
          for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
          {
-            png_uint_32 s0   = (*(rp    ) << 8) | *(rp + 1);
-            png_uint_32 s1   = (*(rp + 2) << 8) | *(rp + 3);
-            png_uint_32 s2   = (*(rp + 4) << 8) | *(rp + 5);
+            png_uint_32 s0   = (png_uint_32)(*(rp    ) << 8) | *(rp + 1);
+            png_uint_32 s1   = (png_uint_32)(*(rp + 2) << 8) | *(rp + 3);
+            png_uint_32 s2   = (png_uint_32)(*(rp + 4) << 8) | *(rp + 5);
             png_uint_32 red  = (s0 + s1 + 65536) & 0xffff;
             png_uint_32 blue = (s2 + s1 + 65536) & 0xffff;
             *(rp    ) = (png_byte)((red >> 8) & 0xff);
@@ -534,6 +539,7 @@
       png_error(png_ptr, "Invalid attempt to read row data");
 
    /* Fill the row with IDAT data: */
+   png_ptr->row_buf[0]=255; /* to force error if no data was found */
    png_read_IDAT_data(png_ptr, png_ptr->row_buf, row_info.rowbytes + 1);
 
    if (png_ptr->row_buf[0] > PNG_FILTER_VALUE_NONE)
@@ -841,6 +847,11 @@
       else if (chunk_name == png_cHRM)
          png_handle_cHRM(png_ptr, info_ptr, length);
 #endif
+
+#ifdef PNG_READ_eXIf_SUPPORTED
+      else if (chunk_name == png_eXIf)
+         png_handle_eXIf(png_ptr, info_ptr, length);
+#endif
 
 #ifdef PNG_READ_gAMA_SUPPORTED
       else if (chunk_name == png_gAMA)
@@ -982,6 +993,12 @@
    png_free(png_ptr, png_ptr->chunk_list);
    png_ptr->chunk_list = NULL;
 #endif
+
+#if defined(PNG_READ_EXPAND_SUPPORTED) && \
+    defined(PNG_ARM_NEON_IMPLEMENTATION)
+   png_free(png_ptr, png_ptr->riffled_palette);
+   png_ptr->riffled_palette = NULL;
+#endif
 
    /* NOTE: the 'setjmp' buffer may still be allocated and the memory and error
     * callbacks are still set at this point.  They are required to complete the
@@ -1393,7 +1410,9 @@
    png_structrp png_ptr = image->opaque->png_ptr;
    png_inforp info_ptr = image->opaque->info_ptr;
 
+#ifdef PNG_BENIGN_ERRORS_SUPPORTED
    png_set_benign_errors(png_ptr, 1/*warn*/);
+#endif
    png_read_info(png_ptr, info_ptr);
 
    /* Do this the fast way; just read directly out of png_struct. */
@@ -1431,7 +1450,7 @@
             break;
 
          case PNG_COLOR_TYPE_PALETTE:
-            cmap_entries = png_ptr->num_palette;
+            cmap_entries = (png_uint_32)png_ptr->num_palette;
             break;
 
          default:
@@ -1519,7 +1538,7 @@
 #endif /* STDIO */
 
 static void PNGCBAPI
-png_image_memory_read(png_structp png_ptr, png_bytep out, png_size_t need)
+png_image_memory_read(png_structp png_ptr, png_bytep out, size_t need)
 {
    if (png_ptr != NULL)
    {
@@ -1530,7 +1549,7 @@
          if (cp != NULL)
          {
             png_const_bytep memory = cp->memory;
-            png_size_t size = cp->size;
+            size_t size = cp->size;
 
             if (memory != NULL && size >= need)
             {
@@ -1549,7 +1568,7 @@
 }
 
 int PNGAPI png_image_begin_read_from_memory(png_imagep image,
-    png_const_voidp memory, png_size_t size)
+    png_const_voidp memory, size_t size)
 {
    if (image != NULL && image->version == PNG_IMAGE_VERSION)
    {
@@ -1608,7 +1627,7 @@
     * errors (which are unfortunately quite common.)
     */
    {
-         static PNG_CONST png_byte chunks_to_process[] = {
+         static const png_byte chunks_to_process[] = {
             98,  75,  71,  68, '\0',  /* bKGD */
             99,  72,  82,  77, '\0',  /* cHRM */
            103,  65,  77,  65, '\0',  /* gAMA */
@@ -1745,9 +1764,9 @@
     png_uint_32 alpha, int encoding)
 {
    png_imagep image = display->image;
-   const int output_encoding = (image->format & PNG_FORMAT_FLAG_LINEAR) != 0 ?
+   int output_encoding = (image->format & PNG_FORMAT_FLAG_LINEAR) != 0 ?
        P_LINEAR : P_sRGB;
-   const int convert_to_Y = (image->format & PNG_FORMAT_FLAG_COLOR) == 0 &&
+   int convert_to_Y = (image->format & PNG_FORMAT_FLAG_COLOR) == 0 &&
        (red != green || green != blue);
 
    if (ip > 255)
@@ -1856,13 +1875,13 @@
    /* Store the value. */
    {
 #     ifdef PNG_FORMAT_AFIRST_SUPPORTED
-         const int afirst = (image->format & PNG_FORMAT_FLAG_AFIRST) != 0 &&
+         int afirst = (image->format & PNG_FORMAT_FLAG_AFIRST) != 0 &&
             (image->format & PNG_FORMAT_FLAG_ALPHA) != 0;
 #     else
 #        define afirst 0
 #     endif
 #     ifdef PNG_FORMAT_BGR_SUPPORTED
-         const int bgr = (image->format & PNG_FORMAT_FLAG_BGR) != 0 ? 2 : 0;
+         int bgr = (image->format & PNG_FORMAT_FLAG_BGR) != 0 ? 2 : 0;
 #     else
 #        define bgr 0
 #     endif
@@ -1881,7 +1900,7 @@
          {
             case 4:
                entry[afirst ? 0 : 3] = (png_uint_16)alpha;
-               /* FALL THROUGH */
+               /* FALLTHROUGH */
 
             case 3:
                if (alpha < 65535)
@@ -1903,7 +1922,7 @@
 
             case 2:
                entry[1 ^ afirst] = (png_uint_16)alpha;
-               /* FALL THROUGH */
+               /* FALLTHROUGH */
 
             case 1:
                if (alpha < 65535)
@@ -1932,6 +1951,7 @@
          {
             case 4:
                entry[afirst ? 0 : 3] = (png_byte)alpha;
+               /* FALLTHROUGH */
             case 3:
                entry[afirst + (2 ^ bgr)] = (png_byte)blue;
                entry[afirst + 1] = (png_byte)green;
@@ -1940,6 +1960,7 @@
 
             case 2:
                entry[1 ^ afirst] = (png_byte)alpha;
+               /* FALLTHROUGH */
             case 1:
                entry[afirst] = (png_byte)green;
                break;
@@ -1966,7 +1987,7 @@
    for (i=0; i<256; ++i)
       png_create_colormap_entry(display, i, i, i, i, 255, P_FILE);
 
-   return i;
+   return (int)i;
 }
 
 static int
@@ -1977,7 +1998,7 @@
    for (i=0; i<256; ++i)
       png_create_colormap_entry(display, i, i, i, i, 255, P_sRGB);
 
-   return i;
+   return (int)i;
 }
 #define PNG_GRAY_COLORMAP_ENTRIES 256
 
@@ -2031,7 +2052,7 @@
              P_sRGB);
    }
 
-   return i;
+   return (int)i;
 }
 
 #define PNG_GA_COLORMAP_ENTRIES 256
@@ -2056,7 +2077,7 @@
       }
    }
 
-   return i;
+   return (int)i;
 }
 
 #define PNG_RGB_COLORMAP_ENTRIES 216
@@ -2070,11 +2091,11 @@
 {
    png_image_read_control *display =
       png_voidcast(png_image_read_control*, argument);
-   const png_imagep image = display->image;
+   png_imagep image = display->image;
 
-   const png_structrp png_ptr = image->opaque->png_ptr;
-   const png_uint_32 output_format = image->format;
-   const int output_encoding = (output_format & PNG_FORMAT_FLAG_LINEAR) != 0 ?
+   png_structrp png_ptr = image->opaque->png_ptr;
+   png_uint_32 output_format = image->format;
+   int output_encoding = (output_format & PNG_FORMAT_FLAG_LINEAR) != 0 ?
       P_LINEAR : P_sRGB;
 
    unsigned int cmap_entries;
@@ -2249,7 +2270,7 @@
             if (PNG_GRAY_COLORMAP_ENTRIES > image->colormap_entries)
                png_error(png_ptr, "gray[16] color-map: too few entries");
 
-            cmap_entries = make_gray_colormap(display);
+            cmap_entries = (unsigned int)make_gray_colormap(display);
 
             if (png_ptr->num_trans > 0)
             {
@@ -2347,7 +2368,7 @@
             if (PNG_GA_COLORMAP_ENTRIES > image->colormap_entries)
                png_error(png_ptr, "gray+alpha color-map: too few entries");
 
-            cmap_entries = make_ga_colormap(display);
+            cmap_entries = (unsigned int)make_ga_colormap(display);
 
             background_index = PNG_CMAP_GA_BACKGROUND;
             output_processing = PNG_CMAP_GA;
@@ -2381,7 +2402,7 @@
                if (PNG_GRAY_COLORMAP_ENTRIES > image->colormap_entries)
                   png_error(png_ptr, "gray-alpha color-map: too few entries");
 
-               cmap_entries = make_gray_colormap(display);
+               cmap_entries = (unsigned int)make_gray_colormap(display);
 
                if (output_encoding == P_LINEAR)
                {
@@ -2520,7 +2541,7 @@
                if (PNG_GA_COLORMAP_ENTRIES > image->colormap_entries)
                   png_error(png_ptr, "rgb[ga] color-map: too few entries");
 
-               cmap_entries = make_ga_colormap(display);
+               cmap_entries = (unsigned int)make_ga_colormap(display);
                background_index = PNG_CMAP_GA_BACKGROUND;
                output_processing = PNG_CMAP_GA;
             }
@@ -2546,12 +2567,12 @@
                   png_ptr->num_trans > 0) &&
                   png_gamma_not_sRGB(png_ptr->colorspace.gamma) != 0)
                {
-                  cmap_entries = make_gray_file_colormap(display);
+                  cmap_entries = (unsigned int)make_gray_file_colormap(display);
                   data_encoding = P_FILE;
                }
 
                else
-                  cmap_entries = make_gray_colormap(display);
+                  cmap_entries = (unsigned int)make_gray_colormap(display);
 
                /* But if the input has alpha or transparency it must be removed
                 */
@@ -2639,7 +2660,7 @@
                   if (PNG_RGB_COLORMAP_ENTRIES+1+27 > image->colormap_entries)
                      png_error(png_ptr, "rgb+alpha color-map: too few entries");
 
-                  cmap_entries = make_rgb_colormap(display);
+                  cmap_entries = (unsigned int)make_rgb_colormap(display);
 
                   /* Add a transparent entry. */
                   png_create_colormap_entry(display, cmap_entries, 255, 255,
@@ -2688,7 +2709,7 @@
                   if (PNG_RGB_COLORMAP_ENTRIES+1+27 > image->colormap_entries)
                      png_error(png_ptr, "rgb-alpha color-map: too few entries");
 
-                  cmap_entries = make_rgb_colormap(display);
+                  cmap_entries = (unsigned int)make_rgb_colormap(display);
 
                   png_create_colormap_entry(display, cmap_entries, back_r,
                       back_g, back_b, 0/*unused*/, output_encoding);
@@ -2773,7 +2794,7 @@
                if (PNG_RGB_COLORMAP_ENTRIES > image->colormap_entries)
                   png_error(png_ptr, "rgb color-map: too few entries");
 
-               cmap_entries = make_rgb_colormap(display);
+               cmap_entries = (unsigned int)make_rgb_colormap(display);
                output_processing = PNG_CMAP_RGB;
             }
          }
@@ -2787,7 +2808,7 @@
             unsigned int num_trans = png_ptr->num_trans;
             png_const_bytep trans = num_trans > 0 ? png_ptr->trans_alpha : NULL;
             png_const_colorp colormap = png_ptr->palette;
-            const int do_background = trans != NULL &&
+            int do_background = trans != NULL &&
                (output_format & PNG_FORMAT_FLAG_ALPHA) == 0;
             unsigned int i;
 
@@ -2797,11 +2818,11 @@
 
             output_processing = PNG_CMAP_NONE;
             data_encoding = P_FILE; /* Don't change from color-map indices */
-            cmap_entries = png_ptr->num_palette;
+            cmap_entries = (unsigned int)png_ptr->num_palette;
             if (cmap_entries > 256)
                cmap_entries = 256;
 
-            if (cmap_entries > image->colormap_entries)
+            if (cmap_entries > (unsigned int)image->colormap_entries)
                png_error(png_ptr, "palette color-map: too few entries");
 
             for (i=0; i < cmap_entries; ++i)
@@ -2859,7 +2880,7 @@
       case P_sRGB:
          /* Change to 8-bit sRGB */
          png_set_alpha_mode_fixed(png_ptr, PNG_ALPHA_PNG, PNG_GAMMA_sRGB);
-         /* FALL THROUGH */
+         /* FALLTHROUGH */
 
       case P_FILE:
          if (png_ptr->bit_depth > 8)
@@ -2913,7 +2934,7 @@
          png_error(png_ptr, "bad background index (internal error)");
    }
 
-   display->colormap_processing = output_processing;
+   display->colormap_processing = (int)output_processing;
 
    return 1/*ok*/;
 }
@@ -3177,8 +3198,7 @@
             image->colormap_entries == 244 /* 216 + 1 + 27 */)
             break;
 
-         /* goto bad_output; */
-         /* FALL THROUGH */
+         goto bad_output;
 
       default:
       bad_output:
@@ -3222,14 +3242,14 @@
 
    else
    {
-      png_alloc_size_t row_bytes = display->row_bytes;
+      png_alloc_size_t row_bytes = (png_alloc_size_t)display->row_bytes;
 
       while (--passes >= 0)
       {
          png_uint_32      y = image->height;
          png_bytep        row = png_voidcast(png_bytep, display->first_row);
 
-         while (y-- > 0)
+         for (; y > 0; --y)
          {
             png_read_row(png_ptr, row, NULL);
             row += row_bytes;
@@ -3432,7 +3452,6 @@
 
             for (pass = 0; pass < passes; ++pass)
             {
-               png_bytep row = png_voidcast(png_bytep, display->first_row);
                unsigned int     startx, stepx, stepy;
                png_uint_32      y;
 
@@ -3537,8 +3556,6 @@
 
                         inrow += 2; /* gray and alpha channel */
                      }
-
-                     row += display->row_bytes;
                   }
                }
             }
@@ -3557,8 +3574,9 @@
              * stride which was multiplied by 2 (below) to get row_bytes.
              */
             ptrdiff_t    step_row = display->row_bytes / 2;
-            int preserve_alpha = (image->format & PNG_FORMAT_FLAG_ALPHA) != 0;
-            unsigned int outchannels = 1+preserve_alpha;
+            unsigned int preserve_alpha = (image->format &
+                PNG_FORMAT_FLAG_ALPHA) != 0;
+            unsigned int outchannels = 1U+preserve_alpha;
             int swap_alpha = 0;
 
 #           ifdef PNG_SIMPLIFIED_READ_AFIRST_SUPPORTED
@@ -3745,6 +3763,12 @@
          output_gamma = PNG_DEFAULT_sRGB;
       }
 
+      if ((change & PNG_FORMAT_FLAG_ASSOCIATED_ALPHA) != 0)
+      {
+         mode = PNG_ALPHA_OPTIMIZED;
+         change &= ~PNG_FORMAT_FLAG_ASSOCIATED_ALPHA;
+      }
+
       /* If 'do_local_background' is set check for the presence of gamma
        * correction; this is part of the work-round for the libpng bug
        * described above.
@@ -3925,7 +3949,7 @@
        */
       if (linear != 0)
       {
-         PNG_CONST png_uint_16 le = 0x0001;
+         png_uint_16 le = 0x0001;
 
          if ((*(png_const_bytep) & le) != 0)
             png_set_swap(png_ptr);
@@ -3970,6 +3994,10 @@
       else if (do_local_compose != 0) /* internal error */
          png_error(png_ptr, "png_image_read: alpha channel lost");
 
+      if ((format & PNG_FORMAT_FLAG_ASSOCIATED_ALPHA) != 0) {
+         info_format |= PNG_FORMAT_FLAG_ASSOCIATED_ALPHA;
+      }
+
       if (info_ptr->bit_depth == 16)
          info_format |= PNG_FORMAT_FLAG_LINEAR;
 
@@ -4055,14 +4083,14 @@
 
    else
    {
-      png_alloc_size_t row_bytes = display->row_bytes;
+      png_alloc_size_t row_bytes = (png_alloc_size_t)display->row_bytes;
 
       while (--passes >= 0)
       {
          png_uint_32      y = image->height;
          png_bytep        row = png_voidcast(png_bytep, display->first_row);
 
-         while (y-- > 0)
+         for (; y > 0; --y)
          {
             png_read_row(png_ptr, row, NULL);
             row += row_bytes;
@@ -4083,7 +4111,7 @@
        * original PNG format because it may not occur in the output PNG format
        * and libpng deals with the issues of reading the original.
        */
-      const unsigned int channels = PNG_IMAGE_PIXEL_CHANNELS(image->format);
+      unsigned int channels = PNG_IMAGE_PIXEL_CHANNELS(image->format);
 
       /* The following checks just the 'row_stride' calculation to ensure it
        * fits in a signed 32-bit value.  Because channels/components can be
@@ -4091,19 +4119,19 @@
        * bits; this is just to verify that the 'row_stride' argument can be
        * represented.
        */
-      if (image->width <= 0x7FFFFFFFU/channels) /* no overflow */
+      if (image->width <= 0x7fffffffU/channels) /* no overflow */
       {
          png_uint_32 check;
-         const png_uint_32 png_row_stride = image->width * channels;
+         png_uint_32 png_row_stride = image->width * channels;
 
          if (row_stride == 0)
             row_stride = (png_int_32)/*SAFE*/png_row_stride;
 
          if (row_stride < 0)
-            check = -row_stride;
+            check = (png_uint_32)(-row_stride);
 
          else
-            check = row_stride;
+            check = (png_uint_32)row_stride;
 
          /* This verifies 'check', the absolute value of the actual stride
           * passed in and detects overflow in the application calculation (i.e.
@@ -4125,10 +4153,10 @@
              *
              * NOTE: this will be changed in 1.7 because PNG_IMAGE_BUFFER_SIZE
              * will be changed to use png_alloc_size_t; bigger images can be
-             * accomodated on 64-bit systems.
+             * accommodated on 64-bit systems.
              */
             if (image->height <=
-                0xFFFFFFFFU/PNG_IMAGE_PIXEL_COMPONENT_SIZE(image->format)/check)
+                0xffffffffU/PNG_IMAGE_PIXEL_COMPONENT_SIZE(image->format)/check)
             {
                if ((image->format & PNG_FORMAT_FLAG_COLORMAP) == 0 ||
                   (image->colormap_entries > 0 && colormap != NULL))
Index: openbabel-src/openbabel/include/openbabel/inchiformat.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/inchiformat.h b/openbabel-src/openbabel/include/openbabel/inchiformat.h
--- a/openbabel-src/openbabel/include/openbabel/inchiformat.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/inchiformat.h	(date 1689048275862)
@@ -131,7 +131,6 @@
   // and "CH4" is less than "C2H6"
   // and "CH4" is less than "ClH" (hydrogen chloride)
   struct InchiLess
-    : public std::binary_function<const std::string&, const std::string&, bool>
   {
     bool operator()(const std::string& s1, const std::string& s2) const
     {
@@ -146,12 +145,14 @@
           {
             n1 = atoi(&*p1);
             //skip over number
-            while(p1!=s1.end() && isdigit(*p1++)); --p1;
+            while(p1!=s1.end() && isdigit(*p1++)) {}
+            --p1;
           }
         if(isdigit(*p2))
           {
             n2 = atoi(&*p2);
-            while(p2!=s2.end() && isdigit(*p2++)); --p2;
+            while(p2!=s2.end() && isdigit(*p2++)) {}
+            --p2;
           }
         if(n1<0 && n2 < 0)
           {
Index: libpng-src/libpng/pngwio.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/pngwio.c b/libpng-src/libpng/pngwio.c
--- a/libpng-src/libpng/pngwio.c	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/pngwio.c	(date 1690795574122)
@@ -1,10 +1,10 @@
 
 /* pngwio.c - functions for data output
  *
- * Last changed in libpng 1.6.24 [August 4, 2016]
- * Copyright (c) 1998-2002,2004,2006-2014,2016 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ * Copyright (c) 2018 Cosmin Truta
+ * Copyright (c) 1998-2002,2004,2006-2014,2016,2018 Glenn Randers-Pehrson
+ * Copyright (c) 1996-1997 Andreas Dilger
+ * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
@@ -30,7 +30,7 @@
  */
 
 void /* PRIVATE */
-png_write_data(png_structrp png_ptr, png_const_bytep data, png_size_t length)
+png_write_data(png_structrp png_ptr, png_const_bytep data, size_t length)
 {
    /* NOTE: write_data_fn must not change the buffer! */
    if (png_ptr->write_data_fn != NULL )
@@ -48,9 +48,9 @@
  * than changing the library.
  */
 void PNGCBAPI
-png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
+png_default_write_data(png_structp png_ptr, png_bytep data, size_t length)
 {
-   png_size_t check;
+   size_t check;
 
    if (png_ptr == NULL)
       return;
Index: libpng-src/libpng/pngtrans.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/pngtrans.c b/libpng-src/libpng/pngtrans.c
--- a/libpng-src/libpng/pngtrans.c	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/pngtrans.c	(date 1690795574122)
@@ -1,10 +1,10 @@
 
 /* pngtrans.c - transforms the data in a row (used by both readers and writers)
  *
- * Last changed in libpng 1.6.24 [August 4, 2016]
- * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ * Copyright (c) 2018 Cosmin Truta
+ * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson
+ * Copyright (c) 1996-1997 Andreas Dilger
+ * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
@@ -269,8 +269,8 @@
    if (row_info->color_type == PNG_COLOR_TYPE_GRAY)
    {
       png_bytep rp = row;
-      png_size_t i;
-      png_size_t istop = row_info->rowbytes;
+      size_t i;
+      size_t istop = row_info->rowbytes;
 
       for (i = 0; i < istop; i++)
       {
@@ -283,8 +283,8 @@
       row_info->bit_depth == 8)
    {
       png_bytep rp = row;
-      png_size_t i;
-      png_size_t istop = row_info->rowbytes;
+      size_t i;
+      size_t istop = row_info->rowbytes;
 
       for (i = 0; i < istop; i += 2)
       {
@@ -298,8 +298,8 @@
       row_info->bit_depth == 16)
    {
       png_bytep rp = row;
-      png_size_t i;
-      png_size_t istop = row_info->rowbytes;
+      size_t i;
+      size_t istop = row_info->rowbytes;
 
       for (i = 0; i < istop; i += 4)
       {
@@ -345,7 +345,7 @@
 #endif
 
 #if defined(PNG_READ_PACKSWAP_SUPPORTED)||defined(PNG_WRITE_PACKSWAP_SUPPORTED)
-static PNG_CONST png_byte onebppswaptable[256] = {
+static const png_byte onebppswaptable[256] = {
    0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
    0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
    0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
@@ -380,7 +380,7 @@
    0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
 };
 
-static PNG_CONST png_byte twobppswaptable[256] = {
+static const png_byte twobppswaptable[256] = {
    0x00, 0x40, 0x80, 0xC0, 0x10, 0x50, 0x90, 0xD0,
    0x20, 0x60, 0xA0, 0xE0, 0x30, 0x70, 0xB0, 0xF0,
    0x04, 0x44, 0x84, 0xC4, 0x14, 0x54, 0x94, 0xD4,
@@ -415,7 +415,7 @@
    0x2F, 0x6F, 0xAF, 0xEF, 0x3F, 0x7F, 0xBF, 0xFF
 };
 
-static PNG_CONST png_byte fourbppswaptable[256] = {
+static const png_byte fourbppswaptable[256] = {
    0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
    0x80, 0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0,
    0x01, 0x11, 0x21, 0x31, 0x41, 0x51, 0x61, 0x71,
@@ -514,11 +514,15 @@
          if (at_start != 0) /* Skip initial filler */
             ++sp;
          else          /* Skip initial channel and, for sp, the filler */
-            sp += 2, ++dp;
+         {
+            sp += 2; ++dp;
+         }
 
          /* For a 1 pixel wide image there is nothing to do */
          while (sp < ep)
-            *dp++ = *sp, sp += 2;
+         {
+            *dp++ = *sp; sp += 2;
+         }
 
          row_info->pixel_depth = 8;
       }
@@ -528,10 +532,14 @@
          if (at_start != 0) /* Skip initial filler */
             sp += 2;
          else          /* Skip initial channel and, for sp, the filler */
-            sp += 4, dp += 2;
+         {
+            sp += 4; dp += 2;
+         }
 
          while (sp < ep)
-            *dp++ = *sp++, *dp++ = *sp, sp += 3;
+         {
+            *dp++ = *sp++; *dp++ = *sp; sp += 3;
+         }
 
          row_info->pixel_depth = 16;
       }
@@ -554,11 +562,15 @@
          if (at_start != 0) /* Skip initial filler */
             ++sp;
          else          /* Skip initial channels and, for sp, the filler */
-            sp += 4, dp += 3;
+         {
+            sp += 4; dp += 3;
+         }
 
          /* Note that the loop adds 3 to dp and 4 to sp each time. */
          while (sp < ep)
-            *dp++ = *sp++, *dp++ = *sp++, *dp++ = *sp, sp += 2;
+         {
+            *dp++ = *sp++; *dp++ = *sp++; *dp++ = *sp; sp += 2;
+         }
 
          row_info->pixel_depth = 24;
       }
@@ -568,14 +580,16 @@
          if (at_start != 0) /* Skip initial filler */
             sp += 2;
          else          /* Skip initial channels and, for sp, the filler */
-            sp += 8, dp += 6;
+         {
+            sp += 8; dp += 6;
+         }
 
          while (sp < ep)
          {
             /* Copy 6 bytes, skip 2 */
-            *dp++ = *sp++, *dp++ = *sp++;
-            *dp++ = *sp++, *dp++ = *sp++;
-            *dp++ = *sp++, *dp++ = *sp, sp += 3;
+            *dp++ = *sp++; *dp++ = *sp++;
+            *dp++ = *sp++; *dp++ = *sp++;
+            *dp++ = *sp++; *dp++ = *sp; sp += 3;
          }
 
          row_info->pixel_depth = 48;
@@ -595,7 +609,7 @@
       return; /* The filler channel has gone already */
 
    /* Fix the rowbytes value. */
-   row_info->rowbytes = dp-row;
+   row_info->rowbytes = (size_t)(dp-row);
 }
 #endif
 
@@ -693,8 +707,8 @@
        * and this calculation is used because it avoids warnings that other
        * forms produced on either GCC or MSVC.
        */
-      int padding = (-row_info->pixel_depth * row_info->width) & 7;
-      png_bytep rp = png_ptr->row_buf + row_info->rowbytes;
+      int padding = PNG_PADBITS(row_info->pixel_depth, row_info->width);
+      png_bytep rp = png_ptr->row_buf + row_info->rowbytes - 1;
 
       switch (row_info->bit_depth)
       {
Index: indigo-src/indigo/api/c/indigo/src/indigo_composition.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_composition.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_composition.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_composition.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_composition.cpp	(date 1690767117645)
@@ -23,7 +23,7 @@
 
 using MoleculeIter = MoleculeRGroupsComposition::MoleculeIter;
 
-class DLLEXPORT IndigoCompositionElem : public IndigoObject
+class IndigoCompositionElem : public IndigoObject
 {
 public:
     IndigoCompositionElem() : IndigoObject(COMPOSITION_ELEM)
@@ -37,7 +37,7 @@
     MoleculeRGroups variants[RGCOMP_OPT_COUNT];
 };
 
-CEXPORT int indigoGetFragmentedMolecule(int elem, const char* options)
+int indigoGetFragmentedMolecule(int elem, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -72,7 +72,7 @@
     INDIGO_END(-1);
 }
 
-class DLLEXPORT IndigoCompositionIter : public IndigoObject
+class IndigoCompositionIter : public IndigoObject
 {
 public:
     IndigoCompositionIter(BaseMolecule& mol) : IndigoObject(COMPOSITION_ITER), _composition(mol), _it(_composition.begin()), _end(_composition.end())
@@ -112,7 +112,7 @@
     bool _hasNext = true;
 };
 
-CEXPORT int indigoRGroupComposition(int molecule, const char* options)
+int indigoRGroupComposition(int molecule, const char* options)
 {
     INDIGO_BEGIN
     {
Index: cairo-src/cairo/src/cairo-compiler-private.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cairo-src/cairo/src/cairo-compiler-private.h b/cairo-src/cairo/src/cairo-compiler-private.h
--- a/cairo-src/cairo/src/cairo-compiler-private.h	(revision c3b672634f0635af1ad0ffa8c15b34fc7c1035cf)
+++ b/cairo-src/cairo/src/cairo-compiler-private.h	(date 1690943826262)
@@ -84,7 +84,7 @@
  * don't need to be hidden and re-exported using the slim hidden
  * macros.
  */
-#if __GNUC__ >= 3 && defined(__ELF__) && !defined(__sun)
+#if 0 && __GNUC__ >= 3 && defined(__ELF__) && !defined(__sun) && !defined(__clang__)
 # define slim_hidden_proto(name)		slim_hidden_proto1(name, slim_hidden_int_name(name)) cairo_private
 # define slim_hidden_proto_no_warn(name)	slim_hidden_proto1(name, slim_hidden_int_name(name)) cairo_private_no_warn
 # define slim_hidden_def(name)			slim_hidden_def1(name, slim_hidden_int_name(name))
Index: openbabel-src/openbabel/include/openbabel/plugin.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/plugin.h b/openbabel-src/openbabel/include/openbabel/plugin.h
--- a/openbabel-src/openbabel/include/openbabel/plugin.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/plugin.h	(date 1690877942623)
@@ -20,7 +20,6 @@
 #define OB_PLUGIN_H
 
 #include <openbabel/babelconfig.h>
-#include <openbabel/dlhandler.h>
 #include <string>
 #include <iostream>
 #include <vector>
@@ -38,7 +37,7 @@
 ///@{
 
 /// @brief Case insensitive string comparison for PluginMapType key.
-struct OBERROR CharPtrLess : public std::binary_function<const char*,const char*, bool>
+struct OBERROR CharPtrLess
 {
   bool operator()(const char* p1,const char* p2) const
   { return strcasecmp(p1,p2)<0; }
@@ -150,53 +149,13 @@
   const char* _id;
 };
 
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-
 //Macro to be added to definition of the base class
 #define MAKE_PLUGIN(BaseClass)\
-protected:\
-  static PluginMapType& Map();\
-  virtual PluginMapType& GetMap() const {\
-    return Map();\
-  }\
-public:\
-  static BaseClass*& Default() {\
-    static BaseClass* d;\
-    return d;\
-  }\
-  BaseClass(const char* ID, bool IsDefault=false) {\
-    _id=ID;\
-    if (ID&&*ID) {\
-      if (IsDefault || Map().empty()) {\
-        Default() = this;\
-      }\
-      if (Map().count(ID) == 0) {\
-        Map()[ID] = this;\
-        PluginMap()[TypeID()] = this;\
-      }\
-    }\
-  }\
-  static BaseClass* FindType(const char* ID) {\
-    if (!ID || *ID==0 || *ID==' ') {\
-      return Default();\
-    }\
-    return static_cast<BaseClass*>(BaseFindType(Map(),ID));\
-  }
-
-#define PLUGIN_CPP_FILE(BaseClass)\
-OBPlugin::PluginMapType& BaseClass::Map() {\
-  static OBPlugin::PluginMapType map;\
-  return map;\
-}
-
-#else // __CYGWIN__ || __MINGW32__
-
-//Macro to be added to definition of the base class
-#define MAKE_PLUGIN(BaseClass)\
+private:\
+   inline static PluginMapType mPluginMapHolder;\
 protected:\
   static PluginMapType& Map() {\
-    static PluginMapType m;\
-    return m;\
+    return mPluginMapHolder;\
   }\
   virtual PluginMapType& GetMap() const {\
     return Map();\
@@ -223,9 +182,8 @@
       return Default();\
     }\
     return static_cast<BaseClass*>(BaseFindType(Map(),ID));\
-  }
-
-#endif // __CYGWIN__ || __MINGW32__
+  }\
+  private:
 
 /** \file plugin.h
    \brief Simplify 'plugin' classes to be discovered and/or loaded at runtime.
@@ -371,7 +329,7 @@
 
 #define OB_STATIC_PLUGIN(className,instanceName) \
   class className; \
-  OBAPI OB_EXTERN className instanceName;
+  OB_EXTERN className instanceName;
 
   // formats
   OB_STATIC_PLUGIN(ABINITFormat, theABINITFormat)
@@ -430,6 +388,8 @@
   OB_STATIC_PLUGIN(HINFormat, theHINFormat)
   OB_STATIC_PLUGIN(JaguarOutputFormat, theJaguarOutputFormat)
   OB_STATIC_PLUGIN(JaguarInputFormat, theJaguarInputFormat)
+  OB_STATIC_PLUGIN(ChemDoodleJSONFormat, theChemDoodleJSONFormat)
+  OB_STATIC_PLUGIN(PubChemJSONFormat, thePubChemJSONFormat)
   OB_STATIC_PLUGIN(LMPDATFormat, theLMPDATFormat)
   OB_STATIC_PLUGIN(MCDLFormat, theMCDLFormat)
   OB_STATIC_PLUGIN(MOLFormat, theMOLFormat)
@@ -463,6 +423,7 @@
   OB_STATIC_PLUGIN(PDBQTFormat, thePDBQTFormat)
 #ifdef HAVE_LIBZ
   OB_STATIC_PLUGIN(PNGFormat, thePNGFormat)
+  OB_STATIC_PLUGIN(PNG2Format, thePNG2Format)
 #endif
   OB_STATIC_PLUGIN(PointCloudFormat, thePointCloudFormat)
   OB_STATIC_PLUGIN(PovrayFormat, thePovrayFormat)
@@ -502,6 +463,8 @@
 #endif
 #ifdef HAVE_STATIC_INCHI
   OB_STATIC_PLUGIN(InChIFormat, theInChIFormat)
+  OB_STATIC_PLUGIN(InChICompareFormat, theInChICompareFormat)
+  OB_STATIC_PLUGIN(InChIKeyFormat, theInChIKeyFormat)
 #endif
 #ifdef HAVE_REGEX_H
   OB_STATIC_PLUGIN(GAMESSUKInputFormat, theGAMESSUKInputFormat)
@@ -560,6 +523,7 @@
   OB_STATIC_PLUGIN(OpFillUC, theOpFillUC)
   OB_STATIC_PLUGIN(OpEnergy, theOpEnergy)
   OB_STATIC_PLUGIN(OpMinimize, theOpMinimize)
+  OB_STATIC_PLUGIN(Op2D, theOp2D)
   OB_STATIC_PLUGIN(OpGen2D, theOpGen2D)
   OB_STATIC_PLUGIN(OpGen3D, theOpGen3D)
   OB_STATIC_PLUGIN(OpNewS, theOpNewS)
Index: libpng-src/libpng/pngpread.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/pngpread.c b/libpng-src/libpng/pngpread.c
--- a/libpng-src/libpng/pngpread.c	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/pngpread.c	(date 1690795574122)
@@ -1,10 +1,10 @@
 
 /* pngpread.c - read a png file in push mode
  *
- * Last changed in libpng 1.6.24 [August 4, 2016]
- * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ * Copyright (c) 2018 Cosmin Truta
+ * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson
+ * Copyright (c) 1996-1997 Andreas Dilger
+ * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
@@ -34,7 +34,7 @@
 
 void PNGAPI
 png_process_data(png_structrp png_ptr, png_inforp info_ptr,
-    png_bytep buffer, png_size_t buffer_size)
+    png_bytep buffer, size_t buffer_size)
 {
    if (png_ptr == NULL || info_ptr == NULL)
       return;
@@ -47,7 +47,7 @@
    }
 }
 
-png_size_t PNGAPI
+size_t PNGAPI
 png_process_data_pause(png_structrp png_ptr, int save)
 {
    if (png_ptr != NULL)
@@ -60,7 +60,7 @@
       else
       {
          /* This includes any pending saved bytes: */
-         png_size_t remaining = png_ptr->buffer_size;
+         size_t remaining = png_ptr->buffer_size;
          png_ptr->buffer_size = 0;
 
          /* So subtract the saved buffer size, unless all the data
@@ -133,8 +133,8 @@
 void /* PRIVATE */
 png_push_read_sig(png_structrp png_ptr, png_inforp info_ptr)
 {
-   png_size_t num_checked = png_ptr->sig_bytes, /* SAFE, does not exceed 8 */
-       num_to_check = 8 - num_checked;
+   size_t num_checked = png_ptr->sig_bytes; /* SAFE, does not exceed 8 */
+   size_t num_to_check = 8 - num_checked;
 
    if (png_ptr->buffer_size < num_to_check)
    {
@@ -189,6 +189,7 @@
       png_crc_read(png_ptr, chunk_tag, 4);
       png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(chunk_tag);
       png_check_chunk_name(png_ptr, png_ptr->chunk_name);
+      png_check_chunk_length(png_ptr, png_ptr->push_length);
       png_ptr->mode |= PNG_HAVE_CHUNK_HEADER;
    }
 
@@ -417,7 +418,7 @@
 }
 
 void PNGCBAPI
-png_push_fill_buffer(png_structp png_ptr, png_bytep buffer, png_size_t length)
+png_push_fill_buffer(png_structp png_ptr, png_bytep buffer, size_t length)
 {
    png_bytep ptr;
 
@@ -427,7 +428,7 @@
    ptr = buffer;
    if (png_ptr->save_buffer_size != 0)
    {
-      png_size_t save_size;
+      size_t save_size;
 
       if (length < png_ptr->save_buffer_size)
          save_size = length;
@@ -444,7 +445,7 @@
    }
    if (length != 0 && png_ptr->current_buffer_size != 0)
    {
-      png_size_t save_size;
+      size_t save_size;
 
       if (length < png_ptr->current_buffer_size)
          save_size = length;
@@ -466,7 +467,7 @@
    {
       if (png_ptr->save_buffer_ptr != png_ptr->save_buffer)
       {
-         png_size_t i, istop;
+         size_t i, istop;
          png_bytep sp;
          png_bytep dp;
 
@@ -481,7 +482,7 @@
    if (png_ptr->save_buffer_size + png_ptr->current_buffer_size >
        png_ptr->save_buffer_max)
    {
-      png_size_t new_max;
+      size_t new_max;
       png_bytep old_buffer;
 
       if (png_ptr->save_buffer_size > PNG_SIZE_MAX -
@@ -493,7 +494,7 @@
       new_max = png_ptr->save_buffer_size + png_ptr->current_buffer_size + 256;
       old_buffer = png_ptr->save_buffer;
       png_ptr->save_buffer = (png_bytep)png_malloc_warn(png_ptr,
-          (png_size_t)new_max);
+          (size_t)new_max);
 
       if (png_ptr->save_buffer == NULL)
       {
@@ -521,7 +522,7 @@
 
 void /* PRIVATE */
 png_push_restore_buffer(png_structrp png_ptr, png_bytep buffer,
-    png_size_t buffer_length)
+    size_t buffer_length)
 {
    png_ptr->current_buffer = buffer;
    png_ptr->current_buffer_size = buffer_length;
@@ -561,7 +562,7 @@
 
    if (png_ptr->idat_size != 0 && png_ptr->save_buffer_size != 0)
    {
-      png_size_t save_size = png_ptr->save_buffer_size;
+      size_t save_size = png_ptr->save_buffer_size;
       png_uint_32 idat_size = png_ptr->idat_size;
 
       /* We want the smaller of 'idat_size' and 'current_buffer_size', but they
@@ -571,7 +572,7 @@
        * will break on either 16-bit or 64-bit platforms.
        */
       if (idat_size < save_size)
-         save_size = (png_size_t)idat_size;
+         save_size = (size_t)idat_size;
 
       else
          idat_size = (png_uint_32)save_size;
@@ -588,7 +589,7 @@
 
    if (png_ptr->idat_size != 0 && png_ptr->current_buffer_size != 0)
    {
-      png_size_t save_size = png_ptr->current_buffer_size;
+      size_t save_size = png_ptr->current_buffer_size;
       png_uint_32 idat_size = png_ptr->idat_size;
 
       /* We want the smaller of 'idat_size' and 'current_buffer_size', but they
@@ -597,7 +598,7 @@
        * larger - this cannot overflow.
        */
       if (idat_size < save_size)
-         save_size = (png_size_t)idat_size;
+         save_size = (size_t)idat_size;
 
       else
          idat_size = (png_uint_32)save_size;
@@ -624,7 +625,7 @@
 
 void /* PRIVATE */
 png_process_IDAT_data(png_structrp png_ptr, png_bytep buffer,
-    png_size_t buffer_length)
+    size_t buffer_length)
 {
    /* The caller checks for a non-zero buffer length. */
    if (!(buffer_length > 0) || buffer == NULL)
@@ -684,7 +685,12 @@
             png_warning(png_ptr, "Truncated compressed data in IDAT");
 
          else
-            png_error(png_ptr, "Decompression error in IDAT");
+         {
+            if (ret == Z_DATA_ERROR)
+               png_benign_error(png_ptr, "IDAT: ADLER32 checksum mismatch");
+            else
+               png_error(png_ptr, "Decompression error in IDAT");
+         }
 
          /* Skip the check on unprocessed input */
          return;
@@ -966,20 +972,20 @@
    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
 
    /* Start of interlace block */
-   static PNG_CONST png_byte png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};
+   static const png_byte png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};
 
    /* Offset to next interlace block */
-   static PNG_CONST png_byte png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};
+   static const png_byte png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};
 
    /* Start of interlace block in the y direction */
-   static PNG_CONST png_byte png_pass_ystart[] = {0, 0, 4, 0, 2, 0, 1};
+   static const png_byte png_pass_ystart[] = {0, 0, 4, 0, 2, 0, 1};
 
    /* Offset to next interlace block in the y direction */
-   static PNG_CONST png_byte png_pass_yinc[] = {8, 8, 8, 4, 4, 2, 2};
+   static const png_byte png_pass_yinc[] = {8, 8, 8, 4, 4, 2, 2};
 
    /* Height of interlace block.  This is not currently used - if you need
     * it, uncomment it here and in png.h
-   static PNG_CONST png_byte png_pass_height[] = {8, 8, 4, 4, 2, 2, 1};
+   static const png_byte png_pass_height[] = {8, 8, 4, 4, 2, 2, 1};
    */
 #endif
 
Index: rdkit-src/rdkit/Code/GraphMol/Descriptors/RDF.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/Descriptors/RDF.cpp b/rdkit-src/rdkit/Code/GraphMol/Descriptors/RDF.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/Descriptors/RDF.cpp	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/GraphMol/Descriptors/RDF.cpp	(date 1689048276110)
@@ -112,6 +112,7 @@
     R7[i] = std::round(1000 * res7) / 1000;
   }
 
+  R1.reserve(R1.size() + R2.size() + R3.size() + R4.size() + R5.size() + R6.size() + R7.size());
   R1.insert(R1.end(), R2.begin(), R2.end());
   R1.insert(R1.end(), R3.begin(), R3.end());
   R1.insert(R1.end(), R4.begin(), R4.end());
Index: libpng-src/libpng/pngset.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/pngset.c b/libpng-src/libpng/pngset.c
--- a/libpng-src/libpng/pngset.c	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/pngset.c	(date 1690795574122)
@@ -1,10 +1,10 @@
 
 /* pngset.c - storage of image information into info struct
  *
- * Last changed in libpng 1.6.24 [August 4, 2016]
- * Copyright (c) 1998-2016 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ * Copyright (c) 2018-2023 Cosmin Truta
+ * Copyright (c) 1998-2018 Glenn Randers-Pehrson
+ * Copyright (c) 1996-1997 Andreas Dilger
+ * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
@@ -134,6 +134,47 @@
 
 #endif /* cHRM */
 
+#ifdef PNG_eXIf_SUPPORTED
+void PNGAPI
+png_set_eXIf(png_const_structrp png_ptr, png_inforp info_ptr,
+    png_bytep exif)
+{
+  png_warning(png_ptr, "png_set_eXIf does not work; use png_set_eXIf_1");
+  PNG_UNUSED(info_ptr)
+  PNG_UNUSED(exif)
+}
+
+void PNGAPI
+png_set_eXIf_1(png_const_structrp png_ptr, png_inforp info_ptr,
+    png_uint_32 num_exif, png_bytep exif)
+{
+   png_bytep new_exif;
+
+   png_debug1(1, "in %s storage function", "eXIf");
+
+   if (png_ptr == NULL || info_ptr == NULL ||
+       (png_ptr->mode & PNG_WROTE_eXIf) != 0)
+      return;
+
+   new_exif = png_voidcast(png_bytep, png_malloc_warn(png_ptr, num_exif));
+
+   if (new_exif == NULL)
+   {
+      png_warning(png_ptr, "Insufficient memory for eXIf chunk data");
+      return;
+   }
+
+   memcpy(new_exif, exif, (size_t)num_exif);
+
+   png_free_data(png_ptr, info_ptr, PNG_FREE_EXIF, 0);
+
+   info_ptr->num_exif = num_exif;
+   info_ptr->exif = new_exif;
+   info_ptr->free_me |= PNG_FREE_EXIF;
+   info_ptr->valid |= PNG_INFO_eXIf;
+}
+#endif /* eXIf */
+
 #ifdef PNG_gAMA_SUPPORTED
 void PNGFAPI
 png_set_gAMA_fixed(png_const_structrp png_ptr, png_inforp info_ptr,
@@ -190,15 +231,13 @@
    if (info_ptr->hist == NULL)
    {
       png_warning(png_ptr, "Insufficient memory for hIST chunk data");
-
       return;
    }
 
-   info_ptr->free_me |= PNG_FREE_HIST;
-
    for (i = 0; i < info_ptr->num_palette; i++)
       info_ptr->hist[i] = hist[i];
 
+   info_ptr->free_me |= PNG_FREE_HIST;
    info_ptr->valid |= PNG_INFO_hIST;
 }
 #endif
@@ -266,7 +305,7 @@
     png_const_charp purpose, png_int_32 X0, png_int_32 X1, int type,
     int nparams, png_const_charp units, png_charpp params)
 {
-   png_size_t length;
+   size_t length;
    int i;
 
    png_debug1(1, "in %s storage function", "pCAL");
@@ -283,17 +322,29 @@
 
    /* Check that the type matches the specification. */
    if (type < 0 || type > 3)
-      png_error(png_ptr, "Invalid pCAL equation type");
+   {
+      png_chunk_report(png_ptr, "Invalid pCAL equation type",
+            PNG_CHUNK_WRITE_ERROR);
+      return;
+   }
 
    if (nparams < 0 || nparams > 255)
-      png_error(png_ptr, "Invalid pCAL parameter count");
+   {
+      png_chunk_report(png_ptr, "Invalid pCAL parameter count",
+            PNG_CHUNK_WRITE_ERROR);
+      return;
+   }
 
    /* Validate params[nparams] */
    for (i=0; i<nparams; ++i)
    {
       if (params[i] == NULL ||
           !png_check_fp_string(params[i], strlen(params[i])))
-         png_error(png_ptr, "Invalid format for pCAL parameter");
+      {
+         png_chunk_report(png_ptr, "Invalid format for pCAL parameter",
+               PNG_CHUNK_WRITE_ERROR);
+         return;
+      }
    }
 
    info_ptr->pcal_purpose = png_voidcast(png_charp,
@@ -301,13 +352,15 @@
 
    if (info_ptr->pcal_purpose == NULL)
    {
-      png_warning(png_ptr, "Insufficient memory for pCAL purpose");
-
+      png_chunk_report(png_ptr, "Insufficient memory for pCAL purpose",
+            PNG_CHUNK_WRITE_ERROR);
       return;
    }
 
    memcpy(info_ptr->pcal_purpose, purpose, length);
 
+   info_ptr->free_me |= PNG_FREE_PCAL;
+
    png_debug(3, "storing X0, X1, type, and nparams in info");
    info_ptr->pcal_X0 = X0;
    info_ptr->pcal_X1 = X1;
@@ -324,23 +377,22 @@
    if (info_ptr->pcal_units == NULL)
    {
       png_warning(png_ptr, "Insufficient memory for pCAL units");
-
       return;
    }
 
    memcpy(info_ptr->pcal_units, units, length);
 
    info_ptr->pcal_params = png_voidcast(png_charpp, png_malloc_warn(png_ptr,
-       (png_size_t)((nparams + 1) * (sizeof (png_charp)))));
+       (size_t)(((unsigned int)nparams + 1) * (sizeof (png_charp)))));
 
    if (info_ptr->pcal_params == NULL)
    {
       png_warning(png_ptr, "Insufficient memory for pCAL params");
-
       return;
    }
 
-   memset(info_ptr->pcal_params, 0, (nparams + 1) * (sizeof (png_charp)));
+   memset(info_ptr->pcal_params, 0, ((unsigned int)nparams + 1) *
+       (sizeof (png_charp)));
 
    for (i = 0; i < nparams; i++)
    {
@@ -353,7 +405,6 @@
       if (info_ptr->pcal_params[i] == NULL)
       {
          png_warning(png_ptr, "Insufficient memory for pCAL parameter");
-
          return;
       }
 
@@ -361,7 +412,6 @@
    }
 
    info_ptr->valid |= PNG_INFO_pCAL;
-   info_ptr->free_me |= PNG_FREE_PCAL;
 }
 #endif
 
@@ -370,7 +420,7 @@
 png_set_sCAL_s(png_const_structrp png_ptr, png_inforp info_ptr,
     int unit, png_const_charp swidth, png_const_charp sheight)
 {
-   png_size_t lengthw = 0, lengthh = 0;
+   size_t lengthw = 0, lengthh = 0;
 
    png_debug1(1, "in %s storage function", "sCAL");
 
@@ -418,18 +468,17 @@
 
    if (info_ptr->scal_s_height == NULL)
    {
-      png_free (png_ptr, info_ptr->scal_s_width);
+      png_free(png_ptr, info_ptr->scal_s_width);
       info_ptr->scal_s_width = NULL;
 
       png_warning(png_ptr, "Memory allocation failed while processing sCAL");
-
       return;
    }
 
    memcpy(info_ptr->scal_s_height, sheight, lengthh);
 
-   info_ptr->valid |= PNG_INFO_sCAL;
    info_ptr->free_me |= PNG_FREE_SCAL;
+   info_ptr->valid |= PNG_INFO_sCAL;
 }
 
 #  ifdef PNG_FLOATING_POINT_SUPPORTED
@@ -563,12 +612,12 @@
        PNG_MAX_PALETTE_LENGTH * (sizeof (png_color))));
 
    if (num_palette > 0)
-      memcpy(png_ptr->palette, palette, num_palette * (sizeof (png_color)));
+      memcpy(png_ptr->palette, palette, (unsigned int)num_palette *
+          (sizeof (png_color)));
+
    info_ptr->palette = png_ptr->palette;
    info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;
-
    info_ptr->free_me |= PNG_FREE_PLTE;
-
    info_ptr->valid |= PNG_INFO_PLTE;
 }
 
@@ -630,7 +679,7 @@
 {
    png_charp new_iccp_name;
    png_bytep new_iccp_profile;
-   png_size_t length;
+   size_t length;
 
    png_debug1(1, "in %s storage function", "iCCP");
 
@@ -957,7 +1006,10 @@
          /* Changed from num_trans to PNG_MAX_PALETTE_LENGTH in version 1.2.1 */
           info_ptr->trans_alpha = png_voidcast(png_bytep,
               png_malloc(png_ptr, PNG_MAX_PALETTE_LENGTH));
-          memcpy(info_ptr->trans_alpha, trans_alpha, (png_size_t)num_trans);
+          memcpy(info_ptr->trans_alpha, trans_alpha, (size_t)num_trans);
+
+          info_ptr->free_me |= PNG_FREE_TRNS;
+          info_ptr->valid |= PNG_INFO_tRNS;
        }
        png_ptr->trans_alpha = info_ptr->trans_alpha;
    }
@@ -990,8 +1042,8 @@
 
    if (num_trans != 0)
    {
-      info_ptr->valid |= PNG_INFO_tRNS;
       info_ptr->free_me |= PNG_FREE_TRNS;
+      info_ptr->valid |= PNG_INFO_tRNS;
    }
 }
 #endif
@@ -1025,11 +1077,11 @@
    {
       /* Out of memory or too many chunks */
       png_chunk_report(png_ptr, "too many sPLT chunks", PNG_CHUNK_WRITE_ERROR);
-
       return;
    }
 
    png_free(png_ptr, info_ptr->splt_palettes);
+
    info_ptr->splt_palettes = np;
    info_ptr->free_me |= PNG_FREE_SPLT;
 
@@ -1037,7 +1089,7 @@
 
    do
    {
-      png_size_t length;
+      size_t length;
 
       /* Skip invalid input entries */
       if (entries->name == NULL || entries->entries == NULL)
@@ -1080,7 +1132,7 @@
        * checked it when doing the allocation.
        */
       memcpy(np->entries, entries->entries,
-          entries->nentries * sizeof (png_sPLT_entry));
+          (unsigned int)entries->nentries * sizeof (png_sPLT_entry));
 
       /* Note that 'continue' skips the advance of the out pointer and out
        * count, so an invalid entry is not added.
@@ -1088,8 +1140,9 @@
       info_ptr->valid |= PNG_INFO_sPLT;
       ++(info_ptr->splt_palettes_num);
       ++np;
+      ++entries;
    }
-   while (++entries, --nentries);
+   while (--nentries);
 
    if (nentries > 0)
       png_chunk_report(png_ptr, "sPLT out of memory", PNG_CHUNK_WRITE_ERROR);
@@ -1182,11 +1235,11 @@
    {
       png_chunk_report(png_ptr, "too many unknown chunks",
           PNG_CHUNK_WRITE_ERROR);
-
       return;
    }
 
    png_free(png_ptr, info_ptr->unknown_chunks);
+
    info_ptr->unknown_chunks = np; /* safe because it is initialized */
    info_ptr->free_me |= PNG_FREE_UNKN;
 
@@ -1249,7 +1302,7 @@
       {
          png_app_error(png_ptr, "invalid unknown chunk location");
          /* Fake out the pre 1.6.0 behavior: */
-         if ((location & PNG_HAVE_IDAT) != 0) /* undocumented! */
+         if (((unsigned int)location & PNG_HAVE_IDAT) != 0) /* undocumented! */
             location = PNG_AFTER_IDAT;
 
          else
@@ -1264,7 +1317,7 @@
 
 #ifdef PNG_MNG_FEATURES_SUPPORTED
 png_uint_32 PNGAPI
-png_permit_mng_features (png_structrp png_ptr, png_uint_32 mng_features)
+png_permit_mng_features(png_structrp png_ptr, png_uint_32 mng_features)
 {
    png_debug(1, "in png_permit_mng_features");
 
@@ -1337,9 +1390,10 @@
       /* Ignore all unknown chunks and all chunks recognized by
        * libpng except for IHDR, PLTE, tRNS, IDAT, and IEND
        */
-      static PNG_CONST png_byte chunks_to_ignore[] = {
+      static const png_byte chunks_to_ignore[] = {
          98,  75,  71,  68, '\0',  /* bKGD */
          99,  72,  82,  77, '\0',  /* cHRM */
+        101,  88,  73, 102, '\0',  /* eXIf */
         103,  65,  77,  65, '\0',  /* gAMA */
         104,  73,  83,  84, '\0',  /* hIST */
         105,  67,  67,  80, '\0',  /* iCCP */
@@ -1373,7 +1427,7 @@
          return;
       }
 
-      num_chunks = num_chunks_in;
+      num_chunks = (unsigned int)num_chunks_in;
    }
 
    old_num_chunks = png_ptr->num_chunk_list;
@@ -1500,7 +1554,7 @@
 #endif
 
 void PNGAPI
-png_set_compression_buffer_size(png_structrp png_ptr, png_size_t size)
+png_set_compression_buffer_size(png_structrp png_ptr, size_t size)
 {
    if (png_ptr == NULL)
       return;
@@ -1563,14 +1617,14 @@
 png_set_invalid(png_const_structrp png_ptr, png_inforp info_ptr, int mask)
 {
    if (png_ptr != NULL && info_ptr != NULL)
-      info_ptr->valid &= ~mask;
+      info_ptr->valid &= (unsigned int)(~mask);
 }
 
 
 #ifdef PNG_SET_USER_LIMITS_SUPPORTED
 /* This function was added to libpng 1.2.6 */
 void PNGAPI
-png_set_user_limits (png_structrp png_ptr, png_uint_32 user_width_max,
+png_set_user_limits(png_structrp png_ptr, png_uint_32 user_width_max,
     png_uint_32 user_height_max)
 {
    /* Images with dimensions larger than these limits will be
@@ -1586,7 +1640,7 @@
 
 /* This function was added to libpng 1.4.0 */
 void PNGAPI
-png_set_chunk_cache_max (png_structrp png_ptr, png_uint_32 user_chunk_cache_max)
+png_set_chunk_cache_max(png_structrp png_ptr, png_uint_32 user_chunk_cache_max)
 {
    if (png_ptr != NULL)
       png_ptr->user_chunk_cache_max = user_chunk_cache_max;
@@ -1594,7 +1648,7 @@
 
 /* This function was added to libpng 1.4.1 */
 void PNGAPI
-png_set_chunk_malloc_max (png_structrp png_ptr,
+png_set_chunk_malloc_max(png_structrp png_ptr,
     png_alloc_size_t user_chunk_malloc_max)
 {
    if (png_ptr != NULL)
@@ -1682,14 +1736,16 @@
       png_byte ch = (png_byte)*key++;
 
       if ((ch > 32 && ch <= 126) || (ch >= 161 /*&& ch <= 255*/))
-         *new_key++ = ch, ++key_len, space = 0;
+      {
+         *new_key++ = ch; ++key_len; space = 0;
+      }
 
       else if (space == 0)
       {
          /* A space or an invalid character when one wasn't seen immediately
           * before; output just a space.
           */
-         *new_key++ = 32, ++key_len, space = 1;
+         *new_key++ = 32; ++key_len; space = 1;
 
          /* If the character was not a space then it is invalid. */
          if (ch != 32)
@@ -1702,7 +1758,7 @@
 
    if (key_len > 0 && space != 0) /* trailing space */
    {
-      --key_len, --new_key;
+      --key_len; --new_key;
       if (bad_character == 0)
          bad_character = 32;
    }
Index: indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.cpp	(date 1690767117645)
@@ -118,7 +118,7 @@
         throw IndigoError("unknown molecule fingerprint type: %s", type);
 }
 
-CEXPORT int indigoFingerprint(int item, const char* type)
+int indigoFingerprint(int item, const char* type)
 {
     INDIGO_BEGIN
     {
@@ -153,7 +153,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadFingerprintFromBuffer(const byte* buffer, int size)
+int indigoLoadFingerprintFromBuffer(const byte* buffer, int size)
 {
     INDIGO_BEGIN
     {
@@ -164,7 +164,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadFingerprintFromDescriptors(const double* arr, int arr_len, int size, double density)
+int indigoLoadFingerprintFromDescriptors(const double* arr, int arr_len, int size, double density)
 {
     INDIGO_BEGIN
     {
@@ -402,7 +402,7 @@
     return 1;
 }
 
-CEXPORT float indigoSimilarity(int item1, int item2, const char* metrics)
+float indigoSimilarity(int item1, int item2, const char* metrics)
 {
     INDIGO_BEGIN
     {
@@ -459,7 +459,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountBits(int fingerprint)
+int indigoCountBits(int fingerprint)
 {
     INDIGO_BEGIN
     {
@@ -469,7 +469,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCommonBits(int fingerprint1, int fingerprint2)
+int indigoCommonBits(int fingerprint1, int fingerprint2)
 {
     INDIGO_BEGIN
     {
@@ -484,7 +484,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoOneBitsList(int fingerprint)
+const char* indigoOneBitsList(int fingerprint)
 {
     INDIGO_BEGIN
     {
Index: opencv-src/opencv/modules/highgui/src/window_QT.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/highgui/src/window_QT.cpp b/opencv-src/opencv/modules/highgui/src/window_QT.cpp
--- a/opencv-src/opencv/modules/highgui/src/window_QT.cpp	(revision f9a59f2592993d3dcc080e495f4f5e02dd8ec7ef)
+++ b/opencv-src/opencv/modules/highgui/src/window_QT.cpp	(date 1689048275970)
@@ -438,7 +438,7 @@
 
     //This is not a very clean way to do the stuff. Indeed, QAction automatically generate toolTil (QLabel)
     //that can be grabbed here and crash the code at 'w->param_name==name'.
-    foreach (QWidget* widget, QApplication::topLevelWidgets())
+    Q_FOREACH (QWidget* widget, QApplication::topLevelWidgets())
     {
         if (widget->isWindow() && !widget->parentWidget())//is a window without parent
         {
@@ -529,7 +529,7 @@
     //"For any GUI application using Qt, there is precisely one QApplication object"
     if (!QApplication::instance())
     {
-#if QT_VERSION >= QT_VERSION_CHECK(5, 6, 0)
+#if QT_VERSION >= QT_VERSION_CHECK(5, 6, 0) and QT_VERSION <= QT_VERSION_CHECK(6, 0, 0)
         QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling, true);
 #endif
         new QApplication(*c, v);
@@ -1182,7 +1182,7 @@
 void GuiReceiver::enablePropertiesButtonEachWindow()
 {
     //For each window, enable window property button
-    foreach (QWidget* widget, QApplication::topLevelWidgets())
+    Q_FOREACH (QWidget* widget, QApplication::topLevelWidgets())
     {
         if (widget->isWindow() && !widget->parentWidget()) //is a window without parent
         {
@@ -2132,7 +2132,7 @@
     myToolBar = new QToolBar(this);
     myToolBar->setFloatable(false); //is not a window
 
-    foreach (QAction *a, vect_QActions)
+    Q_FOREACH (QAction *a, vect_QActions)
         myToolBar->addAction(a);
 }
 
@@ -2796,7 +2796,7 @@
     {
         QMenu menu(this);
 
-        foreach (QAction *a, centralWidget->vect_QActions)
+        Q_FOREACH (QAction *a, centralWidget->vect_QActions)
             menu.addAction(a);
 
         menu.exec(evnt->globalPos());
Index: libpng-src/libpng/scripts/pnglibconf.h.prebuilt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/scripts/pnglibconf.h.prebuilt b/libpng-src/libpng/scripts/pnglibconf.h.prebuilt
--- a/libpng-src/libpng/scripts/pnglibconf.h.prebuilt	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/scripts/pnglibconf.h.prebuilt	(date 1690795574122)
@@ -1,10 +1,9 @@
-/* libpng 1.6.25 STANDARD API DEFINITION */
-
 /* pnglibconf.h - library build configuration */
 
-/* Libpng version 1.6.25 - September 1, 2016 */
+/* libpng version 1.6.40 */
 
-/* Copyright (c) 1998-2015 Glenn Randers-Pehrson */
+/* Copyright (c) 2018-2023 Cosmin Truta */
+/* Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson */
 
 /* This code is released under the libpng license. */
 /* For conditions of distribution and use, see the disclaimer */
@@ -44,6 +43,8 @@
 #define PNG_IO_STATE_SUPPORTED
 #define PNG_MNG_FEATURES_SUPPORTED
 #define PNG_POINTER_INDEXING_SUPPORTED
+/*#undef PNG_POWERPC_VSX_API_SUPPORTED*/
+/*#undef PNG_POWERPC_VSX_CHECK_SUPPORTED*/
 #define PNG_PROGRESSIVE_READ_SUPPORTED
 #define PNG_READ_16BIT_SUPPORTED
 #define PNG_READ_ALPHA_MODE_SUPPORTED
@@ -82,6 +83,7 @@
 #define PNG_READ_USER_TRANSFORM_SUPPORTED
 #define PNG_READ_bKGD_SUPPORTED
 #define PNG_READ_cHRM_SUPPORTED
+#define PNG_READ_eXIf_SUPPORTED
 #define PNG_READ_gAMA_SUPPORTED
 #define PNG_READ_hIST_SUPPORTED
 #define PNG_READ_iCCP_SUPPORTED
@@ -151,6 +153,7 @@
 #define PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
 #define PNG_WRITE_bKGD_SUPPORTED
 #define PNG_WRITE_cHRM_SUPPORTED
+#define PNG_WRITE_eXIf_SUPPORTED
 #define PNG_WRITE_gAMA_SUPPORTED
 #define PNG_WRITE_hIST_SUPPORTED
 #define PNG_WRITE_iCCP_SUPPORTED
@@ -168,6 +171,7 @@
 #define PNG_WRITE_zTXt_SUPPORTED
 #define PNG_bKGD_SUPPORTED
 #define PNG_cHRM_SUPPORTED
+#define PNG_eXIf_SUPPORTED
 #define PNG_gAMA_SUPPORTED
 #define PNG_hIST_SUPPORTED
 #define PNG_iCCP_SUPPORTED
Index: indigo-src/indigo/core/indigo-core/common/base_cpp/scanner.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/common/base_cpp/scanner.cpp b/indigo-src/indigo/core/indigo-core/common/base_cpp/scanner.cpp
--- a/indigo-src/indigo/core/indigo-core/common/base_cpp/scanner.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/core/indigo-core/common/base_cpp/scanner.cpp	(date 1689048275434)
@@ -28,7 +28,7 @@
 #include "base_cpp/tlscont.h"
 #include "reusable_obj_array.h"
 
-#include <../cppcodec/cppcodec/base64_default_rfc4648.hpp>
+#include <cppcodec/base64_default_rfc4648.hpp>
 #include <limits>
 
 using namespace indigo;
Index: openbabel-src/openbabel/include/openbabel/typer.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/typer.h b/openbabel-src/openbabel/include/openbabel/typer.h
--- a/openbabel-src/openbabel/include/openbabel/typer.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/typer.h	(date 1689048275862)
@@ -67,7 +67,7 @@
 #endif
 //! Global OBAtomTyper for marking internal valence, hybridization,
 //!  and atom types (for internal and external use)
-THREAD_LOCAL OB_EXTERN OBAtomTyper      atomtyper;
+THREAD_LOCAL extern OBAtomTyper      atomtyper;
 
 // class introduction in typer.cpp
 class OBAPI OBAromaticTyper
@@ -81,7 +81,7 @@
 };
 
 //! Global OBAromaticTyper for detecting aromatic atoms and bonds
-THREAD_LOCAL OB_EXTERN OBAromaticTyper  aromtyper;
+THREAD_LOCAL extern OBAromaticTyper  aromtyper;
 
 // class introduction in typer.cpp
 class OBAPI OBRingTyper : public OBGlobalDataBase
Index: openbabel-src/openbabel/include/openbabel/tokenst.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/tokenst.h b/openbabel-src/openbabel/include/openbabel/tokenst.h
--- a/openbabel-src/openbabel/include/openbabel/tokenst.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/tokenst.h	(date 1689048275862)
@@ -25,7 +25,6 @@
 #include <vector>
 #include <sstream>
 #include <string>
-#include <fstream>
 
 namespace OpenBabel
 {
@@ -56,7 +55,7 @@
 
   //! Opens a datafile in a directory where OpenBabel expects to find it.
   // full documentation in tokenst.cpp
-  OBERROR std::string OpenDatafile(std::ifstream& fs,
+  OBERROR std::string OpenDatafile(std::istringstream& iss,
                                  const std::string& filename,
                                  const std::string& envvar = "BABEL_DATADIR");
 
Index: indigo-src/indigo/api/c/indigo/src/indigo_scaffold.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_scaffold.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_scaffold.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_scaffold.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_scaffold.cpp	(date 1690767117645)
@@ -31,7 +31,7 @@
 {
 }
 
-CEXPORT int indigoExtractCommonScaffold(int structures, const char* options)
+int indigoExtractCommonScaffold(int structures, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -104,7 +104,7 @@
     return max_scaffold;
 }
 
-CEXPORT int indigoAllScaffolds(int extracted)
+int indigoAllScaffolds(int extracted)
 {
     INDIGO_BEGIN
     {
Index: rdkit-src/rdkit/Code/GraphMol/Canon.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/Canon.cpp b/rdkit-src/rdkit/Code/GraphMol/Canon.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/Canon.cpp	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/GraphMol/Canon.cpp	(date 1689048276102)
@@ -79,7 +79,7 @@
            !details::isUnsaturated(atom, mol)));
 }
 
-auto _possibleCompare = [](const PossibleType &arg1, const PossibleType &arg2) {
+const auto _possibleCompare = [](const PossibleType &arg1, const PossibleType &arg2) {
   return (std::get<0>(arg1) < std::get<0>(arg2));
 };
 
Index: openssl-src/openssl/crypto/dso_conf.h.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openssl-src/openssl/crypto/dso_conf.h.cmake b/openssl-src/openssl/crypto/dso_conf.h.cmake
new file mode 100644
--- /dev/null	(date 1689048276018)
+++ b/openssl-src/openssl/crypto/dso_conf.h.cmake	(date 1689048276018)
@@ -0,0 +1,17 @@
+/*
+ * Copyright 2016-2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://www.openssl.org/source/license.html
+ */
+
+#ifndef OSSL_CRYPTO_DSO_CONF_H
+# define OSSL_CRYPTO_DSO_CONF_H
+# define DSO_EXTENSION "@DSO_EXTENSION@"
+#cmakedefine DSO_NONE
+#cmakedefine DSO_WIN32
+#cmakedefine DSO_DLFCN
+#cmakedefine HAVE_DLFCN_H
+#endif
Index: openbabel-src/openbabel/include/openbabel/obmolecformat.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/obmolecformat.h b/openbabel-src/openbabel/include/openbabel/obmolecformat.h
--- a/openbabel-src/openbabel/include/openbabel/obmolecformat.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/obmolecformat.h	(date 1689048275862)
@@ -142,7 +142,7 @@
 #endif
 
 #ifdef _MSC_VER
-  typedef std::tr1::unordered_map<std::string, unsigned> NameIndexType;
+  typedef std::unordered_map<std::string, unsigned> NameIndexType;
 #elif defined(_LIBCPP_VERSION)
   typedef std::unordered_map<std::string, unsigned> NameIndexType;
 #elif (__GNUC__ == 4 && __GNUC_MINOR__ >= 1 && !defined(__APPLE_CC__)) || defined (USE_BOOST)
Index: indigo-src/indigo/api/c/indigo/src/indigo_properties.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_properties.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_properties.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_properties.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_properties.cpp	(date 1690767117645)
@@ -19,7 +19,7 @@
 #include "indigo_properties.h"
 #include "base_cpp/properties_map.h"
 
-CEXPORT int indigoHasProperty(int handle, const char* prop)
+int indigoHasProperty(int handle, const char* prop)
 {
     INDIGO_BEGIN
     {
@@ -35,7 +35,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetProperty(int handle, const char* prop)
+const char* indigoGetProperty(int handle, const char* prop)
 {
     INDIGO_BEGIN
     {
@@ -52,7 +52,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoSetProperty(int handle, const char* prop, const char* value)
+int indigoSetProperty(int handle, const char* prop, const char* value)
 {
     INDIGO_BEGIN
     {
@@ -70,7 +70,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRemoveProperty(int handle, const char* prop)
+int indigoRemoveProperty(int handle, const char* prop)
 {
     INDIGO_BEGIN
     {
@@ -138,7 +138,7 @@
     return new IndigoProperty(_props, _idx);
 }
 
-CEXPORT int indigoIterateProperties(int handle)
+int indigoIterateProperties(int handle)
 {
     INDIGO_BEGIN
     {
@@ -150,7 +150,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearProperties(int handle)
+int indigoClearProperties(int handle)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_abbreviations_expand.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_abbreviations_expand.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_abbreviations_expand.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_abbreviations_expand.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_abbreviations_expand.cpp	(date 1690767117645)
@@ -769,7 +769,7 @@
         //
         // Interface functions
         //
-        CEXPORT int indigoExpandAbbreviations(int molecule)
+        int indigoExpandAbbreviations(int molecule)
         {
             INDIGO_BEGIN
             {
Index: openbabel-src/openbabel/include/openbabel/math/matrix3x3.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/math/matrix3x3.h b/openbabel-src/openbabel/include/openbabel/math/matrix3x3.h
--- a/openbabel-src/openbabel/include/openbabel/math/matrix3x3.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/math/matrix3x3.h	(date 1689048275862)
@@ -281,7 +281,7 @@
       friend OBAPI std::ostream& operator<< ( std::ostream&, const matrix3x3 & ) ;
 
       //! Eigenvalue calculation
-      static void jacobi(unsigned int n, double *a, double *d, double *v);
+      static void jacobi(int n, double *a, double *d, double *v);
     };
 
 #ifndef SWIG
Index: openbabel-src/openbabel/include/openbabel/tree/tree.hh
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/tree/tree.hh b/openbabel-src/openbabel/include/openbabel/tree/tree.hh
--- a/openbabel-src/openbabel/include/openbabel/tree/tree.hh	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/tree/tree.hh	(date 1689048275862)
@@ -542,8 +542,8 @@
 template <class T, class tree_node_allocator>
 void tree<T, tree_node_allocator>::head_initialise_()
    {
-   head = alloc_.allocate(1,nullptr); // MSVC does not have default second argument
-	feet = alloc_.allocate(1,nullptr);
+   head = alloc_.allocate(1);
+   feet = alloc_.allocate(1);
 
    head->parent=nullptr;
    head->first_child=nullptr;
@@ -869,7 +869,7 @@
 	assert(position.node!=head);
 	assert(position.node);
 
-	tree_node *tmp=alloc_.allocate(1,0);
+	tree_node *tmp=alloc_.allocate(1);
 	kp::constructor(&tmp->data);
 	tmp->first_child=0;
 	tmp->last_child=0;
@@ -894,7 +894,7 @@
 	assert(position.node!=head);
 	assert(position.node);
 
-	tree_node *tmp=alloc_.allocate(1,0);
+	tree_node *tmp=alloc_.allocate(1);
 	kp::constructor(&tmp->data);
 	tmp->first_child=0;
 	tmp->last_child=0;
@@ -923,7 +923,7 @@
 	assert(position.node!=head);
 	assert(position.node);
 
-	tree_node* tmp = alloc_.allocate(1,nullptr);
+	tree_node* tmp = alloc_.allocate(1);
 	kp::constructor(&tmp->data, x);
 	tmp->first_child=nullptr;
 	tmp->last_child=nullptr;
@@ -948,7 +948,7 @@
 	assert(position.node!=head);
 	assert(position.node);
 
-	tree_node* tmp = alloc_.allocate(1,0);
+	tree_node* tmp = alloc_.allocate(1);
 	kp::constructor(&tmp->data, x);
 	tmp->first_child=0;
 	tmp->last_child=0;
@@ -1035,7 +1035,7 @@
 		position.node=feet; // Backward compatibility: when calling insert on a null node,
 		                    // insert before the feet.
 		}
-	tree_node* tmp = alloc_.allocate(1,nullptr);
+	tree_node* tmp = alloc_.allocate(1);
 	kp::constructor(&tmp->data, x);
 	tmp->first_child=nullptr;
 	tmp->last_child=nullptr;
@@ -1057,7 +1057,7 @@
 template <class T, class tree_node_allocator>
 typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::insert(sibling_iterator position, const T& x)
 	{
-	tree_node* tmp = alloc_.allocate(1,0);
+	tree_node* tmp = alloc_.allocate(1);
 	kp::constructor(&tmp->data, x);
 	tmp->first_child=0;
 	tmp->last_child=0;
@@ -1087,7 +1087,7 @@
 template <class iter>
 iter tree<T, tree_node_allocator>::insert_after(iter position, const T& x)
 	{
-	tree_node* tmp = alloc_.allocate(1,0);
+	tree_node* tmp = alloc_.allocate(1);
 	kp::constructor(&tmp->data, x);
 	tmp->first_child=0;
 	tmp->last_child=0;
@@ -1159,7 +1159,7 @@
 //	std::cout << "warning!" << position.node << std::endl;
 	erase_children(position);
 //	std::cout << "no warning!" << std::endl;
-	tree_node* tmp = alloc_.allocate(1,0);
+	tree_node* tmp = alloc_.allocate(1);
 	kp::constructor(&tmp->data, (*from));
 	tmp->first_child=0;
 	tmp->last_child=0;
Index: ncnn-src/ncnn/cmake/ncnn_generate_shader_comp_header.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/cmake/ncnn_generate_shader_comp_header.cmake b/ncnn-src/ncnn/cmake/ncnn_generate_shader_comp_header.cmake
--- a/ncnn-src/ncnn/cmake/ncnn_generate_shader_comp_header.cmake	(revision 903ec7c2c9417e1ee11cb667d2198cc3607458ed)
+++ b/ncnn-src/ncnn/cmake/ncnn_generate_shader_comp_header.cmake	(date 1689048275794)
@@ -15,8 +15,8 @@
 get_filename_component(SHADER_SRC_NAME_WE ${SHADER_SRC} NAME_WE)
 
 # text to hex
-file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/${SHADER_SRC_NAME_WE}.text2hex.txt "${comp_data}")
-file(READ ${CMAKE_CURRENT_BINARY_DIR}/${SHADER_SRC_NAME_WE}.text2hex.txt comp_data_hex HEX)
+file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/generated/ncnn/tmp/${SHADER_SRC_NAME_WE}.text2hex.txt "${comp_data}")
+file(READ ${CMAKE_CURRENT_BINARY_DIR}/generated/ncnn/tmp/${SHADER_SRC_NAME_WE}.text2hex.txt comp_data_hex HEX)
 string(REGEX REPLACE "([0-9a-f][0-9a-f])" "0x\\1," comp_data_hex ${comp_data_hex})
 string(FIND "${comp_data_hex}" "," tail_comma REVERSE)
 string(SUBSTRING "${comp_data_hex}" 0 ${tail_comma} comp_data_hex)
Index: indigo-src/indigo/api/c/indigo/src/indigo_layout.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_layout.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_layout.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_layout.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_layout.cpp	(date 1690767117645)
@@ -27,7 +27,7 @@
 #include <algorithm>
 #include <vector>
 
-CEXPORT int indigoLayout(int object)
+int indigoLayout(int object)
 {
     INDIGO_BEGIN
     {
@@ -126,7 +126,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClean2d(int object)
+int indigoClean2d(int object)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_mapping.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_mapping.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_mapping.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_mapping.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_mapping.cpp	(date 1690767117645)
@@ -62,7 +62,7 @@
     return res_ptr.release();
 }
 
-CEXPORT int indigoMapAtom(int handle, int atom)
+int indigoMapAtom(int handle, int atom)
 {
     INDIGO_BEGIN
     {
@@ -105,7 +105,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoMapBond(int handle, int bond)
+int indigoMapBond(int handle, int bond)
 {
     INDIGO_BEGIN
     {
@@ -190,7 +190,7 @@
     }
 }
 
-CEXPORT int indigoHighlightedTarget(int item)
+int indigoHighlightedTarget(int item)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_savers.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_savers.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_savers.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_savers.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_savers.cpp	(date 1690767117645)
@@ -146,7 +146,7 @@
     append(_output, object);
 }
 
-CEXPORT int indigoSdfAppend(int output, int molecule)
+int indigoSdfAppend(int output, int molecule)
 {
     INDIGO_BEGIN
     {
@@ -274,7 +274,7 @@
     append(_output, object);
 }
 
-CEXPORT int indigoSmilesAppend(int output, int item)
+int indigoSmilesAppend(int output, int item)
 {
     INDIGO_BEGIN
     {
@@ -419,7 +419,7 @@
     appendFooter(_output);
 }
 
-CEXPORT int indigoCmlHeader(int output)
+int indigoCmlHeader(int output)
 {
     INDIGO_BEGIN
     {
@@ -430,7 +430,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCmlFooter(int output)
+int indigoCmlFooter(int output)
 {
     INDIGO_BEGIN
     {
@@ -441,7 +441,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCmlAppend(int output, int item)
+int indigoCmlAppend(int output, int item)
 {
     INDIGO_BEGIN
     {
@@ -520,7 +520,7 @@
     appendHeader(_output);
 }
 
-CEXPORT int indigoRdfHeader(int output)
+int indigoRdfHeader(int output)
 {
     INDIGO_BEGIN
     {
@@ -531,7 +531,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRdfAppend(int output, int item)
+int indigoRdfAppend(int output, int item)
 {
     INDIGO_BEGIN
     {
@@ -546,7 +546,7 @@
 //
 // Saving functions
 //
-CEXPORT int indigoCreateSaver(int output, const char* format)
+int indigoCreateSaver(int output, const char* format)
 {
     INDIGO_BEGIN
     {
@@ -556,7 +556,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateFileSaver(const char* filename, const char* format)
+int indigoCreateFileSaver(const char* filename, const char* format)
 {
     INDIGO_BEGIN
     {
@@ -568,7 +568,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveMolfile(int molecule, int output)
+int indigoSaveMolfile(int molecule, int output)
 {
     INDIGO_BEGIN
     {
@@ -581,7 +581,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveJson(int item, int output)
+int indigoSaveJson(int item, int output)
 {
     INDIGO_BEGIN
     {
@@ -610,7 +610,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveCml(int item, int output)
+int indigoSaveCml(int item, int output)
 {
     INDIGO_BEGIN
     {
@@ -643,7 +643,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveMDLCT(int item, int output)
+int indigoSaveMDLCT(int item, int output)
 {
     INDIGO_BEGIN
     {
@@ -671,7 +671,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveRxnfile(int reaction, int output)
+int indigoSaveRxnfile(int reaction, int output)
 {
     INDIGO_BEGIN
     {
@@ -689,7 +689,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAppend(int saver_id, int object)
+int indigoAppend(int saver_id, int object)
 {
     INDIGO_BEGIN
     {
@@ -704,7 +704,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveCdxml(int item, int output)
+int indigoSaveCdxml(int item, int output)
 {
     INDIGO_BEGIN
     {
@@ -748,7 +748,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveCdx(int item, int output)
+int indigoSaveCdx(int item, int output)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_misc.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_misc.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_misc.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_misc.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_misc.cpp	(date 1690767117645)
@@ -42,7 +42,7 @@
 #include "indigo_savers.h"
 #include "indigo_structure_checker.h"
 
-CEXPORT int indigoAromatize(int object)
+int indigoAromatize(int object)
 {
     INDIGO_BEGIN
     {
@@ -58,7 +58,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDearomatize(int object)
+int indigoDearomatize(int object)
 {
     INDIGO_BEGIN
     {
@@ -78,7 +78,7 @@
 }
 
 #define INDIGO_SET_OPTION(SUFFIX, TYPE)                                                                                                                        \
-    CEXPORT int indigoSetOption##SUFFIX(const char* name, TYPE value)                                                                                          \
+    int indigoSetOption##SUFFIX(const char* name, TYPE value)                                                                                          \
     {                                                                                                                                                          \
         INDIGO_BEGIN                                                                                                                                           \
         {                                                                                                                                                      \
@@ -93,7 +93,7 @@
 INDIGO_SET_OPTION(Bool, int)
 INDIGO_SET_OPTION(Float, float)
 
-CEXPORT int indigoSetOptionColor(const char* name, float r, float g, float b)
+int indigoSetOptionColor(const char* name, float r, float g, float b)
 {
     INDIGO_BEGIN
     {
@@ -102,7 +102,7 @@
     }
     INDIGO_END(-1);
 }
-CEXPORT int indigoSetOptionXY(const char* name, int x, int y)
+int indigoSetOptionXY(const char* name, int x, int y)
 {
     INDIGO_BEGIN
     {
@@ -112,7 +112,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetOption(const char* name)
+const char* indigoGetOption(const char* name)
 {
     INDIGO_BEGIN
     {
@@ -123,7 +123,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoGetOptionInt(const char* name, int* value)
+int indigoGetOptionInt(const char* name, int* value)
 {
     INDIGO_BEGIN
     {
@@ -136,7 +136,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetOptionBool(const char* name, int* value)
+int indigoGetOptionBool(const char* name, int* value)
 {
     INDIGO_BEGIN
     {
@@ -149,7 +149,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetOptionFloat(const char* name, float* value)
+int indigoGetOptionFloat(const char* name, float* value)
 {
     INDIGO_BEGIN
     {
@@ -162,7 +162,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetOptionColor(const char* name, float* r, float* g, float* b)
+int indigoGetOptionColor(const char* name, float* r, float* g, float* b)
 {
     INDIGO_BEGIN
     {
@@ -175,7 +175,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetOptionXY(const char* name, int* x, int* y)
+int indigoGetOptionXY(const char* name, int* x, int* y)
 {
     INDIGO_BEGIN
     {
@@ -188,7 +188,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetOptionType(const char* name)
+const char* indigoGetOptionType(const char* name)
 {
     INDIGO_BEGIN
     {
@@ -199,7 +199,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoResetOptions()
+int indigoResetOptions()
 {
     INDIGO_BEGIN
     {
@@ -229,7 +229,7 @@
     }
 }
 
-CEXPORT const char* indigoCheckBadValence(int handle)
+const char* indigoCheckBadValence(int handle)
 {
     INDIGO_BEGIN
     {
@@ -318,7 +318,7 @@
         }
 }
 
-CEXPORT const char* indigoCheckAmbiguousH(int handle)
+const char* indigoCheckAmbiguousH(int handle)
 {
     INDIGO_BEGIN
     {
@@ -375,7 +375,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoSmiles(int item)
+const char* indigoSmiles(int item)
 {
     INDIGO_BEGIN
     {
@@ -387,7 +387,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoCanonicalSmiles(int item)
+const char* indigoCanonicalSmiles(int item)
 {
     INDIGO_BEGIN
     {
@@ -400,7 +400,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int64_t indigoHash(int item)
+int64_t indigoHash(int item)
 {
     INDIGO_BEGIN
     {
@@ -421,7 +421,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoSmarts(int item)
+const char* indigoSmarts(int item)
 {
     INDIGO_BEGIN
     {
@@ -434,7 +434,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoCanonicalSmarts(int item)
+const char* indigoCanonicalSmarts(int item)
 {
     INDIGO_BEGIN
     {
@@ -447,7 +447,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoUnfoldHydrogens(int item)
+int indigoUnfoldHydrogens(int item)
 {
     INDIGO_BEGIN
     {
@@ -499,7 +499,7 @@
     return to_remove.size() > 0;
 }
 
-CEXPORT int indigoFoldHydrogens(int item)
+int indigoFoldHydrogens(int item)
 {
     INDIGO_BEGIN
     {
@@ -523,7 +523,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetName(int handle, const char* name)
+int indigoSetName(int handle, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -540,7 +540,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoName(int handle)
+const char* indigoName(int handle)
 {
     INDIGO_BEGIN
     {
@@ -549,7 +549,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoRawData(int handler)
+const char* indigoRawData(int handler)
 {
     INDIGO_BEGIN
     {
@@ -579,7 +579,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoRemove(int item)
+int indigoRemove(int item)
 {
     INDIGO_BEGIN
     {
@@ -591,7 +591,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAt(int item, int index)
+int indigoAt(int item, int index)
 {
     INDIGO_BEGIN
     {
@@ -636,7 +636,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCount(int item)
+int indigoCount(int item)
 {
     INDIGO_BEGIN
     {
@@ -659,7 +659,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSerialize(int item, byte** buf, int* size)
+int indigoSerialize(int item, byte** buf, int* size)
 {
     INDIGO_BEGIN
     {
@@ -696,7 +696,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoUnserialize(const byte* buf, int size)
+int indigoUnserialize(const byte* buf, int size)
 {
     INDIGO_BEGIN
     {
@@ -722,7 +722,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClear(int item)
+int indigoClear(int item)
 {
     INDIGO_BEGIN
     {
@@ -745,7 +745,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoHighlight(int item)
+int indigoHighlight(int item)
 {
     INDIGO_BEGIN
     {
@@ -771,7 +771,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoUnhighlight(int item)
+int indigoUnhighlight(int item)
 {
     INDIGO_BEGIN
     {
@@ -809,7 +809,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIsHighlighted(int item)
+int indigoIsHighlighted(int item)
 {
     INDIGO_BEGIN
     {
@@ -835,7 +835,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSelect(int item)
+int indigoSelect(int item)
 {
     INDIGO_BEGIN
     {
@@ -861,7 +861,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoUnselect(int item)
+int indigoUnselect(int item)
 {
     INDIGO_BEGIN
     {
@@ -899,7 +899,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIsSelected(int item)
+int indigoIsSelected(int item)
 {
     INDIGO_BEGIN
     {
@@ -925,7 +925,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoOptimize(int query, const char* options)
+int indigoOptimize(int query, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -981,17 +981,17 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoHasZCoord(int item)
+int indigoHasZCoord(int item)
 {
     return _indigoHasCoord(item, BaseMolecule::hasZCoord, "indigoHasZCoord");
 }
 
-CEXPORT int indigoHasCoord(int item)
+int indigoHasCoord(int item)
 {
     return _indigoHasCoord(item, BaseMolecule::hasCoord, "indigoHasCoord");
 }
 
-CEXPORT const char* indigoDbgInternalType(int object)
+const char* indigoDbgInternalType(int object)
 {
     INDIGO_BEGIN
     {
@@ -1006,7 +1006,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoNormalize(int structure, const char* options)
+int indigoNormalize(int structure, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -1057,7 +1057,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoStandardize(int object)
+int indigoStandardize(int object)
 {
     INDIGO_BEGIN
     {
@@ -1082,7 +1082,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIonize(int object, float pH, float pH_toll)
+int indigoIonize(int object, float pH, float pH_toll)
 {
     INDIGO_BEGIN
     {
@@ -1094,7 +1094,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoBuildPkaModel(int max_level, float threshold, const char* filename)
+int indigoBuildPkaModel(int max_level, float threshold, const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -1106,7 +1106,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT float* indigoGetAcidPkaValue(int object, int atom, int level, int min_level)
+float* indigoGetAcidPkaValue(int object, int atom, int level, int min_level)
 {
     INDIGO_BEGIN
     {
@@ -1129,7 +1129,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT float* indigoGetBasicPkaValue(int object, int atom, int level, int min_level)
+float* indigoGetBasicPkaValue(int object, int atom, int level, int min_level)
 {
     INDIGO_BEGIN
     {
@@ -1152,7 +1152,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoIsPossibleFischerProjection(int object, const char* options)
+int indigoIsPossibleFischerProjection(int object, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -1205,7 +1205,7 @@
     }
 }
 
-CEXPORT int indigoTransformHELMtoSCSR(int object)
+int indigoTransformHELMtoSCSR(int object)
 {
     INDIGO_BEGIN
     {
@@ -1254,7 +1254,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCheckQuery(int item)
+int indigoCheckQuery(int item)
 {
     INDIGO_BEGIN
     {
@@ -1297,7 +1297,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCheckChirality(int item)
+int indigoCheckChirality(int item)
 {
     INDIGO_BEGIN
     {
@@ -1321,7 +1321,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCheck3DStereo(int item)
+int indigoCheck3DStereo(int item)
 {
     INDIGO_BEGIN
     {
@@ -1358,7 +1358,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCheckStereo(int item)
+int indigoCheckStereo(int item)
 {
     INDIGO_BEGIN
     {
@@ -1401,7 +1401,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoCheck(const char* item, const char* check_flags, const char* load_params)
+const char* indigoCheck(const char* item, const char* check_flags, const char* load_params)
 {
     INDIGO_BEGIN
     {
@@ -1416,7 +1416,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoCheckObj(int item, const char* check_flags)
+const char* indigoCheckObj(int item, const char* check_flags)
 {
     INDIGO_BEGIN
     {
@@ -1430,7 +1430,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoCheckStructure(const char* structure, const char* props)
+const char* indigoCheckStructure(const char* structure, const char* props)
 {
     INDIGO_BEGIN
     {
@@ -1456,7 +1456,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoJson(int item)
+const char* indigoJson(int item)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/core/indigo-core/molecule/src/haworth_projection_finder.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/molecule/src/haworth_projection_finder.cpp b/indigo-src/indigo/core/indigo-core/molecule/src/haworth_projection_finder.cpp
--- a/indigo-src/indigo/core/indigo-core/molecule/src/haworth_projection_finder.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/core/indigo-core/molecule/src/haworth_projection_finder.cpp	(date 1689048275442)
@@ -12,6 +12,11 @@
 
 CP_DEF(HaworthProjectionFinder);
 
+template<typename T>
+inline auto indigo_get_sign(T a){
+    return (a > 0 ? 1 : (a < 0 ? -1 : 0));
+}
+
 const float COS10_THRESHOLD = 0.015f;
 
 HaworthProjectionFinder::HaworthProjectionFinder(BaseMolecule& mol)
@@ -147,8 +152,8 @@
 
         float s = _getAngleSin(vi, e1i, e2i);
         if (sign == 0)
-            sign = __sign(s);
-        else if (sign != __sign(s))
+            sign = indigo_get_sign(s);
+        else if (sign != indigo_get_sign(s))
             return false; // Rotation direction is different => non-convex
 
         bool is_corner = _isCornerVertex(vi, e1i, e2i);
@@ -219,8 +224,8 @@
             {
                 // Count only non-horizontal bonds
                 if (sub_sign == 0)
-                    sub_sign = __sign(c2);
-                else if (sub_sign == __sign(c2))
+                    sub_sign = indigo_get_sign(c2);
+                else if (sub_sign == indigo_get_sign(c2))
                     return false; // Substituents are in the same direction
             }
         }
@@ -329,7 +334,7 @@
     float yn = _mol.getAtomXyz(vertices[left_next]).y;
     float yp = _mol.getAtomXyz(vertices[left_prev]).y;
 
-    int parity = __sign(yn - yp);
+    int parity = indigo_get_sign(yn - yp);
 
     for (int j = 0; j < vertices.size(); j++)
     {
@@ -411,7 +416,7 @@
     Vec2f d1(pv1.x - pv.x, pv1.y - pv.y);
     Vec2f d2(pv2.x - pv.x, pv2.y - pv.y);
 
-    return __sign(d1.x * d2.x) == 1;
+    return indigo_get_sign(d1.x * d2.x) == 1;
 }
 
 bool HaworthProjectionFinder::_isHorizontalEdge(int e, float cos_threshold)
Index: indigo-src/indigo/api/c/indigo/src/indigo_match.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_match.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_match.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_match.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_match.cpp	(date 1690767117645)
@@ -72,7 +72,7 @@
     label_list.push(Element::fromString(buf.ptr()));
 }
 
-CEXPORT int indigoSetTautomerRule(int n, const char* beg, const char* end)
+int indigoSetTautomerRule(int n, const char* beg, const char* end)
 {
     INDIGO_BEGIN
     {
@@ -91,7 +91,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearTautomerRules()
+int indigoClearTautomerRules()
 {
     INDIGO_BEGIN
     {
@@ -101,7 +101,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRemoveTautomerRule(int n)
+int indigoRemoveTautomerRule(int n)
 {
     INDIGO_BEGIN
     {
@@ -111,7 +111,7 @@
     INDIGO_END(-1);
 }
 
-DLLEXPORT bool _indigoParseTautomerFlags(const char* flags, IndigoTautomerParams& params)
+bool _indigoParseTautomerFlags(const char* flags, IndigoTautomerParams& params)
 {
     if (flags == 0)
         return false;
@@ -135,7 +135,7 @@
     return true;
 }
 
-DLLEXPORT int _indigoParseExactFlags(const char* flags, bool reaction, float* rms_threshold)
+int _indigoParseExactFlags(const char* flags, bool reaction, float* rms_threshold)
 {
     if (flags == 0)
         throw IndigoError("_indigoParseExactFlags(): zero string pointer");
@@ -243,7 +243,7 @@
     return res;
 }
 
-CEXPORT int indigoExactMatch(int handler1, int handler2, const char* flags)
+int indigoExactMatch(int handler1, int handler2, const char* flags)
 {
     INDIGO_BEGIN
     {
@@ -727,7 +727,7 @@
     return true;
 }
 
-CEXPORT int indigoSubstructureMatcher(int target, const char* mode_str)
+int indigoSubstructureMatcher(int target, const char* mode_str)
 {
     INDIGO_BEGIN
     {
@@ -797,7 +797,7 @@
                                        method);
 }
 
-CEXPORT int indigoIgnoreAtom(int target_matcher, int atom_object)
+int indigoIgnoreAtom(int target_matcher, int atom_object)
 {
     INDIGO_BEGIN
     {
@@ -811,7 +811,7 @@
 }
 
 // Ignore target atom in the substructure matcher
-CEXPORT int indigoUnignoreAtom(int target_matcher, int atom_object)
+int indigoUnignoreAtom(int target_matcher, int atom_object)
 {
     INDIGO_BEGIN
     {
@@ -824,7 +824,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoUnignoreAllAtoms(int target_matcher)
+int indigoUnignoreAllAtoms(int target_matcher)
 {
     INDIGO_BEGIN
     {
@@ -835,7 +835,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoMatch(int target_matcher, int query)
+int indigoMatch(int target_matcher, int query)
 {
     INDIGO_BEGIN
     {
@@ -947,7 +947,7 @@
     return indigoCountMatchesWithLimit(target_matcher, query, 0);
 }
 
-CEXPORT int indigoCountMatchesWithLimit(int target_matcher, int query, int embeddings_limit)
+int indigoCountMatchesWithLimit(int target_matcher, int query, int embeddings_limit)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/option_manager.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/option_manager.cpp b/indigo-src/indigo/api/c/indigo/src/option_manager.cpp
--- a/indigo-src/indigo/api/c/indigo/src/option_manager.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/option_manager.cpp	(date 1690767117645)
@@ -29,7 +29,7 @@
     return mgr;
 }
 
-DLLEXPORT sf::safe_shared_hide_obj<IndigoOptionManager>& indigoGetOptionManager(const qword id)
+sf::safe_shared_hide_obj<IndigoOptionManager>& indigoGetOptionManager(const qword id)
 {
     return IndigoOptionManager::getIndigoOptionManager().getLocalCopy(id);
 }
Index: indigo-src/indigo/core/indigo-core/molecule/src/inchi_wrapper.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/molecule/src/inchi_wrapper.cpp b/indigo-src/indigo/core/indigo-core/molecule/src/inchi_wrapper.cpp
--- a/indigo-src/indigo/core/indigo-core/molecule/src/inchi_wrapper.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/core/indigo-core/molecule/src/inchi_wrapper.cpp	(date 1689048275446)
@@ -17,6 +17,7 @@
  ***************************************************************************/
 
 #include <algorithm>
+#define TARGET_LIB_FOR_WINCHI
 #include <mode.h>
 
 #include "molecule/inchi_wrapper.h"
Index: indigo-src/indigo/api/c/indigo/src/indigo_array.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_array.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_array.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_array.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_array.cpp	(date 1690767117645)
@@ -139,7 +139,7 @@
     return _idx + 1 < _arr->objects.size();
 }
 
-CEXPORT int indigoCreateArray()
+int indigoCreateArray()
 {
     INDIGO_BEGIN
     {
@@ -148,7 +148,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoArrayAdd(int arr, int handle)
+int indigoArrayAdd(int arr, int handle)
 {
     INDIGO_BEGIN
     {
@@ -163,7 +163,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateArray(int arr)
+int indigoIterateArray(int arr)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo-inchi/src/indigo_inchi_api.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo-inchi/src/indigo_inchi_api.cpp b/indigo-src/indigo/api/c/indigo-inchi/src/indigo_inchi_api.cpp
--- a/indigo-src/indigo/api/c/indigo-inchi/src/indigo_inchi_api.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo-inchi/src/indigo_inchi_api.cpp	(date 1690767117645)
@@ -29,7 +29,7 @@
 
 using namespace indigo;
 
-CEXPORT const char* indigoInchiVersion()
+const char* indigoInchiVersion()
 {
     return InchiWrapper::version();
 }
@@ -74,7 +74,7 @@
 // C interface functions
 //
 
-CEXPORT int indigoInchiInit(qword id)
+int indigoInchiInit(qword id)
 {
 #ifdef INDIGO_DEBUG
     std::stringstream ss;
@@ -89,7 +89,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoInchiDispose(qword id)
+int indigoInchiDispose(qword id)
 {
 #ifdef INDIGO_DEBUG
     std::stringstream ss;
@@ -104,14 +104,14 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoInchiResetOptions(void)
+int indigoInchiResetOptions(void)
 {
     IndigoInchiContext& inchi_context = indigoInchiGetInstance();
     inchi_context.init();
     return 0;
 }
 
-CEXPORT int indigoInchiLoadMolecule(const char* inchi_string)
+int indigoInchiLoadMolecule(const char* inchi_string)
 {
     INDIGO_BEGIN
     {
@@ -152,7 +152,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoInchiGetInchi(int molecule)
+const char* indigoInchiGetInchi(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -166,7 +166,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoInchiGetInchiKey(const char* inchi_string)
+const char* indigoInchiGetInchiKey(const char* inchi_string)
 {
     INDIGO_BEGIN
     {
@@ -177,7 +177,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoInchiGetWarning()
+const char* indigoInchiGetWarning()
 {
     InchiWrapper& inchi_wrapper = indigoInchiGetInstance().inchi;
     if (inchi_wrapper.warning.size() != 0)
@@ -185,7 +185,7 @@
     return "";
 }
 
-CEXPORT const char* indigoInchiGetLog()
+const char* indigoInchiGetLog()
 {
     InchiWrapper& inchi_wrapper = indigoInchiGetInstance().inchi;
     if (inchi_wrapper.log.size() != 0)
@@ -193,7 +193,7 @@
     return "";
 }
 
-CEXPORT const char* indigoInchiGetAuxInfo()
+const char* indigoInchiGetAuxInfo()
 {
     InchiWrapper& inchi_wrapper = indigoInchiGetInstance().inchi;
     if (inchi_wrapper.auxInfo.size() != 0)
Index: indigo-src/indigo/api/c/indigo/src/indigo_calc.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_calc.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_calc.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_calc.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_calc.cpp	(date 1690767117645)
@@ -37,7 +37,7 @@
     ReactionGrossFormula::toString_Hill(*gross, str, self.gross_formula_options.add_rsites);
 }
 
-CEXPORT int indigoGrossFormula(int object)
+int indigoGrossFormula(int object)
 {
     INDIGO_BEGIN
     {
@@ -81,7 +81,7 @@
     }
 }
 
-CEXPORT double indigoMolecularWeight(int molecule)
+double indigoMolecularWeight(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -93,7 +93,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT double indigoMostAbundantMass(int molecule)
+double indigoMostAbundantMass(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -105,7 +105,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT double indigoMonoisotopicMass(int molecule)
+double indigoMonoisotopicMass(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -117,7 +117,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoMassComposition(int molecule)
+const char* indigoMassComposition(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -133,7 +133,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT double indigoTPSA(const int molecule, const int includeSP)
+double indigoTPSA(const int molecule, const int includeSP)
 {
     INDIGO_BEGIN
     {
@@ -148,7 +148,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoNumRotatableBonds(const int molecule)
+int indigoNumRotatableBonds(const int molecule)
 {
     INDIGO_BEGIN
     {
@@ -163,7 +163,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoNumHydrogenBondAcceptors(const int molecule)
+int indigoNumHydrogenBondAcceptors(const int molecule)
 {
     INDIGO_BEGIN
     {
@@ -178,7 +178,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoNumHydrogenBondDonors(const int molecule)
+int indigoNumHydrogenBondDonors(const int molecule)
 {
     INDIGO_BEGIN
     {
@@ -193,7 +193,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT double indigoLogP(const int molecule)
+double indigoLogP(const int molecule)
 {
     INDIGO_BEGIN
     {
@@ -208,7 +208,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT double indigoMolarRefractivity(const int molecule)
+double indigoMolarRefractivity(const int molecule)
 {
     INDIGO_BEGIN
     {
@@ -223,7 +223,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT double indigoPka(const int molecule)
+double indigoPka(const int molecule)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_product_enumerator.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_product_enumerator.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_product_enumerator.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_product_enumerator.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_product_enumerator.cpp	(date 1690767117645)
@@ -66,7 +66,7 @@
     indices.copy(monomers_indices);
 }
 
-CEXPORT int indigoReactionProductEnumerate(int reaction, int monomers)
+int indigoReactionProductEnumerate(int reaction, int monomers)
 {
     INDIGO_BEGIN
     {
@@ -155,7 +155,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoTransform(int reaction, int monomers)
+int indigoTransform(int reaction, int monomers)
 {
     INDIGO_BEGIN
     {
Index: freetype-src/freetype/include/freetype/config/ftoption.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/freetype-src/freetype/include/freetype/config/ftoption.h b/freetype-src/freetype/include/freetype/config/ftoption.h
--- a/freetype-src/freetype/include/freetype/config/ftoption.h	(revision de8b92dd7ec634e9e2b25ef534c54a3537555c11)
+++ b/freetype-src/freetype/include/freetype/config/ftoption.h	(date 1689048275378)
@@ -273,7 +273,7 @@
    *   options set by those programs have precedence, overwriting the value
    *   here with the configured one.
    */
-/* #define FT_CONFIG_OPTION_USE_PNG */
+#define FT_CONFIG_OPTION_USE_PNG
 
 
   /**************************************************************************
Index: libpng-src/libpng/pngconf.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/pngconf.h b/libpng-src/libpng/pngconf.h
--- a/libpng-src/libpng/pngconf.h	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/pngconf.h	(date 1690938866074)
@@ -1,11 +1,12 @@
 
-/* pngconf.h - machine configurable file for libpng
+/* pngconf.h - machine-configurable file for libpng
  *
- * libpng version 1.6.25, September 1, 2016
+ * libpng version 1.6.40
  *
- * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ * Copyright (c) 2018-2022 Cosmin Truta
+ * Copyright (c) 1998-2002,2004,2006-2016,2018 Glenn Randers-Pehrson
+ * Copyright (c) 1996-1997 Andreas Dilger
+ * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
@@ -20,6 +21,7 @@
 #ifndef PNGCONF_H
 #define PNGCONF_H
 
+#include "libpng_export.h"
 #ifndef PNG_BUILDING_SYMBOL_TABLE /* else includes may cause problems */
 
 /* From libpng 1.6.0 libpng requires an ANSI X3.159-1989 ("ISOC90") compliant C
@@ -57,14 +59,13 @@
 
 #endif /* PNG_BUILDING_SYMBOL_TABLE */
 
-/* Prior to 1.6.0 it was possible to turn off 'const' in declarations using
- * PNG_NO_CONST; this is no longer supported except for data declarations which
- * apparently still cause problems in 2011 on some compilers.
+/* Prior to 1.6.0, it was possible to turn off 'const' in declarations,
+ * using PNG_NO_CONST.  This is no longer supported.
  */
 #define PNG_CONST const /* backward compatibility only */
 
-/* This controls optimization of the reading of 16-bit and 32-bit values
- * from PNG files.  It can be set on a per-app-file basis - it
+/* This controls optimization of the reading of 16-bit and 32-bit
+ * values from PNG files.  It can be set on a per-app-file basis: it
  * just changes whether a macro is used when the function is called.
  * The library builder sets the default; if read functions are not
  * built into the library the macro implementation is forced on.
@@ -127,7 +128,7 @@
  *
  * These cases only differ if the operating system does not use the C
  * calling convention, at present this just means the above cases
- * (x86 DOS/Windows sytems) and, even then, this does not apply to
+ * (x86 DOS/Windows systems) and, even then, this does not apply to
  * Cygwin running on those systems.
  *
  * Note that the value must be defined in pnglibconf.h so that what
@@ -162,14 +163,6 @@
  * PNG_EXPORT_TYPE(type) A macro that pre or appends PNG_IMPEXP to
  *                       'type', compiler specific.
  *
- * PNG_DLL_EXPORT Set to the magic to use during a libpng build to
- *                make a symbol exported from the DLL.  Not used in the
- *                public header files; see pngpriv.h for how it is used
- *                in the libpng build.
- *
- * PNG_DLL_IMPORT Set to the magic to force the libpng symbols to come
- *                from a DLL - used to define PNG_IMPEXP when
- *                PNG_USE_DLL is set.
  */
 
 /* System specific discovery.
@@ -180,8 +173,9 @@
  * compiler-specific macros to the values required to change the calling
  * conventions of the various functions.
  */
-#if defined(_Windows) || defined(_WINDOWS) || defined(WIN32) ||\
-    defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
+
+#if defined(_WIN32) || defined(__WIN32__) || defined(__NT__) || \
+    defined(__CYGWIN__)
   /* Windows system (DOS doesn't support DLLs).  Includes builds under Cygwin or
    * MinGW on any architecture currently supported by Windows.  Also includes
    * Watcom builds but these need special treatment because they are not
@@ -222,23 +216,6 @@
 #  if defined(PNGAPI) && !defined(PNG_USER_PRIVATEBUILD)
 #     error "PNG_USER_PRIVATEBUILD must be defined if PNGAPI is changed"
 #  endif
-
-#  if (defined(_MSC_VER) && _MSC_VER < 800) ||\
-      (defined(__BORLANDC__) && __BORLANDC__ < 0x500)
-   /* older Borland and MSC
-    * compilers used '__export' and required this to be after
-    * the type.
-    */
-#    ifndef PNG_EXPORT_TYPE
-#      define PNG_EXPORT_TYPE(type) type PNG_IMPEXP
-#    endif
-#    define PNG_DLL_EXPORT __export
-#  else /* newer compiler */
-#    define PNG_DLL_EXPORT __declspec(dllexport)
-#    ifndef PNG_DLL_IMPORT
-#      define PNG_DLL_IMPORT __declspec(dllimport)
-#    endif
-#  endif /* compiler */
 
 #else /* !Windows */
 #  if (defined(__IBMC__) || defined(__IBMCPP__)) && defined(__OS2__)
@@ -265,16 +242,9 @@
  * then in an internal header file when building the library, otherwise (when
  * using the library) it is set here.
  */
-#ifndef PNG_IMPEXP
-#  if defined(PNG_USE_DLL) && defined(PNG_DLL_IMPORT)
-   /* This forces use of a DLL, disallowing static linking */
-#    define PNG_IMPEXP PNG_DLL_IMPORT
-#  endif
-
 #  ifndef PNG_IMPEXP
-#    define PNG_IMPEXP
+#    define PNG_IMPEXP LIBPNG_EXPORT
 #  endif
-#endif
 
 /* In 1.5.2 the definition of PNG_FUNCTION has been changed to always treat
  * 'attributes' as a storage class - the attributes go at the start of the
@@ -507,16 +477,18 @@
 #  error "libpng requires a signed 32-bit (or more) type"
 #endif
 
-#if UINT_MAX > 4294967294
+#if UINT_MAX > 4294967294U
    typedef unsigned int png_uint_32;
-#elif ULONG_MAX > 4294967294
+#elif ULONG_MAX > 4294967294U
    typedef unsigned long int png_uint_32;
 #else
 #  error "libpng requires an unsigned 32-bit (or more) type"
 #endif
 
-/* Prior to 1.6.0 it was possible to disable the use of size_t, 1.6.0, however,
- * requires an ISOC90 compiler and relies on consistent behavior of sizeof.
+/* Prior to 1.6.0, it was possible to disable the use of size_t and ptrdiff_t.
+ * From 1.6.0 onwards, an ISO C90 compiler, as well as a standard-compliant
+ * behavior of sizeof and ptrdiff_t are required.
+ * The legacy typedefs are provided here for backwards compatibility.
  */
 typedef size_t png_size_t;
 typedef ptrdiff_t png_ptrdiff_t;
@@ -537,13 +509,12 @@
 #  endif
 #endif
 
-/* png_alloc_size_t is guaranteed to be no smaller than png_size_t, and no
- * smaller than png_uint_32.  Casts from png_size_t or png_uint_32 to
- * png_alloc_size_t are not necessary; in fact, it is recommended not to use
- * them at all so that the compiler can complain when something turns out to be
- * problematic.
+/* png_alloc_size_t is guaranteed to be no smaller than size_t, and no smaller
+ * than png_uint_32.  Casts from size_t or png_uint_32 to png_alloc_size_t are
+ * not necessary; in fact, it is recommended not to use them at all, so that
+ * the compiler can complain when something turns out to be problematic.
  *
- * Casts in the other direction (from png_alloc_size_t to png_size_t or
+ * Casts in the other direction (from png_alloc_size_t to size_t or
  * png_uint_32) should be explicitly applied; however, we do not expect to
  * encounter practical situations that require such conversions.
  *
@@ -553,7 +524,7 @@
 #ifdef PNG_SMALL_SIZE_T
    typedef png_uint_32 png_alloc_size_t;
 #else
-   typedef png_size_t png_alloc_size_t;
+   typedef size_t png_alloc_size_t;
 #endif
 
 /* Prior to 1.6.0 libpng offered limited support for Microsoft C compiler
@@ -589,8 +560,8 @@
 typedef const char            * png_const_charp;
 typedef png_fixed_point       * png_fixed_point_p;
 typedef const png_fixed_point * png_const_fixed_point_p;
-typedef png_size_t            * png_size_tp;
-typedef const png_size_t      * png_const_size_tp;
+typedef size_t                * png_size_tp;
+typedef const size_t          * png_const_size_tp;
 
 #ifdef PNG_STDIO_SUPPORTED
 typedef FILE            * png_FILE_p;
Index: indigo-src/indigo/api/c/indigo/src/indigo_reaction.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_reaction.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_reaction.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_reaction.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_reaction.cpp	(date 1690767117645)
@@ -352,7 +352,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadReaction(int source)
+int indigoLoadReaction(int source)
 {
     INDIGO_BEGIN
     {
@@ -374,7 +374,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadQueryReaction(int source)
+int indigoLoadQueryReaction(int source)
 {
     INDIGO_BEGIN
     {
@@ -395,27 +395,27 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateReactants(int reaction)
+int indigoIterateReactants(int reaction)
 {
     return _indigoIterateReaction(reaction, IndigoReactionIter::REACTANTS);
 }
 
-CEXPORT int indigoIterateProducts(int reaction)
+int indigoIterateProducts(int reaction)
 {
     return _indigoIterateReaction(reaction, IndigoReactionIter::PRODUCTS);
 }
 
-CEXPORT int indigoIterateCatalysts(int reaction)
+int indigoIterateCatalysts(int reaction)
 {
     return _indigoIterateReaction(reaction, IndigoReactionIter::CATALYSTS);
 }
 
-CEXPORT int indigoIterateMolecules(int reaction)
+int indigoIterateMolecules(int reaction)
 {
     return _indigoIterateReaction(reaction, IndigoReactionIter::MOLECULES);
 }
 
-CEXPORT int indigoCreateReaction(void)
+int indigoCreateReaction(void)
 {
     INDIGO_BEGIN
     {
@@ -424,7 +424,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateQueryReaction(void)
+int indigoCreateQueryReaction(void)
 {
     INDIGO_BEGIN
     {
@@ -433,7 +433,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddReactant(int reaction, int molecule)
+int indigoAddReactant(int reaction, int molecule)
 {
     INDIGO_BEGIN
     {
@@ -445,7 +445,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddProduct(int reaction, int molecule)
+int indigoAddProduct(int reaction, int molecule)
 {
     INDIGO_BEGIN
     {
@@ -457,7 +457,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddCatalyst(int reaction, int molecule)
+int indigoAddCatalyst(int reaction, int molecule)
 {
     INDIGO_BEGIN
     {
@@ -469,7 +469,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountReactants(int reaction)
+int indigoCountReactants(int reaction)
 {
     INDIGO_BEGIN
     {
@@ -478,7 +478,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountProducts(int reaction)
+int indigoCountProducts(int reaction)
 {
     INDIGO_BEGIN
     {
@@ -487,7 +487,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountCatalysts(int reaction)
+int indigoCountCatalysts(int reaction)
 {
     INDIGO_BEGIN
     {
@@ -496,7 +496,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountMolecules(int handle)
+int indigoCountMolecules(int handle)
 {
     INDIGO_BEGIN
     {
@@ -510,7 +510,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetMolecule(int reaction, int index)
+int indigoGetMolecule(int reaction, int index)
 {
     INDIGO_BEGIN
     {
@@ -530,7 +530,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoMapMolecule(int handle, int molecule)
+int indigoMapMolecule(int handle, int molecule)
 {
     INDIGO_BEGIN
     {
@@ -596,7 +596,7 @@
     return nmode;
 }
 
-CEXPORT int indigoAutomap(int reaction, const char* mode)
+int indigoAutomap(int reaction, const char* mode)
 {
     INDIGO_BEGIN
     {
@@ -639,7 +639,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetAtomMappingNumber(int reaction, int reaction_atom)
+int indigoGetAtomMappingNumber(int reaction, int reaction_atom)
 {
     INDIGO_BEGIN
     {
@@ -656,7 +656,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetAtomMappingNumber(int reaction, int reaction_atom, int number)
+int indigoSetAtomMappingNumber(int reaction, int reaction_atom, int number)
 {
     INDIGO_BEGIN
     {
@@ -676,7 +676,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetReactingCenter(int reaction, int reaction_bond, int* rc)
+int indigoGetReactingCenter(int reaction, int reaction_bond, int* rc)
 {
     INDIGO_BEGIN
     {
@@ -694,7 +694,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetReactingCenter(int reaction, int reaction_bond, int rc)
+int indigoSetReactingCenter(int reaction, int reaction_bond, int rc)
 {
     INDIGO_BEGIN
     {
@@ -714,7 +714,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearAAM(int reaction)
+int indigoClearAAM(int reaction)
 {
     INDIGO_BEGIN
     {
@@ -725,7 +725,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCorrectReactingCenters(int reaction)
+int indigoCorrectReactingCenters(int reaction)
 {
     INDIGO_BEGIN
     {
@@ -738,7 +738,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadReactionSmarts(int source)
+int indigoLoadReactionSmarts(int source)
 {
     INDIGO_BEGIN
     {
@@ -756,7 +756,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoCanonicalRSmiles(int reaction)
+const char* indigoCanonicalRSmiles(int reaction)
 {
     INDIGO_BEGIN
     {
Index: libpng-src/libpng/pnginfo.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/pnginfo.h b/libpng-src/libpng/pnginfo.h
--- a/libpng-src/libpng/pnginfo.h	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/pnginfo.h	(date 1690795574122)
@@ -1,10 +1,10 @@
 
 /* pnginfo.h - header file for PNG reference library
  *
- * Last changed in libpng 1.6.1 [March 28, 2013]
- * Copyright (c) 1998-2002,2004,2006-2013 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ * Copyright (c) 2018 Cosmin Truta
+ * Copyright (c) 1998-2002,2004,2006-2013,2018 Glenn Randers-Pehrson
+ * Copyright (c) 1996-1997 Andreas Dilger
+ * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
@@ -55,10 +55,10 @@
 struct png_info_def
 {
    /* The following are necessary for every PNG file */
-   png_uint_32 width;  /* width of image in pixels (from IHDR) */
-   png_uint_32 height; /* height of image in pixels (from IHDR) */
-   png_uint_32 valid;  /* valid chunk data (see PNG_INFO_ below) */
-   png_size_t rowbytes; /* bytes needed to hold an untransformed row */
+   png_uint_32 width;       /* width of image in pixels (from IHDR) */
+   png_uint_32 height;      /* height of image in pixels (from IHDR) */
+   png_uint_32 valid;       /* valid chunk data (see PNG_INFO_ below) */
+   size_t rowbytes;         /* bytes needed to hold an untransformed row */
    png_colorp palette;      /* array of color values (valid & PNG_INFO_PLTE) */
    png_uint_16 num_palette; /* number of color entries in "palette" (PLTE) */
    png_uint_16 num_trans;   /* number of transparent palette color (tRNS) */
@@ -184,6 +184,14 @@
    png_uint_32 y_pixels_per_unit; /* vertical pixel density */
    png_byte phys_unit_type; /* resolution type (see PNG_RESOLUTION_ below) */
 #endif
+
+#ifdef PNG_eXIf_SUPPORTED
+   int num_exif;  /* Added at libpng-1.6.31 */
+   png_bytep exif;
+# ifdef PNG_READ_eXIf_SUPPORTED
+   png_bytep eXIf_buf;  /* Added at libpng-1.6.32 */
+# endif
+#endif
 
 #ifdef PNG_hIST_SUPPORTED
    /* The hIST chunk contains the relative frequency or importance of the
@@ -239,7 +247,7 @@
    /* The sCAL chunk describes the actual physical dimensions of the
     * subject matter of the graphic.  The chunk contains a unit specification
     * a byte value, and two ASCII strings representing floating-point
-    * values.  The values are width and height corresponsing to one pixel
+    * values.  The values are width and height corresponding to one pixel
     * in the image.  Data values are valid if (valid & PNG_INFO_sCAL) is
     * non-zero.
     */
Index: indigo-src/indigo/api/c/indigo/src/indigo_basic.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_basic.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_basic.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_basic.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_basic.cpp	(date 1690767117645)
@@ -21,7 +21,7 @@
 #include "indigo_internal.h"
 #include <memory>
 
-CEXPORT int indigoNext(int iter)
+int indigoNext(int iter)
 {
     INDIGO_BEGIN
     {
@@ -35,7 +35,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoHasNext(int iter)
+int indigoHasNext(int iter)
 {
     INDIGO_BEGIN
     {
@@ -44,7 +44,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIndex(int handle)
+int indigoIndex(int handle)
 {
     INDIGO_BEGIN
     {
@@ -53,7 +53,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClone(int object)
+int indigoClone(int object)
 {
     INDIGO_BEGIN
     {
Index: rdkit-src/rdkit/Code/ForceField/UFF/Params.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/ForceField/UFF/Params.cpp b/rdkit-src/rdkit/Code/ForceField/UFF/Params.cpp
--- a/rdkit-src/rdkit/Code/ForceField/UFF/Params.cpp	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/ForceField/UFF/Params.cpp	(date 1689048276098)
@@ -7,7 +7,7 @@
 //  which is included in the file license.txt, found at the root
 //  of the RDKit source tree.
 //
-#ifdef WIN32
+#if defined(WIN32) && !defined(_USE_MATH_DEFINES)
 #define _USE_MATH_DEFINES
 #endif
 #include <cmath>
Index: libpng-src/libpng/png.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/png.h b/libpng-src/libpng/png.h
--- a/libpng-src/libpng/png.h	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/png.h	(date 1690795574122)
@@ -1,88 +1,120 @@
 
 /* png.h - header file for PNG reference library
  *
- * libpng version 1.6.25, September 1, 2016
+ * libpng version 1.6.40
  *
- * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ * Copyright (c) 2018-2023 Cosmin Truta
+ * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson
+ * Copyright (c) 1996-1997 Andreas Dilger
+ * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
  *
- * This code is released under the libpng license (See LICENSE, below)
+ * This code is released under the libpng license. (See LICENSE, below.)
  *
  * Authors and maintainers:
  *   libpng versions 0.71, May 1995, through 0.88, January 1996: Guy Schalnat
  *   libpng versions 0.89, June 1996, through 0.96, May 1997: Andreas Dilger
- *   libpng versions 0.97, January 1998, through 1.6.25, September 1, 2016:
- *     Glenn Randers-Pehrson.
+ *   libpng versions 0.97, January 1998, through 1.6.35, July 2018:
+ *     Glenn Randers-Pehrson
+ *   libpng versions 1.6.36, December 2018, through 1.6.40, June 2023:
+ *     Cosmin Truta
  *   See also "Contributing Authors", below.
  */
 
 /*
- * COPYRIGHT NOTICE, DISCLAIMER, and LICENSE:
+ * COPYRIGHT NOTICE, DISCLAIMER, and LICENSE
+ * =========================================
+ *
+ * PNG Reference Library License version 2
+ * ---------------------------------------
+ *
+ *  * Copyright (c) 1995-2023 The PNG Reference Library Authors.
+ *  * Copyright (c) 2018-2023 Cosmin Truta.
+ *  * Copyright (c) 2000-2002, 2004, 2006-2018 Glenn Randers-Pehrson.
+ *  * Copyright (c) 1996-1997 Andreas Dilger.
+ *  * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
+ *
+ * The software is supplied "as is", without warranty of any kind,
+ * express or implied, including, without limitation, the warranties
+ * of merchantability, fitness for a particular purpose, title, and
+ * non-infringement.  In no event shall the Copyright owners, or
+ * anyone distributing the software, be liable for any damages or
+ * other liability, whether in contract, tort or otherwise, arising
+ * from, out of, or in connection with the software, or the use or
+ * other dealings in the software, even if advised of the possibility
+ * of such damage.
+ *
+ * Permission is hereby granted to use, copy, modify, and distribute
+ * this software, or portions hereof, for any purpose, without fee,
+ * subject to the following restrictions:
  *
- * If you modify libpng you may insert additional notices immediately following
- * this sentence.
+ *  1. The origin of this software must not be misrepresented; you
+ *     must not claim that you wrote the original software.  If you
+ *     use this software in a product, an acknowledgment in the product
+ *     documentation would be appreciated, but is not required.
  *
- * This code is released under the libpng license.
+ *  2. Altered source versions must be plainly marked as such, and must
+ *     not be misrepresented as being the original software.
  *
- * Some files in the "contrib" directory and some configure-generated
- * files that are distributed with libpng have other copyright owners and
- * are released under other open source licenses.
+ *  3. This Copyright notice may not be removed or altered from any
+ *     source or altered source distribution.
  *
- * libpng versions 1.0.7, July 1, 2000 through 1.6.25, September 1, 2016 are
- * Copyright (c) 2000-2002, 2004, 2006-2016 Glenn Randers-Pehrson, are
+ *
+ * PNG Reference Library License version 1 (for libpng 0.5 through 1.6.35)
+ * -----------------------------------------------------------------------
+ *
+ * libpng versions 1.0.7, July 1, 2000, through 1.6.35, July 15, 2018 are
+ * Copyright (c) 2000-2002, 2004, 2006-2018 Glenn Randers-Pehrson, are
  * derived from libpng-1.0.6, and are distributed according to the same
  * disclaimer and license as libpng-1.0.6 with the following individuals
  * added to the list of Contributing Authors:
  *
- *    Simon-Pierre Cadieux
- *    Eric S. Raymond
- *    Mans Rullgard
- *    Cosmin Truta
- *    Gilles Vollant
- *    James Yu
- *    Mandar Sahastrabuddhe
+ *     Simon-Pierre Cadieux
+ *     Eric S. Raymond
+ *     Mans Rullgard
+ *     Cosmin Truta
+ *     Gilles Vollant
+ *     James Yu
+ *     Mandar Sahastrabuddhe
+ *     Google Inc.
+ *     Vadim Barkov
  *
  * and with the following additions to the disclaimer:
  *
- *    There is no warranty against interference with your enjoyment of the
- *    library or against infringement.  There is no warranty that our
- *    efforts or the library will fulfill any of your particular purposes
- *    or needs.  This library is provided with all faults, and the entire
- *    risk of satisfactory quality, performance, accuracy, and effort is with
- *    the user.
+ *     There is no warranty against interference with your enjoyment of
+ *     the library or against infringement.  There is no warranty that our
+ *     efforts or the library will fulfill any of your particular purposes
+ *     or needs.  This library is provided with all faults, and the entire
+ *     risk of satisfactory quality, performance, accuracy, and effort is
+ *     with the user.
  *
- * Some files in the "contrib" directory have other copyright owners and
+ * Some files in the "contrib" directory and some configure-generated
+ * files that are distributed with libpng have other copyright owners, and
  * are released under other open source licenses.
  *
- *
  * libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are
  * Copyright (c) 1998-2000 Glenn Randers-Pehrson, are derived from
  * libpng-0.96, and are distributed according to the same disclaimer and
- * license as libpng-0.96, with the following individuals added to the list
- * of Contributing Authors:
+ * license as libpng-0.96, with the following individuals added to the
+ * list of Contributing Authors:
  *
- *    Tom Lane
- *    Glenn Randers-Pehrson
- *    Willem van Schaik
+ *     Tom Lane
+ *     Glenn Randers-Pehrson
+ *     Willem van Schaik
  *
- * Some files in the "scripts" directory have different copyright owners
- * but are also released under this license.
- *
  * libpng versions 0.89, June 1996, through 0.96, May 1997, are
  * Copyright (c) 1996-1997 Andreas Dilger, are derived from libpng-0.88,
  * and are distributed according to the same disclaimer and license as
  * libpng-0.88, with the following individuals added to the list of
  * Contributing Authors:
  *
- *    John Bowler
- *    Kevin Bracey
- *    Sam Bushell
- *    Magnus Holmgren
- *    Greg Roelofs
- *    Tom Tanner
+ *     John Bowler
+ *     Kevin Bracey
+ *     Sam Bushell
+ *     Magnus Holmgren
+ *     Greg Roelofs
+ *     Tom Tanner
  *
- * Some files in the "scripts" directory have other copyright owners
+ * Some files in the "scripts" directory have other copyright owners,
  * but are released under this license.
  *
  * libpng versions 0.5, May 1995, through 0.88, January 1996, are
@@ -91,62 +123,49 @@
  * For the purposes of this copyright and license, "Contributing Authors"
  * is defined as the following set of individuals:
  *
- *    Andreas Dilger
- *    Dave Martindale
- *    Guy Eric Schalnat
- *    Paul Schmidt
- *    Tim Wegner
+ *     Andreas Dilger
+ *     Dave Martindale
+ *     Guy Eric Schalnat
+ *     Paul Schmidt
+ *     Tim Wegner
  *
- * The PNG Reference Library is supplied "AS IS".  The Contributing Authors
- * and Group 42, Inc. disclaim all warranties, expressed or implied,
- * including, without limitation, the warranties of merchantability and of
- * fitness for any purpose.  The Contributing Authors and Group 42, Inc.
- * assume no liability for direct, indirect, incidental, special, exemplary,
- * or consequential damages, which may result from the use of the PNG
- * Reference Library, even if advised of the possibility of such damage.
+ * The PNG Reference Library is supplied "AS IS".  The Contributing
+ * Authors and Group 42, Inc. disclaim all warranties, expressed or
+ * implied, including, without limitation, the warranties of
+ * merchantability and of fitness for any purpose.  The Contributing
+ * Authors and Group 42, Inc. assume no liability for direct, indirect,
+ * incidental, special, exemplary, or consequential damages, which may
+ * result from the use of the PNG Reference Library, even if advised of
+ * the possibility of such damage.
  *
  * Permission is hereby granted to use, copy, modify, and distribute this
  * source code, or portions hereof, for any purpose, without fee, subject
  * to the following restrictions:
  *
- *   1. The origin of this source code must not be misrepresented.
+ *  1. The origin of this source code must not be misrepresented.
  *
- *   2. Altered versions must be plainly marked as such and must not
- *      be misrepresented as being the original source.
+ *  2. Altered versions must be plainly marked as such and must not
+ *     be misrepresented as being the original source.
  *
- *   3. This Copyright notice may not be removed or altered from any
- *      source or altered source distribution.
+ *  3. This Copyright notice may not be removed or altered from any
+ *     source or altered source distribution.
  *
- * The Contributing Authors and Group 42, Inc. specifically permit, without
- * fee, and encourage the use of this source code as a component to
- * supporting the PNG file format in commercial products.  If you use this
- * source code in a product, acknowledgment is not required but would be
- * appreciated.
+ * The Contributing Authors and Group 42, Inc. specifically permit,
+ * without fee, and encourage the use of this source code as a component
+ * to supporting the PNG file format in commercial products.  If you use
+ * this source code in a product, acknowledgment is not required but would
+ * be appreciated.
  *
  * END OF COPYRIGHT NOTICE, DISCLAIMER, and LICENSE.
  *
- * TRADEMARK:
+ * TRADEMARK
+ * =========
  *
- * The name "libpng" has not been registered by the Copyright owner
+ * The name "libpng" has not been registered by the Copyright owners
  * as a trademark in any jurisdiction.  However, because libpng has
  * been distributed and maintained world-wide, continually since 1995,
- * the Copyright owner claims "common-law trademark protection" in any
+ * the Copyright owners claim "common-law trademark protection" in any
  * jurisdiction where common-law trademark is recognized.
- *
- * OSI CERTIFICATION:
- *
- * Libpng is OSI Certified Open Source Software.  OSI Certified Open Source is
- * a certification mark of the Open Source Initiative. OSI has not addressed
- * the additional disclaimers inserted at version 1.0.7.
- *
- * EXPORT CONTROL:
- *
- * The Copyright owner believes that the Export Control Classification
- * Number (ECCN) for libpng is EAR99, which means not subject to export
- * controls or International Traffic in Arms Regulations (ITAR) because
- * it is open source, publicly available software, that does not contain
- * any encryption software.  See the EAR, paragraphs 734.3(b)(3) and
- * 734.7(b).
  */
 
 /*
@@ -212,23 +231,25 @@
  *    1.0.7rc1-2               1    10007  2.1.0.7rc1-2 (binary compatible)
  *    1.0.7                    1    10007  (still compatible)
  *    ...
- *    1.0.19                  10    10019  10.so.0.19[.0]
+ *    1.0.69                  10    10069  10.so.0.69[.0]
+ *    ...
+ *    1.2.59                  13    10259  12.so.0.59[.0]
  *    ...
- *    1.2.56                  13    10256  12.so.0.56[.0]
+ *    1.4.20                  14    10420  14.so.0.20[.0]
  *    ...
- *    1.5.27                  15    10527  15.so.15.27[.0]
+ *    1.5.30                  15    10530  15.so.15.30[.0]
  *    ...
- *    1.6.25                  16    10625  16.so.16.25[.0]
+ *    1.6.40                  16    10640  16.so.16.40[.0]
  *
- *    Henceforth the source version will match the shared-library major
- *    and minor numbers; the shared-library major version number will be
- *    used for changes in backward compatibility, as it is intended.  The
- *    PNG_LIBPNG_VER macro, which is not used within libpng but is available
- *    for applications, is an unsigned integer of the form xyyzz corresponding
- *    to the source version x.y.z (leading zeros in y and z).  Beta versions
- *    were given the previous public release number plus a letter, until
- *    version 1.0.6j; from then on they were given the upcoming public
- *    release number plus "betaNN" or "rcNN".
+ *    Henceforth the source version will match the shared-library major and
+ *    minor numbers; the shared-library major version number will be used for
+ *    changes in backward compatibility, as it is intended.
+ *    The PNG_LIBPNG_VER macro, which is not used within libpng but is
+ *    available for applications, is an unsigned integer of the form XYYZZ
+ *    corresponding to the source version X.Y.Z (leading zeros in Y and Z).
+ *    Beta versions were given the previous public release number plus a
+ *    letter, until version 1.0.6j; from then on they were given the upcoming
+ *    public release number plus "betaNN" or "rcNN".
  *
  *    Binary incompatibility exists only when applications make direct access
  *    to the info_ptr or png_ptr members through png.h, and the compiled
@@ -238,65 +259,8 @@
  *    in binary compatibility (e.g., when a new feature is added).
  *
  * See libpng.txt or libpng.3 for more information.  The PNG specification
- * is available as a W3C Recommendation and as an ISO Specification,
- * <http://www.w3.org/TR/2003/REC-PNG-20031110/
- */
-
-/*
- * Y2K compliance in libpng:
- * =========================
- *
- *    September 1, 2016
- *
- *    Since the PNG Development group is an ad-hoc body, we can't make
- *    an official declaration.
- *
- *    This is your unofficial assurance that libpng from version 0.71 and
- *    upward through 1.6.25 are Y2K compliant.  It is my belief that
- *    earlier versions were also Y2K compliant.
- *
- *    Libpng only has two year fields.  One is a 2-byte unsigned integer
- *    that will hold years up to 65535.  The other, which is deprecated,
- *    holds the date in text format, and will hold years up to 9999.
- *
- *    The integer is
- *        "png_uint_16 year" in png_time_struct.
- *
- *    The string is
- *        "char time_buffer[29]" in png_struct.  This is no longer used
- *    in libpng-1.6.x and will be removed from libpng-1.7.0.
- *
- *    There are seven time-related functions:
- *        png.c: png_convert_to_rfc_1123_buffer() in png.c
- *          (formerly png_convert_to_rfc_1123() prior to libpng-1.5.x and
- *          png_convert_to_rfc_1152() in error prior to libpng-0.98)
- *        png_convert_from_struct_tm() in pngwrite.c, called in pngwrite.c
- *        png_convert_from_time_t() in pngwrite.c
- *        png_get_tIME() in pngget.c
- *        png_handle_tIME() in pngrutil.c, called in pngread.c
- *        png_set_tIME() in pngset.c
- *        png_write_tIME() in pngwutil.c, called in pngwrite.c
- *
- *    All handle dates properly in a Y2K environment.  The
- *    png_convert_from_time_t() function calls gmtime() to convert from system
- *    clock time, which returns (year - 1900), which we properly convert to
- *    the full 4-digit year.  There is a possibility that libpng applications
- *    are not passing 4-digit years into the png_convert_to_rfc_1123_buffer()
- *    function, or that they are incorrectly passing only a 2-digit year
- *    instead of "year - 1900" into the png_convert_from_struct_tm() function,
- *    but this is not under our control.  The libpng documentation has always
- *    stated that it works with 4-digit years, and the APIs have been
- *    documented as such.
- *
- *    The tIME chunk itself is also Y2K compliant.  It uses a 2-byte unsigned
- *    integer to hold the year, and can hold years as large as 65535.
- *
- *    zlib, upon which libpng depends, is also Y2K compliant.  It contains
- *    no date-related code.
- *
- *       Glenn Randers-Pehrson
- *       libpng maintainer
- *       PNG Development Group
+ * is available as a W3C Recommendation and as an ISO/IEC Standard; see
+ * <https://www.w3.org/TR/2003/REC-PNG-20031110/>
  */
 
 #ifndef PNG_H
@@ -314,8 +278,8 @@
  */
 
 /* Version information for png.h - this should match the version in png.c */
-#define PNG_LIBPNG_VER_STRING "1.6.25"
-#define PNG_HEADER_VERSION_STRING " libpng version 1.6.25 - September 1, 2016\n"
+#define PNG_LIBPNG_VER_STRING "1.6.40"
+#define PNG_HEADER_VERSION_STRING " libpng version 1.6.40 - June 21, 2023\n"
 
 #define PNG_LIBPNG_VER_SONUM   16
 #define PNG_LIBPNG_VER_DLLNUM  16
@@ -323,12 +287,11 @@
 /* These should match the first 3 components of PNG_LIBPNG_VER_STRING: */
 #define PNG_LIBPNG_VER_MAJOR   1
 #define PNG_LIBPNG_VER_MINOR   6
-#define PNG_LIBPNG_VER_RELEASE 25
+#define PNG_LIBPNG_VER_RELEASE 40
 
-/* This should match the numeric part of the final component of
- * PNG_LIBPNG_VER_STRING, omitting any leading zero:
+/* This should be zero for a public release, or non-zero for a
+ * development version.  [Deprecated]
  */
-
 #define PNG_LIBPNG_VER_BUILD  0
 
 /* Release Status */
@@ -348,13 +311,14 @@
 
 #define PNG_LIBPNG_BUILD_BASE_TYPE PNG_LIBPNG_BUILD_STABLE
 
-/* Careful here.  At one time, Guy wanted to use 082, but that would be octal.
- * We must not include leading zeros.
- * Versions 0.7 through 1.0.0 were in the range 0 to 100 here (only
- * version 1.0.0 was mis-numbered 100 instead of 10000).  From
- * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release
+/* Careful here.  At one time, Guy wanted to use 082, but that
+ * would be octal.  We must not include leading zeros.
+ * Versions 0.7 through 1.0.0 were in the range 0 to 100 here
+ * (only version 1.0.0 was mis-numbered 100 instead of 10000).
+ * From version 1.0.1 it is:
+ * XXYYZZ, where XX=major, YY=minor, ZZ=release
  */
-#define PNG_LIBPNG_VER 10625 /* 1.6.25 */
+#define PNG_LIBPNG_VER 10640 /* 1.6.40 */
 
 /* Library configuration: these options cannot be changed after
  * the library has been built.
@@ -464,7 +428,7 @@
 /* This triggers a compiler error in png.c, if png.c and png.h
  * do not agree upon the version number.
  */
-typedef char* png_libpng_version_1_6_25;
+typedef char* png_libpng_version_1_6_40;
 
 /* Basic control structions.  Read libpng-manual.txt or libpng.3 for more info.
  *
@@ -605,8 +569,8 @@
    png_charp key;          /* keyword, 1-79 character description of "text" */
    png_charp text;         /* comment, may be an empty string (ie "")
                               or a NULL pointer */
-   png_size_t text_length; /* length of the text string */
-   png_size_t itxt_length; /* length of the itxt string */
+   size_t text_length;     /* length of the text string */
+   size_t itxt_length;     /* length of the itxt string */
    png_charp lang;         /* language code, 0-79 characters
                               or a NULL pointer */
    png_charp lang_key;     /* keyword translated UTF-8 string, 0 or more
@@ -659,7 +623,7 @@
 {
    png_byte name[5]; /* Textual chunk name with '\0' terminator */
    png_byte *data;   /* Data, should not be modified on read! */
-   png_size_t size;
+   size_t size;
 
    /* On write 'location' must be set using the flag values listed below.
     * Notice that on read it is set by libpng however the values stored have
@@ -684,7 +648,7 @@
 /* Maximum positive integer used in PNG is (2^31)-1 */
 #define PNG_UINT_31_MAX ((png_uint_32)0x7fffffffL)
 #define PNG_UINT_32_MAX ((png_uint_32)(-1))
-#define PNG_SIZE_MAX ((png_size_t)(-1))
+#define PNG_SIZE_MAX ((size_t)(-1))
 
 /* These are constants for fixed point values encoded in the
  * PNG specification manner (x100000)
@@ -781,6 +745,7 @@
 #define PNG_INFO_sPLT 0x2000U  /* ESR, 1.0.6 */
 #define PNG_INFO_sCAL 0x4000U  /* ESR, 1.0.6 */
 #define PNG_INFO_IDAT 0x8000U  /* ESR, 1.0.6 */
+#define PNG_INFO_eXIf 0x10000U /* GR-P, 1.6.31 */
 
 /* This is used for the transformation routines, as some of them
  * change these values for the row.  It also should enable using
@@ -789,7 +754,7 @@
 typedef struct png_row_info_struct
 {
    png_uint_32 width;    /* width of row */
-   png_size_t rowbytes;  /* number of bytes in row */
+   size_t rowbytes;      /* number of bytes in row */
    png_byte color_type;  /* color type of row */
    png_byte bit_depth;   /* bit depth of row */
    png_byte channels;    /* number of channels (1, 2, 3, or 4) */
@@ -808,7 +773,7 @@
  * expected to return the read data in the buffer.
  */
 typedef PNG_CALLBACK(void, *png_error_ptr, (png_structp, png_const_charp));
-typedef PNG_CALLBACK(void, *png_rw_ptr, (png_structp, png_bytep, png_size_t));
+typedef PNG_CALLBACK(void, *png_rw_ptr, (png_structp, png_bytep, size_t));
 typedef PNG_CALLBACK(void, *png_flush_ptr, (png_structp));
 typedef PNG_CALLBACK(void, *png_read_status_ptr, (png_structp, png_uint_32,
     int));
@@ -945,8 +910,8 @@
  * signature, and non-zero otherwise.  Having num_to_check == 0 or
  * start > 7 will always fail (ie return non-zero).
  */
-PNG_EXPORT(3, int, png_sig_cmp, (png_const_bytep sig, png_size_t start,
-    png_size_t num_to_check));
+PNG_EXPORT(3, int, png_sig_cmp, (png_const_bytep sig, size_t start,
+    size_t num_to_check));
 
 /* Simple signature checking function.  This is the same as calling
  * png_check_sig(sig, n) := !png_sig_cmp(sig, 0, n).
@@ -965,11 +930,11 @@
     png_error_ptr warn_fn),
     PNG_ALLOCATED);
 
-PNG_EXPORT(6, png_size_t, png_get_compression_buffer_size,
+PNG_EXPORT(6, size_t, png_get_compression_buffer_size,
     (png_const_structrp png_ptr));
 
 PNG_EXPORT(7, void, png_set_compression_buffer_size, (png_structrp png_ptr,
-    png_size_t size));
+    size_t size));
 
 /* Moved from pngconf.h in 1.4.0 and modified to ensure setjmp/longjmp
  * match up.
@@ -1022,7 +987,7 @@
 
 /* Write a PNG chunk - size, type, (optional) data, CRC. */
 PNG_EXPORT(14, void, png_write_chunk, (png_structrp png_ptr, png_const_bytep
-    chunk_name, png_const_bytep data, png_size_t length));
+    chunk_name, png_const_bytep data, size_t length));
 
 /* Write the start of a PNG chunk - length and chunk name. */
 PNG_EXPORT(15, void, png_write_chunk_start, (png_structrp png_ptr,
@@ -1030,7 +995,7 @@
 
 /* Write the data of a PNG chunk started with png_write_chunk_start(). */
 PNG_EXPORT(16, void, png_write_chunk_data, (png_structrp png_ptr,
-    png_const_bytep data, png_size_t length));
+    png_const_bytep data, size_t length));
 
 /* Finish a chunk started with png_write_chunk_start() (includes CRC). */
 PNG_EXPORT(17, void, png_write_chunk_end, (png_structrp png_ptr));
@@ -1044,7 +1009,7 @@
  * the API will be removed in the future.
  */
 PNG_EXPORTA(19, void, png_info_init_3, (png_infopp info_ptr,
-    png_size_t png_info_struct_size), PNG_DEPRECATED);
+    size_t png_info_struct_size), PNG_DEPRECATED);
 
 /* Writes all the PNG information before the image. */
 PNG_EXPORT(20, void, png_write_info_before_PLTE,
@@ -1141,7 +1106,7 @@
  * corresponding composited pixel, and the color channels are unassociated
  * (not premultiplied).  The gamma encoded color channels must be scaled
  * according to the contribution and to do this it is necessary to undo
- * the encoding, scale the color values, perform the composition and reencode
+ * the encoding, scale the color values, perform the composition and re-encode
  * the values.  This is the 'PNG' mode.
  *
  * The alternative is to 'associate' the alpha with the color information by
@@ -1197,7 +1162,7 @@
  *
  * png_set_alpha_mode(pp, PNG_ALPHA_PNG, PNG_GAMMA_MAC);
  *    In this case the output is assumed to be something like an sRGB conformant
- *    display preceeded by a power-law lookup table of power 1.45.  This is how
+ *    display preceded by a power-law lookup table of power 1.45.  This is how
  *    early Mac systems behaved.
  *
  * png_set_alpha_mode(pp, PNG_ALPHA_STANDARD, PNG_GAMMA_LINEAR);
@@ -1244,7 +1209,7 @@
  *
  * When the default gamma of PNG files doesn't match the output gamma.
  *    If you have PNG files with no gamma information png_set_alpha_mode allows
- *    you to provide a default gamma, but it also sets the ouput gamma to the
+ *    you to provide a default gamma, but it also sets the output gamma to the
  *    matching value.  If you know your PNG files have a gamma that doesn't
  *    match the output you can take advantage of the fact that
  *    png_set_alpha_mode always sets the output gamma but only sets the PNG
@@ -1481,7 +1446,7 @@
  * mainly useful for testing, as the defaults should work with most users.
  * Those users who are tight on memory or want faster performance at the
  * expense of compression can modify them.  See the compression library
- * header file (zlib.h) for an explination of the compression functions.
+ * header file (zlib.h) for an explanation of the compression functions.
  */
 
 /* Set the filtering method(s) used by libpng.  Currently, the only valid
@@ -1536,7 +1501,7 @@
  * 0 - 9, corresponding directly to the zlib compression levels 0 - 9
  * (0 - no compression, 9 - "maximal" compression).  Note that tests have
  * shown that zlib compression levels 3-6 usually perform as well as level 9
- * for PNG images, and do considerably fewer caclulations.  In the future,
+ * for PNG images, and do considerably fewer calculations.  In the future,
  * these values may not correspond directly to the zlib compression levels.
  */
 #ifdef PNG_WRITE_CUSTOMIZE_COMPRESSION_SUPPORTED
@@ -1695,7 +1660,7 @@
  *           chunk will cause an error at this point unless it is to be saved.
  * positive: The chunk was handled, libpng will ignore/discard it.
  *
- * See "INTERACTION WTIH USER CHUNK CALLBACKS" below for important notes about
+ * See "INTERACTION WITH USER CHUNK CALLBACKS" below for important notes about
  * how this behavior will change in libpng 1.7
  */
 PNG_EXPORT(88, void, png_set_read_user_chunk_fn, (png_structrp png_ptr,
@@ -1720,7 +1685,7 @@
 
 /* Function to be called when data becomes available */
 PNG_EXPORT(92, void, png_process_data, (png_structrp png_ptr,
-    png_inforp info_ptr, png_bytep buffer, png_size_t buffer_size));
+    png_inforp info_ptr, png_bytep buffer, size_t buffer_size));
 
 /* A function which may be called *only* within png_process_data to stop the
  * processing of any more data.  The function returns the number of bytes
@@ -1729,7 +1694,7 @@
  * 'save' is set to true the routine will first save all the pending data and
  * will always return 0.
  */
-PNG_EXPORT(219, png_size_t, png_process_data_pause, (png_structrp, int save));
+PNG_EXPORT(219, size_t, png_process_data_pause, (png_structrp, int save));
 
 /* A function which may be called *only* outside (after) a call to
  * png_process_data.  It returns the number of bytes of data to skip in the
@@ -1793,7 +1758,8 @@
 #define PNG_FREE_PLTE 0x1000U
 #define PNG_FREE_TRNS 0x2000U
 #define PNG_FREE_TEXT 0x4000U
-#define PNG_FREE_ALL  0x7fffU
+#define PNG_FREE_EXIF 0x8000U /* Added at libpng-1.6.31 */
+#define PNG_FREE_ALL  0xffffU
 #define PNG_FREE_MUL  0x4220U /* PNG_FREE_SPLT|PNG_FREE_TEXT|PNG_FREE_UNKN */
 
 #ifdef PNG_USER_MEM_SUPPORTED
@@ -1873,7 +1839,7 @@
     png_const_inforp info_ptr, png_uint_32 flag));
 
 /* Returns number of bytes needed to hold a transformed row. */
-PNG_EXPORT(111, png_size_t, png_get_rowbytes, (png_const_structrp png_ptr,
+PNG_EXPORT(111, size_t, png_get_rowbytes, (png_const_structrp png_ptr,
     png_const_inforp info_ptr));
 
 #ifdef PNG_INFO_IMAGE_SUPPORTED
@@ -2012,6 +1978,18 @@
     png_fixed_point int_blue_Z))
 #endif
 
+#ifdef PNG_eXIf_SUPPORTED
+PNG_EXPORT(246, png_uint_32, png_get_eXIf, (png_const_structrp png_ptr,
+    png_inforp info_ptr, png_bytep *exif));
+PNG_EXPORT(247, void, png_set_eXIf, (png_const_structrp png_ptr,
+    png_inforp info_ptr, png_bytep exif));
+
+PNG_EXPORT(248, png_uint_32, png_get_eXIf_1, (png_const_structrp png_ptr,
+    png_const_inforp info_ptr, png_uint_32 *num_exif, png_bytep *exif));
+PNG_EXPORT(249, void, png_set_eXIf_1, (png_const_structrp png_ptr,
+    png_inforp info_ptr, png_uint_32 num_exif, png_bytep exif));
+#endif
+
 #ifdef PNG_gAMA_SUPPORTED
 PNG_FP_EXPORT(137, png_uint_32, png_get_gAMA, (png_const_structrp png_ptr,
     png_const_inforp info_ptr, double *file_gamma))
@@ -2030,9 +2008,6 @@
 #ifdef PNG_hIST_SUPPORTED
 PNG_EXPORT(141, png_uint_32, png_get_hIST, (png_const_structrp png_ptr,
     png_inforp info_ptr, png_uint_16p *hist));
-#endif
-
-#ifdef PNG_hIST_SUPPORTED
 PNG_EXPORT(142, void, png_set_hIST, (png_const_structrp png_ptr,
     png_inforp info_ptr, png_const_uint_16p hist));
 #endif
@@ -2233,7 +2208,7 @@
  * to specifying "NEVER", however when "AS_DEFAULT" is used for specific chunks
  * it simply resets the behavior to the libpng default.
  *
- * INTERACTION WTIH USER CHUNK CALLBACKS:
+ * INTERACTION WITH USER CHUNK CALLBACKS:
  * The per-chunk handling is always used when there is a png_user_chunk_ptr
  * callback and the callback returns 0; the chunk is then always stored *unless*
  * it is critical and the per-chunk setting is other than ALWAYS.  Notice that
@@ -2652,7 +2627,7 @@
  * The simplified API hides the details of both libpng and the PNG file format
  * itself.  It allows PNG files to be read into a very limited number of
  * in-memory bitmap formats or to be written from the same formats.  If these
- * formats do not accomodate your needs then you can, and should, use the more
+ * formats do not accommodate your needs then you can, and should, use the more
  * sophisticated APIs above - these support a wide variety of in-memory formats
  * and a wide variety of sophisticated transformations to those formats as well
  * as a wide variety of APIs to manipulate ancillary information.
@@ -2758,7 +2733,7 @@
  *
  * When the simplified API needs to convert between sRGB and linear colorspaces,
  * the actual sRGB transfer curve defined in the sRGB specification (see the
- * article at http://en.wikipedia.org/wiki/SRGB) is used, not the gamma=1/2.2
+ * article at <https://en.wikipedia.org/wiki/SRGB>) is used, not the gamma=1/2.2
  * approximation used elsewhere in libpng.
  *
  * When an alpha channel is present it is expected to denote pixel coverage
@@ -2813,6 +2788,8 @@
 #  define PNG_FORMAT_FLAG_AFIRST 0x20U /* alpha channel comes first */
 #endif
 
+#define PNG_FORMAT_FLAG_ASSOCIATED_ALPHA 0x40U /* alpha channel is associated */
+
 /* Commonly used formats have predefined macros.
  *
  * First the single byte (sRGB) formats:
@@ -2959,7 +2936,7 @@
  * 'flags' field of png_image.
  */
 #define PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB 0x01
-   /* This indicates the the RGB values of the in-memory bitmap do not
+   /* This indicates that the RGB values of the in-memory bitmap do not
     * correspond to the red, green and blue end-points defined by sRGB.
     */
 
@@ -3012,7 +2989,7 @@
 #endif /* STDIO */
 
 PNG_EXPORT(236, int, png_image_begin_read_from_memory, (png_imagep image,
-   png_const_voidp memory, png_size_t size));
+   png_const_voidp memory, size_t size));
    /* The PNG header is read from the given memory buffer. */
 
 PNG_EXPORT(237, int, png_image_finish_read, (png_imagep image,
@@ -3125,7 +3102,7 @@
     * than or equal to the original value.
     *
     * If the function returns false and *memory_bytes was not changed an error
-    * occured during write.  If *memory_bytes was changed, or is not 0 if
+    * occurred during write.  If *memory_bytes was changed, or is not 0 if
     * 'memory' was NULL, the write would have succeeded but for the memory
     * buffer being too small.  *memory_bytes contains the required number of
     * bytes and will be bigger that the original value.
@@ -3209,7 +3186,7 @@
  * option and 'onoff' is 0 (off) or non-0 (on).  The value returned is given
  * by the PNG_OPTION_ defines below.
  *
- * HARDWARE: normally hardware capabilites, such as the Intel SSE instructions,
+ * HARDWARE: normally hardware capabilities, such as the Intel SSE instructions,
  *           are detected at run time, however sometimes it may be impossible
  *           to do this in user mode, in which case it is necessary to discover
  *           the capabilities in an OS specific way.  Such capabilities are
@@ -3230,7 +3207,11 @@
 #ifdef PNG_MIPS_MSA_API_SUPPORTED
 #  define PNG_MIPS_MSA   6 /* HARDWARE: MIPS Msa SIMD instructions supported */
 #endif
-#define PNG_OPTION_NEXT  8 /* Next option - numbers must be even */
+#define PNG_IGNORE_ADLER32 8
+#ifdef PNG_POWERPC_VSX_API_SUPPORTED
+#  define PNG_POWERPC_VSX   10 /* HARDWARE: PowerPC VSX SIMD instructions supported */
+#endif
+#define PNG_OPTION_NEXT  12 /* Next option - numbers must be even */
 
 /* Return values: NOTE: there are four values and 'off' is *not* zero */
 #define PNG_OPTION_UNSET   0 /* Unset - defaults to off */
@@ -3254,7 +3235,7 @@
  * one to use is one more than this.)
  */
 #ifdef PNG_EXPORT_LAST_ORDINAL
-  PNG_EXPORT_LAST_ORDINAL(245);
+  PNG_EXPORT_LAST_ORDINAL(249);
 #endif
 
 #ifdef __cplusplus
Index: indigo-src/indigo/api/c/indigo/src/indigo_macros.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_macros.c b/indigo-src/indigo/api/c/indigo/src/indigo_macros.c
--- a/indigo-src/indigo/api/c/indigo/src/indigo_macros.c	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_macros.c	(date 1690767117645)
@@ -19,7 +19,7 @@
 #include "indigo.h"
 
 #define WRAPPER_LOAD_FROM_STRING(name)                                                                                                                         \
-    CEXPORT int name##FromString(const char* string)                                                                                                           \
+    INDIGO_EXPORT int name##FromString(const char* string)                                                                                                           \
     {                                                                                                                                                          \
         int source = indigoReadString(string);                                                                                                                 \
         int result;                                                                                                                                            \
@@ -33,7 +33,7 @@
     }
 
 #define WRAPPER_LOAD_FROM_FILE(name)                                                                                                                           \
-    CEXPORT int name##FromFile(const char* filename)                                                                                                           \
+    INDIGO_EXPORT int name##FromFile(const char* filename)                                                                                                           \
     {                                                                                                                                                          \
         int source = indigoReadFile(filename);                                                                                                                 \
         int result;                                                                                                                                            \
@@ -47,7 +47,7 @@
     }
 
 #define WRAPPER_LOAD_FROM_BUFFER(name)                                                                                                                         \
-    CEXPORT int name##FromBuffer(const char* buf, int size)                                                                                                    \
+    INDIGO_EXPORT int name##FromBuffer(const char* buf, int size)                                                                                                    \
     {                                                                                                                                                          \
         int source = indigoReadBuffer(buf, size);                                                                                                              \
         int result;                                                                                                                                            \
@@ -84,7 +84,7 @@
 WRAPPER_LOAD_FROM_FILE(indigoLoadReactionSmarts)
 WRAPPER_LOAD_FROM_BUFFER(indigoLoadReactionSmarts)
 
-CEXPORT int indigoSaveMolfileToFile(int molecule, const char* filename)
+INDIGO_EXPORT int indigoSaveMolfileToFile(int molecule, const char* filename)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -98,7 +98,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveJsonToFile(int item, const char* filename)
+INDIGO_EXPORT int indigoSaveJsonToFile(int item, const char* filename)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -112,7 +112,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveCmlToFile(int molecule, const char* filename)
+INDIGO_EXPORT int indigoSaveCmlToFile(int molecule, const char* filename)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -126,7 +126,7 @@
     return res;
 }
 
-CEXPORT const char* indigoMolfile(int molecule)
+INDIGO_EXPORT const char* indigoMolfile(int molecule)
 {
     int b = indigoWriteBuffer();
     const char* res;
@@ -142,7 +142,7 @@
     return res;
 }
 
-CEXPORT const char* indigoCdxBase64(int object)
+INDIGO_EXPORT const char* indigoCdxBase64(int object)
 {
     int b = indigoWriteBuffer();
     const char* res;
@@ -158,7 +158,7 @@
     return res;
 }
 
-CEXPORT const char* indigoCml(int molecule)
+INDIGO_EXPORT const char* indigoCml(int molecule)
 {
     int b = indigoWriteBuffer();
     const char* res;
@@ -174,7 +174,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveRxnfileToFile(int reaction, const char* filename)
+INDIGO_EXPORT int indigoSaveRxnfileToFile(int reaction, const char* filename)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -188,7 +188,7 @@
     return res;
 }
 
-CEXPORT const char* indigoRxnfile(int molecule)
+INDIGO_EXPORT const char* indigoRxnfile(int molecule)
 {
     int b = indigoWriteBuffer();
     const char* res;
@@ -204,7 +204,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveCdxmlToFile(int item, const char* filename)
+INDIGO_EXPORT int indigoSaveCdxmlToFile(int item, const char* filename)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -218,7 +218,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveCdxToFile(int item, const char* filename)
+INDIGO_EXPORT int indigoSaveCdxToFile(int item, const char* filename)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -232,7 +232,7 @@
     return res;
 }
 
-CEXPORT const char* indigoCdxml(int item)
+INDIGO_EXPORT const char* indigoCdxml(int item)
 {
     int b = indigoWriteBuffer();
     const char* res;
Index: libpng-src/libpng/pngpriv.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/pngpriv.h b/libpng-src/libpng/pngpriv.h
--- a/libpng-src/libpng/pngpriv.h	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/pngpriv.h	(date 1690938866074)
@@ -1,10 +1,10 @@
 
 /* pngpriv.h - private declarations for use inside libpng
  *
- * Last changed in libpng 1.6.25 [September 1, 2016]
- * Copyright (c) 1998-2002,2004,2006-2016 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ * Copyright (c) 2018-2023 Cosmin Truta
+ * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson
+ * Copyright (c) 1996-1997 Andreas Dilger
+ * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
@@ -35,7 +35,9 @@
  * Windows/Visual Studio) there is no effect; the OS specific tests below are
  * still required (as of 2011-05-02.)
  */
-#define _POSIX_SOURCE 1 /* Just the POSIX 1003.1 and C89 APIs */
+#ifndef _POSIX_SOURCE
+# define _POSIX_SOURCE 1 /* Just the POSIX 1003.1 and C89 APIs */
+#endif
 
 #ifndef PNG_VERSION_INFO_ONLY
 /* Standard library headers not required by png.h: */
@@ -172,7 +174,10 @@
 #     else /* !defined __ARM_NEON__ */
          /* The 'intrinsics' code simply won't compile without this -mfpu=neon:
           */
-#        define PNG_ARM_NEON_IMPLEMENTATION 2
+#        if !defined(__aarch64__) && !defined(_M_ARM64)
+            /* The assembler code currently does not work on ARM64 */
+#          define PNG_ARM_NEON_IMPLEMENTATION 2
+#        endif /* __aarch64__ */
 #     endif /* __ARM_NEON__ */
 #  endif /* !PNG_ARM_NEON_IMPLEMENTATION */
 
@@ -180,6 +185,8 @@
       /* Use the intrinsics code by default. */
 #     define PNG_ARM_NEON_IMPLEMENTATION 1
 #  endif
+#else /* PNG_ARM_NEON_OPT == 0 */
+#     define PNG_ARM_NEON_IMPLEMENTATION 0
 #endif /* PNG_ARM_NEON_OPT > 0 */
 
 #ifndef PNG_MIPS_MSA_OPT
@@ -189,6 +196,56 @@
 #     define PNG_MIPS_MSA_OPT 0
 #  endif
 #endif
+
+#ifndef PNG_POWERPC_VSX_OPT
+#  if defined(__PPC64__) && defined(__ALTIVEC__) && defined(__VSX__)
+#     define PNG_POWERPC_VSX_OPT 2
+#  else
+#     define PNG_POWERPC_VSX_OPT 0
+#  endif
+#endif
+
+#ifndef PNG_INTEL_SSE_OPT
+#   ifdef PNG_INTEL_SSE
+      /* Only check for SSE if the build configuration has been modified to
+       * enable SSE optimizations.  This means that these optimizations will
+       * be off by default.  See contrib/intel for more details.
+       */
+#     if defined(__SSE4_1__) || defined(__AVX__) || defined(__SSSE3__) || \
+       defined(__SSE2__) || defined(_M_X64) || defined(_M_AMD64) || \
+       (defined(_M_IX86_FP) && _M_IX86_FP >= 2)
+#         define PNG_INTEL_SSE_OPT 1
+#      else
+#         define PNG_INTEL_SSE_OPT 0
+#      endif
+#   else
+#      define PNG_INTEL_SSE_OPT 0
+#   endif
+#endif
+
+#if PNG_INTEL_SSE_OPT > 0
+#   ifndef PNG_INTEL_SSE_IMPLEMENTATION
+#      if defined(__SSE4_1__) || defined(__AVX__)
+          /* We are not actually using AVX, but checking for AVX is the best
+             way we can detect SSE4.1 and SSSE3 on MSVC.
+          */
+#         define PNG_INTEL_SSE_IMPLEMENTATION 3
+#      elif defined(__SSSE3__)
+#         define PNG_INTEL_SSE_IMPLEMENTATION 2
+#      elif defined(__SSE2__) || defined(_M_X64) || defined(_M_AMD64) || \
+       (defined(_M_IX86_FP) && _M_IX86_FP >= 2)
+#         define PNG_INTEL_SSE_IMPLEMENTATION 1
+#      else
+#         define PNG_INTEL_SSE_IMPLEMENTATION 0
+#      endif
+#   endif
+
+#   if PNG_INTEL_SSE_IMPLEMENTATION > 0
+#      define PNG_FILTER_OPTIMIZATIONS png_init_filter_functions_sse2
+#   endif
+#else
+#   define PNG_INTEL_SSE_IMPLEMENTATION 0
+#endif
 
 #if PNG_MIPS_MSA_OPT > 0
 #  define PNG_FILTER_OPTIMIZATIONS png_init_filter_functions_msa
@@ -208,8 +265,17 @@
 #  ifndef PNG_MIPS_MSA_IMPLEMENTATION
 #     define PNG_MIPS_MSA_IMPLEMENTATION 1
 #  endif
+#else
+#  define PNG_MIPS_MSA_IMPLEMENTATION 0
 #endif /* PNG_MIPS_MSA_OPT > 0 */
 
+#if PNG_POWERPC_VSX_OPT > 0
+#  define PNG_FILTER_OPTIMIZATIONS png_init_filter_functions_vsx
+#  define PNG_POWERPC_VSX_IMPLEMENTATION 1
+#else
+#  define PNG_POWERPC_VSX_IMPLEMENTATION 0
+#endif
+
 
 /* Is this a build of a DLL where compilation of the object modules requires
  * different preprocessor settings to those required for a simple library?  If
@@ -256,16 +322,9 @@
  * PNG_IMPEXP must be set here when building the library to prevent pngconf.h
  * setting it to the "import" setting for a DLL build.
  */
-#ifndef PNG_IMPEXP
-#  ifdef PNG_BUILD_DLL
-#     define PNG_IMPEXP PNG_DLL_EXPORT
-#  else
-      /* Not building a DLL, or the DLL doesn't require specific export
-       * definitions.
-       */
-#     define PNG_IMPEXP
+#  ifndef PNG_IMPEXP
+#    define PNG_IMPEXP LIBPNG_EXPORT
 #  endif
-#endif
 
 /* No warnings for private or deprecated functions in the build: */
 #ifndef PNG_DEPRECATED
@@ -325,11 +384,6 @@
 
 #include "png.h"
 
-/* pngconf.h does not set PNG_DLL_EXPORT unless it is required, so: */
-#ifndef PNG_DLL_EXPORT
-#  define PNG_DLL_EXPORT
-#endif
-
 /* This is a global switch to set the compilation for an installed system
  * (a release build).  It can be set for testing debug builds to ensure that
  * they will compile when the build type is switched to RC or STABLE, the
@@ -403,6 +457,21 @@
 #  define png_fixed_error(s1,s2) png_err(s1)
 #endif
 
+/* Some fixed point APIs are still required even if not exported because
+ * they get used by the corresponding floating point APIs.  This magic
+ * deals with this:
+ */
+#ifdef PNG_FIXED_POINT_SUPPORTED
+#  define PNGFAPI PNGAPI
+#else
+#  define PNGFAPI /* PRIVATE */
+#endif
+
+#ifndef PNG_VERSION_INFO_ONLY
+/* Other defines specific to compilers can go here.  Try to keep
+ * them inside an appropriate ifdef/endif pair for portability.
+ */
+
 /* C allows up-casts from (void*) to any pointer and (const void*) to any
  * pointer to a const object.  C++ regards this as a type error and requires an
  * explicit, static, cast and provides the static_cast<> rune to ensure that
@@ -417,25 +486,11 @@
    static_cast<type>(static_cast<const void*>(value))
 #else
 #  define png_voidcast(type, value) (value)
-#  define png_constcast(type, value) ((type)(value))
+#  define png_constcast(type, value) ((type)(void*)(const void*)(value))
 #  define png_aligncast(type, value) ((void*)(value))
 #  define png_aligncastconst(type, value) ((const void*)(value))
 #endif /* __cplusplus */
 
-/* Some fixed point APIs are still required even if not exported because
- * they get used by the corresponding floating point APIs.  This magic
- * deals with this:
- */
-#ifdef PNG_FIXED_POINT_SUPPORTED
-#  define PNGFAPI PNGAPI
-#else
-#  define PNGFAPI /* PRIVATE */
-#endif
-
-#ifndef PNG_VERSION_INFO_ONLY
-/* Other defines specific to compilers can go here.  Try to keep
- * them inside an appropriate ifdef/endif pair for portability.
- */
 #if defined(PNG_FLOATING_POINT_SUPPORTED) ||\
     defined(PNG_FLOATING_ARITHMETIC_SUPPORTED)
    /* png.c requires the following ANSI-C constants if the conversion of
@@ -473,9 +528,8 @@
 #  include <alloc.h>
 #endif
 
-#if defined(WIN32) || defined(_Windows) || defined(_WINDOWS) || \
-    defined(_WIN32) || defined(__WIN32__)
-#  include <windows.h>  /* defines _WINDOWS_ macro */
+#if defined(_WIN32) || defined(__WIN32__) || defined(__NT__)
+#  include <windows.h>
 #endif
 #endif /* PNG_VERSION_INFO_ONLY */
 
@@ -484,24 +538,20 @@
  * functions that are passed far data must be model-independent.
  */
 
-/* Memory model/platform independent fns */
+/* Platform-independent functions */
 #ifndef PNG_ABORT
-#  ifdef _WINDOWS_
-#    define PNG_ABORT() ExitProcess(0)
-#  else
-#    define PNG_ABORT() abort()
-#  endif
+#  define PNG_ABORT() abort()
 #endif
 
 /* These macros may need to be architecture dependent. */
-#define PNG_ALIGN_NONE   0 /* do not use data alignment */
-#define PNG_ALIGN_ALWAYS 1 /* assume unaligned accesses are OK */
+#define PNG_ALIGN_NONE      0 /* do not use data alignment */
+#define PNG_ALIGN_ALWAYS    1 /* assume unaligned accesses are OK */
 #ifdef offsetof
-#  define PNG_ALIGN_OFFSET 2 /* use offsetof to determine alignment */
+#  define PNG_ALIGN_OFFSET  2 /* use offsetof to determine alignment */
 #else
 #  define PNG_ALIGN_OFFSET -1 /* prevent the use of this */
 #endif
-#define PNG_ALIGN_SIZE   3 /* use sizeof to determine alignment */
+#define PNG_ALIGN_SIZE      3 /* use sizeof to determine alignment */
 
 #ifndef PNG_ALIGN_TYPE
    /* Default to using aligned access optimizations and requiring alignment to a
@@ -515,25 +565,25 @@
    /* This is used because in some compiler implementations non-aligned
     * structure members are supported, so the offsetof approach below fails.
     * Set PNG_ALIGN_SIZE=0 for compiler combinations where unaligned access
-    * is good for performance.  Do not do this unless you have tested the result
-    * and understand it.
+    * is good for performance.  Do not do this unless you have tested the
+    * result and understand it.
     */
-#  define png_alignof(type) (sizeof (type))
+#  define png_alignof(type) (sizeof(type))
 #else
 #  if PNG_ALIGN_TYPE == PNG_ALIGN_OFFSET
-#     define png_alignof(type) offsetof(struct{char c; type t;}, t)
+#    define png_alignof(type) offsetof(struct{char c; type t;}, t)
 #  else
-#     if PNG_ALIGN_TYPE == PNG_ALIGN_ALWAYS
-#        define png_alignof(type) (1)
-#     endif
-      /* Else leave png_alignof undefined to prevent use thereof */
+#    if PNG_ALIGN_TYPE == PNG_ALIGN_ALWAYS
+#      define png_alignof(type) 1
+#    endif
+     /* Else leave png_alignof undefined to prevent use thereof */
 #  endif
 #endif
 
-/* This implicitly assumes alignment is always to a power of 2. */
+/* This implicitly assumes alignment is always a multiple of 2. */
 #ifdef png_alignof
-#  define png_isaligned(ptr, type)\
-   ((((const char*)ptr-(const char*)0) & (png_alignof(type)-1)) == 0)
+#  define png_isaligned(ptr, type) \
+   (((type)(size_t)((const void*)(ptr)) & (type)(png_alignof(type)-1)) == 0)
 #else
 #  define png_isaligned(ptr, type) 0
 #endif
@@ -550,92 +600,92 @@
  * are defined in png.h because they need to be visible to applications
  * that call png_set_unknown_chunk().
  */
-/* #define PNG_HAVE_IHDR            0x01 (defined in png.h) */
-/* #define PNG_HAVE_PLTE            0x02 (defined in png.h) */
-#define PNG_HAVE_IDAT               0x04
-/* #define PNG_AFTER_IDAT           0x08 (defined in png.h) */
-#define PNG_HAVE_IEND               0x10
-                   /*               0x20 (unused) */
-                   /*               0x40 (unused) */
-                   /*               0x80 (unused) */
-#define PNG_HAVE_CHUNK_HEADER      0x100
-#define PNG_WROTE_tIME             0x200
-#define PNG_WROTE_INFO_BEFORE_PLTE 0x400
-#define PNG_BACKGROUND_IS_GRAY     0x800
-#define PNG_HAVE_PNG_SIGNATURE    0x1000
-#define PNG_HAVE_CHUNK_AFTER_IDAT 0x2000 /* Have another chunk after IDAT */
-                   /*             0x4000 (unused) */
-#define PNG_IS_READ_STRUCT        0x8000 /* Else is a write struct */
+/* #define PNG_HAVE_IHDR            0x01U (defined in png.h) */
+/* #define PNG_HAVE_PLTE            0x02U (defined in png.h) */
+#define PNG_HAVE_IDAT               0x04U
+/* #define PNG_AFTER_IDAT           0x08U (defined in png.h) */
+#define PNG_HAVE_IEND               0x10U
+                   /*               0x20U (unused) */
+                   /*               0x40U (unused) */
+                   /*               0x80U (unused) */
+#define PNG_HAVE_CHUNK_HEADER      0x100U
+#define PNG_WROTE_tIME             0x200U
+#define PNG_WROTE_INFO_BEFORE_PLTE 0x400U
+#define PNG_BACKGROUND_IS_GRAY     0x800U
+#define PNG_HAVE_PNG_SIGNATURE    0x1000U
+#define PNG_HAVE_CHUNK_AFTER_IDAT 0x2000U /* Have another chunk after IDAT */
+#define PNG_WROTE_eXIf            0x4000U
+#define PNG_IS_READ_STRUCT        0x8000U /* Else is a write struct */
 
 /* Flags for the transformations the PNG library does on the image data */
-#define PNG_BGR                 0x0001
-#define PNG_INTERLACE           0x0002
-#define PNG_PACK                0x0004
-#define PNG_SHIFT               0x0008
-#define PNG_SWAP_BYTES          0x0010
-#define PNG_INVERT_MONO         0x0020
-#define PNG_QUANTIZE            0x0040
-#define PNG_COMPOSE             0x0080     /* Was PNG_BACKGROUND */
-#define PNG_BACKGROUND_EXPAND   0x0100
-#define PNG_EXPAND_16           0x0200     /* Added to libpng 1.5.2 */
-#define PNG_16_TO_8             0x0400     /* Becomes 'chop' in 1.5.4 */
-#define PNG_RGBA                0x0800
-#define PNG_EXPAND              0x1000
-#define PNG_GAMMA               0x2000
-#define PNG_GRAY_TO_RGB         0x4000
-#define PNG_FILLER              0x8000
-#define PNG_PACKSWAP           0x10000
-#define PNG_SWAP_ALPHA         0x20000
-#define PNG_STRIP_ALPHA        0x40000
-#define PNG_INVERT_ALPHA       0x80000
-#define PNG_USER_TRANSFORM    0x100000
-#define PNG_RGB_TO_GRAY_ERR   0x200000
-#define PNG_RGB_TO_GRAY_WARN  0x400000
-#define PNG_RGB_TO_GRAY       0x600000 /* two bits, RGB_TO_GRAY_ERR|WARN */
-#define PNG_ENCODE_ALPHA      0x800000 /* Added to libpng-1.5.4 */
-#define PNG_ADD_ALPHA        0x1000000 /* Added to libpng-1.2.7 */
-#define PNG_EXPAND_tRNS      0x2000000 /* Added to libpng-1.2.9 */
-#define PNG_SCALE_16_TO_8    0x4000000 /* Added to libpng-1.5.4 */
-                       /*    0x8000000 unused */
-                       /*   0x10000000 unused */
-                       /*   0x20000000 unused */
-                       /*   0x40000000 unused */
+#define PNG_BGR                 0x0001U
+#define PNG_INTERLACE           0x0002U
+#define PNG_PACK                0x0004U
+#define PNG_SHIFT               0x0008U
+#define PNG_SWAP_BYTES          0x0010U
+#define PNG_INVERT_MONO         0x0020U
+#define PNG_QUANTIZE            0x0040U
+#define PNG_COMPOSE             0x0080U    /* Was PNG_BACKGROUND */
+#define PNG_BACKGROUND_EXPAND   0x0100U
+#define PNG_EXPAND_16           0x0200U    /* Added to libpng 1.5.2 */
+#define PNG_16_TO_8             0x0400U    /* Becomes 'chop' in 1.5.4 */
+#define PNG_RGBA                0x0800U
+#define PNG_EXPAND              0x1000U
+#define PNG_GAMMA               0x2000U
+#define PNG_GRAY_TO_RGB         0x4000U
+#define PNG_FILLER              0x8000U
+#define PNG_PACKSWAP           0x10000U
+#define PNG_SWAP_ALPHA         0x20000U
+#define PNG_STRIP_ALPHA        0x40000U
+#define PNG_INVERT_ALPHA       0x80000U
+#define PNG_USER_TRANSFORM    0x100000U
+#define PNG_RGB_TO_GRAY_ERR   0x200000U
+#define PNG_RGB_TO_GRAY_WARN  0x400000U
+#define PNG_RGB_TO_GRAY       0x600000U /* two bits, RGB_TO_GRAY_ERR|WARN */
+#define PNG_ENCODE_ALPHA      0x800000U /* Added to libpng-1.5.4 */
+#define PNG_ADD_ALPHA        0x1000000U /* Added to libpng-1.2.7 */
+#define PNG_EXPAND_tRNS      0x2000000U /* Added to libpng-1.2.9 */
+#define PNG_SCALE_16_TO_8    0x4000000U /* Added to libpng-1.5.4 */
+                       /*    0x8000000U unused */
+                       /*   0x10000000U unused */
+                       /*   0x20000000U unused */
+                       /*   0x40000000U unused */
 /* Flags for png_create_struct */
-#define PNG_STRUCT_PNG   0x0001
-#define PNG_STRUCT_INFO  0x0002
+#define PNG_STRUCT_PNG   0x0001U
+#define PNG_STRUCT_INFO  0x0002U
 
 /* Flags for the png_ptr->flags rather than declaring a byte for each one */
-#define PNG_FLAG_ZLIB_CUSTOM_STRATEGY     0x0001
-#define PNG_FLAG_ZSTREAM_INITIALIZED      0x0002 /* Added to libpng-1.6.0 */
-                                  /*      0x0004    unused */
-#define PNG_FLAG_ZSTREAM_ENDED            0x0008 /* Added to libpng-1.6.0 */
-                                  /*      0x0010    unused */
-                                  /*      0x0020    unused */
-#define PNG_FLAG_ROW_INIT                 0x0040
-#define PNG_FLAG_FILLER_AFTER             0x0080
-#define PNG_FLAG_CRC_ANCILLARY_USE        0x0100
-#define PNG_FLAG_CRC_ANCILLARY_NOWARN     0x0200
-#define PNG_FLAG_CRC_CRITICAL_USE         0x0400
-#define PNG_FLAG_CRC_CRITICAL_IGNORE      0x0800
-#define PNG_FLAG_ASSUME_sRGB              0x1000 /* Added to libpng-1.5.4 */
-#define PNG_FLAG_OPTIMIZE_ALPHA           0x2000 /* Added to libpng-1.5.4 */
-#define PNG_FLAG_DETECT_UNINITIALIZED     0x4000 /* Added to libpng-1.5.4 */
-/* #define PNG_FLAG_KEEP_UNKNOWN_CHUNKS      0x8000 */
-/* #define PNG_FLAG_KEEP_UNSAFE_CHUNKS      0x10000 */
-#define PNG_FLAG_LIBRARY_MISMATCH        0x20000
-#define PNG_FLAG_STRIP_ERROR_NUMBERS     0x40000
-#define PNG_FLAG_STRIP_ERROR_TEXT        0x80000
-#define PNG_FLAG_BENIGN_ERRORS_WARN     0x100000 /* Added to libpng-1.4.0 */
-#define PNG_FLAG_APP_WARNINGS_WARN      0x200000 /* Added to libpng-1.6.0 */
-#define PNG_FLAG_APP_ERRORS_WARN        0x400000 /* Added to libpng-1.6.0 */
-                                  /*    0x800000    unused */
-                                  /*   0x1000000    unused */
-                                  /*   0x2000000    unused */
-                                  /*   0x4000000    unused */
-                                  /*   0x8000000    unused */
-                                  /*  0x10000000    unused */
-                                  /*  0x20000000    unused */
-                                  /*  0x40000000    unused */
+#define PNG_FLAG_ZLIB_CUSTOM_STRATEGY     0x0001U
+#define PNG_FLAG_ZSTREAM_INITIALIZED      0x0002U /* Added to libpng-1.6.0 */
+                                  /*      0x0004U    unused */
+#define PNG_FLAG_ZSTREAM_ENDED            0x0008U /* Added to libpng-1.6.0 */
+                                  /*      0x0010U    unused */
+                                  /*      0x0020U    unused */
+#define PNG_FLAG_ROW_INIT                 0x0040U
+#define PNG_FLAG_FILLER_AFTER             0x0080U
+#define PNG_FLAG_CRC_ANCILLARY_USE        0x0100U
+#define PNG_FLAG_CRC_ANCILLARY_NOWARN     0x0200U
+#define PNG_FLAG_CRC_CRITICAL_USE         0x0400U
+#define PNG_FLAG_CRC_CRITICAL_IGNORE      0x0800U
+#define PNG_FLAG_ASSUME_sRGB              0x1000U /* Added to libpng-1.5.4 */
+#define PNG_FLAG_OPTIMIZE_ALPHA           0x2000U /* Added to libpng-1.5.4 */
+#define PNG_FLAG_DETECT_UNINITIALIZED     0x4000U /* Added to libpng-1.5.4 */
+/* #define PNG_FLAG_KEEP_UNKNOWN_CHUNKS      0x8000U */
+/* #define PNG_FLAG_KEEP_UNSAFE_CHUNKS      0x10000U */
+#define PNG_FLAG_LIBRARY_MISMATCH        0x20000U
+#define PNG_FLAG_STRIP_ERROR_NUMBERS     0x40000U
+#define PNG_FLAG_STRIP_ERROR_TEXT        0x80000U
+#define PNG_FLAG_BENIGN_ERRORS_WARN     0x100000U /* Added to libpng-1.4.0 */
+#define PNG_FLAG_APP_WARNINGS_WARN      0x200000U /* Added to libpng-1.6.0 */
+#define PNG_FLAG_APP_ERRORS_WARN        0x400000U /* Added to libpng-1.6.0 */
+                                  /*    0x800000U    unused */
+                                  /*   0x1000000U    unused */
+                                  /*   0x2000000U    unused */
+                                  /*   0x4000000U    unused */
+                                  /*   0x8000000U    unused */
+                                  /*  0x10000000U    unused */
+                                  /*  0x20000000U    unused */
+                                  /*  0x40000000U    unused */
 
 #define PNG_FLAG_CRC_ANCILLARY_MASK (PNG_FLAG_CRC_ANCILLARY_USE | \
                                      PNG_FLAG_CRC_ANCILLARY_NOWARN)
@@ -666,8 +716,26 @@
 /* Added to libpng-1.2.6 JB */
 #define PNG_ROWBYTES(pixel_bits, width) \
     ((pixel_bits) >= 8 ? \
-    ((png_size_t)(width) * (((png_size_t)(pixel_bits)) >> 3)) : \
-    (( ((png_size_t)(width) * ((png_size_t)(pixel_bits))) + 7) >> 3) )
+    ((size_t)(width) * (((size_t)(pixel_bits)) >> 3)) : \
+    (( ((size_t)(width) * ((size_t)(pixel_bits))) + 7) >> 3) )
+
+/* This returns the number of trailing bits in the last byte of a row, 0 if the
+ * last byte is completely full of pixels.  It is, in principle, (pixel_bits x
+ * width) % 8, but that would overflow for large 'width'.  The second macro is
+ * the same except that it returns the number of unused bits in the last byte;
+ * (8-TRAILBITS), but 0 when TRAILBITS is 0.
+ *
+ * NOTE: these macros are intended to be self-evidently correct and never
+ * overflow on the assumption that pixel_bits is in the range 0..255.  The
+ * arguments are evaluated only once and they can be signed (e.g. as a result of
+ * the integral promotions).  The result of the expression always has type
+ * (png_uint_32), however the compiler always knows it is in the range 0..7.
+ */
+#define PNG_TRAILBITS(pixel_bits, width) \
+    (((pixel_bits) * ((width) % (png_uint_32)8)) % 8)
+
+#define PNG_PADBITS(pixel_bits, width) \
+    ((8 - PNG_TRAILBITS(pixel_bits, width)) % 8)
 
 /* PNG_OUT_OF_RANGE returns true if value is outside the range
  * ideal-delta..ideal+delta.  Each argument is evaluated twice.
@@ -762,6 +830,7 @@
 #define png_PLTE PNG_U32( 80,  76,  84,  69)
 #define png_bKGD PNG_U32( 98,  75,  71,  68)
 #define png_cHRM PNG_U32( 99,  72,  82,  77)
+#define png_eXIf PNG_U32(101,  88,  73, 102) /* registered July 2017 */
 #define png_fRAc PNG_U32(102,  82,  65,  99) /* registered, not defined */
 #define png_gAMA PNG_U32(103,  65,  77,  65)
 #define png_gIFg PNG_U32(103,  73,  70, 103)
@@ -836,7 +905,7 @@
     * PNG files the -I directives must match.
     *
     * The most likely explanation is that you passed a -I in CFLAGS. This will
-    * not work; all the preprocessor directories and in particular all the -I
+    * not work; all the preprocessor directives and in particular all the -I
     * directives must be in CPPFLAGS.
     */
 #endif
@@ -965,15 +1034,15 @@
  */
 
 PNG_INTERNAL_FUNCTION(void PNGCBAPI,png_default_read_data,(png_structp png_ptr,
-    png_bytep data, png_size_t length),PNG_EMPTY);
+    png_bytep data, size_t length),PNG_EMPTY);
 
 #ifdef PNG_PROGRESSIVE_READ_SUPPORTED
 PNG_INTERNAL_FUNCTION(void PNGCBAPI,png_push_fill_buffer,(png_structp png_ptr,
-    png_bytep buffer, png_size_t length),PNG_EMPTY);
+    png_bytep buffer, size_t length),PNG_EMPTY);
 #endif
 
 PNG_INTERNAL_FUNCTION(void PNGCBAPI,png_default_write_data,(png_structp png_ptr,
-    png_bytep data, png_size_t length),PNG_EMPTY);
+    png_bytep data, size_t length),PNG_EMPTY);
 
 #ifdef PNG_WRITE_FLUSH_SUPPORTED
 #  ifdef PNG_STDIO_SUPPORTED
@@ -987,7 +1056,7 @@
 
 /* Write the "data" buffer to whatever output you are using */
 PNG_INTERNAL_FUNCTION(void,png_write_data,(png_structrp png_ptr,
-    png_const_bytep data, png_size_t length),PNG_EMPTY);
+    png_const_bytep data, size_t length),PNG_EMPTY);
 
 /* Read and check the PNG file signature */
 PNG_INTERNAL_FUNCTION(void,png_read_sig,(png_structrp png_ptr,
@@ -999,7 +1068,7 @@
 
 /* Read data from whatever input you are using into the "data" buffer */
 PNG_INTERNAL_FUNCTION(void,png_read_data,(png_structrp png_ptr, png_bytep data,
-    png_size_t length),PNG_EMPTY);
+    size_t length),PNG_EMPTY);
 
 /* Read bytes into buf, and update png_ptr->crc */
 PNG_INTERNAL_FUNCTION(void,png_crc_read,(png_structrp png_ptr, png_bytep buf,
@@ -1017,7 +1086,7 @@
  * since this is the maximum buffer size we can specify.
  */
 PNG_INTERNAL_FUNCTION(void,png_calculate_crc,(png_structrp png_ptr,
-   png_const_bytep ptr, png_size_t length),PNG_EMPTY);
+   png_const_bytep ptr, size_t length),PNG_EMPTY);
 
 #ifdef PNG_WRITE_FLUSH_SUPPORTED
 PNG_INTERNAL_FUNCTION(void,png_flush,(png_structrp png_ptr),PNG_EMPTY);
@@ -1061,6 +1130,11 @@
 PNG_INTERNAL_FUNCTION(void,png_write_sRGB,(png_structrp png_ptr,
     int intent),PNG_EMPTY);
 #endif
+
+#ifdef PNG_WRITE_eXIf_SUPPORTED
+PNG_INTERNAL_FUNCTION(void,png_write_eXIf,(png_structrp png_ptr,
+    png_bytep exif, int num_exif),PNG_EMPTY);
+#endif
 
 #ifdef PNG_WRITE_iCCP_SUPPORTED
 PNG_INTERNAL_FUNCTION(void,png_write_iCCP,(png_structrp png_ptr,
@@ -1095,7 +1169,7 @@
 /* Chunks that have keywords */
 #ifdef PNG_WRITE_tEXt_SUPPORTED
 PNG_INTERNAL_FUNCTION(void,png_write_tEXt,(png_structrp png_ptr,
-   png_const_charp key, png_const_charp text, png_size_t text_len),PNG_EMPTY);
+   png_const_charp key, png_const_charp text, size_t text_len),PNG_EMPTY);
 #endif
 
 #ifdef PNG_WRITE_zTXt_SUPPORTED
@@ -1237,6 +1311,38 @@
     row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
 #endif
 
+#if PNG_POWERPC_VSX_OPT > 0
+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_up_vsx,(png_row_infop row_info,
+    png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_sub3_vsx,(png_row_infop
+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_sub4_vsx,(png_row_infop
+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_avg3_vsx,(png_row_infop
+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_avg4_vsx,(png_row_infop
+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_paeth3_vsx,(png_row_infop
+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_paeth4_vsx,(png_row_infop
+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
+#endif
+
+#if PNG_INTEL_SSE_IMPLEMENTATION > 0
+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_sub3_sse2,(png_row_infop
+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_sub4_sse2,(png_row_infop
+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_avg3_sse2,(png_row_infop
+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_avg4_sse2,(png_row_infop
+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_paeth3_sse2,(png_row_infop
+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_paeth4_sse2,(png_row_infop
+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);
+#endif
+
 /* Choose the best filter to use and filter the row data */
 PNG_INTERNAL_FUNCTION(void,png_write_find_filter,(png_structrp png_ptr,
     png_row_infop row_info),PNG_EMPTY);
@@ -1263,7 +1369,7 @@
 /* Initialize the row buffers, etc. */
 PNG_INTERNAL_FUNCTION(void,png_read_start_row,(png_structrp png_ptr),PNG_EMPTY);
 
-#if PNG_ZLIB_VERNUM >= 0x1240
+#if ZLIB_VERNUM >= 0x1240
 PNG_INTERNAL_FUNCTION(int,png_zlib_inflate,(png_structrp png_ptr, int flush),
       PNG_EMPTY);
 #  define PNG_INFLATE(pp, flush) png_zlib_inflate(pp, flush)
@@ -1329,6 +1435,11 @@
     png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
 #endif
 
+#ifdef PNG_READ_eXIf_SUPPORTED
+PNG_INTERNAL_FUNCTION(void,png_handle_eXIf,(png_structrp png_ptr,
+    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
+#endif
+
 #ifdef PNG_READ_gAMA_SUPPORTED
 PNG_INTERNAL_FUNCTION(void,png_handle_gAMA,(png_structrp png_ptr,
     png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
@@ -1404,9 +1515,12 @@
     png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);
 #endif
 
-PNG_INTERNAL_FUNCTION(void,png_check_chunk_name,(png_structrp png_ptr,
+PNG_INTERNAL_FUNCTION(void,png_check_chunk_name,(png_const_structrp png_ptr,
     png_uint_32 chunk_name),PNG_EMPTY);
 
+PNG_INTERNAL_FUNCTION(void,png_check_chunk_length,(png_const_structrp png_ptr,
+    png_uint_32 chunk_length),PNG_EMPTY);
+
 PNG_INTERNAL_FUNCTION(void,png_handle_unknown,(png_structrp png_ptr,
     png_inforp info_ptr, png_uint_32 length, int keep),PNG_EMPTY);
    /* This is the function that gets called for unknown chunks.  The 'keep'
@@ -1448,10 +1562,10 @@
 PNG_INTERNAL_FUNCTION(void,png_push_save_buffer,(png_structrp png_ptr),
     PNG_EMPTY);
 PNG_INTERNAL_FUNCTION(void,png_push_restore_buffer,(png_structrp png_ptr,
-    png_bytep buffer, png_size_t buffer_length),PNG_EMPTY);
+    png_bytep buffer, size_t buffer_length),PNG_EMPTY);
 PNG_INTERNAL_FUNCTION(void,png_push_read_IDAT,(png_structrp png_ptr),PNG_EMPTY);
 PNG_INTERNAL_FUNCTION(void,png_process_IDAT_data,(png_structrp png_ptr,
-    png_bytep buffer, png_size_t buffer_length),PNG_EMPTY);
+    png_bytep buffer, size_t buffer_length),PNG_EMPTY);
 PNG_INTERNAL_FUNCTION(void,png_push_process_row,(png_structrp png_ptr),
     PNG_EMPTY);
 PNG_INTERNAL_FUNCTION(void,png_push_handle_unknown,(png_structrp png_ptr,
@@ -1721,13 +1835,13 @@
 
 #ifdef PNG_FLOATING_POINT_SUPPORTED
 PNG_INTERNAL_FUNCTION(void,png_ascii_from_fp,(png_const_structrp png_ptr,
-   png_charp ascii, png_size_t size, double fp, unsigned int precision),
+   png_charp ascii, size_t size, double fp, unsigned int precision),
    PNG_EMPTY);
 #endif /* FLOATING_POINT */
 
 #ifdef PNG_FIXED_POINT_SUPPORTED
 PNG_INTERNAL_FUNCTION(void,png_ascii_from_fixed,(png_const_structrp png_ptr,
-   png_charp ascii, png_size_t size, png_fixed_point fp),PNG_EMPTY);
+   png_charp ascii, size_t size, png_fixed_point fp),PNG_EMPTY);
 #endif /* FIXED_POINT */
 #endif /* sCAL */
 
@@ -1784,7 +1898,7 @@
  */
 #define PNG_FP_INVALID  512  /* Available for callers as a distinct value */
 
-/* Result codes for the parser (boolean - true meants ok, false means
+/* Result codes for the parser (boolean - true means ok, false means
  * not ok yet.)
  */
 #define PNG_FP_MAYBE      0  /* The number may be valid in the future */
@@ -1820,7 +1934,7 @@
  * the problem character.)  This has not been tested within libpng.
  */
 PNG_INTERNAL_FUNCTION(int,png_check_fp_number,(png_const_charp string,
-   png_size_t size, int *statep, png_size_tp whereami),PNG_EMPTY);
+   size_t size, int *statep, size_t *whereami),PNG_EMPTY);
 
 /* This is the same but it checks a complete string and returns true
  * only if it just contains a floating point number.  As of 1.5.4 this
@@ -1829,7 +1943,7 @@
  * for negative or zero values using the sticky flag.
  */
 PNG_INTERNAL_FUNCTION(int,png_check_fp_string,(png_const_charp string,
-   png_size_t size),PNG_EMPTY);
+   size_t size),PNG_EMPTY);
 #endif /* pCAL || sCAL */
 
 #if defined(PNG_GAMMA_SUPPORTED) ||\
@@ -1904,7 +2018,7 @@
    png_voidp   error_buf;           /* Always a jmp_buf at present. */
 
    png_const_bytep memory;          /* Memory buffer. */
-   png_size_t      size;            /* Size of the memory buffer. */
+   size_t          size;            /* Size of the memory buffer. */
 
    unsigned int for_write       :1; /* Otherwise it is a read structure */
    unsigned int owned_file      :1; /* We own the file in io_ptr */
@@ -1972,11 +2086,39 @@
 PNG_INTERNAL_FUNCTION(void, png_init_filter_functions_msa,
    (png_structp png_ptr, unsigned int bpp), PNG_EMPTY);
 #endif
+
+#  if PNG_INTEL_SSE_IMPLEMENTATION > 0
+PNG_INTERNAL_FUNCTION(void, png_init_filter_functions_sse2,
+   (png_structp png_ptr, unsigned int bpp), PNG_EMPTY);
+#  endif
 #endif
 
 PNG_INTERNAL_FUNCTION(png_uint_32, png_check_keyword, (png_structrp png_ptr,
    png_const_charp key, png_bytep new_key), PNG_EMPTY);
 
+#if PNG_ARM_NEON_IMPLEMENTATION == 1
+PNG_INTERNAL_FUNCTION(void,
+                      png_riffle_palette_neon,
+                      (png_structrp),
+                      PNG_EMPTY);
+PNG_INTERNAL_FUNCTION(int,
+                      png_do_expand_palette_rgba8_neon,
+                      (png_structrp,
+                       png_row_infop,
+                       png_const_bytep,
+                       const png_bytepp,
+                       const png_bytepp),
+                      PNG_EMPTY);
+PNG_INTERNAL_FUNCTION(int,
+                      png_do_expand_palette_rgb8_neon,
+                      (png_structrp,
+                       png_row_infop,
+                       png_const_bytep,
+                       const png_bytepp,
+                       const png_bytepp),
+                      PNG_EMPTY);
+#endif
+
 /* Maintainer: Put new private prototypes here ^ */
 
 #include "pngdebug.h"
Index: indigo-src/indigo/api/c/indigo/src/indigo_molecule.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_molecule.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_molecule.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_molecule.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_molecule.cpp	(date 1690767117645)
@@ -470,7 +470,7 @@
     return new IndigoBond(_mol, _idx);
 }
 
-CEXPORT int indigoLoadMolecule(int source)
+int indigoLoadMolecule(int source)
 {
     INDIGO_BEGIN
     {
@@ -501,7 +501,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadQueryMolecule(int source)
+int indigoLoadQueryMolecule(int source)
 {
     INDIGO_BEGIN
     {
@@ -525,7 +525,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadSmarts(int source)
+int indigoLoadSmarts(int source)
 {
     INDIGO_BEGIN
     {
@@ -551,7 +551,7 @@
     return isIn(string, ">>") || startWith(string, "$RXN") || isIn(string, "<reactantList>");
 }
 
-CEXPORT int indigoLoadStructureFromString(const char* string, const char* params)
+int indigoLoadStructureFromString(const char* string, const char* params)
 {
     INDIGO_BEGIN
     {
@@ -604,7 +604,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadStructureFromBuffer(const byte* buff, int bufferSize, const char* params)
+int indigoLoadStructureFromBuffer(const byte* buff, int bufferSize, const char* params)
 {
     BufferScanner scanner(buff, bufferSize);
     Array<char> arr;
@@ -613,7 +613,7 @@
     return indigoLoadStructureFromString(arr.ptr(), params);
 }
 
-CEXPORT int indigoLoadStructureFromFile(const char* filename, const char* params)
+int indigoLoadStructureFromFile(const char* filename, const char* params)
 {
     INDIGO_BEGIN
     {
@@ -735,7 +735,7 @@
     return self.addObject(new IndigoAtomsIter(&self.getObject(molecule).getBaseMolecule(), type));
 }
 
-CEXPORT int indigoIterateAtoms(int molecule)
+int indigoIterateAtoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -782,7 +782,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateBonds(int molecule)
+int indigoIterateBonds(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -829,7 +829,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountAtoms(int molecule)
+int indigoCountAtoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -863,7 +863,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountBonds(int molecule)
+int indigoCountBonds(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -897,7 +897,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountPseudoatoms(int molecule)
+int indigoCountPseudoatoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -913,7 +913,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountRSites(int molecule)
+int indigoCountRSites(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -929,7 +929,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIteratePseudoatoms(int molecule)
+int indigoIteratePseudoatoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -938,7 +938,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateRSites(int molecule)
+int indigoIterateRSites(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -947,7 +947,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateStereocenters(int molecule)
+int indigoIterateStereocenters(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -956,7 +956,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateAlleneCenters(int molecule)
+int indigoIterateAlleneCenters(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -965,7 +965,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoSymbol(int atom)
+const char* indigoSymbol(int atom)
 {
     INDIGO_BEGIN
     {
@@ -978,7 +978,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoIsPseudoatom(int atom)
+int indigoIsPseudoatom(int atom)
 {
     INDIGO_BEGIN
     {
@@ -991,7 +991,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIsRSite(int atom)
+int indigoIsRSite(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1004,7 +1004,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIsTemplateAtom(int atom)
+int indigoIsTemplateAtom(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1017,7 +1017,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSingleAllowedRGroup(int rsite)
+int indigoSingleAllowedRGroup(int rsite)
 {
     INDIGO_BEGIN
     {
@@ -1058,7 +1058,7 @@
 {
 }
 
-CEXPORT int indigoIterateRGroups(int molecule)
+int indigoIterateRGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1173,7 +1173,7 @@
     return new IndigoRGroupFragment(_mol, _rgroup_idx, _frag_idx);
 }
 
-CEXPORT int indigoIterateRGroupFragments(int rgroup)
+int indigoIterateRGroupFragments(int rgroup)
 {
     INDIGO_BEGIN
     {
@@ -1183,7 +1183,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountRGroups(int molecule)
+int indigoCountRGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1223,7 +1223,7 @@
     return rgroup.release();
 }
 
-CEXPORT int indigoCountAttachmentPoints(int rgroup)
+int indigoCountAttachmentPoints(int rgroup)
 {
     INDIGO_BEGIN
     {
@@ -1238,7 +1238,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDegree(int atom)
+int indigoDegree(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1249,7 +1249,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetCharge(int atom, int* charge)
+int indigoGetCharge(int atom, int* charge)
 {
     INDIGO_BEGIN
     {
@@ -1266,7 +1266,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoValence(int atom)
+int indigoValence(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1276,7 +1276,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetHybridization(int atom)
+int indigoGetHybridization(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1287,7 +1287,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCheckValence(int atom)
+int indigoCheckValence(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1303,7 +1303,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetExplicitValence(int atom, int* valence)
+int indigoGetExplicitValence(int atom, int* valence)
 {
     INDIGO_BEGIN
     {
@@ -1320,7 +1320,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetExplicitValence(int atom, int valence)
+int indigoSetExplicitValence(int atom, int valence)
 {
     INDIGO_BEGIN
     {
@@ -1331,7 +1331,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIsotope(int atom)
+int indigoIsotope(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1342,7 +1342,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAtomicNumber(int atom)
+int indigoAtomicNumber(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1359,7 +1359,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetRadicalElectrons(int atom, int* electrons)
+int indigoGetRadicalElectrons(int atom, int* electrons)
 {
     INDIGO_BEGIN
     {
@@ -1411,7 +1411,7 @@
     }
 }
 
-CEXPORT int indigoGetRadical(int atom, int* radical)
+int indigoGetRadical(int atom, int* radical)
 {
     INDIGO_BEGIN
     {
@@ -1429,7 +1429,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetRadical(int atom, int radical)
+int indigoSetRadical(int atom, int radical)
 {
     INDIGO_BEGIN
     {
@@ -1440,7 +1440,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT float* indigoXYZ(int atom)
+float* indigoXYZ(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1457,7 +1457,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoSetXYZ(int atom, float x, float y, float z)
+int indigoSetXYZ(int atom, float x, float y, float z)
 {
     INDIGO_BEGIN
     {
@@ -1471,7 +1471,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoResetCharge(int atom)
+int indigoResetCharge(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1487,7 +1487,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetExplicitValence(int atom)
+int indigoResetExplicitValence(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1503,7 +1503,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetRadical(int atom)
+int indigoResetRadical(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1519,7 +1519,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetIsotope(int atom)
+int indigoResetIsotope(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1535,7 +1535,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetRsite(int atom)
+int indigoResetRsite(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1548,7 +1548,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetAttachmentPoint(int atom, int order)
+int indigoSetAttachmentPoint(int atom, int order)
 {
     INDIGO_BEGIN
     {
@@ -1560,7 +1560,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearAttachmentPoints(int item)
+int indigoClearAttachmentPoints(int item)
 {
     INDIGO_BEGIN
     {
@@ -1571,7 +1571,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRemoveConstraints(int item, const char* str_type)
+int indigoRemoveConstraints(int item, const char* str_type)
 {
     INDIGO_BEGIN
     {
@@ -1595,7 +1595,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddConstraint(int atom, const char* type, const char* value)
+int indigoAddConstraint(int atom, const char* type, const char* value)
 {
     INDIGO_BEGIN
     {
@@ -1614,7 +1614,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddConstraintNot(int atom, const char* type, const char* value)
+int indigoAddConstraintNot(int atom, const char* type, const char* value)
 {
     INDIGO_BEGIN
     {
@@ -1633,7 +1633,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddConstraintOr(int atom, const char* type, const char* value)
+int indigoAddConstraintOr(int atom, const char* type, const char* value)
 {
     INDIGO_BEGIN
     {
@@ -1653,7 +1653,7 @@
 }
 
 /*
-CEXPORT int indigoAddConstraintOrNot(int atom, const char* type, const char* value)
+int indigoAddConstraintOrNot(int atom, const char* type, const char* value)
 {
    INDIGO_BEGIN
    {
@@ -1673,7 +1673,7 @@
 }
  * */
 
-CEXPORT const int* indigoSymmetryClasses(int molecule, int* count_out)
+const int* indigoSymmetryClasses(int molecule, int* count_out)
 {
     INDIGO_BEGIN
     {
@@ -1711,7 +1711,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoLayeredCode(int molecule)
+const char* indigoLayeredCode(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1729,7 +1729,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoCreateSubmolecule(int molecule, int nvertices, int* vertices)
+int indigoCreateSubmolecule(int molecule, int nvertices, int* vertices)
 {
     INDIGO_BEGIN
     {
@@ -1757,7 +1757,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSubmolecule(int molecule, int nvertices, int* vertices)
+int indigoGetSubmolecule(int molecule, int nvertices, int* vertices)
 {
     INDIGO_BEGIN
     {
@@ -1786,7 +1786,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateEdgeSubmolecule(int molecule, int nvertices, int* vertices, int nedges, int* edges)
+int indigoCreateEdgeSubmolecule(int molecule, int nvertices, int* vertices, int nedges, int* edges)
 {
     INDIGO_BEGIN
     {
@@ -1816,7 +1816,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRemoveAtoms(int molecule, int nvertices, int* vertices)
+int indigoRemoveAtoms(int molecule, int nvertices, int* vertices)
 {
     INDIGO_BEGIN
     {
@@ -1831,7 +1831,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRemoveBonds(int molecule, int nbonds, int* bonds)
+int indigoRemoveBonds(int molecule, int nbonds, int* bonds)
 {
     INDIGO_BEGIN
     {
@@ -1879,7 +1879,7 @@
     return _nei_counters;
 }
 
-CEXPORT int indigoIsChiral(int molecule)
+int indigoIsChiral(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1889,7 +1889,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoBondOrder(int bond)
+int indigoBondOrder(int bond)
 {
     INDIGO_BEGIN
     {
@@ -1901,7 +1901,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoTopology(int bond)
+int indigoTopology(int bond)
 {
     INDIGO_BEGIN
     {
@@ -1917,7 +1917,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetAtom(int molecule, int idx)
+int indigoGetAtom(int molecule, int idx)
 {
     INDIGO_BEGIN
     {
@@ -1928,7 +1928,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetBond(int molecule, int idx)
+int indigoGetBond(int molecule, int idx)
 {
     INDIGO_BEGIN
     {
@@ -1939,7 +1939,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSource(int bond)
+int indigoSource(int bond)
 {
     INDIGO_BEGIN
     {
@@ -1949,7 +1949,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDestination(int bond)
+int indigoDestination(int bond)
 {
     INDIGO_BEGIN
     {
@@ -2008,7 +2008,7 @@
     return vertex.neiNext(_nei_idx) != vertex.neiEnd();
 }
 
-CEXPORT int indigoIterateNeighbors(int atom)
+int indigoIterateNeighbors(int atom)
 {
     INDIGO_BEGIN
     {
@@ -2019,7 +2019,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoBond(int nei)
+int indigoBond(int nei)
 {
     INDIGO_BEGIN
     {
@@ -2035,7 +2035,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT float indigoAlignAtoms(int molecule, int natoms, int* atom_ids, float* desired_xyz)
+float indigoAlignAtoms(int molecule, int natoms, int* atom_ids, float* desired_xyz)
 {
     INDIGO_BEGIN
     {
@@ -2076,7 +2076,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountSuperatoms(int molecule)
+int indigoCountSuperatoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2086,7 +2086,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountDataSGroups(int molecule)
+int indigoCountDataSGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2096,7 +2096,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountRepeatingUnits(int molecule)
+int indigoCountRepeatingUnits(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2106,7 +2106,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountMultipleGroups(int molecule)
+int indigoCountMultipleGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2116,7 +2116,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountGenericSGroups(int molecule)
+int indigoCountGenericSGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2157,7 +2157,7 @@
     return sgroup.release();
 }
 
-CEXPORT int indigoIterateDataSGroups(int molecule)
+int indigoIterateDataSGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2458,7 +2458,7 @@
     return sgroup.release();
 }
 
-CEXPORT int indigoIterateGenericSGroups(int molecule)
+int indigoIterateGenericSGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2544,7 +2544,7 @@
     return sgroup.release();
 }
 
-CEXPORT int indigoIterateSGroups(int molecule)
+int indigoIterateSGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2632,7 +2632,7 @@
     return tgroup.release();
 }
 
-CEXPORT int indigoIterateTGroups(int molecule)
+int indigoIterateTGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2642,7 +2642,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateRepeatingUnits(int molecule)
+int indigoIterateRepeatingUnits(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2655,7 +2655,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateMultipleGroups(int molecule)
+int indigoIterateMultipleGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2668,7 +2668,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateSuperatoms(int molecule)
+int indigoIterateSuperatoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2681,7 +2681,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSuperatom(int molecule, int index)
+int indigoGetSuperatom(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -2698,7 +2698,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetDataSGroup(int molecule, int index)
+int indigoGetDataSGroup(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -2715,7 +2715,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetGenericSGroup(int molecule, int index)
+int indigoGetGenericSGroup(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -2732,7 +2732,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetMultipleGroup(int molecule, int index)
+int indigoGetMultipleGroup(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -2749,7 +2749,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetRepeatingUnit(int molecule, int index)
+int indigoGetRepeatingUnit(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -2766,7 +2766,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoDescription(int data_sgroup)
+const char* indigoDescription(int data_sgroup)
 {
     INDIGO_BEGIN
     {
@@ -2778,7 +2778,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoData(int data_sgroup)
+const char* indigoData(int data_sgroup)
 {
     INDIGO_BEGIN
     {
@@ -2790,7 +2790,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoAddDataSGroup(int molecule, int natoms, int* atoms, int nbonds, int* bonds, const char* name, const char* data)
+int indigoAddDataSGroup(int molecule, int natoms, int* atoms, int nbonds, int* bonds, const char* name, const char* data)
 {
     INDIGO_BEGIN
     {
@@ -2814,7 +2814,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddSuperatom(int molecule, int natoms, int* atoms, const char* name)
+int indigoAddSuperatom(int molecule, int natoms, int* atoms, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -2833,7 +2833,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetDataSGroupXY(int sgroup, float x, float y, const char* options)
+int indigoSetDataSGroupXY(int sgroup, float x, float y, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -2858,7 +2858,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupData(int sgroup, const char* data)
+int indigoSetSGroupData(int sgroup, const char* data)
 {
     INDIGO_BEGIN
     {
@@ -2872,7 +2872,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupCoords(int sgroup, float x, float y)
+int indigoSetSGroupCoords(int sgroup, float x, float y)
 {
     INDIGO_BEGIN
     {
@@ -2886,7 +2886,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupDescription(int sgroup, const char* description)
+int indigoSetSGroupDescription(int sgroup, const char* description)
 {
     INDIGO_BEGIN
     {
@@ -2900,7 +2900,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupFieldName(int sgroup, const char* name)
+int indigoSetSGroupFieldName(int sgroup, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -2914,7 +2914,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupQueryCode(int sgroup, const char* querycode)
+int indigoSetSGroupQueryCode(int sgroup, const char* querycode)
 {
     INDIGO_BEGIN
     {
@@ -2928,7 +2928,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupQueryOper(int sgroup, const char* queryoper)
+int indigoSetSGroupQueryOper(int sgroup, const char* queryoper)
 {
     INDIGO_BEGIN
     {
@@ -2942,7 +2942,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupDisplay(int sgroup, const char* option)
+int indigoSetSGroupDisplay(int sgroup, const char* option)
 {
     INDIGO_BEGIN
     {
@@ -2963,7 +2963,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupLocation(int sgroup, const char* option)
+int indigoSetSGroupLocation(int sgroup, const char* option)
 {
     INDIGO_BEGIN
     {
@@ -2984,7 +2984,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupTag(int sgroup, const char* tag)
+int indigoSetSGroupTag(int sgroup, const char* tag)
 {
     INDIGO_BEGIN
     {
@@ -3000,7 +3000,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupTagAlign(int sgroup, int tag_align)
+int indigoSetSGroupTagAlign(int sgroup, int tag_align)
 {
     INDIGO_BEGIN
     {
@@ -3016,7 +3016,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupDataType(int sgroup, const char* data_type)
+int indigoSetSGroupDataType(int sgroup, const char* data_type)
 {
     INDIGO_BEGIN
     {
@@ -3032,7 +3032,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupXCoord(int sgroup, float x)
+int indigoSetSGroupXCoord(int sgroup, float x)
 {
     INDIGO_BEGIN
     {
@@ -3045,7 +3045,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupYCoord(int sgroup, float y)
+int indigoSetSGroupYCoord(int sgroup, float y)
 {
     INDIGO_BEGIN
     {
@@ -3058,7 +3058,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateSGroup(const char* type, int mapping, const char* name)
+int indigoCreateSGroup(const char* type, int mapping, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -3115,7 +3115,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupClass(int sgroup, const char* sgclass)
+int indigoSetSGroupClass(int sgroup, const char* sgclass)
 {
     INDIGO_BEGIN
     {
@@ -3127,7 +3127,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetSGroupClass(int sgroup)
+const char* indigoGetSGroupClass(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3139,7 +3139,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoSetSGroupName(int sgroup, const char* sgname)
+int indigoSetSGroupName(int sgroup, const char* sgname)
 {
     INDIGO_BEGIN
     {
@@ -3151,7 +3151,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetSGroupName(int sgroup)
+const char* indigoGetSGroupName(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3163,7 +3163,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoGetSGroupNumCrossBonds(int sgroup)
+int indigoGetSGroupNumCrossBonds(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3173,7 +3173,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddSGroupAttachmentPoint(int sgroup, int aidx, int lvidx, const char* apid)
+int indigoAddSGroupAttachmentPoint(int sgroup, int aidx, int lvidx, const char* apid)
 {
     INDIGO_BEGIN
     {
@@ -3188,7 +3188,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDeleteSGroupAttachmentPoint(int sgroup, int ap_idx)
+int indigoDeleteSGroupAttachmentPoint(int sgroup, int ap_idx)
 {
     INDIGO_BEGIN
     {
@@ -3199,7 +3199,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSGroupDisplayOption(int sgroup)
+int indigoGetSGroupDisplayOption(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3212,7 +3212,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupDisplayOption(int sgroup, int option)
+int indigoSetSGroupDisplayOption(int sgroup, int option)
 {
     INDIGO_BEGIN
     {
@@ -3224,7 +3224,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSGroupSeqId(int sgroup)
+int indigoGetSGroupSeqId(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3236,7 +3236,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT float* indigoGetSGroupCoords(int sgroup)
+float* indigoGetSGroupCoords(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3252,7 +3252,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoGetSGroupMultiplier(int sgroup)
+int indigoGetSGroupMultiplier(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3262,7 +3262,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetRepeatingUnitSubscript(int sgroup)
+const char* indigoGetRepeatingUnitSubscript(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3272,7 +3272,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoGetRepeatingUnitConnectivity(int sgroup)
+int indigoGetRepeatingUnitConnectivity(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3282,7 +3282,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupMultiplier(int sgroup, int multiplier)
+int indigoSetSGroupMultiplier(int sgroup, int multiplier)
 {
     INDIGO_BEGIN
     {
@@ -3294,7 +3294,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupBrackets(int sgroup, int brk_style, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4)
+int indigoSetSGroupBrackets(int sgroup, int brk_style, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4)
 {
     INDIGO_BEGIN
     {
@@ -3323,7 +3323,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoFindSGroups(int item, const char* property, const char* value)
+int indigoFindSGroups(int item, const char* property, const char* value)
 {
     INDIGO_BEGIN
     {
@@ -3338,7 +3338,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSGroupType(int sgroup)
+int indigoGetSGroupType(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3348,7 +3348,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSGroupIndex(int sgroup)
+int indigoGetSGroupIndex(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3358,7 +3358,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSGroupOriginalId(int sgroup)
+int indigoGetSGroupOriginalId(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3368,7 +3368,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupOriginalId(int sgroup, int new_original)
+int indigoSetSGroupOriginalId(int sgroup, int new_original)
 {
     INDIGO_BEGIN
     {
@@ -3398,7 +3398,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSGroupParentId(int sgroup)
+int indigoGetSGroupParentId(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3408,7 +3408,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupParentId(int sgroup, int parent)
+int indigoSetSGroupParentId(int sgroup, int parent)
 {
     INDIGO_BEGIN
     {
@@ -3431,7 +3431,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddTemplate(int molecule, int templates, const char* tname)
+int indigoAddTemplate(int molecule, int templates, const char* tname)
 {
     INDIGO_BEGIN
     {
@@ -3449,7 +3449,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRemoveTemplate(int molecule, const char* tname)
+int indigoRemoveTemplate(int molecule, const char* tname)
 {
     INDIGO_BEGIN
     {
@@ -3464,7 +3464,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoFindTemplate(int molecule, const char* tname)
+int indigoFindTemplate(int molecule, const char* tname)
 {
     INDIGO_BEGIN
     {
@@ -3479,7 +3479,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetTGroupClass(int tgroup)
+const char* indigoGetTGroupClass(int tgroup)
 {
     INDIGO_BEGIN
     {
@@ -3491,7 +3491,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoGetTGroupName(int tgroup)
+const char* indigoGetTGroupName(int tgroup)
 {
     INDIGO_BEGIN
     {
@@ -3503,7 +3503,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoGetTGroupAlias(int tgroup)
+const char* indigoGetTGroupAlias(int tgroup)
 {
     INDIGO_BEGIN
     {
@@ -3515,7 +3515,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoTransformSCSRtoCTAB(int molecule)
+int indigoTransformSCSRtoCTAB(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -3528,7 +3528,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoTransformCTABtoSCSR(int molecule, int templates)
+int indigoTransformCTABtoSCSR(int molecule, int templates)
 {
     INDIGO_BEGIN
     {
@@ -3550,7 +3550,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountHeavyAtoms(int molecule)
+int indigoCountHeavyAtoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -3566,7 +3566,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountComponents(int molecule)
+int indigoCountComponents(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -3577,7 +3577,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCloneComponent(int molecule, int index)
+int indigoCloneComponent(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -3593,7 +3593,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoComponentIndex(int atom)
+int indigoComponentIndex(int atom)
 {
     INDIGO_BEGIN
     {
@@ -3604,7 +3604,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoComponent(int molecule, int index)
+int indigoComponent(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -3711,7 +3711,7 @@
     return idx;
 }
 
-CEXPORT int indigoIterateComponents(int molecule)
+int indigoIterateComponents(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -3722,7 +3722,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateComponentAtoms(int molecule, int index)
+int indigoIterateComponentAtoms(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -3733,7 +3733,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateComponentBonds(int molecule, int index)
+int indigoIterateComponentBonds(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -3744,7 +3744,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountComponentAtoms(int molecule, int index)
+int indigoCountComponentAtoms(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -3755,7 +3755,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountComponentBonds(int molecule, int index)
+int indigoCountComponentBonds(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -3766,7 +3766,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateMolecule()
+int indigoCreateMolecule()
 {
     INDIGO_BEGIN
     {
@@ -3776,7 +3776,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateQueryMolecule()
+int indigoCreateQueryMolecule()
 {
     INDIGO_BEGIN
     {
@@ -3785,7 +3785,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoMerge(int where, int what)
+int indigoMerge(int where, int what)
 {
     INDIGO_BEGIN
     {
@@ -3801,7 +3801,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddAtom(int molecule, const char* symbol)
+int indigoAddAtom(int molecule, const char* symbol)
 {
     INDIGO_BEGIN
     {
@@ -3833,7 +3833,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetAtom(int atom, const char* symbol)
+int indigoResetAtom(int atom, const char* symbol)
 {
     INDIGO_BEGIN
     {
@@ -3871,7 +3871,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetTemplateAtomClass(int atom)
+const char* indigoGetTemplateAtomClass(int atom)
 {
     INDIGO_BEGIN
     {
@@ -3892,7 +3892,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoSetTemplateAtomClass(int atom, const char* name)
+int indigoSetTemplateAtomClass(int atom, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -3948,7 +3948,7 @@
         mol.allowRGroupOnRSite(atom_index, rsites[i]);
 }
 
-CEXPORT int indigoAddRSite(int molecule, const char* name)
+int indigoAddRSite(int molecule, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -3971,7 +3971,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetRSite(int atom, const char* name)
+int indigoSetRSite(int atom, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -3985,7 +3985,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetCharge(int atom, int charge)
+int indigoSetCharge(int atom, int charge)
 {
     INDIGO_BEGIN
     {
@@ -3997,7 +3997,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetIsotope(int atom, int isotope)
+int indigoSetIsotope(int atom, int isotope)
 {
     INDIGO_BEGIN
     {
@@ -4009,7 +4009,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetImplicitHCount(int atom, int impl_h)
+int indigoSetImplicitHCount(int atom, int impl_h)
 {
     INDIGO_BEGIN
     {
@@ -4021,7 +4021,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddBond(int source, int destination, int order)
+int indigoAddBond(int source, int destination, int order)
 {
     INDIGO_BEGIN
     {
@@ -4042,7 +4042,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetBondOrder(int bond, int order)
+int indigoSetBondOrder(int bond, int order)
 {
     INDIGO_BEGIN
     {
@@ -4181,7 +4181,7 @@
     return new IndigoBond(_submol.getOriginalMolecule(), _submol.edges[_idx]);
 }
 
-CEXPORT int indigoCountSSSR(int molecule)
+int indigoCountSSSR(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -4192,7 +4192,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateSSSR(int molecule)
+int indigoIterateSSSR(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -4271,7 +4271,7 @@
     return res.release();
 }
 
-CEXPORT int indigoIterateSubtrees(int molecule, int min_atoms, int max_atoms)
+int indigoIterateSubtrees(int molecule, int min_atoms, int max_atoms)
 {
     INDIGO_BEGIN
     {
@@ -4321,7 +4321,7 @@
     return res.release();
 }
 
-CEXPORT int indigoIterateRings(int molecule, int min_atoms, int max_atoms)
+int indigoIterateRings(int molecule, int min_atoms, int max_atoms)
 {
     INDIGO_BEGIN
     {
@@ -4374,7 +4374,7 @@
     return res.release();
 }
 
-CEXPORT int indigoIterateEdgeSubmolecules(int molecule, int min_bonds, int max_bonds)
+int indigoIterateEdgeSubmolecules(int molecule, int min_bonds, int max_bonds)
 {
     INDIGO_BEGIN
     {
@@ -4385,7 +4385,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountHydrogens(int item, int* hydro)
+int indigoCountHydrogens(int item, int* hydro)
 {
     INDIGO_BEGIN
     {
@@ -4423,7 +4423,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountImplicitHydrogens(int item)
+int indigoCountImplicitHydrogens(int item)
 {
     INDIGO_BEGIN
     {
@@ -4476,7 +4476,7 @@
     return _mol.getAttachmentPoint(_order, _index + 1) != -1;
 }
 
-CEXPORT int indigoIterateAttachmentPoints(int molecule, int order)
+int indigoIterateAttachmentPoints(int molecule, int order)
 {
     INDIGO_BEGIN
     {
@@ -4494,7 +4494,7 @@
 name - a name to parse
 params - a string containing parsing options or nullptr if no options are changed
 */
-CEXPORT int indigoNameToStructure(const char* name, const char* params)
+int indigoNameToStructure(const char* name, const char* params)
 {
     INDIGO_BEGIN
     {
@@ -4528,7 +4528,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCheckRGroups(int item)
+int indigoCheckRGroups(int item)
 {
     INDIGO_BEGIN
     {
Index: libpng-src/libpng/config.h.in
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/config.h.in b/libpng-src/libpng/config.h.in
new file mode 100644
--- /dev/null	(date 1690795574118)
+++ b/libpng-src/libpng/config.h.in	(date 1690795574118)
@@ -0,0 +1,123 @@
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you have the `feenableexcept' function. */
+#undef HAVE_FEENABLEEXCEPT
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the `m' library (-lm). */
+#undef HAVE_LIBM
+
+/* Define to 1 if you have the `z' library (-lz). */
+#undef HAVE_LIBZ
+
+/* Define to 1 if you have the `pow' function. */
+#undef HAVE_POW
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdio.h> header file. */
+#undef HAVE_STDIO_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
+#undef LT_OBJDIR
+
+/* Name of package */
+#undef PACKAGE
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the home page for this package. */
+#undef PACKAGE_URL
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* Turn on ARM Neon optimizations at run-time */
+#undef PNG_ARM_NEON_API_SUPPORTED
+
+/* Check for ARM Neon support at run-time */
+#undef PNG_ARM_NEON_CHECK_SUPPORTED
+
+/* Enable ARM Neon optimizations */
+#undef PNG_ARM_NEON_OPT
+
+/* Enable Intel SSE optimizations */
+#undef PNG_INTEL_SSE_OPT
+
+/* Turn on MIPS MSA optimizations at run-time */
+#undef PNG_MIPS_MSA_API_SUPPORTED
+
+/* Check for MIPS MSA support at run-time */
+#undef PNG_MIPS_MSA_CHECK_SUPPORTED
+
+/* Enable MIPS MSA optimizations */
+#undef PNG_MIPS_MSA_OPT
+
+/* Turn on POWERPC VSX optimizations at run-time */
+#undef PNG_POWERPC_VSX_API_SUPPORTED
+
+/* Check for POWERPC VSX support at run-time */
+#undef PNG_POWERPC_VSX_CHECK_SUPPORTED
+
+/* Enable POWERPC VSX optimizations */
+#undef PNG_POWERPC_VSX_OPT
+
+/* Define to 1 if all of the C90 standard headers exist (not just the ones
+   required in a freestanding environment). This macro is provided for
+   backward compatibility; new code need not use it. */
+#undef STDC_HEADERS
+
+/* Define to 1 if your <sys/time.h> declares `struct tm'. */
+#undef TM_IN_SYS_TIME
+
+/* Version number of package */
+#undef VERSION
+
+/* Define to the equivalent of the C99 'restrict' keyword, or to
+   nothing if this is not supported.  Do not define if restrict is
+   supported only directly.  */
+#undef restrict
+/* Work around a bug in older versions of Sun C++, which did not
+   #define __restrict__ or support _Restrict or __restrict__
+   even though the corresponding Sun C compiler ended up with
+   "#define restrict _Restrict" or "#define restrict __restrict__"
+   in the previous line.  This workaround can be removed once
+   we assume Oracle Developer Studio 12.5 (2016) or later.  */
+#if defined __SUNPRO_CC && !defined __RESTRICT && !defined __restrict__
+# define _Restrict
+# define __restrict__
+#endif
Index: indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.cpp	(revision 2d40433a1825f4c17a70628b7dbf38828a4e0716)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.cpp	(date 1690767117645)
@@ -1564,7 +1564,7 @@
     return false;
 }
 
-CEXPORT int indigoDecomposeMolecules(int scaffold, int structures)
+int indigoDecomposeMolecules(int scaffold, int structures)
 {
     INDIGO_BEGIN
     {
@@ -1585,7 +1585,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateDecomposedMolecules(int decomp)
+int indigoIterateDecomposedMolecules(int decomp)
 {
     INDIGO_BEGIN
     {
@@ -1601,7 +1601,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDecomposedMoleculeScaffold(int decomp)
+int indigoDecomposedMoleculeScaffold(int decomp)
 {
     INDIGO_BEGIN
     {
@@ -1658,7 +1658,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDecomposedMoleculeHighlighted(int decomp)
+int indigoDecomposedMoleculeHighlighted(int decomp)
 {
     INDIGO_BEGIN
     {
@@ -1694,7 +1694,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDecomposedMoleculeSubstituents(int decomp)
+int indigoDecomposedMoleculeSubstituents(int decomp)
 {
     INDIGO_BEGIN
     {
@@ -1732,7 +1732,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDecomposedMoleculeWithRGroups(int decomp)
+int indigoDecomposedMoleculeWithRGroups(int decomp)
 {
     INDIGO_BEGIN
     {
@@ -1775,7 +1775,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateDecomposer(int scaffold)
+int indigoCreateDecomposer(int scaffold)
 {
     INDIGO_BEGIN
     {
@@ -1792,7 +1792,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDecomposeMolecule(int decomp, int mol)
+int indigoDecomposeMolecule(int decomp, int mol)
 {
     INDIGO_BEGIN
     {
@@ -1813,7 +1813,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateDecompositions(int deco_item)
+int indigoIterateDecompositions(int deco_item)
 {
     INDIGO_BEGIN
     {
@@ -1837,7 +1837,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddDecomposition(int decomp, int q_match)
+int indigoAddDecomposition(int decomp, int q_match)
 {
     INDIGO_BEGIN
     {
Index: libpng-src/libpng/pngdebug.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/pngdebug.h b/libpng-src/libpng/pngdebug.h
--- a/libpng-src/libpng/pngdebug.h	(revision e3a66311237bd7a6e390d3da8beb5ad74fcee5d0)
+++ b/libpng-src/libpng/pngdebug.h	(date 1690795574122)
@@ -1,10 +1,10 @@
 
 /* pngdebug.h - Debugging macros for libpng, also used in pngtest.c
  *
- * Last changed in libpng 1.6.8 [December 19, 2013]
+ * Copyright (c) 2018 Cosmin Truta
  * Copyright (c) 1998-2002,2004,2006-2013 Glenn Randers-Pehrson
- * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
- * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ * Copyright (c) 1996-1997 Andreas Dilger
+ * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
  *
  * This code is released under the libpng license.
  * For conditions of distribution and use, see the disclaimer
Index: opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/convolution.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/convolution.hpp b/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/convolution.hpp
--- a/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/convolution.hpp	(revision f9a59f2592993d3dcc080e495f4f5e02dd8ec7ef)
+++ b/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/convolution.hpp	(date 1689048275942)
@@ -63,7 +63,7 @@
     float* weightsWinoBufPtr;
     std::vector<float> biasBuf;
 
-#if CV_NEON && CV_NEON_AARCH64 && CV_FP16
+#if CONV_ARM_FP16
     std::vector<float16_t> weightsBuf_FP16;
     float16_t* weightsBufPtr_FP16;
     std::vector<float16_t> weightsWinoBuf_FP16;
Index: rdkit-src/rdkit/Code/ForceField/MMFF/Params.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/ForceField/MMFF/Params.cpp b/rdkit-src/rdkit/Code/ForceField/MMFF/Params.cpp
--- a/rdkit-src/rdkit/Code/ForceField/MMFF/Params.cpp	(revision aaf837069b40b4429bba739df27531398822aeeb)
+++ b/rdkit-src/rdkit/Code/ForceField/MMFF/Params.cpp	(date 1689048276098)
@@ -10,7 +10,7 @@
 //  which is included in the file license.txt, found at the root
 //  of the RDKit source tree.
 //
-#ifdef WIN32
+#if defined(WIN32) && !defined(_USE_MATH_DEFINES)
 #define _USE_MATH_DEFINES
 #endif
 #include <cmath>
Index: opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_winograd_f63.simd.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_winograd_f63.simd.hpp b/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_winograd_f63.simd.hpp
--- a/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_winograd_f63.simd.hpp	(revision f9a59f2592993d3dcc080e495f4f5e02dd8ec7ef)
+++ b/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_winograd_f63.simd.hpp	(date 1689048275942)
@@ -409,478 +409,5 @@
 
 CV_CPU_OPTIMIZATION_NAMESPACE_END
 
-// NEON code work around.
-namespace opt_NEON
-{
-
-#if !defined(CV_CPU_OPTIMIZATION_DECLARATIONS_ONLY) && CV_NEON && CV_NEON_AARCH64
-/* Accumulate */
-void winofunc_accum_f32(const float* inwptr, const float* wptr, float* outbuf, int Cg, int iblock,
-                        const int winoIblock, const int winoKblock, const int winoAtomF32, const int winoNatomF32);
-
-/*Input transform*/
-void winofunc_BtXB_8x8_f32(const float* inptr, int inpstep,
-                            float* outptr, int Cg, const int winoIblock, const int winoAtomF32);
-
-/*Output transform*/
-void winofunc_AtXA_8x8_f32(const float* inptr, int inpstep,
-                            float* bpptr, int bpstep, float* outptr, int outstep,
-                            float bias, float minval, float maxval, bool ifMinMaxAct);
-
-void winofunc_accum_f32(const float* inwptr, const float* wptr, float* outbuf, int Cg, int iblock,
-                            const int winoIblock, const int winoKblock, const int winoAtomF32, const int winoNatomF32)
-{
-    CV_Assert(winoIblock == 6 && winoKblock == 4 && winoAtomF32 == 4);
-    if (iblock > 3)
-    {
-        for (int atom_id = 0; atom_id < winoNatomF32; atom_id++,
-                outbuf += winoAtomF32)
-        {
-            float32x4_t s00 = vdupq_n_f32(0.f), s01 = s00, s02 = s00, s03 = s00, s04 = s00, s05 = s00;
-            float32x4_t s10 = vdupq_n_f32(0.f), s11 = s00, s12 = s00, s13 = s00, s14 = s00, s15 = s00;
-            float32x4_t s20 = vdupq_n_f32(0.f), s21 = s00, s22 = s00, s23 = s00, s24 = s00, s25 = s00;
-            float32x4_t s30 = vdupq_n_f32(0.f), s31 = s00, s32 = s00, s33 = s00, s34 = s00, s35 = s00;
-            for (int c = 0; c < Cg; c++, inwptr += winoIblock*winoAtomF32,
-                                         wptr += winoKblock*winoAtomF32) {
-                float32x4_t w0 = vld1q_f32(wptr), w1 = vld1q_f32(wptr + 4);
-                float32x4_t w2 = vld1q_f32(wptr + 8), w3 = vld1q_f32(wptr + 12);
-                float32x4_t x0, x1;
-                x0 = vld1q_f32(inwptr);
-                x1 = vld1q_f32(inwptr + 4);
-                s00 = vfmaq_f32(s00, w0, x0);
-                s01 = vfmaq_f32(s01, w0, x1);
-                s10 = vfmaq_f32(s10, w1, x0);
-                s11 = vfmaq_f32(s11, w1, x1);
-                s20 = vfmaq_f32(s20, w2, x0);
-                s21 = vfmaq_f32(s21, w2, x1);
-                s30 = vfmaq_f32(s30, w3, x0);
-                s31 = vfmaq_f32(s31, w3, x1);
-                x0 = vld1q_f32(inwptr + 8);
-                x1 = vld1q_f32(inwptr + 12);
-                s02 = vfmaq_f32(s02, w0, x0);
-                s03 = vfmaq_f32(s03, w0, x1);
-                s12 = vfmaq_f32(s12, w1, x0);
-                s13 = vfmaq_f32(s13, w1, x1);
-                s22 = vfmaq_f32(s22, w2, x0);
-                s23 = vfmaq_f32(s23, w2, x1);
-                s32 = vfmaq_f32(s32, w3, x0);
-                s33 = vfmaq_f32(s33, w3, x1);
-                x0 = vld1q_f32(inwptr + 16);
-                x1 = vld1q_f32(inwptr + 20);
-                s04 = vfmaq_f32(s04, w0, x0);
-                s05 = vfmaq_f32(s05, w0, x1);
-                s14 = vfmaq_f32(s14, w1, x0);
-                s15 = vfmaq_f32(s15, w1, x1);
-                s24 = vfmaq_f32(s24, w2, x0);
-                s25 = vfmaq_f32(s25, w2, x1);
-                s34 = vfmaq_f32(s34, w3, x0);
-                s35 = vfmaq_f32(s35, w3, x1);
-            }
-
-            vst1q_f32(outbuf, s00);
-            vst1q_f32(outbuf + 1*64, s01);
-            vst1q_f32(outbuf + 2*64, s02);
-            vst1q_f32(outbuf + 3*64, s03);
-            vst1q_f32(outbuf + 4*64, s04);
-            vst1q_f32(outbuf + 5*64, s05);
-
-            vst1q_f32(outbuf + 6*64, s10);
-            vst1q_f32(outbuf + 7*64, s11);
-            vst1q_f32(outbuf + 8*64, s12);
-            vst1q_f32(outbuf + 9*64, s13);
-            vst1q_f32(outbuf + 10*64, s14);
-            vst1q_f32(outbuf + 11*64, s15);
-
-            vst1q_f32(outbuf + 12*64, s20);
-            vst1q_f32(outbuf + 13*64, s21);
-            vst1q_f32(outbuf + 14*64, s22);
-            vst1q_f32(outbuf + 15*64, s23);
-            vst1q_f32(outbuf + 16*64, s24);
-            vst1q_f32(outbuf + 17*64, s25);
-
-            vst1q_f32(outbuf + 18*64, s30);
-            vst1q_f32(outbuf + 19*64, s31);
-            vst1q_f32(outbuf + 20*64, s32);
-            vst1q_f32(outbuf + 21*64, s33);
-            vst1q_f32(outbuf + 22*64, s34);
-            vst1q_f32(outbuf + 23*64, s35);
-        }
-    }
-    else
-    {
-        for (int atom_id = 0; atom_id < winoNatomF32; atom_id++,
-                outbuf += winoAtomF32)
-        {
-            float32x4_t s00 = vdupq_n_f32(0.f), s01 = s00, s02 = s00;
-            float32x4_t s10 = vdupq_n_f32(0.f), s11 = s00, s12 = s00;
-            float32x4_t s20 = vdupq_n_f32(0.f), s21 = s00, s22 = s00;
-            float32x4_t s30 = vdupq_n_f32(0.f), s31 = s00, s32 = s00;
-            for (int c = 0; c < Cg; c++, inwptr += winoIblock*winoAtomF32,
-                                         wptr += winoKblock*winoAtomF32) {
-                float32x4_t w0 = vld1q_f32(wptr), w1 = vld1q_f32(wptr + 4);
-                float32x4_t w2 = vld1q_f32(wptr + 8), w3 = vld1q_f32(wptr + 12);
-                float32x4_t x0, x1, x2;
-                x0 = vld1q_f32(inwptr);
-                x1 = vld1q_f32(inwptr + 4);
-                x2 = vld1q_f32(inwptr + 8);
-                s00 = vfmaq_f32(s00, w0, x0);
-                s01 = vfmaq_f32(s01, w0, x1);
-                s02 = vfmaq_f32(s02, w0, x2);
-                s10 = vfmaq_f32(s10, w1, x0);
-                s11 = vfmaq_f32(s11, w1, x1);
-                s12 = vfmaq_f32(s12, w1, x2);
-                s20 = vfmaq_f32(s20, w2, x0);
-                s21 = vfmaq_f32(s21, w2, x1);
-                s22 = vfmaq_f32(s22, w2, x2);
-                s30 = vfmaq_f32(s30, w3, x0);
-                s31 = vfmaq_f32(s31, w3, x1);
-                s32 = vfmaq_f32(s32, w3, x2);
-            }
-
-            vst1q_f32(outbuf, s00);
-            vst1q_f32(outbuf + 1*64, s01);
-            vst1q_f32(outbuf + 2*64, s02);
-            vst1q_f32(outbuf + 6*64, s10);
-            vst1q_f32(outbuf + 7*64, s11);
-            vst1q_f32(outbuf + 8*64, s12);
-            vst1q_f32(outbuf + 12*64, s20);
-            vst1q_f32(outbuf + 13*64, s21);
-            vst1q_f32(outbuf + 14*64, s22);
-            vst1q_f32(outbuf + 18*64, s30);
-            vst1q_f32(outbuf + 19*64, s31);
-            vst1q_f32(outbuf + 20*64, s32);
-        }
-    }
-}
-
-#define T4x4(a, b, c, d, tr0, tr1) \
-    tr0 = vtrnq_f32(a, b); \
-    tr1 = vtrnq_f32(c, d); \
-    a = vcombine_f32(vget_low_f32(tr0.val[0]), vget_low_f32(tr1.val[0])); \
-    b = vcombine_f32(vget_low_f32(tr0.val[1]), vget_low_f32(tr1.val[1])); \
-    c = vcombine_f32(vget_high_f32(tr0.val[0]), vget_high_f32(tr1.val[0])); \
-    d = vcombine_f32(vget_high_f32(tr0.val[1]), vget_high_f32(tr1.val[1]))
-
-/*Input transform*/
-void winofunc_BtXB_8x8_f32(const float* inptr, int inpstep,
-                          float* outptr, int Cg, const int winoIblock, const int winoAtomF32)
-{
-    float32x4_t x00 = vld1q_f32(inptr), x01 = vld1q_f32(inptr + 4);
-    float32x4_t x10 = vld1q_f32(inptr + inpstep), x11 = vld1q_f32(inptr + inpstep + 4);
-    float32x4_t x20 = vld1q_f32(inptr + inpstep*2), x21 = vld1q_f32(inptr + inpstep*2 + 4);
-    float32x4_t x30 = vld1q_f32(inptr + inpstep*3), x31 = vld1q_f32(inptr + inpstep*3 + 4);
-    float32x4_t x40 = vld1q_f32(inptr + inpstep*4), x41 = vld1q_f32(inptr + inpstep*4 + 4);
-    float32x4_t x50 = vld1q_f32(inptr + inpstep*5), x51 = vld1q_f32(inptr + inpstep*5 + 4);
-    float32x4_t x60 = vld1q_f32(inptr + inpstep*6), x61 = vld1q_f32(inptr + inpstep*6 + 4);
-    float32x4_t x70 = vld1q_f32(inptr + inpstep*7), x71 = vld1q_f32(inptr + inpstep*7 + 4);
-
-    float32x4_t z00, z01, z10, z11, z20, z21, z30, z31, z40, z41, z50, z51, z60, z61, z70, z71;
-
-    {
-        /* Y[0] = [1.f, 0.f, -5.25f, 0.f, 5.25f, 0.f, -1.f, 0.f]*X */
-        /* Y[7] = [0.f, -1.f, 0.f, 5.25f, 0.f, -5.25f, 0.f, 1.f]*X */
-        float32x4_t q5_25 = vdupq_n_f32(5.25f), t00, t01, t10, t11;
-        t00 = vsubq_f32(x40, x20);
-        t01 = vsubq_f32(x41, x21);
-        t10 = vsubq_f32(x30, x50);
-        t11 = vsubq_f32(x31, x51);
-        float32x4_t y00 = vfmaq_f32(vsubq_f32(x00, x60), t00, q5_25);
-        float32x4_t y01 = vfmaq_f32(vsubq_f32(x01, x61), t01, q5_25);
-        float32x4_t y70 = vfmaq_f32(vsubq_f32(x70, x10), t10, q5_25);
-        float32x4_t y71 = vfmaq_f32(vsubq_f32(x71, x11), t11, q5_25);
-
-        /* Y[1] = [0.f, 1.f, 1.f, -4.25f, -4.25f, 1.f, 1.f, 0.f]*X */
-        /* Y[2] = [0.f, -1.f, 1.f, 4.25f, -4.25f, -1.f, 1.f, 0.f]*X */
-        float32x4_t qm4_25 = vdupq_n_f32(-4.25f);
-        t00 = vfmaq_f32(vaddq_f32(x10, x50), x30, qm4_25);
-        t01 = vfmaq_f32(vaddq_f32(x11, x51), x31, qm4_25);
-        t10 = vfmaq_f32(vaddq_f32(x20, x60), x40, qm4_25);
-        t11 = vfmaq_f32(vaddq_f32(x21, x61), x41, qm4_25);
-
-        float32x4_t y10 = vaddq_f32(t00, t10), y11 = vaddq_f32(t01, t11);
-        float32x4_t y20 = vsubq_f32(t10, t00), y21 = vsubq_f32(t11, t01);
-
-        /* Y[3] = [0.f, 0.5f, 0.25f, -2.5f, -1.25f, 2.f, 1.f, 0.f]*X */
-        /* Y[4] = [0.f, -0.5f, 0.25f, 2.5f, -1.25f, -2.f, 1.f, 0.f]*X */
-        float32x4_t q0_5 = vdupq_n_f32(0.5f), q0_25 = vdupq_n_f32(0.25f);
-        float32x4_t qm2_5 = vdupq_n_f32(-2.5f), qm1_25 = vdupq_n_f32(-1.25f);
-        t00 = vfmaq_f32(vaddq_f32(x50, x50), x10, q0_5);
-        t01 = vfmaq_f32(vaddq_f32(x51, x51), x11, q0_5);
-        t10 = vfmaq_f32(x60, x20, q0_25);
-        t11 = vfmaq_f32(x61, x21, q0_25);
-        t00 = vfmaq_f32(t00, x30, qm2_5);
-        t01 = vfmaq_f32(t01, x31, qm2_5);
-        t10 = vfmaq_f32(t10, x40, qm1_25);
-        t11 = vfmaq_f32(t11, x41, qm1_25);
-
-        float32x4_t y30 = vaddq_f32(t00, t10), y31 = vaddq_f32(t01, t11);
-        float32x4_t y40 = vsubq_f32(t10, t00), y41 = vsubq_f32(t11, t01);
-
-        /* Y[5] = [0.f, 2.f, 4.f, -2.5f, -5.f, 0.5f, 1.f, 0.f]*X */
-        /* Y[6] = [0.f, -2.f, 4.f, 2.5f, -5.f, -0.5f, 1.f, 0.f]*X */
-        float32x4_t q4 = vdupq_n_f32(4.f), qm5 = vdupq_n_f32(-5.f);
-        t00 = vfmaq_f32(vaddq_f32(x10, x10), x50, q0_5);
-        t01 = vfmaq_f32(vaddq_f32(x11, x11), x51, q0_5);
-        t10 = vfmaq_f32(x60, x20, q4);
-        t11 = vfmaq_f32(x61, x21, q4);
-        t00 = vfmaq_f32(t00, x30, qm2_5);
-        t01 = vfmaq_f32(t01, x31, qm2_5);
-        t10 = vfmaq_f32(t10, x40, qm5);
-        t11 = vfmaq_f32(t11, x41, qm5);
-
-        float32x4_t y50 = vaddq_f32(t00, t10), y51 = vaddq_f32(t01, t11);
-        float32x4_t y60 = vsubq_f32(t10, t00), y61 = vsubq_f32(t11, t01);
-
-        /* transpose 8x8 matrix in-place with some renumeration of the elements: */
-        /* Y:              */
-        /*        y00 y01  */
-        /*        y10 y11  */
-        /*        ...      */
-        /*        y70 y71  */
-        /*   Y':           */
-        /*        y00 y40  */
-        /*        y10 y50  */
-        /*        y20 y60  */
-        /*        y30 y70  */
-        /*        y01 y41  */
-        /*        y11 y51  */
-        /*        y21 y61  */
-        /*        y31 y71  */
-        /*    in other words, y40 <-> y01, y50 <-> y11, y60 <-> y21, y70 <-> y31 */
-        float32x4x2_t tr0, tr1;
-
-        T4x4(y00, y10, y20, y30, tr0, tr1);
-        T4x4(y01, y11, y21, y31, tr0, tr1);
-        T4x4(y40, y50, y60, y70, tr0, tr1);
-        T4x4(y41, y51, y61, y71, tr0, tr1);
-
-        /* Z[0] = [1.f, 0.f, -5.25f, 0.f, 5.25f, 0.f, -1.f, 0.f]*Y */
-        /* Z[7] = [0.f, -1.f, 0.f, 5.25f, 0.f, -5.25f, 0.f, 1.f]*Y */
-        t00 = vsubq_f32(y01, y20);
-        t01 = vsubq_f32(y41, y60);
-        t10 = vsubq_f32(y30, y11);
-        t11 = vsubq_f32(y70, y51);
-        z00 = vfmaq_f32(vsubq_f32(y00, y21), t00, q5_25);
-        z01 = vfmaq_f32(vsubq_f32(y40, y61), t01, q5_25);
-        z70 = vfmaq_f32(vsubq_f32(y31, y10), t10, q5_25);
-        z71 = vfmaq_f32(vsubq_f32(y71, y50), t11, q5_25);
-
-        /* Z[1] = [0.f, 1.f, 1.f, -4.25f, -4.25f, 1.f, 1.f, 0.f]*Y */
-        /* Z[2] = [0.f, -1.f, 1.f, 4.25f, -4.25f, -1.f, 1.f, 0.f]*Y */
-        t00 = vfmaq_f32(vaddq_f32(y10, y11), y30, qm4_25);
-        t01 = vfmaq_f32(vaddq_f32(y50, y51), y70, qm4_25);
-        t10 = vfmaq_f32(vaddq_f32(y20, y21), y01, qm4_25);
-        t11 = vfmaq_f32(vaddq_f32(y60, y61), y41, qm4_25);
-
-        z10 = vaddq_f32(t00, t10); z11 = vaddq_f32(t01, t11);
-        z20 = vsubq_f32(t10, t00); z21 = vsubq_f32(t11, t01);
-
-        /* Z[3] = [0.f, 0.5f, 0.25f, -2.5f, -1.25f, 2.f, 1.f, 0.f]*Y */
-        /* Z[4] = [0.f, -0.5f, 0.25f, 2.5f, -1.25f, -2.f, 1.f, 0.f]*Y */
-        t00 = vfmaq_f32(vaddq_f32(y11, y11), y10, q0_5);
-        t01 = vfmaq_f32(vaddq_f32(y51, y51), y50, q0_5);
-        t10 = vfmaq_f32(y21, y20, q0_25);
-        t11 = vfmaq_f32(y61, y60, q0_25);
-        t00 = vfmaq_f32(t00, y30, qm2_5);
-        t01 = vfmaq_f32(t01, y70, qm2_5);
-        t10 = vfmaq_f32(t10, y01, qm1_25);
-        t11 = vfmaq_f32(t11, y41, qm1_25);
-
-        z30 = vaddq_f32(t00, t10); z31 = vaddq_f32(t01, t11);
-        z40 = vsubq_f32(t10, t00); z41 = vsubq_f32(t11, t01);
-
-        /* Z[5] = [0.f, 2.f, 4.f, -2.5f, -5.f, 0.5f, 1.f, 0.f]*Y */
-        /* Z[6] = [0.f, -2.f, 4.f, 2.5f, -5.f, -0.5f, 1.f, 0.f]*Y */
-        t00 = vfmaq_f32(vaddq_f32(y10, y10), y11, q0_5);
-        t01 = vfmaq_f32(vaddq_f32(y50, y50), y51, q0_5);
-        t10 = vfmaq_f32(y21, y20, q4);
-        t11 = vfmaq_f32(y61, y60, q4);
-        t00 = vfmaq_f32(t00, y30, qm2_5);
-        t01 = vfmaq_f32(t01, y70, qm2_5);
-        t10 = vfmaq_f32(t10, y01, qm5);
-        t11 = vfmaq_f32(t11, y41, qm5);
-
-        z50 = vaddq_f32(t00, t10); z51 = vaddq_f32(t01, t11);
-        z60 = vsubq_f32(t10, t00); z61 = vsubq_f32(t11, t01);
-    }
-
-    const int outstep = winoIblock*winoAtomF32*Cg;
-
-    vst1q_f32(outptr, z00);
-    vst1q_f32(outptr + outstep, z01);
-    vst1q_f32(outptr + outstep*2, z10);
-    vst1q_f32(outptr + outstep*3, z11);
-    vst1q_f32(outptr + outstep*4, z20);
-    vst1q_f32(outptr + outstep*5, z21);
-    vst1q_f32(outptr + outstep*6, z30);
-    vst1q_f32(outptr + outstep*7, z31);
-    vst1q_f32(outptr + outstep*8, z40);
-    vst1q_f32(outptr + outstep*9, z41);
-    vst1q_f32(outptr + outstep*10, z50);
-    vst1q_f32(outptr + outstep*11, z51);
-    vst1q_f32(outptr + outstep*12, z60);
-    vst1q_f32(outptr + outstep*13, z61);
-    vst1q_f32(outptr + outstep*14, z70);
-    vst1q_f32(outptr + outstep*15, z71);
-}
-
-/*Output transform*/
-void winofunc_AtXA_8x8_f32(const float* inptr, int inpstep,
-                          float* bpptr, int bpstep, float* outptr, int outstep,
-                          float bias, float minval, float maxval, bool ifMinMaxAct)
-{
-    float32x4_t x00 = vld1q_f32(inptr), x01 = vld1q_f32(inptr + 4);
-    float32x4_t x10 = vld1q_f32(inptr + inpstep), x11 = vld1q_f32(inptr + inpstep + 4);
-    float32x4_t x20 = vld1q_f32(inptr + inpstep*2), x21 = vld1q_f32(inptr + inpstep*2 + 4);
-    float32x4_t x30 = vld1q_f32(inptr + inpstep*3), x31 = vld1q_f32(inptr + inpstep*3 + 4);
-    float32x4_t x40 = vld1q_f32(inptr + inpstep*4), x41 = vld1q_f32(inptr + inpstep*4 + 4);
-    float32x4_t x50 = vld1q_f32(inptr + inpstep*5), x51 = vld1q_f32(inptr + inpstep*5 + 4);
-    float32x4_t x60 = vld1q_f32(inptr + inpstep*6), x61 = vld1q_f32(inptr + inpstep*6 + 4);
-    float32x4_t x70 = vld1q_f32(inptr + inpstep*7), x71 = vld1q_f32(inptr + inpstep*7 + 4);
-    float32x4_t z00, z01, z10, z11, z20, z21, z30, z31, z40, z41, z50, z51;
-
-    {
-        float32x4_t s12_0, s12_1, s34_0, s34_1, s56_0, s56_1;
-        s12_0 = vaddq_f32(x10, x20); s12_1 = vaddq_f32(x11, x21);
-        s34_0 = vaddq_f32(x30, x40); s34_1 = vaddq_f32(x31, x41);
-        s56_0 = vaddq_f32(x50, x60); s56_1 = vaddq_f32(x51, x61);
-
-        float32x4_t y00 = vaddq_f32(vaddq_f32(vaddq_f32(x00, s12_0), s34_0), s56_0);
-        float32x4_t y01 = vaddq_f32(vaddq_f32(vaddq_f32(x01, s12_1), s34_1), s56_1);
-        float32x4_t y20 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 4.0f), s56_0, 0.25f);
-        float32x4_t y21 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 4.0f), s56_1, 0.25f);
-        float32x4_t y40 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 16.0f), s56_0, 1.f/16);
-        float32x4_t y41 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 16.0f), s56_1, 1.f/16);
-
-        s12_0 = vsubq_f32(x10, x20); s12_1 = vsubq_f32(x11, x21);
-        s34_0 = vsubq_f32(x30, x40); s34_1 = vsubq_f32(x31, x41);
-        s56_0 = vsubq_f32(x50, x60); s56_1 = vsubq_f32(x51, x61);
-
-        float32x4_t y50 = vfmaq_n_f32(vfmaq_n_f32(vaddq_f32(x70, s12_0),
-                                      s34_0, 32.f), s56_0, 1.f/32);
-        float32x4_t y51 = vfmaq_n_f32(vfmaq_n_f32(vaddq_f32(x71, s12_1),
-                                      s34_1, 32.f), s56_1, 1.f/32);
-        float32x4_t y10 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 2.0f), s56_0, 0.5f);
-        float32x4_t y11 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 2.0f), s56_1, 0.5f);
-        float32x4_t y30 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 8.0f), s56_0, 0.125f);
-        float32x4_t y31 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 8.0f), s56_1, 0.125f);
-        float32x4_t y60 = vdupq_n_f32(0.f), y61 = y60, y70 = y60, y71 = y60;
-
-        /* transpose 8x8 matrix in-place with some renumeration of the elements: */
-        /*  Y: */
-        /*        y00 y01 */
-        /*        y10 y11 */
-        /*        ... */
-        /*        y50 y51 */
-        /*        0   0 */
-        /*        0   0 */
-        /*   Y': */
-        /*        y00 y40 */
-        /*        y10 y50 */
-        /*        y20 y60 */
-        /*        y30 y70 */
-        /*        y01 y41 */
-        /*        y11 y51 */
-        /*        y21 y61 */
-        /*        y31 y71 */
-        /*    in other words, y40 <-> y01, y50 <-> y11, y60 <-> y21, y70 <-> y31 */
-        float32x4x2_t tr0, tr1;
-
-        T4x4(y00, y10, y20, y30, tr0, tr1);
-        T4x4(y01, y11, y21, y31, tr0, tr1);
-        T4x4(y40, y50, y60, y70, tr0, tr1);
-        T4x4(y41, y51, y61, y71, tr0, tr1);
-
-        s12_0 = vaddq_f32(y10, y20); s12_1 = vaddq_f32(y50, y60);
-        s34_0 = vaddq_f32(y30, y01); s34_1 = vaddq_f32(y70, y41);
-        s56_0 = vaddq_f32(y11, y21); s56_1 = vaddq_f32(y51, y61);
-
-        z00 = vaddq_f32(vaddq_f32(vaddq_f32(y00, s12_0), s34_0), s56_0);
-        z01 = vaddq_f32(vaddq_f32(vaddq_f32(y40, s12_1), s34_1), s56_1);
-        z20 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 4.0f), s56_0, 0.25f);
-        z21 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 4.0f), s56_1, 0.25f);
-        z40 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 16.0f), s56_0, 1.f/16);
-        z41 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 16.0f), s56_1, 1.f/16);
-
-        s12_0 = vsubq_f32(y10, y20); s12_1 = vsubq_f32(y50, y60);
-        s34_0 = vsubq_f32(y30, y01); s34_1 = vsubq_f32(y70, y41);
-        s56_0 = vsubq_f32(y11, y21); s56_1 = vsubq_f32(y51, y61);
-
-        z50 = vfmaq_n_f32(vfmaq_n_f32(vaddq_f32(y31, s12_0),
-                          s34_0, 32.f), s56_0, 1.f/32);
-        z51 = vfmaq_n_f32(vfmaq_n_f32(vaddq_f32(y71, s12_1),
-                          s34_1, 32.f), s56_1, 1.f/32);
-        z10 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 2.0f), s56_0, 0.5f);
-        z11 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 2.0f), s56_1, 0.5f);
-        z30 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 8.0f), s56_0, 0.125f);
-        z31 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 8.0f), s56_1, 0.125f);
-        float32x4_t vbias = vdupq_n_f32(bias);
-
-        z00 = vaddq_f32(z00, vbias);
-        z01 = vaddq_f32(z01, vbias);
-        z10 = vaddq_f32(z10, vbias);
-        z11 = vaddq_f32(z11, vbias);
-        z20 = vaddq_f32(z20, vbias);
-        z21 = vaddq_f32(z21, vbias);
-        z30 = vaddq_f32(z30, vbias);
-        z31 = vaddq_f32(z31, vbias);
-        z40 = vaddq_f32(z40, vbias);
-        z41 = vaddq_f32(z41, vbias);
-        z50 = vaddq_f32(z50, vbias);
-        z51 = vaddq_f32(z51, vbias);
-    }
-
-    if (bpptr)
-    {
-        float32x2_t zhalf = vdup_n_f32(0.f);
-        z00 = vaddq_f32(z00, vld1q_f32(bpptr));
-        z01 = vaddq_f32(z01, vcombine_f32(vld1_f32(bpptr + 4), zhalf));
-        z10 = vaddq_f32(z10, vld1q_f32(bpptr + bpstep));
-        z11 = vaddq_f32(z11, vcombine_f32(vld1_f32(bpptr + bpstep + 4), zhalf));
-        z20 = vaddq_f32(z20, vld1q_f32(bpptr + bpstep*2));
-        z21 = vaddq_f32(z21, vcombine_f32(vld1_f32(bpptr + bpstep*2 + 4), zhalf));
-        z30 = vaddq_f32(z30, vld1q_f32(bpptr + bpstep*3));
-        z31 = vaddq_f32(z31, vcombine_f32(vld1_f32(bpptr + bpstep*3 + 4), zhalf));
-        z40 = vaddq_f32(z40, vld1q_f32(bpptr + bpstep*4));
-        z41 = vaddq_f32(z41, vcombine_f32(vld1_f32(bpptr + bpstep*4 + 4), zhalf));
-        z50 = vaddq_f32(z50, vld1q_f32(bpptr + bpstep*5));
-        z51 = vaddq_f32(z51, vcombine_f32(vld1_f32(bpptr + bpstep*5 + 4), zhalf));
-    }
-
-    if (ifMinMaxAct)
-    {
-        float32x4_t vmax = vdupq_n_f32(maxval);
-        float32x4_t vmin = vdupq_n_f32(minval);
-
-        z00 = vminq_f32(vmaxq_f32(z00, vmin), vmax);
-        z01 = vminq_f32(vmaxq_f32(z01, vmin), vmax);
-        z10 = vminq_f32(vmaxq_f32(z10, vmin), vmax);
-        z11 = vminq_f32(vmaxq_f32(z11, vmin), vmax);
-        z20 = vminq_f32(vmaxq_f32(z20, vmin), vmax);
-        z21 = vminq_f32(vmaxq_f32(z21, vmin), vmax);
-        z30 = vminq_f32(vmaxq_f32(z30, vmin), vmax);
-        z31 = vminq_f32(vmaxq_f32(z31, vmin), vmax);
-        z40 = vminq_f32(vmaxq_f32(z40, vmin), vmax);
-        z41 = vminq_f32(vmaxq_f32(z41, vmin), vmax);
-        z50 = vminq_f32(vmaxq_f32(z50, vmin), vmax);
-        z51 = vminq_f32(vmaxq_f32(z51, vmin), vmax);
-    }
-
-    vst1q_f32(outptr, z00);
-    vst1_f32(outptr + 4, vget_low_f32(z01));
-    vst1q_f32(outptr + outstep, z10);
-    vst1_f32(outptr + outstep + 4, vget_low_f32(z11));
-    vst1q_f32(outptr + outstep*2, z20);
-    vst1_f32(outptr + outstep*2 + 4, vget_low_f32(z21));
-    vst1q_f32(outptr + outstep*3, z30);
-    vst1_f32(outptr + outstep*3 + 4, vget_low_f32(z31));
-    vst1q_f32(outptr + outstep*4, z40);
-    vst1_f32(outptr + outstep*4 + 4, vget_low_f32(z41));
-    vst1q_f32(outptr + outstep*5, z50);
-    vst1_f32(outptr + outstep*5 + 4, vget_low_f32(z51));
-}
-
-#endif
-}
 
 }} // namespace
diff --git a/nodeeditor-src/nodeeditor/src/locateNode.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/locateNode.cpp
rename from nodeeditor-src/nodeeditor/src/locateNode.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/locateNode.cpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeDelegateModel.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeDelegateModel.cpp
rename from nodeeditor-src/nodeeditor/src/NodeDelegateModel.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeDelegateModel.cpp
diff --git a/nodeeditor-src/nodeeditor/src/GraphicsView.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/GraphicsView.cpp
rename from nodeeditor-src/nodeeditor/src/GraphicsView.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/GraphicsView.cpp
diff --git a/nodeeditor-src/nodeeditor/src/AbstractGraphModel.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/AbstractGraphModel.cpp
rename from nodeeditor-src/nodeeditor/src/AbstractGraphModel.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/AbstractGraphModel.cpp
diff --git a/nodeeditor-src/nodeeditor/src/StyleCollection.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/StyleCollection.cpp
rename from nodeeditor-src/nodeeditor/src/StyleCollection.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/StyleCollection.cpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeState.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeState.cpp
rename from nodeeditor-src/nodeeditor/src/NodeState.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeState.cpp
diff --git a/nodeeditor-src/nodeeditor/src/ConnectionGraphicsObject.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionGraphicsObject.cpp
rename from nodeeditor-src/nodeeditor/src/ConnectionGraphicsObject.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionGraphicsObject.cpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeStyle.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeStyle.cpp
rename from nodeeditor-src/nodeeditor/src/NodeStyle.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeStyle.cpp
diff --git a/nodeeditor-src/nodeeditor/src/Definitions.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/Definitions.cpp
rename from nodeeditor-src/nodeeditor/src/Definitions.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/Definitions.cpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeConnectionInteraction.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeConnectionInteraction.cpp
rename from nodeeditor-src/nodeeditor/src/NodeConnectionInteraction.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeConnectionInteraction.cpp
diff --git a/nodeeditor-src/nodeeditor/src/GraphicsViewStyle.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/GraphicsViewStyle.cpp
rename from nodeeditor-src/nodeeditor/src/GraphicsViewStyle.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/GraphicsViewStyle.cpp
diff --git a/nodeeditor-src/nodeeditor/src/DefaultHorizontalNodeGeometry.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultHorizontalNodeGeometry.cpp
rename from nodeeditor-src/nodeeditor/src/DefaultHorizontalNodeGeometry.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultHorizontalNodeGeometry.cpp
diff --git a/nodeeditor-src/nodeeditor/src/DataFlowGraphicsScene.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DataFlowGraphicsScene.cpp
rename from nodeeditor-src/nodeeditor/src/DataFlowGraphicsScene.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DataFlowGraphicsScene.cpp
diff --git a/nodeeditor-src/nodeeditor/src/ConnectionPainter.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionPainter.cpp
rename from nodeeditor-src/nodeeditor/src/ConnectionPainter.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionPainter.cpp
diff --git a/nodeeditor-src/nodeeditor/src/DefaultNodePainter.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultNodePainter.cpp
rename from nodeeditor-src/nodeeditor/src/DefaultNodePainter.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultNodePainter.cpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeGraphicsObject.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeGraphicsObject.cpp
rename from nodeeditor-src/nodeeditor/src/NodeGraphicsObject.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeGraphicsObject.cpp
diff --git a/nodeeditor-src/nodeeditor/src/AbstractNodeGeometry.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/AbstractNodeGeometry.cpp
rename from nodeeditor-src/nodeeditor/src/AbstractNodeGeometry.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/AbstractNodeGeometry.cpp
diff --git a/nodeeditor-src/nodeeditor/src/ConnectionStyle.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionStyle.cpp
rename from nodeeditor-src/nodeeditor/src/ConnectionStyle.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionStyle.cpp
diff --git a/nodeeditor-src/nodeeditor/src/BasicGraphicsScene.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/BasicGraphicsScene.cpp
rename from nodeeditor-src/nodeeditor/src/BasicGraphicsScene.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/BasicGraphicsScene.cpp
diff --git a/nodeeditor-src/nodeeditor/src/UndoCommands.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/UndoCommands.cpp
rename from nodeeditor-src/nodeeditor/src/UndoCommands.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/UndoCommands.cpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeConnectionInteraction.hpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeConnectionInteraction.hpp
rename from nodeeditor-src/nodeeditor/src/NodeConnectionInteraction.hpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeConnectionInteraction.hpp
diff --git a/nodeeditor-src/nodeeditor/src/UndoCommands.hpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/UndoCommands.hpp
rename from nodeeditor-src/nodeeditor/src/UndoCommands.hpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/UndoCommands.hpp
diff --git a/nodeeditor-src/nodeeditor/src/DataFlowGraphModel.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DataFlowGraphModel.cpp
rename from nodeeditor-src/nodeeditor/src/DataFlowGraphModel.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DataFlowGraphModel.cpp
diff --git a/nodeeditor-src/nodeeditor/src/ConnectionPainter.hpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionPainter.hpp
rename from nodeeditor-src/nodeeditor/src/ConnectionPainter.hpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionPainter.hpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeDelegateModelRegistry.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeDelegateModelRegistry.cpp
rename from nodeeditor-src/nodeeditor/src/NodeDelegateModelRegistry.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeDelegateModelRegistry.cpp
diff --git a/nodeeditor-src/nodeeditor/src/DefaultHorizontalNodeGeometry.hpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultHorizontalNodeGeometry.hpp
rename from nodeeditor-src/nodeeditor/src/DefaultHorizontalNodeGeometry.hpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultHorizontalNodeGeometry.hpp
diff --git a/nodeeditor-src/nodeeditor/src/ConnectionState.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionState.cpp
rename from nodeeditor-src/nodeeditor/src/ConnectionState.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionState.cpp
diff --git a/nodeeditor-src/nodeeditor/src/DefaultVerticalNodeGeometry.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultVerticalNodeGeometry.cpp
rename from nodeeditor-src/nodeeditor/src/DefaultVerticalNodeGeometry.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultVerticalNodeGeometry.cpp
diff --git a/nodeeditor-src/nodeeditor/src/DefaultVerticalNodeGeometry.hpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultVerticalNodeGeometry.hpp
rename from nodeeditor-src/nodeeditor/src/DefaultVerticalNodeGeometry.hpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultVerticalNodeGeometry.hpp
