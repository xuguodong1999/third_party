Subject: [PATCH] third_party-changes
---
Index: ggml-src/ggml/include/ggml-cuda.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ggml-src/ggml/include/ggml-cuda.h b/ggml-src/ggml/include/ggml-cuda.h
--- a/ggml-src/ggml/include/ggml-cuda.h	(revision 3e7e5e26f90fecf4f7c2808df7d94454630b219c)
+++ b/ggml-src/ggml/include/ggml-cuda.h	(date 1727618793389)
@@ -18,27 +18,27 @@
 #define GGML_CUDA_MAX_DEVICES       16
 
 // backend API
-GGML_API GGML_CALL ggml_backend_t ggml_backend_cuda_init(int device);
+GGML_CALL ggml_backend_t ggml_backend_cuda_init(int device);
 
-GGML_API GGML_CALL bool ggml_backend_is_cuda(ggml_backend_t backend);
+GGML_CALL bool ggml_backend_is_cuda(ggml_backend_t backend);
 
 // device buffer
-GGML_API GGML_CALL ggml_backend_buffer_type_t ggml_backend_cuda_buffer_type(int device);
+GGML_CALL ggml_backend_buffer_type_t ggml_backend_cuda_buffer_type(int device);
 
 // split tensor buffer that splits matrices by rows across multiple devices
-GGML_API GGML_CALL ggml_backend_buffer_type_t ggml_backend_cuda_split_buffer_type(const float * tensor_split);
+GGML_CALL ggml_backend_buffer_type_t ggml_backend_cuda_split_buffer_type(const float * tensor_split);
 
 // pinned host buffer for use with the CPU backend for faster copies between CPU and GPU
-GGML_API GGML_CALL ggml_backend_buffer_type_t ggml_backend_cuda_host_buffer_type(void);
+GGML_CALL ggml_backend_buffer_type_t ggml_backend_cuda_host_buffer_type(void);
 
-GGML_API GGML_CALL int  ggml_backend_cuda_get_device_count(void);
-GGML_API GGML_CALL void ggml_backend_cuda_get_device_description(int device, char * description, size_t description_size);
-GGML_API GGML_CALL void ggml_backend_cuda_get_device_memory(int device, size_t * free, size_t * total);
+GGML_CALL int  ggml_backend_cuda_get_device_count(void);
+GGML_CALL void ggml_backend_cuda_get_device_description(int device, char * description, size_t description_size);
+GGML_CALL void ggml_backend_cuda_get_device_memory(int device, size_t * free, size_t * total);
 
-GGML_API GGML_CALL bool ggml_backend_cuda_register_host_buffer(void * buffer, size_t size);
-GGML_API GGML_CALL void ggml_backend_cuda_unregister_host_buffer(void * buffer);
+GGML_CALL bool ggml_backend_cuda_register_host_buffer(void * buffer, size_t size);
+GGML_CALL void ggml_backend_cuda_unregister_host_buffer(void * buffer);
 
-GGML_API void ggml_backend_cuda_log_set_callback(ggml_log_callback log_callback, void * user_data);
+void ggml_backend_cuda_log_set_callback(ggml_log_callback log_callback, void * user_data);
 #ifdef  __cplusplus
 }
 #endif
Index: fluentui-src/fluentui/src/Qt6/imports/FluentUI/Controls/FluIcon.qml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/Qt6/imports/FluentUI/Controls/FluIcon.qml b/fluentui-src/fluentui/src/Qt6/imports/FluentUI/Controls/FluIcon.qml
--- a/fluentui-src/fluentui/src/Qt6/imports/FluentUI/Controls/FluIcon.qml	(revision 4e4016ae3fed7d1a3534760b44313e8fb0b8fd29)
+++ b/fluentui-src/fluentui/src/Qt6/imports/FluentUI/Controls/FluIcon.qml	(date 1745662832946)
@@ -16,6 +16,6 @@
     opacity: iconSource>0
     FontLoader{
         id: font_loader
-        source: "qrc:/qt/qml/FluentUI/Font/FluentIcons.ttf"
+        source: "qrc:/FluentUI/Font/FluentIcons.ttf"
     }
 }
Index: svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns_utils.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns_utils.hpp b/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns_utils.hpp
new file mode 100644
--- /dev/null	(date 1745583016070)
+++ b/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns_utils.hpp	(date 1745583016070)
@@ -0,0 +1,122 @@
+#ifndef RAPIDXML_NS_UTILS_HPP_INCLUDED
+#define RAPIDXML_NS_UTILS_HPP_INCLUDED
+
+// Copyright (C) 2006, 2009 Marcin Kalicinski
+// Version 1.13
+// Revision $DateTime: 2009/05/15 23:02:39 $
+//! \file rapidxml_utils.hpp This file contains high-level rapidxml utilities that can be useful
+//! in certain simple scenarios. They should probably not be used if maximizing performance is the main objective.
+
+#include "rapidxml_ns.hpp"
+#include <vector>
+#include <string>
+#include <fstream>
+#include <stdexcept>
+
+namespace rapidxml_ns
+{
+
+    //! Represents data loaded from a file
+    template<class Ch = char>
+    class file
+    {
+
+    public:
+
+        //! Loads file into the memory. Data will be automatically destroyed by the destructor.
+        //! \param filename Filename to load.
+        file(const char *filename)
+        {
+            using namespace std;
+
+            // Open stream
+            basic_ifstream<Ch> stream(filename, ios::binary);
+            if (!stream)
+                throw runtime_error(string("cannot open file ") + filename);
+            stream.unsetf(ios::skipws);
+
+            // Determine stream size
+            stream.seekg(0, ios::end);
+            size_t size = stream.tellg();
+            stream.seekg(0);
+
+            // Load data and add terminating 0
+            m_data.resize(size + 1);
+            stream.read(&m_data.front(), static_cast<streamsize>(size));
+            m_data[size] = 0;
+        }
+
+        //! Loads file into the memory. Data will be automatically destroyed by the destructor
+        //! \param stream Stream to load from
+        file(std::basic_istream<Ch> &stream)
+        {
+            using namespace std;
+
+            // Load data and add terminating 0
+            stream.unsetf(ios::skipws);
+            m_data.assign(istreambuf_iterator<Ch>(stream), istreambuf_iterator<Ch>());
+            if (stream.fail() || stream.bad())
+                throw runtime_error("error reading stream");
+            m_data.push_back(0);
+        }
+
+        //! Gets file data.
+        //! \return Pointer to data of file.
+        Ch *data()
+        {
+            return &m_data.front();
+        }
+
+        //! Gets file data.
+        //! \return Pointer to data of file.
+        const Ch *data() const
+        {
+            return &m_data.front();
+        }
+
+        //! Gets file data size.
+        //! \return Size of file data, in characters.
+        std::size_t size() const
+        {
+            return m_data.size();
+        }
+
+    private:
+
+        std::vector<Ch> m_data;   // File data
+
+    };
+
+    //! Counts children of node. Time complexity is O(n).
+    //! \return Number of children of node
+    template<class Ch>
+    inline std::size_t count_children(xml_node<Ch> *node)
+    {
+        xml_node<Ch> *child = node->first_node();
+        std::size_t count = 0;
+        while (child)
+        {
+            ++count;
+            child = child->next_sibling();
+        }
+        return count;
+    }
+
+    //! Counts attributes of node. Time complexity is O(n).
+    //! \return Number of attributes of node
+    template<class Ch>
+    inline std::size_t count_attributes(xml_node<Ch> *node)
+    {
+        xml_attribute<Ch> *attr = node->first_attribute();
+        std::size_t count = 0;
+        while (attr)
+        {
+            ++count;
+            attr = attr->next_attribute();
+        }
+        return count;
+    }
+
+}
+
+#endif
Index: opencv-src/opencv/modules/highgui/src/window_QT.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/highgui/src/window_QT.cpp b/opencv-src/opencv/modules/highgui/src/window_QT.cpp
--- a/opencv-src/opencv/modules/highgui/src/window_QT.cpp	(revision 31b0eeea0b44b370fd0712312df4214d4ae1b158)
+++ b/opencv-src/opencv/modules/highgui/src/window_QT.cpp	(date 1745583015836)
@@ -438,7 +438,7 @@
 
     //This is not a very clean way to do the stuff. Indeed, QAction automatically generate toolTil (QLabel)
     //that can be grabbed here and crash the code at 'w->param_name==name'.
-    foreach (QWidget* widget, QApplication::topLevelWidgets())
+    Q_FOREACH (QWidget* widget, QApplication::topLevelWidgets())
     {
         if (widget->isWindow() && !widget->parentWidget())//is a window without parent
         {
@@ -529,7 +529,7 @@
     //"For any GUI application using Qt, there is precisely one QApplication object"
     if (!QApplication::instance())
     {
-#if QT_VERSION >= QT_VERSION_CHECK(5, 6, 0)
+#if QT_VERSION >= QT_VERSION_CHECK(5, 6, 0) and QT_VERSION <= QT_VERSION_CHECK(6, 0, 0)
         QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling, true);
 #endif
         new QApplication(*c, v);
@@ -1182,7 +1182,7 @@
 void GuiReceiver::enablePropertiesButtonEachWindow()
 {
     //For each window, enable window property button
-    foreach (QWidget* widget, QApplication::topLevelWidgets())
+    Q_FOREACH (QWidget* widget, QApplication::topLevelWidgets())
     {
         if (widget->isWindow() && !widget->parentWidget()) //is a window without parent
         {
@@ -2133,7 +2133,7 @@
     myToolBar = new QToolBar(this);
     myToolBar->setFloatable(false); //is not a window
 
-    foreach (QAction *a, vect_QActions)
+    Q_FOREACH (QAction *a, vect_QActions)
         myToolBar->addAction(a);
 }
 
@@ -2800,7 +2800,7 @@
     {
         QMenu menu(this);
 
-        foreach (QAction *a, centralWidget->vect_QActions)
+        Q_FOREACH (QAction *a, centralWidget->vect_QActions)
             menu.addAction(a);
 
         menu.exec(evnt->globalPos());
Index: svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns_print.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns_print.hpp b/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns_print.hpp
new file mode 100644
--- /dev/null	(date 1745583016070)
+++ b/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns_print.hpp	(date 1745583016070)
@@ -0,0 +1,432 @@
+#ifndef RAPIDXML_NS_PRINT_HPP_INCLUDED
+#define RAPIDXML_NS_PRINT_HPP_INCLUDED
+
+// Copyright (C) 2006, 2009 Marcin Kalicinski
+// Version 1.13
+// Revision $DateTime: 2009/05/13 01:46:17 $
+//! \file rapidxml_ns_print.hpp This file contains rapidxml printer implementation
+
+#include "rapidxml_ns.hpp"
+
+// Only include streams if not disabled
+#ifndef RAPIDXML_NO_STREAMS
+    #include <ostream>
+    #include <iterator>
+#endif
+
+namespace rapidxml_ns
+{
+
+    ///////////////////////////////////////////////////////////////////////
+    // Printing flags
+
+    const int print_no_indenting = 0x1;   //!< Printer flag instructing the printer to suppress indenting of XML. See print() function.
+
+    ///////////////////////////////////////////////////////////////////////
+    // Internal
+
+    //! \cond internal
+    namespace internal
+    {
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Internal character operations
+
+        // Copy characters from given range to given output iterator
+        template<class OutIt, class Ch>
+        inline OutIt copy_chars(const Ch *begin, const Ch *end, OutIt out)
+        {
+            while (begin != end)
+                *out++ = *begin++;
+            return out;
+        }
+
+        // Copy characters from given range to given output iterator and expand
+        // characters into references (&lt; &gt; &apos; &quot; &amp;)
+        template<class OutIt, class Ch>
+        inline OutIt copy_and_expand_chars(const Ch *begin, const Ch *end, Ch noexpand, OutIt out)
+        {
+            while (begin != end)
+            {
+                if (*begin == noexpand)
+                {
+                    *out++ = *begin;    // No expansion, copy character
+                }
+                else
+                {
+                    switch (*begin)
+                    {
+                    case Ch('<'):
+                        *out++ = Ch('&'); *out++ = Ch('l'); *out++ = Ch('t'); *out++ = Ch(';');
+                        break;
+                    case Ch('>'):
+                        *out++ = Ch('&'); *out++ = Ch('g'); *out++ = Ch('t'); *out++ = Ch(';');
+                        break;
+                    case Ch('\''):
+                        *out++ = Ch('&'); *out++ = Ch('a'); *out++ = Ch('p'); *out++ = Ch('o'); *out++ = Ch('s'); *out++ = Ch(';');
+                        break;
+                    case Ch('"'):
+                        *out++ = Ch('&'); *out++ = Ch('q'); *out++ = Ch('u'); *out++ = Ch('o'); *out++ = Ch('t'); *out++ = Ch(';');
+                        break;
+                    case Ch('&'):
+                        *out++ = Ch('&'); *out++ = Ch('a'); *out++ = Ch('m'); *out++ = Ch('p'); *out++ = Ch(';');
+                        break;
+                    default:
+                        *out++ = *begin;    // No expansion, copy character
+                    }
+                }
+                ++begin;    // Step to next character
+            }
+            return out;
+        }
+
+        // Fill given output iterator with repetitions of the same character
+        template<class OutIt, class Ch>
+        inline OutIt fill_chars(OutIt out, int n, Ch ch)
+        {
+            for (int i = 0; i < n; ++i)
+                *out++ = ch;
+            return out;
+        }
+
+        // Find character
+        template<class Ch, Ch ch>
+        inline bool find_char(const Ch *begin, const Ch *end)
+        {
+            while (begin != end)
+                if (*begin++ == ch)
+                    return true;
+            return false;
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Internal printing operations
+
+        // Printing function declarations (fix for clang bug in gcc and others: http://sourceforge.net/p/rapidxml/bugs/16/)
+
+        template<class OutIt, class Ch> inline OutIt print_children(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_element_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_data_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_cdata_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_declaration_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_comment_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_doctype_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_pi_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+
+        // Print node
+        template<class OutIt, class Ch>
+        inline OutIt print_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            // Print proper node type
+            switch (node->type())
+            {
+
+            // Document
+            case node_document:
+                out = print_children(out, node, flags, indent);
+                break;
+
+            // Element
+            case node_element:
+                out = print_element_node(out, node, flags, indent);
+                break;
+
+            // Data
+            case node_data:
+                out = print_data_node(out, node, flags, indent);
+                break;
+
+            // CDATA
+            case node_cdata:
+                out = print_cdata_node(out, node, flags, indent);
+                break;
+
+            // Declaration
+            case node_declaration:
+                out = print_declaration_node(out, node, flags, indent);
+                break;
+
+            // Comment
+            case node_comment:
+                out = print_comment_node(out, node, flags, indent);
+                break;
+
+            // Doctype
+            case node_doctype:
+                out = print_doctype_node(out, node, flags, indent);
+                break;
+
+            // Pi
+            case node_pi:
+                out = print_pi_node(out, node, flags, indent);
+                break;
+
+                // Unknown
+            default:
+                assert(0);
+                break;
+            }
+
+            // If indenting not disabled, add line break after node
+            if (!(flags & print_no_indenting))
+                *out = Ch('\n'), ++out;
+
+            // Return modified iterator
+            return out;
+        }
+
+        // Print children of the node
+        template<class OutIt, class Ch>
+        inline OutIt print_children(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            for (xml_node<Ch> *child = node->first_node(); child; child = child->next_sibling())
+                out = print_node(out, child, flags, indent);
+            return out;
+        }
+
+        // Print attributes of the node
+        template<class OutIt, class Ch>
+        inline OutIt print_attributes(OutIt out, const xml_node<Ch> *node, int flags)
+        {
+            for (xml_attribute<Ch> *attribute = node->first_attribute(); attribute; attribute = attribute->next_attribute())
+            {
+                if (attribute->name() && attribute->value())
+                {
+                    // Print attribute name
+                    *out = Ch(' '), ++out;
+                    out = copy_chars(attribute->name(), attribute->name() + attribute->name_size(), out);
+                    *out = Ch('='), ++out;
+                    // Print attribute value using appropriate quote type
+                    if (find_char<Ch, Ch('"')>(attribute->value(), attribute->value() + attribute->value_size()))
+                    {
+                        *out = Ch('\''), ++out;
+                        out = copy_and_expand_chars(attribute->value(), attribute->value() + attribute->value_size(), Ch('"'), out);
+                        *out = Ch('\''), ++out;
+                    }
+                    else
+                    {
+                        *out = Ch('"'), ++out;
+                        out = copy_and_expand_chars(attribute->value(), attribute->value() + attribute->value_size(), Ch('\''), out);
+                        *out = Ch('"'), ++out;
+                    }
+                }
+            }
+            return out;
+        }
+
+        // Print data node
+        template<class OutIt, class Ch>
+        inline OutIt print_data_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            assert(node->type() == node_data);
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            out = copy_and_expand_chars(node->value(), node->value() + node->value_size(), Ch(0), out);
+            return out;
+        }
+
+        // Print data node
+        template<class OutIt, class Ch>
+        inline OutIt print_cdata_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            assert(node->type() == node_cdata);
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            *out = Ch('<'); ++out;
+            *out = Ch('!'); ++out;
+            *out = Ch('['); ++out;
+            *out = Ch('C'); ++out;
+            *out = Ch('D'); ++out;
+            *out = Ch('A'); ++out;
+            *out = Ch('T'); ++out;
+            *out = Ch('A'); ++out;
+            *out = Ch('['); ++out;
+            out = copy_chars(node->value(), node->value() + node->value_size(), out);
+            *out = Ch(']'); ++out;
+            *out = Ch(']'); ++out;
+            *out = Ch('>'); ++out;
+            return out;
+        }
+
+        // Print element node
+        template<class OutIt, class Ch>
+        inline OutIt print_element_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            assert(node->type() == node_element);
+
+            // Print element name and attributes, if any
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            *out = Ch('<'), ++out;
+            out = copy_chars(node->name(), node->name() + node->name_size(), out);
+            out = print_attributes(out, node, flags);
+
+            // If node is childless
+            if (node->value_size() == 0 && !node->first_node())
+            {
+                // Print childless node tag ending
+                *out = Ch('/'), ++out;
+                *out = Ch('>'), ++out;
+            }
+            else
+            {
+                // Print normal node tag ending
+                *out = Ch('>'), ++out;
+
+                // Test if node contains a single data node only (and no other nodes)
+                xml_node<Ch> *child = node->first_node();
+                if (!child)
+                {
+                    // If node has no children, only print its value without indenting
+                    out = copy_and_expand_chars(node->value(), node->value() + node->value_size(), Ch(0), out);
+                }
+                else if (child->next_sibling() == 0 && child->type() == node_data)
+                {
+                    // If node has a sole data child, only print its value without indenting
+                    out = copy_and_expand_chars(child->value(), child->value() + child->value_size(), Ch(0), out);
+                }
+                else
+                {
+                    // Print all children with full indenting
+                    if (!(flags & print_no_indenting))
+                        *out = Ch('\n'), ++out;
+                    out = print_children(out, node, flags, indent + 1);
+                    if (!(flags & print_no_indenting))
+                        out = fill_chars(out, indent, Ch('\t'));
+                }
+
+                // Print node end
+                *out = Ch('<'), ++out;
+                *out = Ch('/'), ++out;
+                out = copy_chars(node->name(), node->name() + node->name_size(), out);
+                *out = Ch('>'), ++out;
+            }
+            return out;
+        }
+
+        // Print declaration node
+        template<class OutIt, class Ch>
+        inline OutIt print_declaration_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            // Print declaration start
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            *out = Ch('<'), ++out;
+            *out = Ch('?'), ++out;
+            *out = Ch('x'), ++out;
+            *out = Ch('m'), ++out;
+            *out = Ch('l'), ++out;
+
+            // Print attributes
+            out = print_attributes(out, node, flags);
+
+            // Print declaration end
+            *out = Ch('?'), ++out;
+            *out = Ch('>'), ++out;
+
+            return out;
+        }
+
+        // Print comment node
+        template<class OutIt, class Ch>
+        inline OutIt print_comment_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            assert(node->type() == node_comment);
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            *out = Ch('<'), ++out;
+            *out = Ch('!'), ++out;
+            *out = Ch('-'), ++out;
+            *out = Ch('-'), ++out;
+            out = copy_chars(node->value(), node->value() + node->value_size(), out);
+            *out = Ch('-'), ++out;
+            *out = Ch('-'), ++out;
+            *out = Ch('>'), ++out;
+            return out;
+        }
+
+        // Print doctype node
+        template<class OutIt, class Ch>
+        inline OutIt print_doctype_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            assert(node->type() == node_doctype);
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            *out = Ch('<'), ++out;
+            *out = Ch('!'), ++out;
+            *out = Ch('D'), ++out;
+            *out = Ch('O'), ++out;
+            *out = Ch('C'), ++out;
+            *out = Ch('T'), ++out;
+            *out = Ch('Y'), ++out;
+            *out = Ch('P'), ++out;
+            *out = Ch('E'), ++out;
+            *out = Ch(' '), ++out;
+            out = copy_chars(node->value(), node->value() + node->value_size(), out);
+            *out = Ch('>'), ++out;
+            return out;
+        }
+
+        // Print pi node
+        template<class OutIt, class Ch>
+        inline OutIt print_pi_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            assert(node->type() == node_pi);
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            *out = Ch('<'), ++out;
+            *out = Ch('?'), ++out;
+            out = copy_chars(node->name(), node->name() + node->name_size(), out);
+            *out = Ch(' '), ++out;
+            out = copy_chars(node->value(), node->value() + node->value_size(), out);
+            *out = Ch('?'), ++out;
+            *out = Ch('>'), ++out;
+            return out;
+        }
+
+    }
+    //! \endcond
+
+    ///////////////////////////////////////////////////////////////////////////
+    // Printing
+
+    //! Prints XML to given output iterator.
+    //! \param out Output iterator to print to.
+    //! \param node Node to be printed. Pass xml_document to print entire document.
+    //! \param flags Flags controlling how XML is printed.
+    //! \return Output iterator pointing to position immediately after last character of printed text.
+    template<class OutIt, class Ch>
+    inline OutIt print(OutIt out, const xml_node<Ch> &node, int flags = 0)
+    {
+        return internal::print_node(out, &node, flags, 0);
+    }
+
+#ifndef RAPIDXML_NO_STREAMS
+
+    //! Prints XML to given output stream.
+    //! \param out Output stream to print to.
+    //! \param node Node to be printed. Pass xml_document to print entire document.
+    //! \param flags Flags controlling how XML is printed.
+    //! \return Output stream.
+    template<class Ch>
+    inline std::basic_ostream<Ch> &print(std::basic_ostream<Ch> &out, const xml_node<Ch> &node, int flags = 0)
+    {
+        print(std::ostream_iterator<Ch>(out), node, flags);
+        return out;
+    }
+
+    //! Prints formatted XML to given output stream. Uses default printing flags. Use print() function to customize printing process.
+    //! \param out Output stream to print to.
+    //! \param node Node to be printed.
+    //! \return Output stream.
+    template<class Ch>
+    inline std::basic_ostream<Ch> &operator <<(std::basic_ostream<Ch> &out, const xml_node<Ch> &node)
+    {
+        return print(out, node);
+    }
+
+#endif
+
+}
+
+#endif
Index: ggml-src/ggml/include/ggml.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ggml-src/ggml/include/ggml.h b/ggml-src/ggml/include/ggml.h
--- a/ggml-src/ggml/include/ggml.h	(revision 3e7e5e26f90fecf4f7c2808df7d94454630b219c)
+++ b/ggml-src/ggml/include/ggml.h	(date 1727618793390)
@@ -187,6 +187,13 @@
 #    define GGML_API
 #endif
 
+#undef GGML_API
+#include <ggml_export.h>
+#undef GGML_DEPRECATED
+#ifndef GGML_API
+#define GGML_API GGML_EXPORT
+#endif
+
 #ifdef GGML_MULTIPLATFORM
 #    if defined(_WIN32)
 #        define GGML_CALL
@@ -1521,7 +1528,7 @@
         "use ggml_rope_ext_inplace instead");
 
     // compute correction dims for YaRN RoPE scaling
-    GGML_CALL void ggml_rope_yarn_corr_dims(
+    GGML_API GGML_CALL void ggml_rope_yarn_corr_dims(
         int n_dims, int n_ctx_orig, float freq_base, float beta_fast, float beta_slow, float dims[2]);
 
     // rotary position embedding backward, i.e compute dx from dy
Index: svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns.hpp b/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns.hpp
new file mode 100644
--- /dev/null	(date 1745583016070)
+++ b/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns.hpp	(date 1745583016070)
@@ -0,0 +1,3113 @@
+#ifndef RAPIDXML_NS_HPP_INCLUDED
+#define RAPIDXML_NS_HPP_INCLUDED
+
+// Copyright (C) 2006, 2009 Marcin Kalicinski
+// Version 1.13
+// Revision $DateTime: 2009/05/13 01:46:17 $
+//! \file rapidxml_ns.hpp This file contains rapidxml_ns parser and DOM implementation
+
+// If standard library is disabled, user must provide implementations of required functions and typedefs
+#if !defined(RAPIDXML_NO_STDLIB)
+    #include <cstdlib>      // For std::size_t
+    #include <cassert>      // For assert
+    #include <new>          // For placement new
+    #include <vector>
+#endif
+
+// On MSVC, disable "conditional expression is constant" warning (level 4).
+// This warning is almost impossible to avoid with certain types of templated code
+#ifdef _MSC_VER
+    #pragma warning(push)
+    #pragma warning(disable:4127)   // Conditional expression is constant
+#endif
+
+///////////////////////////////////////////////////////////////////////////
+// RAPIDXML_PARSE_ERROR
+
+#if defined(RAPIDXML_NO_EXCEPTIONS)
+
+#define RAPIDXML_PARSE_ERROR(what, where) { parse_error_handler(what, where); assert(0); }
+
+namespace rapidxml_ns
+{
+    //! When exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS,
+    //! this function is called to notify user about the error.
+    //! It must be defined by the user.
+    //! <br><br>
+    //! This function cannot return. If it does, the results are undefined.
+    //! <br><br>
+    //! A very simple definition might look like that:
+    //! <pre>
+    //! void %rapidxml_ns::%parse_error_handler(const char *what, void *where)
+    //! {
+    //!     std::cout << "Parse error: " << what << "\n";
+    //!     std::abort();
+    //! }
+    //! </pre>
+    //! \param what Human readable description of the error.
+    //! \param where Pointer to character data where error was detected.
+    void parse_error_handler(const char *what, void *where);
+}
+
+#else
+
+#include <exception>    // For std::exception
+
+#define RAPIDXML_PARSE_ERROR(what, where) throw parse_error(what, where)
+
+namespace rapidxml_ns
+{
+
+    //! Parse error exception.
+    //! This exception is thrown by the parser when an error occurs.
+    //! Use what() function to get human-readable error message.
+    //! Use where() function to get a pointer to position within source text where error was detected.
+    //! <br><br>
+    //! If throwing exceptions by the parser is undesirable,
+    //! it can be disabled by defining RAPIDXML_NO_EXCEPTIONS macro before rapidxml_ns.hpp is included.
+    //! This will cause the parser to call rapidxml_ns::parse_error_handler() function instead of throwing an exception.
+    //! This function must be defined by the user.
+    //! <br><br>
+    //! This class derives from <code>std::exception</code> class.
+    class parse_error: public std::exception
+    {
+
+    public:
+
+        //! Constructs parse error
+        parse_error(const char *what, void *where)
+            : m_what(what)
+            , m_where(where)
+        {
+        }
+
+        //! Gets human readable description of error.
+        //! \return Pointer to null terminated description of the error.
+        virtual const char *what() const throw()
+        {
+            return m_what;
+        }
+
+        //! Gets pointer to character data where error happened.
+        //! Ch should be the same as char type of xml_document that produced the error.
+        //! \return Pointer to location within the parsed string where error occured.
+        template<class Ch>
+        Ch *where() const
+        {
+            return reinterpret_cast<Ch *>(m_where);
+        }
+
+    private:
+
+        const char *m_what;
+        void *m_where;
+
+    };
+}
+
+#endif
+
+///////////////////////////////////////////////////////////////////////////
+// Pool sizes
+
+#ifndef RAPIDXML_STATIC_POOL_SIZE
+    // Size of static memory block of memory_pool.
+    // Define RAPIDXML_STATIC_POOL_SIZE before including rapidxml_ns.hpp if you want to override the default value.
+    // No dynamic memory allocations are performed by memory_pool until static memory is exhausted.
+    #define RAPIDXML_STATIC_POOL_SIZE (64 * 1024)
+#endif
+
+#ifndef RAPIDXML_DYNAMIC_POOL_SIZE
+    // Size of dynamic memory block of memory_pool.
+    // Define RAPIDXML_DYNAMIC_POOL_SIZE before including rapidxml_ns.hpp if you want to override the default value.
+    // After the static block is exhausted, dynamic blocks with approximately this size are allocated by memory_pool.
+    #define RAPIDXML_DYNAMIC_POOL_SIZE (64 * 1024)
+#endif
+
+#ifndef RAPIDXML_ALIGNMENT
+    // Memory allocation alignment.
+    // Define RAPIDXML_ALIGNMENT before including rapidxml_ns.hpp if you want to override the default value, which is the size of pointer.
+    // All memory allocations for nodes, attributes and strings will be aligned to this value.
+    // This must be a power of 2 and at least 1, otherwise memory_pool will not work.
+    #define RAPIDXML_ALIGNMENT sizeof(void *)
+#endif
+
+namespace rapidxml_ns
+{
+    // Forward declarations
+    template<class Ch> class xml_base;
+    template<class Ch> class xml_node;
+    template<class Ch> class xml_attribute;
+    template<class Ch> class xml_document;
+
+    //! Enumeration listing all node types produced by the parser.
+    //! Use xml_node::type() function to query node type.
+    enum node_type
+    {
+        node_document,      //!< A document node. Name and value are empty.
+        node_element,       //!< An element node. Name contains element name. Value contains text of first data node.
+        node_data,          //!< A data node. Name is empty. Value contains data text.
+        node_cdata,         //!< A CDATA node. Name is empty. Value contains data text.
+        node_comment,       //!< A comment node. Name is empty. Value contains comment text.
+        node_declaration,   //!< A declaration node. Name and value are empty. Declaration parameters (version, encoding and standalone) are in node attributes.
+        node_doctype,       //!< A DOCTYPE node. Name is empty. Value contains DOCTYPE text.
+        node_pi             //!< A PI node. Name contains target. Value contains instructions.
+    };
+
+    ///////////////////////////////////////////////////////////////////////
+    // Parsing flags
+
+    //! Parse flag instructing the parser to not create data nodes.
+    //! Text of first data node will still be placed in value of parent element, unless rapidxml_ns::parse_no_element_values flag is also specified.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_no_data_nodes = 0x1;
+
+    //! Parse flag instructing the parser to not use text of first data node as a value of parent element.
+    //! Can be combined with other flags by use of | operator.
+    //! Note that child data nodes of element node take precendence over its value when printing.
+    //! That is, if element has one or more child data nodes <em>and</em> a value, the value will be ignored.
+    //! Use rapidxml_ns::parse_no_data_nodes flag to prevent creation of data nodes if you want to manipulate data using values of elements.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_no_element_values = 0x2;
+
+    //! Parse flag instructing the parser to not place zero terminators after strings in the source text.
+    //! By default zero terminators are placed, modifying source text.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_no_string_terminators = 0x4;
+
+    //! Parse flag instructing the parser to not translate entities in the source text.
+    //! By default entities are translated, modifying source text.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_no_entity_translation = 0x8;
+
+    //! Parse flag instructing the parser to disable UTF-8 handling and assume plain 8 bit characters.
+    //! By default, UTF-8 handling is enabled.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_no_utf8 = 0x10;
+
+    //! Parse flag instructing the parser to create XML declaration node.
+    //! By default, declaration node is not created.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_declaration_node = 0x20;
+
+    //! Parse flag instructing the parser to create comments nodes.
+    //! By default, comment nodes are not created.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_comment_nodes = 0x40;
+
+    //! Parse flag instructing the parser to create DOCTYPE node.
+    //! By default, doctype node is not created.
+    //! Although W3C specification allows at most one DOCTYPE node, RapidXml will silently accept documents with more than one.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_doctype_node = 0x80;
+
+    //! Parse flag instructing the parser to create PI nodes.
+    //! By default, PI nodes are not created.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_pi_nodes = 0x100;
+
+    //! Parse flag instructing the parser to validate closing tag names.
+    //! If not set, name inside closing tag is irrelevant to the parser.
+    //! By default, closing tags are not validated.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_validate_closing_tags = 0x200;
+
+    //! Parse flag instructing the parser to trim all leading and trailing whitespace of data nodes.
+    //! By default, whitespace is not trimmed.
+    //! This flag does not cause the parser to modify source text.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_trim_whitespace = 0x400;
+
+    //! Parse flag instructing the parser to condense all whitespace runs of data nodes to a single space character.
+    //! Trimming of leading and trailing whitespace of data is controlled by rapidxml_ns::parse_trim_whitespace flag.
+    //! By default, whitespace is not normalized.
+    //! If this flag is specified, source text will be modified.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_normalize_whitespace = 0x800;
+
+    //! Parse flag instructing the parser to skip assigning XML namespace URI to elements and attributes.
+    //! I.e. to behave like original RapidXML parser.
+    //! By default, namespaces are set.
+    //! This flag does not cause the parser to modify source text.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_no_namespace = 0x1000;
+
+    // Compound flags
+
+    //! Parse flags which represent default behaviour of the parser.
+    //! This is always equal to 0, so that all other flags can be simply ored together.
+    //! Normally there is no need to inconveniently disable flags by anding with their negated (~) values.
+    //! This also means that meaning of each flag is a <i>negation</i> of the default setting.
+    //! For example, if flag name is rapidxml_ns::parse_no_utf8, it means that utf-8 is <i>enabled</i> by default,
+    //! and using the flag will disable it.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_default = 0;
+
+    //! A combination of parse flags that forbids any modifications of the source text.
+    //! This also results in faster parsing. However, note that the following will occur:
+    //! <ul>
+    //! <li>names and values of nodes will not be zero terminated, you have to use xml_base::name_size() and xml_base::value_size() functions to determine where name and value ends</li>
+    //! <li>entities will not be translated</li>
+    //! <li>whitespace will not be normalized</li>
+    //! </ul>
+    //! See xml_document::parse() function.
+    const int parse_non_destructive = parse_no_string_terminators | parse_no_entity_translation;
+
+    //! A combination of parse flags resulting in fastest possible parsing, without sacrificing important data.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_fastest = parse_non_destructive | parse_no_data_nodes;
+
+    //! A combination of parse flags resulting in largest amount of data being extracted.
+    //! This usually results in slowest parsing.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_full = parse_declaration_node | parse_comment_nodes | parse_doctype_node | parse_pi_nodes | parse_validate_closing_tags;
+
+    template<class Ch>
+    struct xml_namespace
+    {
+        static const size_t prefix_size = 3;
+
+        static Ch const * prefix()
+        {
+            static const Ch value[prefix_size] = {'x', 'm', 'l'};
+            return value;
+        }
+
+        static const size_t uri_size = 36;
+
+        // There should be only one instance of "http://www.w3.org/XML/1998/namespace" string, so
+        // that it can be compared as pointer
+        static Ch const * uri()
+        {
+            static const Ch value[uri_size] =
+                {'h', 't', 't', 'p', ':', '/', '/', 'w', 'w', 'w', '.', 'w', '3', '.', 'o', 'r', 'g',
+                 '/', 'X', 'M', 'L', '/', '1', '9', '9', '8', '/', 'n', 'a', 'm', 'e', 's', 'p', 'a', 'c', 'e'};
+            return value;
+        }
+    };
+
+    template<class Ch>
+    struct xmlns_namespace
+    {
+        static const size_t prefix_size = 5;
+
+        static Ch const * prefix()
+        {
+            static const Ch value[prefix_size] = {'x', 'm', 'l', 'n', 's'};
+            return value;
+        }
+
+        static const size_t uri_size = 29;
+
+        // There should be only one instance of "http://www.w3.org/2000/xmlns/" string, so
+        // that it can be compared as pointer
+        static Ch const * uri()
+        {
+            static const Ch value[uri_size] =
+                {'h', 't', 't', 'p', ':', '/', '/', 'w', 'w', 'w', '.', 'w', '3', '.', 'o', 'r', 'g',
+                 '/', '2', '0', '0', '0', '/', 'x', 'm', 'l', 'n', 's', '/'};
+            return value;
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////
+    // Internals
+
+    //! \cond internal
+    namespace internal
+    {
+
+        // Struct that contains lookup tables for the parser
+        // It must be a template to allow correct linking (because it has static data members, which are defined in a header file).
+        template<int Dummy>
+        struct lookup_tables
+        {
+            static const unsigned char lookup_whitespace[256];              // Whitespace table
+            static const unsigned char lookup_node_name[256];               // Node name table
+            static const unsigned char lookup_node_ncname[256];             // Node NCName table
+            static const unsigned char lookup_text[256];                    // Text table
+            static const unsigned char lookup_text_pure_no_ws[256];         // Text table
+            static const unsigned char lookup_text_pure_with_ws[256];       // Text table
+            static const unsigned char lookup_attribute_name[256];          // Attribute name table
+            static const unsigned char lookup_attribute_ncname[256];        // Attribute NCName table
+            static const unsigned char lookup_attribute_data_1[256];        // Attribute data table with single quote
+            static const unsigned char lookup_attribute_data_1_pure[256];   // Attribute data table with single quote
+            static const unsigned char lookup_attribute_data_2[256];        // Attribute data table with double quotes
+            static const unsigned char lookup_attribute_data_2_pure[256];   // Attribute data table with double quotes
+            static const unsigned char lookup_digits[256];                  // Digits
+            static const unsigned char lookup_upcase[256];                  // To uppercase conversion table for ASCII characters
+        };
+
+        // Find length of the string
+        template<class Ch>
+        inline std::size_t measure(const Ch *p)
+        {
+            const Ch *tmp = p;
+            while (*tmp)
+                ++tmp;
+            return tmp - p;
+        }
+
+        // Compare strings for equality
+        template<class Ch>
+        inline bool compare(const Ch *p1, std::size_t size1, const Ch *p2, std::size_t size2)
+        {
+            if (size1 != size2)
+                return false;
+            for (const Ch *end = p1 + size1; p1 < end; ++p1, ++p2)
+                if (*p1 != *p2)
+                    return false;
+            return true;
+        }
+
+        // Compare strings for equality with option to ignore case
+        template<class Ch>
+        inline bool compare(const Ch *p1, std::size_t size1, const Ch *p2, std::size_t size2, bool case_sensitive)
+        {
+            if (size1 != size2)
+                return false;
+            if (case_sensitive)
+            {
+                for (const Ch *end = p1 + size1; p1 < end; ++p1, ++p2)
+                    if (*p1 != *p2)
+                        return false;
+            }
+            else
+            {
+                for (const Ch *end = p1 + size1; p1 < end; ++p1, ++p2)
+                    if (lookup_tables<0>::lookup_upcase[static_cast<unsigned char>(*p1)] != lookup_tables<0>::lookup_upcase[static_cast<unsigned char>(*p2)])
+                        return false;
+            }
+            return true;
+        }
+
+        template<class Ch, class NamespaceStorage>
+        void assign_element_namespace_uris(xml_node<Ch> * element, NamespaceStorage & ns_storage)
+        {
+            xml_attribute<Ch> * first_prefixed_attribute = 0;
+            for (xml_attribute<Ch> *attr = element->first_attribute(); attr; attr = attr->next_attribute())
+            {
+                switch (attr->prefix_size())
+                {
+                case 0:
+                    if (compare(attr->name(), attr->name_size(),
+                        xmlns_namespace<Ch>::prefix(), xmlns_namespace<Ch>::prefix_size))
+                    {
+                        attr->namespace_uri(xmlns_namespace<Ch>::uri(), xmlns_namespace<Ch>::uri_size);
+                        ns_storage.set_default_namespace(attr);
+                    }
+                    continue;
+                case xml_namespace<Ch>::prefix_size:
+                    if (compare(attr->prefix(), attr->prefix_size(),
+                        xml_namespace<Ch>::prefix(), xml_namespace<Ch>::prefix_size))
+                    {
+                        attr->namespace_uri(xml_namespace<Ch>::uri(), xml_namespace<Ch>::uri_size);
+                        continue;
+                    }
+                    break;
+                case xmlns_namespace<Ch>::prefix_size:
+                    if (compare(attr->prefix(), attr->prefix_size(),
+                        xmlns_namespace<Ch>::prefix(), xmlns_namespace<Ch>::prefix_size))
+                    {
+                        attr->namespace_uri(xmlns_namespace<Ch>::uri(), xmlns_namespace<Ch>::uri_size);
+                        ns_storage.add_namespace_prefix(attr);
+                        continue;
+                    }
+                    break;
+                } // switch
+                if (!first_prefixed_attribute)
+                    first_prefixed_attribute = attr;
+            } // for
+            if (element->prefix_size() == 0)
+                ns_storage.set_element_default_namespace_uri(element);
+            else
+                ns_storage.set_node_namespace_uri_by_prefix(element);
+
+            for (; first_prefixed_attribute; first_prefixed_attribute = first_prefixed_attribute->next_attribute())
+                if (first_prefixed_attribute->prefix_size() > 0 && first_prefixed_attribute->namespace_uri_size() == 0)
+                    ns_storage.set_node_namespace_uri_by_prefix(first_prefixed_attribute);
+        }
+
+        template<class Ch>
+        class xml_namespace_processor
+        {
+        public:
+            class scope
+            {
+            public:
+                scope(xml_namespace_processor & processor)
+                    : m_processor(processor)
+                    , m_stack_position(processor.m_namespace_prefixes.size())
+                    , m_default_namespace(0)
+                {
+                }
+
+                scope(scope const & parent_scope)
+                    : m_processor(parent_scope.m_processor)
+                    , m_stack_position(m_processor.m_namespace_prefixes.size())
+                    , m_default_namespace(parent_scope.m_default_namespace)
+                {
+                }
+
+                ~scope()
+                {
+                    m_processor.m_namespace_prefixes.resize(m_stack_position);
+                }
+
+                void process_element(xml_node<Ch> * element)
+                {
+                    assign_element_namespace_uris(element, *this);
+                }
+
+                void set_default_namespace(xml_attribute<Ch> * ns_attr)
+                {
+                    m_default_namespace = ns_attr;
+                }
+
+                void add_namespace_prefix(xml_attribute<Ch> * ns_attr)
+                {
+                    m_processor.m_namespace_prefixes.push_back(ns_attr);
+                }
+
+                void set_element_default_namespace_uri(xml_node<Ch> * element) const
+                {
+                    if (m_default_namespace)
+                        element->namespace_uri(m_default_namespace->value(), m_default_namespace->value_size());
+                }
+
+                void set_node_namespace_uri_by_prefix(xml_base<Ch> * node) const
+                {
+                    Ch const * prefix = node->prefix();
+                    std::size_t prefix_size = node->prefix_size();
+                    for (typename xml_namespace_processor::xmlns_attributes_t::const_reverse_iterator
+                            it = m_processor.m_namespace_prefixes.rbegin();
+                            it != m_processor.m_namespace_prefixes.rend(); ++it)
+                        if (compare((*it)->local_name(), (*it)->local_name_size(), prefix, prefix_size))
+                        {
+                            node->namespace_uri((*it)->value(), (*it)->value_size());
+                            return;
+                        }
+                    RAPIDXML_PARSE_ERROR("No namespace definition found", 0);
+                }
+
+            private:
+                xml_namespace_processor & m_processor;
+                size_t const m_stack_position;
+                xml_attribute<Ch> * m_default_namespace;
+            };
+
+        private:
+            typedef std::vector<xml_attribute<Ch> *> xmlns_attributes_t;
+            xmlns_attributes_t m_namespace_prefixes;
+        };
+
+        template<class Ch>
+        class xml_namespace_processor_stub
+        {
+        public:
+          class scope
+          {
+          public:
+            scope(xml_namespace_processor_stub &)
+            {}
+
+            scope(scope const &)
+            {}
+
+            void process_element(xml_node<Ch> *) const
+            {}
+          };
+        };
+    }
+    //! \endcond
+
+    ///////////////////////////////////////////////////////////////////////
+    // Memory pool
+
+    //! This class is used by the parser to create new nodes and attributes, without overheads of dynamic memory allocation.
+    //! In most cases, you will not need to use this class directly.
+    //! However, if you need to create nodes manually or modify names/values of nodes,
+    //! you are encouraged to use memory_pool of relevant xml_document to allocate the memory.
+    //! Not only is this faster than allocating them by using <code>new</code> operator,
+    //! but also their lifetime will be tied to the lifetime of document,
+    //! possibly simplyfing memory management.
+    //! <br><br>
+    //! Call allocate_node() or allocate_attribute() functions to obtain new nodes or attributes from the pool.
+    //! You can also call allocate_string() function to allocate strings.
+    //! Such strings can then be used as names or values of nodes without worrying about their lifetime.
+    //! Note that there is no <code>free()</code> function -- all allocations are freed at once when clear() function is called,
+    //! or when the pool is destroyed.
+    //! <br><br>
+    //! It is also possible to create a standalone memory_pool, and use it
+    //! to allocate nodes, whose lifetime will not be tied to any document.
+    //! <br><br>
+    //! Pool maintains <code>RAPIDXML_STATIC_POOL_SIZE</code> bytes of statically allocated memory.
+    //! Until static memory is exhausted, no dynamic memory allocations are done.
+    //! When static memory is exhausted, pool allocates additional blocks of memory of size <code>RAPIDXML_DYNAMIC_POOL_SIZE</code> each,
+    //! by using global <code>new[]</code> and <code>delete[]</code> operators.
+    //! This behaviour can be changed by setting custom allocation routines.
+    //! Use set_allocator() function to set them.
+    //! <br><br>
+    //! Allocations for nodes, attributes and strings are aligned at <code>RAPIDXML_ALIGNMENT</code> bytes.
+    //! This value defaults to the size of pointer on target architecture.
+    //! <br><br>
+    //! To obtain absolutely top performance from the parser,
+    //! it is important that all nodes are allocated from a single, contiguous block of memory.
+    //! Otherwise, cache misses when jumping between two (or more) disjoint blocks of memory can slow down parsing quite considerably.
+    //! If required, you can tweak <code>RAPIDXML_STATIC_POOL_SIZE</code>, <code>RAPIDXML_DYNAMIC_POOL_SIZE</code> and <code>RAPIDXML_ALIGNMENT</code>
+    //! to obtain best wasted memory to performance compromise.
+    //! To do it, define their values before rapidxml_ns.hpp file is included.
+    //! \param Ch Character type of created nodes.
+    template<class Ch = char>
+    class memory_pool
+    {
+
+    public:
+
+        //! \cond internal
+        typedef void *(alloc_func)(std::size_t);       // Type of user-defined function used to allocate memory
+        typedef void (free_func)(void *);              // Type of user-defined function used to free memory
+        //! \endcond
+
+        //! Constructs empty pool with default allocator functions.
+        memory_pool()
+            : m_alloc_func(0)
+            , m_free_func(0)
+        {
+            init();
+        }
+
+        //! Destroys pool and frees all the memory.
+        //! This causes memory occupied by nodes allocated by the pool to be freed.
+        //! Nodes allocated from the pool are no longer valid.
+        ~memory_pool()
+        {
+            clear();
+        }
+
+        //! Allocates a new node from the pool, and optionally assigns name and value to it.
+        //! If the allocation request cannot be accomodated, this function will throw <code>std::bad_alloc</code>.
+        //! If exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, this function
+        //! will call rapidxml_ns::parse_error_handler() function.
+        //! \param type Type of node to create.
+        //! \param name Name to assign to the node, or 0 to assign no name.
+        //! \param value Value to assign to the node, or 0 to assign no value.
+        //! \param name_size Size of name to assign, or 0 to automatically calculate size from name string.
+        //! \param value_size Size of value to assign, or 0 to automatically calculate size from value string.
+        //! \return Pointer to allocated node. This pointer will never be NULL.
+        xml_node<Ch> *allocate_node(node_type type,
+                                    const Ch *name = 0, const Ch *value = 0,
+                                    std::size_t name_size = 0, std::size_t value_size = 0)
+        {
+            void *memory = allocate_aligned(sizeof(xml_node<Ch>));
+            xml_node<Ch> *node = new(memory) xml_node<Ch>(type);
+            if (name)
+            {
+                if (name_size > 0)
+                    node->name(name, name_size);
+                else
+                    node->name(name);
+            }
+            if (value)
+            {
+                if (value_size > 0)
+                    node->value(value, value_size);
+                else
+                    node->value(value);
+            }
+            return node;
+        }
+
+        //! Allocates a new attribute from the pool, and optionally assigns name and value to it.
+        //! If the allocation request cannot be accomodated, this function will throw <code>std::bad_alloc</code>.
+        //! If exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, this function
+        //! will call rapidxml_ns::parse_error_handler() function.
+        //! \param name Name to assign to the attribute, or 0 to assign no name.
+        //! \param value Value to assign to the attribute, or 0 to assign no value.
+        //! \param name_size Size of name to assign, or 0 to automatically calculate size from name string.
+        //! \param value_size Size of value to assign, or 0 to automatically calculate size from value string.
+        //! \return Pointer to allocated attribute. This pointer will never be NULL.
+        xml_attribute<Ch> *allocate_attribute(const Ch *name = 0, const Ch *value = 0,
+                                              std::size_t name_size = 0, std::size_t value_size = 0)
+        {
+            void *memory = allocate_aligned(sizeof(xml_attribute<Ch>));
+            xml_attribute<Ch> *attribute = new(memory) xml_attribute<Ch>;
+            if (name)
+            {
+                if (name_size > 0)
+                    attribute->name(name, name_size);
+                else
+                    attribute->name(name);
+            }
+            if (value)
+            {
+                if (value_size > 0)
+                    attribute->value(value, value_size);
+                else
+                    attribute->value(value);
+            }
+            return attribute;
+        }
+
+        //! Allocates a char array of given size from the pool, and optionally copies a given string to it.
+        //! If the allocation request cannot be accomodated, this function will throw <code>std::bad_alloc</code>.
+        //! If exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, this function
+        //! will call rapidxml_ns::parse_error_handler() function.
+        //! \param source String to initialize the allocated memory with, or 0 to not initialize it.
+        //! \param size Number of characters to allocate, or zero to calculate it automatically from source string length; if size is 0, source string must be specified and null terminated.
+        //! \return Pointer to allocated char array. This pointer will never be NULL.
+        Ch *allocate_string(const Ch *source = 0, std::size_t size = 0)
+        {
+            assert(source || size);     // Either source or size (or both) must be specified
+            if (size == 0)
+                size = internal::measure(source) + 1;
+            Ch *result = static_cast<Ch *>(allocate_aligned(size * sizeof(Ch)));
+            if (source)
+                for (std::size_t i = 0; i < size; ++i)
+                    result[i] = source[i];
+            return result;
+        }
+
+        //! Clones an xml_node and its hierarchy of child nodes and attributes.
+        //! Nodes and attributes are allocated from this memory pool.
+        //! Names and values are not cloned, they are shared between the clone and the source.
+        //! Result node can be optionally specified as a second parameter,
+        //! in which case its contents will be replaced with cloned source node.
+        //! This is useful when you want to clone entire document.
+        //! \param source Node to clone.
+        //! \param result Node to put results in, or 0 to automatically allocate result node
+        //! \return Pointer to cloned node. This pointer will never be NULL.
+        xml_node<Ch> *clone_node(const xml_node<Ch> *source, xml_node<Ch> *result = 0)
+        {
+            // Prepare result node
+            if (result)
+            {
+                result->remove_all_attributes();
+                result->remove_all_nodes();
+                result->type(source->type());
+            }
+            else
+                result = allocate_node(source->type());
+
+            // Clone name and value
+            result->qname(source->name(), source->name_size(), source->local_name());
+            result->value(source->value(), source->value_size());
+
+            // Clone child nodes and attributes
+            for (xml_node<Ch> *child = source->first_node(); child; child = child->next_sibling())
+                result->append_node(clone_node(child));
+            for (xml_attribute<Ch> *attr = source->first_attribute(); attr; attr = attr->next_attribute())
+                result->append_attribute(allocate_attribute(attr->name(), attr->value(), attr->name_size(), attr->value_size()));
+
+            return result;
+        }
+
+        //! Clears the pool.
+        //! This causes memory occupied by nodes allocated by the pool to be freed.
+        //! Any nodes or strings allocated from the pool will no longer be valid.
+        void clear()
+        {
+            while (m_begin != m_static_memory)
+            {
+                char *previous_begin = reinterpret_cast<header *>(align(m_begin))->previous_begin;
+                if (m_free_func)
+                    m_free_func(m_begin);
+                else
+                    delete[] m_begin;
+                m_begin = previous_begin;
+            }
+            init();
+        }
+
+        //! Sets or resets the user-defined memory allocation functions for the pool.
+        //! This can only be called when no memory is allocated from the pool yet, otherwise results are undefined.
+        //! Allocation function must not return invalid pointer on failure. It should either throw,
+        //! stop the program, or use <code>longjmp()</code> function to pass control to other place of program.
+        //! If it returns invalid pointer, results are undefined.
+        //! <br><br>
+        //! User defined allocation functions must have the following forms:
+        //! <br><code>
+        //! <br>void *allocate(std::size_t size);
+        //! <br>void free(void *pointer);
+        //! </code><br>
+        //! \param af Allocation function, or 0 to restore default function
+        //! \param ff Free function, or 0 to restore default function
+        void set_allocator(alloc_func *af, free_func *ff)
+        {
+            assert(m_begin == m_static_memory && m_ptr == align(m_begin));    // Verify that no memory is allocated yet
+            m_alloc_func = af;
+            m_free_func = ff;
+        }
+
+    private:
+
+        struct header
+        {
+            char *previous_begin;
+        };
+
+        void init()
+        {
+            m_begin = m_static_memory;
+            m_ptr = align(m_begin);
+            m_end = m_static_memory + sizeof(m_static_memory);
+        }
+
+        char *align(char *ptr)
+        {
+            std::size_t alignment = ((RAPIDXML_ALIGNMENT - (std::size_t(ptr) & (RAPIDXML_ALIGNMENT - 1))) & (RAPIDXML_ALIGNMENT - 1));
+            return ptr + alignment;
+        }
+
+        char *allocate_raw(std::size_t size)
+        {
+            // Allocate
+            void *memory;
+            if (m_alloc_func)   // Allocate memory using either user-specified allocation function or global operator new[]
+            {
+                memory = m_alloc_func(size);
+                assert(memory); // Allocator is not allowed to return 0, on failure it must either throw, stop the program or use longjmp
+            }
+            else
+            {
+                memory = new char[size];
+#ifdef RAPIDXML_NO_EXCEPTIONS
+                if (!memory)            // If exceptions are disabled, verify memory allocation, because new will not be able to throw bad_alloc
+                    RAPIDXML_PARSE_ERROR("out of memory", 0);
+#endif
+            }
+            return static_cast<char *>(memory);
+        }
+
+        void *allocate_aligned(std::size_t size)
+        {
+            // Calculate aligned pointer
+            char *result = align(m_ptr);
+
+            // If not enough memory left in current pool, allocate a new pool
+            if (result + size > m_end)
+            {
+                // Calculate required pool size (may be bigger than RAPIDXML_DYNAMIC_POOL_SIZE)
+                std::size_t pool_size = RAPIDXML_DYNAMIC_POOL_SIZE;
+                if (pool_size < size)
+                    pool_size = size;
+
+                // Allocate
+                std::size_t alloc_size = sizeof(header) + (2 * RAPIDXML_ALIGNMENT - 2) + pool_size;     // 2 alignments required in worst case: one for header, one for actual allocation
+                char *raw_memory = allocate_raw(alloc_size);
+
+                // Setup new pool in allocated memory
+                char *pool = align(raw_memory);
+                header *new_header = reinterpret_cast<header *>(pool);
+                new_header->previous_begin = m_begin;
+                m_begin = raw_memory;
+                m_ptr = pool + sizeof(header);
+                m_end = raw_memory + alloc_size;
+
+                // Calculate aligned pointer again using new pool
+                result = align(m_ptr);
+            }
+
+            // Update pool and return aligned pointer
+            m_ptr = result + size;
+            return result;
+        }
+
+        char *m_begin;                                      // Start of raw memory making up current pool
+        char *m_ptr;                                        // First free byte in current pool
+        char *m_end;                                        // One past last available byte in current pool
+        char m_static_memory[RAPIDXML_STATIC_POOL_SIZE];    // Static raw memory
+        alloc_func *m_alloc_func;                           // Allocator function, or 0 if default is to be used
+        free_func *m_free_func;                             // Free function, or 0 if default is to be used
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    // XML base
+
+    //! Base class for xml_node and xml_attribute implementing common functions:
+    //! name(), name_size(), value(), value_size() and parent().
+    //! \param Ch Character type to use
+    template<class Ch = char>
+    class xml_base
+    {
+
+    public:
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Construction & destruction
+
+        // Construct a base with empty name, value and parent
+        xml_base()
+            : m_local_name(0)
+            , m_name(0)
+            , m_namespace_uri(0)
+            , m_value(0)
+            , m_parent(0)
+        {
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Node data access
+
+        Ch *local_name() const
+        {
+            return m_local_name ? m_local_name : nullstr();
+        }
+
+        std::size_t local_name_size() const
+        {
+            return m_local_name ? (m_name_size - (m_local_name - m_name)) : 0;
+        }
+
+        //! Gets namespace prefix.
+        //! Returned string is never zero-terminated, regardless of parse_no_string_terminators. Use prefix_size()
+        //! "Note that the prefix functions only as a placeholder for a namespace name. Applications
+        //! SHOULD use the namespace name, not the prefix, in constructing names whose scope extends beyond the containing
+        //! document" Namespaces in XML 1.0 (Third Edition)
+        Ch *prefix() const
+        {
+            return m_name ? m_name : nullstr();
+        }
+
+        //! Gets size of namespace prefix, not including terminator character.
+        //! \return Size of namespace prefix, in characters.
+        std::size_t prefix_size() const
+        {
+            return (m_name && m_local_name > m_name) ? (m_local_name - m_name - 1) : 0;
+        }
+
+        //! Gets QName of the node.
+        //! Interpretation of name depends on type of node.
+        //! Note that name will not be zero-terminated if rapidxml_ns::parse_no_string_terminators option was selected during parse.
+        //! <br><br>
+        //! Use name_size() function to determine length of the name.
+        //! \return Name of node, or empty string if node has no name.
+        Ch *name() const
+        {
+            return m_name ? m_name : nullstr();
+        }
+
+        //! Gets size of node QName, not including terminator character.
+        //! This function works correctly irrespective of whether name is or is not zero terminated.
+        //! \return Size of node name, in characters.
+        std::size_t name_size() const
+        {
+            return m_name ? m_name_size : 0;
+        }
+
+        //! Gets value of node.
+        //! Interpretation of value depends on type of node.
+        //! Note that value will not be zero-terminated if rapidxml_ns::parse_no_string_terminators option was selected during parse.
+        //! <br><br>
+        //! Use value_size() function to determine length of the value.
+        //! \return Value of node, or empty string if node has no value.
+        Ch *value() const
+        {
+            return m_value ? m_value : nullstr();
+        }
+
+        //! Gets size of node value, not including terminator character.
+        //! This function works correctly irrespective of whether value is or is not zero terminated.
+        //! \return Size of node value, in characters.
+        std::size_t value_size() const
+        {
+            return m_value ? m_value_size : 0;
+        }
+
+        //! Gets namespace URI of the node.
+        //! Note that URI will not be zero-terminated if rapidxml_ns::parse_no_string_terminators option was selected during parse.
+        //! Namespace URI is not assigned if rapidxml_ns::parse_no_namespace option was selected during parse.
+        //! <br><br>
+        //! Use namespace_uri_size() function to determine length of the name.
+        //! \return Namespace URI of node, or empty string if node has no namespace assigned.
+        Ch const *namespace_uri() const
+        {
+            return m_namespace_uri ? m_namespace_uri : nullstr();
+        }
+
+        //! Gets size of namespace URI value, not including terminator character.
+        //! This function works correctly irrespective of whether namespace URI is or is not zero terminated.
+        //! \return Size of namespace URI, in characters.
+        std::size_t namespace_uri_size() const
+        {
+            return m_namespace_uri ? m_namespace_uri_size : 0;
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Node modification
+
+        //! Sets QName of node to a non zero-terminated string.
+        //! See \ref ownership_of_strings.
+        //! <br><br>
+        //! Note that node does not own its name or value, it only stores a pointer to it.
+        //! It will not delete or otherwise free the pointer on destruction.
+        //! It is reponsibility of the user to properly manage lifetime of the string.
+        //! The easiest way to achieve it is to use memory_pool of the document to allocate the string -
+        //! on destruction of the document the string will be automatically freed.
+        //! <br><br>
+        //! Note that passed string will not be automatically divided to prefix and local_name,
+        //! it seems useless for manual node creation. qname() may be used instead
+        //! local_name() will be set to be equal to name()
+        //! <br><br>
+        //! Size of name must be specified separately, because name does not have to be zero terminated.
+        //! Use name(const Ch *) function to have the length automatically calculated (string must be zero terminated).
+        //! \param name QName of node to set. Does not have to be zero terminated.
+        //! \param size Size of name, in characters. This does not include zero terminator, if one is present.
+        void name(const Ch *name, std::size_t size)
+        {
+            qname(name, size);
+        }
+
+        //! Sets QName of node to a zero-terminated string.
+        //! See also \ref ownership_of_strings and xml_node::name(const Ch *, std::size_t).
+        //! \param name Name of node to set. Must be zero terminated.
+        void name(const Ch *name)
+        {
+            this->name(name, internal::measure(name));
+        }
+
+        //! Sets QName as PrefixedName or UnprefixedName where local_part points in QName string
+        void qname(const Ch *qname, std::size_t qname_size, const Ch * local_part)
+        {
+            m_name = const_cast<Ch *>(qname);
+            m_name_size = qname_size;
+            m_local_name = const_cast<Ch *>(local_part);
+        }
+
+        //! Sets QName as UnprefixedName
+        void qname(const Ch *qname, std::size_t qname_size)
+        {
+            m_name = const_cast<Ch *>(qname);
+            m_name_size = qname_size;
+            m_local_name = m_name;
+        }
+
+        void namespace_uri(const Ch *uri, std::size_t size)
+        {
+            m_namespace_uri = uri;
+            m_namespace_uri_size = size;
+        }
+
+        //! Sets value of node to a non zero-terminated string.
+        //! See \ref ownership_of_strings.
+        //! <br><br>
+        //! Note that node does not own its name or value, it only stores a pointer to it.
+        //! It will not delete or otherwise free the pointer on destruction.
+        //! It is responsibility of the user to properly manage lifetime of the string.
+        //! The easiest way to achieve it is to use memory_pool of the document to allocate the string -
+        //! on destruction of the document the string will be automatically freed.
+        //! <br><br>
+        //! Size of value must be specified separately, because it does not have to be zero terminated.
+        //! Use value(const Ch *) function to have the length automatically calculated (string must be zero terminated).
+        //! <br><br>
+        //! If an element has a child node of type node_data, it will take precedence over element value when printing.
+        //! If you want to manipulate data of elements using values, use parser flag rapidxml_ns::parse_no_data_nodes to prevent creation of data nodes by the parser.
+        //! \param value value of node to set. Does not have to be zero terminated.
+        //! \param size Size of value, in characters. This does not include zero terminator, if one is present.
+        void value(const Ch *value, std::size_t size)
+        {
+            m_value = const_cast<Ch *>(value);
+            m_value_size = size;
+        }
+
+        //! Sets value of node to a zero-terminated string.
+        //! See also \ref ownership_of_strings and xml_node::value(const Ch *, std::size_t).
+        //! \param value Vame of node to set. Must be zero terminated.
+        void value(const Ch *value)
+        {
+            this->value(value, internal::measure(value));
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Related nodes access
+
+        //! Gets node parent.
+        //! \return Pointer to parent node, or 0 if there is no parent.
+        xml_node<Ch> *parent() const
+        {
+            return m_parent;
+        }
+
+    protected:
+
+        // Return empty string
+        static Ch *nullstr()
+        {
+            static Ch zero = Ch('\0');
+            return &zero;
+        }
+
+        Ch *m_local_name;                   // Pointer into m_name where local part begins
+        Ch *m_name;                         // Name of node, or 0 if no name
+        Ch *m_value;                        // Value of node, or 0 if no value
+        Ch const *m_namespace_uri;
+        std::size_t m_name_size;            // Length of node name, or undefined of no name
+        std::size_t m_value_size;           // Length of node value, or undefined if no value
+        std::size_t m_namespace_uri_size;
+        xml_node<Ch> *m_parent;             // Pointer to parent node, or 0 if none
+
+    };
+
+    //! Class representing attribute node of XML document.
+    //! Each attribute has name and value strings, which are available through name() and value() functions (inherited from xml_base).
+    //! Note that after parse, both name and value of attribute will point to interior of source text used for parsing.
+    //! Thus, this text must persist in memory for the lifetime of attribute.
+    //! \param Ch Character type to use.
+    template<class Ch = char>
+    class xml_attribute: public xml_base<Ch>
+    {
+
+        friend class xml_node<Ch>;
+
+    public:
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Construction & destruction
+
+        //! Constructs an empty attribute with the specified type.
+        //! Consider using memory_pool of appropriate xml_document if allocating attributes manually.
+        xml_attribute()
+        {
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Related nodes access
+
+        //! Gets document of which attribute is a child.
+        //! \return Pointer to document that contains this attribute, or 0 if there is no parent document.
+        xml_document<Ch> *document() const
+        {
+            if (xml_node<Ch> *node = this->parent())
+            {
+                while (node->parent())
+                    node = node->parent();
+                return node->type() == node_document ? static_cast<xml_document<Ch> *>(node) : 0;
+            }
+            else
+                return 0;
+        }
+
+        //! Gets previous attribute, optionally matching attribute name.
+        //! \param name Name of attribute to find, or 0 to return previous attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found attribute, or 0 if not found.
+        xml_attribute<Ch> *previous_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_attribute<Ch> *attribute = m_prev_attribute; attribute; attribute = attribute->m_prev_attribute)
+                    if (internal::compare(attribute->name(), attribute->name_size(), name, name_size, case_sensitive))
+                        return attribute;
+                return 0;
+            }
+            else
+                return this->m_parent ? m_prev_attribute : 0;
+        }
+
+        //! Gets next attribute, optionally matching attribute name.
+        //! \param name Name of attribute to find, or 0 to return next attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found attribute, or 0 if not found.
+        xml_attribute<Ch> *next_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_attribute<Ch> *attribute = m_next_attribute; attribute; attribute = attribute->m_next_attribute)
+                    if (internal::compare(attribute->name(), attribute->name_size(), name, name_size, case_sensitive))
+                        return attribute;
+                return 0;
+            }
+            else
+                return this->m_parent ? m_next_attribute : 0;
+        }
+
+        //! Gets next attribute, matching attribute local name and attribute namespace URI .
+        //! \param namespace_uri Namespace URI of attribute to find; this string have to be zero-terminated
+        //! \param local_name Local name of attribute to find; this string have to be zero-terminated
+        //! \param local_name_case_sensitive Should local name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found attribute, or 0 if not found.
+        xml_attribute<Ch> *next_attribute_ns(const Ch * namespace_uri, const Ch *local_name,
+                                             bool local_name_case_sensitive = true) const
+        {
+            return next_attribute_ns(namespace_uri, internal::measure(namespace_uri),
+                local_name, internal::measure(local_name), local_name_case_sensitive);
+        }
+
+        xml_attribute<Ch> *next_attribute_ns(const Ch * namespace_uri, std::size_t namespace_uri_size,
+                                             const Ch *local_name,     std::size_t local_name_size,
+                                             bool local_name_case_sensitive = true) const
+        {
+            for (xml_attribute<Ch> *attribute = m_next_attribute; attribute; attribute = attribute->m_next_attribute)
+                if (internal::compare(attribute->local_name(), attribute->local_name_size(),
+                        local_name, local_name_size, local_name_case_sensitive)
+                    && internal::compare(attribute->namespace_uri(), attribute->namespace_uri_size(),
+                        namespace_uri, namespace_uri_size))
+                    return attribute;
+            return 0;
+        }
+
+    private:
+
+        xml_attribute<Ch> *m_prev_attribute;        // Pointer to previous sibling of attribute, or 0 if none; only valid if parent is non-zero
+        xml_attribute<Ch> *m_next_attribute;        // Pointer to next sibling of attribute, or 0 if none; only valid if parent is non-zero
+
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    // XML node
+
+    //! Class representing a node of XML document.
+    //! Each node may have associated name and value strings, which are available through name() and value() functions.
+    //! Interpretation of name and value depends on type of the node.
+    //! Type of node can be determined by using type() function.
+    //! <br><br>
+    //! Note that after parse, both name and value of node, if any, will point interior of source text used for parsing.
+    //! Thus, this text must persist in the memory for the lifetime of node.
+    //! \param Ch Character type to use.
+    template<class Ch = char>
+    class xml_node: public xml_base<Ch>
+    {
+
+    public:
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Construction & destruction
+
+        //! Constructs an empty node with the specified type.
+        //! Consider using memory_pool of appropriate document to allocate nodes manually.
+        //! \param type Type of node to construct.
+        xml_node(node_type type)
+            : m_type(type)
+            , m_first_node(0)
+            , m_first_attribute(0)
+        {
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Node data access
+
+        //! Gets type of node.
+        //! \return Type of node.
+        node_type type() const
+        {
+            return m_type;
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Related nodes access
+
+        //! Gets document of which node is a child.
+        //! \return Pointer to document that contains this node, or 0 if there is no parent document.
+        xml_document<Ch> *document() const
+        {
+            xml_node<Ch> *node = const_cast<xml_node<Ch> *>(this);
+            while (node->parent())
+                node = node->parent();
+            return node->type() == node_document ? static_cast<xml_document<Ch> *>(node) : 0;
+        }
+
+        //! Gets first child node, optionally matching node name.
+        //! \param name Name of child to find, or 0 to return first child regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found child, or 0 if not found.
+        xml_node<Ch> *first_node(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_node<Ch> *child = m_first_node; child; child = child->next_sibling())
+                    if (internal::compare(child->name(), child->name_size(), name, name_size, case_sensitive))
+                        return child;
+                return 0;
+            }
+            else
+                return m_first_node;
+        }
+
+        //! Gets first child node, matching node local name and namespace URI.
+        //! \param namespace_uri Namespace URI of child to find; this string have to be zero-terminated
+        //! \param local_name Local name of child to find; this string have to be zero-terminated
+        //! \param local_name_case_sensitive Should local name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found child, or 0 if not found.
+        xml_node<Ch> *first_node_ns(const Ch * namespace_uri, const Ch *local_name,
+                                    bool local_name_case_sensitive = true) const
+        {
+            return first_node_ns(namespace_uri, internal::measure(namespace_uri),
+                local_name, internal::measure(local_name), local_name_case_sensitive);
+        }
+
+        xml_node<Ch> *first_node_ns(const Ch *namespace_uri,  std::size_t namespace_uri_size,
+                                    const Ch *local_name,     std::size_t local_name_size,
+                                    bool local_name_case_sensitive = true) const
+        {
+            for (xml_node<Ch> *child = m_first_node; child; child = child->next_sibling())
+                if (internal::compare(child->local_name(), child->local_name_size(),
+                        local_name, local_name_size, local_name_case_sensitive)
+                    && internal::compare(child->namespace_uri(), child->namespace_uri_size(),
+                        namespace_uri, namespace_uri_size))
+                    return child;
+            return 0;
+        }
+
+        xml_node<Ch> *first_node_ns(const Ch *namespace_uri, std::size_t namespace_uri_size = 0) const
+        {
+            if (namespace_uri_size == 0)
+                namespace_uri_size = internal::measure(namespace_uri);
+            for (xml_node<Ch> *child = m_first_node; child; child = child->next_sibling())
+                if (internal::compare(child->namespace_uri(), child->namespace_uri_size(), namespace_uri, namespace_uri_size))
+                    return child;
+            return 0;
+        }
+
+        //! Gets last child node, optionally matching node name.
+        //! Behaviour is undefined if node has no children.
+        //! Use first_node() to test if node has children.
+        //! \param name Name of child to find, or 0 to return last child regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found child, or 0 if not found.
+        xml_node<Ch> *last_node(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            assert(m_first_node);  // Cannot query for last child if node has no children
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_node<Ch> *child = m_last_node; child; child = child->previous_sibling())
+                    if (internal::compare(child->name(), child->name_size(), name, name_size, case_sensitive))
+                        return child;
+                return 0;
+            }
+            else
+                return m_last_node;
+        }
+
+        //! Gets previous sibling node, optionally matching node name.
+        //! Behaviour is undefined if node has no parent.
+        //! Use parent() to test if node has a parent.
+        //! \param name Name of sibling to find, or 0 to return previous sibling regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found sibling, or 0 if not found.
+        xml_node<Ch> *previous_sibling(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            assert(this->m_parent);     // Cannot query for siblings if node has no parent
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_node<Ch> *sibling = m_prev_sibling; sibling; sibling = sibling->m_prev_sibling)
+                    if (internal::compare(sibling->name(), sibling->name_size(), name, name_size, case_sensitive))
+                        return sibling;
+                return 0;
+            }
+            else
+                return m_prev_sibling;
+        }
+
+        //! Gets next sibling node, optionally matching node name.
+        //! Behaviour is undefined if node has no parent.
+        //! Use parent() to test if node has a parent.
+        //! \param name Name of sibling to find, or 0 to return next sibling regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found sibling, or 0 if not found.
+        xml_node<Ch> *next_sibling(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            assert(this->m_parent);     // Cannot query for siblings if node has no parent
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_node<Ch> *sibling = m_next_sibling; sibling; sibling = sibling->m_next_sibling)
+                    if (internal::compare(sibling->name(), sibling->name_size(), name, name_size, case_sensitive))
+                        return sibling;
+                return 0;
+            }
+            else
+                return m_next_sibling;
+        }
+
+        xml_node<Ch> *next_sibling_ns(const Ch * namespace_uri, const Ch *local_name,
+                                      bool local_name_case_sensitive = true) const
+        {
+            return next_sibling_ns(namespace_uri, internal::measure(namespace_uri),
+                local_name, internal::measure(local_name), local_name_case_sensitive);
+        }
+
+        xml_node<Ch> *next_sibling_ns(const Ch * namespace_uri, std::size_t namespace_uri_size,
+                                      const Ch *local_name,     std::size_t local_name_size,
+                                      bool local_name_case_sensitive = true) const
+        {
+            for (xml_node<Ch> *sibling = m_next_sibling; sibling; sibling = sibling->m_next_sibling)
+                if (internal::compare(sibling->local_name(), sibling->local_name_size(),
+                        local_name, local_name_size, local_name_case_sensitive)
+                    && internal::compare(sibling->namespace_uri(), sibling->namespace_uri_size(),
+                        namespace_uri, namespace_uri_size))
+                    return sibling;
+            return 0;
+        }
+
+        xml_node<Ch> *next_sibling_ns(const Ch *namespace_uri, std::size_t namespace_uri_size = 0) const
+        {
+            if (namespace_uri_size == 0)
+                namespace_uri_size = internal::measure(namespace_uri);
+            for (xml_node<Ch> *sibling = m_next_sibling; sibling; sibling = sibling->m_next_sibling)
+                if (internal::compare(sibling->namespace_uri(), sibling->namespace_uri_size(), namespace_uri, namespace_uri_size))
+                    return sibling;
+            return 0;
+        }
+
+        //! Gets first attribute of node, optionally matching attribute name.
+        //! \param name Name of attribute to find, or 0 to return first attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found attribute, or 0 if not found.
+        xml_attribute<Ch> *first_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_attribute<Ch> *attribute = m_first_attribute; attribute; attribute = attribute->m_next_attribute)
+                    if (internal::compare(attribute->name(), attribute->name_size(), name, name_size, case_sensitive))
+                        return attribute;
+                return 0;
+            }
+            else
+                return m_first_attribute;
+        }
+
+        //! Gets first attribute of node, matching attribute namespace URI and local name.
+        //! \param namespace_uri Namespace URI of attribute to find; this string have to be zero-terminated
+        //! \param local_name Local name of attribute to find; this string have to be zero-terminated
+        //! \param local_name_case_sensitive Should local name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found attribute, or 0 if not found.
+        xml_attribute<Ch> *first_attribute_ns(const Ch * namespace_uri, const Ch *local_name,
+                                             bool local_name_case_sensitive = true) const
+        {
+            return first_attribute_ns(namespace_uri, internal::measure(namespace_uri),
+                local_name, internal::measure(local_name), local_name_case_sensitive);
+        }
+
+        xml_attribute<Ch> *first_attribute_ns(const Ch * namespace_uri, std::size_t namespace_uri_size,
+                                             const Ch *local_name,     std::size_t local_name_size,
+                                             bool local_name_case_sensitive = true) const
+        {
+            for (xml_attribute<Ch> *attribute = m_first_attribute; attribute; attribute = attribute->m_next_attribute)
+                if (internal::compare(attribute->local_name(), attribute->local_name_size(),
+                        local_name, local_name_size, local_name_case_sensitive)
+                    && internal::compare(attribute->namespace_uri(), attribute->namespace_uri_size(),
+                        namespace_uri, namespace_uri_size))
+                    return attribute;
+            return 0;
+        }
+
+        //! Gets last attribute of node, optionally matching attribute name.
+        //! \param name Name of attribute to find, or 0 to return last attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found attribute, or 0 if not found.
+        xml_attribute<Ch> *last_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_attribute<Ch> *attribute = m_last_attribute; attribute; attribute = attribute->m_prev_attribute)
+                    if (internal::compare(attribute->name(), attribute->name_size(), name, name_size, case_sensitive))
+                        return attribute;
+                return 0;
+            }
+            else
+                return m_first_attribute ? m_last_attribute : 0;
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Node modification
+
+        //! Sets type of node.
+        //! \param type Type of node to set.
+        void type(node_type type)
+        {
+            m_type = type;
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Node manipulation
+
+        //! Prepends a new child node.
+        //! The prepended child becomes the first child, and all existing children are moved one position back.
+        //! \param child Node to prepend.
+        void prepend_node(xml_node<Ch> *child)
+        {
+            assert(child && !child->parent() && child->type() != node_document);
+            if (first_node())
+            {
+                child->m_next_sibling = m_first_node;
+                m_first_node->m_prev_sibling = child;
+            }
+            else
+            {
+                child->m_next_sibling = 0;
+                m_last_node = child;
+            }
+            m_first_node = child;
+            child->m_parent = this;
+            child->m_prev_sibling = 0;
+        }
+
+        //! Appends a new child node.
+        //! The appended child becomes the last child.
+        //! \param child Node to append.
+        void append_node(xml_node<Ch> *child)
+        {
+            assert(child && !child->parent() && child->type() != node_document);
+            if (first_node())
+            {
+                child->m_prev_sibling = m_last_node;
+                m_last_node->m_next_sibling = child;
+            }
+            else
+            {
+                child->m_prev_sibling = 0;
+                m_first_node = child;
+            }
+            m_last_node = child;
+            child->m_parent = this;
+            child->m_next_sibling = 0;
+        }
+
+        //! Inserts a new child node at specified place inside the node.
+        //! All children after and including the specified node are moved one position back.
+        //! \param where Place where to insert the child, or 0 to insert at the back.
+        //! \param child Node to insert.
+        void insert_node(xml_node<Ch> *where, xml_node<Ch> *child)
+        {
+            assert(!where || where->parent() == this);
+            assert(child && !child->parent() && child->type() != node_document);
+            if (where == m_first_node)
+                prepend_node(child);
+            else if (where == 0)
+                append_node(child);
+            else
+            {
+                child->m_prev_sibling = where->m_prev_sibling;
+                child->m_next_sibling = where;
+                where->m_prev_sibling->m_next_sibling = child;
+                where->m_prev_sibling = child;
+                child->m_parent = this;
+            }
+        }
+
+        //! Removes first child node.
+        //! If node has no children, behaviour is undefined.
+        //! Use first_node() to test if node has children.
+        void remove_first_node()
+        {
+            assert(first_node());
+            xml_node<Ch> *child = m_first_node;
+            m_first_node = child->m_next_sibling;
+            if (child->m_next_sibling)
+                child->m_next_sibling->m_prev_sibling = 0;
+            else
+                m_last_node = 0;
+            child->m_parent = 0;
+        }
+
+        //! Removes last child of the node.
+        //! If node has no children, behaviour is undefined.
+        //! Use first_node() to test if node has children.
+        void remove_last_node()
+        {
+            assert(first_node());
+            xml_node<Ch> *child = m_last_node;
+            if (child->m_prev_sibling)
+            {
+                m_last_node = child->m_prev_sibling;
+                child->m_prev_sibling->m_next_sibling = 0;
+            }
+            else
+                m_first_node = 0;
+            child->m_parent = 0;
+        }
+
+        //! Removes specified child from the node
+        // \param where Pointer to child to be removed.
+        void remove_node(xml_node<Ch> *where)
+        {
+            assert(where && where->parent() == this);
+            assert(first_node());
+            if (where == m_first_node)
+                remove_first_node();
+            else if (where == m_last_node)
+                remove_last_node();
+            else
+            {
+                where->m_prev_sibling->m_next_sibling = where->m_next_sibling;
+                where->m_next_sibling->m_prev_sibling = where->m_prev_sibling;
+                where->m_parent = 0;
+            }
+        }
+
+        //! Removes all child nodes (but not attributes).
+        void remove_all_nodes()
+        {
+            for (xml_node<Ch> *node = first_node(); node; node = node->m_next_sibling)
+                node->m_parent = 0;
+            m_first_node = 0;
+        }
+
+        //! Prepends a new attribute to the node.
+        //! \param attribute Attribute to prepend.
+        void prepend_attribute(xml_attribute<Ch> *attribute)
+        {
+            assert(attribute && !attribute->parent());
+            if (first_attribute())
+            {
+                attribute->m_next_attribute = m_first_attribute;
+                m_first_attribute->m_prev_attribute = attribute;
+            }
+            else
+            {
+                attribute->m_next_attribute = 0;
+                m_last_attribute = attribute;
+            }
+            m_first_attribute = attribute;
+            attribute->m_parent = this;
+            attribute->m_prev_attribute = 0;
+        }
+
+        //! Appends a new attribute to the node.
+        //! \param attribute Attribute to append.
+        void append_attribute(xml_attribute<Ch> *attribute)
+        {
+            assert(attribute && !attribute->parent());
+            if (first_attribute())
+            {
+                attribute->m_prev_attribute = m_last_attribute;
+                m_last_attribute->m_next_attribute = attribute;
+            }
+            else
+            {
+                attribute->m_prev_attribute = 0;
+                m_first_attribute = attribute;
+            }
+            m_last_attribute = attribute;
+            attribute->m_parent = this;
+            attribute->m_next_attribute = 0;
+        }
+
+        //! Inserts a new attribute at specified place inside the node.
+        //! All attributes after and including the specified attribute are moved one position back.
+        //! \param where Place where to insert the attribute, or 0 to insert at the back.
+        //! \param attribute Attribute to insert.
+        void insert_attribute(xml_attribute<Ch> *where, xml_attribute<Ch> *attribute)
+        {
+            assert(!where || where->parent() == this);
+            assert(attribute && !attribute->parent());
+            if (where == m_first_attribute)
+                prepend_attribute(attribute);
+            else if (where == 0)
+                append_attribute(attribute);
+            else
+            {
+                attribute->m_prev_attribute = where->m_prev_attribute;
+                attribute->m_next_attribute = where;
+                where->m_prev_attribute->m_next_attribute = attribute;
+                where->m_prev_attribute = attribute;
+                attribute->m_parent = this;
+            }
+        }
+
+        //! Removes first attribute of the node.
+        //! If node has no attributes, behaviour is undefined.
+        //! Use first_attribute() to test if node has attributes.
+        void remove_first_attribute()
+        {
+            assert(first_attribute());
+            xml_attribute<Ch> *attribute = m_first_attribute;
+            if (attribute->m_next_attribute)
+            {
+                attribute->m_next_attribute->m_prev_attribute = 0;
+            }
+            else
+                m_last_attribute = 0;
+            attribute->m_parent = 0;
+            m_first_attribute = attribute->m_next_attribute;
+        }
+
+        //! Removes last attribute of the node.
+        //! If node has no attributes, behaviour is undefined.
+        //! Use first_attribute() to test if node has attributes.
+        void remove_last_attribute()
+        {
+            assert(first_attribute());
+            xml_attribute<Ch> *attribute = m_last_attribute;
+            if (attribute->m_prev_attribute)
+            {
+                attribute->m_prev_attribute->m_next_attribute = 0;
+                m_last_attribute = attribute->m_prev_attribute;
+            }
+            else
+                m_first_attribute = 0;
+            attribute->m_parent = 0;
+        }
+
+        //! Removes specified attribute from node.
+        //! \param where Pointer to attribute to be removed.
+        void remove_attribute(xml_attribute<Ch> *where)
+        {
+            assert(first_attribute() && where->parent() == this);
+            if (where == m_first_attribute)
+                remove_first_attribute();
+            else if (where == m_last_attribute)
+                remove_last_attribute();
+            else
+            {
+                where->m_prev_attribute->m_next_attribute = where->m_next_attribute;
+                where->m_next_attribute->m_prev_attribute = where->m_prev_attribute;
+                where->m_parent = 0;
+            }
+        }
+
+        //! Removes all attributes of node.
+        void remove_all_attributes()
+        {
+            for (xml_attribute<Ch> *attribute = first_attribute(); attribute; attribute = attribute->m_next_attribute)
+                attribute->m_parent = 0;
+            m_first_attribute = 0;
+        }
+
+    private:
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Restrictions
+
+        // No copying
+        xml_node(const xml_node &);
+        void operator =(const xml_node &);
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Data members
+
+        // Note that some of the pointers below have UNDEFINED values if certain other pointers are 0.
+        // This is required for maximum performance, as it allows the parser to omit initialization of
+        // unneded/redundant values.
+        //
+        // The rules are as follows:
+        // 1. first_node and first_attribute contain valid pointers, or 0 if node has no children/attributes respectively
+        // 2. last_node and last_attribute are valid only if node has at least one child/attribute respectively, otherwise they contain garbage
+        // 3. prev_sibling and next_sibling are valid only if node has a parent, otherwise they contain garbage
+
+        node_type m_type;                       // Type of node; always valid
+        xml_node<Ch> *m_first_node;             // Pointer to first child node, or 0 if none; always valid
+        xml_node<Ch> *m_last_node;              // Pointer to last child node, or 0 if none; this value is only valid if m_first_node is non-zero
+        xml_attribute<Ch> *m_first_attribute;   // Pointer to first attribute of node, or 0 if none; always valid
+        xml_attribute<Ch> *m_last_attribute;    // Pointer to last attribute of node, or 0 if none; this value is only valid if m_first_attribute is non-zero
+        xml_node<Ch> *m_prev_sibling;           // Pointer to previous sibling of node, or 0 if none; this value is only valid if m_parent is non-zero
+        xml_node<Ch> *m_next_sibling;           // Pointer to next sibling of node, or 0 if none; this value is only valid if m_parent is non-zero
+
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    // XML document
+
+    //! This class represents root of the DOM hierarchy.
+    //! It is also an xml_node and a memory_pool through public inheritance.
+    //! Use parse() function to build a DOM tree from a zero-terminated XML text string.
+    //! parse() function allocates memory for nodes and attributes by using functions of xml_document,
+    //! which are inherited from memory_pool.
+    //! To access root node of the document, use the document itself, as if it was an xml_node.
+    //! \param Ch Character type to use.
+    template<class Ch = char>
+    class xml_document: public xml_node<Ch>, public memory_pool<Ch>
+    {
+
+    public:
+
+        //! Constructs empty XML document
+        xml_document()
+            : xml_node<Ch>(node_document)
+        {
+        }
+
+        //! Parses zero-terminated XML string according to given flags.
+        //! Passed string will be modified by the parser, unless rapidxml_ns::parse_non_destructive flag is used.
+        //! The string must persist for the lifetime of the document.
+        //! In case of error, rapidxml_ns::parse_error exception will be thrown.
+        //! <br><br>
+        //! If you want to parse contents of a file, you must first load the file into the memory, and pass pointer to its beginning.
+        //! Make sure that data is zero-terminated.
+        //! <br><br>
+        //! Document can be parsed into multiple times.
+        //! Each new call to parse removes previous nodes and attributes (if any), but does not clear memory pool.
+        //! \param text XML data to parse; pointer is non-const to denote fact that this data may be modified by the parser.
+        template<int Flags>
+        void parse(Ch *text)
+        {
+            if (Flags & parse_no_namespace)
+                parse_ns<Flags, internal::xml_namespace_processor_stub<Ch> >(text);
+            else
+                parse_ns<Flags, internal::xml_namespace_processor<Ch> >(text);
+        }
+
+        //! Use parse() instead.
+        //! Parses zero-terminated XML string according to given flags and NamespaceProcessor passed.
+        //! Should be called only when default xml_namespace_processor is substituted with custom one.
+        template<int Flags, class NamespaceProcessor>
+        void parse_ns(Ch *text)
+        {
+            assert(text);
+
+            // Remove current contents
+            this->remove_all_nodes();
+            this->remove_all_attributes();
+
+            NamespaceProcessor namespace_processor;
+            // Creating topmost namespace scope that actually won't be used
+            typename NamespaceProcessor::scope const namespace_scope(namespace_processor);
+
+            // Parse BOM, if any
+            parse_bom<Flags>(text);
+
+            // Parse children
+            while (1)
+            {
+                // Skip whitespace before node
+                skip<whitespace_pred, Flags>(text);
+                if (*text == 0)
+                    break;
+
+                // Parse and append new child
+                if (*text == Ch('<'))
+                {
+                    ++text;     // Skip '<'
+                    if (xml_node<Ch> *node = parse_node<Flags, typename NamespaceProcessor::scope>(text, namespace_scope))
+                        this->append_node(node);
+                }
+                else
+                    RAPIDXML_PARSE_ERROR("expected <", text);
+            }
+
+        }
+
+        //! Clears the document by deleting all nodes and clearing the memory pool.
+        //! All nodes owned by document pool are destroyed.
+        void clear()
+        {
+            this->remove_all_nodes();
+            this->remove_all_attributes();
+            memory_pool<Ch>::clear();
+        }
+
+    private:
+
+        ///////////////////////////////////////////////////////////////////////
+        // Internal character utility functions
+
+        // Detect whitespace character
+        struct whitespace_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_whitespace[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect node name character
+        struct node_name_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_node_name[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect node name character without ':' (NCName) - namespace prefix or local name
+        struct node_ncname_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_node_ncname[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect attribute name character
+        struct attribute_name_pred
+        {
+          static unsigned char test(Ch ch)
+          {
+            return internal::lookup_tables<0>::lookup_attribute_name[static_cast<unsigned char>(ch)];
+          }
+        };
+
+        // Detect attribute name character without ':' (NCName) - namespace prefix or local name
+        struct attribute_ncname_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_attribute_ncname[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect text character (PCDATA)
+        struct text_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_text[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect text character (PCDATA) that does not require processing
+        struct text_pure_no_ws_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_text_pure_no_ws[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect text character (PCDATA) that does not require processing
+        struct text_pure_with_ws_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_text_pure_with_ws[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect attribute value character
+        template<Ch Quote>
+        struct attribute_value_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                if (Quote == Ch('\''))
+                    return internal::lookup_tables<0>::lookup_attribute_data_1[static_cast<unsigned char>(ch)];
+                if (Quote == Ch('\"'))
+                    return internal::lookup_tables<0>::lookup_attribute_data_2[static_cast<unsigned char>(ch)];
+                return 0;       // Should never be executed, to avoid warnings on Comeau
+            }
+        };
+
+        // Detect attribute value character
+        template<Ch Quote>
+        struct attribute_value_pure_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                if (Quote == Ch('\''))
+                    return internal::lookup_tables<0>::lookup_attribute_data_1_pure[static_cast<unsigned char>(ch)];
+                if (Quote == Ch('\"'))
+                    return internal::lookup_tables<0>::lookup_attribute_data_2_pure[static_cast<unsigned char>(ch)];
+                return 0;       // Should never be executed, to avoid warnings on Comeau
+            }
+        };
+
+        // Insert coded character, using UTF8 or 8-bit ASCII
+        template<int Flags>
+        static void insert_coded_character(Ch *&text, unsigned long code)
+        {
+            if (Flags & parse_no_utf8)
+            {
+                // Insert 8-bit ASCII character
+                // Todo: possibly verify that code is less than 256 and use replacement char otherwise?
+                text[0] = static_cast<unsigned char>(code);
+                text += 1;
+            }
+            else
+            {
+                // Insert UTF8 sequence
+                if (code < 0x80)    // 1 byte sequence
+                {
+	                text[0] = static_cast<unsigned char>(code);
+                    text += 1;
+                }
+                else if (code < 0x800)  // 2 byte sequence
+                {
+	                text[1] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;
+	                text[0] = static_cast<unsigned char>(code | 0xC0);
+                    text += 2;
+                }
+	            else if (code < 0x10000)    // 3 byte sequence
+                {
+	                text[2] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;
+	                text[1] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;
+	                text[0] = static_cast<unsigned char>(code | 0xE0);
+                    text += 3;
+                }
+	            else if (code < 0x110000)   // 4 byte sequence
+                {
+	                text[3] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;
+	                text[2] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;
+	                text[1] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;
+	                text[0] = static_cast<unsigned char>(code | 0xF0);
+                    text += 4;
+                }
+                else    // Invalid, only codes up to 0x10FFFF are allowed in Unicode
+                {
+                    RAPIDXML_PARSE_ERROR("invalid numeric character entity", text);
+                }
+            }
+        }
+
+        // Skip characters until predicate evaluates to true
+        template<class StopPred, int Flags>
+        static void skip(Ch *&text)
+        {
+            Ch *tmp = text;
+            while (StopPred::test(*tmp))
+                ++tmp;
+            text = tmp;
+        }
+
+        // Skip characters until predicate evaluates to true while doing the following:
+        // - replacing XML character entity references with proper characters (&apos; &amp; &quot; &lt; &gt; &#...;)
+        // - condensing whitespace sequences to single space character
+        template<class StopPred, class StopPredPure, int Flags>
+        static Ch *skip_and_expand_character_refs(Ch *&text)
+        {
+            // If entity translation, whitespace condense and whitespace trimming is disabled, use plain skip
+            if (Flags & parse_no_entity_translation &&
+                !(Flags & parse_normalize_whitespace) &&
+                !(Flags & parse_trim_whitespace))
+            {
+                skip<StopPred, Flags>(text);
+                return text;
+            }
+
+            // Use simple skip until first modification is detected
+            skip<StopPredPure, Flags>(text);
+
+            // Use translation skip
+            Ch *src = text;
+            Ch *dest = src;
+            while (StopPred::test(*src))
+            {
+                // If entity translation is enabled
+                if (!(Flags & parse_no_entity_translation))
+                {
+                    // Test if replacement is needed
+                    if (src[0] == Ch('&'))
+                    {
+                        switch (src[1])
+                        {
+
+                        // &amp; &apos;
+                        case Ch('a'):
+                            if (src[2] == Ch('m') && src[3] == Ch('p') && src[4] == Ch(';'))
+                            {
+                                *dest = Ch('&');
+                                ++dest;
+                                src += 5;
+                                continue;
+                            }
+                            if (src[2] == Ch('p') && src[3] == Ch('o') && src[4] == Ch('s') && src[5] == Ch(';'))
+                            {
+                                *dest = Ch('\'');
+                                ++dest;
+                                src += 6;
+                                continue;
+                            }
+                            break;
+
+                        // &quot;
+                        case Ch('q'):
+                            if (src[2] == Ch('u') && src[3] == Ch('o') && src[4] == Ch('t') && src[5] == Ch(';'))
+                            {
+                                *dest = Ch('"');
+                                ++dest;
+                                src += 6;
+                                continue;
+                            }
+                            break;
+
+                        // &gt;
+                        case Ch('g'):
+                            if (src[2] == Ch('t') && src[3] == Ch(';'))
+                            {
+                                *dest = Ch('>');
+                                ++dest;
+                                src += 4;
+                                continue;
+                            }
+                            break;
+
+                        // &lt;
+                        case Ch('l'):
+                            if (src[2] == Ch('t') && src[3] == Ch(';'))
+                            {
+                                *dest = Ch('<');
+                                ++dest;
+                                src += 4;
+                                continue;
+                            }
+                            break;
+
+                        // &#...; - assumes ASCII
+                        case Ch('#'):
+                            if (src[2] == Ch('x'))
+                            {
+                                unsigned long code = 0;
+                                src += 3;   // Skip &#x
+                                while (1)
+                                {
+                                    unsigned char digit = internal::lookup_tables<0>::lookup_digits[static_cast<unsigned char>(*src)];
+                                    if (digit == 0xFF)
+                                        break;
+                                    code = code * 16 + digit;
+                                    ++src;
+                                }
+                                insert_coded_character<Flags>(dest, code);    // Put character in output
+                            }
+                            else
+                            {
+                                unsigned long code = 0;
+                                src += 2;   // Skip &#
+                                while (1)
+                                {
+                                    unsigned char digit = internal::lookup_tables<0>::lookup_digits[static_cast<unsigned char>(*src)];
+                                    if (digit == 0xFF)
+                                        break;
+                                    code = code * 10 + digit;
+                                    ++src;
+                                }
+                                insert_coded_character<Flags>(dest, code);    // Put character in output
+                            }
+                            if (*src == Ch(';'))
+                                ++src;
+                            else
+                                RAPIDXML_PARSE_ERROR("expected ;", src);
+                            continue;
+
+                        // Something else
+                        default:
+                            // Ignore, just copy '&' verbatim
+                            break;
+
+                        }
+                    }
+                }
+
+                // If whitespace condensing is enabled
+                if (Flags & parse_normalize_whitespace)
+                {
+                    // Test if condensing is needed
+                    if (whitespace_pred::test(*src))
+                    {
+                        *dest = Ch(' '); ++dest;    // Put single space in dest
+                        ++src;                      // Skip first whitespace char
+                        // Skip remaining whitespace chars
+                        while (whitespace_pred::test(*src))
+                            ++src;
+                        continue;
+                    }
+                }
+
+                // No replacement, only copy character
+                *dest++ = *src++;
+
+            }
+
+            // Return new end
+            text = src;
+            return dest;
+
+        }
+
+        ///////////////////////////////////////////////////////////////////////
+        // Internal parsing functions
+
+        // Parse BOM, if any
+        template<int Flags>
+        void parse_bom(Ch *&text)
+        {
+            // UTF-8?
+            if (static_cast<unsigned char>(text[0]) == 0xEF &&
+                static_cast<unsigned char>(text[1]) == 0xBB &&
+                static_cast<unsigned char>(text[2]) == 0xBF)
+            {
+                text += 3;      // Skup utf-8 bom
+            }
+        }
+
+        // Parse XML declaration (<?xml...)
+        template<int Flags>
+        xml_node<Ch> *parse_xml_declaration(Ch *&text)
+        {
+            // If parsing of declaration is disabled
+            if (!(Flags & parse_declaration_node))
+            {
+                // Skip until end of declaration
+                while (text[0] != Ch('?') || text[1] != Ch('>'))
+                {
+                    if (!text[0])
+                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                    ++text;
+                }
+                text += 2;    // Skip '?>'
+                return 0;
+            }
+
+            // Create declaration
+            xml_node<Ch> *declaration = this->allocate_node(node_declaration);
+
+            // Skip whitespace before attributes or ?>
+            skip<whitespace_pred, Flags>(text);
+
+            // Parse declaration attributes
+            parse_node_attributes<Flags>(text, declaration);
+
+            // Skip ?>
+            if (text[0] != Ch('?') || text[1] != Ch('>'))
+                RAPIDXML_PARSE_ERROR("expected ?>", text);
+            text += 2;
+
+            return declaration;
+        }
+
+        // Parse XML comment (<!--...)
+        template<int Flags>
+        xml_node<Ch> *parse_comment(Ch *&text)
+        {
+            // If parsing of comments is disabled
+            if (!(Flags & parse_comment_nodes))
+            {
+                // Skip until end of comment
+                while (text[0] != Ch('-') || text[1] != Ch('-') || text[2] != Ch('>'))
+                {
+                    if (!text[0])
+                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                    ++text;
+                }
+                text += 3;     // Skip '-->'
+                return 0;      // Do not produce comment node
+            }
+
+            // Remember value start
+            Ch *value = text;
+
+            // Skip until end of comment
+            while (text[0] != Ch('-') || text[1] != Ch('-') || text[2] != Ch('>'))
+            {
+                if (!text[0])
+                    RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                ++text;
+            }
+
+            // Create comment node
+            xml_node<Ch> *comment = this->allocate_node(node_comment);
+            comment->value(value, text - value);
+
+            // Place zero terminator after comment value
+            if (!(Flags & parse_no_string_terminators))
+                *text = Ch('\0');
+
+            text += 3;     // Skip '-->'
+            return comment;
+        }
+
+        // Parse DOCTYPE
+        template<int Flags>
+        xml_node<Ch> *parse_doctype(Ch *&text)
+        {
+            // Remember value start
+            Ch *value = text;
+
+            // Skip to >
+            while (*text != Ch('>'))
+            {
+                // Determine character type
+                switch (*text)
+                {
+
+                // If '[' encountered, scan for matching ending ']' using naive algorithm with depth
+                // This works for all W3C test files except for 2 most wicked
+                case Ch('['):
+                {
+                    ++text;     // Skip '['
+                    int depth = 1;
+                    while (depth > 0)
+                    {
+                        switch (*text)
+                        {
+                            case Ch('['): ++depth; break;
+                            case Ch(']'): --depth; break;
+                            case 0: RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                        }
+                        ++text;
+                    }
+                    break;
+                }
+
+                // Error on end of text
+                case Ch('\0'):
+                    RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+
+                // Other character, skip it
+                default:
+                    ++text;
+
+                }
+            }
+
+            // If DOCTYPE nodes enabled
+            if (Flags & parse_doctype_node)
+            {
+                // Create a new doctype node
+                xml_node<Ch> *doctype = this->allocate_node(node_doctype);
+                doctype->value(value, text - value);
+
+                // Place zero terminator after value
+                if (!(Flags & parse_no_string_terminators))
+                    *text = Ch('\0');
+
+                text += 1;      // skip '>'
+                return doctype;
+            }
+            else
+            {
+                text += 1;      // skip '>'
+                return 0;
+            }
+
+        }
+
+        // Parse PI
+        template<int Flags>
+        xml_node<Ch> *parse_pi(Ch *&text)
+        {
+            // If creation of PI nodes is enabled
+            if (Flags & parse_pi_nodes)
+            {
+                // Create pi node
+                xml_node<Ch> *pi = this->allocate_node(node_pi);
+
+                // Extract PI target name
+                Ch *name = text;
+                skip<node_name_pred, Flags>(text);
+                if (text == name)
+                    RAPIDXML_PARSE_ERROR("expected PI target", text);
+                pi->name(name, text - name);
+
+                // Skip whitespace between pi target and pi
+                skip<whitespace_pred, Flags>(text);
+
+                // Remember start of pi
+                Ch *value = text;
+
+                // Skip to '?>'
+                while (text[0] != Ch('?') || text[1] != Ch('>'))
+                {
+                    if (*text == Ch('\0'))
+                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                    ++text;
+                }
+
+                // Set pi value (verbatim, no entity expansion or whitespace normalization)
+                pi->value(value, text - value);
+
+                // Place zero terminator after name and value
+                if (!(Flags & parse_no_string_terminators))
+                {
+                    pi->name()[pi->name_size()] = Ch('\0');
+                    pi->value()[pi->value_size()] = Ch('\0');
+                }
+
+                text += 2;                          // Skip '?>'
+                return pi;
+            }
+            else
+            {
+                // Skip to '?>'
+                while (text[0] != Ch('?') || text[1] != Ch('>'))
+                {
+                    if (*text == Ch('\0'))
+                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                    ++text;
+                }
+                text += 2;    // Skip '?>'
+                return 0;
+            }
+        }
+
+        // Parse and append data
+        // Return character that ends data.
+        // This is necessary because this character might have been overwritten by a terminating 0
+        template<int Flags>
+        Ch parse_and_append_data(xml_node<Ch> *node, Ch *&text, Ch *contents_start)
+        {
+            // Backup to contents start if whitespace trimming is disabled
+            if (!(Flags & parse_trim_whitespace))
+                text = contents_start;
+
+            // Skip until end of data
+            Ch *value = text, *end;
+            if (Flags & parse_normalize_whitespace)
+                end = skip_and_expand_character_refs<text_pred, text_pure_with_ws_pred, Flags>(text);
+            else
+                end = skip_and_expand_character_refs<text_pred, text_pure_no_ws_pred, Flags>(text);
+
+            // Trim trailing whitespace if flag is set; leading was already trimmed by whitespace skip after >
+            if (Flags & parse_trim_whitespace)
+            {
+                if (Flags & parse_normalize_whitespace)
+                {
+                    // Whitespace is already condensed to single space characters by skipping function, so just trim 1 char off the end
+                    if (*(end - 1) == Ch(' '))
+                        --end;
+                }
+                else
+                {
+                    // Backup until non-whitespace character is found
+                    while (whitespace_pred::test(*(end - 1)))
+                        --end;
+                }
+            }
+
+            // If characters are still left between end and value (this test is only necessary if normalization is enabled)
+            // Create new data node
+            if (!(Flags & parse_no_data_nodes))
+            {
+                xml_node<Ch> *data = this->allocate_node(node_data);
+                data->value(value, end - value);
+                node->append_node(data);
+            }
+
+            // Add data to parent node if no data exists yet
+            if (!(Flags & parse_no_element_values))
+                if (*node->value() == Ch('\0'))
+                    node->value(value, end - value);
+
+            // Place zero terminator after value
+            if (!(Flags & parse_no_string_terminators))
+            {
+                Ch ch = *text;
+                *end = Ch('\0');
+                return ch;      // Return character that ends data; this is required because zero terminator overwritten it
+            }
+
+            // Return character that ends data
+            return *text;
+        }
+
+        // Parse CDATA
+        template<int Flags>
+        xml_node<Ch> *parse_cdata(Ch *&text)
+        {
+            // If CDATA is disabled
+            if (Flags & parse_no_data_nodes)
+            {
+                // Skip until end of cdata
+                while (text[0] != Ch(']') || text[1] != Ch(']') || text[2] != Ch('>'))
+                {
+                    if (!text[0])
+                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                    ++text;
+                }
+                text += 3;      // Skip ]]>
+                return 0;       // Do not produce CDATA node
+            }
+
+            // Skip until end of cdata
+            Ch *value = text;
+            while (text[0] != Ch(']') || text[1] != Ch(']') || text[2] != Ch('>'))
+            {
+                if (!text[0])
+                    RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                ++text;
+            }
+
+            // Create new cdata node
+            xml_node<Ch> *cdata = this->allocate_node(node_cdata);
+            cdata->value(value, text - value);
+
+            // Place zero terminator after value
+            if (!(Flags & parse_no_string_terminators))
+                *text = Ch('\0');
+
+            text += 3;      // Skip ]]>
+            return cdata;
+        }
+
+        // Parse element node
+        template<int Flags, class NamespaceScope>
+        xml_node<Ch> *parse_element(Ch *&text, NamespaceScope namespace_scope)
+        {
+            // Create element node
+            xml_node<Ch> *element = this->allocate_node(node_element);
+
+            // Extract element name
+            Ch *name = text;
+            if (Flags & parse_no_namespace)
+                skip<node_name_pred, Flags>(text);
+            else
+                skip<node_ncname_pred, Flags>(text);
+            if (text == name)
+                RAPIDXML_PARSE_ERROR("expected element name", text);
+            if ((Flags & parse_no_namespace) == 0 && *text == Ch(':'))
+            {
+                // Namespace prefix found
+                ++text;
+                Ch *local_name = text;
+                skip<node_ncname_pred, Flags>(text);
+                if (*text == Ch(':'))
+                    RAPIDXML_PARSE_ERROR("second colon in element name", text);
+                if (text == local_name)
+                    RAPIDXML_PARSE_ERROR("expected local part of element name", text);
+                element->qname(name, text - name, local_name);
+            }
+            else
+                element->qname(name, text - name);
+
+            // Skip whitespace between element name and attributes or >
+            skip<whitespace_pred, Flags>(text);
+
+            // Parse attributes, if any
+            parse_node_attributes<Flags>(text, element);
+
+            // Setting attributes and element own namespace_uri, adding declared
+            // namespace prefixes and probably setting default namespace
+            namespace_scope.process_element(element);
+
+            // Determine ending type
+            if (*text == Ch('>'))
+            {
+                ++text;
+                parse_node_contents<Flags, NamespaceScope>(text, element, namespace_scope);
+            }
+            else if (*text == Ch('/'))
+            {
+                ++text;
+                if (*text != Ch('>'))
+                    RAPIDXML_PARSE_ERROR("expected >", text);
+                ++text;
+            }
+            else
+                RAPIDXML_PARSE_ERROR("expected >", text);
+
+            // Place zero terminator after name
+            if (!(Flags & parse_no_string_terminators))
+                element->name()[element->name_size()] = Ch('\0');
+
+            // Return parsed element
+            return element;
+        }
+
+        // Determine node type, and parse it
+        template<int Flags, class NamespaceScope>
+        xml_node<Ch> *parse_node(Ch *&text, NamespaceScope const & namespace_scope)
+        {
+            // Parse proper node type
+            switch (text[0])
+            {
+
+            // <...
+            default:
+                // Parse and append element node
+                return parse_element<Flags, NamespaceScope>(text, namespace_scope);
+
+            // <?...
+            case Ch('?'):
+                ++text;     // Skip ?
+                if ((text[0] == Ch('x') || text[0] == Ch('X')) &&
+                    (text[1] == Ch('m') || text[1] == Ch('M')) &&
+                    (text[2] == Ch('l') || text[2] == Ch('L')) &&
+                    whitespace_pred::test(text[3]))
+                {
+                    // '<?xml ' - xml declaration
+                    text += 4;      // Skip 'xml '
+                    return parse_xml_declaration<Flags>(text);
+                }
+                else
+                {
+                    // Parse PI
+                    return parse_pi<Flags>(text);
+                }
+
+            // <!...
+            case Ch('!'):
+
+                // Parse proper subset of <! node
+                switch (text[1])
+                {
+
+                // <!-
+                case Ch('-'):
+                    if (text[2] == Ch('-'))
+                    {
+                        // '<!--' - xml comment
+                        text += 3;     // Skip '!--'
+                        return parse_comment<Flags>(text);
+                    }
+                    break;
+
+                // <![
+                case Ch('['):
+                    if (text[2] == Ch('C') && text[3] == Ch('D') && text[4] == Ch('A') &&
+                        text[5] == Ch('T') && text[6] == Ch('A') && text[7] == Ch('['))
+                    {
+                        // '<![CDATA[' - cdata
+                        text += 8;     // Skip '![CDATA['
+                        return parse_cdata<Flags>(text);
+                    }
+                    break;
+
+                // <!D
+                case Ch('D'):
+                    if (text[2] == Ch('O') && text[3] == Ch('C') && text[4] == Ch('T') &&
+                        text[5] == Ch('Y') && text[6] == Ch('P') && text[7] == Ch('E') &&
+                        whitespace_pred::test(text[8]))
+                    {
+                        // '<!DOCTYPE ' - doctype
+                        text += 9;      // skip '!DOCTYPE '
+                        return parse_doctype<Flags>(text);
+                    }
+
+                }   // switch
+
+                // Attempt to skip other, unrecognized node types starting with <!
+                ++text;     // Skip !
+                while (*text != Ch('>'))
+                {
+                    if (*text == 0)
+                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                    ++text;
+                }
+                ++text;     // Skip '>'
+                return 0;   // No node recognized
+
+            }
+        }
+
+        // Parse contents of the node - children, data etc.
+        template<int Flags, class NamespaceScope>
+        void parse_node_contents(Ch *&text, xml_node<Ch> *node, NamespaceScope const & namespace_scope)
+        {
+            // For all children and text
+            while (1)
+            {
+                // Skip whitespace between > and node contents
+                Ch *contents_start = text;      // Store start of node contents before whitespace is skipped
+                skip<whitespace_pred, Flags>(text);
+                Ch next_char = *text;
+
+            // After data nodes, instead of continuing the loop, control jumps here.
+            // This is because zero termination inside parse_and_append_data() function
+            // would wreak havoc with the above code.
+            // Also, skipping whitespace after data nodes is unnecessary.
+            after_data_node:
+
+                // Determine what comes next: node closing, child node, data node, or 0?
+                switch (next_char)
+                {
+
+                // Node closing or child node
+                case Ch('<'):
+                    if (text[1] == Ch('/'))
+                    {
+                        // Node closing
+                        text += 2;      // Skip '</'
+                        if (Flags & parse_validate_closing_tags)
+                        {
+                            // Skip and validate closing tag name
+                            Ch *closing_name = text;
+                            skip<node_name_pred, Flags>(text);
+                            if (!internal::compare(node->name(), node->name_size(), closing_name, text - closing_name, true))
+                                RAPIDXML_PARSE_ERROR("invalid closing tag name", text);
+                        }
+                        else
+                        {
+                            // No validation, just skip name
+                            skip<node_name_pred, Flags>(text);
+                        }
+                        // Skip remaining whitespace after node name
+                        skip<whitespace_pred, Flags>(text);
+                        if (*text != Ch('>'))
+                            RAPIDXML_PARSE_ERROR("expected >", text);
+                        ++text;     // Skip '>'
+                        return;     // Node closed, finished parsing contents
+                    }
+                    else
+                    {
+                        // Child node
+                        ++text;     // Skip '<'
+                        if (xml_node<Ch> *child = parse_node<Flags, NamespaceScope>(text, namespace_scope))
+                            node->append_node(child);
+                    }
+                    break;
+
+                // End of data - error
+                case Ch('\0'):
+                    RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+
+                // Data node
+                default:
+                    next_char = parse_and_append_data<Flags>(node, text, contents_start);
+                    goto after_data_node;   // Bypass regular processing after data nodes
+
+                }
+            }
+        }
+
+        // Parse XML attributes of the node
+        template<int Flags>
+        void parse_node_attributes(Ch *&text, xml_node<Ch> *node)
+        {
+            // For all attributes
+            while ((Flags & parse_no_namespace)
+                ? attribute_name_pred::test(*text)
+                : attribute_ncname_pred::test(*text))
+            {
+                // Extract attribute name
+                Ch *name = text;
+                ++text;     // Skip first character of attribute name
+                if (Flags & parse_no_namespace)
+                    skip<attribute_name_pred, Flags>(text);
+                else
+                    skip<attribute_ncname_pred, Flags>(text);
+                if (text == name)
+                    RAPIDXML_PARSE_ERROR("expected attribute name", name);
+                // Create new attribute
+                xml_attribute<Ch> *attribute = this->allocate_attribute();
+                if ((Flags & parse_no_namespace) == 0 && *text == Ch(':'))
+                {
+                    // Namespace prefix found
+                    ++text;
+                    Ch *local_name = text;
+                    skip<attribute_ncname_pred, Flags>(text);
+                    if (text == local_name)
+                        RAPIDXML_PARSE_ERROR("expected local part of attribute name", local_name);
+                    attribute->qname(name, text - name, local_name);
+                }
+                else
+                    attribute->qname(name, text - name);
+
+                node->append_attribute(attribute);
+
+                // Skip whitespace after attribute name
+                skip<whitespace_pred, Flags>(text);
+
+                // Skip =
+                if (*text != Ch('='))
+                    RAPIDXML_PARSE_ERROR("expected =", text);
+                ++text;
+
+                // Add terminating zero after name
+                if (!(Flags & parse_no_string_terminators))
+                    attribute->name()[attribute->name_size()] = 0;
+
+                // Skip whitespace after =
+                skip<whitespace_pred, Flags>(text);
+
+                // Skip quote and remember if it was ' or "
+                Ch quote = *text;
+                if (quote != Ch('\'') && quote != Ch('"'))
+                    RAPIDXML_PARSE_ERROR("expected ' or \"", text);
+                ++text;
+
+                // Extract attribute value and expand char refs in it
+                Ch *value = text, *end;
+                const int AttFlags = Flags & ~parse_normalize_whitespace;   // No whitespace normalization in attributes
+                if (quote == Ch('\''))
+                    end = skip_and_expand_character_refs<attribute_value_pred<Ch('\'')>, attribute_value_pure_pred<Ch('\'')>, AttFlags>(text);
+                else
+                    end = skip_and_expand_character_refs<attribute_value_pred<Ch('"')>, attribute_value_pure_pred<Ch('"')>, AttFlags>(text);
+
+                // Set attribute value
+                attribute->value(value, end - value);
+
+                // Make sure that end quote is present
+                if (*text != quote)
+                    RAPIDXML_PARSE_ERROR("expected ' or \"", text);
+                ++text;     // Skip quote
+
+                // Add terminating zero after value
+                if (!(Flags & parse_no_string_terminators))
+                    attribute->value()[attribute->value_size()] = 0;
+
+                // Skip whitespace after attribute value
+                skip<whitespace_pred, Flags>(text);
+            }
+        }
+
+    };
+
+    //! \cond internal
+    namespace internal
+    {
+
+        // Whitespace (space \n \r \t)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_whitespace[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  0,  // 0
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 1
+             1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 2
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 3
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 4
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 5
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 6
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 7
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 8
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 9
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // A
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // B
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // C
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // D
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // E
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0   // F
+        };
+
+        // Node name (anything but space \n \r \t / > ? \0)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_node_name[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Node NCName (anything but space \n \r \t / > ? \0 :)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_node_ncname[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  0,  0,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Text (i.e. PCDATA) (anything but < \0)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_text[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Text (i.e. PCDATA) that does not require processing when ws normalization is disabled
+        // (anything but < \0 &)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_text_pure_no_ws[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Text (i.e. PCDATA) that does not require processing when ws normalizationis is enabled
+        // (anything but < \0 & space \n \r \t)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_text_pure_with_ws[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             0,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Attribute name (anything but space \n \r \t / < > = ? ! \0)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_attribute_name[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+        // Attribute name (anything but space \n \r \t / < > = ? ! \0 :)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_attribute_ncname[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  0,  0,  0,  0,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Attribute data with single quote (anything but ' \0)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_1[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Attribute data with single quote that does not require processing (anything but ' \0 &)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_1_pure[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Attribute data with double quote (anything but " \0)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_2[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Attribute data with double quote that does not require processing (anything but " \0 &)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_2_pure[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             1,  1,  0,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Digits (dec and hex, 255 denotes end of numeric character reference)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_digits[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 0
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 1
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 2
+             0,  1,  2,  3,  4,  5,  6,  7,  8,  9,255,255,255,255,255,255,  // 3
+           255, 10, 11, 12, 13, 14, 15,255,255,255,255,255,255,255,255,255,  // 4
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 5
+           255, 10, 11, 12, 13, 14, 15,255,255,255,255,255,255,255,255,255,  // 6
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 7
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 8
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 9
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // A
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // B
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // C
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // D
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // E
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255   // F
+        };
+
+        // Upper case conversion
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_upcase[256] =
+        {
+          // 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  A   B   C   D   E   F
+           0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15,   // 0
+           16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,   // 1
+           32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,   // 2
+           48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,   // 3
+           64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,   // 4
+           80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,   // 5
+           96, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,   // 6
+           80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 123,124,125,126,127,  // 7
+           128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,  // 8
+           144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,  // 9
+           160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,  // A
+           176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,  // B
+           192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,  // C
+           208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,  // D
+           224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,  // E
+           240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255   // F
+        };
+    }
+    //! \endcond
+
+}
+
+// Undefine internal macros
+#undef RAPIDXML_PARSE_ERROR
+
+// On MSVC, restore warnings state
+#ifdef _MSC_VER
+    #pragma warning(pop)
+#endif
+
+#endif
Index: indigo-src/indigo/api/c/indigo/indigo.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/indigo.h b/indigo-src/indigo/api/c/indigo/indigo.h
--- a/indigo-src/indigo/api/c/indigo/indigo.h	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/indigo.h	(date 1745648090774)
@@ -20,6 +20,7 @@
 #define __indigo__
 
 #include <stdint.h>
+#include "indigo_export.h"
 
 #if defined(_WIN32) && !defined(__MINGW32__)
 #define qword unsigned __int64
@@ -27,6 +28,7 @@
 #define qword unsigned long long
 #endif
 
+#if 0
 #ifndef EXPORT_SYMBOL
 #ifdef _WIN32
 #define EXPORT_SYMBOL __declspec(dllexport)
@@ -39,9 +41,10 @@
 
 #ifndef CEXPORT
 #ifndef __cplusplus
-#define CEXPORT EXPORT_SYMBOL
+#define INDIGO_EXPORT EXPORT_SYMBOL
 #else
-#define CEXPORT extern "C" EXPORT_SYMBOL
+#define INDIGO_EXPORT extern "C" EXPORT_SYMBOL
+#endif
 #endif
 #endif
 
@@ -50,6 +53,9 @@
 typedef unsigned char byte;
 #endif
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 /* All integer and float functions return -1 on error. */
 /* All string functions return zero pointer on error. */
 
@@ -58,55 +64,55 @@
 
 /* System */
 
-CEXPORT const char* indigoVersion();
-CEXPORT const char* indigoVersionInfo();
+INDIGO_EXPORT const char* indigoVersion();
+INDIGO_EXPORT const char* indigoVersionInfo();
 
 // Allocate a new session. Each session has its own
 // set of objects created and options set up.
-CEXPORT qword indigoAllocSessionId();
+INDIGO_EXPORT qword indigoAllocSessionId();
 // Switch to another session. The session, if was not allocated
 // previously, is allocated automatically and initialized with
 // empty set of objects and default options.
-CEXPORT void indigoSetSessionId(qword id);
+INDIGO_EXPORT void indigoSetSessionId(qword id);
 // Release session. The memory used by the released session
 // is not freed, but the number will be reused on
 // further allocations.
-CEXPORT void indigoReleaseSessionId(qword id);
+INDIGO_EXPORT void indigoReleaseSessionId(qword id);
 
 // Get the last error message
-CEXPORT const char* indigoGetLastError(void);
+INDIGO_EXPORT const char *indigoGetLastError(void);
 
-typedef void (*INDIGO_ERROR_HANDLER)(const char* message, void* context);
-CEXPORT void indigoSetErrorHandler(INDIGO_ERROR_HANDLER handler, void* context);
+typedef void (*INDIGO_ERROR_HANDLER)(const char *message, void *context);
+INDIGO_EXPORT void indigoSetErrorHandler(INDIGO_ERROR_HANDLER handler, void *context);
 
 // Free an object
-CEXPORT int indigoFree(int handle);
+INDIGO_EXPORT int indigoFree(int handle);
 // Clone an object
-CEXPORT int indigoClone(int object);
+INDIGO_EXPORT int indigoClone(int object);
 // Count object currently allocated
-CEXPORT int indigoCountReferences(void);
+INDIGO_EXPORT int indigoCountReferences(void);
 
 // Deallocate all the objects in the current session
-CEXPORT int indigoFreeAllObjects();
+INDIGO_EXPORT int indigoFreeAllObjects();
 
 /* Options */
 
-CEXPORT int indigoSetOption(const char* name, const char* value);
-CEXPORT int indigoSetOptionInt(const char* name, int value);
-CEXPORT int indigoSetOptionBool(const char* name, int value);
-CEXPORT int indigoSetOptionFloat(const char* name, float value);
-CEXPORT int indigoSetOptionColor(const char* name, float r, float g, float b);
-CEXPORT int indigoSetOptionXY(const char* name, int x, int y);
-CEXPORT int indigoResetOptions();
+INDIGO_EXPORT int indigoSetOption(const char *name, const char *value);
+INDIGO_EXPORT int indigoSetOptionInt(const char *name, int value);
+INDIGO_EXPORT int indigoSetOptionBool(const char *name, int value);
+INDIGO_EXPORT int indigoSetOptionFloat(const char *name, float value);
+INDIGO_EXPORT int indigoSetOptionColor(const char *name, float r, float g, float b);
+INDIGO_EXPORT int indigoSetOptionXY(const char *name, int x, int y);
+INDIGO_EXPORT int indigoResetOptions();
 
-CEXPORT const char* indigoGetOption(const char* name);
-CEXPORT int indigoGetOptionInt(const char* name, int* value);
-CEXPORT int indigoGetOptionBool(const char* name, int* value);
-CEXPORT int indigoGetOptionFloat(const char* name, float* value);
-CEXPORT int indigoGetOptionColor(const char* name, float* r, float* g, float* b);
-CEXPORT int indigoGetOptionXY(const char* name, int* x, int* y);
+INDIGO_EXPORT const char *indigoGetOption(const char *name);
+INDIGO_EXPORT int indigoGetOptionInt(const char *name, int *value);
+INDIGO_EXPORT int indigoGetOptionBool(const char *name, int *value);
+INDIGO_EXPORT int indigoGetOptionFloat(const char *name, float *value);
+INDIGO_EXPORT int indigoGetOptionColor(const char *name, float *r, float *g, float *b);
+INDIGO_EXPORT int indigoGetOptionXY(const char *name, int *x, int *y);
 
-CEXPORT const char* indigoGetOptionType(const char* name);
+INDIGO_EXPORT const char *indigoGetOptionType(const char *name);
 
 /* Basic input-output */
 
@@ -116,19 +122,19 @@
 // string/buffer. All these functions are low-level and
 // rarely needed to anyone.
 
-CEXPORT int indigoReadFile(const char* filename);
-CEXPORT int indigoReadString(const char* str);
-CEXPORT int indigoLoadString(const char* str);
-CEXPORT int indigoReadBuffer(const char* buffer, int size);
-CEXPORT int indigoLoadBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoReadFile(const char *filename);
+INDIGO_EXPORT int indigoReadString(const char *str);
+INDIGO_EXPORT int indigoLoadString(const char *str);
+INDIGO_EXPORT int indigoReadBuffer(const char *buffer, int size);
+INDIGO_EXPORT int indigoLoadBuffer(const char *buffer, int size);
 
 // indigoWrite*** return a new writer object.
 
-CEXPORT int indigoWriteFile(const char* filename);
-CEXPORT int indigoWriteBuffer(void);
+INDIGO_EXPORT int indigoWriteFile(const char *filename);
+INDIGO_EXPORT int indigoWriteBuffer(void);
 
 // Closes the file output stream but does not delete the object
-CEXPORT int indigoClose(int output);
+INDIGO_EXPORT int indigoClose(int output);
 
 /* Iterators */
 
@@ -160,116 +166,116 @@
  */
 
 // Obtains the next element, returns zero if there is no next element
-CEXPORT int indigoNext(int iter);
+INDIGO_EXPORT int indigoNext(int iter);
 // Does not obtain the next element, just tells if there is one
-CEXPORT int indigoHasNext(int iter);
+INDIGO_EXPORT int indigoHasNext(int iter);
 // Returns the index of the element
-CEXPORT int indigoIndex(int item);
+INDIGO_EXPORT int indigoIndex(int item);
 
 // Removes the item from its container (usually a molecule)
-CEXPORT int indigoRemove(int item);
+INDIGO_EXPORT int indigoRemove(int item);
 
 /* Molecules, query molecules, SMARTS */
 
-CEXPORT const char* indigoGetOriginalFormat(int item);
+INDIGO_EXPORT const char* indigoGetOriginalFormat(int item);
 
-CEXPORT int indigoCreateMolecule(void);
-CEXPORT int indigoCreateQueryMolecule(void);
+INDIGO_EXPORT int indigoCreateMolecule(void);
+INDIGO_EXPORT int indigoCreateQueryMolecule(void);
 
-CEXPORT int indigoLoadStructureFromString(const char* string, const char* params);
-CEXPORT int indigoLoadStructureFromBuffer(const byte* string, int bufferSize, const char* params);
-CEXPORT int indigoLoadStructureFromFile(const char* filename, const char* params);
+INDIGO_EXPORT int indigoLoadStructureFromString(const char* string, const char* params);
+INDIGO_EXPORT int indigoLoadStructureFromBuffer(const byte* string, int bufferSize, const char* params);
+INDIGO_EXPORT int indigoLoadStructureFromFile(const char* filename, const char* params);
 
-CEXPORT int indigoLoadMolecule(int source);
-CEXPORT int indigoLoadMoleculeFromString(const char* string);
-CEXPORT int indigoLoadMoleculeFromFile(const char* filename);
-CEXPORT int indigoLoadMoleculeFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadMolecule(int source);
+INDIGO_EXPORT int indigoLoadMoleculeFromString(const char* string);
+INDIGO_EXPORT int indigoLoadMoleculeFromFile(const char* filename);
+INDIGO_EXPORT int indigoLoadMoleculeFromBuffer(const char* buffer, int size);
 
-CEXPORT int indigoLoadQueryMolecule(int source);
-CEXPORT int indigoLoadQueryMoleculeFromString(const char* string);
-CEXPORT int indigoLoadQueryMoleculeFromFile(const char* filename);
-CEXPORT int indigoLoadQueryMoleculeFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadQueryMolecule(int source);
+INDIGO_EXPORT int indigoLoadQueryMoleculeFromString(const char* string);
+INDIGO_EXPORT int indigoLoadQueryMoleculeFromFile(const char* filename);
+INDIGO_EXPORT int indigoLoadQueryMoleculeFromBuffer(const char* buffer, int size);
 
-CEXPORT int indigoLoadSmarts(int source);
-CEXPORT int indigoLoadSmartsFromString(const char* string);
-CEXPORT int indigoLoadSmartsFromFile(const char* filename);
-CEXPORT int indigoLoadSmartsFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadSmarts(int source);
+INDIGO_EXPORT int indigoLoadSmartsFromString(const char* string);
+INDIGO_EXPORT int indigoLoadSmartsFromFile(const char* filename);
+INDIGO_EXPORT int indigoLoadSmartsFromBuffer(const char* buffer, int size);
 
-CEXPORT int indigoLoadMonomerLibrary(int source);
-CEXPORT int indigoLoadMonomerLibraryFromString(const char* string);
-CEXPORT int indigoLoadMonomerLibraryFromFile(const char* filename);
-CEXPORT int indigoLoadMonomerLibraryFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadMonomerLibrary(int source);
+INDIGO_EXPORT int indigoLoadMonomerLibraryFromString(const char* string);
+INDIGO_EXPORT int indigoLoadMonomerLibraryFromFile(const char* filename);
+INDIGO_EXPORT int indigoLoadMonomerLibraryFromBuffer(const char* buffer, int size);
 
-CEXPORT int indigoLoadKetDocument(int source);
-CEXPORT int indigoLoadKetDocumentFromString(const char* string);
-CEXPORT int indigoLoadKetDocumentFromFile(const char* filename);
-CEXPORT int indigoLoadKetDocumentFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadKetDocument(int source);
+INDIGO_EXPORT int indigoLoadKetDocumentFromString(const char* string);
+INDIGO_EXPORT int indigoLoadKetDocumentFromFile(const char* filename);
+INDIGO_EXPORT int indigoLoadKetDocumentFromBuffer(const char* buffer, int size);
 
-CEXPORT int indigoLoadSequence(int source, const char* seq_type, int library);
-CEXPORT int indigoLoadSequenceFromString(const char* string, const char* seq_type, int library);
-CEXPORT int indigoLoadSequenceFromFile(const char* filename, const char* seq_type, int library);
+INDIGO_EXPORT int indigoLoadSequence(int source, const char* seq_type, int library);
+INDIGO_EXPORT int indigoLoadSequenceFromString(const char* string, const char* seq_type, int library);
+INDIGO_EXPORT int indigoLoadSequenceFromFile(const char* filename, const char* seq_type, int library);
 
-CEXPORT int indigoLoadFasta(int source, const char* seq_type, int library);
-CEXPORT int indigoLoadFastaFromString(const char* string, const char* seq_type, int library);
-CEXPORT int indigoLoadFastaFromFile(const char* filename, const char* seq_type, int library);
+INDIGO_EXPORT int indigoLoadFasta(int source, const char* seq_type, int library);
+INDIGO_EXPORT int indigoLoadFastaFromString(const char* string, const char* seq_type, int library);
+INDIGO_EXPORT int indigoLoadFastaFromFile(const char* filename, const char* seq_type, int library);
 
-CEXPORT int indigoLoadIdt(int source, int library);
-CEXPORT int indigoLoadIdtFromString(const char* string, int library);
-CEXPORT int indigoLoadIdtFromFile(const char* filename, int library);
+INDIGO_EXPORT int indigoLoadIdt(int source, int library);
+INDIGO_EXPORT int indigoLoadIdtFromString(const char* string, int library);
+INDIGO_EXPORT int indigoLoadIdtFromFile(const char* filename, int library);
 
-CEXPORT int indigoLoadHelm(int source, int library);
-CEXPORT int indigoLoadHelmFromString(const char* string, int library);
-CEXPORT int indigoLoadHelmFromFile(const char* filename, int library);
+INDIGO_EXPORT int indigoLoadHelm(int source, int library);
+INDIGO_EXPORT int indigoLoadHelmFromString(const char* string, int library);
+INDIGO_EXPORT int indigoLoadHelmFromFile(const char* filename, int library);
 
-CEXPORT int indigoSaveMolfile(int molecule, int output);
-CEXPORT int indigoSaveMolfileToFile(int molecule, const char* filename);
-CEXPORT const char* indigoMolfile(int molecule);
+INDIGO_EXPORT int indigoSaveMolfile(int molecule, int output);
+INDIGO_EXPORT int indigoSaveMolfileToFile(int molecule, const char* filename);
+INDIGO_EXPORT const char* indigoMolfile(int molecule);
 
-CEXPORT int indigoSaveSequence(int molecule, int output, int library);
-CEXPORT int indigoSaveSequenceToFile(int molecule, const char* filename, int library);
-CEXPORT const char* indigoSequence(int molecule, int library);
+INDIGO_EXPORT int indigoSaveSequence(int molecule, int output, int library);
+INDIGO_EXPORT int indigoSaveSequenceToFile(int molecule, const char* filename, int library);
+INDIGO_EXPORT const char* indigoSequence(int molecule, int library);
 
-CEXPORT int indigoSaveSequence3Letter(int molecule, int output, int library);
-CEXPORT int indigoSaveSequence3LetterToFile(int molecule, const char* filename, int library);
-CEXPORT const char* indigoSequence3Letter(int molecule, int library);
+INDIGO_EXPORT int indigoSaveSequence3Letter(int molecule, int output, int library);
+INDIGO_EXPORT int indigoSaveSequence3LetterToFile(int molecule, const char* filename, int library);
+INDIGO_EXPORT const char* indigoSequence3Letter(int molecule, int library);
 
-CEXPORT int indigoSaveFasta(int molecule, int output, int library);
-CEXPORT int indigoSaveFastaToFile(int molecule, const char* filename, int library);
-CEXPORT const char* indigoFasta(int molecule, int library);
+INDIGO_EXPORT int indigoSaveFasta(int molecule, int output, int library);
+INDIGO_EXPORT int indigoSaveFastaToFile(int molecule, const char* filename, int library);
+INDIGO_EXPORT const char* indigoFasta(int molecule, int library);
 
-CEXPORT int indigoSaveIdt(int molecule, int output, int library);
-CEXPORT int indigoSaveIdtToFile(int molecule, const char* filename, int library);
-CEXPORT const char* indigoIdt(int molecule, int library);
+INDIGO_EXPORT int indigoSaveIdt(int molecule, int output, int library);
+INDIGO_EXPORT int indigoSaveIdtToFile(int molecule, const char* filename, int library);
+INDIGO_EXPORT const char* indigoIdt(int molecule, int library);
 
-CEXPORT int indigoSaveHelm(int molecule, int output, int library);
-CEXPORT int indigoSaveHelmToFile(int molecule, const char* filename, int library);
-CEXPORT const char* indigoHelm(int molecule, int library);
+INDIGO_EXPORT int indigoSaveHelm(int molecule, int output, int library);
+INDIGO_EXPORT int indigoSaveHelmToFile(int molecule, const char* filename, int library);
+INDIGO_EXPORT const char* indigoHelm(int molecule, int library);
 
-CEXPORT int indigoSaveJsonToFile(int item, const char* filename);
-CEXPORT int indigoSaveJson(int item, int output);
+INDIGO_EXPORT int indigoSaveJsonToFile(int item, const char* filename);
+INDIGO_EXPORT int indigoSaveJson(int item, int output);
 
 // accepts molecules and reactions (but not query ones)
-CEXPORT int indigoSaveCml(int object, int output);
-CEXPORT int indigoSaveCmlToFile(int object, const char* filename);
-CEXPORT const char* indigoCml(int object);
-CEXPORT const char* indigoCdxBase64(int object);
+INDIGO_EXPORT int indigoSaveCml(int object, int output);
+INDIGO_EXPORT int indigoSaveCmlToFile(int object, const char* filename);
+INDIGO_EXPORT const char* indigoCml(int object);
+INDIGO_EXPORT const char* indigoCdxBase64(int object);
 
 // accepts molecules and reactions
-CEXPORT int indigoSaveCdxml(int object, int output);
-CEXPORT int indigoSaveCdx(int item, int output);
+INDIGO_EXPORT int indigoSaveCdxml(int object, int output);
+INDIGO_EXPORT int indigoSaveCdx(int item, int output);
 
-CEXPORT const char* indigoCdxml(int item);
+INDIGO_EXPORT const char* indigoCdxml(int item);
 
-CEXPORT int indigoSaveCdxmlToFile(int object, const char* filename);
-CEXPORT int indigoSaveCdxToFile(int item, const char* filename);
+INDIGO_EXPORT int indigoSaveCdxmlToFile(int object, const char* filename);
+INDIGO_EXPORT int indigoSaveCdxToFile(int item, const char* filename);
 
-CEXPORT const char* indigoCdxml(int object);
+INDIGO_EXPORT const char* indigoCdxml(int object);
 
 // the output must be a file or a buffer, but not a string
 // (because MDLCT data usually contains zeroes)
-CEXPORT int indigoSaveMDLCT(int item, int output);
+INDIGO_EXPORT int indigoSaveMDLCT(int item, int output);
 
-CEXPORT const char* indigoJson(int object);
+INDIGO_EXPORT const char* indigoJson(int object);
 
 /*
 Converts a chemical name into a corresponding structure
@@ -278,7 +284,7 @@
    name - a name to parse
    params - a string containing parsing options or nullptr if no options are changed
 */
-CEXPORT int indigoNameToStructure(const char* name, const char* params);
+INDIGO_EXPORT int indigoNameToStructure(const char *name, const char *params);
 
 /* Reactions, query reactions */
 /*
@@ -293,67 +299,67 @@
     INDIGO_RC_MADE_OR_BROKEN = 4,
     INDIGO_RC_ORDER_CHANGED = 8
 };
-CEXPORT int indigoLoadReaction(int source);
-CEXPORT int indigoLoadReactionFromString(const char* string);
-CEXPORT int indigoLoadReactionFromFile(const char* filename);
-CEXPORT int indigoLoadReactionFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadReaction(int source);
+INDIGO_EXPORT int indigoLoadReactionFromString(const char* string);
+INDIGO_EXPORT int indigoLoadReactionFromFile(const char* filename);
+INDIGO_EXPORT int indigoLoadReactionFromBuffer(const char* buffer, int size);
 
-CEXPORT int indigoLoadQueryReaction(int source);
-CEXPORT int indigoLoadQueryReactionFromString(const char* string);
-CEXPORT int indigoLoadQueryReactionFromFile(const char* filename);
-CEXPORT int indigoLoadQueryReactionFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadQueryReaction(int source);
+INDIGO_EXPORT int indigoLoadQueryReactionFromString(const char* string);
+INDIGO_EXPORT int indigoLoadQueryReactionFromFile(const char* filename);
+INDIGO_EXPORT int indigoLoadQueryReactionFromBuffer(const char* buffer, int size);
 
-CEXPORT int indigoLoadReactionSmarts(int source);
-CEXPORT int indigoLoadReactionSmartsFromString(const char* string);
-CEXPORT int indigoLoadReactionSmartsFromFile(const char* filename);
-CEXPORT int indigoLoadReactionSmartsFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadReactionSmarts(int source);
+INDIGO_EXPORT int indigoLoadReactionSmartsFromString(const char* string);
+INDIGO_EXPORT int indigoLoadReactionSmartsFromFile(const char* filename);
+INDIGO_EXPORT int indigoLoadReactionSmartsFromBuffer(const char* buffer, int size);
 
-CEXPORT int indigoCreateReaction(void);
-CEXPORT int indigoCreateQueryReaction(void);
+INDIGO_EXPORT int indigoCreateReaction(void);
+INDIGO_EXPORT int indigoCreateQueryReaction(void);
 
-CEXPORT int indigoAddReactant(int reaction, int molecule);
-CEXPORT int indigoAddProduct(int reaction, int molecule);
-CEXPORT int indigoAddCatalyst(int reaction, int molecule);
+INDIGO_EXPORT int indigoAddReactant(int reaction, int molecule);
+INDIGO_EXPORT int indigoAddProduct(int reaction, int molecule);
+INDIGO_EXPORT int indigoAddCatalyst(int reaction, int molecule);
 
-CEXPORT int indigoCountReactants(int reaction);
-CEXPORT int indigoCountProducts(int reaction);
-CEXPORT int indigoCountCatalysts(int reaction);
+INDIGO_EXPORT int indigoCountReactants(int reaction);
+INDIGO_EXPORT int indigoCountProducts(int reaction);
+INDIGO_EXPORT int indigoCountCatalysts(int reaction);
 // Counts reactants, products, and catalysts.
-CEXPORT int indigoCountMolecules(int reaction);
-CEXPORT int indigoGetMolecule(int reaction, int index);
+INDIGO_EXPORT int indigoCountMolecules(int reaction);
+INDIGO_EXPORT int indigoGetMolecule(int reaction, int index);
 
-CEXPORT int indigoIterateReactants(int reaction);
-CEXPORT int indigoIterateProducts(int reaction);
-CEXPORT int indigoIterateCatalysts(int reaction);
+INDIGO_EXPORT int indigoIterateReactants(int reaction);
+INDIGO_EXPORT int indigoIterateProducts(int reaction);
+INDIGO_EXPORT int indigoIterateCatalysts(int reaction);
 // Returns an iterator for reactants, products, and catalysts.
-CEXPORT int indigoIterateMolecules(int reaction);
-CEXPORT int indigoIterateReactions(int reaction);
+INDIGO_EXPORT int indigoIterateMolecules(int reaction);
+INDIGO_EXPORT int indigoIterateReactions(int reaction);
 
-CEXPORT int indigoSaveRxnfile(int reaction, int output);
-CEXPORT int indigoSaveRxnfileToFile(int reaction, const char* filename);
-CEXPORT const char* indigoRxnfile(int reaction);
+INDIGO_EXPORT int indigoSaveRxnfile(int reaction, int output);
+INDIGO_EXPORT int indigoSaveRxnfileToFile(int reaction, const char* filename);
+INDIGO_EXPORT const char* indigoRxnfile(int reaction);
 
 // Method for query optimizations for faster substructure search
 // (works for both query molecules and query reactions)
-CEXPORT int indigoOptimize(int query, const char* options);
+INDIGO_EXPORT int indigoOptimize(int query, const char* options);
 
 // Methods for structure normalization
 // It neutrailzes charges, resolves 5-valence Nitrogen, removes hydrogens and etc.
 // Default options is empty.
-CEXPORT int indigoNormalize(int structure, const char* options);
+INDIGO_EXPORT int indigoNormalize(int structure, const char* options);
 
 // Method for molecule and query standardizing
 // It stadrdize charges, stereo and etc.
-CEXPORT int indigoStandardize(int item);
+INDIGO_EXPORT int indigoStandardize(int item);
 
 // Method for structure ionization at specified pH and pH tollerance
-CEXPORT int indigoIonize(int item, float pH, float pH_toll);
+INDIGO_EXPORT int indigoIonize(int item, float pH, float pH_toll);
 
 // Method for building PKA model
-CEXPORT int indigoBuildPkaModel(int max_level, float threshold, const char* filename);
+INDIGO_EXPORT int indigoBuildPkaModel(int max_level, float threshold, const char* filename);
 
-CEXPORT float* indigoGetAcidPkaValue(int item, int atom, int level, int min_level);
-CEXPORT float* indigoGetBasicPkaValue(int item, int atom, int level, int min_level);
+INDIGO_EXPORT float* indigoGetAcidPkaValue(int item, int atom, int level, int min_level);
+INDIGO_EXPORT float* indigoGetBasicPkaValue(int item, int atom, int level, int min_level);
 
 // Automatic reaction atom-to-atom mapping
 // mode is one of the following (separated by a space):
@@ -368,23 +374,23 @@
 //    "ignore_isotopes" : do not consider atom isotopes while searching
 //    "ignore_valence" : do not consider atom valence while searching
 //    "ignore_radicals" : do not consider atom radicals while searching
-CEXPORT int indigoAutomap(int reaction, const char* mode);
+INDIGO_EXPORT int indigoAutomap(int reaction, const char *mode);
 
 // Returns mapping number. It might appear that there is more them
 // one atom with the same number in AAM
 // Value 0 means no mapping number has been specified.
-CEXPORT int indigoGetAtomMappingNumber(int reaction, int reaction_atom);
-CEXPORT int indigoSetAtomMappingNumber(int reaction, int reaction_atom, int number);
+INDIGO_EXPORT int indigoGetAtomMappingNumber(int reaction, int reaction_atom);
+INDIGO_EXPORT int indigoSetAtomMappingNumber(int reaction, int reaction_atom, int number);
 
 // Getters and setters for reacting centers
-CEXPORT int indigoGetReactingCenter(int reaction, int reaction_bond, int* rc);
-CEXPORT int indigoSetReactingCenter(int reaction, int reaction_bond, int rc);
+INDIGO_EXPORT int indigoGetReactingCenter(int reaction, int reaction_bond, int *rc);
+INDIGO_EXPORT int indigoSetReactingCenter(int reaction, int reaction_bond, int rc);
 
 // Clears all reaction AAM information
-CEXPORT int indigoClearAAM(int reaction);
+INDIGO_EXPORT int indigoClearAAM(int reaction);
 
 // Corrects reacting centers according to AAM
-CEXPORT int indigoCorrectReactingCenters(int reaction);
+INDIGO_EXPORT int indigoCorrectReactingCenters(int reaction);
 
 /* Accessing a molecule */
 
@@ -409,61 +415,61 @@
 
 // Returns an iterator for all atoms of the given
 // molecule, including r-sites and pseudoatoms.
-CEXPORT int indigoIterateAtoms(int molecule);
-CEXPORT int indigoIteratePseudoatoms(int molecule);
-CEXPORT int indigoIterateRSites(int molecule);
-CEXPORT int indigoIterateStereocenters(int molecule);
-CEXPORT int indigoIterateAlleneCenters(int molecule);
-CEXPORT int indigoIterateRGroups(int molecule);
+INDIGO_EXPORT int indigoIterateAtoms(int molecule);
+INDIGO_EXPORT int indigoIteratePseudoatoms(int molecule);
+INDIGO_EXPORT int indigoIterateRSites(int molecule);
+INDIGO_EXPORT int indigoIterateStereocenters(int molecule);
+INDIGO_EXPORT int indigoIterateAlleneCenters(int molecule);
+INDIGO_EXPORT int indigoIterateRGroups(int molecule);
 
-CEXPORT int indigoCountRGroups(int molecule);
-CEXPORT int indigoCopyRGroups(int molecule_from, int molecule_to);
+INDIGO_EXPORT int indigoCountRGroups(int molecule);
+INDIGO_EXPORT int indigoCopyRGroups(int molecule_from, int molecule_to);
 
-CEXPORT int indigoIsPseudoatom(int atom);
-CEXPORT int indigoIsRSite(int atom);
-CEXPORT int indigoIsTemplateAtom(int atom);
+INDIGO_EXPORT int indigoIsPseudoatom(int atom);
+INDIGO_EXPORT int indigoIsRSite(int atom);
+INDIGO_EXPORT int indigoIsTemplateAtom(int atom);
 
 // returns INDIGO_{ABS,OR,AND,EITHER}
 // or zero if the atom is not a stereoatom
-CEXPORT int indigoStereocenterType(int atom);
-CEXPORT int indigoChangeStereocenterType(int atom, int type);
+INDIGO_EXPORT int indigoStereocenterType(int atom);
+INDIGO_EXPORT int indigoChangeStereocenterType(int atom, int type);
 
-CEXPORT int indigoStereocenterGroup(int atom);
-CEXPORT int indigoSetStereocenterGroup(int atom, int group);
+INDIGO_EXPORT int indigoStereocenterGroup(int atom);
+INDIGO_EXPORT int indigoSetStereocenterGroup(int atom, int group);
 
 // returns 4 integers with atom indices that defines stereocenter pyramid
-CEXPORT const int* indigoStereocenterPyramid(int atom);
+INDIGO_EXPORT const int *indigoStereocenterPyramid(int atom);
 
-CEXPORT int indigoSingleAllowedRGroup(int rsite);
+INDIGO_EXPORT int indigoSingleAllowedRGroup(int rsite);
 
-CEXPORT int indigoAddStereocenter(int atom, int type, int v1, int v2, int v3, int v4);
+INDIGO_EXPORT int indigoAddStereocenter(int atom, int type, int v1, int v2, int v3, int v4);
 
 // Applicable to an R-Group, but not to a molecule
-CEXPORT int indigoIterateRGroupFragments(int rgroup);
+INDIGO_EXPORT int indigoIterateRGroupFragments(int rgroup);
 // Applicable to an R-Group and to a molecule
 // Returns maximal order of attachment points
-CEXPORT int indigoCountAttachmentPoints(int item);
-CEXPORT int indigoIterateAttachmentPoints(int item, int order);
+INDIGO_EXPORT int indigoCountAttachmentPoints(int item);
+INDIGO_EXPORT int indigoIterateAttachmentPoints(int item, int order);
 
-CEXPORT const char* indigoSymbol(int atom);
-CEXPORT int indigoDegree(int atom);
+INDIGO_EXPORT const char *indigoSymbol(int atom);
+INDIGO_EXPORT int indigoDegree(int atom);
 
 // Returns zero if the charge is ambiguous
 // If the charge is nonambiguous, returns 1 and writes *charge
-CEXPORT int indigoGetCharge(int atom, int* charge);
+INDIGO_EXPORT int indigoGetCharge(int atom, int *charge);
 // Same as indigoGetCharge
-CEXPORT int indigoGetExplicitValence(int atom, int* valence);
+INDIGO_EXPORT int indigoGetExplicitValence(int atom, int *valence);
 
-CEXPORT int indigoSetExplicitValence(int atom, int valence);
+INDIGO_EXPORT int indigoSetExplicitValence(int atom, int valence);
 
 // Returns a number of element from the periodic table.
 // Returns zero on ambiguous atom.
 // Can not be applied to pseudo-atoms and R-sites.
-CEXPORT int indigoAtomicNumber(int atom);
+INDIGO_EXPORT int indigoAtomicNumber(int atom);
 // Returns zero on unspecified or ambiguous isotope
-CEXPORT int indigoIsotope(int atom);
+INDIGO_EXPORT int indigoIsotope(int atom);
 // Not applicable to query molecules.
-CEXPORT int indigoValence(int atom);
+INDIGO_EXPORT int indigoValence(int atom);
 // Return atom hybridization
 // S = 1,
 // SP = 2,
@@ -474,329 +480,329 @@
 // SP3D3 = 7,
 // SP3D4 = 8,
 // SP2D = 9
-CEXPORT int indigoGetHybridization(int atom);
+INDIGO_EXPORT int indigoGetHybridization(int atom);
 // Returns zero if valence of the atom is wrong
-CEXPORT int indigoCheckValence(int atom);
+INDIGO_EXPORT int indigoCheckValence(int atom);
 
 // Returns one if atom or bond belongs Query or has any query feature
-CEXPORT int indigoCheckQuery(int item);
+INDIGO_EXPORT int indigoCheckQuery(int item);
 
 // Returns one if structure contains RGroup features (RSites, RGroups or attachment points
-CEXPORT int indigoCheckRGroups(int item);
+INDIGO_EXPORT int indigoCheckRGroups(int item);
 
 // Returns check result for Indigo object as text file for requested properties as JSON
-CEXPORT const char* indigoCheck(const char* item, const char* check_flags, const char* load_params);
+INDIGO_EXPORT const char* indigoCheck(const char* item, const char* check_flags, const char* load_params);
 
 // Returns check result for Indigo object for requested properties as JSON
-CEXPORT const char* indigoCheckObj(int item, const char* check_flags);
+INDIGO_EXPORT const char* indigoCheckObj(int item, const char* check_flags);
 
 // Returns check result for structure against requested properties
-CEXPORT const char* indigoCheckStructure(const char* structure, const char* props);
+INDIGO_EXPORT const char* indigoCheckStructure(const char* structure, const char* props);
 
 // Applicable to atoms, query atoms, and molecules. Can fail
 // (return zero) on query atoms where the number of hydrogens
 // is not definitely known. Otherwise, returns one and writes *hydro.
-CEXPORT int indigoCountHydrogens(int item, int* hydro);
+INDIGO_EXPORT int indigoCountHydrogens(int item, int* hydro);
 
 // Applicable to non-query molecules and atoms.
-CEXPORT int indigoCountImplicitHydrogens(int item);
+INDIGO_EXPORT int indigoCountImplicitHydrogens(int item);
 
 // Calculate macromolecule properties. Return Json string with properties.
-CEXPORT const char* indigoMacroProperties(int object);
+INDIGO_EXPORT const char* indigoMacroProperties(int object);
 
 // On success, returns always the same pointer to a 3-element array;
 // you should not free() it, but rather memcpy() it if you want to keep it.
-CEXPORT float* indigoXYZ(int atom);
+INDIGO_EXPORT float* indigoXYZ(int atom);
 
-CEXPORT int indigoSetXYZ(int atom, float x, float y, float z);
+INDIGO_EXPORT int indigoSetXYZ(int atom, float x, float y, float z);
 
-CEXPORT int indigoClearXYZ(int molecule);
-CEXPORT int indigoCountSuperatoms(int molecule);
-CEXPORT int indigoCountDataSGroups(int molecule);
-CEXPORT int indigoCountRepeatingUnits(int molecule);
-CEXPORT int indigoCountMultipleGroups(int molecule);
-CEXPORT int indigoCountGenericSGroups(int molecule);
-CEXPORT int indigoIterateDataSGroups(int molecule);
-CEXPORT int indigoIterateSuperatoms(int molecule);
-CEXPORT int indigoIterateGenericSGroups(int molecule);
-CEXPORT int indigoIterateRepeatingUnits(int molecule);
-CEXPORT int indigoIterateMultipleGroups(int molecule);
+INDIGO_EXPORT int indigoClearXYZ(int molecule);
+INDIGO_EXPORT int indigoCountSuperatoms(int molecule);
+INDIGO_EXPORT int indigoCountDataSGroups(int molecule);
+INDIGO_EXPORT int indigoCountRepeatingUnits(int molecule);
+INDIGO_EXPORT int indigoCountMultipleGroups(int molecule);
+INDIGO_EXPORT int indigoCountGenericSGroups(int molecule);
+INDIGO_EXPORT int indigoIterateDataSGroups(int molecule);
+INDIGO_EXPORT int indigoIterateSuperatoms(int molecule);
+INDIGO_EXPORT int indigoIterateGenericSGroups(int molecule);
+INDIGO_EXPORT int indigoIterateRepeatingUnits(int molecule);
+INDIGO_EXPORT int indigoIterateMultipleGroups(int molecule);
 
-CEXPORT int indigoIterateTGroups(int molecule);
-CEXPORT int indigoIterateSGroups(int molecule);
+INDIGO_EXPORT int indigoIterateTGroups(int molecule);
+INDIGO_EXPORT int indigoIterateSGroups(int molecule);
 
-CEXPORT int indigoGetSuperatom(int molecule, int index);
-CEXPORT int indigoGetDataSGroup(int molecule, int index);
-CEXPORT int indigoGetGenericSGroup(int molecule, int index);
-CEXPORT int indigoGetMultipleGroup(int molecule, int index);
-CEXPORT int indigoGetRepeatingUnit(int molecule, int index);
+INDIGO_EXPORT int indigoGetSuperatom(int molecule, int index);
+INDIGO_EXPORT int indigoGetDataSGroup(int molecule, int index);
+INDIGO_EXPORT int indigoGetGenericSGroup(int molecule, int index);
+INDIGO_EXPORT int indigoGetMultipleGroup(int molecule, int index);
+INDIGO_EXPORT int indigoGetRepeatingUnit(int molecule, int index);
 
-CEXPORT const char* indigoDescription(int data_sgroup);
-CEXPORT const char* indigoData(int data_sgroup);
+INDIGO_EXPORT const char* indigoDescription(int data_sgroup);
+INDIGO_EXPORT const char* indigoData(int data_sgroup);
 
-CEXPORT int indigoAddDataSGroup(int molecule, int natoms, int* atoms, int nbonds, int* bonds, const char* description, const char* data);
+INDIGO_EXPORT int indigoAddDataSGroup(int molecule, int natoms, int* atoms, int nbonds, int* bonds, const char* description, const char* data);
 
-CEXPORT int indigoAddSuperatom(int molecule, int natoms, int* atoms, const char* name);
+INDIGO_EXPORT int indigoAddSuperatom(int molecule, int natoms, int* atoms, const char* name);
 
-CEXPORT int indigoSetDataSGroupXY(int sgroup, float x, float y, const char* options);
+INDIGO_EXPORT int indigoSetDataSGroupXY(int sgroup, float x, float y, const char* options);
 
-CEXPORT int indigoSetSGroupData(int sgroup, const char* data);
-CEXPORT int indigoSetSGroupCoords(int sgroup, float x, float y);
-CEXPORT int indigoSetSGroupDescription(int sgroup, const char* description);
-CEXPORT int indigoSetSGroupFieldName(int sgroup, const char* name);
-CEXPORT int indigoSetSGroupQueryCode(int sgroup, const char* querycode);
-CEXPORT int indigoSetSGroupQueryOper(int sgroup, const char* queryoper);
-CEXPORT int indigoSetSGroupDisplay(int sgroup, const char* option);
-CEXPORT int indigoSetSGroupLocation(int sgroup, const char* option);
-CEXPORT int indigoSetSGroupTag(int sgroup, const char* tag);
-CEXPORT int indigoSetSGroupTagAlign(int sgroup, int tag_align);
-CEXPORT int indigoSetSGroupDataType(int sgroup, const char* type);
-CEXPORT int indigoSetSGroupXCoord(int sgroup, float x);
-CEXPORT int indigoSetSGroupYCoord(int sgroup, float y);
+INDIGO_EXPORT int indigoSetSGroupData(int sgroup, const char* data);
+INDIGO_EXPORT int indigoSetSGroupCoords(int sgroup, float x, float y);
+INDIGO_EXPORT int indigoSetSGroupDescription(int sgroup, const char* description);
+INDIGO_EXPORT int indigoSetSGroupFieldName(int sgroup, const char* name);
+INDIGO_EXPORT int indigoSetSGroupQueryCode(int sgroup, const char* querycode);
+INDIGO_EXPORT int indigoSetSGroupQueryOper(int sgroup, const char* queryoper);
+INDIGO_EXPORT int indigoSetSGroupDisplay(int sgroup, const char* option);
+INDIGO_EXPORT int indigoSetSGroupLocation(int sgroup, const char* option);
+INDIGO_EXPORT int indigoSetSGroupTag(int sgroup, const char* tag);
+INDIGO_EXPORT int indigoSetSGroupTagAlign(int sgroup, int tag_align);
+INDIGO_EXPORT int indigoSetSGroupDataType(int sgroup, const char* type);
+INDIGO_EXPORT int indigoSetSGroupXCoord(int sgroup, float x);
+INDIGO_EXPORT int indigoSetSGroupYCoord(int sgroup, float y);
 
-CEXPORT int indigoCreateSGroup(const char* type, int mapping, const char* name);
-CEXPORT const char* indigoGetSGroupClass(int sgroup);
-CEXPORT const char* indigoGetSGroupName(int sgroup);
-CEXPORT int indigoSetSGroupClass(int sgroup, const char* sgclass);
-CEXPORT int indigoSetSGroupName(int sgroup, const char* sgname);
-CEXPORT int indigoGetSGroupNumCrossBonds(int sgroup);
+INDIGO_EXPORT int indigoCreateSGroup(const char* type, int mapping, const char* name);
+INDIGO_EXPORT const char* indigoGetSGroupClass(int sgroup);
+INDIGO_EXPORT const char* indigoGetSGroupName(int sgroup);
+INDIGO_EXPORT int indigoSetSGroupClass(int sgroup, const char* sgclass);
+INDIGO_EXPORT int indigoSetSGroupName(int sgroup, const char* sgname);
+INDIGO_EXPORT int indigoGetSGroupNumCrossBonds(int sgroup);
 
-CEXPORT int indigoAddSGroupAttachmentPoint(int sgroup, int aidx, int lvidx, const char* apid);
-CEXPORT int indigoDeleteSGroupAttachmentPoint(int sgroup, int index);
-CEXPORT int indigoGetSGroupDisplayOption(int sgroup);
-CEXPORT int indigoSetSGroupDisplayOption(int sgroup, int option);
-CEXPORT int indigoGetSGroupSeqId(int sgroup);
-CEXPORT float* indigoGetSGroupCoords(int sgroup);
+INDIGO_EXPORT int indigoAddSGroupAttachmentPoint(int sgroup, int aidx, int lvidx, const char* apid);
+INDIGO_EXPORT int indigoDeleteSGroupAttachmentPoint(int sgroup, int index);
+INDIGO_EXPORT int indigoGetSGroupDisplayOption(int sgroup);
+INDIGO_EXPORT int indigoSetSGroupDisplayOption(int sgroup, int option);
+INDIGO_EXPORT int indigoGetSGroupSeqId(int sgroup);
+INDIGO_EXPORT float* indigoGetSGroupCoords(int sgroup);
 
-CEXPORT int indigoGetSGroupMultiplier(int sgroup);
-CEXPORT int indigoSetSGroupMultiplier(int sgroup, int multiplier);
+INDIGO_EXPORT int indigoGetSGroupMultiplier(int sgroup);
+INDIGO_EXPORT int indigoSetSGroupMultiplier(int sgroup, int multiplier);
 
-CEXPORT const char* indigoGetRepeatingUnitSubscript(int sgroup);
-CEXPORT int indigoGetRepeatingUnitConnectivity(int sgroup);
+INDIGO_EXPORT const char* indigoGetRepeatingUnitSubscript(int sgroup);
+INDIGO_EXPORT int indigoGetRepeatingUnitConnectivity(int sgroup);
 
-CEXPORT int indigoSetSGroupBrackets(int sgroup, int brk_style, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);
+INDIGO_EXPORT int indigoSetSGroupBrackets(int sgroup, int brk_style, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);
 
-CEXPORT int indigoFindSGroups(int item, const char* property, const char* value);
+INDIGO_EXPORT int indigoFindSGroups(int item, const char* property, const char* value);
 
-CEXPORT int indigoGetSGroupType(int item);
-CEXPORT int indigoGetSGroupIndex(int item);
+INDIGO_EXPORT int indigoGetSGroupType(int item);
+INDIGO_EXPORT int indigoGetSGroupIndex(int item);
 
-CEXPORT int indigoGetSGroupOriginalId(int sgroup);
-CEXPORT int indigoSetSGroupOriginalId(int sgroup, int original);
-CEXPORT int indigoGetSGroupParentId(int sgroup);
-CEXPORT int indigoSetSGroupParentId(int sgroup, int parent);
+INDIGO_EXPORT int indigoGetSGroupOriginalId(int sgroup);
+INDIGO_EXPORT int indigoSetSGroupOriginalId(int sgroup, int original);
+INDIGO_EXPORT int indigoGetSGroupParentId(int sgroup);
+INDIGO_EXPORT int indigoSetSGroupParentId(int sgroup, int parent);
 
-CEXPORT int indigoAddTemplate(int molecule, int templates, const char* tname);
-CEXPORT int indigoRemoveTemplate(int molecule, const char* tname);
-CEXPORT int indigoFindTemplate(int molecule, const char* tname);
+INDIGO_EXPORT int indigoAddTemplate(int molecule, int templates, const char* tname);
+INDIGO_EXPORT int indigoRemoveTemplate(int molecule, const char* tname);
+INDIGO_EXPORT int indigoFindTemplate(int molecule, const char* tname);
 
-CEXPORT const char* indigoGetTGroupClass(int tgroup);
-CEXPORT const char* indigoGetTGroupName(int tgroup);
-CEXPORT const char* indigoGetTGroupAlias(int tgroup);
+INDIGO_EXPORT const char* indigoGetTGroupClass(int tgroup);
+INDIGO_EXPORT const char* indigoGetTGroupName(int tgroup);
+INDIGO_EXPORT const char* indigoGetTGroupAlias(int tgroup);
 
-CEXPORT int indigoTransformSCSRtoCTAB(int item);
-CEXPORT int indigoTransformCTABtoSCSR(int molecule, int templates);
+INDIGO_EXPORT int indigoTransformSCSRtoCTAB(int item);
+INDIGO_EXPORT int indigoTransformCTABtoSCSR(int molecule, int templates);
 
-CEXPORT int indigoResetCharge(int atom);
-CEXPORT int indigoResetExplicitValence(int atom);
-CEXPORT int indigoResetIsotope(int atom);
+INDIGO_EXPORT int indigoResetCharge(int atom);
+INDIGO_EXPORT int indigoResetExplicitValence(int atom);
+INDIGO_EXPORT int indigoResetIsotope(int atom);
 
-CEXPORT int indigoSetAttachmentPoint(int atom, int order);
-CEXPORT int indigoClearAttachmentPoints(int item);
+INDIGO_EXPORT int indigoSetAttachmentPoint(int atom, int order);
+INDIGO_EXPORT int indigoClearAttachmentPoints(int item);
 
-CEXPORT int indigoRemoveConstraints(int item, const char* type);
-CEXPORT int indigoAddConstraint(int item, const char* type, const char* value);
-CEXPORT int indigoAddConstraintNot(int item, const char* type, const char* value);
-CEXPORT int indigoAddConstraintOr(int atom, const char* type, const char* value);
+INDIGO_EXPORT int indigoRemoveConstraints(int item, const char* type);
+INDIGO_EXPORT int indigoAddConstraint(int item, const char* type, const char* value);
+INDIGO_EXPORT int indigoAddConstraintNot(int item, const char* type, const char* value);
+INDIGO_EXPORT int indigoAddConstraintOr(int atom, const char* type, const char* value);
 
-CEXPORT int indigoResetStereo(int item);
-CEXPORT int indigoInvertStereo(int item);
+INDIGO_EXPORT int indigoResetStereo(int item);
+INDIGO_EXPORT int indigoInvertStereo(int item);
 
-CEXPORT int indigoCountAtoms(int molecule);
-CEXPORT int indigoCountBonds(int molecule);
-CEXPORT int indigoCountPseudoatoms(int molecule);
-CEXPORT int indigoCountRSites(int molecule);
+INDIGO_EXPORT int indigoCountAtoms(int molecule);
+INDIGO_EXPORT int indigoCountBonds(int molecule);
+INDIGO_EXPORT int indigoCountPseudoatoms(int molecule);
+INDIGO_EXPORT int indigoCountRSites(int molecule);
 
-CEXPORT int indigoIterateBonds(int molecule);
+INDIGO_EXPORT int indigoIterateBonds(int molecule);
 // Returns 1/2/3 if the bond is a single/double/triple bond
 // Returns 4 if the bond is an aromatic bond
 // Returns zero if the bond is ambiguous (query bond)
-CEXPORT int indigoBondOrder(int bond);
+INDIGO_EXPORT int indigoBondOrder(int bond);
 
 // Returns INDIGO_{UP/DOWN/EITHER/CIS/TRANS},
 // or zero if the bond is not a stereobond
-CEXPORT int indigoBondStereo(int bond);
+INDIGO_EXPORT int indigoBondStereo(int bond);
 
 // Returns INDIGO_{CHAIN/RING},
-CEXPORT int indigoTopology(int bond);
+INDIGO_EXPORT int indigoTopology(int bond);
 
 // Returns an iterator whose elements can be treated as atoms.
 // At the same time, they support indigoBond() call.
-CEXPORT int indigoIterateNeighbors(int atom);
+INDIGO_EXPORT int indigoIterateNeighbors(int atom);
 
 // Applicable exclusively to the "atom neighbors iterator".
 // Returns a bond to the neighbor atom.
-CEXPORT int indigoBond(int nei);
+INDIGO_EXPORT int indigoBond(int nei);
 
 // Accessing atoms and bonds by index
-CEXPORT int indigoGetAtom(int molecule, int idx);
-CEXPORT int indigoGetBond(int molecule, int idx);
+INDIGO_EXPORT int indigoGetAtom(int molecule, int idx);
+INDIGO_EXPORT int indigoGetBond(int molecule, int idx);
 
-CEXPORT int indigoSource(int bond);
-CEXPORT int indigoDestination(int bond);
+INDIGO_EXPORT int indigoSource(int bond);
+INDIGO_EXPORT int indigoDestination(int bond);
 
-CEXPORT int indigoClearCisTrans(int handle);
-CEXPORT int indigoClearStereocenters(int handle);
-CEXPORT int indigoCountStereocenters(int molecule);
-CEXPORT int indigoClearAlleneCenters(int molecule);
-CEXPORT int indigoCountAlleneCenters(int molecule);
+INDIGO_EXPORT int indigoClearCisTrans(int handle);
+INDIGO_EXPORT int indigoClearStereocenters(int handle);
+INDIGO_EXPORT int indigoCountStereocenters(int molecule);
+INDIGO_EXPORT int indigoClearAlleneCenters(int molecule);
+INDIGO_EXPORT int indigoCountAlleneCenters(int molecule);
 
-CEXPORT int indigoResetSymmetricCisTrans(int handle);
-CEXPORT int indigoResetSymmetricStereocenters(int handle);
-CEXPORT int indigoMarkEitherCisTrans(int handle);
-CEXPORT int indigoMarkStereobonds(int handle);
+INDIGO_EXPORT int indigoResetSymmetricCisTrans(int handle);
+INDIGO_EXPORT int indigoResetSymmetricStereocenters(int handle);
+INDIGO_EXPORT int indigoMarkEitherCisTrans(int handle);
+INDIGO_EXPORT int indigoMarkStereobonds(int handle);
 
-CEXPORT int indigoValidateChirality(int handle);
+INDIGO_EXPORT int indigoValidateChirality(int handle);
 
 // Accepts a symbol from the periodic table (like "C" or "Br"),
 // or a pseudoatom symbol, like "Pol". Returns the added atom.
-CEXPORT int indigoAddAtom(int molecule, const char* symbol);
+INDIGO_EXPORT int indigoAddAtom(int molecule, const char* symbol);
 // Set a new atom instead of specified
-CEXPORT int indigoResetAtom(int atom, const char* symbol);
+INDIGO_EXPORT int indigoResetAtom(int atom, const char* symbol);
 
-CEXPORT const char* indigoGetTemplateAtomClass(int atom);
-CEXPORT int indigoSetTemplateAtomClass(int atom, const char* name);
+INDIGO_EXPORT const char* indigoGetTemplateAtomClass(int atom);
+INDIGO_EXPORT int indigoSetTemplateAtomClass(int atom, const char* name);
 
 // Accepts Rsite name "R" (or just ""), "R1", "R2" or list with names "R1 R3"
-CEXPORT int indigoAddRSite(int molecule, const char* name);
-CEXPORT int indigoSetRSite(int atom, const char* name);
+INDIGO_EXPORT int indigoAddRSite(int molecule, const char* name);
+INDIGO_EXPORT int indigoSetRSite(int atom, const char* name);
 
-CEXPORT int indigoSetCharge(int atom, int charge);
-CEXPORT int indigoSetIsotope(int atom, int isotope);
+INDIGO_EXPORT int indigoSetCharge(int atom, int charge);
+INDIGO_EXPORT int indigoSetIsotope(int atom, int isotope);
 
 // If the radical is nonambiguous, returns 1 and writes *electrons
-CEXPORT int indigoGetRadicalElectrons(int atom, int* electrons);
+INDIGO_EXPORT int indigoGetRadicalElectrons(int atom, int* electrons);
 // If the radical is nonambiguous, returns 1 and writes *radical
-CEXPORT int indigoGetRadical(int atom, int* radical);
-CEXPORT int indigoSetRadical(int atom, int radical);
-CEXPORT int indigoResetRadical(int atom);
+INDIGO_EXPORT int indigoGetRadical(int atom, int* radical);
+INDIGO_EXPORT int indigoSetRadical(int atom, int radical);
+INDIGO_EXPORT int indigoResetRadical(int atom);
 
 // Used for hacks with aromatic molecules; not recommended to use
 // in other situations
-CEXPORT int indigoSetImplicitHCount(int atom, int impl_h);
+INDIGO_EXPORT int indigoSetImplicitHCount(int atom, int impl_h);
 
 // Accepts two atoms (source and destination) and the order of the new bond
 // (1/2/3/4 = single/double/triple/aromatic). Returns the added bond.
-CEXPORT int indigoAddBond(int source, int destination, int order);
+INDIGO_EXPORT int indigoAddBond(int source, int destination, int order);
 
-CEXPORT int indigoSetBondOrder(int bond, int order);
+INDIGO_EXPORT int indigoSetBondOrder(int bond, int order);
 
-CEXPORT int indigoMerge(int where_to, int what);
+INDIGO_EXPORT int indigoMerge(int where_to, int what);
 
 /* Highlighting */
 
 // Access atoms and bonds
-CEXPORT int indigoHighlight(int item);
+INDIGO_EXPORT int indigoHighlight(int item);
 
 // Access atoms, bonds, molecules, and reactions
-CEXPORT int indigoUnhighlight(int item);
+INDIGO_EXPORT int indigoUnhighlight(int item);
 
 // Access atoms and bonds
-CEXPORT int indigoIsHighlighted(int item);
+INDIGO_EXPORT int indigoIsHighlighted(int item);
 
 /* Selection */
 
 // Access atoms and bonds
-CEXPORT int indigoSelect(int item);
+INDIGO_EXPORT int indigoSelect(int item);
 
 // Access atoms, bonds, molecules, and reactions
-CEXPORT int indigoUnselect(int item);
+INDIGO_EXPORT int indigoUnselect(int item);
 
 // Access atoms and bonds
-CEXPORT int indigoIsSelected(int item);
+INDIGO_EXPORT int indigoIsSelected(int item);
 
 /* Connected components of molecules */
 
-CEXPORT int indigoCountComponents(int molecule);
-CEXPORT int indigoComponentIndex(int atom);
-CEXPORT int indigoIterateComponents(int molecule);
+INDIGO_EXPORT int indigoCountComponents(int molecule);
+INDIGO_EXPORT int indigoComponentIndex(int atom);
+INDIGO_EXPORT int indigoIterateComponents(int molecule);
 
 // Returns a 'molecule component' object, which can not be used as a
 // [query] molecule, but supports the indigo{Count,Iterate}{Atoms,Bonds} calls,
 // and also the indigoClone() call, which returns a [query] molecule.
-CEXPORT int indigoComponent(int molecule, int index);
+INDIGO_EXPORT int indigoComponent(int molecule, int index);
 
 /* Smallest Set of Smallest Rings */
 
-CEXPORT int indigoCountSSSR(int molecule);
-CEXPORT int indigoIterateSSSR(int molecule);
+INDIGO_EXPORT int indigoCountSSSR(int molecule);
+INDIGO_EXPORT int indigoIterateSSSR(int molecule);
 
-CEXPORT int indigoIterateSubtrees(int molecule, int min_atoms, int max_atoms);
-CEXPORT int indigoIterateRings(int molecule, int min_atoms, int max_atoms);
-CEXPORT int indigoIterateEdgeSubmolecules(int molecule, int min_bonds, int max_bonds);
+INDIGO_EXPORT int indigoIterateSubtrees(int molecule, int min_atoms, int max_atoms);
+INDIGO_EXPORT int indigoIterateRings(int molecule, int min_atoms, int max_atoms);
+INDIGO_EXPORT int indigoIterateEdgeSubmolecules(int molecule, int min_bonds, int max_bonds);
 
 /* Calculation on molecules */
 
-CEXPORT int indigoCountHeavyAtoms(int molecule);
-CEXPORT int indigoGrossFormula(int molecule);
-CEXPORT double indigoMolecularWeight(int molecule);
-CEXPORT double indigoMostAbundantMass(int molecule);
-CEXPORT double indigoMonoisotopicMass(int molecule);
-CEXPORT const char* indigoMassComposition(int molecule);
-CEXPORT double indigoTPSA(int molecule, int includeSP);
-CEXPORT int indigoNumRotatableBonds(int molecule);
-CEXPORT int indigoNumHydrogenBondAcceptors(int molecule);
-CEXPORT int indigoNumHydrogenBondDonors(int molecule);
-CEXPORT double indigoLogP(int molecule);
-CEXPORT double indigoMolarRefractivity(int molecule);
-CEXPORT double indigoPka(int molecule);
+INDIGO_EXPORT int indigoCountHeavyAtoms(int molecule);
+INDIGO_EXPORT int indigoGrossFormula(int molecule);
+INDIGO_EXPORT double indigoMolecularWeight(int molecule);
+INDIGO_EXPORT double indigoMostAbundantMass(int molecule);
+INDIGO_EXPORT double indigoMonoisotopicMass(int molecule);
+INDIGO_EXPORT const char* indigoMassComposition(int molecule);
+INDIGO_EXPORT double indigoTPSA(int molecule, int includeSP);
+INDIGO_EXPORT int indigoNumRotatableBonds(int molecule);
+INDIGO_EXPORT int indigoNumHydrogenBondAcceptors(int molecule);
+INDIGO_EXPORT int indigoNumHydrogenBondDonors(int molecule);
+INDIGO_EXPORT double indigoLogP(int molecule);
+INDIGO_EXPORT double indigoMolarRefractivity(int molecule);
+INDIGO_EXPORT double indigoPka(int molecule);
 
-CEXPORT const char* indigoCanonicalSmiles(int molecule);
-CEXPORT const char* indigoLayeredCode(int molecule);
+INDIGO_EXPORT const char* indigoCanonicalSmiles(int molecule);
+INDIGO_EXPORT const char* indigoLayeredCode(int molecule);
 
-CEXPORT int64_t indigoHash(int chemicalObject);
+INDIGO_EXPORT int64_t indigoHash(int chemicalObject);
 
-CEXPORT const int* indigoSymmetryClasses(int molecule, int* count_out);
+INDIGO_EXPORT const int* indigoSymmetryClasses(int molecule, int* count_out);
 
-CEXPORT int indigoHasCoord(int molecule);
-CEXPORT int indigoHasZCoord(int molecule);
-CEXPORT int indigoIsChiral(int molecule);
-CEXPORT int indigoCheckChirality(int molecule);
-CEXPORT int indigoCheck3DStereo(int molecule);
-CEXPORT int indigoCheckStereo(int molecule);
+INDIGO_EXPORT int indigoHasCoord(int molecule);
+INDIGO_EXPORT int indigoHasZCoord(int molecule);
+INDIGO_EXPORT int indigoIsChiral(int molecule);
+INDIGO_EXPORT int indigoCheckChirality(int molecule);
+INDIGO_EXPORT int indigoCheck3DStereo(int molecule);
+INDIGO_EXPORT int indigoCheckStereo(int molecule);
 
-CEXPORT int indigoIsPossibleFischerProjection(int molecule, const char* options);
+INDIGO_EXPORT int indigoIsPossibleFischerProjection(int molecule, const char* options);
 
-CEXPORT int indigoCreateSubmolecule(int molecule, int nvertices, int* vertices);
-CEXPORT int indigoCreateEdgeSubmolecule(int molecule, int nvertices, int* vertices, int nedges, int* edges);
+INDIGO_EXPORT int indigoCreateSubmolecule(int molecule, int nvertices, int* vertices);
+INDIGO_EXPORT int indigoCreateEdgeSubmolecule(int molecule, int nvertices, int* vertices, int nedges, int* edges);
 
-CEXPORT int indigoGetSubmolecule(int molecule, int nvertices, int* vertices);
+INDIGO_EXPORT int indigoGetSubmolecule(int molecule, int nvertices, int* vertices);
 
-CEXPORT int indigoRemoveAtoms(int molecule, int nvertices, int* vertices);
-CEXPORT int indigoRemoveBonds(int molecule, int nbonds, int* bonds);
+INDIGO_EXPORT int indigoRemoveAtoms(int molecule, int nvertices, int* vertices);
+INDIGO_EXPORT int indigoRemoveBonds(int molecule, int nbonds, int* bonds);
 
 // Determines and applies the best transformation to the given molecule
 // so that the specified atoms move as close as possible to the desired
 // positions. The size of desired_xyz is equal to 3 * natoms.
 // The return value is the root-mean-square measure of the difference
 // between the desired and obtained positions.
-CEXPORT float indigoAlignAtoms(int molecule, int natoms, int* atom_ids, float* desired_xyz);
+INDIGO_EXPORT float indigoAlignAtoms(int molecule, int natoms, int* atom_ids, float* desired_xyz);
 
 /* Things that work for both molecules and reactions */
 
-CEXPORT int indigoAromatize(int item);
-CEXPORT int indigoDearomatize(int item);
+INDIGO_EXPORT int indigoAromatize(int item);
+INDIGO_EXPORT int indigoDearomatize(int item);
 
-CEXPORT int indigoFoldHydrogens(int item);
-CEXPORT int indigoUnfoldHydrogens(int item);
-CEXPORT int indigoFoldUnfoldHydrogens(int item);
+INDIGO_EXPORT int indigoFoldHydrogens(int item);
+INDIGO_EXPORT int indigoUnfoldHydrogens(int item);
+INDIGO_EXPORT int indigoFoldUnfoldHydrogens(int item);
 
-CEXPORT int indigoLayout(int object);
-CEXPORT int indigoClean2d(int object);
+INDIGO_EXPORT int indigoLayout(int object);
+INDIGO_EXPORT int indigoClean2d(int object);
 
-CEXPORT const char* indigoSmiles(int item);
-CEXPORT const char* indigoSmarts(int item);
-CEXPORT const char* indigoCanonicalSmarts(int item);
+INDIGO_EXPORT const char* indigoSmiles(int item);
+INDIGO_EXPORT const char* indigoSmarts(int item);
+INDIGO_EXPORT const char* indigoCanonicalSmarts(int item);
 
 // Returns a "mapping" if there is an exact match, zero otherwise
 // The flags string consists of space-separated flags.
@@ -807,55 +813,55 @@
 // "FRA": Connected fragments: disallows match of separate ions in salts
 // "ALL": All of the above
 // By default (with null or empty flags string) all flags are on.
-CEXPORT int indigoExactMatch(int item1, int item2, const char* flags);
+INDIGO_EXPORT int indigoExactMatch(int item1, int item2, const char *flags);
 
 // "beg" and "end" refer to the two ends of the tautomeric chain. Allowed
 // elements are separated by commas. '1' at the beginning means an aromatic
 // atom, while '0' means an aliphatic atom.
-CEXPORT int indigoSetTautomerRule(int id, const char* beg, const char* end);
+INDIGO_EXPORT int indigoSetTautomerRule(int id, const char *beg, const char *end);
 
-CEXPORT int indigoRemoveTautomerRule(int id);
+INDIGO_EXPORT int indigoRemoveTautomerRule(int id);
 
-CEXPORT int indigoClearTautomerRules();
+INDIGO_EXPORT int indigoClearTautomerRules();
 
-CEXPORT const char* indigoName(int handle);
-CEXPORT int indigoSetName(int handle, const char* name);
+INDIGO_EXPORT const char *indigoName(int handle);
+INDIGO_EXPORT int indigoSetName(int handle, const char *name);
 
 // You should not free() the obtained buffer, but rather memcpy() it if you want to keep it
-CEXPORT int indigoSerialize(int handle, byte** buf, int* size);
+INDIGO_EXPORT int indigoSerialize(int handle, byte **buf, int *size);
 
-CEXPORT int indigoUnserialize(const byte* buf, int size);
+INDIGO_EXPORT int indigoUnserialize(const byte *buf, int size);
 
 // Applicable to molecules/reactions obtained from SDF or RDF files,
 // and to their clones, and to their R-Group deconvolutions.
-CEXPORT int indigoHasProperty(int handle, const char* prop);
-CEXPORT const char* indigoGetProperty(int handle, const char* prop);
+INDIGO_EXPORT int indigoHasProperty(int handle, const char *prop);
+INDIGO_EXPORT const char *indigoGetProperty(int handle, const char *prop);
 
 // Applicable to newly created or cloned molecules/reactions,
 // and also to molecules/reactions obtained from SDF or RDF files.
 // If the property with the given name does not exist, it is created automatically.
-CEXPORT int indigoSetProperty(int item, const char* prop, const char* value);
+INDIGO_EXPORT int indigoSetProperty(int item, const char *prop, const char *value);
 
 // Does not raise an error if the given property does not exist
-CEXPORT int indigoRemoveProperty(int item, const char* prop);
+INDIGO_EXPORT int indigoRemoveProperty(int item, const char *prop);
 
 // Returns an iterator that one can pass to indigoName() to
 // know the name of the property. The value of the property can be
 // obtained via indigoGetProperty() call to the object
-CEXPORT int indigoIterateProperties(int handle);
+INDIGO_EXPORT int indigoIterateProperties(int handle);
 
 // Clears all properties of the molecule
-CEXPORT int indigoClearProperties(int handle);
+INDIGO_EXPORT int indigoClearProperties(int handle);
 
 // Accepts a molecule or reaction (but not query molecule or query reaction).
 // Returns a string describing the first encountered mistake with valence.
 // Returns an empty string if the input molecule/reaction is fine.
-CEXPORT const char* indigoCheckBadValence(int handle);
+INDIGO_EXPORT const char *indigoCheckBadValence(int handle);
 
 // Accepts a molecule or reaction (but not query molecule or query reaction).
 // Returns a string describing the first encountered mistake with ambiguous H counter.
 // Returns an empty string if the input molecule/reaction is fine.
-CEXPORT const char* indigoCheckAmbiguousH(int handle);
+INDIGO_EXPORT const char *indigoCheckAmbiguousH(int handle);
 
 /* Fingerprints */
 
@@ -873,119 +879,119 @@
 //                 substructure screening
 //   "full"    -- "Full fingerprint", which has all the mentioned
 //                 fingerprint types included
-CEXPORT int indigoFingerprint(int item, const char* type);
+INDIGO_EXPORT int indigoFingerprint(int item, const char *type);
 
 // Counts the nonzero (i.e. one) bits in a fingerprint
-CEXPORT int indigoCountBits(int fingerprint);
+INDIGO_EXPORT int indigoCountBits(int fingerprint);
 
 // Counts the number of the coinincident in two fingerprints
-CEXPORT int indigoCommonBits(int fingerprint1, int fingerprint2);
+INDIGO_EXPORT int indigoCommonBits(int fingerprint1, int fingerprint2);
 
 // Return one bits string for the fingerprint object
-CEXPORT const char* indigoOneBitsList(int fingerprint);
+INDIGO_EXPORT const char *indigoOneBitsList(int fingerprint);
 
 // Returns a 'fingerprint' object with data from 'buffer'
-CEXPORT int indigoLoadFingerprintFromBuffer(const byte* buffer, int size);
+INDIGO_EXPORT int indigoLoadFingerprintFromBuffer(const byte *buffer, int size);
 
 // Constructs a 'fingerprint' object from a normalized array of double descriptors
-CEXPORT int indigoLoadFingerprintFromDescriptors(const double* arr, int arr_len, int size, double density);
+INDIGO_EXPORT int indigoLoadFingerprintFromDescriptors(const double *arr, int arr_len, int size, double density);
 
 // Accepts two molecules, two reactions, or two fingerprints.
 // Returns the similarity measure between them.
 // Metrics: "tanimoto", "tversky", "tversky <alpha> <beta>", "euclid-sub" or "normalized-edit"
 // Zero pointer or empty string defaults to "tanimoto".
 // "tversky" without numbers defaults to alpha = beta = 0.5
-CEXPORT float indigoSimilarity(int item1, int item2, const char* metrics);
+INDIGO_EXPORT float indigoSimilarity(int item1, int item2, const char *metrics);
 
 /* Working with SDF/RDF/SMILES/CML/CDX files  */
 
-CEXPORT int indigoIterateSDF(int reader);
-CEXPORT int indigoIterateRDF(int reader);
-CEXPORT int indigoIterateSmiles(int reader);
-CEXPORT int indigoIterateCML(int reader);
-CEXPORT int indigoIterateCDX(int reader);
+INDIGO_EXPORT int indigoIterateSDF(int reader);
+INDIGO_EXPORT int indigoIterateRDF(int reader);
+INDIGO_EXPORT int indigoIterateSmiles(int reader);
+INDIGO_EXPORT int indigoIterateCML(int reader);
+INDIGO_EXPORT int indigoIterateCDX(int reader);
 
-CEXPORT int indigoIterateSDFile(const char* filename);
-CEXPORT int indigoIterateRDFile(const char* filename);
-CEXPORT int indigoIterateSmilesFile(const char* filename);
-CEXPORT int indigoIterateCMLFile(const char* filename);
-CEXPORT int indigoIterateCDXFile(const char* filename);
+INDIGO_EXPORT int indigoIterateSDFile(const char *filename);
+INDIGO_EXPORT int indigoIterateRDFile(const char *filename);
+INDIGO_EXPORT int indigoIterateSmilesFile(const char *filename);
+INDIGO_EXPORT int indigoIterateCMLFile(const char *filename);
+INDIGO_EXPORT int indigoIterateCDXFile(const char *filename);
 
 // Applicable to items returned by SDF/RDF iterators.
 // Returns the content of SDF/RDF item.
-CEXPORT const char* indigoRawData(int item);
+INDIGO_EXPORT const char *indigoRawData(int item);
 
 // Applicable to items returned by SDF/RDF iterators.
 // Returns the offset in the SDF/RDF file.
-CEXPORT int indigoTell(int handle);
-CEXPORT long long indigoTell64(int handle);
+INDIGO_EXPORT int indigoTell(int handle);
+INDIGO_EXPORT long long indigoTell64(int handle);
 
 // Saves the molecule to an SDF output stream
-CEXPORT int indigoSdfAppend(int output, int item);
+INDIGO_EXPORT int indigoSdfAppend(int output, int item);
 // Saves the molecule to a multiline SMILES output stream
-CEXPORT int indigoSmilesAppend(int output, int item);
+INDIGO_EXPORT int indigoSmilesAppend(int output, int item);
 
 // Similarly for RDF files, except that the header should be written first
-CEXPORT int indigoRdfHeader(int output);
-CEXPORT int indigoRdfAppend(int output, int item);
+INDIGO_EXPORT int indigoRdfHeader(int output);
+INDIGO_EXPORT int indigoRdfAppend(int output, int item);
 
 // Similarly for CML files, except that they have both header and footer
-CEXPORT int indigoCmlHeader(int output);
-CEXPORT int indigoCmlAppend(int output, int item);
-CEXPORT int indigoCmlFooter(int output);
+INDIGO_EXPORT int indigoCmlHeader(int output);
+INDIGO_EXPORT int indigoCmlAppend(int output, int item);
+INDIGO_EXPORT int indigoCmlFooter(int output);
 
 // Create saver objects that can be used to save molecules or reactions
 // Supported formats: 'sdf', 'smi' or 'smiles', 'cml', 'rdf'
 // Format argument is case-insensitive
 // Saver should be closed with indigoClose function
-CEXPORT int indigoCreateSaver(int output, const char* format);
-CEXPORT int indigoCreateFileSaver(const char* filename, const char* format);
+INDIGO_EXPORT int indigoCreateSaver(int output, const char *format);
+INDIGO_EXPORT int indigoCreateFileSaver(const char *filename, const char *format);
 
 // Append object to a specified saver stream
-CEXPORT int indigoAppend(int saver, int object);
+INDIGO_EXPORT int indigoAppend(int saver, int object);
 
 /* Arrays */
 
-CEXPORT int indigoCreateArray();
+INDIGO_EXPORT int indigoCreateArray();
 // Note: a clone of the object is added, not the object itself
-CEXPORT int indigoArrayAdd(int arr, int object);
-CEXPORT int indigoAt(int item, int index);
-CEXPORT int indigoCount(int item);
-CEXPORT int indigoClear(int arr);
-CEXPORT int indigoIterateArray(int arr);
+INDIGO_EXPORT int indigoArrayAdd(int arr, int object);
+INDIGO_EXPORT int indigoAt(int item, int index);
+INDIGO_EXPORT int indigoCount(int item);
+INDIGO_EXPORT int indigoClear(int arr);
+INDIGO_EXPORT int indigoIterateArray(int arr);
 
 /* Substructure matching */
 
 // Returns a new 'matcher' object
 // 'mode' is reserved for future use; currently its value is ignored
-CEXPORT int indigoSubstructureMatcher(int target, const char* mode);
+INDIGO_EXPORT int indigoSubstructureMatcher(int target, const char *mode);
 
 // Ignore target atom in the substructure matcher
-CEXPORT int indigoIgnoreAtom(int matcher, int atom_object);
+INDIGO_EXPORT int indigoIgnoreAtom(int matcher, int atom_object);
 
 // Ignore target atom in the substructure matcher
-CEXPORT int indigoUnignoreAtom(int matcher, int atom_object);
+INDIGO_EXPORT int indigoUnignoreAtom(int matcher, int atom_object);
 
 // Clear list of ignored target atoms in the substructure matcher
-CEXPORT int indigoUnignoreAllAtoms(int matcher);
+INDIGO_EXPORT int indigoUnignoreAllAtoms(int matcher);
 
 // Returns a new 'match' object on success, zero on fail
 //    matcher is an matcher object returned by indigoSubstructureMatcher
-CEXPORT int indigoMatch(int matcher, int query);
+INDIGO_EXPORT int indigoMatch(int matcher, int query);
 
 // Counts the number of embeddings of the query structure into the target
-CEXPORT int indigoCountMatches(int matcher, int query);
+INDIGO_EXPORT int indigoCountMatches(int matcher, int query);
 
 // Counts the number of embeddings of the query structure into the target
 // If number of embeddings is more then limit then limit is returned
-CEXPORT int indigoCountMatchesWithLimit(int matcher, int query, int embeddings_limit);
+INDIGO_EXPORT int indigoCountMatchesWithLimit(int matcher, int query, int embeddings_limit);
 
 // Returns substructure matches iterator
-CEXPORT int indigoIterateMatches(int matcher, int query);
+INDIGO_EXPORT int indigoIterateMatches(int matcher, int query);
 
 // Accepts a 'match' object obtained from indigoMatchSubstructure.
 // Returns a new molecule which has the query highlighted.
-CEXPORT int indigoHighlightedTarget(int match);
+INDIGO_EXPORT int indigoHighlightedTarget(int match);
 
 // Accepts an atom from the query, not an atom index.
 //   You can use indigoGetAtom() to obtain the atom by its index.
@@ -993,7 +999,7 @@
 // atom doesn't match particular atom in the target (R-group or explicit
 // hydrogen) then return value is zero.
 //   You can use indigoIndex() to obtain the index of the returned atom.
-CEXPORT int indigoMapAtom(int handle, int atom);
+INDIGO_EXPORT int indigoMapAtom(int handle, int atom);
 
 // Accepts a bond from the query, not a bond index.
 //   You can use indigoGetBond() to obtain the bond by its index.
@@ -1001,7 +1007,7 @@
 // bond doesn't match particular bond in the target (R-group or explicit
 // hydrogen) then return value is zero.
 //   You can use indigoIndex() to obtain the index of the returned bond.
-CEXPORT int indigoMapBond(int handle, int bond);
+INDIGO_EXPORT int indigoMapBond(int handle, int bond);
 
 // Accepts a molecule from the query reaction, not a molecule index.
 //   You can use indigoGetMolecule() to obtain the bond by its index.
@@ -1009,11 +1015,11 @@
 // molecule doesn't match particular molecule in the target then return
 // value is zero.
 //   You can use indigoIndex() to obtain the index of the returned molecule.
-CEXPORT int indigoMapMolecule(int handle, int molecule);
+INDIGO_EXPORT int indigoMapMolecule(int handle, int molecule);
 
 // Accepts a molecule and options for tautomer enumeration algorithms
 // Returns an iterator object over the molecules that are tautomers of this molecule.
-CEXPORT int indigoIterateTautomers(int molecule, const char* options);
+INDIGO_EXPORT int indigoIterateTautomers(int molecule, const char *options);
 
 /* Scaffold detection */
 
@@ -1022,91 +1028,93 @@
 //   (i) treated as a structure: the maximum (by the number of rings) common
 //       substructure of the given structures.
 //  (ii) passed to indigoAllScaffolds()
-CEXPORT int indigoExtractCommonScaffold(int structures, const char* options);
+INDIGO_EXPORT int indigoExtractCommonScaffold(int structures, const char *options);
 
 // Returns an array of all possible scaffolds.
 // The input parameter is the value returned by indigoExtractCommonScaffold().
-CEXPORT int indigoAllScaffolds(int extracted);
+INDIGO_EXPORT int indigoAllScaffolds(int extracted);
 
 /* R-Group deconvolution */
 
 // Returns a ``decomposition'' object that can be passed to
 // indigoDecomposedMoleculeScaffold() and
 // indigoIterateDecomposedMolecules()
-CEXPORT int indigoDecomposeMolecules(int scaffold, int structures);
+INDIGO_EXPORT int indigoDecomposeMolecules(int scaffold, int structures);
 
 // Returns a scaffold molecule with r-sites marking the place
 // for substituents to add to form the structures given above.
-CEXPORT int indigoDecomposedMoleculeScaffold(int decomp);
+INDIGO_EXPORT int indigoDecomposedMoleculeScaffold(int decomp);
 
 // Returns an iterator which corresponds to the given collection of structures.
 // indigoDecomposedMoleculeHighlighted() and
 // indigoDecomposedMoleculeWithRGroups() are applicable to the
 // values returned by the iterator.
-CEXPORT int indigoIterateDecomposedMolecules(int decomp);
+INDIGO_EXPORT int indigoIterateDecomposedMolecules(int decomp);
 
 // Returns a molecule with highlighted scaffold
-CEXPORT int indigoDecomposedMoleculeHighlighted(int decomp);
+INDIGO_EXPORT int indigoDecomposedMoleculeHighlighted(int decomp);
 
 // Returns a query molecule with r-sites and "R1=...", "R2=..."
 // substituents defined. The 'scaffold' part of the molecule
 // is identical to the indigoDecomposedMoleculeScaffold()
-CEXPORT int indigoDecomposedMoleculeWithRGroups(int decomp);
+INDIGO_EXPORT int indigoDecomposedMoleculeWithRGroups(int decomp);
 
 /*
  * Decomposition Iteration API
  */
 // Returns a 'decomposition' object
-CEXPORT int indigoCreateDecomposer(int scaffold);
+INDIGO_EXPORT int indigoCreateDecomposer(int scaffold);
 // Returns a 'decomposition' item
-CEXPORT int indigoDecomposeMolecule(int decomp, int mol);
+INDIGO_EXPORT int indigoDecomposeMolecule(int decomp, int mol);
 // Returns decomposition iterator
-CEXPORT int indigoIterateDecompositions(int deco_item);
+INDIGO_EXPORT int indigoIterateDecompositions(int deco_item);
 // Adds the input decomposition to a full scaffold
-CEXPORT int indigoAddDecomposition(int decomp, int q_match);
+INDIGO_EXPORT int indigoAddDecomposition(int decomp, int q_match);
 
 /* R-Group convolution */
 
-CEXPORT int indigoGetFragmentedMolecule(int elem, const char* options);
-CEXPORT int indigoRGroupComposition(int molecule, const char* options);
+INDIGO_EXPORT int indigoGetFragmentedMolecule(int elem, const char *options);
+INDIGO_EXPORT int indigoRGroupComposition(int molecule, const char *options);
 
 /*
  * Abbreviations
  */
-CEXPORT int indigoExpandAbbreviations(int molecule);
+INDIGO_EXPORT int indigoExpandAbbreviations(int molecule);
 
 /* Other */
 
-CEXPORT const char* indigoToString(int handle);
-CEXPORT const char* indigoToBase64String(int handle);
-CEXPORT int indigoToBuffer(int handle, char** buf, int* size);
+INDIGO_EXPORT const char *indigoToString(int handle);
+INDIGO_EXPORT const char *indigoToBase64String(int handle);
+INDIGO_EXPORT int indigoToBuffer(int handle, char **buf, int *size);
 
 /* Reaction products enumeration */
 
 // Accepts a query reaction with markd R-sites, and array of arrays
 // of substituents corresponding to the R-Sites. Returns an array of
 // reactions with R-Sites replaced by the actual substituents.
-CEXPORT int indigoReactionProductEnumerate(int reaction, int monomers);
+INDIGO_EXPORT int indigoReactionProductEnumerate(int reaction, int monomers);
 
-CEXPORT int indigoTransform(int reaction, int monomers);
+INDIGO_EXPORT int indigoTransform(int reaction, int monomers);
 
-CEXPORT int indigoTransformHELMtoSCSR(int monomer);
+INDIGO_EXPORT int indigoTransformHELMtoSCSR(int monomer);
 
 /* Debug functionality */
 
 // Returns internal type of an object
-CEXPORT const char* indigoDbgInternalType(int object);
+INDIGO_EXPORT const char *indigoDbgInternalType(int object);
 
 // Internal breakpoint
-CEXPORT void indigoDbgBreakpoint(void);
+INDIGO_EXPORT void indigoDbgBreakpoint(void);
 
 // Methods that returns profiling infromation in a human readable format
-CEXPORT const char* indigoDbgProfiling(int /*bool*/ whole_session);
+INDIGO_EXPORT const char *indigoDbgProfiling(int /*bool*/ whole_session);
 
 // Reset profiling counters either for the current state or for the whole session
-CEXPORT int indigoDbgResetProfiling(int /*bool*/ whole_session);
+INDIGO_EXPORT int indigoDbgResetProfiling(int /*bool*/ whole_session);
 
 // Methods that returns profiling counter value for a particular counter
-CEXPORT qword indigoDbgProfilingGetCounter(const char* name, int /*bool*/ whole_session);
-
+INDIGO_EXPORT qword indigoDbgProfilingGetCounter(const char *name, int /*bool*/ whole_session);
+#ifdef __cplusplus
+}
+#endif
 #endif
Index: indigo-src/indigo/api/c/indigo/src/indigo_match.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_match.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_match.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_match.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_match.cpp	(date 1745583015945)
@@ -72,7 +72,7 @@
     label_list.push(Element::fromString(buf.ptr()));
 }
 
-CEXPORT int indigoSetTautomerRule(int n, const char* beg, const char* end)
+int indigoSetTautomerRule(int n, const char* beg, const char* end)
 {
     INDIGO_BEGIN
     {
@@ -91,7 +91,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearTautomerRules()
+int indigoClearTautomerRules()
 {
     INDIGO_BEGIN
     {
@@ -101,7 +101,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRemoveTautomerRule(int n)
+int indigoRemoveTautomerRule(int n)
 {
     INDIGO_BEGIN
     {
@@ -111,7 +111,7 @@
     INDIGO_END(-1);
 }
 
-DLLEXPORT bool _indigoParseTautomerFlags(const char* flags, IndigoTautomerParams& params)
+bool _indigoParseTautomerFlags(const char* flags, IndigoTautomerParams& params)
 {
     if (flags == 0)
         return false;
@@ -135,7 +135,7 @@
     return true;
 }
 
-DLLEXPORT int _indigoParseExactFlags(const char* flags, bool reaction, float* rms_threshold)
+int _indigoParseExactFlags(const char* flags, bool reaction, float* rms_threshold)
 {
     if (flags == 0)
         throw IndigoError("_indigoParseExactFlags(): zero string pointer");
@@ -243,7 +243,7 @@
     return res;
 }
 
-CEXPORT int indigoExactMatch(int handler1, int handler2, const char* flags)
+int indigoExactMatch(int handler1, int handler2, const char* flags)
 {
     INDIGO_BEGIN
     {
@@ -727,7 +727,7 @@
     return true;
 }
 
-CEXPORT int indigoSubstructureMatcher(int target, const char* mode_str)
+int indigoSubstructureMatcher(int target, const char* mode_str)
 {
     INDIGO_BEGIN
     {
@@ -797,7 +797,7 @@
                                        method);
 }
 
-CEXPORT int indigoIgnoreAtom(int target_matcher, int atom_object)
+int indigoIgnoreAtom(int target_matcher, int atom_object)
 {
     INDIGO_BEGIN
     {
@@ -811,7 +811,7 @@
 }
 
 // Ignore target atom in the substructure matcher
-CEXPORT int indigoUnignoreAtom(int target_matcher, int atom_object)
+int indigoUnignoreAtom(int target_matcher, int atom_object)
 {
     INDIGO_BEGIN
     {
@@ -824,7 +824,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoUnignoreAllAtoms(int target_matcher)
+int indigoUnignoreAllAtoms(int target_matcher)
 {
     INDIGO_BEGIN
     {
@@ -835,7 +835,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoMatch(int target_matcher, int query)
+int indigoMatch(int target_matcher, int query)
 {
     INDIGO_BEGIN
     {
@@ -947,7 +947,7 @@
     return indigoCountMatchesWithLimit(target_matcher, query, 0);
 }
 
-CEXPORT int indigoCountMatchesWithLimit(int target_matcher, int query, int embeddings_limit)
+int indigoCountMatchesWithLimit(int target_matcher, int query, int embeddings_limit)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_product_enumerator.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_product_enumerator.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_product_enumerator.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_product_enumerator.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_product_enumerator.cpp	(date 1745583015898)
@@ -66,7 +66,7 @@
     indices.copy(monomers_indices);
 }
 
-CEXPORT int indigoReactionProductEnumerate(int reaction, int monomers)
+int indigoReactionProductEnumerate(int reaction, int monomers)
 {
     INDIGO_BEGIN
     {
@@ -155,7 +155,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoTransform(int reaction, int monomers)
+int indigoTransform(int reaction, int monomers)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.h b/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.h	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.h	(date 1745583015929)
@@ -26,7 +26,7 @@
 #pragma warning(disable : 4251)
 #endif
 
-class DLLEXPORT IndigoFingerprint : public IndigoObject
+class INDIGO_EXPORT IndigoFingerprint : public IndigoObject
 {
 public:
     IndigoFingerprint();
Index: indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.cpp	(date 1745583015898)
@@ -118,7 +118,7 @@
         throw IndigoError("unknown molecule fingerprint type: %s", type);
 }
 
-CEXPORT int indigoFingerprint(int item, const char* type)
+int indigoFingerprint(int item, const char* type)
 {
     INDIGO_BEGIN
     {
@@ -153,7 +153,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadFingerprintFromBuffer(const byte* buffer, int size)
+int indigoLoadFingerprintFromBuffer(const byte* buffer, int size)
 {
     INDIGO_BEGIN
     {
@@ -164,7 +164,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadFingerprintFromDescriptors(const double* arr, int arr_len, int size, double density)
+int indigoLoadFingerprintFromDescriptors(const double* arr, int arr_len, int size, double density)
 {
     INDIGO_BEGIN
     {
@@ -402,7 +402,7 @@
     return 1;
 }
 
-CEXPORT float indigoSimilarity(int item1, int item2, const char* metrics)
+float indigoSimilarity(int item1, int item2, const char* metrics)
 {
     INDIGO_BEGIN
     {
@@ -459,7 +459,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountBits(int fingerprint)
+int indigoCountBits(int fingerprint)
 {
     INDIGO_BEGIN
     {
@@ -469,7 +469,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCommonBits(int fingerprint1, int fingerprint2)
+int indigoCommonBits(int fingerprint1, int fingerprint2)
 {
     INDIGO_BEGIN
     {
@@ -484,7 +484,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoOneBitsList(int fingerprint)
+const char* indigoOneBitsList(int fingerprint)
 {
     INDIGO_BEGIN
     {
Index: rdkit-src/rdkit/Code/GraphMol/FMCS/MaximumCommonSubgraph.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/FMCS/MaximumCommonSubgraph.cpp b/rdkit-src/rdkit/Code/GraphMol/FMCS/MaximumCommonSubgraph.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/FMCS/MaximumCommonSubgraph.cpp	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Code/GraphMol/FMCS/MaximumCommonSubgraph.cpp	(date 1745583015820)
@@ -278,7 +278,7 @@
       Seed seed;
       seed.setStoreAllDegenerateMCS(Parameters.StoreAll);
       seed.ExcludedBonds = excludedBonds;
-      seed.MatchResult.resize(Targets.size());
+      seed.resizeMatchResult(Targets.size());
 #ifdef VERBOSE_STATISTICS_ON
       {
         ++VerboseStatistics.Seed;
@@ -344,7 +344,7 @@
       //    continue;
       Seed seed;
       seed.setStoreAllDegenerateMCS(Parameters.StoreAll);
-      seed.MatchResult.resize(Targets.size());
+      seed.resizeMatchResult(Targets.size());
 
 #ifdef VERBOSE_STATISTICS_ON
       {
@@ -1249,7 +1249,7 @@
     { ++VerboseStatistics.MatchCall; }
 #endif
     bool target_matched = false;
-    if (!seed.MatchResult.empty() && !seed.MatchResult.at(itarget).empty()) {
+    if (!seed.MatchResult.empty() && !seed.MatchResult.at(itarget)->empty()) {
       target_matched = matchIncrementalFast(seed, itarget);
     }
     if (!target_matched) {  // slow full match
@@ -1260,11 +1260,11 @@
       // save current match info
       if (target_matched) {
         if (seed.MatchResult.empty()) {
-          seed.MatchResult.resize(Targets.size());
+          seed.resizeMatchResult(Targets.size());
         }
-        seed.MatchResult[itarget].init(seed, match, *QueryMolecule, tag);
+        seed.MatchResult[itarget]->init(seed, match, *QueryMolecule, tag);
       } else if (!seed.MatchResult.empty()) {
-        seed.MatchResult[itarget].clear();  //.Empty = true; // == fast clear();
+        seed.MatchResult[itarget]->clear();  //.Empty = true; // == fast clear();
       }
 #ifdef VERBOSE_STATISTICS_ON
       if (target_matched) {
@@ -1301,19 +1301,19 @@
 #endif
   const auto &target = Targets.at(itarget);
   auto &match = seed.MatchResult.at(itarget);
-  if (match.empty()) {
+  if (match->empty()) {
     return false;
   }
   /*
   // CHIRALITY: FinalMatchCheck:
   if(Parameters.AtomCompareParameters.MatchChiralTag ||
   Parameters.FinalMatchChecker) {   // TEMP
-          match.clear();
+          match->clear();
           return false;
   }
   */
   bool matched = false;
-  for (unsigned int newBondSeedIdx = match.MatchedBondSize;
+  for (unsigned int newBondSeedIdx = match->MatchedBondSize;
        newBondSeedIdx < seed.getNumBonds(); newBondSeedIdx++) {
     matched = false;
     bool atomAdded = false;
@@ -1328,7 +1328,7 @@
         seed.MoleculeFragment.SeedAtomIdxMap.at(newBond->getBeginAtomIdx());
     unsigned int j =
         seed.MoleculeFragment.SeedAtomIdxMap.at(newBond->getEndAtomIdx());
-    if (i >= match.MatchedAtomSize) {
+    if (i >= match->MatchedAtomSize) {
       // this is new atom in the seed
       newBondSourceAtomSeedIdx = j;
       newBondOtherAtomSeedIdx = i;
@@ -1342,15 +1342,15 @@
         seed.MoleculeFragment.Atoms.at(newBondSourceAtomSeedIdx)->getIdx();
     // matched to newBondSourceAtomSeedIdx
     unsigned int newBondSourceAtomTargetIdx =
-        match.TargetAtomIdx.at(newBondSourceAtomQueryIdx);
+        match->TargetAtomIdx.at(newBondSourceAtomQueryIdx);
     const Bond *tb = nullptr;
     unsigned int newBondOtherAtomTargetIdx = NotSet;
 
-    if (newBondOtherAtomSeedIdx < match.MatchedAtomSize) {
+    if (newBondOtherAtomSeedIdx < match->MatchedAtomSize) {
       // new bond between old atoms - both are
       // matched to exact atoms in the target
       newBondOtherAtomTargetIdx =
-          match.TargetAtomIdx.at(newBondOtherAtomQueryIdx);
+          match->TargetAtomIdx.at(newBondOtherAtomQueryIdx);
       // target bond between Source and Other atom
       tb = target.Molecule->getBondBetweenAtoms(newBondSourceAtomTargetIdx,
                                                 newBondOtherAtomTargetIdx);
@@ -1359,7 +1359,7 @@
         unsigned int tbi = tb->getIdx();
         unsigned int qbi =
             seed.MoleculeFragment.Bonds.at(newBondSeedIdx)->getIdx();
-        if (!match.VisitedTargetBonds.test(tbi)) {
+        if (!match->VisitedTargetBonds.test(tbi)) {
           // false if target bond is already matched
           matched = target.BondMatchTable.at(qbi, tbi);
         }
@@ -1371,14 +1371,14 @@
       for (const auto &nbri :
            boost::make_iterator_range(target.Molecule->getAtomBonds(atom))) {
         tb = (*target.Molecule)[nbri];
-        if (match.VisitedTargetBonds.test(tb->getIdx())) {
+        if (match->VisitedTargetBonds.test(tb->getIdx())) {
           continue;
         }
         newBondOtherAtomTargetIdx = tb->getBeginAtomIdx();
         if (newBondSourceAtomTargetIdx == newBondOtherAtomTargetIdx) {
           newBondOtherAtomTargetIdx = tb->getEndAtomIdx();
         }
-        if (match.VisitedTargetAtoms.test(newBondOtherAtomTargetIdx)) {
+        if (match->VisitedTargetAtoms.test(newBondOtherAtomTargetIdx)) {
           continue;
         }
         // check OtherAtom and bond
@@ -1396,24 +1396,24 @@
 
     if (matched) {      // update match history
       if (atomAdded) {  // new atom has been added
-        match.MatchedAtomSize++;
-        match.TargetAtomIdx[newBondOtherAtomQueryIdx] =
+        match->MatchedAtomSize++;
+        match->TargetAtomIdx[newBondOtherAtomQueryIdx] =
             newBondOtherAtomTargetIdx;
-        match.VisitedTargetAtoms.set(newBondOtherAtomTargetIdx);
+        match->VisitedTargetAtoms.set(newBondOtherAtomTargetIdx);
       }
-      match.MatchedBondSize++;
-      match.TargetBondIdx[newBondQueryIdx] = tb->getIdx();
-      match.VisitedTargetBonds.set(tb->getIdx());
+      match->MatchedBondSize++;
+      match->TargetBondIdx[newBondQueryIdx] = tb->getIdx();
+      match->VisitedTargetBonds.set(tb->getIdx());
     } else {
-      match.clear();
+      match->clear();
       return false;
     }
   }
 
-  if (match.MatchedAtomSize != seed.getNumAtoms() ||
-      match.MatchedBondSize !=
+  if (match->MatchedAtomSize != seed.getNumAtoms() ||
+      match->MatchedBondSize !=
           seed.getNumBonds()) {  // number of unique items !!!
-    match.clear();
+    match->clear();
     return false;
   }
   // CHIRALITY: FinalMatchCheck
@@ -1425,14 +1425,14 @@
     for (unsigned int si = 0; si < seed.getNumAtoms(); ++si) {
       // index in the seed topology
       c1.push_back(si);
-      c2.push_back(match.TargetAtomIdx.at(seed.Topology[si]));
+      c2.push_back(match->TargetAtomIdx.at(seed.Topology[si]));
     }
     matched = Parameters.FinalMatchChecker(c1.data(), c2.data(), *QueryMolecule,
                                            seed.Topology, *target.Molecule,
                                            target.Topology,
                                            &Parameters);  // check CHIRALITY
     if (!matched) {
-      match.clear();
+      match->clear();
     }
   }
 #ifdef VERBOSE_STATISTICS_ON
Index: indigo-src/indigo/api/c/indigo/src/indigo_basic.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_basic.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_basic.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_basic.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_basic.cpp	(date 1745583015945)
@@ -21,7 +21,7 @@
 #include "indigo_internal.h"
 #include <memory>
 
-CEXPORT int indigoNext(int iter)
+int indigoNext(int iter)
 {
     INDIGO_BEGIN
     {
@@ -35,7 +35,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoHasNext(int iter)
+int indigoHasNext(int iter)
 {
     INDIGO_BEGIN
     {
@@ -44,7 +44,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIndex(int handle)
+int indigoIndex(int handle)
 {
     INDIGO_BEGIN
     {
@@ -53,7 +53,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClone(int object)
+int indigoClone(int object)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_composition.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_composition.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_composition.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_composition.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_composition.cpp	(date 1745583015883)
@@ -23,7 +23,7 @@
 
 using MoleculeIter = MoleculeRGroupsComposition::MoleculeIter;
 
-class DLLEXPORT IndigoCompositionElem : public IndigoObject
+class IndigoCompositionElem : public IndigoObject
 {
 public:
     IndigoCompositionElem() : IndigoObject(COMPOSITION_ELEM)
@@ -37,7 +37,7 @@
     MoleculeRGroups variants[RGCOMP_OPT_COUNT];
 };
 
-CEXPORT int indigoGetFragmentedMolecule(int elem, const char* options)
+int indigoGetFragmentedMolecule(int elem, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -72,7 +72,7 @@
     INDIGO_END(-1);
 }
 
-class DLLEXPORT IndigoCompositionIter : public IndigoObject
+class IndigoCompositionIter : public IndigoObject
 {
 public:
     IndigoCompositionIter(BaseMolecule& mol) : IndigoObject(COMPOSITION_ITER), _composition(mol), _it(_composition.begin()), _end(_composition.end())
@@ -112,7 +112,7 @@
     bool _hasNext = true;
 };
 
-CEXPORT int indigoRGroupComposition(int molecule, const char* options)
+int indigoRGroupComposition(int molecule, const char* options)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo.cpp b/indigo-src/indigo/api/c/indigo/src/indigo.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo.cpp	(date 1745583015945)
@@ -40,23 +40,23 @@
 #include <iostream>
 #endif
 
-DLLEXPORT _SessionLocalContainer<Indigo>& indigoSelf()
+_SessionLocalContainer<Indigo>& indigoSelf()
 {
     static _SessionLocalContainer<Indigo> indigo_self;
     return indigo_self;
 }
 
-DLLEXPORT Indigo& indigoGetInstance()
+Indigo& indigoGetInstance()
 {
     return indigoSelf().getLocalCopy();
 }
 
-CEXPORT const char* indigoVersion()
+const char* indigoVersion()
 {
     return INDIGO_VERSION "-" INDIGO_PLATFORM;
 }
 
-CEXPORT const char* indigoVersionInfo()
+const char* indigoVersionInfo()
 {
     INDIGO_BEGIN
     {
@@ -311,7 +311,7 @@
     };
 }
 
-CEXPORT qword indigoAllocSessionId()
+qword indigoAllocSessionId()
 {
     qword id = TL_ALLOC_SESSION_ID();
     TL_SET_SESSION_ID(id);
@@ -328,12 +328,12 @@
     return id;
 }
 
-CEXPORT void indigoSetSessionId(qword id)
+void indigoSetSessionId(qword id)
 {
     TL_SET_SESSION_ID(id);
 }
 
-CEXPORT void indigoReleaseSessionId(qword id)
+void indigoReleaseSessionId(qword id)
 {
     TL_SET_SESSION_ID(id);
     indigoGetInstance().removeAllObjects();
@@ -347,17 +347,17 @@
 #endif
 }
 
-CEXPORT const char* indigoGetLastError(void)
+const char* indigoGetLastError(void)
 {
     return Indigo::getErrorMessage().ptr();
 }
 
-CEXPORT void indigoSetErrorHandler(INDIGO_ERROR_HANDLER handler, void* context)
+void indigoSetErrorHandler(INDIGO_ERROR_HANDLER handler, void* context)
 {
     Indigo::setErrorHandler(handler, context);
 }
 
-CEXPORT int indigoFree(int handle)
+int indigoFree(int handle)
 {
     // In some runtimes (e.g. Python) session could be removed before objects during resource releasing stage)
     if (indigoSelf().hasLocalCopy())
@@ -374,13 +374,13 @@
     return 1;
 }
 
-CEXPORT int indigoFreeAllObjects()
+int indigoFreeAllObjects()
 {
     indigoGetInstance().removeAllObjects();
     return 1;
 }
 
-CEXPORT int indigoCountReferences(void)
+int indigoCountReferences(void)
 {
     INDIGO_BEGIN
     {
@@ -389,7 +389,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT void indigoSetErrorMessage(const char* message)
+void indigoSetErrorMessage(const char* message)
 {
     Indigo& self = indigoGetInstance();
     self.setErrorMessage(message);
@@ -509,9 +509,9 @@
 // Debug methods
 //
 
-#ifdef _WIN32
+#if defined(_WIN32) && !defined(__MINGW32__)
 #include <Windows.h>
-#elif defined(__linux__)
+#elif defined(__linux__) || defined(__MINGW32__)
 #include <fcntl.h>
 #include <unistd.h>
 #elif defined(__APPLE__)
@@ -525,7 +525,7 @@
 {
     void sleepMs(int ms)
     {
-#ifdef _WIN32
+#if defined(_WIN32) && !defined(__MINGW32__)
         Sleep(ms);
 #else
         sleep(ms * 1e-3);
@@ -534,7 +534,7 @@
 
     bool debuggerIsAttached()
     {
-#ifdef _WIN32
+#if defined(_WIN32) && !defined(__MINGW32__)
         return IsDebuggerPresent();
 #elif defined(__APPLE__)
         int mib[4];
@@ -567,9 +567,9 @@
     }
 }
 
-CEXPORT void indigoDbgBreakpoint(void)
+void indigoDbgBreakpoint(void)
 {
-#ifdef _WIN32
+#if defined(_WIN32) && !defined(__MINGW32__)
     if (!IsDebuggerPresent())
     {
         char msg[200];
@@ -592,7 +592,7 @@
 #endif
 }
 
-CEXPORT const char* indigoDbgProfiling(int whole_session)
+const char* indigoDbgProfiling(int whole_session)
 {
     INDIGO_BEGIN
     {
@@ -606,7 +606,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoDbgResetProfiling(int whole_session)
+int indigoDbgResetProfiling(int whole_session)
 {
     INDIGO_BEGIN
     {
@@ -620,7 +620,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT qword indigoDbgProfilingGetCounter(const char* name, int whole_session)
+qword indigoDbgProfilingGetCounter(const char* name, int whole_session)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_mapping.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_mapping.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_mapping.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_mapping.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_mapping.cpp	(date 1745583015914)
@@ -62,7 +62,7 @@
     return res_ptr.release();
 }
 
-CEXPORT int indigoMapAtom(int handle, int atom)
+int indigoMapAtom(int handle, int atom)
 {
     INDIGO_BEGIN
     {
@@ -105,7 +105,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoMapBond(int handle, int bond)
+int indigoMapBond(int handle, int bond)
 {
     INDIGO_BEGIN
     {
@@ -190,7 +190,7 @@
     }
 }
 
-CEXPORT int indigoHighlightedTarget(int item)
+int indigoHighlightedTarget(int item)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_misc.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_misc.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_misc.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_misc.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_misc.cpp	(date 1745583015929)
@@ -47,7 +47,7 @@
 #include "indigo_savers.h"
 #include "indigo_structure_checker.h"
 
-CEXPORT int indigoAromatize(int object)
+int indigoAromatize(int object)
 {
     INDIGO_BEGIN
     {
@@ -63,7 +63,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDearomatize(int object)
+int indigoDearomatize(int object)
 {
     INDIGO_BEGIN
     {
@@ -83,7 +83,7 @@
 }
 
 #define INDIGO_SET_OPTION(SUFFIX, TYPE)                                                                                                                        \
-    CEXPORT int indigoSetOption##SUFFIX(const char* name, TYPE value)                                                                                          \
+    int indigoSetOption##SUFFIX(const char* name, TYPE value)                                                                                          \
     {                                                                                                                                                          \
         INDIGO_BEGIN                                                                                                                                           \
         {                                                                                                                                                      \
@@ -98,7 +98,7 @@
 INDIGO_SET_OPTION(Bool, int)
 INDIGO_SET_OPTION(Float, float)
 
-CEXPORT int indigoSetOptionColor(const char* name, float r, float g, float b)
+int indigoSetOptionColor(const char* name, float r, float g, float b)
 {
     INDIGO_BEGIN
     {
@@ -107,7 +107,7 @@
     }
     INDIGO_END(-1);
 }
-CEXPORT int indigoSetOptionXY(const char* name, int x, int y)
+int indigoSetOptionXY(const char* name, int x, int y)
 {
     INDIGO_BEGIN
     {
@@ -117,7 +117,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetOption(const char* name)
+const char* indigoGetOption(const char* name)
 {
     INDIGO_BEGIN
     {
@@ -128,7 +128,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoGetOptionInt(const char* name, int* value)
+int indigoGetOptionInt(const char* name, int* value)
 {
     INDIGO_BEGIN
     {
@@ -141,7 +141,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetOptionBool(const char* name, int* value)
+int indigoGetOptionBool(const char* name, int* value)
 {
     INDIGO_BEGIN
     {
@@ -154,7 +154,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetOptionFloat(const char* name, float* value)
+int indigoGetOptionFloat(const char* name, float* value)
 {
     INDIGO_BEGIN
     {
@@ -167,7 +167,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetOptionColor(const char* name, float* r, float* g, float* b)
+int indigoGetOptionColor(const char* name, float* r, float* g, float* b)
 {
     INDIGO_BEGIN
     {
@@ -180,7 +180,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetOptionXY(const char* name, int* x, int* y)
+int indigoGetOptionXY(const char* name, int* x, int* y)
 {
     INDIGO_BEGIN
     {
@@ -193,7 +193,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetOptionType(const char* name)
+const char* indigoGetOptionType(const char* name)
 {
     INDIGO_BEGIN
     {
@@ -204,7 +204,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoResetOptions()
+int indigoResetOptions()
 {
     INDIGO_BEGIN
     {
@@ -234,7 +234,7 @@
     }
 }
 
-CEXPORT const char* indigoCheckBadValence(int handle)
+const char* indigoCheckBadValence(int handle)
 {
     INDIGO_BEGIN
     {
@@ -323,7 +323,7 @@
         }
 }
 
-CEXPORT const char* indigoCheckAmbiguousH(int handle)
+const char* indigoCheckAmbiguousH(int handle)
 {
     INDIGO_BEGIN
     {
@@ -380,7 +380,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoSmiles(int item)
+const char* indigoSmiles(int item)
 {
     INDIGO_BEGIN
     {
@@ -392,7 +392,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoCanonicalSmiles(int item)
+const char* indigoCanonicalSmiles(int item)
 {
     INDIGO_BEGIN
     {
@@ -405,7 +405,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int64_t indigoHash(int item)
+int64_t indigoHash(int item)
 {
     INDIGO_BEGIN
     {
@@ -426,7 +426,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoSmarts(int item)
+const char* indigoSmarts(int item)
 {
     INDIGO_BEGIN
     {
@@ -439,7 +439,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoCanonicalSmarts(int item)
+const char* indigoCanonicalSmarts(int item)
 {
     INDIGO_BEGIN
     {
@@ -490,7 +490,7 @@
     return false;
 }
 
-CEXPORT int indigoUnfoldHydrogens(int item)
+int indigoUnfoldHydrogens(int item)
 {
     INDIGO_BEGIN
     {
@@ -577,7 +577,7 @@
     return false;
 }
 
-CEXPORT int indigoFoldUnfoldHydrogens(int item)
+int indigoFoldUnfoldHydrogens(int item)
 {
     INDIGO_BEGIN
     {
@@ -671,7 +671,7 @@
     return to_remove.size() > 0;
 }
 
-CEXPORT int indigoFoldHydrogens(int item)
+int indigoFoldHydrogens(int item)
 {
     INDIGO_BEGIN
     {
@@ -721,7 +721,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetName(int handle, const char* name)
+int indigoSetName(int handle, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -738,7 +738,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoName(int handle)
+const char* indigoName(int handle)
 {
     INDIGO_BEGIN
     {
@@ -747,7 +747,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoRawData(int handler)
+const char* indigoRawData(int handler)
 {
     INDIGO_BEGIN
     {
@@ -777,7 +777,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoRemove(int item)
+int indigoRemove(int item)
 {
     INDIGO_BEGIN
     {
@@ -789,7 +789,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAt(int item, int index)
+int indigoAt(int item, int index)
 {
     INDIGO_BEGIN
     {
@@ -834,7 +834,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCount(int item)
+int indigoCount(int item)
 {
     INDIGO_BEGIN
     {
@@ -857,7 +857,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSerialize(int item, byte** buf, int* size)
+int indigoSerialize(int item, byte** buf, int* size)
 {
     INDIGO_BEGIN
     {
@@ -894,7 +894,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoUnserialize(const byte* buf, int size)
+int indigoUnserialize(const byte* buf, int size)
 {
     INDIGO_BEGIN
     {
@@ -920,7 +920,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClear(int item)
+int indigoClear(int item)
 {
     INDIGO_BEGIN
     {
@@ -943,7 +943,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoHighlight(int item)
+int indigoHighlight(int item)
 {
     INDIGO_BEGIN
     {
@@ -969,7 +969,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoUnhighlight(int item)
+int indigoUnhighlight(int item)
 {
     INDIGO_BEGIN
     {
@@ -1007,7 +1007,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIsHighlighted(int item)
+int indigoIsHighlighted(int item)
 {
     INDIGO_BEGIN
     {
@@ -1033,7 +1033,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSelect(int item)
+int indigoSelect(int item)
 {
     INDIGO_BEGIN
     {
@@ -1059,7 +1059,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoUnselect(int item)
+int indigoUnselect(int item)
 {
     INDIGO_BEGIN
     {
@@ -1097,7 +1097,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIsSelected(int item)
+int indigoIsSelected(int item)
 {
     INDIGO_BEGIN
     {
@@ -1123,7 +1123,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoOptimize(int query, const char* options)
+int indigoOptimize(int query, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -1179,17 +1179,17 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoHasZCoord(int item)
+int indigoHasZCoord(int item)
 {
     return _indigoHasCoord(item, BaseMolecule::hasZCoord, "indigoHasZCoord");
 }
 
-CEXPORT int indigoHasCoord(int item)
+int indigoHasCoord(int item)
 {
     return _indigoHasCoord(item, BaseMolecule::hasCoord, "indigoHasCoord");
 }
 
-CEXPORT const char* indigoDbgInternalType(int object)
+const char* indigoDbgInternalType(int object)
 {
     INDIGO_BEGIN
     {
@@ -1204,7 +1204,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoNormalize(int structure, const char* options)
+int indigoNormalize(int structure, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -1255,7 +1255,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoStandardize(int object)
+int indigoStandardize(int object)
 {
     INDIGO_BEGIN
     {
@@ -1280,7 +1280,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIonize(int object, float pH, float pH_toll)
+int indigoIonize(int object, float pH, float pH_toll)
 {
     INDIGO_BEGIN
     {
@@ -1292,7 +1292,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoBuildPkaModel(int max_level, float threshold, const char* filename)
+int indigoBuildPkaModel(int max_level, float threshold, const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -1304,7 +1304,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT float* indigoGetAcidPkaValue(int object, int atom, int level, int min_level)
+float* indigoGetAcidPkaValue(int object, int atom, int level, int min_level)
 {
     INDIGO_BEGIN
     {
@@ -1327,7 +1327,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT float* indigoGetBasicPkaValue(int object, int atom, int level, int min_level)
+float* indigoGetBasicPkaValue(int object, int atom, int level, int min_level)
 {
     INDIGO_BEGIN
     {
@@ -1350,7 +1350,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoIsPossibleFischerProjection(int object, const char* options)
+int indigoIsPossibleFischerProjection(int object, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -1403,7 +1403,7 @@
     }
 }
 
-CEXPORT int indigoTransformHELMtoSCSR(int object)
+int indigoTransformHELMtoSCSR(int object)
 {
     INDIGO_BEGIN
     {
@@ -1452,7 +1452,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCheckQuery(int item)
+int indigoCheckQuery(int item)
 {
     INDIGO_BEGIN
     {
@@ -1495,7 +1495,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCheckChirality(int item)
+int indigoCheckChirality(int item)
 {
     INDIGO_BEGIN
     {
@@ -1519,7 +1519,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCheck3DStereo(int item)
+int indigoCheck3DStereo(int item)
 {
     INDIGO_BEGIN
     {
@@ -1556,7 +1556,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCheckStereo(int item)
+int indigoCheckStereo(int item)
 {
     INDIGO_BEGIN
     {
@@ -1599,7 +1599,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoCheck(const char* item, const char* check_flags, const char* load_params)
+const char* indigoCheck(const char* item, const char* check_flags, const char* load_params)
 {
     INDIGO_BEGIN
     {
@@ -1614,7 +1614,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoCheckObj(int item, const char* check_flags)
+const char* indigoCheckObj(int item, const char* check_flags)
 {
     INDIGO_BEGIN
     {
@@ -1628,7 +1628,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoCheckStructure(const char* structure, const char* props)
+const char* indigoCheckStructure(const char* structure, const char* props)
 {
     INDIGO_BEGIN
     {
@@ -1654,7 +1654,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoJson(int item)
+const char* indigoJson(int item)
 {
     INDIGO_BEGIN
     {
@@ -1719,7 +1719,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoGetOriginalFormat(int item)
+const char* indigoGetOriginalFormat(int item)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_calc.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_calc.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_calc.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_calc.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_calc.cpp	(date 1745583015945)
@@ -37,7 +37,7 @@
     ReactionGrossFormula::toString_Hill(*gross, str, self.gross_formula_options.add_rsites);
 }
 
-CEXPORT int indigoGrossFormula(int object)
+int indigoGrossFormula(int object)
 {
     INDIGO_BEGIN
     {
@@ -81,7 +81,7 @@
     }
 }
 
-CEXPORT double indigoMolecularWeight(int molecule)
+double indigoMolecularWeight(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -93,7 +93,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT double indigoMostAbundantMass(int molecule)
+double indigoMostAbundantMass(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -105,7 +105,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT double indigoMonoisotopicMass(int molecule)
+double indigoMonoisotopicMass(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -117,7 +117,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoMassComposition(int molecule)
+const char* indigoMassComposition(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -133,7 +133,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT double indigoTPSA(const int molecule, const int includeSP)
+double indigoTPSA(const int molecule, const int includeSP)
 {
     INDIGO_BEGIN
     {
@@ -148,7 +148,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoNumRotatableBonds(const int molecule)
+int indigoNumRotatableBonds(const int molecule)
 {
     INDIGO_BEGIN
     {
@@ -163,7 +163,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoNumHydrogenBondAcceptors(const int molecule)
+int indigoNumHydrogenBondAcceptors(const int molecule)
 {
     INDIGO_BEGIN
     {
@@ -178,7 +178,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoNumHydrogenBondDonors(const int molecule)
+int indigoNumHydrogenBondDonors(const int molecule)
 {
     INDIGO_BEGIN
     {
@@ -193,7 +193,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT double indigoLogP(const int molecule)
+double indigoLogP(const int molecule)
 {
     INDIGO_BEGIN
     {
@@ -208,7 +208,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT double indigoMolarRefractivity(const int molecule)
+double indigoMolarRefractivity(const int molecule)
 {
     INDIGO_BEGIN
     {
@@ -223,7 +223,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT double indigoPka(const int molecule)
+double indigoPka(const int molecule)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/core/indigo-core/molecule/metadata_storage.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/molecule/metadata_storage.h b/indigo-src/indigo/core/indigo-core/molecule/metadata_storage.h
--- a/indigo-src/indigo/core/indigo-core/molecule/metadata_storage.h	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/core/indigo-core/molecule/metadata_storage.h	(date 1745648166779)
@@ -30,7 +30,7 @@
     class MetaObject
     {
     public:
-        explicit MetaObject(uint32_t class_id) : _class_id(class_id)
+        explicit MetaObject(std::uint32_t class_id) : _class_id(class_id)
         {
         }
         uint32_t _class_id;
Index: rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.h b/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.h
--- a/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.h	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.h	(date 1745583015820)
@@ -91,13 +91,15 @@
   DuplicatedSeedCache::TKey DupCacheKey;
 #endif
   // for each target
-  std::vector<TargetMatch> MatchResult;
+  std::vector<std::shared_ptr<TargetMatch>> MatchResult;
 
  public:
   Seed()
 
   {}
 
+  void resizeMatchResult(const std::size_t& size);
+
   void setMoleculeFragment(const Seed &src) {
     MoleculeFragment = src.MoleculeFragment;
   }
Index: indigo-src/indigo/api/c/indigo/src/option_manager.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/option_manager.h b/indigo-src/indigo/api/c/indigo/src/option_manager.h
--- a/indigo-src/indigo/api/c/indigo/src/option_manager.h	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/option_manager.h	(date 1745648090774)
@@ -26,13 +26,14 @@
 
 #include "base_cpp/os_sync_wrapper.h"
 #include "base_cpp/red_black.h"
+#include "indigo.h"
 
 #include <cstdint>
 #include <sstream>
 
 using namespace indigo;
 
-#define DECL_SET_OPT_HANDLER(suffix, ftype, type, map) DLLEXPORT void setOptionHandler##suffix(const char* name, ftype func);
+#define DECL_SET_OPT_HANDLER(suffix, ftype, type, map) INDIGO_EXPORT void setOptionHandler##suffix(const char* name, ftype func);
 
 #define DEF_HANDLER(suffix, ftype, type, map)                                                                                                                  \
     void setOptionHandler##suffix(const char* name, ftype func)                                                                                                \
@@ -137,7 +138,7 @@
             }                                                                                                                                                  \
         }
 
-class DLLEXPORT IndigoOptionManager
+class INDIGO_EXPORT IndigoOptionManager
 {
 public:
     IndigoOptionManager() = default;
@@ -239,6 +240,9 @@
     IndigoOptionManager(const IndigoOptionManager&);
 };
 
+INDIGO_EXPORT sf::safe_shared_hide_obj<IndigoOptionManager> &
+indigoGetOptionManager(const qword id = TL_GET_SESSION_ID());
+
 #ifdef _MSC_VER
 #pragma warning(pop)
 #endif
Index: rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.cpp b/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.cpp	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.cpp	(date 1745583015820)
@@ -19,6 +19,14 @@
 namespace RDKit {
 namespace FMCS {
 
+void Seed::resizeMatchResult(const std::size_t& size) {
+  MatchResult.clear();
+  MatchResult.resize(size);
+  for(auto&p : MatchResult) {
+    p = std::make_shared<TargetMatch>();
+  }
+}
+
 unsigned int Seed::addAtom(const Atom *atom) {
   unsigned int i = MoleculeFragment.Atoms.size();
   unsigned int aqi = atom->getIdx();
Index: indigo-src/indigo/api/c/indigo/src/indigo_io.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_io.h b/indigo-src/indigo/api/c/indigo/src/indigo_io.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_io.h	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_io.h	(date 1745583015898)
@@ -27,7 +27,7 @@
 #pragma warning(disable : 4251)
 #endif
 
-class DLLEXPORT IndigoScanner : public IndigoObject
+class INDIGO_EXPORT IndigoScanner : public IndigoObject
 {
 public:
     IndigoScanner(Scanner* scanner);
@@ -44,7 +44,7 @@
     Array<char> _buf;
 };
 
-class DLLEXPORT IndigoOutput : public IndigoObject
+class INDIGO_EXPORT IndigoOutput : public IndigoObject
 {
 public:
     IndigoOutput();
Index: cppcoro-src/cppcoro/lib/socket_recv_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_recv_operation.cpp b/cppcoro-src/cppcoro/lib/socket_recv_operation.cpp
--- a/cppcoro-src/cppcoro/lib/socket_recv_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_recv_operation.cpp	(date 1745583016148)
@@ -7,10 +7,10 @@
 #include <cppcoro/net/socket.hpp>
 
 #if CPPCORO_OS_WINNT
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 
 bool cppcoro::net::socket_recv_operation_impl::try_start(
 	cppcoro::detail::win32_overlapped_operation_base& operation) noexcept
Index: indigo-src/indigo/api/c/indigo/src/indigo_reaction.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_reaction.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_reaction.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_reaction.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_reaction.cpp	(date 1745648090790)
@@ -442,7 +442,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadReaction(int source)
+int indigoLoadReaction(int source)
 {
     INDIGO_BEGIN
     {
@@ -477,7 +477,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadQueryReaction(int source)
+int indigoLoadQueryReaction(int source)
 {
     INDIGO_BEGIN
     {
@@ -498,32 +498,32 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateReactants(int reaction)
+int indigoIterateReactants(int reaction)
 {
     return _indigoIterateReaction(reaction, IndigoReactionIter::REACTANTS);
 }
 
-CEXPORT int indigoIterateProducts(int reaction)
+int indigoIterateProducts(int reaction)
 {
     return _indigoIterateReaction(reaction, IndigoReactionIter::PRODUCTS);
 }
 
-CEXPORT int indigoIterateCatalysts(int reaction)
+int indigoIterateCatalysts(int reaction)
 {
     return _indigoIterateReaction(reaction, IndigoReactionIter::CATALYSTS);
 }
 
-CEXPORT int indigoIterateMolecules(int reaction)
+int indigoIterateMolecules(int reaction)
 {
     return _indigoIterateReaction(reaction, IndigoReactionIter::MOLECULES);
 }
 
-CEXPORT int indigoIterateReactions(int reaction)
+int indigoIterateReactions(int reaction)
 {
     return _indigoIterateReaction(reaction, IndigoReactionIter::REACTIONS);
 }
 
-CEXPORT int indigoCreateReaction(void)
+int indigoCreateReaction(void)
 {
     INDIGO_BEGIN
     {
@@ -532,7 +532,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateQueryReaction(void)
+int indigoCreateQueryReaction(void)
 {
     INDIGO_BEGIN
     {
@@ -541,7 +541,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddReactant(int reaction, int molecule)
+int indigoAddReactant(int reaction, int molecule)
 {
     INDIGO_BEGIN
     {
@@ -553,7 +553,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddProduct(int reaction, int molecule)
+int indigoAddProduct(int reaction, int molecule)
 {
     INDIGO_BEGIN
     {
@@ -565,7 +565,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddCatalyst(int reaction, int molecule)
+int indigoAddCatalyst(int reaction, int molecule)
 {
     INDIGO_BEGIN
     {
@@ -577,7 +577,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountReactants(int reaction)
+int indigoCountReactants(int reaction)
 {
     INDIGO_BEGIN
     {
@@ -586,7 +586,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountProducts(int reaction)
+int indigoCountProducts(int reaction)
 {
     INDIGO_BEGIN
     {
@@ -595,7 +595,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountCatalysts(int reaction)
+int indigoCountCatalysts(int reaction)
 {
     INDIGO_BEGIN
     {
@@ -604,7 +604,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountMolecules(int handle)
+int indigoCountMolecules(int handle)
 {
     INDIGO_BEGIN
     {
@@ -618,7 +618,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetMolecule(int reaction, int index)
+int indigoGetMolecule(int reaction, int index)
 {
     INDIGO_BEGIN
     {
@@ -638,7 +638,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoMapMolecule(int handle, int molecule)
+int indigoMapMolecule(int handle, int molecule)
 {
     INDIGO_BEGIN
     {
@@ -704,7 +704,7 @@
     return nmode;
 }
 
-CEXPORT int indigoAutomap(int reaction, const char* mode)
+int indigoAutomap(int reaction, const char* mode)
 {
     INDIGO_BEGIN
     {
@@ -747,7 +747,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetAtomMappingNumber(int reaction, int reaction_atom)
+int indigoGetAtomMappingNumber(int reaction, int reaction_atom)
 {
     INDIGO_BEGIN
     {
@@ -764,7 +764,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetAtomMappingNumber(int reaction, int reaction_atom, int number)
+int indigoSetAtomMappingNumber(int reaction, int reaction_atom, int number)
 {
     INDIGO_BEGIN
     {
@@ -784,7 +784,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetReactingCenter(int reaction, int reaction_bond, int* rc)
+int indigoGetReactingCenter(int reaction, int reaction_bond, int* rc)
 {
     INDIGO_BEGIN
     {
@@ -802,7 +802,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetReactingCenter(int reaction, int reaction_bond, int rc)
+int indigoSetReactingCenter(int reaction, int reaction_bond, int rc)
 {
     INDIGO_BEGIN
     {
@@ -822,7 +822,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearAAM(int reaction)
+int indigoClearAAM(int reaction)
 {
     INDIGO_BEGIN
     {
@@ -833,7 +833,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCorrectReactingCenters(int reaction)
+int indigoCorrectReactingCenters(int reaction)
 {
     INDIGO_BEGIN
     {
@@ -846,7 +846,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadReactionSmarts(int source)
+int indigoLoadReactionSmarts(int source)
 {
     INDIGO_BEGIN
     {
@@ -864,7 +864,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoCanonicalRSmiles(int reaction)
+const char* indigoCanonicalRSmiles(int reaction)
 {
     INDIGO_BEGIN
     {
Index: cppcoro-src/cppcoro/lib/async_manual_reset_event.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/async_manual_reset_event.cpp b/cppcoro-src/cppcoro/lib/async_manual_reset_event.cpp
--- a/cppcoro-src/cppcoro/lib/async_manual_reset_event.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/async_manual_reset_event.cpp	(date 1745583016179)
@@ -72,7 +72,7 @@
 }
 
 bool cppcoro::async_manual_reset_event_operation::await_suspend(
-	std::experimental::coroutine_handle<> awaiter) noexcept
+	std::coroutine_handle<> awaiter) noexcept
 {
 	m_awaiter = awaiter;
 
Index: cppcoro-src/cppcoro/lib/file.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/file.cpp b/cppcoro-src/cppcoro/lib/file.cpp
--- a/cppcoro-src/cppcoro/lib/file.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/file.cpp	(date 1745583016179)
@@ -13,7 +13,7 @@
 # ifndef WIN32_LEAN_AND_MEAN
 #  define WIN32_LEAN_AND_MEAN
 # endif
-# include <Windows.h>
+# include <windows.h>
 #endif
 
 cppcoro::file::~file()
@@ -47,7 +47,7 @@
 cppcoro::detail::win32::safe_handle cppcoro::file::open(
 	detail::win32::dword_t fileAccess,
 	io_service& ioService,
-	const std::experimental::filesystem::path& path,
+	const std::filesystem::path& path,
 	file_open_mode openMode,
 	file_share_mode shareMode,
 	file_buffering_mode bufferingMode)
Index: indigo-src/indigo/api/c/indigo/src/indigo_savers.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_savers.h b/indigo-src/indigo/api/c/indigo/src/indigo_savers.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_savers.h	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_savers.h	(date 1745583015961)
@@ -26,7 +26,7 @@
 
 #include "indigo_internal.h"
 
-class DLLEXPORT IndigoSaver : public IndigoObject
+class INDIGO_EXPORT IndigoSaver : public IndigoObject
 {
 public:
     IndigoSaver(Output& output);
Index: cppcoro-src/cppcoro/lib/socket_helpers.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_helpers.cpp b/cppcoro-src/cppcoro/lib/socket_helpers.cpp
--- a/cppcoro-src/cppcoro/lib/socket_helpers.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_helpers.cpp	(date 1745583016148)
@@ -11,10 +11,10 @@
 #include <cstring>
 #include <cassert>
 
-#include <WinSock2.h>
-#include <WS2tcpip.h>
-#include <MSWSock.h>
-#include <Windows.h>
+#include <winsock2.h>
+#include <ws2tcpip.h>
+#include <mswsock.h>
+#include <windows.h>
 
 
 cppcoro::net::ip_endpoint
@@ -74,7 +74,11 @@
 		std::memcpy(&ipv6Address.sin6_addr, ipv6EndPoint.address().bytes(), 16);
 		ipv6Address.sin6_port = htons(ipv6EndPoint.port());
 		ipv6Address.sin6_flowinfo = 0;
+#ifdef SCOPEID_UNSPECIFIED_INIT
 		ipv6Address.sin6_scope_struct = SCOPEID_UNSPECIFIED_INIT;
+#else
+		ipv6Address.sin6_scope_struct = {0};
+#endif
 
 		std::memcpy(&address.get(), &ipv6Address, sizeof(ipv6Address));
 
Index: indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.cpp	(date 1745583015945)
@@ -1564,7 +1564,7 @@
     return false;
 }
 
-CEXPORT int indigoDecomposeMolecules(int scaffold, int structures)
+int indigoDecomposeMolecules(int scaffold, int structures)
 {
     INDIGO_BEGIN
     {
@@ -1585,7 +1585,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateDecomposedMolecules(int decomp)
+int indigoIterateDecomposedMolecules(int decomp)
 {
     INDIGO_BEGIN
     {
@@ -1601,7 +1601,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDecomposedMoleculeScaffold(int decomp)
+int indigoDecomposedMoleculeScaffold(int decomp)
 {
     INDIGO_BEGIN
     {
@@ -1658,7 +1658,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDecomposedMoleculeHighlighted(int decomp)
+int indigoDecomposedMoleculeHighlighted(int decomp)
 {
     INDIGO_BEGIN
     {
@@ -1694,7 +1694,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDecomposedMoleculeSubstituents(int decomp)
+int indigoDecomposedMoleculeSubstituents(int decomp)
 {
     INDIGO_BEGIN
     {
@@ -1732,7 +1732,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDecomposedMoleculeWithRGroups(int decomp)
+int indigoDecomposedMoleculeWithRGroups(int decomp)
 {
     INDIGO_BEGIN
     {
@@ -1775,7 +1775,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateDecomposer(int scaffold)
+int indigoCreateDecomposer(int scaffold)
 {
     INDIGO_BEGIN
     {
@@ -1792,7 +1792,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDecomposeMolecule(int decomp, int mol)
+int indigoDecomposeMolecule(int decomp, int mol)
 {
     INDIGO_BEGIN
     {
@@ -1813,7 +1813,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateDecompositions(int deco_item)
+int indigoIterateDecompositions(int deco_item)
 {
     INDIGO_BEGIN
     {
@@ -1837,7 +1837,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddDecomposition(int decomp, int q_match)
+int indigoAddDecomposition(int decomp, int q_match)
 {
     INDIGO_BEGIN
     {
Index: cppcoro-src/cppcoro/lib/socket_accept_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_accept_operation.cpp b/cppcoro-src/cppcoro/lib/socket_accept_operation.cpp
--- a/cppcoro-src/cppcoro/lib/socket_accept_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_accept_operation.cpp	(date 1745583016179)
@@ -11,10 +11,10 @@
 #include <system_error>
 
 #if CPPCORO_OS_WINNT
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 
 // TODO: Eliminate duplication of implementation between socket_accept_operation
 // and socket_accept_operation_cancellable.
Index: cppcoro-src/cppcoro/lib/auto_reset_event.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/auto_reset_event.cpp b/cppcoro-src/cppcoro/lib/auto_reset_event.cpp
--- a/cppcoro-src/cppcoro/lib/auto_reset_event.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/auto_reset_event.cpp	(date 1745583016164)
@@ -7,7 +7,7 @@
 
 #if CPPCORO_OS_WINNT
 # define WIN32_LEAN_AND_MEAN
-# include <Windows.h>
+# include <windows.h>
 # include <system_error>
 #endif
 
Index: zlib-src/zlib/zconf.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/zlib-src/zlib/zconf.h b/zlib-src/zlib/zconf.h
--- a/zlib-src/zlib/zconf.h	(revision 51b7f2abdade71cd9bb0e7a373ef2610ec6f9daf)
+++ b/zlib-src/zlib/zconf.h	(date 1745583016133)
@@ -8,6 +8,7 @@
 #ifndef ZCONF_H
 #define ZCONF_H
 
+#include "zlib_export.h"
 /*
  * If you *really* need a unique prefix for all types and library functions,
  * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
@@ -327,6 +328,7 @@
 #  endif
 #endif
 
+#if 0
 #if defined(WINDOWS) || defined(WIN32)
    /* If building or using zlib as a DLL, define ZLIB_DLL.
     * This is not mandatory, but it offers a little performance increase.
@@ -374,9 +376,10 @@
 #    endif
 #  endif
 #endif
+#endif
 
 #ifndef ZEXTERN
-#  define ZEXTERN extern
+#  define ZEXTERN extern ZLIB_EXPORT
 #endif
 #ifndef ZEXPORT
 #  define ZEXPORT
Index: indigo-src/indigo/api/c/indigo/src/indigo_properties.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_properties.h b/indigo-src/indigo/api/c/indigo/src/indigo_properties.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_properties.h	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_properties.h	(date 1745583015898)
@@ -25,7 +25,7 @@
     class PropertiesMap;
 }
 
-class DLLEXPORT IndigoProperty : public IndigoObject
+class INDIGO_EXPORT IndigoProperty : public IndigoObject
 {
 public:
     IndigoProperty(indigo::PropertiesMap& props, int idx);
Index: cppcoro-src/cppcoro/lib/socket_send_to_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_send_to_operation.cpp b/cppcoro-src/cppcoro/lib/socket_send_to_operation.cpp
--- a/cppcoro-src/cppcoro/lib/socket_send_to_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_send_to_operation.cpp	(date 1745583016164)
@@ -9,10 +9,10 @@
 #if CPPCORO_OS_WINNT
 # include "socket_helpers.hpp"
 
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 
 bool cppcoro::net::socket_send_to_operation_impl::try_start(
 	cppcoro::detail::win32_overlapped_operation_base& operation) noexcept
Index: indigo-src/indigo/api/c/indigo/src/indigo_properties.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_properties.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_properties.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_properties.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_properties.cpp	(date 1745583015898)
@@ -19,7 +19,7 @@
 #include "indigo_properties.h"
 #include "base_cpp/properties_map.h"
 
-CEXPORT int indigoHasProperty(int handle, const char* prop)
+int indigoHasProperty(int handle, const char* prop)
 {
     INDIGO_BEGIN
     {
@@ -35,7 +35,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetProperty(int handle, const char* prop)
+const char* indigoGetProperty(int handle, const char* prop)
 {
     INDIGO_BEGIN
     {
@@ -52,7 +52,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoSetProperty(int handle, const char* prop, const char* value)
+int indigoSetProperty(int handle, const char* prop, const char* value)
 {
     INDIGO_BEGIN
     {
@@ -70,7 +70,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRemoveProperty(int handle, const char* prop)
+int indigoRemoveProperty(int handle, const char* prop)
 {
     INDIGO_BEGIN
     {
@@ -138,7 +138,7 @@
     return new IndigoProperty(_props, _idx);
 }
 
-CEXPORT int indigoIterateProperties(int handle)
+int indigoIterateProperties(int handle)
 {
     INDIGO_BEGIN
     {
@@ -150,7 +150,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearProperties(int handle)
+int indigoClearProperties(int handle)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_tautomer_enumerator.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_tautomer_enumerator.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_tautomer_enumerator.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_tautomer_enumerator.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_tautomer_enumerator.cpp	(date 1745583015945)
@@ -19,7 +19,7 @@
 #include "indigo_tautomer_enumerator.h"
 #include "indigo_molecule.h"
 
-CEXPORT int indigoIterateTautomers(int molecule, const char* options)
+int indigoIterateTautomers(int molecule, const char* options)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_structure_checker.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_structure_checker.h b/indigo-src/indigo/api/c/indigo/src/indigo_structure_checker.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_structure_checker.h	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_structure_checker.h	(date 1745583015883)
@@ -28,7 +28,7 @@
 namespace indigo
 {
 
-    class DLLEXPORT IndigoStructureChecker : public StructureChecker
+    class INDIGO_EXPORT IndigoStructureChecker : public StructureChecker
     {
     public:
         IndigoStructureChecker();
Index: indigo-src/indigo/api/c/indigo/src/indigo_match.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_match.h b/indigo-src/indigo/api/c/indigo/src/indigo_match.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_match.h	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_match.h	(date 1745583015914)
@@ -101,7 +101,7 @@
 };
 
 // Matcher class for matching queries on a specified target molecule
-class DLLEXPORT IndigoMoleculeSubstructureMatcher : public IndigoObject
+class INDIGO_EXPORT IndigoMoleculeSubstructureMatcher : public IndigoObject
 {
 public:
     enum
@@ -145,7 +145,7 @@
     MoleculeAtomNeighbourhoodCounters _nei_counters, _nei_counters_h_unfolded;
 };
 
-class DLLEXPORT IndigoReactionSubstructureMatcher : public IndigoObject
+class INDIGO_EXPORT IndigoReactionSubstructureMatcher : public IndigoObject
 {
 public:
     IndigoReactionSubstructureMatcher(Reaction& target);
@@ -164,8 +164,8 @@
     Array<int> mol_mapping;
 };
 
-DLLEXPORT bool _indigoParseTautomerFlags(const char* flags, IndigoTautomerParams& params);
-DLLEXPORT int _indigoParseExactFlags(const char* flags, bool reaction, float* rms_threshold);
+INDIGO_EXPORT bool _indigoParseTautomerFlags(const char* flags, IndigoTautomerParams& params);
+INDIGO_EXPORT int _indigoParseExactFlags(const char* flags, bool reaction, float* rms_threshold);
 
 #ifdef _WIN32
 #pragma warning(pop)
Index: cppcoro-src/cppcoro/lib/static_thread_pool.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/static_thread_pool.cpp b/cppcoro-src/cppcoro/lib/static_thread_pool.cpp
--- a/cppcoro-src/cppcoro/lib/static_thread_pool.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/static_thread_pool.cpp	(date 1745583016164)
@@ -12,6 +12,7 @@
 #include <cassert>
 #include <mutex>
 #include <chrono>
+#include <utility>
 
 namespace
 {
@@ -319,7 +320,7 @@
 	};
 
 	void static_thread_pool::schedule_operation::await_suspend(
-		std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+		std::coroutine_handle<> awaitingCoroutine) noexcept
 	{
 		m_awaitingCoroutine = awaitingCoroutine;
 		m_threadPool->schedule_impl(this);
Index: indigo-src/indigo/api/c/indigo/src/indigo_loaders.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_loaders.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_loaders.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_loaders.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_loaders.cpp	(date 1745583015914)
@@ -511,7 +511,7 @@
     return next();
 }
 
-CEXPORT int indigoIterateSDF(int reader)
+int indigoIterateSDF(int reader)
 {
     INDIGO_BEGIN
     {
@@ -522,7 +522,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateRDF(int reader)
+int indigoIterateRDF(int reader)
 {
     INDIGO_BEGIN
     {
@@ -533,7 +533,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateSmiles(int reader)
+int indigoIterateSmiles(int reader)
 {
     INDIGO_BEGIN
     {
@@ -544,7 +544,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoTell(int handle)
+int indigoTell(int handle)
 {
     INDIGO_BEGIN
     {
@@ -585,7 +585,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT long long indigoTell64(int handle)
+long long indigoTell64(int handle)
 {
     INDIGO_BEGIN
     {
@@ -618,7 +618,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateSDFile(const char* filename)
+int indigoIterateSDFile(const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -627,7 +627,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateRDFile(const char* filename)
+int indigoIterateRDFile(const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -636,7 +636,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateSmilesFile(const char* filename)
+int indigoIterateSmilesFile(const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -775,7 +775,7 @@
         return new IndigoCmlMolecule(loader->data, counter, offset);
 }
 
-CEXPORT int indigoIterateCML(int reader)
+int indigoIterateCML(int reader)
 {
     INDIGO_BEGIN
     {
@@ -786,7 +786,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateCMLFile(const char* filename)
+int indigoIterateCMLFile(const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -937,7 +937,7 @@
         return new IndigoCdxMolecule(loader->data, loader->properties, index, 0);
 }
 
-CEXPORT int indigoIterateCDX(int reader)
+int indigoIterateCDX(int reader)
 {
     INDIGO_BEGIN
     {
@@ -948,7 +948,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateCDXFile(const char* filename)
+int indigoIterateCDXFile(const char* filename)
 {
     INDIGO_BEGIN
     {
Index: cppcoro-src/cppcoro/lib/spin_wait.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/spin_wait.cpp b/cppcoro-src/cppcoro/lib/spin_wait.cpp
--- a/cppcoro-src/cppcoro/lib/spin_wait.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/spin_wait.cpp	(date 1745583016148)
@@ -10,7 +10,7 @@
 
 #if CPPCORO_OS_WINNT
 # define WIN32_LEAN_AND_MEAN
-# include <Windows.h>
+# include <windows.h>
 #endif
 
 namespace
Index: indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.h b/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.h	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.h	(date 1745583015914)
@@ -37,7 +37,7 @@
 class IndigoDeconvolutionElem;
 class IndigoDecompositionMatch;
 
-class DLLEXPORT IndigoDeconvolution : public IndigoObject
+class INDIGO_EXPORT IndigoDeconvolution : public IndigoObject
 {
 private:
     enum
@@ -143,7 +143,7 @@
     ObjArray<IndigoDeconvolutionElem> _deconvolutionElems;
 };
 
-class DLLEXPORT IndigoDeconvolutionElem : public IndigoObject
+class INDIGO_EXPORT IndigoDeconvolutionElem : public IndigoObject
 {
 public:
     IndigoDeconvolutionElem(Molecule& mol);
@@ -169,7 +169,7 @@
     indigo::PropertiesMap _properties;
 };
 
-class DLLEXPORT IndigoDecompositionMatch : public IndigoObject
+class INDIGO_EXPORT IndigoDecompositionMatch : public IndigoObject
 {
 public:
     IndigoDecompositionMatch();
@@ -205,7 +205,7 @@
     bool _completeScaffold;
 };
 
-class DLLEXPORT IndigoDeconvolutionIter : public IndigoObject
+class INDIGO_EXPORT IndigoDeconvolutionIter : public IndigoObject
 {
 public:
     IndigoDeconvolutionIter(ObjArray<IndigoDeconvolutionElem>& items);
@@ -218,7 +218,7 @@
     int _index;
     ObjArray<IndigoDeconvolutionElem>& _items;
 };
-class DLLEXPORT IndigoDecompositionMatchIter : public IndigoObject
+class INDIGO_EXPORT IndigoDecompositionMatchIter : public IndigoObject
 {
 public:
     IndigoDecompositionMatchIter(ObjArray<IndigoDecompositionMatch>& matches);
Index: cppcoro-src/cppcoro/lib/socket_disconnect_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_disconnect_operation.cpp b/cppcoro-src/cppcoro/lib/socket_disconnect_operation.cpp
--- a/cppcoro-src/cppcoro/lib/socket_disconnect_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_disconnect_operation.cpp	(date 1745583016164)
@@ -11,10 +11,10 @@
 #include <system_error>
 
 #if CPPCORO_OS_WINNT
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 
 bool cppcoro::net::socket_disconnect_operation_impl::try_start(
 	cppcoro::detail::win32_overlapped_operation_base& operation) noexcept
Index: indigo-src/indigo/api/c/indigo/src/indigo_reaction.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_reaction.h b/indigo-src/indigo/api/c/indigo/src/indigo_reaction.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_reaction.h	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_reaction.h	(date 1745583015961)
@@ -29,7 +29,7 @@
 #pragma warning(disable : 4251)
 #endif
 
-class DLLEXPORT IndigoBaseReaction : public IndigoObject
+class INDIGO_EXPORT IndigoBaseReaction : public IndigoObject
 {
 public:
     explicit IndigoBaseReaction(int type_);
@@ -59,7 +59,7 @@
     indigo::PropertiesMap _properties;
 };
 
-class DLLEXPORT IndigoReaction : public IndigoBaseReaction
+class INDIGO_EXPORT IndigoReaction : public IndigoBaseReaction
 {
 public:
     IndigoReaction();
@@ -99,7 +99,7 @@
     std::unique_ptr<BaseReaction> rxn;
 };
 
-class DLLEXPORT IndigoQueryReaction : public IndigoBaseReaction
+class INDIGO_EXPORT IndigoQueryReaction : public IndigoBaseReaction
 {
 public:
     IndigoQueryReaction();
Index: cppcoro-src/cppcoro/lib/read_write_file.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/read_write_file.cpp b/cppcoro-src/cppcoro/lib/read_write_file.cpp
--- a/cppcoro-src/cppcoro/lib/read_write_file.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/read_write_file.cpp	(date 1745583016148)
@@ -3,17 +3,17 @@
 // Licenced under MIT license. See LICENSE.txt for details.
 ///////////////////////////////////////////////////////////////////////////////
 
-#include <cppcoro\read_write_file.hpp>
+#include <cppcoro/read_write_file.hpp>
 
 #if CPPCORO_OS_WINNT
 # ifndef WIN32_LEAN_AND_MEAN
 #  define WIN32_LEAN_AND_MEAN
 # endif
-# include <Windows.h>
+# include <windows.h>
 
 cppcoro::read_write_file cppcoro::read_write_file::open(
 	io_service& ioService,
-	const std::experimental::filesystem::path& path,
+	const std::filesystem::path& path,
 	file_open_mode openMode,
 	file_share_mode shareMode,
 	file_buffering_mode bufferingMode)
Index: indigo-src/indigo/api/c/indigo/src/indigo_array.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_array.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_array.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_array.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_array.cpp	(date 1745583015898)
@@ -139,7 +139,7 @@
     return _idx + 1 < _arr->objects.size();
 }
 
-CEXPORT int indigoCreateArray()
+int indigoCreateArray()
 {
     INDIGO_BEGIN
     {
@@ -148,7 +148,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoArrayAdd(int arr, int handle)
+int indigoArrayAdd(int arr, int handle)
 {
     INDIGO_BEGIN
     {
@@ -163,7 +163,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateArray(int arr)
+int indigoIterateArray(int arr)
 {
     INDIGO_BEGIN
     {
Index: cppcoro-src/cppcoro/lib/async_auto_reset_event.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/async_auto_reset_event.cpp b/cppcoro-src/cppcoro/lib/async_auto_reset_event.cpp
--- a/cppcoro-src/cppcoro/lib/async_auto_reset_event.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/async_auto_reset_event.cpp	(date 1745583016148)
@@ -241,7 +241,7 @@
 {}
 
 bool cppcoro::async_auto_reset_event_operation::await_suspend(
-	std::experimental::coroutine_handle<> awaiter) noexcept
+	std::coroutine_handle<> awaiter) noexcept
 {
 	m_awaiter = awaiter;
 
Index: indigo-src/indigo/api/c/indigo/src/indigo_molecule.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_molecule.h b/indigo-src/indigo/api/c/indigo/src/indigo_molecule.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_molecule.h	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_molecule.h	(date 1745583015992)
@@ -33,7 +33,7 @@
 #include "molecule/molecule_neighbourhood_counters.h"
 #include "molecule/query_molecule.h"
 
-class DLLEXPORT IndigoBaseMolecule : public IndigoObject
+class INDIGO_EXPORT IndigoBaseMolecule : public IndigoObject
 {
 public:
     explicit IndigoBaseMolecule(int type_);
@@ -52,7 +52,7 @@
     indigo::PropertiesMap _properties;
 };
 
-class DLLEXPORT IndigoQueryMolecule : public IndigoBaseMolecule
+class INDIGO_EXPORT IndigoQueryMolecule : public IndigoBaseMolecule
 {
 public:
     IndigoQueryMolecule();
@@ -80,7 +80,7 @@
     int _nei_counters_edit_revision;
 };
 
-class DLLEXPORT IndigoMolecule : public IndigoBaseMolecule
+class INDIGO_EXPORT IndigoMolecule : public IndigoBaseMolecule
 {
 public:
     IndigoMolecule();
@@ -104,7 +104,7 @@
     Molecule mol;
 };
 
-class DLLEXPORT IndigoAtom : public IndigoObject
+class INDIGO_EXPORT IndigoAtom : public IndigoObject
 {
 public:
     IndigoAtom(BaseMolecule& mol_, int idx_);
@@ -124,7 +124,7 @@
     const char* debugInfo() const override;
 };
 
-class DLLEXPORT IndigoRGroup : public IndigoObject
+class INDIGO_EXPORT IndigoRGroup : public IndigoObject
 {
 public:
     IndigoRGroup();
@@ -138,7 +138,7 @@
     int idx;
 };
 
-class DLLEXPORT IndigoRGroupFragment : public IndigoObject
+class INDIGO_EXPORT IndigoRGroupFragment : public IndigoObject
 {
 public:
     IndigoRGroupFragment(IndigoRGroup& rgp, int idx);
@@ -158,7 +158,7 @@
     int frag_idx;
 };
 
-class DLLEXPORT IndigoBond : public IndigoObject
+class INDIGO_EXPORT IndigoBond : public IndigoObject
 {
 public:
     IndigoBond(BaseMolecule& mol_, int idx_);
Index: cppcoro-src/cppcoro/lib/read_only_file.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/read_only_file.cpp b/cppcoro-src/cppcoro/lib/read_only_file.cpp
--- a/cppcoro-src/cppcoro/lib/read_only_file.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/read_only_file.cpp	(date 1745583016179)
@@ -3,17 +3,17 @@
 // Licenced under MIT license. See LICENSE.txt for details.
 ///////////////////////////////////////////////////////////////////////////////
 
-#include <cppcoro\read_only_file.hpp>
+#include <cppcoro/read_only_file.hpp>
 
 #if CPPCORO_OS_WINNT
 # ifndef WIN32_LEAN_AND_MEAN
 #  define WIN32_LEAN_AND_MEAN
 # endif
-# include <Windows.h>
+# include <windows.h>
 
 cppcoro::read_only_file cppcoro::read_only_file::open(
 	io_service& ioService,
-	const std::experimental::filesystem::path& path,
+	const std::filesystem::path& path,
 	file_share_mode shareMode,
 	file_buffering_mode bufferingMode)
 {
Index: openbabel-src/openbabel/src/RDKitConv.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/RDKitConv.cpp b/openbabel-src/openbabel/src/RDKitConv.cpp
--- a/openbabel-src/openbabel/src/RDKitConv.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/RDKitConv.cpp	(date 1745583016008)
@@ -23,6 +23,9 @@
 ***********************************************************************/
 
 #include <openbabel/babelconfig.h>
+#include <openbabel/oberror.h>
+#include <openbabel/bond.h>
+#include <openbabel/bondtyper.h>
 #include <RDKitConv.h>
 
 using OpenBabel::OBMolAtomIter;
@@ -45,7 +48,7 @@
   {
     //bond order >3 needs doing properly
     //assume RDKit atom indices start at 0
-    RDMol.addBond(b->GetBeginAtomIdx()-1, b->GetEndAtomIdx()-1, (RDKit::Bond::BondType)b->GetBO());
+    RDMol.addBond(b->GetBeginAtomIdx()-1, b->GetEndAtomIdx()-1, (RDKit::Bond::BondType)b->GetBondOrder());
   }
   std::string msg("RWMol made from ");
   if(pOBMol->GetTitle())
Index: cppcoro-src/cppcoro/lib/write_only_file.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/write_only_file.cpp b/cppcoro-src/cppcoro/lib/write_only_file.cpp
--- a/cppcoro-src/cppcoro/lib/write_only_file.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/write_only_file.cpp	(date 1745583016148)
@@ -3,17 +3,17 @@
 // Licenced under MIT license. See LICENSE.txt for details.
 ///////////////////////////////////////////////////////////////////////////////
 
-#include <cppcoro\write_only_file.hpp>
+#include <cppcoro/write_only_file.hpp>
 
 #if CPPCORO_OS_WINNT
 # ifndef WIN32_LEAN_AND_MEAN
 #  define WIN32_LEAN_AND_MEAN
 # endif
-# include <Windows.h>
+# include <windows.h>
 
 cppcoro::write_only_file cppcoro::write_only_file::open(
 	io_service& ioService,
-	const std::experimental::filesystem::path& path,
+	const std::filesystem::path& path,
 	file_open_mode openMode,
 	file_share_mode shareMode,
 	file_buffering_mode bufferingMode)
Index: indigo-src/indigo/api/c/indigo/src/indigo_savers.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_savers.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_savers.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_savers.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_savers.cpp	(date 1745583015945)
@@ -153,7 +153,7 @@
     append(_output, object);
 }
 
-CEXPORT int indigoSdfAppend(int output, int molecule)
+int indigoSdfAppend(int output, int molecule)
 {
     INDIGO_BEGIN
     {
@@ -286,7 +286,7 @@
     append(_output, object);
 }
 
-CEXPORT int indigoSmilesAppend(int output, int item)
+int indigoSmilesAppend(int output, int item)
 {
     INDIGO_BEGIN
     {
@@ -431,7 +431,7 @@
     appendFooter(_output);
 }
 
-CEXPORT int indigoCmlHeader(int output)
+int indigoCmlHeader(int output)
 {
     INDIGO_BEGIN
     {
@@ -442,7 +442,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCmlFooter(int output)
+int indigoCmlFooter(int output)
 {
     INDIGO_BEGIN
     {
@@ -453,7 +453,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCmlAppend(int output, int item)
+int indigoCmlAppend(int output, int item)
 {
     INDIGO_BEGIN
     {
@@ -532,7 +532,7 @@
     appendHeader(_output);
 }
 
-CEXPORT int indigoRdfHeader(int output)
+int indigoRdfHeader(int output)
 {
     INDIGO_BEGIN
     {
@@ -543,7 +543,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRdfAppend(int output, int item)
+int indigoRdfAppend(int output, int item)
 {
     INDIGO_BEGIN
     {
@@ -558,7 +558,7 @@
 //
 // Saving functions
 //
-CEXPORT int indigoCreateSaver(int output, const char* format)
+int indigoCreateSaver(int output, const char* format)
 {
     INDIGO_BEGIN
     {
@@ -568,7 +568,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateFileSaver(const char* filename, const char* format)
+int indigoCreateFileSaver(const char* filename, const char* format)
 {
     INDIGO_BEGIN
     {
@@ -580,7 +580,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveMolfile(int molecule, int output)
+int indigoSaveMolfile(int molecule, int output)
 {
     INDIGO_BEGIN
     {
@@ -724,7 +724,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveJson(int item, int output)
+int indigoSaveJson(int item, int output)
 {
     INDIGO_BEGIN
     {
@@ -773,7 +773,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveCml(int item, int output)
+int indigoSaveCml(int item, int output)
 {
     INDIGO_BEGIN
     {
@@ -805,7 +805,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveMDLCT(int item, int output)
+int indigoSaveMDLCT(int item, int output)
 {
     INDIGO_BEGIN
     {
@@ -833,7 +833,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveRxnfile(int reaction, int output)
+int indigoSaveRxnfile(int reaction, int output)
 {
     INDIGO_BEGIN
     {
@@ -851,7 +851,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAppend(int saver_id, int object)
+int indigoAppend(int saver_id, int object)
 {
     INDIGO_BEGIN
     {
@@ -866,7 +866,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveCdxml(int item, int output)
+int indigoSaveCdxml(int item, int output)
 {
     INDIGO_BEGIN
     {
@@ -916,7 +916,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveCdx(int item, int output)
+int indigoSaveCdx(int item, int output)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_scaffold.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_scaffold.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_scaffold.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_scaffold.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_scaffold.cpp	(date 1745583015945)
@@ -31,7 +31,7 @@
 {
 }
 
-CEXPORT int indigoExtractCommonScaffold(int structures, const char* options)
+int indigoExtractCommonScaffold(int structures, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -104,7 +104,7 @@
     return max_scaffold;
 }
 
-CEXPORT int indigoAllScaffolds(int extracted)
+int indigoAllScaffolds(int extracted)
 {
     INDIGO_BEGIN
     {
Index: cppcoro-src/cppcoro/lib/socket_send_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_send_operation.cpp b/cppcoro-src/cppcoro/lib/socket_send_operation.cpp
--- a/cppcoro-src/cppcoro/lib/socket_send_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_send_operation.cpp	(date 1745583016179)
@@ -7,10 +7,10 @@
 #include <cppcoro/net/socket.hpp>
 
 #if CPPCORO_OS_WINNT
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 
 bool cppcoro::net::socket_send_operation_impl::try_start(
 	cppcoro::detail::win32_overlapped_operation_base& operation) noexcept
Index: indigo-src/indigo/api/c/indigo/src/option_manager.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/option_manager.cpp b/indigo-src/indigo/api/c/indigo/src/option_manager.cpp
--- a/indigo-src/indigo/api/c/indigo/src/option_manager.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/option_manager.cpp	(date 1745583015898)
@@ -29,7 +29,7 @@
     return mgr;
 }
 
-DLLEXPORT sf::safe_shared_hide_obj<IndigoOptionManager>& indigoGetOptionManager(const qword id)
+sf::safe_shared_hide_obj<IndigoOptionManager>& indigoGetOptionManager(const qword id)
 {
     return IndigoOptionManager::getIndigoOptionManager().getLocalCopy(id);
 }
Index: indigo-src/indigo/api/c/indigo/src/indigo_internal.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_internal.h b/indigo-src/indigo/api/c/indigo/src/indigo_internal.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_internal.h	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_internal.h	(date 1745583015929)
@@ -73,9 +73,7 @@
     typedef ObjArray<PropertiesMap> MonomersProperties;
 } // namespace indigo
 
-extern DLLEXPORT sf::safe_shared_hide_obj<IndigoOptionManager>& indigoGetOptionManager(const qword id = TL_GET_SESSION_ID());
-
-class DLLEXPORT IndigoObject
+class INDIGO_EXPORT IndigoObject
 {
 public:
     explicit IndigoObject(int type_);
@@ -240,7 +238,7 @@
     std::unique_ptr<std::pair<PtrArray<GROSS_UNITS>, PtrArray<GROSS_UNITS>>> gross;
 };
 
-struct DLLEXPORT ProductEnumeratorParams
+struct INDIGO_EXPORT ProductEnumeratorParams
 {
     ProductEnumeratorParams()
     {
@@ -267,7 +265,7 @@
     int max_product_count;
 };
 
-class DLLEXPORT Indigo
+class INDIGO_EXPORT Indigo
 {
 public:
     Indigo();
@@ -394,7 +392,7 @@
     std::unique_ptr<abbreviations::IndigoAbbreviations> _abbreviations = nullptr;
 };
 
-class DLLEXPORT IndigoPluginContext
+class INDIGO_EXPORT IndigoPluginContext
 {
 public:
     IndigoPluginContext();
@@ -433,10 +431,10 @@
     return fail;                                                                                                                                               \
     }
 
-DLLEXPORT Indigo& indigoGetInstance();
-DLLEXPORT _SessionLocalContainer<Indigo>& indigoSelf();
+INDIGO_EXPORT Indigo& indigoGetInstance();
+INDIGO_EXPORT _SessionLocalContainer<Indigo>& indigoSelf();
 
-class DLLEXPORT IndigoError : public Exception
+class INDIGO_EXPORT IndigoError : public Exception
 {
 public:
     explicit IndigoError(const char* format, ...);
Index: fluentui-src/fluentui/src/FluentIconDef.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/FluentIconDef.cpp b/fluentui-src/fluentui/src/FluentIconDef.cpp
new file mode 100644
--- /dev/null	(date 1745662832946)
+++ b/fluentui-src/fluentui/src/FluentIconDef.cpp	(date 1745662832946)
@@ -0,0 +1,1 @@
+#include "FluentIconDef.h"
Index: cppcoro-src/cppcoro/lib/win32.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/win32.cpp b/cppcoro-src/cppcoro/lib/win32.cpp
--- a/cppcoro-src/cppcoro/lib/win32.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/win32.cpp	(date 1745583016148)
@@ -8,7 +8,7 @@
 #ifndef WIN32_LEAN_AND_MEAN
 # define WIN32_LEAN_AND_MEAN
 #endif
-#include <Windows.h>
+#include <windows.h>
 
 void cppcoro::detail::win32::safe_handle::close() noexcept
 {
Index: indigo-src/indigo/api/c/indigo/src/indigo_array.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_array.h b/indigo-src/indigo/api/c/indigo/src/indigo_array.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_array.h	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_array.h	(date 1745583015961)
@@ -26,7 +26,7 @@
 #pragma warning(disable : 4251)
 #endif
 
-class DLLEXPORT IndigoArray : public IndigoObject
+class INDIGO_EXPORT IndigoArray : public IndigoObject
 {
 public:
     IndigoArray();
@@ -41,7 +41,7 @@
     PtrArray<IndigoObject> objects;
 };
 
-class DLLEXPORT IndigoArrayElement : public IndigoObject
+class INDIGO_EXPORT IndigoArrayElement : public IndigoObject
 {
 public:
     IndigoArrayElement(IndigoArray& arr, int idx_);
Index: fluentui-src/fluentui/src/Def.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/Def.cpp b/fluentui-src/fluentui/src/Def.cpp
new file mode 100644
--- /dev/null	(date 1745662832946)
+++ b/fluentui-src/fluentui/src/Def.cpp	(date 1745662832946)
@@ -0,0 +1,1 @@
+#include "Def.h"
Index: indigo-src/indigo/api/c/indigo/src/indigo_abbreviations_expand.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_abbreviations_expand.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_abbreviations_expand.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_abbreviations_expand.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_abbreviations_expand.cpp	(date 1745583015898)
@@ -769,7 +769,7 @@
         //
         // Interface functions
         //
-        CEXPORT int indigoExpandAbbreviations(int molecule)
+        int indigoExpandAbbreviations(int molecule)
         {
             INDIGO_BEGIN
             {
Index: indigo-src/indigo/api/c/indigo/src/indigo_molecule.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_molecule.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_molecule.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_molecule.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_molecule.cpp	(date 1745583015961)
@@ -481,7 +481,7 @@
     return new IndigoBond(_mol, _idx);
 }
 
-CEXPORT int indigoLoadMolecule(int source)
+int indigoLoadMolecule(int source)
 {
     INDIGO_BEGIN
     {
@@ -512,7 +512,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadQueryMolecule(int source)
+int indigoLoadQueryMolecule(int source)
 {
     INDIGO_BEGIN
     {
@@ -774,7 +774,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadSmarts(int source)
+int indigoLoadSmarts(int source)
 {
     INDIGO_BEGIN
     {
@@ -800,7 +800,7 @@
     return isIn(string, ">>") || startWith(string, "$RXN") || isIn(string, "<reactantList>");
 }
 
-CEXPORT int indigoLoadStructureFromString(const char* string, const char* params)
+int indigoLoadStructureFromString(const char* string, const char* params)
 {
     INDIGO_BEGIN
     {
@@ -853,7 +853,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadStructureFromBuffer(const byte* buff, int bufferSize, const char* params)
+int indigoLoadStructureFromBuffer(const byte* buff, int bufferSize, const char* params)
 {
     BufferScanner scanner(buff, bufferSize);
     Array<char> arr;
@@ -862,7 +862,7 @@
     return indigoLoadStructureFromString(arr.ptr(), params);
 }
 
-CEXPORT int indigoLoadStructureFromFile(const char* filename, const char* params)
+int indigoLoadStructureFromFile(const char* filename, const char* params)
 {
     INDIGO_BEGIN
     {
@@ -990,7 +990,7 @@
     return self.addObject(new IndigoAtomsIter(&self.getObject(molecule).getBaseMolecule(), type));
 }
 
-CEXPORT int indigoIterateAtoms(int molecule)
+int indigoIterateAtoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1037,7 +1037,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateBonds(int molecule)
+int indigoIterateBonds(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1084,7 +1084,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountAtoms(int molecule)
+int indigoCountAtoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1118,7 +1118,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountBonds(int molecule)
+int indigoCountBonds(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1152,7 +1152,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountPseudoatoms(int molecule)
+int indigoCountPseudoatoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1168,7 +1168,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountRSites(int molecule)
+int indigoCountRSites(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1184,7 +1184,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIteratePseudoatoms(int molecule)
+int indigoIteratePseudoatoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1193,7 +1193,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateRSites(int molecule)
+int indigoIterateRSites(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1202,7 +1202,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateStereocenters(int molecule)
+int indigoIterateStereocenters(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1211,7 +1211,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateAlleneCenters(int molecule)
+int indigoIterateAlleneCenters(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1220,7 +1220,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoSymbol(int atom)
+const char* indigoSymbol(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1233,7 +1233,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoIsPseudoatom(int atom)
+int indigoIsPseudoatom(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1246,7 +1246,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIsRSite(int atom)
+int indigoIsRSite(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1259,7 +1259,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIsTemplateAtom(int atom)
+int indigoIsTemplateAtom(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1272,7 +1272,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSingleAllowedRGroup(int rsite)
+int indigoSingleAllowedRGroup(int rsite)
 {
     INDIGO_BEGIN
     {
@@ -1313,7 +1313,7 @@
 {
 }
 
-CEXPORT int indigoIterateRGroups(int molecule)
+int indigoIterateRGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1428,7 +1428,7 @@
     return new IndigoRGroupFragment(_mol, _rgroup_idx, _frag_idx);
 }
 
-CEXPORT int indigoIterateRGroupFragments(int rgroup)
+int indigoIterateRGroupFragments(int rgroup)
 {
     INDIGO_BEGIN
     {
@@ -1438,7 +1438,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountRGroups(int molecule)
+int indigoCountRGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1490,7 +1490,7 @@
     return rgroup.release();
 }
 
-CEXPORT int indigoCountAttachmentPoints(int rgroup)
+int indigoCountAttachmentPoints(int rgroup)
 {
     INDIGO_BEGIN
     {
@@ -1505,7 +1505,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDegree(int atom)
+int indigoDegree(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1516,7 +1516,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetCharge(int atom, int* charge)
+int indigoGetCharge(int atom, int* charge)
 {
     INDIGO_BEGIN
     {
@@ -1533,7 +1533,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoValence(int atom)
+int indigoValence(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1543,7 +1543,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetHybridization(int atom)
+int indigoGetHybridization(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1554,7 +1554,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCheckValence(int atom)
+int indigoCheckValence(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1570,7 +1570,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetExplicitValence(int atom, int* valence)
+int indigoGetExplicitValence(int atom, int* valence)
 {
     INDIGO_BEGIN
     {
@@ -1587,7 +1587,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetExplicitValence(int atom, int valence)
+int indigoSetExplicitValence(int atom, int valence)
 {
     INDIGO_BEGIN
     {
@@ -1598,7 +1598,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIsotope(int atom)
+int indigoIsotope(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1609,7 +1609,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAtomicNumber(int atom)
+int indigoAtomicNumber(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1626,7 +1626,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetRadicalElectrons(int atom, int* electrons)
+int indigoGetRadicalElectrons(int atom, int* electrons)
 {
     INDIGO_BEGIN
     {
@@ -1678,7 +1678,7 @@
     }
 }
 
-CEXPORT int indigoGetRadical(int atom, int* radical)
+int indigoGetRadical(int atom, int* radical)
 {
     INDIGO_BEGIN
     {
@@ -1696,7 +1696,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetRadical(int atom, int radical)
+int indigoSetRadical(int atom, int radical)
 {
     INDIGO_BEGIN
     {
@@ -1707,7 +1707,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT float* indigoXYZ(int atom)
+float* indigoXYZ(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1724,7 +1724,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoSetXYZ(int atom, float x, float y, float z)
+int indigoSetXYZ(int atom, float x, float y, float z)
 {
     INDIGO_BEGIN
     {
@@ -1738,7 +1738,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoResetCharge(int atom)
+int indigoResetCharge(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1754,7 +1754,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetExplicitValence(int atom)
+int indigoResetExplicitValence(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1770,7 +1770,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetRadical(int atom)
+int indigoResetRadical(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1786,7 +1786,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetIsotope(int atom)
+int indigoResetIsotope(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1802,7 +1802,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetRsite(int atom)
+int indigoResetRsite(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1815,7 +1815,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetAttachmentPoint(int atom, int order)
+int indigoSetAttachmentPoint(int atom, int order)
 {
     INDIGO_BEGIN
     {
@@ -1827,7 +1827,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearAttachmentPoints(int item)
+int indigoClearAttachmentPoints(int item)
 {
     INDIGO_BEGIN
     {
@@ -1838,7 +1838,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRemoveConstraints(int item, const char* str_type)
+int indigoRemoveConstraints(int item, const char* str_type)
 {
     INDIGO_BEGIN
     {
@@ -1862,7 +1862,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddConstraint(int atom, const char* type, const char* value)
+int indigoAddConstraint(int atom, const char* type, const char* value)
 {
     INDIGO_BEGIN
     {
@@ -1881,7 +1881,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddConstraintNot(int atom, const char* type, const char* value)
+int indigoAddConstraintNot(int atom, const char* type, const char* value)
 {
     INDIGO_BEGIN
     {
@@ -1900,7 +1900,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddConstraintOr(int atom, const char* type, const char* value)
+int indigoAddConstraintOr(int atom, const char* type, const char* value)
 {
     INDIGO_BEGIN
     {
@@ -1920,7 +1920,7 @@
 }
 
 /*
-CEXPORT int indigoAddConstraintOrNot(int atom, const char* type, const char* value)
+int indigoAddConstraintOrNot(int atom, const char* type, const char* value)
 {
    INDIGO_BEGIN
    {
@@ -1940,7 +1940,7 @@
 }
  * */
 
-CEXPORT const int* indigoSymmetryClasses(int molecule, int* count_out)
+const int* indigoSymmetryClasses(int molecule, int* count_out)
 {
     INDIGO_BEGIN
     {
@@ -1978,7 +1978,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoLayeredCode(int molecule)
+const char* indigoLayeredCode(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1996,7 +1996,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoCreateSubmolecule(int molecule, int nvertices, int* vertices)
+int indigoCreateSubmolecule(int molecule, int nvertices, int* vertices)
 {
     INDIGO_BEGIN
     {
@@ -2024,7 +2024,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSubmolecule(int molecule, int nvertices, int* vertices)
+int indigoGetSubmolecule(int molecule, int nvertices, int* vertices)
 {
     INDIGO_BEGIN
     {
@@ -2053,7 +2053,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateEdgeSubmolecule(int molecule, int nvertices, int* vertices, int nedges, int* edges)
+int indigoCreateEdgeSubmolecule(int molecule, int nvertices, int* vertices, int nedges, int* edges)
 {
     INDIGO_BEGIN
     {
@@ -2083,7 +2083,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRemoveAtoms(int molecule, int nvertices, int* vertices)
+int indigoRemoveAtoms(int molecule, int nvertices, int* vertices)
 {
     INDIGO_BEGIN
     {
@@ -2098,7 +2098,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRemoveBonds(int molecule, int nbonds, int* bonds)
+int indigoRemoveBonds(int molecule, int nbonds, int* bonds)
 {
     INDIGO_BEGIN
     {
@@ -2146,7 +2146,7 @@
     return _nei_counters;
 }
 
-CEXPORT int indigoIsChiral(int molecule)
+int indigoIsChiral(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2156,7 +2156,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoBondOrder(int bond)
+int indigoBondOrder(int bond)
 {
     INDIGO_BEGIN
     {
@@ -2168,7 +2168,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoTopology(int bond)
+int indigoTopology(int bond)
 {
     INDIGO_BEGIN
     {
@@ -2184,7 +2184,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetAtom(int molecule, int idx)
+int indigoGetAtom(int molecule, int idx)
 {
     INDIGO_BEGIN
     {
@@ -2195,7 +2195,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetBond(int molecule, int idx)
+int indigoGetBond(int molecule, int idx)
 {
     INDIGO_BEGIN
     {
@@ -2206,7 +2206,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSource(int bond)
+int indigoSource(int bond)
 {
     INDIGO_BEGIN
     {
@@ -2216,7 +2216,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDestination(int bond)
+int indigoDestination(int bond)
 {
     INDIGO_BEGIN
     {
@@ -2275,7 +2275,7 @@
     return vertex.neiNext(_nei_idx) != vertex.neiEnd();
 }
 
-CEXPORT int indigoIterateNeighbors(int atom)
+int indigoIterateNeighbors(int atom)
 {
     INDIGO_BEGIN
     {
@@ -2286,7 +2286,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoBond(int nei)
+int indigoBond(int nei)
 {
     INDIGO_BEGIN
     {
@@ -2302,7 +2302,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT float indigoAlignAtoms(int molecule, int natoms, int* atom_ids, float* desired_xyz)
+float indigoAlignAtoms(int molecule, int natoms, int* atom_ids, float* desired_xyz)
 {
     INDIGO_BEGIN
     {
@@ -2353,7 +2353,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountSuperatoms(int molecule)
+int indigoCountSuperatoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2363,7 +2363,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountDataSGroups(int molecule)
+int indigoCountDataSGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2373,7 +2373,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountRepeatingUnits(int molecule)
+int indigoCountRepeatingUnits(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2383,7 +2383,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountMultipleGroups(int molecule)
+int indigoCountMultipleGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2393,7 +2393,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountGenericSGroups(int molecule)
+int indigoCountGenericSGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2434,7 +2434,7 @@
     return sgroup.release();
 }
 
-CEXPORT int indigoIterateDataSGroups(int molecule)
+int indigoIterateDataSGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2735,7 +2735,7 @@
     return sgroup.release();
 }
 
-CEXPORT int indigoIterateGenericSGroups(int molecule)
+int indigoIterateGenericSGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2821,7 +2821,7 @@
     return sgroup.release();
 }
 
-CEXPORT int indigoIterateSGroups(int molecule)
+int indigoIterateSGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2909,7 +2909,7 @@
     return tgroup.release();
 }
 
-CEXPORT int indigoIterateTGroups(int molecule)
+int indigoIterateTGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2919,7 +2919,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateRepeatingUnits(int molecule)
+int indigoIterateRepeatingUnits(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2932,7 +2932,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateMultipleGroups(int molecule)
+int indigoIterateMultipleGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2945,7 +2945,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateSuperatoms(int molecule)
+int indigoIterateSuperatoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2958,7 +2958,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSuperatom(int molecule, int index)
+int indigoGetSuperatom(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -2975,7 +2975,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetDataSGroup(int molecule, int index)
+int indigoGetDataSGroup(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -2992,7 +2992,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetGenericSGroup(int molecule, int index)
+int indigoGetGenericSGroup(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -3009,7 +3009,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetMultipleGroup(int molecule, int index)
+int indigoGetMultipleGroup(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -3026,7 +3026,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetRepeatingUnit(int molecule, int index)
+int indigoGetRepeatingUnit(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -3043,7 +3043,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoDescription(int data_sgroup)
+const char* indigoDescription(int data_sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3055,7 +3055,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoData(int data_sgroup)
+const char* indigoData(int data_sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3067,7 +3067,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoAddDataSGroup(int molecule, int natoms, int* atoms, int nbonds, int* bonds, const char* name, const char* data)
+int indigoAddDataSGroup(int molecule, int natoms, int* atoms, int nbonds, int* bonds, const char* name, const char* data)
 {
     INDIGO_BEGIN
     {
@@ -3090,7 +3090,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddSuperatom(int molecule, int natoms, int* atoms, const char* name)
+int indigoAddSuperatom(int molecule, int natoms, int* atoms, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -3109,7 +3109,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetDataSGroupXY(int sgroup, float x, float y, const char* options)
+int indigoSetDataSGroupXY(int sgroup, float x, float y, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -3134,7 +3134,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupData(int sgroup, const char* data)
+int indigoSetSGroupData(int sgroup, const char* data)
 {
     INDIGO_BEGIN
     {
@@ -3148,7 +3148,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupCoords(int sgroup, float x, float y)
+int indigoSetSGroupCoords(int sgroup, float x, float y)
 {
     INDIGO_BEGIN
     {
@@ -3162,7 +3162,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupDescription(int sgroup, const char* description)
+int indigoSetSGroupDescription(int sgroup, const char* description)
 {
     INDIGO_BEGIN
     {
@@ -3176,7 +3176,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupFieldName(int sgroup, const char* name)
+int indigoSetSGroupFieldName(int sgroup, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -3190,7 +3190,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupQueryCode(int sgroup, const char* querycode)
+int indigoSetSGroupQueryCode(int sgroup, const char* querycode)
 {
     INDIGO_BEGIN
     {
@@ -3204,7 +3204,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupQueryOper(int sgroup, const char* queryoper)
+int indigoSetSGroupQueryOper(int sgroup, const char* queryoper)
 {
     INDIGO_BEGIN
     {
@@ -3218,7 +3218,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupDisplay(int sgroup, const char* option)
+int indigoSetSGroupDisplay(int sgroup, const char* option)
 {
     INDIGO_BEGIN
     {
@@ -3239,7 +3239,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupLocation(int sgroup, const char* option)
+int indigoSetSGroupLocation(int sgroup, const char* option)
 {
     INDIGO_BEGIN
     {
@@ -3260,7 +3260,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupTag(int sgroup, const char* tag)
+int indigoSetSGroupTag(int sgroup, const char* tag)
 {
     INDIGO_BEGIN
     {
@@ -3276,7 +3276,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupTagAlign(int sgroup, int tag_align)
+int indigoSetSGroupTagAlign(int sgroup, int tag_align)
 {
     INDIGO_BEGIN
     {
@@ -3292,7 +3292,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupDataType(int sgroup, const char* data_type)
+int indigoSetSGroupDataType(int sgroup, const char* data_type)
 {
     INDIGO_BEGIN
     {
@@ -3308,7 +3308,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupXCoord(int sgroup, float x)
+int indigoSetSGroupXCoord(int sgroup, float x)
 {
     INDIGO_BEGIN
     {
@@ -3321,7 +3321,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupYCoord(int sgroup, float y)
+int indigoSetSGroupYCoord(int sgroup, float y)
 {
     INDIGO_BEGIN
     {
@@ -3334,7 +3334,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateSGroup(const char* type, int mapping, const char* name)
+int indigoCreateSGroup(const char* type, int mapping, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -3391,7 +3391,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupClass(int sgroup, const char* sgclass)
+int indigoSetSGroupClass(int sgroup, const char* sgclass)
 {
     INDIGO_BEGIN
     {
@@ -3403,7 +3403,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetSGroupClass(int sgroup)
+const char* indigoGetSGroupClass(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3415,7 +3415,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoSetSGroupName(int sgroup, const char* sgname)
+int indigoSetSGroupName(int sgroup, const char* sgname)
 {
     INDIGO_BEGIN
     {
@@ -3427,7 +3427,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetSGroupName(int sgroup)
+const char* indigoGetSGroupName(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3439,7 +3439,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoGetSGroupNumCrossBonds(int sgroup)
+int indigoGetSGroupNumCrossBonds(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3449,7 +3449,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddSGroupAttachmentPoint(int sgroup, int aidx, int lvidx, const char* apid)
+int indigoAddSGroupAttachmentPoint(int sgroup, int aidx, int lvidx, const char* apid)
 {
     INDIGO_BEGIN
     {
@@ -3464,7 +3464,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDeleteSGroupAttachmentPoint(int sgroup, int ap_idx)
+int indigoDeleteSGroupAttachmentPoint(int sgroup, int ap_idx)
 {
     INDIGO_BEGIN
     {
@@ -3475,7 +3475,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSGroupDisplayOption(int sgroup)
+int indigoGetSGroupDisplayOption(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3488,7 +3488,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupDisplayOption(int sgroup, int option)
+int indigoSetSGroupDisplayOption(int sgroup, int option)
 {
     INDIGO_BEGIN
     {
@@ -3500,7 +3500,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSGroupSeqId(int sgroup)
+int indigoGetSGroupSeqId(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3512,7 +3512,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT float* indigoGetSGroupCoords(int sgroup)
+float* indigoGetSGroupCoords(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3528,7 +3528,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoGetSGroupMultiplier(int sgroup)
+int indigoGetSGroupMultiplier(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3538,7 +3538,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetRepeatingUnitSubscript(int sgroup)
+const char* indigoGetRepeatingUnitSubscript(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3548,7 +3548,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoGetRepeatingUnitConnectivity(int sgroup)
+int indigoGetRepeatingUnitConnectivity(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3558,7 +3558,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupMultiplier(int sgroup, int multiplier)
+int indigoSetSGroupMultiplier(int sgroup, int multiplier)
 {
     INDIGO_BEGIN
     {
@@ -3570,7 +3570,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupBrackets(int sgroup, int brk_style, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4)
+int indigoSetSGroupBrackets(int sgroup, int brk_style, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4)
 {
     INDIGO_BEGIN
     {
@@ -3599,7 +3599,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoFindSGroups(int item, const char* property, const char* value)
+int indigoFindSGroups(int item, const char* property, const char* value)
 {
     INDIGO_BEGIN
     {
@@ -3614,7 +3614,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSGroupType(int sgroup)
+int indigoGetSGroupType(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3624,7 +3624,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSGroupIndex(int sgroup)
+int indigoGetSGroupIndex(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3634,7 +3634,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSGroupOriginalId(int sgroup)
+int indigoGetSGroupOriginalId(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3644,7 +3644,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupOriginalId(int sgroup, int new_original)
+int indigoSetSGroupOriginalId(int sgroup, int new_original)
 {
     INDIGO_BEGIN
     {
@@ -3674,7 +3674,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSGroupParentId(int sgroup)
+int indigoGetSGroupParentId(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3684,7 +3684,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupParentId(int sgroup, int parent)
+int indigoSetSGroupParentId(int sgroup, int parent)
 {
     INDIGO_BEGIN
     {
@@ -3707,7 +3707,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddTemplate(int molecule, int templates, const char* tname)
+int indigoAddTemplate(int molecule, int templates, const char* tname)
 {
     INDIGO_BEGIN
     {
@@ -3725,7 +3725,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRemoveTemplate(int molecule, const char* tname)
+int indigoRemoveTemplate(int molecule, const char* tname)
 {
     INDIGO_BEGIN
     {
@@ -3740,7 +3740,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoFindTemplate(int molecule, const char* tname)
+int indigoFindTemplate(int molecule, const char* tname)
 {
     INDIGO_BEGIN
     {
@@ -3755,7 +3755,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetTGroupClass(int tgroup)
+const char* indigoGetTGroupClass(int tgroup)
 {
     INDIGO_BEGIN
     {
@@ -3767,7 +3767,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoGetTGroupName(int tgroup)
+const char* indigoGetTGroupName(int tgroup)
 {
     INDIGO_BEGIN
     {
@@ -3779,7 +3779,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoGetTGroupAlias(int tgroup)
+const char* indigoGetTGroupAlias(int tgroup)
 {
     INDIGO_BEGIN
     {
@@ -3791,7 +3791,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoTransformSCSRtoCTAB(int molecule)
+int indigoTransformSCSRtoCTAB(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -3804,7 +3804,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoTransformCTABtoSCSR(int molecule, int templates)
+int indigoTransformCTABtoSCSR(int molecule, int templates)
 {
     INDIGO_BEGIN
     {
@@ -3826,7 +3826,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountHeavyAtoms(int molecule)
+int indigoCountHeavyAtoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -3842,7 +3842,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountComponents(int molecule)
+int indigoCountComponents(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -3853,7 +3853,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCloneComponent(int molecule, int index)
+int indigoCloneComponent(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -3869,7 +3869,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoComponentIndex(int atom)
+int indigoComponentIndex(int atom)
 {
     INDIGO_BEGIN
     {
@@ -3880,7 +3880,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoComponent(int molecule, int index)
+int indigoComponent(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -3987,7 +3987,7 @@
     return idx;
 }
 
-CEXPORT int indigoIterateComponents(int molecule)
+int indigoIterateComponents(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -3998,7 +3998,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateComponentAtoms(int molecule, int index)
+int indigoIterateComponentAtoms(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -4009,7 +4009,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateComponentBonds(int molecule, int index)
+int indigoIterateComponentBonds(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -4020,7 +4020,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountComponentAtoms(int molecule, int index)
+int indigoCountComponentAtoms(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -4031,7 +4031,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountComponentBonds(int molecule, int index)
+int indigoCountComponentBonds(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -4042,7 +4042,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateMolecule()
+int indigoCreateMolecule()
 {
     INDIGO_BEGIN
     {
@@ -4052,7 +4052,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateQueryMolecule()
+int indigoCreateQueryMolecule()
 {
     INDIGO_BEGIN
     {
@@ -4061,7 +4061,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoMerge(int where, int what)
+int indigoMerge(int where, int what)
 {
     INDIGO_BEGIN
     {
@@ -4077,7 +4077,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddAtom(int molecule, const char* symbol)
+int indigoAddAtom(int molecule, const char* symbol)
 {
     INDIGO_BEGIN
     {
@@ -4109,7 +4109,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetAtom(int atom, const char* symbol)
+int indigoResetAtom(int atom, const char* symbol)
 {
     INDIGO_BEGIN
     {
@@ -4147,7 +4147,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetTemplateAtomClass(int atom)
+const char* indigoGetTemplateAtomClass(int atom)
 {
     INDIGO_BEGIN
     {
@@ -4168,7 +4168,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoSetTemplateAtomClass(int atom, const char* name)
+int indigoSetTemplateAtomClass(int atom, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -4224,7 +4224,7 @@
         mol.allowRGroupOnRSite(atom_index, rsites[i]);
 }
 
-CEXPORT int indigoAddRSite(int molecule, const char* name)
+int indigoAddRSite(int molecule, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -4247,7 +4247,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetRSite(int atom, const char* name)
+int indigoSetRSite(int atom, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -4261,7 +4261,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetCharge(int atom, int charge)
+int indigoSetCharge(int atom, int charge)
 {
     INDIGO_BEGIN
     {
@@ -4273,7 +4273,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetIsotope(int atom, int isotope)
+int indigoSetIsotope(int atom, int isotope)
 {
     INDIGO_BEGIN
     {
@@ -4285,7 +4285,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetImplicitHCount(int atom, int impl_h)
+int indigoSetImplicitHCount(int atom, int impl_h)
 {
     INDIGO_BEGIN
     {
@@ -4297,7 +4297,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddBond(int source, int destination, int order)
+int indigoAddBond(int source, int destination, int order)
 {
     INDIGO_BEGIN
     {
@@ -4318,7 +4318,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetBondOrder(int bond, int order)
+int indigoSetBondOrder(int bond, int order)
 {
     INDIGO_BEGIN
     {
@@ -4457,7 +4457,7 @@
     return new IndigoBond(_submol.getOriginalMolecule(), _submol.edges[_idx]);
 }
 
-CEXPORT int indigoCountSSSR(int molecule)
+int indigoCountSSSR(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -4468,7 +4468,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateSSSR(int molecule)
+int indigoIterateSSSR(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -4547,7 +4547,7 @@
     return res.release();
 }
 
-CEXPORT int indigoIterateSubtrees(int molecule, int min_atoms, int max_atoms)
+int indigoIterateSubtrees(int molecule, int min_atoms, int max_atoms)
 {
     INDIGO_BEGIN
     {
@@ -4597,7 +4597,7 @@
     return res.release();
 }
 
-CEXPORT int indigoIterateRings(int molecule, int min_atoms, int max_atoms)
+int indigoIterateRings(int molecule, int min_atoms, int max_atoms)
 {
     INDIGO_BEGIN
     {
@@ -4650,7 +4650,7 @@
     return res.release();
 }
 
-CEXPORT int indigoIterateEdgeSubmolecules(int molecule, int min_bonds, int max_bonds)
+int indigoIterateEdgeSubmolecules(int molecule, int min_bonds, int max_bonds)
 {
     INDIGO_BEGIN
     {
@@ -4661,7 +4661,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountHydrogens(int item, int* hydro)
+int indigoCountHydrogens(int item, int* hydro)
 {
     INDIGO_BEGIN
     {
@@ -4699,7 +4699,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountImplicitHydrogens(int item)
+int indigoCountImplicitHydrogens(int item)
 {
     INDIGO_BEGIN
     {
@@ -4752,7 +4752,7 @@
     return _mol.getAttachmentPoint(_order, _index + 1) != -1;
 }
 
-CEXPORT int indigoIterateAttachmentPoints(int molecule, int order)
+int indigoIterateAttachmentPoints(int molecule, int order)
 {
     INDIGO_BEGIN
     {
@@ -4770,7 +4770,7 @@
 name - a name to parse
 params - a string containing parsing options or nullptr if no options are changed
 */
-CEXPORT int indigoNameToStructure(const char* name, const char* params)
+int indigoNameToStructure(const char* name, const char* params)
 {
     INDIGO_BEGIN
     {
@@ -4804,7 +4804,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCheckRGroups(int item)
+int indigoCheckRGroups(int item)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_stereo.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_stereo.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_stereo.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_stereo.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_stereo.cpp	(date 1745583015929)
@@ -22,7 +22,7 @@
 #include "molecule/molecule_exact_matcher.h"
 #include "reaction/reaction.h"
 
-CEXPORT int indigoStereocenterType(int atom)
+int indigoStereocenterType(int atom)
 {
     INDIGO_BEGIN
     {
@@ -65,7 +65,7 @@
     }
 }
 
-CEXPORT int indigoStereocenterGroup(int atom)
+int indigoStereocenterGroup(int atom)
 {
     INDIGO_BEGIN
     {
@@ -79,7 +79,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetStereocenterGroup(int atom, int group)
+int indigoSetStereocenterGroup(int atom, int group)
 {
     INDIGO_BEGIN
     {
@@ -94,7 +94,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoChangeStereocenterType(int atom, int type)
+int indigoChangeStereocenterType(int atom, int type)
 {
     INDIGO_BEGIN
     {
@@ -113,7 +113,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddStereocenter(int atom, int type, int v1, int v2, int v3, int v4)
+int indigoAddStereocenter(int atom, int type, int v1, int v2, int v3, int v4)
 {
     INDIGO_BEGIN
     {
@@ -145,7 +145,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const int* indigoStereocenterPyramid(int atom)
+const int* indigoStereocenterPyramid(int atom)
 {
     INDIGO_BEGIN
     {
@@ -159,7 +159,7 @@
     INDIGO_END(NULL);
 }
 
-CEXPORT int indigoCountStereocenters(int molecule)
+int indigoCountStereocenters(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -170,7 +170,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearAlleneCenters(int molecule)
+int indigoClearAlleneCenters(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -182,7 +182,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountAlleneCenters(int molecule)
+int indigoCountAlleneCenters(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -193,7 +193,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoBondStereo(int bond)
+int indigoBondStereo(int bond)
 {
     INDIGO_BEGIN
     {
@@ -220,7 +220,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoInvertStereo(int item)
+int indigoInvertStereo(int item)
 {
     INDIGO_BEGIN
     {
@@ -261,7 +261,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetStereo(int item)
+int indigoResetStereo(int item)
 {
     INDIGO_BEGIN
     {
@@ -290,7 +290,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearStereocenters(int object)
+int indigoClearStereocenters(int object)
 {
     INDIGO_BEGIN
     {
@@ -319,7 +319,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearCisTrans(int object)
+int indigoClearCisTrans(int object)
 {
     INDIGO_BEGIN
     {
@@ -433,7 +433,7 @@
     return sum;
 }
 
-CEXPORT int indigoResetSymmetricCisTrans(int handle)
+int indigoResetSymmetricCisTrans(int handle)
 {
     INDIGO_BEGIN
     {
@@ -455,7 +455,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetSymmetricStereocenters(int handle)
+int indigoResetSymmetricStereocenters(int handle)
 {
     INDIGO_BEGIN
     {
@@ -477,7 +477,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoMarkEitherCisTrans(int handle)
+int indigoMarkEitherCisTrans(int handle)
 {
     INDIGO_BEGIN
     {
@@ -499,7 +499,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoMarkStereobonds(int handle)
+int indigoMarkStereobonds(int handle)
 {
     INDIGO_BEGIN
     {
@@ -552,7 +552,7 @@
     }
 }
 
-CEXPORT int indigoValidateChirality(int handle)
+int indigoValidateChirality(int handle)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_io.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_io.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_io.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_io.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_io.cpp	(date 1745583015945)
@@ -86,7 +86,7 @@
     throw IndigoError("%s is not an output", obj.debugInfo());
 }
 
-CEXPORT int indigoReadFile(const char* filename)
+int indigoReadFile(const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -95,7 +95,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoReadString(const char* str)
+int indigoReadString(const char* str)
 {
     INDIGO_BEGIN
     {
@@ -104,7 +104,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoReadBuffer(const char* buffer, int size)
+int indigoReadBuffer(const char* buffer, int size)
 {
     INDIGO_BEGIN
     {
@@ -113,7 +113,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadString(const char* str)
+int indigoLoadString(const char* str)
 {
     INDIGO_BEGIN
     {
@@ -122,7 +122,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadBuffer(const char* buffer, int size)
+int indigoLoadBuffer(const char* buffer, int size)
 {
     INDIGO_BEGIN
     {
@@ -131,7 +131,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoWriteFile(const char* filename)
+int indigoWriteFile(const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -140,7 +140,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClose(int output)
+int indigoClose(int output)
 {
     INDIGO_BEGIN
     {
@@ -163,7 +163,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoWriteBuffer(void)
+int indigoWriteBuffer(void)
 {
     INDIGO_BEGIN
     {
@@ -172,7 +172,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoToString(int handle)
+const char* indigoToString(int handle)
 {
     INDIGO_BEGIN
     {
@@ -187,7 +187,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoToBase64String(int handle)
+const char* indigoToBase64String(int handle)
 {
     INDIGO_BEGIN
     {
@@ -200,7 +200,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoToBuffer(int handle, char** buf, int* size)
+int indigoToBuffer(int handle, char** buf, int* size)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_layout.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_layout.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_layout.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_layout.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_layout.cpp	(date 1745648090758)
@@ -32,7 +32,7 @@
 #pragma warning(push, 4)
 #endif
 
-CEXPORT int indigoLayout(int object)
+int indigoLayout(int object)
 {
     INDIGO_BEGIN
     {
@@ -137,7 +137,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClean2d(int object)
+int indigoClean2d(int object)
 {
     INDIGO_BEGIN
     {
Index: cppcoro-src/cppcoro/lib/socket_recv_from_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_recv_from_operation.cpp b/cppcoro-src/cppcoro/lib/socket_recv_from_operation.cpp
--- a/cppcoro-src/cppcoro/lib/socket_recv_from_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_recv_from_operation.cpp	(date 1745583016179)
@@ -9,10 +9,10 @@
 #if CPPCORO_OS_WINNT
 # include "socket_helpers.hpp"
 
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 
 bool cppcoro::net::socket_recv_from_operation_impl::try_start(
 	cppcoro::detail::win32_overlapped_operation_base& operation) noexcept
Index: openbabel-src/openbabel/src/bondtyper.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/bondtyper.cpp b/openbabel-src/openbabel/src/bondtyper.cpp
--- a/openbabel-src/openbabel/src/bondtyper.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/bondtyper.cpp	(date 1745583016039)
@@ -24,8 +24,6 @@
 #include <openbabel/bondtyper.h>
 #include <openbabel/elements.h>
 
-// data header with default parameters
-#include "bondtyp.h"
 
 using namespace std;
 
@@ -54,7 +52,7 @@
     _envvar = "BABEL_DATADIR";
     _filename = "bondtyp.txt";
     _subdir = "data";
-    _dataptr = BondTypeData;
+    _dataptr = nullptr;
   }
 
   void OBBondTyper::ParseLine(const char *buffer)
Index: cppcoro-src/cppcoro/lib/writable_file.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/writable_file.cpp b/cppcoro-src/cppcoro/lib/writable_file.cpp
--- a/cppcoro-src/cppcoro/lib/writable_file.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/writable_file.cpp	(date 1745583016179)
@@ -11,7 +11,7 @@
 # ifndef WIN32_LEAN_AND_MEAN
 #  define WIN32_LEAN_AND_MEAN
 # endif
-# include <Windows.h>
+# include <windows.h>
 
 void cppcoro::writable_file::set_size(
 	std::uint64_t fileSize)
Index: zlib-src/zlib/gzguts.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/zlib-src/zlib/gzguts.h b/zlib-src/zlib/gzguts.h
--- a/zlib-src/zlib/gzguts.h	(revision 51b7f2abdade71cd9bb0e7a373ef2610ec6f9daf)
+++ b/zlib-src/zlib/gzguts.h	(date 1745583016133)
@@ -36,6 +36,8 @@
 
 #if defined(__TURBOC__) || defined(_MSC_VER) || defined(_WIN32)
 #  include <io.h>
+#else
+#  include <unistd.h>
 #endif
 
 #if defined(_WIN32)
Index: indigo-src/indigo/api/c/bingo-nosql/src/bingo-nosql.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/bingo-nosql/src/bingo-nosql.cpp b/indigo-src/indigo/api/c/bingo-nosql/src/bingo-nosql.cpp
--- a/indigo-src/indigo/api/c/bingo-nosql/src/bingo-nosql.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/bingo-nosql/src/bingo-nosql.cpp	(date 1745583016023)
@@ -349,12 +349,12 @@
     auto matcher_ptr = sf::xlock_safe_ptr(searches_data->searches.at(id));                                                                                     \
     auto& matcher = **matcher_ptr;
 
-CEXPORT const char* bingoVersion()
+const char* bingoVersion()
 {
     return BINGO_VERSION;
 }
 
-CEXPORT int bingoCreateDatabaseFile(const char* location, const char* type, const char* options)
+int bingoCreateDatabaseFile(const char* location, const char* type, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -363,7 +363,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int bingoLoadDatabaseFile(const char* location, const char* options)
+int bingoLoadDatabaseFile(const char* location, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -372,7 +372,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int bingoCloseDatabase(int db)
+int bingoCloseDatabase(int db)
 {
 #ifdef INDIGO_DEBUG
     std::stringstream ss;
@@ -389,7 +389,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoInsertRecordObj(int db, int obj)
+int bingoInsertRecordObj(int db, int obj)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -414,7 +414,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoInsertIteratorObj(int db, int iterator_obj_id)
+int bingoInsertIteratorObj(int db, int iterator_obj_id)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -437,7 +437,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoInsertRecordObjWithId(int db, int obj, int id)
+int bingoInsertRecordObjWithId(int db, int obj, int id)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -447,7 +447,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoInsertRecordObjWithExtFP(int db, int obj, int fp)
+int bingoInsertRecordObjWithExtFP(int db, int obj, int fp)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -473,7 +473,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoInsertRecordObjWithIdAndExtFP(int db, int obj, int id, int fp)
+int bingoInsertRecordObjWithIdAndExtFP(int db, int obj, int id, int fp)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -484,7 +484,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoDeleteRecord(int db, int id)
+int bingoDeleteRecord(int db, int id)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -496,7 +496,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoGetRecordObj(int db, int id)
+int bingoGetRecordObj(int db, int id)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -538,7 +538,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoOptimize(int db)
+int bingoOptimize(int db)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -550,7 +550,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchSub(int db, int query_obj, const char* options)
+int bingoSearchSub(int db, int query_obj, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -601,7 +601,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchExact(int db, int query_obj, const char* options)
+int bingoSearchExact(int db, int query_obj, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -650,7 +650,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchMolFormula(int db, const char* query, const char* options)
+int bingoSearchMolFormula(int db, const char* query, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -674,7 +674,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchSim(int db, int query_obj, float min, float max, const char* options)
+int bingoSearchSim(int db, int query_obj, float min, float max, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -725,7 +725,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchSimWithExtFP(int db, int query_obj, float min, float max, int fp, const char* options)
+int bingoSearchSimWithExtFP(int db, int query_obj, float min, float max, int fp, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -777,7 +777,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchSimTopN(int db, int query_obj, int limit, float min, const char* options)
+int bingoSearchSimTopN(int db, int query_obj, int limit, float min, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -828,7 +828,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchSimTopNWithExtFP(int db, int query_obj, int limit, float min, int fp, const char* options)
+int bingoSearchSimTopNWithExtFP(int db, int query_obj, int limit, float min, int fp, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -880,7 +880,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoEnumerateId(int db)
+int bingoEnumerateId(int db)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -900,7 +900,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoEndSearch(int search_obj)
+int bingoEndSearch(int search_obj)
 {
 #ifdef INDIGO_DEBUG
     std::stringstream ss;
@@ -916,7 +916,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoNext(int search_obj)
+int bingoNext(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -926,7 +926,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoGetCurrentId(int search_obj)
+int bingoGetCurrentId(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -936,7 +936,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT float bingoGetCurrentSimilarityValue(int search_obj)
+float bingoGetCurrentSimilarityValue(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -946,7 +946,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoEstimateRemainingResultsCount(int search_obj)
+int bingoEstimateRemainingResultsCount(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -957,7 +957,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoContainersCount(int search_obj)
+int bingoContainersCount(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -967,7 +967,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoCellsCount(int search_obj)
+int bingoCellsCount(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -977,7 +977,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoCurrentCell(int search_obj)
+int bingoCurrentCell(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -987,7 +987,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoMinCell(int search_obj)
+int bingoMinCell(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -997,7 +997,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoMaxCell(int search_obj)
+int bingoMaxCell(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -1007,7 +1007,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoEstimateRemainingResultsCountError(int search_obj)
+int bingoEstimateRemainingResultsCountError(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -1019,7 +1019,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoEstimateRemainingTime(int search_obj, float* time_sec)
+int bingoEstimateRemainingTime(int search_obj, float* time_sec)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -1031,7 +1031,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoGetObject(int search_obj)
+int bingoGetObject(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -1042,7 +1042,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT const char* bingoProfilingGetStatistics(int for_session)
+const char* bingoProfilingGetStatistics(int for_session)
 {
     INDIGO_BEGIN
     {
Index: cppcoro-src/cppcoro/lib/socket.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket.cpp b/cppcoro-src/cppcoro/lib/socket.cpp
--- a/cppcoro-src/cppcoro/lib/socket.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket.cpp	(date 1745583016164)
@@ -17,10 +17,10 @@
 #include "socket_helpers.hpp"
 
 #if CPPCORO_OS_WINNT
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 
 namespace
 {
Index: openbabel-src/openbabel/src/format.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/format.cpp b/openbabel-src/openbabel/src/format.cpp
--- a/openbabel-src/openbabel/src/format.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/format.cpp	(date 1745583015976)
@@ -23,11 +23,6 @@
 using namespace std;
 namespace OpenBabel
 {
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-  // macro to implement static OBPlugin::PluginMapType& Map()
-  PLUGIN_CPP_FILE(OBFormat)
-#endif
-
 int OBFormat::RegisterFormat(const char* ID, const char* MIME)
 {
   GetMap()[ID] = this;
Index: cppcoro-src/cppcoro/lib/socket_connect_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_connect_operation.cpp b/cppcoro-src/cppcoro/lib/socket_connect_operation.cpp
--- a/cppcoro-src/cppcoro/lib/socket_connect_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_connect_operation.cpp	(date 1745583016179)
@@ -14,10 +14,10 @@
 #include <system_error>
 
 #if CPPCORO_OS_WINNT
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 
 bool cppcoro::net::socket_connect_operation_impl::try_start(
 	cppcoro::detail::win32_overlapped_operation_base& operation) noexcept
Index: openbabel-src/openbabel/src/distgeom.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/distgeom.cpp b/openbabel-src/openbabel/src/distgeom.cpp
--- a/openbabel-src/openbabel/src/distgeom.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/distgeom.cpp	(date 1745583016023)
@@ -16,7 +16,7 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 ***********************************************************************/
-
+#include <openbabel/babelconfig.h>
 #ifdef HAVE_EIGEN
 
 #include <openbabel/distgeom.h>
Index: openbabel-src/openbabel/src/zipstreamimpl.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/zipstreamimpl.h b/openbabel-src/openbabel/src/zipstreamimpl.h
--- a/openbabel-src/openbabel/src/zipstreamimpl.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/zipstreamimpl.h	(date 1745583015992)
@@ -176,8 +176,7 @@
     }
     while(_err == Z_OK);
 
-    if(&_ostream)
-			_ostream.flush();
+    _ostream.flush();
 
     return total_written_byte_size;
 }
Index: cppcoro-src/cppcoro/lib/lightweight_manual_reset_event.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/lightweight_manual_reset_event.cpp b/cppcoro-src/cppcoro/lib/lightweight_manual_reset_event.cpp
--- a/cppcoro-src/cppcoro/lib/lightweight_manual_reset_event.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/lightweight_manual_reset_event.cpp	(date 1745583016179)
@@ -11,7 +11,7 @@
 # ifndef WIN32_LEAN_AND_MEAN
 #  define WIN32_LEAN_AND_MEAN
 # endif
-# include <Windows.h>
+# include <windows.h>
 
 # if CPPCORO_OS_WINNT >= 0x0602
 
Index: cppcoro-src/cppcoro/lib/io_service.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/io_service.cpp b/cppcoro-src/cppcoro/lib/io_service.cpp
--- a/cppcoro-src/cppcoro/lib/io_service.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/io_service.cpp	(date 1745583016164)
@@ -18,10 +18,10 @@
 # ifndef NOMINMAX
 #  define NOMINMAX
 # endif
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 #endif
 
 namespace
@@ -642,7 +642,7 @@
 			{
 				// This was a coroutine scheduled via a call to
 				// io_service::schedule().
-				std::experimental::coroutine_handle<>::from_address(
+				std::coroutine_handle<>::from_address(
 					reinterpret_cast<void*>(completionKey)).resume();
 				return true;
 			}
@@ -911,7 +911,7 @@
 }
 
 void cppcoro::io_service::schedule_operation::await_suspend(
-	std::experimental::coroutine_handle<> awaiter) noexcept
+	std::coroutine_handle<> awaiter) noexcept
 {
 	m_awaiter = awaiter;
 	m_service.schedule_impl(this);
@@ -947,7 +947,7 @@
 }
 
 void cppcoro::io_service::timed_schedule_operation::await_suspend(
-	std::experimental::coroutine_handle<> awaiter)
+	std::coroutine_handle<> awaiter)
 {
 	m_scheduleOperation.m_awaiter = awaiter;
 
Index: indigo-src/indigo/api/c/indigo/src/indigo_macros.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_macros.c b/indigo-src/indigo/api/c/indigo/src/indigo_macros.c
--- a/indigo-src/indigo/api/c/indigo/src/indigo_macros.c	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_macros.c	(date 1745648090774)
@@ -19,7 +19,7 @@
 #include "indigo.h"
 
 #define WRAPPER_LOAD_FROM_STRING(name)                                                                                                                         \
-    CEXPORT int name##FromString(const char* string)                                                                                                           \
+    int name##FromString(const char* string)                                                                                                           \
     {                                                                                                                                                          \
         int source = indigoReadString(string);                                                                                                                 \
         int result;                                                                                                                                            \
@@ -33,7 +33,7 @@
     }
 
 #define WRAPPER_LOAD_FROM_FILE(name)                                                                                                                           \
-    CEXPORT int name##FromFile(const char* filename)                                                                                                           \
+    int name##FromFile(const char* filename)                                                                                                           \
     {                                                                                                                                                          \
         int source = indigoReadFile(filename);                                                                                                                 \
         int result;                                                                                                                                            \
@@ -47,7 +47,7 @@
     }
 
 #define WRAPPER_LOAD_FROM_BUFFER(name)                                                                                                                         \
-    CEXPORT int name##FromBuffer(const char* buf, int size)                                                                                                    \
+    int name##FromBuffer(const char* buf, int size)                                                                                                    \
     {                                                                                                                                                          \
         int source = indigoReadBuffer(buf, size);                                                                                                              \
         int result;                                                                                                                                            \
@@ -92,7 +92,7 @@
 WRAPPER_LOAD_FROM_FILE(indigoLoadKetDocument)
 WRAPPER_LOAD_FROM_BUFFER(indigoLoadKetDocument)
 
-CEXPORT int indigoSaveMolfileToFile(int molecule, const char* filename)
+int indigoSaveMolfileToFile(int molecule, const char* filename)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -106,7 +106,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveJsonToFile(int item, const char* filename)
+int indigoSaveJsonToFile(int item, const char* filename)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -120,7 +120,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveSequenceToFile(int item, const char* filename, int library)
+int indigoSaveSequenceToFile(int item, const char* filename, int library)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -134,7 +134,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveSequence3LetterToFile(int item, const char* filename, int library)
+int indigoSaveSequence3LetterToFile(int item, const char* filename, int library)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -148,7 +148,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveFastaToFile(int item, const char* filename, int library)
+int indigoSaveFastaToFile(int item, const char* filename, int library)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -162,7 +162,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveIdtToFile(int item, const char* filename, int library)
+int indigoSaveIdtToFile(int item, const char* filename, int library)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -176,7 +176,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveHelmToFile(int item, const char* filename, int library)
+int indigoSaveHelmToFile(int item, const char* filename, int library)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -190,7 +190,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveCmlToFile(int molecule, const char* filename)
+int indigoSaveCmlToFile(int molecule, const char* filename)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -204,7 +204,7 @@
     return res;
 }
 
-CEXPORT const char* indigoMolfile(int molecule)
+const char* indigoMolfile(int molecule)
 {
     int b = indigoWriteBuffer();
     const char* res;
@@ -220,7 +220,7 @@
     return res;
 }
 
-CEXPORT const char* indigoSequence(int molecule, int library)
+const char* indigoSequence(int molecule, int library)
 {
     int b = indigoWriteBuffer();
     const char* res;
@@ -236,7 +236,7 @@
     return res;
 }
 
-CEXPORT const char* indigoSequence3Letter(int molecule, int library)
+const char* indigoSequence3Letter(int molecule, int library)
 {
     int b = indigoWriteBuffer();
     const char* res;
@@ -252,7 +252,7 @@
     return res;
 }
 
-CEXPORT const char* indigoFasta(int molecule, int library)
+const char* indigoFasta(int molecule, int library)
 {
     int b = indigoWriteBuffer();
     const char* res;
@@ -268,7 +268,7 @@
     return res;
 }
 
-CEXPORT const char* indigoIdt(int molecule, int library)
+const char* indigoIdt(int molecule, int library)
 {
     int b = indigoWriteBuffer();
     const char* res;
@@ -284,7 +284,7 @@
     return res;
 }
 
-CEXPORT const char* indigoHelm(int molecule, int library)
+const char* indigoHelm(int molecule, int library)
 {
     int b = indigoWriteBuffer();
     const char* res;
@@ -300,7 +300,7 @@
     return res;
 }
 
-CEXPORT const char* indigoCdxBase64(int object)
+const char* indigoCdxBase64(int object)
 {
     int b = indigoWriteBuffer();
     const char* res;
@@ -316,7 +316,7 @@
     return res;
 }
 
-CEXPORT const char* indigoCml(int molecule)
+const char* indigoCml(int molecule)
 {
     int b = indigoWriteBuffer();
     const char* res;
@@ -332,7 +332,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveRxnfileToFile(int reaction, const char* filename)
+int indigoSaveRxnfileToFile(int reaction, const char* filename)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -346,7 +346,7 @@
     return res;
 }
 
-CEXPORT const char* indigoRxnfile(int molecule)
+const char* indigoRxnfile(int molecule)
 {
     int b = indigoWriteBuffer();
     const char* res;
@@ -362,7 +362,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveCdxmlToFile(int item, const char* filename)
+int indigoSaveCdxmlToFile(int item, const char* filename)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -376,7 +376,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveCdxToFile(int item, const char* filename)
+int indigoSaveCdxToFile(int item, const char* filename)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -390,7 +390,7 @@
     return res;
 }
 
-CEXPORT const char* indigoCdxml(int item)
+const char* indigoCdxml(int item)
 {
     int b = indigoWriteBuffer();
     const char* res;
Index: cppcoro-src/cppcoro/lib/socket_helpers.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_helpers.hpp b/cppcoro-src/cppcoro/lib/socket_helpers.hpp
--- a/cppcoro-src/cppcoro/lib/socket_helpers.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_helpers.hpp	(date 1745583016148)
@@ -13,6 +13,9 @@
 struct sockaddr_storage;
 #endif
 
+# include <cstring>
+# include <memory>
+
 namespace cppcoro
 {
 	namespace net
Index: cppcoro-src/cppcoro/lib/async_mutex.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/async_mutex.cpp b/cppcoro-src/cppcoro/lib/async_mutex.cpp
--- a/cppcoro-src/cppcoro/lib/async_mutex.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/async_mutex.cpp	(date 1745583016148)
@@ -85,7 +85,7 @@
 	waitersHead->m_awaiter.resume();
 }
 
-bool cppcoro::async_mutex_lock_operation::await_suspend(std::experimental::coroutine_handle<> awaiter) noexcept
+bool cppcoro::async_mutex_lock_operation::await_suspend(std::coroutine_handle<> awaiter) noexcept
 {
 	m_awaiter = awaiter;
 
Index: cppcoro-src/cppcoro/lib/file_write_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/file_write_operation.cpp b/cppcoro-src/cppcoro/lib/file_write_operation.cpp
--- a/cppcoro-src/cppcoro/lib/file_write_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/file_write_operation.cpp	(date 1745583016179)
@@ -9,7 +9,7 @@
 # ifndef WIN32_LEAN_AND_MEAN
 #  define WIN32_LEAN_AND_MEAN
 # endif
-# include <Windows.h>
+# include <windows.h>
 
 bool cppcoro::file_write_operation_impl::try_start(
 	cppcoro::detail::win32_overlapped_operation_base& operation) noexcept
Index: openbabel-src/openbabel/src/config.h.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/config.h.cmake b/openbabel-src/openbabel/src/config.h.cmake
--- a/openbabel-src/openbabel/src/config.h.cmake	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/config.h.cmake	(date 1745583016039)
@@ -16,23 +16,12 @@
 /* The file extension used for shared modules */
 #define MODULE_EXTENSION "@MODULE_EXTENSION@"
 
+#include <openbabel_export.hpp>
 // If we are using a recent GCC version with visibility support use it
-#ifdef HAVE_GCC_VISIBILITY
-  #define OB_EXPORT __attribute__ ((visibility("default")))
-  #define OB_IMPORT __attribute__ ((visibility("default")))
-  #define OB_HIDDEN __attribute__ ((visibility("hidden")))
-#elif defined(WIN32) && defined(USING_DYNAMIC_LIBS) && !defined(__MINGW32__)
- #define OB_EXPORT __declspec(dllexport)
- #define OB_IMPORT __declspec(dllimport)
- #define OB_HIDDEN
-#else
- #define OB_EXPORT
- #define OB_IMPORT
- #define OB_HIDDEN
+#ifndef OB_EXPORT
+#define OB_EXPORT OPENBABEL_EXPORT
 #endif
 
-/* Used to export symbols for DLL / shared library builds */
-#if defined(MAKE_OBDLL) // e.g. in src/main.cpp
  #ifndef OB_EXTERN
   #define OB_EXTERN   OB_EXPORT extern
  #endif
@@ -60,39 +49,6 @@
  #ifndef OBDEPICT
   #define OBDEPICT OB_EXPORT
  #endif
-
-#else   // defined(MAKE_OBDLL)
-
- #ifndef OB_EXTERN
-  #define OB_EXTERN   OB_IMPORT extern
- #endif
- #ifndef OBAPI
-  #define OBAPI    OB_IMPORT
- #endif
- #ifndef OBCOMMON
-  #define OBCOMMON OB_IMPORT
- #endif
- #ifndef OBCONV
-  #define OBCONV   OB_IMPORT
- #endif
- #ifndef OBERROR
-  #define OBERROR  OB_IMPORT
- #endif
- #ifndef OBFPRT
-  #define OBFPRT   OB_IMPORT
- #endif
- #ifndef OBFPTR
-  #define OBFPTR   OB_IMPORT
- #endif
- #ifndef OBMCDL
- #define OBMCDL    OB_IMPORT
-  #ifndef OBDEPICT
- #define OBDEPICT  OB_IMPORT
- #endif
-
- #endif
-
-#endif
 
 #ifdef _MSC_VER
  // Suppress warning on deprecated functions
@@ -149,6 +105,22 @@
 /* have struct clock_t */
 #cmakedefine HAVE_CLOCK_T 1
 
+#cmakedefine HAVE_REGEX_H 1
+
+#cmakedefine HAVE_SHARED_POINTER 1
+
+#cmakedefine HAVE_EIGEN 1
+
+#cmakedefine HAVE_EIGEN3 1
+
+#cmakedefine HAVE_STATIC_INCHI 1
+
+#cmakedefine HAVE_LIBZ 1
+
+#cmakedefine HAVE_STATIC_LIBXML 1
+
+#cmakedefine HAVE_RPC_XDR_H 1
+
 /* shared pointer implementation to be used */
 #cmakedefine OB_SHARED_PTR_IMPLEMENTATION @OB_SHARED_PTR_IMPLEMENTATION@
 
Index: openbabel-src/openbabel/src/mcdlutil.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/mcdlutil.cpp b/openbabel-src/openbabel/src/mcdlutil.cpp
--- a/openbabel-src/openbabel/src/mcdlutil.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/mcdlutil.cpp	(date 1745583016008)
@@ -5033,7 +5033,7 @@
 
     if (bondLabel != nullptr && nBonds() > 0) {
       bondLabel->resize(molecule1->nBonds());
-      if (test2) for (j=0; j<molecule1->nBonds(); j++) if (bSTested[j]>=0) (*bondLabel)[j]=1; else (*bondLabel)[j]=0;
+      if (test2) for (j=0; j<molecule1->nBonds(); j++) { if (bSTested[j]>=0) (*bondLabel)[j]=1; else (*bondLabel)[j]=0; }
     };
     result=test2;
 
@@ -5102,7 +5102,7 @@
   std::vector<TEditedMolecule *> TemplateRedraw::queryData;
 
   bool TemplateRedraw::loadTemplates() {
-    std::ifstream ifs;
+    std::istringstream ifs;
     string filename("templates.sdf");//("e:\\templates.sdf");
     TEditedMolecule sm;
     TEditedMolecule * em;
Index: indigo-src/indigo/api/c/bingo-nosql/bingo-nosql.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/bingo-nosql/bingo-nosql.h b/indigo-src/indigo/api/c/bingo-nosql/bingo-nosql.h
--- a/indigo-src/indigo/api/c/bingo-nosql/bingo-nosql.h	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/bingo-nosql/bingo-nosql.h	(date 1745583015976)
@@ -20,63 +20,64 @@
 #define __indigo_bingo__
 
 #include "indigo.h"
+#include "bingo_nosql_export.h"
 
-CEXPORT const char* bingoVersion();
+BINGO_NOSQL_EXPORT const char* bingoVersion();
 
 // options = "id: <property-name>"
-CEXPORT int bingoCreateDatabaseFile(const char* location, const char* type, const char* options);
-CEXPORT int bingoLoadDatabaseFile(const char* location, const char* options);
-CEXPORT int bingoCloseDatabase(int db);
+BINGO_NOSQL_EXPORT int bingoCreateDatabaseFile(const char* location, const char* type, const char* options);
+BINGO_NOSQL_EXPORT int bingoLoadDatabaseFile(const char* location, const char* options);
+BINGO_NOSQL_EXPORT int bingoCloseDatabase(int db);
 
 //
 // Record insertion/deletion
 //
-CEXPORT int bingoInsertRecordObj(int db, int obj);
-CEXPORT int bingoInsertIteratorObj(int db, int iterator_obj_id);
-CEXPORT int bingoInsertRecordObjWithId(int db, int obj, int id);
-CEXPORT int bingoInsertRecordObjWithExtFP(int db, int obj, int fp);
-CEXPORT int bingoInsertRecordObjWithIdAndExtFP(int db, int obj, int id, int fp);
-CEXPORT int bingoDeleteRecord(int db, int id);
-CEXPORT int bingoGetRecordObj(int db, int id);
+BINGO_NOSQL_EXPORT int bingoInsertRecordObj(int db, int obj);
+BINGO_NOSQL_EXPORT int bingoInsertIteratorObj(int db, int iterator_obj_id);
+BINGO_NOSQL_EXPORT int bingoInsertRecordObjWithId(int db, int obj, int id);
+BINGO_NOSQL_EXPORT int bingoInsertRecordObjWithExtFP(int db, int obj, int fp);
+BINGO_NOSQL_EXPORT int bingoInsertRecordObjWithIdAndExtFP(int db, int obj, int id, int fp);
+BINGO_NOSQL_EXPORT int bingoDeleteRecord(int db, int id);
+BINGO_NOSQL_EXPORT int bingoGetRecordObj(int db, int id);
 
-CEXPORT int bingoOptimize(int db);
+BINGO_NOSQL_EXPORT int bingoOptimize(int db);
 
 // Search methods that returns search object
 // Search object is an iterator
-CEXPORT int bingoSearchSub(int db, int query_obj, const char* options);
-CEXPORT int bingoSearchExact(int db, int query_obj, const char* options);
-CEXPORT int bingoSearchMolFormula(int db, const char* query, const char* options);
-CEXPORT int bingoSearchSim(int db, int query_obj, float min, float max, const char* options);
-CEXPORT int bingoSearchSimWithExtFP(int db, int query_obj, float min, float max, int fp, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchSub(int db, int query_obj, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchExact(int db, int query_obj, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchMolFormula(int db, const char* query, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchSim(int db, int query_obj, float min, float max, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchSimWithExtFP(int db, int query_obj, float min, float max, int fp, const char* options);
 
-CEXPORT int bingoSearchSimTopN(int db, int query_obj, int limit, float min, const char* options);
-CEXPORT int bingoSearchSimTopNWithExtFP(int db, int query_obj, int limit, float min, int fp, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchSimTopN(int db, int query_obj, int limit, float min, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchSimTopNWithExtFP(int db, int query_obj, int limit, float min, int fp, const char* options);
 
-CEXPORT int bingoEnumerateId(int db);
+BINGO_NOSQL_EXPORT int bingoEnumerateId(int db);
 
 //
 // Search object methods
 //
-CEXPORT int bingoNext(int search_obj);
-CEXPORT int bingoGetCurrentId(int search_obj);
-CEXPORT float bingoGetCurrentSimilarityValue(int search_obj);
+BINGO_NOSQL_EXPORT int bingoNext(int search_obj);
+BINGO_NOSQL_EXPORT int bingoGetCurrentId(int search_obj);
+BINGO_NOSQL_EXPORT float bingoGetCurrentSimilarityValue(int search_obj);
 
 // Estimation methods
-CEXPORT int bingoEstimateRemainingResultsCount(int search_obj);
-CEXPORT int bingoEstimateRemainingResultsCountError(int search_obj);
-CEXPORT int bingoEstimateRemainingTime(int search_obj, float* time_sec);
-CEXPORT int bingoContainersCount(int search_obj);
-CEXPORT int bingoCellsCount(int search_obj);
-CEXPORT int bingoCurrentCell(int search_obj);
-CEXPORT int bingoMinCell(int search_obj);
-CEXPORT int bingoMaxCell(int search_obj);
+BINGO_NOSQL_EXPORT int bingoEstimateRemainingResultsCount(int search_obj);
+BINGO_NOSQL_EXPORT int bingoEstimateRemainingResultsCountError(int search_obj);
+BINGO_NOSQL_EXPORT int bingoEstimateRemainingTime(int search_obj, float* time_sec);
+BINGO_NOSQL_EXPORT int bingoContainersCount(int search_obj);
+BINGO_NOSQL_EXPORT int bingoCellsCount(int search_obj);
+BINGO_NOSQL_EXPORT int bingoCurrentCell(int search_obj);
+BINGO_NOSQL_EXPORT int bingoMinCell(int search_obj);
+BINGO_NOSQL_EXPORT int bingoMaxCell(int search_obj);
 
 // This method return IndigoObject that represents current object.
 // After calling bingoNext this object automatically points to the next found result
-CEXPORT int bingoGetObject(int search_obj);
+BINGO_NOSQL_EXPORT int bingoGetObject(int search_obj);
 
-CEXPORT int bingoEndSearch(int search_obj);
+BINGO_NOSQL_EXPORT int bingoEndSearch(int search_obj);
 
-CEXPORT const char* bingoProfilingGetStatistics(int for_session);
+BINGO_NOSQL_EXPORT const char* bingoProfilingGetStatistics(int for_session);
 
 #endif // __indigo_bingo__
Index: cppcoro-src/cppcoro/lib/file_read_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/file_read_operation.cpp b/cppcoro-src/cppcoro/lib/file_read_operation.cpp
--- a/cppcoro-src/cppcoro/lib/file_read_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/file_read_operation.cpp	(date 1745583016179)
@@ -9,7 +9,7 @@
 # ifndef WIN32_LEAN_AND_MEAN
 #  define WIN32_LEAN_AND_MEAN
 # endif
-# include <Windows.h>
+# include <windows.h>
 
 bool cppcoro::file_read_operation_impl::try_start(
 	cppcoro::detail::win32_overlapped_operation_base& operation) noexcept
Index: openbabel-src/openbabel/src/alias.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/alias.cpp b/openbabel-src/openbabel/src/alias.cpp
--- a/openbabel-src/openbabel/src/alias.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/alias.cpp	(date 1745583016039)
@@ -222,7 +222,7 @@
 bool AliasData::LoadFile(SuperAtomTable& table)
 {
   //In table: key=alias left-form; value=pair<alias right-form, SMILES>
-  ifstream ifs;
+  istringstream ifs;
   if (OpenDatafile(ifs, "superatom.txt").length() == 0)
   {
     obErrorLog.ThrowError(__FUNCTION__, "Cannot open superatom.txt", obError);
@@ -250,7 +250,7 @@
 bool AliasData::LoadFile(SmartsTable& smtable)
 {
   //Re-parse the datafile. Seems simpler than trying to extract from the map.
-  ifstream ifs;
+  istringstream ifs;
   if (OpenDatafile(ifs, "superatom.txt").length() == 0)
   {
     obErrorLog.ThrowError(__FUNCTION__, "Cannot open superatom.txt", obError);
Index: fluentui-src/fluentui/src/qhotkey/qhotkey.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/qhotkey/qhotkey.h b/fluentui-src/fluentui/src/qhotkey/qhotkey.h
--- a/fluentui-src/fluentui/src/qhotkey/qhotkey.h	(revision 4e4016ae3fed7d1a3534760b44313e8fb0b8fd29)
+++ b/fluentui-src/fluentui/src/qhotkey/qhotkey.h	(date 1745583015851)
@@ -88,7 +88,7 @@
 	//! Get the current native shortcut
 	NativeShortcut currentNativeShortcut() const;
 
-public slots:
+public Q_SLOTS:
 	//! @writeAcFn{QHotkey::registered}
 	bool setRegistered(bool registered);
 
@@ -102,7 +102,7 @@
 	//! Set this hotkey to a native shortcut
 	bool setNativeShortcut(QHotkey::NativeShortcut nativeShortcut, bool autoRegister = false);
 
-signals:
+Q_SIGNALS:
 	//! Will be emitted if the shortcut is pressed
 	void activated(QPrivateSignal);
 
Index: openbabel-src/openbabel/src/locale.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/locale.cpp b/openbabel-src/openbabel/src/locale.cpp
--- a/openbabel-src/openbabel/src/locale.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/locale.cpp	(date 1745583016039)
@@ -16,33 +16,19 @@
 GNU General Public License for more details.
 ***********************************************************************/
 
-#include <stdlib.h>
-#include <string.h>
 #include <openbabel/locale.h>
-
-#if HAVE_XLOCALE_H
-#include <xlocale.h>
-#endif
-#if HAVE_LOCALE_H
-#include <locale.h>
-#endif
+#include <string>
+#include <clocale>
 
 namespace OpenBabel
 {
   class OBLocalePrivate {
   public:
-    char *old_locale_string;
-#if HAVE_USELOCALE
-    locale_t new_c_num_locale;
-    locale_t old_locale;
-#endif
+    std::string old_locale_string;
     unsigned int counter; // Reference counter -- ensures balance in SetLocale/RestoreLocale calls
 
     OBLocalePrivate(): counter(0)
     {
-#if HAVE_USELOCALE
-      new_c_num_locale = newlocale(LC_NUMERIC_MASK, NULL, NULL);
-#endif
     }
 
     ~OBLocalePrivate()
@@ -92,21 +78,8 @@
   void OBLocale::SetLocale()
   {
     if (d->counter == 0) {
-      // Set the locale for number parsing to avoid locale issues: PR#1785463
-#if HAVE_USELOCALE
-      // Extended per-thread interface
-      d->old_locale = uselocale(d->new_c_num_locale);
-#else
-#ifndef ANDROID
-      // Original global POSIX interface
-      // regular UNIX, no USELOCALE, no ANDROID
-      d->old_locale_string = strdup(setlocale(LC_NUMERIC, nullptr));
-#else
-      // ANDROID should stay as "C" -- Igor Filippov
-      d->old_locale_string = "C";
-#endif
+      d->old_locale_string = std::setlocale(LC_ALL, nullptr);
   	  setlocale(LC_NUMERIC, "C");
-#endif
     }
 
     ++d->counter;
@@ -117,15 +90,7 @@
     --d->counter;
     if(d->counter == 0) {
       // return the locale to the original one
-#ifdef HAVE_USELOCALE
-      uselocale(d->old_locale);
-#else
-      setlocale(LC_NUMERIC, d->old_locale_string);
-#ifndef ANDROID
-      // Don't free on Android because "C" is a static ctring constant
-      free (d->old_locale_string);
-#endif
-#endif
+      std::setlocale(LC_NUMERIC, d->old_locale_string.c_str());
     }
   }
 
Index: openbabel-src/openbabel/src/op.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/op.cpp b/openbabel-src/openbabel/src/op.cpp
--- a/openbabel-src/openbabel/src/op.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/op.cpp	(date 1745583016008)
@@ -22,10 +22,6 @@
 using namespace std;
 namespace OpenBabel
 {
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-  // macro to implement static OBPlugin::PluginMapType& Map()
-  PLUGIN_CPP_FILE(OBOp)
-#endif
 }
 
 
Index: openbabel-src/openbabel/src/data.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/data.cpp b/openbabel-src/openbabel/src/data.cpp
--- a/openbabel-src/openbabel/src/data.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/data.cpp	(date 1745583016023)
@@ -31,9 +31,6 @@
 #include <openbabel/oberror.h>
 #include <openbabel/elements.h>
 
-// data headers with default parameters
-#include "types.h"
-#include "resdata.h"
 
 
 #if !HAVE_STRNCASECMP
@@ -250,7 +247,7 @@
     _envvar = "BABEL_DATADIR";
     _filename = "types.txt";
     _subdir = "data";
-    _dataptr = TypesData;
+    _dataptr = nullptr;
     _linecount = 0;
     _from = _to = -1;
   }
@@ -434,7 +431,7 @@
     _envvar = "BABEL_DATADIR";
     _filename = "resdata.txt";
     _subdir = "data";
-    _dataptr = ResidueData;
+    _dataptr = nullptr;
   }
 
   bool OBResidueData::AssignBonds(OBMol &mol)
@@ -669,7 +666,7 @@
       return;
     _init = true;
 
-    ifstream ifs;
+    istringstream ifs;
     char charBuffer[BUFF_SIZE];
 
     // Set the locale for number parsing to avoid locale issues: PR#1785463
@@ -716,8 +713,6 @@
     // return the locale to the original one
     obLocale.RestoreLocale();
 
-    if (ifs)
-      ifs.close();
 
     if (GetSize() == 0)
       {
Index: indigo-src/indigo/core/indigo-core/molecule/src/inchi_wrapper.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/molecule/src/inchi_wrapper.cpp b/indigo-src/indigo/core/indigo-core/molecule/src/inchi_wrapper.cpp
--- a/indigo-src/indigo/core/indigo-core/molecule/src/inchi_wrapper.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/core/indigo-core/molecule/src/inchi_wrapper.cpp	(date 1745583016179)
@@ -17,6 +17,7 @@
  ***************************************************************************/
 
 #include <algorithm>
+#define TARGET_LIB_FOR_WINCHI
 #include <mode.h>
 
 #include "molecule/inchi_wrapper.h"
Index: opencv-src/opencv/modules/imgproc/src/spatialgradient.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/imgproc/src/spatialgradient.cpp b/opencv-src/opencv/modules/imgproc/src/spatialgradient.cpp
--- a/opencv-src/opencv/modules/imgproc/src/spatialgradient.cpp	(revision 31b0eeea0b44b370fd0712312df4214d4ae1b158)
+++ b/opencv-src/opencv/modules/imgproc/src/spatialgradient.cpp	(date 1745583015976)
@@ -77,7 +77,11 @@
 #endif
 
 template <typename T>
+#if 1930 <= _MSC_VER && _MSC_VER < 1940 // FIXME: MSVC 2022, static build, got fatal error C1001
+static __declspec(noinline) void spatialGradientKernel( T& vx, T& vy,
+#else
 static inline void spatialGradientKernel( T& vx, T& vy,
+#endif
                                           const T& v00, const T& v01, const T& v02,
                                           const T& v10,               const T& v12,
                                           const T& v20, const T& v21, const T& v22 )
Index: openbabel-src/openbabel/src/confsearch.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/confsearch.cpp b/openbabel-src/openbabel/src/confsearch.cpp
--- a/openbabel-src/openbabel/src/confsearch.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/confsearch.cpp	(date 1745583015992)
@@ -131,7 +131,7 @@
 
     const double arr[] = {3.0, 2.0, 1.5, 1.0, 0.5, 0.25};
     std::vector<double> vec (arr, arr + sizeof(arr) / sizeof(arr[0]) );
-    vec.erase(std::remove_if(vec.begin(), vec.end(), std::bind2nd(std::less<double>(), (cutoff + 0.1) )), vec.end());
+    vec.erase(std::remove_if(vec.begin(), vec.end(), std::bind(std::less<double>(), std::placeholders::_1, (cutoff + 0.1) )), vec.end());
     vec.push_back(cutoff);
 
     levels = vec;
@@ -293,7 +293,7 @@
   std::vector <OBDiversePoses::PosePair> confs, newconfs;
 
   // The leaf iterator will (in effect) iterate over the nodes just at the loweset level
-  for (OBDiversePoses::Tree::leaf_iterator node = poses->begin(); node != poses->end(); ++node)
+  for (auto node = poses->begin(); node != poses->end(); ++node)
     if (node->first.size() > 0) // Don't include the dummy head node
       confs.push_back(*node);
 
@@ -441,7 +441,7 @@
     UpdateConformersFromTree(&_mol, _energies, &divposes, verbose);
 
     // Add back the energy offset
-    transform(_energies.begin(), _energies.end(), _energies.begin(), bind2nd(std::plus<double>(), energy_offset));
+    transform(_energies.begin(), _energies.end(), _energies.begin(), std::bind(std::plus<double>(), std::placeholders::_1, energy_offset));
 
     // Clean up
     delete [] store_initial;
Index: freesasa-src/freesasa/src/xml.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/freesasa-src/freesasa/src/xml.c b/freesasa-src/freesasa/src/xml.c
--- a/freesasa-src/freesasa/src/xml.c	(revision aa3c67d174049c0103d39a2a97b4a3a931d55243)
+++ b/freesasa-src/freesasa/src/xml.c	(date 1745583015836)
@@ -3,6 +3,7 @@
 #endif
 #include <assert.h>
 #include <errno.h>
+#include <libxml/parser.h>
 #include <libxml/tree.h>
 #include <libxml/xmlwriter.h>
 #include <stdlib.h>
Index: openbabel-src/openbabel/src/builder.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/builder.cpp b/openbabel-src/openbabel/src/builder.cpp
--- a/openbabel-src/openbabel/src/builder.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/builder.cpp	(date 1745583015992)
@@ -97,7 +97,7 @@
 
   void OBBuilder::LoadFragments()  {
     // open data/fragments.txt
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "rigid-fragments-index.txt").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open ring-fragments-index.txt", obError);
       return;
@@ -171,7 +171,7 @@
       return coords;
     }
 
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "rigid-fragments.txt").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open rigid-fragments.txt", obError);
       return coords;
Index: openbabel-src/openbabel/src/descriptor.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/descriptor.cpp b/openbabel-src/openbabel/src/descriptor.cpp
--- a/openbabel-src/openbabel/src/descriptor.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/descriptor.cpp	(date 1745583016023)
@@ -25,11 +25,6 @@
 using namespace std;
 namespace OpenBabel
 {
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-  // macro to implement static OBPlugin::PluginMapType& Map()
-  PLUGIN_CPP_FILE(OBDescriptor)
-#endif
-
 /**
      Compare() is a virtual function and can be overridden to allow different
      comparison behaviour.
Index: cairo-src/cairo/src/cairo.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cairo-src/cairo/src/cairo.h b/cairo-src/cairo/src/cairo.h
--- a/cairo-src/cairo/src/cairo.h	(revision 4541e0cd3a751b85e52e2a83d02ac6145a5efa85)
+++ b/cairo-src/cairo/src/cairo.h	(date 1745583015914)
@@ -38,6 +38,7 @@
 #ifndef CAIRO_H
 #define CAIRO_H
 
+#include "cairo_export.h"
 #include "cairo-version.h"
 #include "cairo-features.h"
 #include "cairo-deprecated.h"
@@ -50,6 +51,7 @@
 # define CAIRO_END_DECLS
 #endif
 
+#if 0
 #if (defined(_WIN32) || defined(__CYGWIN__)) && !defined(CAIRO_WIN32_STATIC_BUILD)
 # define _cairo_export __declspec(dllexport)
 # define _cairo_import __declspec(dllimport)
@@ -66,6 +68,8 @@
 #else
 # define _cairo_api _cairo_import
 #endif
+#endif
+# define _cairo_api CAIRO_EXPORT
 
 #define cairo_public _cairo_api extern
 
Index: openbabel-src/openbabel/src/typer.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/typer.cpp b/openbabel-src/openbabel/src/typer.cpp
--- a/openbabel-src/openbabel/src/typer.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/typer.cpp	(date 1745583016039)
@@ -27,8 +27,6 @@
 #include <openbabel/typer.h>
 #include <openbabel/elements.h>
 
-// private data headers with default parameters
-#include "atomtyp.h"
 
 #ifdef WIN32
 #pragma warning (disable : 4786)
@@ -64,7 +62,7 @@
     _envvar = "BABEL_DATADIR";
     _filename = "atomtyp.txt";
     _subdir = "data";
-    _dataptr = AtomTypeData;
+    _dataptr = nullptr;
   }
 
   void OBAtomTyper::ParseLine(const char *buffer)
Index: rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.cpp b/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.cpp	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.cpp	(date 1745583016133)
@@ -45,6 +45,11 @@
 
 TautomerCatalogParams::~TautomerCatalogParams() {}
 
+TautomerCatalogParams::TautomerCatalogParams() {
+    d_typeStr = "Tautomer Catalog Parameters";
+    d_transforms.clear();
+}
+
 const std::vector<TautomerTransform> &TautomerCatalogParams::getTransforms()
     const {
   return d_transforms;
Index: eigen-src/eigen/Eigen/src/Core/util/Macros.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/eigen-src/eigen/Eigen/src/Core/util/Macros.h b/eigen-src/eigen/Eigen/src/Core/util/Macros.h
--- a/eigen-src/eigen/Eigen/src/Core/util/Macros.h	(revision 3147391d946bb4b6c68edd901f2add6ac1f31f8c)
+++ b/eigen-src/eigen/Eigen/src/Core/util/Macros.h	(date 1745583016070)
@@ -59,7 +59,7 @@
 //------------------------------------------------------------------------------------------
 
 /// \internal EIGEN_COMP_GNUC set to 1 for all compilers compatible with GCC
-#ifdef __GNUC__
+#if defined(__GNUC__) && !defined(EMSCRIPTEN)
   #define EIGEN_COMP_GNUC (__GNUC__*10+__GNUC_MINOR__)
 #else
   #define EIGEN_COMP_GNUC 0
Index: indigo-src/indigo/api/c/indigo-inchi/indigo-inchi.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo-inchi/indigo-inchi.h b/indigo-src/indigo/api/c/indigo-inchi/indigo-inchi.h
--- a/indigo-src/indigo/api/c/indigo-inchi/indigo-inchi.h	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo-inchi/indigo-inchi.h	(date 1745583016039)
@@ -20,24 +20,25 @@
 #define __indigo_inchi__
 
 #include "indigo.h"
+#include "indigo_inchi_export.h"
 
-CEXPORT const char* indigoInchiVersion();
+INDIGO_INCHI_EXPORT const char *indigoInchiVersion();
 
-CEXPORT int indigoInchiInit(qword id);
-CEXPORT int indigoInchiDispose(qword id);
+INDIGO_INCHI_EXPORT int indigoInchiInit(qword id);
+INDIGO_INCHI_EXPORT int indigoInchiDispose(qword id);
 
-CEXPORT int indigoInchiResetOptions();
+INDIGO_INCHI_EXPORT int indigoInchiResetOptions();
 
-CEXPORT int indigoInchiLoadMolecule(const char* inchi_string);
+INDIGO_INCHI_EXPORT int indigoInchiLoadMolecule(const char *inchi_string);
 
-CEXPORT const char* indigoInchiGetInchi(int molecule);
+INDIGO_INCHI_EXPORT const char *indigoInchiGetInchi(int molecule);
 
-CEXPORT const char* indigoInchiGetInchiKey(const char* inchi_string);
+INDIGO_INCHI_EXPORT const char *indigoInchiGetInchiKey(const char *inchi_string);
 
-CEXPORT const char* indigoInchiGetWarning();
+INDIGO_INCHI_EXPORT const char *indigoInchiGetWarning();
 
-CEXPORT const char* indigoInchiGetLog();
+INDIGO_INCHI_EXPORT const char *indigoInchiGetLog();
 
-CEXPORT const char* indigoInchiGetAuxInfo();
+INDIGO_INCHI_EXPORT const char *indigoInchiGetAuxInfo();
 
 #endif // __indigo_inchi__
Index: indigo-src/indigo/api/c/indigo-inchi/src/indigo_inchi_api.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo-inchi/src/indigo_inchi_api.cpp b/indigo-src/indigo/api/c/indigo-inchi/src/indigo_inchi_api.cpp
--- a/indigo-src/indigo/api/c/indigo-inchi/src/indigo_inchi_api.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo-inchi/src/indigo_inchi_api.cpp	(date 1745583016023)
@@ -29,7 +29,7 @@
 
 using namespace indigo;
 
-CEXPORT const char* indigoInchiVersion()
+const char* indigoInchiVersion()
 {
     return InchiWrapper::version();
 }
@@ -74,7 +74,7 @@
 // C interface functions
 //
 
-CEXPORT int indigoInchiInit(qword id)
+int indigoInchiInit(qword id)
 {
 #ifdef INDIGO_DEBUG
     std::stringstream ss;
@@ -89,7 +89,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoInchiDispose(qword id)
+int indigoInchiDispose(qword id)
 {
 #ifdef INDIGO_DEBUG
     std::stringstream ss;
@@ -104,14 +104,14 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoInchiResetOptions(void)
+int indigoInchiResetOptions(void)
 {
     IndigoInchiContext& inchi_context = indigoInchiGetInstance();
     inchi_context.init();
     return 0;
 }
 
-CEXPORT int indigoInchiLoadMolecule(const char* inchi_string)
+int indigoInchiLoadMolecule(const char* inchi_string)
 {
     INDIGO_BEGIN
     {
@@ -152,7 +152,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoInchiGetInchi(int molecule)
+const char* indigoInchiGetInchi(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -166,7 +166,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoInchiGetInchiKey(const char* inchi_string)
+const char* indigoInchiGetInchiKey(const char* inchi_string)
 {
     INDIGO_BEGIN
     {
@@ -177,7 +177,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoInchiGetWarning()
+const char* indigoInchiGetWarning()
 {
     InchiWrapper& inchi_wrapper = indigoInchiGetInstance().inchi;
     if (inchi_wrapper.warning.size() != 0)
@@ -185,7 +185,7 @@
     return "";
 }
 
-CEXPORT const char* indigoInchiGetLog()
+const char* indigoInchiGetLog()
 {
     InchiWrapper& inchi_wrapper = indigoInchiGetInstance().inchi;
     if (inchi_wrapper.log.size() != 0)
@@ -193,7 +193,7 @@
     return "";
 }
 
-CEXPORT const char* indigoInchiGetAuxInfo()
+const char* indigoInchiGetAuxInfo()
 {
     InchiWrapper& inchi_wrapper = indigoInchiGetInstance().inchi;
     if (inchi_wrapper.auxInfo.size() != 0)
Index: indigo-src/indigo/api/c/indigo-renderer/indigo-renderer.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo-renderer/indigo-renderer.h b/indigo-src/indigo/api/c/indigo-renderer/indigo-renderer.h
--- a/indigo-src/indigo/api/c/indigo-renderer/indigo-renderer.h	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo-renderer/indigo-renderer.h	(date 1745583016023)
@@ -20,34 +20,35 @@
 #define __indigo_render__
 
 #include "indigo.h"
+#include "indigo_renderer_export.h"
 
-CEXPORT int indigoRendererInit(qword id);
-CEXPORT int indigoRendererDispose(qword id);
+INDIGO_RENDERER_EXPORT int indigoRendererInit(qword id);
+INDIGO_RENDERER_EXPORT int indigoRendererDispose(qword id);
 
 /* Rendering */
 
 // Returns an 'output' object for the given HDC
-CEXPORT int indigoRenderWriteHDC(void* hdc, int printingHdc);
+INDIGO_RENDERER_EXPORT int indigoRenderWriteHDC(void* hdc, int printingHdc);
 
 // output is either a file output obtained via indigoWriteFile(), or
 //        a buffer obtained via indigoWriteBuffer(), or
 //        an HDC obtained via indigoRenderWriteHDC
-CEXPORT int indigoRender(int object, int output);
+INDIGO_RENDERER_EXPORT int indigoRender(int object, int output);
 
 // objects  is an array of molecules created with indigoCreateArray)
 // refAtoms is an array of integers, whose size must be equal to the number
 //          of molecules if the array
 // nColumns is the number of columns in the grid
 // output -- see the comment for indigoRender
-CEXPORT int indigoRenderGrid(int objects, int* refAtoms, int nColumns, int output);
+INDIGO_RENDERER_EXPORT int indigoRenderGrid(int objects, int* refAtoms, int nColumns, int output);
 
 // Works like indigoRender(), but renders directly to file
-CEXPORT int indigoRenderToFile(int object, const char* filename);
+INDIGO_RENDERER_EXPORT int indigoRenderToFile(int object, const char* filename);
 
 // Works like indigoRenderGrid(), but renders directly to file
-CEXPORT int indigoRenderGridToFile(int objects, int* refAtoms, int nColumns, const char* filename);
+INDIGO_RENDERER_EXPORT int indigoRenderGridToFile(int objects, int* refAtoms, int nColumns, const char* filename);
 
 // Resets all the rendering settings
-CEXPORT int indigoRenderReset();
+INDIGO_RENDERER_EXPORT int indigoRenderReset();
 
 #endif
Index: openbabel-src/openbabel/src/obmolecformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/obmolecformat.cpp b/openbabel-src/openbabel/src/obmolecformat.cpp
--- a/openbabel-src/openbabel/src/obmolecformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/obmolecformat.cpp	(date 1745583016008)
@@ -500,12 +500,12 @@
 
     NameIndexType::iterator itr;
 
-    ifstream indexstream;
+    istringstream indexstream;
     OpenDatafile(indexstream, datafilename + ".obindx");
     if(!indexstream)
       {
         //Need to prepare the index
-        ifstream datastream;
+        istringstream datastream;
         string datafilepath = OpenDatafile(datastream, datafilename);
         if(!datastream)
           {
Index: openbabel-src/openbabel/src/phmodel.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/phmodel.cpp b/openbabel-src/openbabel/src/phmodel.cpp
--- a/openbabel-src/openbabel/src/phmodel.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/phmodel.cpp	(date 1745583016008)
@@ -28,8 +28,6 @@
 
 #include <cstdlib>
 
-// private data header with default parameters
-#include "phmodeldata.h"
 
 #ifdef WIN32
 #pragma warning (disable : 4786)
@@ -50,7 +48,7 @@
     _envvar = "BABEL_DATADIR";
     _filename = "phmodel.txt";
     _subdir = "data";
-    _dataptr = PhModelData;
+    _dataptr = nullptr;
   }
 
   OBPhModel::~OBPhModel()
Index: eigen-src/eigen/Eigen/src/Core/util/DisableStupidWarnings.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/eigen-src/eigen/Eigen/src/Core/util/DisableStupidWarnings.h b/eigen-src/eigen/Eigen/src/Core/util/DisableStupidWarnings.h
--- a/eigen-src/eigen/Eigen/src/Core/util/DisableStupidWarnings.h	(revision 3147391d946bb4b6c68edd901f2add6ac1f31f8c)
+++ b/eigen-src/eigen/Eigen/src/Core/util/DisableStupidWarnings.h	(date 1745583016070)
@@ -74,25 +74,25 @@
 #endif
 
 #if defined __NVCC__
-  #pragma diag_suppress boolean_controlling_expr_is_constant
+  #pragma nv_diag_suppress boolean_controlling_expr_is_constant
   // Disable the "statement is unreachable" message
-  #pragma diag_suppress code_is_unreachable
+  #pragma nv_diag_suppress code_is_unreachable
   // Disable the "dynamic initialization in unreachable code" message
-  #pragma diag_suppress initialization_not_reachable
+  #pragma nv_diag_suppress initialization_not_reachable
   // Disable the "invalid error number" message that we get with older versions of nvcc
-  #pragma diag_suppress 1222
+  #pragma nv_diag_suppress 1222
   // Disable the "calling a __host__ function from a __host__ __device__ function is not allowed" messages (yes, there are many of them and they seem to change with every version of the compiler)
-  #pragma diag_suppress 2527
-  #pragma diag_suppress 2529
-  #pragma diag_suppress 2651
-  #pragma diag_suppress 2653
-  #pragma diag_suppress 2668
-  #pragma diag_suppress 2669
-  #pragma diag_suppress 2670
-  #pragma diag_suppress 2671
-  #pragma diag_suppress 2735
-  #pragma diag_suppress 2737
-  #pragma diag_suppress 2739
+  #pragma nv_diag_suppress 2527
+  #pragma nv_diag_suppress 2529
+  #pragma nv_diag_suppress 2651
+  #pragma nv_diag_suppress 2653
+  #pragma nv_diag_suppress 2668
+  #pragma nv_diag_suppress 2669
+  #pragma nv_diag_suppress 2670
+  #pragma nv_diag_suppress 2671
+  #pragma nv_diag_suppress 2735
+  #pragma nv_diag_suppress 2737
+  #pragma nv_diag_suppress 2739
 #endif
 
 #else
Index: openbabel-src/openbabel/src/plugin.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/plugin.cpp b/openbabel-src/openbabel/src/plugin.cpp
--- a/openbabel-src/openbabel/src/plugin.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/plugin.cpp	(date 1745583016023)
@@ -285,6 +285,8 @@
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theHINFormat)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theJaguarOutputFormat)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theJaguarInputFormat)->GetID());
+  plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theChemDoodleJSONFormat)->GetID());
+  plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&thePubChemJSONFormat)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theLMPDATFormat)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theMCDLFormat)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theMOLFormat)->GetID());
@@ -315,6 +317,7 @@
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&thePDBQTFormat)->GetID());
 #ifdef HAVE_LIBZ
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&thePNGFormat)->GetID());
+  plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&thePNG2Format)->GetID());
 #endif
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&thePointCloudFormat)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&thePovrayFormat)->GetID());
@@ -354,6 +357,8 @@
 #endif
 #ifdef HAVE_STATIC_INCHI
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theInChIFormat)->GetID());
+  plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theInChICompareFormat)->GetID());
+  plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theInChIKeyFormat)->GetID());
 #endif
 #ifdef HAVE_RPC_XDR_H
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theXTCFormat)->GetID());
@@ -413,6 +418,7 @@
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOpFillUC)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOpEnergy)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOpMinimize)->GetID());
+  plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOp2D)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOpGen2D)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOpGen3D)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOpNewS)->GetID());
Index: rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.h b/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.h
--- a/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.h	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.h	(date 1745583016133)
@@ -36,10 +36,7 @@
 class RDKIT_MOLSTANDARDIZE_EXPORT TautomerCatalogParams
     : public RDCatalog::CatalogParams {
  public:
-  TautomerCatalogParams() {
-    d_typeStr = "Tautomer Catalog Parameters";
-    d_transforms.clear();
-  }
+  TautomerCatalogParams();
 
   TautomerCatalogParams(const std::string &tautomerFile);
   TautomerCatalogParams(const TautomerTransformDefs &data);
Index: opencv-src/opencv/modules/core/src/parallel.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/core/src/parallel.cpp b/opencv-src/opencv/modules/core/src/parallel.cpp
--- a/opencv-src/opencv/modules/core/src/parallel.cpp	(revision 31b0eeea0b44b370fd0712312df4214d4ae1b158)
+++ b/opencv-src/opencv/modules/core/src/parallel.cpp	(date 1745583016039)
@@ -80,7 +80,7 @@
     #include <thread>
 #endif
 
-#ifdef _OPENMP
+#if defined(_OPENMP) && !defined(HAVE_OPENMP)
     #define HAVE_OPENMP
 #endif
 
Index: openbabel-src/openbabel/src/rotor.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/rotor.cpp b/openbabel-src/openbabel/src/rotor.cpp
--- a/openbabel-src/openbabel/src/rotor.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/rotor.cpp	(date 1745583016008)
@@ -31,8 +31,6 @@
 #include <set>
 #include <assert.h>
 
-// private data headers with default parameters
-#include "torlib.h"
 
 #ifndef M_PI
 #define M_PI 3.14159265358979323846
@@ -806,7 +804,7 @@
     _envvar = "BABEL_DATADIR";
     _filename = "torlib.txt";
     _subdir = "data";
-    _dataptr = TorsionDefaults;
+    _dataptr = nullptr;
   }
 
   void OBRotorRules::ParseLine(const char *buffer)
Index: openbabel-src/openbabel/src/chargemodel.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/chargemodel.cpp b/openbabel-src/openbabel/src/chargemodel.cpp
--- a/openbabel-src/openbabel/src/chargemodel.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/chargemodel.cpp	(date 1745583016039)
@@ -26,11 +26,6 @@
 using namespace std;
 namespace OpenBabel
 {
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-  // macro to implement static OBPlugin::PluginMapType& Map()
-  PLUGIN_CPP_FILE(OBChargeModel)
-#endif
-
   void OBChargeModel::FillChargeVectors(OBMol &mol)
   {
     OBAtom *atom;
Index: openbabel-src/openbabel/src/fingerprint.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/fingerprint.cpp b/openbabel-src/openbabel/src/fingerprint.cpp
--- a/openbabel-src/openbabel/src/fingerprint.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/fingerprint.cpp	(date 1745583016039)
@@ -30,11 +30,6 @@
 using namespace std;
 namespace OpenBabel
 {
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-  // macro to implement static OBPlugin::PluginMapType& Map()
-  PLUGIN_CPP_FILE(OBFingerprint)
-#endif
-
   const unsigned int OBFingerprint::bitsperint = 8 * sizeof(unsigned int);
 
   void OBFingerprint::SetBit(vector<unsigned int>& vec, const unsigned int n)
Index: openbabel-src/openbabel/src/oberror.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/oberror.cpp b/openbabel-src/openbabel/src/oberror.cpp
--- a/openbabel-src/openbabel/src/oberror.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/oberror.cpp	(date 1745583015976)
@@ -22,6 +22,7 @@
 #include <iostream>
 #include <string>
 #include <algorithm>
+#include <mutex>
 
 #include <openbabel/oberror.h>
 
@@ -162,6 +163,8 @@
 
   void OBMessageHandler::ThrowError(OBError err, errorQualifier qualifier)
   {
+    static std::mutex mutex_;
+    std::unique_lock lk(mutex_);
     if (!_logging)
       return;
 
@@ -182,6 +185,8 @@
                                     const std::string &errorMsg,
                                     obMessageLevel level, errorQualifier qualifier)
   {
+    static std::mutex mutex_;
+    std::unique_lock lk(mutex_);
     if (errorMsg.length() > 1)
       {
         OBError err(method, errorMsg, "", "", "", level);
@@ -191,6 +196,8 @@
 
   std::vector<std::string> OBMessageHandler::GetMessagesOfLevel(const obMessageLevel level)
   {
+    static std::mutex mutex_;
+    std::unique_lock lk(mutex_);
     vector<string> results;
     deque<OBError>::iterator i;
     OBError error;
@@ -207,6 +214,8 @@
 
   bool OBMessageHandler::StartErrorWrap()
   {
+    static std::mutex mutex_;
+    std::unique_lock lk(mutex_);
     if (_inWrapStreamBuf != nullptr)
       return true; // already wrapped cerr  -- don't go into loops!
 
@@ -223,6 +232,8 @@
 
   bool OBMessageHandler::StopErrorWrap()
   {
+    static std::mutex mutex_;
+    std::unique_lock lk(mutex_);
     if (_inWrapStreamBuf == nullptr)
       return true; // never wrapped cerr
 
@@ -237,6 +248,8 @@
 
   string OBMessageHandler::GetMessageSummary()
   {
+    static std::mutex mutex_;
+    std::unique_lock lk(mutex_);
     stringstream summary;
     if (_messageCount[obError] > 0)
       summary << _messageCount[obError] << " errors ";
Index: indigo-src/indigo/api/c/indigo-renderer/src/indigo_render2d.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo-renderer/src/indigo_render2d.cpp b/indigo-src/indigo/api/c/indigo-renderer/src/indigo_render2d.cpp
--- a/indigo-src/indigo/api/c/indigo-renderer/src/indigo_render2d.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/api/c/indigo-renderer/src/indigo_render2d.cpp	(date 1745649162404)
@@ -370,7 +370,7 @@
         value.readString("right", true);
 }
 
-CEXPORT int indigoRendererInit(qword id)
+int indigoRendererInit(qword id)
 {
 #ifdef INDIGO_DEBUG
     std::stringstream ss;
@@ -386,7 +386,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRendererDispose(const qword id)
+int indigoRendererDispose(const qword id)
 {
 #ifdef INDIGO_DEBUG
     std::stringstream ss;
@@ -424,7 +424,7 @@
     }
 }
 
-CEXPORT int indigoRender(int object, int output)
+int indigoRender(int object, int output)
 {
     INDIGO_BEGIN
     {
@@ -484,7 +484,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRenderGrid(int objects, int* refAtoms, int nColumns, int output)
+int indigoRenderGrid(int objects, int* refAtoms, int nColumns, int output)
 {
     INDIGO_BEGIN
     {
@@ -610,7 +610,7 @@
     return indigoRenderMapOutputFormat(ext + 1);
 }
 
-CEXPORT int indigoRenderToFile(int object, const char* filename)
+int indigoRenderToFile(int object, const char* filename)
 {
     int f = indigoWriteFile(filename);
 
@@ -627,7 +627,7 @@
     return res;
 }
 
-CEXPORT int indigoRenderGridToFile(int objects, int* refAtoms, int nColumns, const char* filename)
+int indigoRenderGridToFile(int objects, int* refAtoms, int nColumns, const char* filename)
 {
     int f = indigoWriteFile(filename);
 
@@ -644,7 +644,7 @@
     return res;
 }
 
-CEXPORT int indigoRenderReset()
+int indigoRenderReset()
 {
     INDIGO_BEGIN
     {
@@ -655,13 +655,13 @@
     INDIGO_END(-1);
 }
 
-CEXPORT void indigoRenderResetOptions()
+void indigoRenderResetOptions()
 {
     indigoRendererGetInstance().init();
     getCdxmlContext().clear();
 }
 
-CEXPORT int indigoRenderWriteHDC(void* hdc, int printingHdc)
+int indigoRenderWriteHDC(void* hdc, int printingHdc)
 {
     INDIGO_BEGIN
     {
Index: eigen-src/eigen/Eigen/src/Core/util/ConfigureVectorization.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/eigen-src/eigen/Eigen/src/Core/util/ConfigureVectorization.h b/eigen-src/eigen/Eigen/src/Core/util/ConfigureVectorization.h
--- a/eigen-src/eigen/Eigen/src/Core/util/ConfigureVectorization.h	(revision 3147391d946bb4b6c68edd901f2add6ac1f31f8c)
+++ b/eigen-src/eigen/Eigen/src/Core/util/ConfigureVectorization.h	(date 1745583016054)
@@ -339,7 +339,7 @@
     extern "C" {
       // In theory we should only include immintrin.h and not the other *mmintrin.h header files directly.
       // Doing so triggers some issues with ICC. However old gcc versions seems to not have this file, thus:
-      #if EIGEN_COMP_ICC >= 1110
+      #if EIGEN_COMP_ICC >= 1110 || EIGEN_COMP_EMSCRIPTEN
         #include <immintrin.h>
       #else
         #include <mmintrin.h>
Index: openbabel-src/openbabel/src/forcefield.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/forcefield.cpp b/openbabel-src/openbabel/src/forcefield.cpp
--- a/openbabel-src/openbabel/src/forcefield.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/forcefield.cpp	(date 1745583015992)
@@ -40,11 +40,6 @@
 
 namespace OpenBabel
 {
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-  // macro to implement static OBPlugin::PluginMapType& Map()
-  PLUGIN_CPP_FILE(OBForceField)
-#endif
-
   /** \class OBForceField forcefield.h <openbabel/forcefield.h>
       \brief Base class for molecular mechanics force fields
 
Index: openbabel-src/openbabel/src/patty.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/patty.cpp b/openbabel-src/openbabel/src/patty.cpp
--- a/openbabel-src/openbabel/src/patty.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/patty.cpp	(date 1745583016054)
@@ -25,6 +25,7 @@
 
 #include <cstring>
 #include <cstdlib>
+#include <fstream>
 
 // Simple programmable atom typer
 // WPW - 070199
Index: openbabel-src/openbabel/src/tokenst.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/tokenst.cpp b/openbabel-src/openbabel/src/tokenst.cpp
--- a/openbabel-src/openbabel/src/tokenst.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/tokenst.cpp	(date 1745583016008)
@@ -24,7 +24,7 @@
 #include <limits>
 #include <cstring>
 #include <openbabel/tokenst.h>
-
+#include "text_assets.hpp"
 using namespace std;
 
 namespace OpenBabel
@@ -180,7 +180,7 @@
      or "BABEL_DATADIR" if @p envvar is not specified, or the compiled-in
      macro BABEL_DATADIR if the environment variable is not set
 
-     \param ifs        Stream to load
+     \param iss        Stream to load
      \param filename   Name of the data file to load
      \param envvar     Name of the environment variable
 
@@ -188,51 +188,16 @@
      unless it is in current directory
 
   **/
-  std::string OpenDatafile(std::ifstream& ifs, const std::string& filename,
+  std::string OpenDatafile(std::istringstream& iss, const std::string& filename,
                            const std::string& envvar)
   {
-    ios_base::openmode imode = ios_base::in;
-    #ifdef ALL_READS_BINARY //Makes unix files compatible with VC++6
-      imode = ios_base::in|ios_base::binary;
-    #endif
-
-    // check the current directory
-    ifs.close();
-    ifs.clear();
-    ifs.open(filename.c_str(),imode);
-    if(ifs)
-      return filename;
-
-    string file;
-    const char* datadir = getenv(envvar.c_str());
-    if(!datadir)
-      datadir = BABEL_DATADIR;
-
-    // check the subdirectory for this version number
-    file = datadir;
-    file += FILE_SEP_CHAR;
-    file += BABEL_VERSION;
-    file += FILE_SEP_CHAR + filename;
-
-    ifs.clear();
-    ifs.open(file.c_str(),imode);
-    if(ifs)
-      return file;
-
-    // couldn't find it with the version built in, so try the parent
-    file = datadir;
-    file += FILE_SEP_CHAR;
-    file += filename;
-
-    ifs.clear();
-    ifs.open(file.c_str(),imode);
-
-    if (ifs)
-      return file;
-
-    ifs.clear();
-    ifs.close();
-    return(""); // error
+    auto it = openbabel::OPENBABEL_ASSET_MAP.find(filename);
+    if(it==openbabel::OPENBABEL_ASSET_MAP.end()) {
+        return "";
+    }
+    iss.clear();
+    iss.str(it->second);
+    return filename;
   }
 
 
Index: rdkit-src/rdkit/Contrib/PBF/PBFRDKit.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Contrib/PBF/PBFRDKit.cpp b/rdkit-src/rdkit/Contrib/PBF/PBFRDKit.cpp
--- a/rdkit-src/rdkit/Contrib/PBF/PBFRDKit.cpp	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Contrib/PBF/PBFRDKit.cpp	(date 1745583016179)
@@ -114,7 +114,7 @@
   if (eigensolver.info() != Eigen::Success) {
     BOOST_LOG(rdErrorLog) << "eigenvalue calculation did not converge"
                           << std::endl;
-    return 0.0;
+    return false;
   }
   RDGeom::Point3D normal;
   normal.x = eigensolver.eigenvectors()(0, 0);
@@ -125,6 +125,7 @@
   plane[1] = normal.y;
   plane[2] = normal.z;
   plane[3] = -1 * normal.dotProduct(origin);
+  return true;
 }
 
 double PBFRD(ROMol &mol, int confId) {
Index: indigo-src/indigo/core/indigo-core/molecule/src/haworth_projection_finder.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/molecule/src/haworth_projection_finder.cpp b/indigo-src/indigo/core/indigo-core/molecule/src/haworth_projection_finder.cpp
--- a/indigo-src/indigo/core/indigo-core/molecule/src/haworth_projection_finder.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/core/indigo-core/molecule/src/haworth_projection_finder.cpp	(date 1745583016179)
@@ -12,6 +12,11 @@
 
 CP_DEF(HaworthProjectionFinder);
 
+template<typename T>
+inline auto indigo_get_sign(T a){
+    return (a > 0 ? 1 : (a < 0 ? -1 : 0));
+}
+
 const float COS10_THRESHOLD = 0.015f;
 
 HaworthProjectionFinder::HaworthProjectionFinder(BaseMolecule& mol)
@@ -147,8 +152,8 @@
 
         float s = _getAngleSin(vi, e1i, e2i);
         if (sign == 0)
-            sign = __sign(s);
-        else if (sign != __sign(s))
+            sign = indigo_get_sign(s);
+        else if (sign != indigo_get_sign(s))
             return false; // Rotation direction is different => non-convex
 
         bool is_corner = _isCornerVertex(vi, e1i, e2i);
@@ -219,8 +224,8 @@
             {
                 // Count only non-horizontal bonds
                 if (sub_sign == 0)
-                    sub_sign = __sign(c2);
-                else if (sub_sign == __sign(c2))
+                    sub_sign = indigo_get_sign(c2);
+                else if (sub_sign == indigo_get_sign(c2))
                     return false; // Substituents are in the same direction
             }
         }
@@ -329,7 +334,7 @@
     float yn = _mol.getAtomXyz(vertices[left_next]).y;
     float yp = _mol.getAtomXyz(vertices[left_prev]).y;
 
-    int parity = __sign(yn - yp);
+    int parity = indigo_get_sign(yn - yp);
 
     for (int j = 0; j < vertices.size(); j++)
     {
@@ -410,7 +415,7 @@
     Vec2f d1(pv1.x - pv.x, pv1.y - pv.y);
     Vec2f d2(pv2.x - pv.x, pv2.y - pv.y);
 
-    return __sign(d1.x * d2.x) == 1;
+    return indigo_get_sign(d1.x * d2.x) == 1;
 }
 
 bool HaworthProjectionFinder::_isHorizontalEdge(int e, float cos_threshold)
Index: openbabel-src/openbabel/src/ops/unique.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/ops/unique.cpp b/openbabel-src/openbabel/src/ops/unique.cpp
--- a/openbabel-src/openbabel/src/ops/unique.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/ops/unique.cpp	(date 1745583016070)
@@ -39,7 +39,7 @@
   #ifdef _LIBCPP_VERSION
     using std::unordered_map;
   #else
-    using std::tr1::unordered_map;
+    using std::unordered_map;
   #endif
 #endif
 namespace OpenBabel
Index: opencv-src/opencv/modules/core/src/utils/datafile.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/core/src/utils/datafile.cpp b/opencv-src/opencv/modules/core/src/utils/datafile.cpp
--- a/opencv-src/opencv/modules/core/src/utils/datafile.cpp	(revision 31b0eeea0b44b370fd0712312df4214d4ae1b158)
+++ b/opencv-src/opencv/modules/core/src/utils/datafile.cpp	(date 1745583016054)
@@ -110,6 +110,7 @@
 static cv::String getModuleLocation(const void* addr)
 {
     CV_UNUSED(addr);
+#ifdef OPENCV_HAVE_FILESYSTEM_SUPPORT
 #ifdef _WIN32
     HMODULE m = 0;
 #if _WIN32_WINNT >= 0x0501 && (!defined(WINAPI_FAMILY) || (WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP))
@@ -151,6 +152,7 @@
 # endif
 #else
     // not supported, skip
+#endif
 #endif
     return cv::String();
 }
Index: openbabel-src/openbabel/src/ops/op2d.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/ops/op2d.cpp b/openbabel-src/openbabel/src/ops/op2d.cpp
--- a/openbabel-src/openbabel/src/ops/op2d.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/ops/op2d.cpp	(date 1745583016070)
@@ -25,12 +25,13 @@
 #include <openbabel/babelconfig.h>
 #include <iostream>
 #include<openbabel/op.h>
+#include<openbabel/atom.h>
 #include<openbabel/mol.h>
+#include<openbabel/oberror.h>
 #include <RDKitConv.h>
 #include <GraphMol/Depictor/RDDepictor.h>
 #include <Geometry/point.h>
-#include <GraphMol/conformer.h>
-#include <GraphMol/molops.h>
+#include <GraphMol/MolOps.h>
 
 #ifndef OBERROR
  #define OBERROR
@@ -49,13 +50,13 @@
   }
   virtual bool WorksWith(OBBase* pOb)const{ return dynamic_cast<OBMol*>(pOb)!=NULL; }
 
-  virtual bool Do(OBBase* pOb, OpMap*, const char* OptionText);
+  virtual bool Do(OBBase* pOb, const char*, OpMap*, OBConversion*);
 };
 
 Op2D theOp2D("2D"); //Global instance
 
 /////////////////////////////////////////////////////////////////
-bool Op2D::Do(OBBase* pOb, OpMap*, const char* OptionText)
+bool Op2D::Do(OBBase* pOb, const char*, OpMap*, OBConversion*)
 {
   OBMol* pmol = dynamic_cast<OBMol*>(pOb);
   if(!pmol)
Index: openbabel-src/openbabel/src/ops/optransform.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/ops/optransform.cpp b/openbabel-src/openbabel/src/ops/optransform.cpp
--- a/openbabel-src/openbabel/src/ops/optransform.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/ops/optransform.cpp	(date 1745583016070)
@@ -40,9 +40,7 @@
 {
   _dataLoaded=true;
   _transforms.clear();
-  ifstream ifs;
-  if(ifs.is_open())
-    ifs.close();
+  istringstream ifs;
   char charBuffer[BUFF_SIZE];
 
   // Set the locale for number parsing to avoid locale issues: PR#1785463
Index: arrow-src/arrow/cpp/src/arrow/dataset/visibility.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/arrow-src/arrow/cpp/src/arrow/dataset/visibility.h b/arrow-src/arrow/cpp/src/arrow/dataset/visibility.h
--- a/arrow-src/arrow/cpp/src/arrow/dataset/visibility.h	(revision 272715f6df2a042d69881ffa03d5078c58e4b345)
+++ b/arrow-src/arrow/cpp/src/arrow/dataset/visibility.h	(date 1745649506139)
@@ -19,6 +19,7 @@
 
 #pragma once
 
+#if 0
 #if defined(_WIN32) || defined(__CYGWIN__)
 #  if defined(_MSC_VER)
 #    pragma warning(push)
@@ -48,3 +49,15 @@
 #if defined(_MSC_VER)
 #  pragma warning(pop)
 #endif
+
+#endif
+
+#include <arrow/util/visibility.h>
+
+#ifndef ARROW_DS_EXPORT
+#define ARROW_DS_EXPORT ARROW_EXPORT
+#endif
+
+#ifndef ARROW_DS_NO_EXPORT
+#define ARROW_DS_NO_EXPORT ARROW_NO_EXPORT
+#endif
Index: openbabel-src/openbabel/src/ops/sort.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/ops/sort.cpp b/openbabel-src/openbabel/src/ops/sort.cpp
--- a/openbabel-src/openbabel/src/ops/sort.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/ops/sort.cpp	(date 1745583016070)
@@ -29,7 +29,7 @@
 {
 
 template<class T>
-struct Order : public std::binary_function<std::pair<OBBase*,T>, std::pair<OBBase*,T>, bool>
+struct Order
 {
   Order(OBDescriptor* pDesc, bool rev) : _pDesc(pDesc), _rev(rev){}
   bool operator()(std::pair<OBBase*,T> p1, std::pair<OBBase*,T> p2) const
Index: openbabel-src/openbabel/src/ops/gen3d.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/ops/gen3d.cpp b/openbabel-src/openbabel/src/ops/gen3d.cpp
--- a/openbabel-src/openbabel/src/ops/gen3d.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/ops/gen3d.cpp	(date 1745583016070)
@@ -70,8 +70,10 @@
   bool useDistGeom = false;
 
   // first try converting OptionText to an integer
-  char *endptr;
-  speed = strtol(OptionText, &endptr, 10);
+  char *endptr = nullptr;
+  if (OptionText) {
+    speed = strtol(OptionText, &endptr, 10);
+  }
   if (endptr == OptionText) { // not a number
     speed = 3; // we'll default to balanced
     // but let's also check if it's words like "fast" or "best"
@@ -131,12 +133,12 @@
       return true; // done
 
     // All other speed levels do some FF cleanup
-    // Try MMFF94 first and UFF if that doesn't work
-    OBForceField* pFF = OBForceField::FindForceField("MMFF94");
+    // Try UFF first and MMFF94 if that doesn't work
+    OBForceField* pFF = OBForceField::FindForceField("UFF");
     if (!pFF)
       return true;
     if (!pFF->Setup(molCopy)) {
-      pFF = OBForceField::FindForceField("UFF");
+      pFF = OBForceField::FindForceField("MMFF94");
       if (!pFF || !pFF->Setup(molCopy)) return true; // can't use either MMFF94 or UFF
     }
 
Index: rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTree.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTree.h b/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTree.h
--- a/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTree.h	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTree.h	(date 1745583015883)
@@ -13,7 +13,7 @@
 #define _RD_FEATTREE_H_
 
 #include <boost/graph/adjacency_list.hpp>
-#include <boost/property_map.hpp>
+#include <boost/property_map/property_map.hpp>
 #include <boost/shared_ptr.hpp>
 #include <set>
 
Index: rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTreeUtils.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTreeUtils.cpp b/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTreeUtils.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTreeUtils.cpp	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTreeUtils.cpp	(date 1745583015883)
@@ -16,7 +16,7 @@
 #include "FeatTree.h"
 
 #include <boost/graph/biconnected_components.hpp>
-#include <boost/property_map.hpp>
+#include <boost/property_map/property_map.hpp>
 #include <map>
 #include <set>
 
Index: openbabel-src/openbabel/src/ops/loader.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/ops/loader.cpp b/openbabel-src/openbabel/src/ops/loader.cpp
--- a/openbabel-src/openbabel/src/ops/loader.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/ops/loader.cpp	(date 1745583016070)
@@ -35,11 +35,6 @@
   const char* TypeID(){return "loaders";};
 };
 
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-// macro to implement static OBPlugin::PluginMapType& Map()
-PLUGIN_CPP_FILE(OBLoader)
-#endif
-
 //*********************************************************
 ///Class which makes instances of plugin classes from information in text file.
 ///This allows the commandline and GUI interfaces to be extended without recompiling.
@@ -55,7 +50,7 @@
   OBDefine(const char* ID, const char* filename)
     : OBLoader(ID, false), _filename(filename)
   {
-    ifstream ifs;
+    istringstream ifs;
     bool filefound = !OpenDatafile(ifs, filename).empty();
     if(!ifs)
     {
Index: openbabel-src/openbabel/src/depict/depict.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/depict/depict.cpp b/openbabel-src/openbabel/src/depict/depict.cpp
--- a/openbabel-src/openbabel/src/depict/depict.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/depict/depict.cpp	(date 1745583016086)
@@ -1235,7 +1235,7 @@
                       end.x() - offset.x(), end.y() - offset.y());
 
     static const float dashpattern[] = {5., 5.};
-    static const vector<double> pat = vector<double>(dashpattern,dashpattern + sizeof(dashpattern)/sizeof(double));
+    static const vector<double> pat = vector<double>(dashpattern, dashpattern + sizeof(dashpattern)/sizeof(float));
     painter->DrawLine(begin.x() + offset.x(), begin.y() + offset.y(),
                       end.x() + offset.x(), end.y() + offset.y(), pat);
   }
Index: openbabel-src/openbabel/src/math/matrix3x3.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/math/matrix3x3.cpp b/openbabel-src/openbabel/src/math/matrix3x3.cpp
--- a/openbabel-src/openbabel/src/math/matrix3x3.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/math/matrix3x3.cpp	(date 1745583016070)
@@ -545,7 +545,7 @@
     eigenvectors. The eigenvectors are normalized and mutually
     orthogonal.
   */
-  void matrix3x3::jacobi(unsigned int n, double *a, double *d, double *v)
+  void matrix3x3::jacobi(int n, double *a, double *d, double *v)
   {
     double onorm, dnorm;
     double b, dma, q, t, c, s;
@@ -557,9 +557,9 @@
 
     // Set v to the identity matrix, set the vector d to contain the
     // diagonal elements of the matrix a
-    for (j = 0; j < static_cast<int>(n); j++)
+    for (j = 0; j < n; j++)
       {
-        for (i = 0; i < static_cast<int>(n); i++)
+        for (i = 0; i < n; i++)
           v[n*i+j] = 0.0;
         v[n*j+j] = 1.0;
         d[j] = a[n*j+j];
@@ -572,7 +572,7 @@
         // onorm to the maximum norm of the off-diagonal elements
         dnorm = 0.0;
         onorm = 0.0;
-        for (j = 0; j < static_cast<int>(n); j++)
+        for (j = 0; j < n; j++)
           {
             dnorm += (double)fabs(d[j]);
             for (i = 0; i < j; i++)
@@ -582,7 +582,7 @@
         if((onorm/dnorm) <= 1.0e-12)
           goto Exit_now;
 
-        for (j = 1; j < static_cast<int>(n); j++)
+        for (j = 1; j < n; j++)
           {
             for (i = 0; i <= j - 1; i++)
               {
@@ -619,14 +619,14 @@
                         a[n*i+k] = atemp;
                       }
 
-                    for (k = j+1; k < static_cast<int>(n); k++)
+                    for (k = j+1; k < n; k++)
                       {
                         atemp = c * a[n*i+k] - s * a[n*j+k];
                         a[n*j+k] = s * a[n*i+k] + c * a[n*j+k];
                         a[n*i+k] = atemp;
                       }
 
-                    for (k = 0; k < static_cast<int>(n); k++)
+                    for (k = 0; k < n; k++)
                       {
                         vtemp = c * v[n*k+i] - s * v[n*k+j];
                         v[n*k+j] = s * v[n*k+i] + c * v[n*k+j];
@@ -647,11 +647,11 @@
     // smallest eigenvalues come first.
     nrot = l;
 
-    for (j = 0; j < static_cast<int>(n)-1; j++)
+    for (j = 0; j < n-1; j++)
       {
         k = j;
         dtemp = d[k];
-        for (i = j+1; i < static_cast<int>(n); i++)
+        for (i = j+1; i < n; i++)
           if(d[i] < dtemp)
             {
               k = i;
@@ -662,7 +662,7 @@
           {
             d[k] = d[j];
             d[j] = dtemp;
-            for (i = 0; i < static_cast<int>(n); i++)
+            for (i = 0; i < n; i++)
               {
                 dtemp = v[n*i+k];
                 v[n*i+k] = v[n*i+j];
Index: boost-src/boost/libs/serialization/src/text_wiarchive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/text_wiarchive.cpp b/boost-src/boost/libs/serialization/src/text_wiarchive.cpp
--- a/boost-src/boost/libs/serialization/src/text_wiarchive.cpp	(revision a20c4d97c37e5f437c8ba78f296830edb79cff9e)
+++ b/boost-src/boost/libs/serialization/src/text_wiarchive.cpp	(date 1745583016164)
@@ -14,6 +14,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/text_wiarchive.hpp>
Index: openbabel-src/openbabel/src/charges/qeq.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/charges/qeq.cpp b/openbabel-src/openbabel/src/charges/qeq.cpp
--- a/openbabel-src/openbabel/src/charges/qeq.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/charges/qeq.cpp	(date 1745583016086)
@@ -15,7 +15,7 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 ***********************************************************************/
-
+#include <openbabel/babelconfig.h>
 #ifdef HAVE_EIGEN
 
 #include "qeq.h"
@@ -125,7 +125,7 @@
     char buffer[BUFF_SIZE];
 
     // open data/qeq.txt
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "qeq.txt").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open qeq.txt", obError);
       return;
Index: rdkit-src/rdkit/Code/GraphMol/MolAlign/O3AAlignMolecules.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/MolAlign/O3AAlignMolecules.h b/rdkit-src/rdkit/Code/GraphMol/MolAlign/O3AAlignMolecules.h
--- a/rdkit-src/rdkit/Code/GraphMol/MolAlign/O3AAlignMolecules.h	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Code/GraphMol/MolAlign/O3AAlignMolecules.h	(date 1745583015914)
@@ -27,7 +27,7 @@
 
 namespace RDKit {
 namespace MolAlign {
-struct RDKIT_MOLALIGN_EXPORT O3AFuncData {
+struct RDKIT_O3AALIGN_EXPORT O3AFuncData {
   const Conformer *prbConf;
   const Conformer *refConf;
   void *prbProp;
@@ -46,7 +46,7 @@
 //! is defined by a pair of atom indexes (one for the probe,
 //! one for the reference) and a weight. Constraints can
 //! can be added via the O3AConstraintVect class.
-class RDKIT_MOLALIGN_EXPORT O3AConstraint {
+class RDKIT_O3AALIGN_EXPORT O3AConstraint {
   friend class O3AConstraintVect;
 
  public:
@@ -66,7 +66,7 @@
 //! method is invoked, the vector is sorted to make lookup faster.
 //! Hence, constraints are not necessarily stored in the same order
 //! they were appended.
-class RDKIT_MOLALIGN_EXPORT O3AConstraintVect {
+class RDKIT_O3AALIGN_EXPORT O3AConstraintVect {
  public:
   O3AConstraintVect() {}
   ~O3AConstraintVect() = default;
@@ -128,7 +128,7 @@
   O3_LOCAL_ONLY = (1 << 2)
 };
 
-class RDKIT_MOLALIGN_EXPORT MolHistogram {
+class RDKIT_O3AALIGN_EXPORT MolHistogram {
  public:
   MolHistogram(const ROMol &mol, const double *dmat, bool cleanupDmat = false);
   ~MolHistogram() = default;
@@ -142,7 +142,7 @@
   boost::multi_array<int, 2> d_h;
 };
 
-class RDKIT_MOLALIGN_EXPORT LAP {
+class RDKIT_O3AALIGN_EXPORT LAP {
  public:
   LAP(unsigned int dim)
       : d_rowSol(dim),
@@ -184,7 +184,7 @@
   boost::multi_array<int, 2> d_cost;
 };
 
-class RDKIT_MOLALIGN_EXPORT SDM {
+class RDKIT_O3AALIGN_EXPORT SDM {
  public:
   // constructor
   SDM(const Conformer *prbConf = nullptr, const Conformer *refConf = nullptr,
@@ -271,7 +271,7 @@
   }
 };
 
-class RDKIT_MOLALIGN_EXPORT O3A {
+class RDKIT_O3AALIGN_EXPORT O3A {
  public:
   //! pre-defined atom typing schemes
   typedef enum { MMFF94 = 0, CRIPPEN } AtomTypeScheme;
@@ -319,30 +319,30 @@
   double d_o3aScore;
 };
 
-RDKIT_MOLALIGN_EXPORT void randomTransform(ROMol &mol, const int cid = -1,
+RDKIT_O3AALIGN_EXPORT void randomTransform(ROMol &mol, const int cid = -1,
                                            const int seed = -1);
-RDKIT_MOLALIGN_EXPORT const RDGeom::POINT3D_VECT *reflect(
+RDKIT_O3AALIGN_EXPORT const RDGeom::POINT3D_VECT *reflect(
     const Conformer &conf);
-RDKIT_MOLALIGN_EXPORT int o3aMMFFCostFunc(const unsigned int prbIdx,
+RDKIT_O3AALIGN_EXPORT int o3aMMFFCostFunc(const unsigned int prbIdx,
                                           const unsigned int refIdx,
                                           double hSum, void *data);
-RDKIT_MOLALIGN_EXPORT double o3aMMFFWeightFunc(const unsigned int prbIdx,
+RDKIT_O3AALIGN_EXPORT double o3aMMFFWeightFunc(const unsigned int prbIdx,
                                                const unsigned int refIdx,
                                                void *data);
-RDKIT_MOLALIGN_EXPORT double o3aMMFFScoringFunc(const unsigned int prbIdx,
+RDKIT_O3AALIGN_EXPORT double o3aMMFFScoringFunc(const unsigned int prbIdx,
                                                 const unsigned int refIdx,
                                                 void *data);
-RDKIT_MOLALIGN_EXPORT int o3aCrippenCostFunc(const unsigned int prbIdx,
+RDKIT_O3AALIGN_EXPORT int o3aCrippenCostFunc(const unsigned int prbIdx,
                                              const unsigned int refIdx,
                                              double hSum, void *data);
-RDKIT_MOLALIGN_EXPORT double o3aCrippenWeightFunc(const unsigned int prbIdx,
+RDKIT_O3AALIGN_EXPORT double o3aCrippenWeightFunc(const unsigned int prbIdx,
                                                   const unsigned int refIdx,
                                                   void *data);
-RDKIT_MOLALIGN_EXPORT double o3aCrippenScoringFunc(const unsigned int prbIdx,
+RDKIT_O3AALIGN_EXPORT double o3aCrippenScoringFunc(const unsigned int prbIdx,
                                                    const unsigned int refIdx,
                                                    void *data);
 
-RDKIT_MOLALIGN_EXPORT void getO3AForProbeConfs(
+RDKIT_O3AALIGN_EXPORT void getO3AForProbeConfs(
     ROMol &prbMol, const ROMol &refMol, void *prbProp, void *refProp,
     std::vector<boost::shared_ptr<O3A>> &res, int numThreads = 1,
     O3A::AtomTypeScheme atomTypes = O3A::MMFF94, const int refCid = -1,
Index: openbabel-src/openbabel/src/charges/eqeq.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/charges/eqeq.cpp b/openbabel-src/openbabel/src/charges/eqeq.cpp
--- a/openbabel-src/openbabel/src/charges/eqeq.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/charges/eqeq.cpp	(date 1745583016086)
@@ -15,7 +15,7 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 ***********************************************************************/
-
+#include <openbabel/babelconfig.h>
 #ifdef HAVE_EIGEN3
 
 #include "eqeq.h"
@@ -52,7 +52,7 @@
     char buffer[BUFF_SIZE];
 
     // open data/eqeqIonizations.txt
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "eqeqIonizations.txt").length() == 0)
     {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open eqeqIonizations.txt", obError);
Index: boost-src/boost/libs/serialization/src/basic_text_woprimitive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/basic_text_woprimitive.cpp b/boost-src/boost/libs/serialization/src/basic_text_woprimitive.cpp
--- a/boost-src/boost/libs/serialization/src/basic_text_woprimitive.cpp	(revision a20c4d97c37e5f437c8ba78f296830edb79cff9e)
+++ b/boost-src/boost/libs/serialization/src/basic_text_woprimitive.cpp	(date 1745583016164)
@@ -20,6 +20,7 @@
 #  pragma warning (disable : 4786) // too long name, harmless warning
 #endif
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/detail/auto_link_warchive.hpp>
Index: boost-src/boost/libs/serialization/src/binary_woarchive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/binary_woarchive.cpp b/boost-src/boost/libs/serialization/src/binary_woarchive.cpp
--- a/boost-src/boost/libs/serialization/src/binary_woarchive.cpp	(revision a20c4d97c37e5f437c8ba78f296830edb79cff9e)
+++ b/boost-src/boost/libs/serialization/src/binary_woarchive.cpp	(date 1745583016164)
@@ -14,6 +14,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/archive/binary_woarchive.hpp>
 
Index: openbabel-src/openbabel/src/stereo/perception.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/stereo/perception.cpp b/openbabel-src/openbabel/src/stereo/perception.cpp
--- a/openbabel-src/openbabel/src/stereo/perception.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/stereo/perception.cpp	(date 1745583016070)
@@ -2969,9 +2969,6 @@
   }
 
   void StereoRefToImplicit(OBMol& mol, OBStereo::Ref atomId) {
-    // The following is for use in replace_if(...) below
-    const std::binder1st<std::equal_to<OBStereo::Ref> > equal_to_atomId = std::bind1st (equal_to<OBStereo::Ref>(), atomId);
-
     std::vector<OBGenericData*> vdata = mol.GetAllData(OBGenericDataType::StereoData);
     for (std::vector<OBGenericData*>::iterator data = vdata.begin(); data != vdata.end(); ++data) {
       OBStereo::Type datatype = ((OBStereoBase*)*data)->GetType();
@@ -2987,23 +2984,20 @@
       if (datatype == OBStereo::CisTrans) {
         OBCisTransStereo *ct = dynamic_cast<OBCisTransStereo*>(*data);
         OBCisTransStereo::Config ct_cfg = ct->GetConfig();
-        replace_if(ct_cfg.refs.begin(), ct_cfg.refs.end(), equal_to_atomId, (OBStereo::Ref) OBStereo::ImplicitRef);
+        replace(ct_cfg.refs.begin(), ct_cfg.refs.end(), atomId, (OBStereo::Ref) OBStereo::ImplicitRef);
         ct->SetConfig(ct_cfg);
       }
       else if (datatype == OBStereo::Tetrahedral) {
         OBTetrahedralStereo *ts = dynamic_cast<OBTetrahedralStereo*>(*data);
         OBTetrahedralStereo::Config ts_cfg = ts->GetConfig();
         if (ts_cfg.from == atomId) ts_cfg.from = OBStereo::ImplicitRef;
-        replace_if(ts_cfg.refs.begin(), ts_cfg.refs.end(), equal_to_atomId, (OBStereo::Ref) OBStereo::ImplicitRef);
+        replace(ts_cfg.refs.begin(), ts_cfg.refs.end(), atomId, (OBStereo::Ref) OBStereo::ImplicitRef);
         ts->SetConfig(ts_cfg);
       }
     }
   }
 
   void ImplicitRefToStereo(OBMol& mol, OBStereo::Ref centerId, OBStereo::Ref newId) {
-    // The following is for use in replace_if(...) below
-    const std::binder1st<std::equal_to<OBStereo::Ref> > equal_to_implicitRef = std::bind1st (equal_to<OBStereo::Ref>(), (OBStereo::Ref) OBStereo::ImplicitRef);
-
     std::vector<OBGenericData*> vdata = mol.GetAllData(OBGenericDataType::StereoData);
     for (std::vector<OBGenericData*>::iterator data = vdata.begin(); data != vdata.end(); ++data) {
       OBStereo::Type datatype = ((OBStereoBase*)*data)->GetType();
@@ -3022,9 +3016,9 @@
         if (ct_cfg.begin == centerId || ct_cfg.end == centerId) {
           // Assumption: the first two refs are on the begin atom, the last two on the end atom
           if (ct_cfg.begin == centerId)
-            replace_if(ct_cfg.refs.begin(), ct_cfg.refs.begin()+2, equal_to_implicitRef, (OBStereo::Ref) newId);
+            replace(ct_cfg.refs.begin(), ct_cfg.refs.begin()+2, (OBStereo::Ref) OBStereo::ImplicitRef, (OBStereo::Ref) newId);
           if (ct_cfg.end == centerId)
-            replace_if(ct_cfg.refs.begin()+2, ct_cfg.refs.end(), equal_to_implicitRef, (OBStereo::Ref) newId);
+            replace(ct_cfg.refs.begin()+2, ct_cfg.refs.end(), (OBStereo::Ref) OBStereo::ImplicitRef, (OBStereo::Ref) newId);
           ct->SetConfig(ct_cfg);
         }
       }
@@ -3033,7 +3027,7 @@
         OBTetrahedralStereo::Config ts_cfg = ts->GetConfig();
         if (ts_cfg.center == centerId) {
           if (ts_cfg.from == OBStereo::ImplicitRef) ts_cfg.from = newId;
-          replace_if(ts_cfg.refs.begin(), ts_cfg.refs.end(), equal_to_implicitRef, (OBStereo::Ref) newId);
+          replace(ts_cfg.refs.begin(), ts_cfg.refs.end(), (OBStereo::Ref) OBStereo::ImplicitRef, (OBStereo::Ref) newId);
           ts->SetConfig(ts_cfg);
         }
       }
Index: ringdecomposerlib-src/ringdecomposerlib/src/RingDecomposerLib/RingDecomposerLib.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ringdecomposerlib-src/ringdecomposerlib/src/RingDecomposerLib/RingDecomposerLib.h b/ringdecomposerlib-src/ringdecomposerlib/src/RingDecomposerLib/RingDecomposerLib.h
--- a/ringdecomposerlib-src/ringdecomposerlib/src/RingDecomposerLib/RingDecomposerLib.h	(revision 7b1629781cfb7fda29716d1af14a6110bb553892)
+++ b/ringdecomposerlib-src/ringdecomposerlib/src/RingDecomposerLib/RingDecomposerLib.h	(date 1745583015836)
@@ -27,6 +27,7 @@
 #ifndef RING_DECOMPOSER_LIB_H
 #define RING_DECOMPOSER_LIB_H
 
+#if 0
 #if (defined( _WIN32 ) && defined( _MSC_VER ) )
     /* Win32 & MS VC ++ */
     #define RDL_API __declspec(dllexport)
@@ -35,6 +36,12 @@
 #else
     #define RDL_API
 #endif
+#endif
+#include "ringdecomposerlib_export.h"
+
+#ifndef RDL_API
+#define RDL_API RINGDECOMPOSERLIB_EXPORT
+#endif
 
 #ifdef __cplusplus
 extern "C" {
Index: rdkit-src/rdkit/Code/GraphMol/SubstructLibrary/SubstructLibrary.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/SubstructLibrary/SubstructLibrary.h b/rdkit-src/rdkit/Code/GraphMol/SubstructLibrary/SubstructLibrary.h
--- a/rdkit-src/rdkit/Code/GraphMol/SubstructLibrary/SubstructLibrary.h	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Code/GraphMol/SubstructLibrary/SubstructLibrary.h	(date 1745583015820)
@@ -415,7 +415,7 @@
       const std::vector<unsigned int> &indices) const override {
     std::vector<std::string> res;
     std::transform(indices.begin(), indices.end(), std::back_inserter(res),
-                   [=](unsigned idx) { return keys.at(idx); });
+                   [=, this](unsigned idx) { return keys.at(idx); });
     return res;
   }
   unsigned int size() const override { return keys.size(); }
Index: boost-src/boost/libs/serialization/src/codecvt_null.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/codecvt_null.cpp b/boost-src/boost/libs/serialization/src/codecvt_null.cpp
--- a/boost-src/boost/libs/serialization/src/codecvt_null.cpp	(revision a20c4d97c37e5f437c8ba78f296830edb79cff9e)
+++ b/boost-src/boost/libs/serialization/src/codecvt_null.cpp	(date 1745583016179)
@@ -7,6 +7,7 @@
 // License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
 // http://www.boost.org/LICENSE_1_0.txt)
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/codecvt_null.hpp>
Index: openbabel-src/openbabel/src/charges/eem.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/charges/eem.cpp b/openbabel-src/openbabel/src/charges/eem.cpp
--- a/openbabel-src/openbabel/src/charges/eem.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/charges/eem.cpp	(date 1745583016086)
@@ -92,7 +92,7 @@
 
   void EEMCharges::_loadParameters()
   {
-    std::ifstream ifs;
+    std::istringstream ifs;
     if (!OpenDatafile(ifs, _parameters_file).length()) {
       obErrorLog.ThrowError(__FUNCTION__, std::string("Cannot open file with parameters: ").append(_parameters_file), obError);
       return;
Index: openbabel-src/openbabel/src/charges/qtpie.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/charges/qtpie.cpp b/openbabel-src/openbabel/src/charges/qtpie.cpp
--- a/openbabel-src/openbabel/src/charges/qtpie.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/charges/qtpie.cpp	(date 1745583016086)
@@ -15,7 +15,7 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 ***********************************************************************/
-
+#include <openbabel/babelconfig.h>
 #ifdef HAVE_EIGEN
 
 #include "qtpie.h"
@@ -117,7 +117,7 @@
     char buffer[BUFF_SIZE];
 
     // open data/qeq.txt
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "qeq.txt").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open qeq.txt", obError);
       return;
Index: boost-src/boost/libs/serialization/src/basic_text_wiprimitive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/basic_text_wiprimitive.cpp b/boost-src/boost/libs/serialization/src/basic_text_wiprimitive.cpp
--- a/boost-src/boost/libs/serialization/src/basic_text_wiprimitive.cpp	(revision a20c4d97c37e5f437c8ba78f296830edb79cff9e)
+++ b/boost-src/boost/libs/serialization/src/basic_text_wiprimitive.cpp	(date 1745583016148)
@@ -20,6 +20,7 @@
 #  pragma warning (disable : 4786) // too long name, harmless warning
 #endif
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/detail/auto_link_warchive.hpp>
Index: boost-src/boost/libs/serialization/src/xml_woarchive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/xml_woarchive.cpp b/boost-src/boost/libs/serialization/src/xml_woarchive.cpp
--- a/boost-src/boost/libs/serialization/src/xml_woarchive.cpp	(revision a20c4d97c37e5f437c8ba78f296830edb79cff9e)
+++ b/boost-src/boost/libs/serialization/src/xml_woarchive.cpp	(date 1745583016148)
@@ -17,6 +17,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/xml_woarchive.hpp>
Index: rdkit-src/rdkit/Code/GraphMol/SLNParse/lex.yysln.cpp.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/SLNParse/lex.yysln.cpp.cmake b/rdkit-src/rdkit/Code/GraphMol/SLNParse/lex.yysln.cpp.cmake
--- a/rdkit-src/rdkit/Code/GraphMol/SLNParse/lex.yysln.cpp.cmake	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Code/GraphMol/SLNParse/lex.yysln.cpp.cmake	(date 1745583015976)
@@ -727,8 +727,8 @@
 #endif
 
 #include <cstdio>
-#ifdef WIN32
-#include <io.h> 	 
+#if defined(WIN32) || defined(__MINGW32__)
+#include <io.h>
 #endif
 
 #include <RDGeneral/Exceptions.h>
Index: inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.h b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.h
--- a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.h	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.h	(date 1745583015929)
@@ -35,7 +35,7 @@
 #ifndef __INCHI_DLL_A_H__
 #define __INCHI_DLL_A_H__
 
-#include "../../../INCHI_BASE/src/ichicant.h"
+#include "ichicant.h"
 
 typedef struct tagCOMPONENT_TREAT_INFO
 {
@@ -128,6 +128,7 @@
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
 
 
+#if 0
 #if (defined( _WIN32 ) && defined( _MSC_VER ) && defined(BUILD_LINK_AS_DLL) )
     /* Win32 & MS VC ++, compile and link as a DLL */
 #ifdef _USRDLL
@@ -147,6 +148,7 @@
 #define EXPIMP_TEMPLATE
 #define INCHI_DECL
 #endif
+#endif
 
 
 
Index: boost-src/boost/libs/serialization/src/text_woarchive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/text_woarchive.cpp b/boost-src/boost/libs/serialization/src/text_woarchive.cpp
--- a/boost-src/boost/libs/serialization/src/text_woarchive.cpp	(revision a20c4d97c37e5f437c8ba78f296830edb79cff9e)
+++ b/boost-src/boost/libs/serialization/src/text_woarchive.cpp	(date 1745583016179)
@@ -13,6 +13,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/text_woarchive.hpp>
Index: inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.c b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.c	(date 1745583015929)
@@ -46,26 +46,26 @@
 #include <limits.h>
 #include <float.h>
 #include <math.h>
-#include "../../../INCHI_BASE/src/incomdef.h"
-#include "../../../INCHI_BASE/src/ichidrp.h"
-#include "../../../INCHI_BASE/src/inpdef.h"
-#include "../../../INCHI_BASE/src/ichi.h"
-#include "../../../INCHI_BASE/src/strutil.h"
-#include "../../../INCHI_BASE/src/util.h"
-#include "../../../INCHI_BASE/src/ichierr.h"
-#include "../../../INCHI_BASE/src/ichimain.h"
-#include "../../../INCHI_BASE/src/extr_ct.h"
-#include "../../../INCHI_BASE/src/ichi_io.h"
-#include "../../../INCHI_BASE/src/mol_fmt.h"
-#include "../../../INCHI_BASE/src/ichicomp.h"
-#include "../../../INCHI_BASE/src/ichitaut.h"
-#include "../../../INCHI_BASE/src/ichinorm.h"
+#include "incomdef.h"
+#include "ichidrp.h"
+#include "inpdef.h"
+#include "ichi.h"
+#include "strutil.h"
+#include "util.h"
+#include "ichierr.h"
+#include "ichimain.h"
+#include "extr_ct.h"
+#include "ichi_io.h"
+#include "mol_fmt.h"
+#include "ichicomp.h"
+#include "ichitaut.h"
+#include "ichinorm.h"
 
 
-#include "../../../INCHI_BASE/src/ichisize.h"
-#include "../../../INCHI_BASE/src/ichitime.h"
-#include "../../../INCHI_BASE/src/mode.h"
-#include "../../../INCHI_BASE/src/inchi_api.h"
+#include "ichisize.h"
+#include "ichitime.h"
+#include "mode.h"
+#include "inchi_api.h"
 
 #include "inchi_dll_a.h" /* not inchi_api.h as it hides internal data types */
 #include "inchi_dll.h"
Index: inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a2.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a2.c b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a2.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a2.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a2.c	(date 1745583015914)
@@ -43,31 +43,31 @@
 
 /*  */
 
-#include "../../../INCHI_BASE/src/mode.h"
-#include "../../../INCHI_BASE/src/ichitime.h"
-#include "../../../INCHI_BASE/src/incomdef.h"
-#include "../../../INCHI_BASE/src/ichidrp.h"
-#include "../../../INCHI_BASE/src/inpdef.h"
-#include "../../../INCHI_BASE/src/ichi.h"
-#include "../../../INCHI_BASE/src/strutil.h"
-#include "../../../INCHI_BASE/src/util.h"
-#include "../../../INCHI_BASE/src/ichidrp.h"
-#include "../../../INCHI_BASE/src/ichierr.h"
-#include "../../../INCHI_BASE/src/ichimain.h"
-#include "../../../INCHI_BASE/src/extr_ct.h"
-#include "../../../INCHI_BASE/src/ichitaut.h"
-#include "../../../INCHI_BASE/src/ichi_io.h"
-#include "../../../INCHI_BASE/src/ichinorm.h"
-#include "../../../INCHI_BASE/src/ichicant.h"
-#include "../../../INCHI_BASE/src/ichicano.h"
-#include "../../../INCHI_BASE/src/ichicomn.h"
-#include "../../../INCHI_BASE/src/ichimake.h"
-#include "../../../INCHI_BASE/src/ichister.h"
+#include "mode.h"
+#include "ichitime.h"
+#include "incomdef.h"
+#include "ichidrp.h"
+#include "inpdef.h"
+#include "ichi.h"
+#include "strutil.h"
+#include "util.h"
+#include "ichidrp.h"
+#include "ichierr.h"
+#include "ichimain.h"
+#include "extr_ct.h"
+#include "ichitaut.h"
+#include "ichi_io.h"
+#include "ichinorm.h"
+#include "ichicant.h"
+#include "ichicano.h"
+#include "ichicomn.h"
+#include "ichimake.h"
+#include "ichister.h"
 /* */
 #ifdef INCHI_LIB
 #include "ichi_lib.h"
 #endif
-#include "../../../INCHI_BASE/src/ichicomp.h"
+#include "ichicomp.h"
 
 /* for DisplayTheWholeStructure() */
 #define COMP_ORIG_0_MAIN  0x0001
@@ -77,9 +77,9 @@
 #define COMP_ORIG_1_MAIN  0x0010
 #define COMP_ORIG_1_RECN  0x0020
 
-#include "../../../INCHI_BASE/src/ichisize.h"
-#include "../../../INCHI_BASE/src/mode.h"
-#include "../../../INCHI_BASE/src/inchi_api.h"
+#include "ichisize.h"
+#include "mode.h"
+#include "inchi_api.h"
 #include "inchi_dll_a.h" /* not inchi_api.h as it hides internal data types */
 
 
Index: inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_main.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_main.c b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_main.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_main.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_main.c	(date 1745583015914)
@@ -34,7 +34,7 @@
 
 /* inchi_dll_main.c : Defines the entry point for the DLL application. */
 
-#include "../../../INCHI_BASE/src/mode.h"
+#include "mode.h"
 
 #if defined(_WIN32) && defined(_USRDLL) && defined(_DEBUG) && !(defined(__STDC__) && __STDC__ == 1)
 #include "inchi_dll_main.h"
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.h b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.h
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.h	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.h	(date 1745583015976)
@@ -35,7 +35,7 @@
 #ifndef __IXA_STATUS_H__
 #define __IXA_STATUS_H__
 
-#include "../../../../INCHI_BASE/src/ixa.h"
+#include "ixa.h"
 
 void STATUS_PushMessage( IXA_STATUS_HANDLE hStatus,
                         IXA_STATUS        vSeverity,
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_inchikey_builder.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_inchikey_builder.c b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_inchikey_builder.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_inchikey_builder.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_inchikey_builder.c	(date 1745583015961)
@@ -32,8 +32,8 @@
  */
 
 
-#include "../../../../INCHI_BASE/src/mode.h"
-#include "../../../../INCHI_BASE/src/inchi_api.h"
+#include "mode.h"
+#include "inchi_api.h"
 #include "ixa_status.h"
 #include <stdlib.h>
 #include <string.h>
Index: inchi-src/inchi/INCHI_API/libinchi/src/ichilnct.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ichilnct.c b/inchi-src/inchi/INCHI_API/libinchi/src/ichilnct.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ichilnct.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ichilnct.c	(date 1745583015945)
@@ -42,16 +42,16 @@
 
 /* for use in the InChI library */
 
-#include "../../../INCHI_BASE/src/mode.h"
+#include "mode.h"
 
-#include "../../../INCHI_BASE/src/incomdef.h"
-#include "../../../INCHI_BASE/src/ichidrp.h"
-#include "../../../INCHI_BASE/src/inpdef.h"
-#include "../../../INCHI_BASE/src/util.h"
-#include "../../../INCHI_BASE/src/ichierr.h"
-#include "../../../INCHI_BASE/src/ichicomp.h"
-#include "../../../INCHI_BASE/src/ichi_io.h"
-#include "../../../INCHI_BASE/src/inchi_api.h"
+#include "incomdef.h"
+#include "ichidrp.h"
+#include "inpdef.h"
+#include "util.h"
+#include "ichierr.h"
+#include "ichicomp.h"
+#include "ichi_io.h"
+#include "inchi_api.h"
 
 #include "inchi_dll_b.h"
 
@@ -63,7 +63,7 @@
                        int *err, char *pStrErr );
 
 /* This contains executable code. Included in lReadAux.c, e_ReadINCH.c, ReadINCH.c,  */
-#include "../../../INCHI_BASE/src/readinch.h"
+#include "readinch.h"
 
 
 
Index: inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_b.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_b.c b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_b.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_b.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_b.c	(date 1745583015929)
@@ -42,22 +42,22 @@
 #include <float.h>
 #include <math.h>
 
-#include "../../../INCHI_BASE/src/mode.h"
-#include "../../../INCHI_BASE/src/inchi_api.h"
-#include "../../../INCHI_BASE/src/incomdef.h"
-#include "../../../INCHI_BASE/src/ichidrp.h"
-#include "../../../INCHI_BASE/src/inpdef.h"
-#include "../../../INCHI_BASE/src/ichi.h"
-#include "../../../INCHI_BASE/src/strutil.h"
-#include "../../../INCHI_BASE/src/util.h"
-#include "../../../INCHI_BASE/src/ichierr.h"
-#include "../../../INCHI_BASE/src/ichimain.h"
-#include "../../../INCHI_BASE/src/extr_ct.h"
-#include "../../../INCHI_BASE/src/ichi_io.h"
-#include "../../../INCHI_BASE/src/ichicomp.h"
-#include "../../../INCHI_BASE/src/ichitime.h"
-#include "../../../INCHI_BASE/src/ichicant.h"
-#include "../../../INCHI_BASE/src/readinch.h"
+#include "mode.h"
+#include "inchi_api.h"
+#include "incomdef.h"
+#include "ichidrp.h"
+#include "inpdef.h"
+#include "ichi.h"
+#include "strutil.h"
+#include "util.h"
+#include "ichierr.h"
+#include "ichimain.h"
+#include "extr_ct.h"
+#include "ichi_io.h"
+#include "ichicomp.h"
+#include "ichitime.h"
+#include "ichicant.h"
+#include "readinch.h"
 
 #include "inchi_dll.h"
 #include "inchi_dll_b.h"
Index: openbabel-src/openbabel/src/formats/exampleformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/exampleformat.cpp b/openbabel-src/openbabel/src/formats/exampleformat.cpp
--- a/openbabel-src/openbabel/src/formats/exampleformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/exampleformat.cpp	(date 1745583016148)
@@ -32,6 +32,7 @@
 
 #include <openbabel/babelconfig.h>
 #include <openbabel/obmolecformat.h>
+#include <openbabel/mol.h>
 
 using namespace std;
 namespace OpenBabel
Index: inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll.c b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll.c	(date 1745583015945)
@@ -42,25 +42,25 @@
 #include <float.h>
 #include <math.h>
 
-#include "../../../INCHI_BASE/src/mode.h"
+#include "mode.h"
 
-#include "../../../INCHI_BASE/src/incomdef.h"
-#include "../../../INCHI_BASE/src/ichidrp.h"
-#include "../../../INCHI_BASE/src/inpdef.h"
-#include "../../../INCHI_BASE/src/ichi.h"
-#include "../../../INCHI_BASE/src/strutil.h"
-#include "../../../INCHI_BASE/src/util.h"
-#include "../../../INCHI_BASE/src/ichierr.h"
-#include "../../../INCHI_BASE/src/ichimain.h"
-#include "../../../INCHI_BASE/src/extr_ct.h"
-#include "../../../INCHI_BASE/src/ichi_io.h"
-#include "../../../INCHI_BASE/src/ichicomp.h"
-#include "../../../INCHI_BASE/src/inchi_api.h"
-#include "../../../INCHI_BASE/src/readinch.h"
+#include "incomdef.h"
+#include "ichidrp.h"
+#include "inpdef.h"
+#include "ichi.h"
+#include "strutil.h"
+#include "util.h"
+#include "ichierr.h"
+#include "ichimain.h"
+#include "extr_ct.h"
+#include "ichi_io.h"
+#include "ichicomp.h"
+#include "inchi_api.h"
+#include "readinch.h"
 
-#include "../../../INCHI_BASE/src/ichitaut.h"
-#include "../../../INCHI_BASE/src/ichicant.h"
-#include "../../../INCHI_BASE/src/ichitime.h"
+#include "ichitaut.h"
+#include "ichicant.h"
+#include "ichitime.h"
 
 #include "inchi_dll.h"
 
Index: boost-src/boost/libs/serialization/src/xml_wgrammar.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/xml_wgrammar.cpp b/boost-src/boost/libs/serialization/src/xml_wgrammar.cpp
--- a/boost-src/boost/libs/serialization/src/xml_wgrammar.cpp	(revision a20c4d97c37e5f437c8ba78f296830edb79cff9e)
+++ b/boost-src/boost/libs/serialization/src/xml_wgrammar.cpp	(date 1745583016148)
@@ -14,6 +14,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/impl/basic_xml_grammar.hpp>
Index: openbabel-src/openbabel/src/formats/mdffformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/mdffformat.cpp b/openbabel-src/openbabel/src/formats/mdffformat.cpp
--- a/openbabel-src/openbabel/src/formats/mdffformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/mdffformat.cpp	(date 1745583016148)
@@ -30,9 +30,13 @@
 #include <algorithm>
 
 #ifdef _MSC_VER
+#ifndef INFINITY
 #define INFINITY (DBL_MAX+DBL_MAX)
+#endif
+#ifndef NAN
 #define NAN (INFINITY-INFINITY)
 #endif
+#endif
 
 using namespace std;
 namespace OpenBabel {
@@ -133,7 +137,7 @@
     //    path = buffer;
     string full_path = pConv->GetInFilename();
     size_t found = full_path.rfind("/");
-    string path = (found == string::npos) ? "" : path.substr(0, found);
+    string path = (found == string::npos) ? "" : full_path.substr(0, found);
     string short_fn = full_path.substr(path.length(), string::npos);
 
     // Open files
Index: arrow-src/arrow/cpp/src/arrow/vendored/uriparser/UriBase.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/arrow-src/arrow/cpp/src/arrow/vendored/uriparser/UriBase.h b/arrow-src/arrow/cpp/src/arrow/vendored/uriparser/UriBase.h
--- a/arrow-src/arrow/cpp/src/arrow/vendored/uriparser/UriBase.h	(revision 272715f6df2a042d69881ffa03d5078c58e4b345)
+++ b/arrow-src/arrow/cpp/src/arrow/vendored/uriparser/UriBase.h	(date 1745583016179)
@@ -96,8 +96,10 @@
 #endif
 
 
+#include <arrow_export.h>
 
 /* Import/export decorator */
+#if 0
 #if defined(URI_STATIC_BUILD)
 # define URI_PUBLIC
 #else
@@ -117,6 +119,8 @@
 #  endif
 # endif
 #endif
+#endif
+#define URI_PUBLIC ARROW_EXPORT
 
 
 
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_inchi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_inchi.c b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_inchi.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_inchi.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_inchi.c	(date 1745583015961)
@@ -34,9 +34,9 @@
 
 #include "string.h"
 
-#include "../../../../INCHI_BASE/src/mode.h"
-#include "../../../../INCHI_BASE/src/inchi_api.h"
-#include "../../../../INCHI_BASE/src/util.h"
+#include "mode.h"
+#include "inchi_api.h"
+#include "util.h"
 #include "ixa_mol.h"
 #include "ixa_status.h"
 
Index: arrow-src/arrow/cpp/src/arrow/vendored/datetime/tz.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/arrow-src/arrow/cpp/src/arrow/vendored/datetime/tz.h b/arrow-src/arrow/cpp/src/arrow/vendored/datetime/tz.h
--- a/arrow-src/arrow/cpp/src/arrow/vendored/datetime/tz.h	(revision 272715f6df2a042d69881ffa03d5078c58e4b345)
+++ b/arrow-src/arrow/cpp/src/arrow/vendored/datetime/tz.h	(date 1745649400663)
@@ -98,6 +98,10 @@
 
 #include "date.h"
 
+#include <arrow_export.h>
+
+#define DATE_API ARROW_EXPORT
+
 #if defined(_MSC_VER) && (_MSC_VER < 1900)
 #include "tz_private.h"
 #endif
@@ -118,6 +122,7 @@
 #include <utility>
 #include <vector>
 
+#if 0
 #ifdef _WIN32
 #  ifdef DATE_BUILD_DLL
 #    define DATE_API __declspec(dllexport)
@@ -133,6 +138,7 @@
 #    define DATE_API
 #  endif
 #endif
+#endif
 
 namespace arrow_vendored::date
 {
Index: boost-src/boost/libs/serialization/src/binary_wiarchive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/binary_wiarchive.cpp b/boost-src/boost/libs/serialization/src/binary_wiarchive.cpp
--- a/boost-src/boost/libs/serialization/src/binary_wiarchive.cpp	(revision a20c4d97c37e5f437c8ba78f296830edb79cff9e)
+++ b/boost-src/boost/libs/serialization/src/binary_wiarchive.cpp	(date 1745583016179)
@@ -14,6 +14,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/archive/binary_wiarchive.hpp>
 #include <boost/archive/detail/archive_serializer_map.hpp>
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_mol.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_mol.c b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_mol.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_mol.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_mol.c	(date 1745583015914)
@@ -38,12 +38,12 @@
 #include <stdlib.h>
 #include <string.h>
 
-#include "../../../../INCHI_BASE/src/mode.h"
-#include "../../../../INCHI_BASE/src/inchi_api.h"
-#include "../../../../INCHI_BASE/src/ichicomp.h"
-#include "../../../../INCHI_BASE/src/util.h"
-#include "../../../../INCHI_BASE/src/mol_fmt.h"
-#include "../../../../INCHI_BASE/src/ichi_io.h"
+#include "mode.h"
+#include "inchi_api.h"
+#include "ichicomp.h"
+#include "util.h"
+#include "mol_fmt.h"
+#include "ichi_io.h"
 
 #include "ixa_status.h"
 #include "ixa_mol.h"
Index: boost-src/boost/libs/gil/include/boost/gil/extension/rasterization/ellipse.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/gil/include/boost/gil/extension/rasterization/ellipse.hpp b/boost-src/boost/libs/gil/include/boost/gil/extension/rasterization/ellipse.hpp
--- a/boost-src/boost/libs/gil/include/boost/gil/extension/rasterization/ellipse.hpp	(revision 201f31c76eed54b304f8d89e44da08a5e8825094)
+++ b/boost-src/boost/libs/gil/include/boost/gil/extension/rasterization/ellipse.hpp	(date 1745583016086)
@@ -37,8 +37,8 @@
     /// center respectively.
     /// \param semi_axes - Point containing positive integer lengths of horizontal semi-axis
     /// and vertical semi-axis respectively.
-    midpoint_ellipse_rasterizer(point<unsigned int> center_point,
-        point<unsigned int> semi_axes_values)
+    midpoint_ellipse_rasterizer(point_t center_point,
+        point_t semi_axes_values)
         : center(center_point)
         , semi_axes(semi_axes_values)
     {}
@@ -130,7 +130,7 @@
         }
 
         // mutable center copy
-        point<unsigned int> center2(center);
+        point_t center2(center);
         --center2[0], --center2[1]; // For converting center co-ordinate values to zero based indexing.
         for (point_t pnt : trajectory_points)
         {
@@ -186,8 +186,8 @@
         draw_curve(view, pixel, obtain_trajectory());
     }
 
-    point<unsigned int> center;
-    point<unsigned int> semi_axes;
+    point_t center;
+    point_t semi_axes;
 };
 
 namespace detail {
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_builder.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_builder.c b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_builder.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_builder.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_builder.c	(date 1745583015898)
@@ -32,9 +32,9 @@
  */
 
 
-#include "../../../../INCHI_BASE/src/mode.h"
-#include "../../../../INCHI_BASE/src/inchi_api.h"
-#include "../../../../INCHI_BASE/src/inpdef.h"
+#include "mode.h"
+#include "inchi_api.h"
+#include "inpdef.h"
 #include "ixa_status.h"
 #include "ixa_mol.h"
 #include <ctype.h>
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.h b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.h
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.h	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.h	(date 1745583015961)
@@ -35,7 +35,7 @@
 #ifndef __IXA_MOL_H__
 #define __IXA_MOL_H__
 
-#include "../../../../INCHI_BASE/src/ixa.h"
+#include "ixa.h"
 
 typedef struct
 {
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.c b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.c	(date 1745583015961)
@@ -36,12 +36,12 @@
 #include <string.h>
 #include <limits.h>
 
-#include "../../../../INCHI_BASE/src/mode.h"
-#include "../../../../INCHI_BASE/src/ichierr.h"
-#include "../../../../INCHI_BASE/src/mol_fmt.h"
-#include "../../../../INCHI_BASE/src/inchi_api.h"
+#include "mode.h"
+#include "ichierr.h"
+#include "mol_fmt.h"
+#include "inchi_api.h"
 
-#include "../../../../INCHI_BASE/src/ichi_io.h"
+#include "ichi_io.h"
 
 #include "ixa_mol.h"
 #include "ixa_status.h"
Index: boost-src/boost/libs/serialization/src/xml_wiarchive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/xml_wiarchive.cpp b/boost-src/boost/libs/serialization/src/xml_wiarchive.cpp
--- a/boost-src/boost/libs/serialization/src/xml_wiarchive.cpp	(revision a20c4d97c37e5f437c8ba78f296830edb79cff9e)
+++ b/boost-src/boost/libs/serialization/src/xml_wiarchive.cpp	(date 1745583016148)
@@ -17,6 +17,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/xml_wiarchive.hpp>
Index: openbabel-src/openbabel/src/formats/chemdrawcdx.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/chemdrawcdx.cpp b/openbabel-src/openbabel/src/formats/chemdrawcdx.cpp
--- a/openbabel-src/openbabel/src/formats/chemdrawcdx.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/chemdrawcdx.cpp	(date 1745583016179)
@@ -810,7 +810,7 @@
 ///////////////////////////////////////////////////////////////////////
 bool CDXReader::ParseEnums(map<CDXTag, string>& enummap, const string& filename)
 {
-  ifstream ihs;
+  istringstream ihs;
   if(OpenDatafile(ihs, filename).empty())
   {
     obErrorLog.ThrowError(__FUNCTION__, 
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.c b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.c	(date 1745583015914)
@@ -32,8 +32,8 @@
  */
 
 
-#include "../../../../INCHI_BASE/src/mode.h"
-#include "../../../../INCHI_BASE/src/inchi_api.h"
+#include "mode.h"
+#include "inchi_api.h"
 #include "ixa_status.h"
 #include <string.h>
 #include <stdarg.h>
Index: openbabel-src/openbabel/src/formats/fchkformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/fchkformat.cpp b/openbabel-src/openbabel/src/formats/fchkformat.cpp
--- a/openbabel-src/openbabel/src/formats/fchkformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/fchkformat.cpp	(date 1745583016148)
@@ -665,16 +665,16 @@
            no atom numbers < 0 or > Natoms */
         if (NBond.end() != find_if(NBond.begin(),
                                    NBond.end(),
-                                   bind2nd(less_equal<int>(), 0)) ||
+                                   bind(less_equal<int>(), std::placeholders::_1, 0)) ||
             NBond.end() != find_if(NBond.begin(),
                                    NBond.end(),
-                                   bind2nd(greater<int>(), MxBond)) ||
+                                   bind(greater<int>(), std::placeholders::_1, MxBond)) ||
             IBond.end() != find_if(IBond.begin(),
                                    IBond.end(),
-                                   bind2nd(less<int>(), 0)) ||
+                                   bind(less<int>(), std::placeholders::_1, 0)) ||
             IBond.end() != find_if(IBond.begin(),
                                    IBond.end(),
-                                   bind2nd(greater<int>(), Natoms)))
+                                   bind(greater<int>(), std::placeholders::_1, Natoms)))
           {
             error_msg << "Invalid connectivity : check the \"NBond\" and/or"
                       << " \"IBond\" section(s).";
Index: openbabel-src/openbabel/src/formats/povrayformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/povrayformat.cpp b/openbabel-src/openbabel/src/formats/povrayformat.cpp
--- a/openbabel-src/openbabel/src/formats/povrayformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/povrayformat.cpp	(date 1745583016179)
@@ -523,7 +523,7 @@
 
         /* ---- Add a pigment - statement for start-atom of bond ---- */
         bond_type = bond->GetBeginAtom() -> GetType();
-        bond_type.erase(remove_if(bond_type.begin(), bond_type.end(), bind1st(equal_to<char>(), '.')), bond_type.end());
+        bond_type.erase(remove(bond_type.begin(), bond_type.end(), '.'), bond_type.end());
         ofs << "\t    pigment{color Color_"
             << bond_type
             << "}" << endl;
@@ -584,7 +584,7 @@
 
         /* ---- Add a pigment - statement for end-atom of bond i ---- */
         bond_type = bond->GetEndAtom() -> GetType();
-        bond_type.erase(remove_if(bond_type.begin(), bond_type.end(), bind1st(equal_to<char>(), '.')), bond_type.end());
+        bond_type.erase(remove(bond_type.begin(), bond_type.end(), '.'), bond_type.end());
 
         ofs << "\t    pigment{color Color_"
             << bond_type
Index: openbabel-src/openbabel/src/formats/nwchemformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/nwchemformat.cpp b/openbabel-src/openbabel/src/formats/nwchemformat.cpp
--- a/openbabel-src/openbabel/src/formats/nwchemformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/nwchemformat.cpp	(date 1745583016148)
@@ -303,10 +303,11 @@
         blank_line = false;
         if (vs[0][0] == '0')
             charge = atoi(vs[4].c_str());
-        else if (vs[0][0] == '1')
+        else if (vs[0][0] == '1') {
             for (unsigned int i = 0; i < 3; i++)
                 if (vs[i+1][0] == '1')
                     dipole[i] = atof(vs[4].c_str());
+        }
         else if (vs[0][0] == '2')
         {
             double value = atof(vs[4].c_str());
Index: openbabel-src/openbabel/src/formats/vaspformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/vaspformat.cpp b/openbabel-src/openbabel/src/formats/vaspformat.cpp
--- a/openbabel-src/openbabel/src/formats/vaspformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/vaspformat.cpp	(date 1745583016133)
@@ -532,7 +532,7 @@
             for (size_t natom = 0; natom < pmol->NumAtoms(); ++natom) {
               const vector3 dxyz = currXyz[natom] - prevXyz[natom];
               vector3::const_iterator iter = std::find_if(dxyz.begin(), dxyz.end(),
-                      std::bind2nd(std::not_equal_to<double>(), 0.0));
+                      std::bind(std::not_equal_to<double>(), std::placeholders::_1, 0.0));
               if (iter != dxyz.end()) dipGrad[natom].SetRow(iter - dxyz.begin(),
                                                             (currDm - prevDm) / *iter);
             }
@@ -586,7 +586,7 @@
       if (max != 0.0) {
         // Normalize
         std::transform(Intensities.begin(), Intensities.end(), Intensities.begin(),
-                       std::bind2nd(std::divides<double>(), max / 100.0));
+                       std::bind(std::divides<double>(), std::placeholders::_1, max / 100.0));
       } else {
         Intensities.clear();
       }
Index: openbabel-src/openbabel/src/formats/orcaformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/orcaformat.cpp b/openbabel-src/openbabel/src/formats/orcaformat.cpp
--- a/openbabel-src/openbabel/src/formats/orcaformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/orcaformat.cpp	(date 1745583016148)
@@ -24,11 +24,7 @@
 #include <openbabel/generic.h>
 #include <cstdlib>
 
-#ifdef _MSC_VER
 #include <regex>
-#else
-#include <regex.h>
-#endif
 
 #include <iomanip>
 
@@ -696,38 +692,22 @@
 
 // small function to avoid wrong parsing
 // if there is no whitespace between the numbers in the column structure
-#ifdef _MSC_VER
   string OrcaOutputFormat::checkColumns(string checkBuffer)
   {
     string pattern ("[0-9]-");
-    std::tr1::regex myregex;
-    std::tr1::smatch pm;
+    std::regex myregex;
+    std::smatch pm;
     try {
       myregex.assign(pattern,
-                     std::tr1::regex_constants::extended);
+                     std::regex_constants::extended);
       //iok = true;
-    } catch (std::tr1::regex_error ex) {
+    } catch (std::regex_error ex) {
         return (checkBuffer); // do nothing
       //iok = false;
     }
-    while (std::tr1::regex_search (checkBuffer,pm,myregex)) {
+    while (std::regex_search (checkBuffer,pm,myregex)) {
         checkBuffer.insert(pm.position(0)+1, " ");
     }
     return (checkBuffer);
   }
-#else
-  string OrcaOutputFormat::checkColumns(string checkBuffer)
-  {
-      string pattern ("[0-9]-");
-      regmatch_t pm;
-      regex_t myregex;
-      int pos = regcomp(&myregex, pattern.c_str(), REG_EXTENDED);
-      if (pos !=0) return (checkBuffer); // do nothing
-
-      while (regexec(&myregex, checkBuffer.c_str(), 1, &pm, REG_EXTENDED) == 0) {
-          checkBuffer.insert(pm.rm_eo-1, " ");  // insert whitespace to separate the columns
-      }
-      return (checkBuffer);
-  }
-#endif
 } //namespace OpenBabel
Index: inchi-src/inchi/INCHI_BASE/src/ichiparm.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_BASE/src/ichiparm.c b/inchi-src/inchi/INCHI_BASE/src/ichiparm.c
--- a/inchi-src/inchi/INCHI_BASE/src/ichiparm.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_BASE/src/ichiparm.c	(date 1745583016023)
@@ -586,7 +586,7 @@
     int bHashKey            = 0;
     int bHashXtra1          = 0;
     int bHashXtra2          = 0;
-    int bLargeMolecules     = 0;
+    int bLargeMolecules     = 1;
     int bPolymers           = POLYMERS_NO;
 #ifdef TARGET_LIB_FOR_WINCHI
     int bFoldPolymerSRU     = 0;
Index: rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupFingerprintScore.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupFingerprintScore.cpp b/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupFingerprintScore.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupFingerprintScore.cpp	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupFingerprintScore.cpp	(date 1745583015851)
@@ -12,7 +12,7 @@
 #include "GraphMol/Fingerprints/Fingerprints.h"
 #include "GraphMol//Fingerprints/MorganFingerprints.h"
 #include <GraphMol/SmilesParse/SmilesParse.h>
-#include "../../../External/GA/util/Util.h"
+#include "GA/util/Util.h"
 #include <memory>
 #include <utility>
 #include <vector>
Index: openbabel-src/openbabel/src/formats/gamessukformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/gamessukformat.cpp b/openbabel-src/openbabel/src/formats/gamessukformat.cpp
--- a/openbabel-src/openbabel/src/formats/gamessukformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/gamessukformat.cpp	(date 1745583016086)
@@ -23,12 +23,7 @@
 
 #include <algorithm>
 #include <cmath>
-
-#ifdef _MSC_VER
 #include <regex>
-#else
-#include <regex.h>
-#endif
 
 using namespace std;
 
@@ -797,20 +792,15 @@
     //                     ------label--------   -------charge-------- < seems enough for a match
     string pattern(" *\\* *[a-zA-Z]{1,2}[0-9]* *[0-9]{1,3}\\.[0-9]{1}");
     bool iok;
-#ifdef _MSC_VER
-    std::tr1::regex myregex;
+    std::regex myregex;
     try {
       myregex.assign(pattern,
-                     std::tr1::regex_constants::extended |
-                     std::tr1::regex_constants::nosubs);
+                     std::regex_constants::extended |
+                     std::regex_constants::nosubs);
       iok = true;
-    } catch (std::tr1::regex_error ex) {
+    } catch (std::regex_error ex) {
       iok = false;
     }
-#else
-    regex_t *myregex = new regex_t;
-    iok = regcomp(myregex, pattern.c_str(), REG_EXTENDED | REG_NOSUB)==0;
-#endif
     if (!iok) cerr << "Error compiling regex in GUK OUTPUT!\n";
 
     // Read in the coordinates - we process them directly rather
@@ -820,11 +810,7 @@
 
       // End of geometry block
       if (strstr(buffer, "*************************") != nullptr) break;
-#ifdef _MSC_VER
-      if (std::tr1::regex_search(buffer, myregex)) {
-#else
-        if (regexec(myregex, buffer, 0, nullptr, 0) == 0) {
-#endif
+      if (std::regex_search(buffer, myregex)) {
           //cerr << "Got Coord line: " << buffer << endl;
           OBAtom *atom = mol.NewAtom();
           tokenize(tokens,buffer," ");
@@ -841,9 +827,6 @@
         }
       }
       mol.EndModify();
-#ifndef _MSC_VER
-      regfree(myregex);
-#endif
       return true;
     } // End ReadInitalCartesian
 
Index: rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.h b/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.h
--- a/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.h	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.h	(date 1745583015851)
@@ -16,11 +16,11 @@
 #include <map>
 #include <chrono>
 
-#include "../../../External/GA/ga/StringChromosome.h"
-#include "../../../External/GA/ga/GaBase.h"
-#include "../../../External/GA/ga/GaOperation.h"
-#include "../../../External/GA/ga/LinkedPopLinearSel.h"
-#include "../../../External/GA/ga/IntegerStringChromosomePolicy.h"
+#include "GA/ga/StringChromosome.h"
+#include "GA/ga/GaBase.h"
+#include "GA/ga/GaOperation.h"
+#include "GA/ga/LinkedPopLinearSel.h"
+#include "GA/ga/IntegerStringChromosomePolicy.h"
 #include "RGroupFingerprintScore.h"
 #include "RGroupScore.h"
 
Index: rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/DrawTextQt.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/DrawTextQt.h b/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/DrawTextQt.h
--- a/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/DrawTextQt.h	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/DrawTextQt.h	(date 1745583016054)
@@ -11,6 +11,7 @@
 #define RDKIT_DRAWTEXTQT_H
 
 #include <RDGeneral/export.h>
+#include <MolDraw2DQt/rdkit_export.hpp>
 #include <GraphMol/MolDraw2D/DrawTextNotFT.h>
 
 class QPainter;
Index: rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/MolDraw2DQt.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/MolDraw2DQt.h b/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/MolDraw2DQt.h
--- a/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/MolDraw2DQt.h	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/MolDraw2DQt.h	(date 1745583016054)
@@ -10,10 +10,10 @@
 // This is a concrete class derived from MolDraw2D that uses RDKit to draw a
 // molecule into a QPainter.
 
-#include <RDGeneral/export.h>
 #ifndef MOLDRAW2DQT_H
 #define MOLDRAW2DQT_H
-
+#include <RDGeneral/export.h>
+#include <MolDraw2DQt/rdkit_export.hpp>
 #include <GraphMol/MolDraw2D/MolDraw2D.h>
 
 class QPainter;
Index: openbabel-src/openbabel/src/formats/xtcformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/xtcformat.cpp b/openbabel-src/openbabel/src/formats/xtcformat.cpp
--- a/openbabel-src/openbabel/src/formats/xtcformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/xtcformat.cpp	(date 1745583016164)
@@ -29,7 +29,7 @@
 #include <vector>
 
 #define MAXID 20
-#define MAXABS INT_MAX-2
+#define MAXABS float(INT_MAX-2)
 
 #ifndef MIN
 #define MIN(x,y) ((x) < (y) ? (x):(y))
Index: rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.cpp b/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.cpp	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.cpp	(date 1745583015836)
@@ -7,7 +7,7 @@
 //  which is included in the file license.txt, found at the root
 //  of the RDKit source tree.
 //
-
+#include <RDGeneral/export.h>
 #include <ctime>
 #include <limits>
 #ifdef RDK_BUILD_THREADSAFE_SSS
@@ -18,7 +18,7 @@
 #include "RGroupDecompData.h"
 #include "RGroupDecomp.h"
 #include "RGroupFingerprintScore.h"
-#include "../../../External/GA/util/Util.h"
+#include "GA/util/Util.h"
 
 // #define DEBUG
 
Index: openbabel-src/openbabel/src/formats/chemkinformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/chemkinformat.cpp b/openbabel-src/openbabel/src/formats/chemkinformat.cpp
--- a/openbabel-src/openbabel/src/formats/chemkinformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/chemkinformat.cpp	(date 1745583016133)
@@ -726,7 +726,7 @@
 
   string missing; // list of molecules which do not have thermodata
   OBConversion StdThermConv;
-  ifstream stdthermo;
+  istringstream stdthermo;
   OpenDatafile(stdthermo, datafilename);
   if(!stdthermo)
   {
Index: cppcoro-src/cppcoro/include/cppcoro/round_robin_scheduler.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/round_robin_scheduler.hpp b/cppcoro-src/cppcoro/include/cppcoro/round_robin_scheduler.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/round_robin_scheduler.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/round_robin_scheduler.hpp	(date 1745583016008)
@@ -7,7 +7,7 @@
 
 #include <cppcoro/config.hpp>
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <array>
 #include <cassert>
 #include <algorithm>
@@ -44,8 +44,8 @@
 				return false;
 			}
 
-			std::experimental::coroutine_handle<> await_suspend(
-				std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+			std::coroutine_handle<> await_suspend(
+				std::coroutine_handle<> awaitingCoroutine) noexcept
 			{
 				return m_scheduler.exchange_next(awaitingCoroutine);
 			}
@@ -61,7 +61,7 @@
 	public:
 		round_robin_scheduler() noexcept
 			: m_index(0)
-			, m_noop(std::experimental::noop_coroutine())
+			, m_noop(std::noop_coroutine())
 		{
 			for (size_t i = 0; i < N - 1; ++i)
 			{
@@ -104,8 +104,8 @@
 
 	private:
 
-		std::experimental::coroutine_handle exchange_next(
-			std::experimental::coroutine_handle<> coroutine) noexcept
+		std::coroutine_handle exchange_next(
+			std::coroutine_handle<> coroutine) noexcept
 		{
 			auto coroutineToResume = std::exchange(
 				m_scheduler.m_coroutines[m_scheduler.m_index],
@@ -115,8 +115,8 @@
 		}
 
 		size_t m_index;
-		const std::experimental::coroutine_handle<> m_noop;
-		std::array<std::experimental::coroutine_handle<>, N - 1> m_coroutines;
+		const std::coroutine_handle<> m_noop;
+		std::array<std::coroutine_handle<>, N - 1> m_coroutines;
 	};
 #endif
 }
Index: inchi-src/inchi/INCHI_BASE/src/ichicomp.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_BASE/src/ichicomp.h b/inchi-src/inchi/INCHI_BASE/src/ichicomp.h
--- a/inchi-src/inchi/INCHI_BASE/src/ichicomp.h	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_BASE/src/ichicomp.h	(date 1745583016023)
@@ -54,9 +54,11 @@
 
 /*  ANSI redefinitions */
 #ifdef COMPILE_ANSI_ONLY  /* { */
+#if 0
 #ifndef __isascii
 #define __isascii(val)  ((unsigned)(val) <= 0x7F)
 #endif
+#endif
 
 /* #ifndef __GNUC__ */
 /* these non-ANSI functions are implemented in gcc */
Index: openbabel-src/openbabel/src/formats/svgformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/svgformat.cpp b/openbabel-src/openbabel/src/formats/svgformat.cpp
--- a/openbabel-src/openbabel/src/formats/svgformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/svgformat.cpp	(date 1745583016148)
@@ -513,7 +513,7 @@
 //returns true if the file "svgformat.script" was inserted into the output
 bool SVGFormat::EmbedScript(ostream& ofs)
 {
-  ifstream ifs;
+  istringstream ifs;
   if(!ifs || OpenDatafile(ifs, "svgformat.script").empty())
     return false;
   ofs << ifs.rdbuf(); //copy whole file
Index: cppcoro-src/cppcoro/include/cppcoro/single_producer_sequencer.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/single_producer_sequencer.hpp b/cppcoro-src/cppcoro/include/cppcoro/single_producer_sequencer.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/single_producer_sequencer.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/single_producer_sequencer.hpp	(date 1745583016008)
@@ -160,7 +160,7 @@
 			return m_consumerWaitOperation.await_ready();
 		}
 
-		auto await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+		auto await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 		{
 			return m_consumerWaitOperation.await_suspend(awaitingCoroutine);
 		}
@@ -199,7 +199,7 @@
 			return m_consumerWaitOperation.await_ready();
 		}
 
-		auto await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+		auto await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 		{
 			return m_consumerWaitOperation.await_suspend(awaitingCoroutine);
 		}
Index: cppcoro-src/cppcoro/include/cppcoro/single_consumer_event.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/single_consumer_event.hpp b/cppcoro-src/cppcoro/include/cppcoro/single_consumer_event.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/single_consumer_event.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/single_consumer_event.hpp	(date 1745583016008)
@@ -6,7 +6,7 @@
 #define CPPCORO_SINGLE_CONSUMER_EVENT_HPP_INCLUDED
 
 #include <atomic>
-#include <experimental/coroutine>
+#include <coroutine>
 
 namespace cppcoro
 {
@@ -84,7 +84,7 @@
 					return m_event.is_set();
 				}
 
-				bool await_suspend(std::experimental::coroutine_handle<> awaiter)
+				bool await_suspend(std::coroutine_handle<> awaiter)
 				{
 					m_event.m_awaiter = awaiter;
 
@@ -120,7 +120,7 @@
 		// by encoding 'not_set' as 0 (nullptr), 'set' as 1 and
 		// 'not_set_consumer_waiting' as a coroutine handle pointer.
 		std::atomic<state> m_state;
-		std::experimental::coroutine_handle<> m_awaiter;
+		std::coroutine_handle<> m_awaiter;
 
 	};
 }
Index: cppcoro-src/cppcoro/include/cppcoro/multi_producer_sequencer.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/multi_producer_sequencer.hpp b/cppcoro-src/cppcoro/include/cppcoro/multi_producer_sequencer.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/multi_producer_sequencer.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/multi_producer_sequencer.hpp	(date 1745583016023)
@@ -194,7 +194,7 @@
 			return m_barrierWait.await_ready();
 		}
 
-		auto await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+		auto await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 		{
 			return m_barrierWait.await_suspend(awaitingCoroutine);
 		}
@@ -273,7 +273,7 @@
 			return m_waitOp.await_ready();
 		}
 
-		auto await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+		auto await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 		{
 			return m_waitOp.await_suspend(awaitingCoroutine);
 		}
@@ -347,7 +347,7 @@
 			return !TRAITS::precedes(m_lastKnownPublished, m_targetSequence);
 		}
 
-		bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+		bool await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 		{
 			m_awaitingCoroutine = awaitingCoroutine;
 
@@ -384,7 +384,7 @@
 		SEQUENCE m_targetSequence;
 		SEQUENCE m_lastKnownPublished;
 		multi_producer_sequencer_wait_operation_base* m_next;
-		std::experimental::coroutine_handle<> m_awaitingCoroutine;
+		std::coroutine_handle<> m_awaitingCoroutine;
 		std::atomic<bool> m_readyToResume;
 	};
 
Index: cppcoro-src/cppcoro/include/cppcoro/async_scope.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/async_scope.hpp b/cppcoro-src/cppcoro/include/cppcoro/async_scope.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/async_scope.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/async_scope.hpp	(date 1745583016039)
@@ -8,7 +8,7 @@
 #include <cppcoro/on_scope_exit.hpp>
 
 #include <atomic>
-#include <experimental/coroutine>
+#include <coroutine>
 #include <type_traits>
 #include <cassert>
 
@@ -52,7 +52,7 @@
 					return m_scope->m_count.load(std::memory_order_acquire) == 0;
 				}
 
-				bool await_suspend(std::experimental::coroutine_handle<> continuation) noexcept
+				bool await_suspend(std::coroutine_handle<> continuation) noexcept
 				{
 					m_scope->m_continuation = continuation;
 					return m_scope->m_count.fetch_sub(1u, std::memory_order_acq_rel) > 1u;
@@ -85,8 +85,8 @@
 		{
 			struct promise_type
 			{
-				std::experimental::suspend_never initial_suspend() { return {}; }
-				std::experimental::suspend_never final_suspend() { return {}; }
+				std::suspend_never initial_suspend() { return {}; }
+				std::suspend_never final_suspend() { return {}; }
 				void unhandled_exception() { std::terminate(); }
 				oneway_task get_return_object() { return {}; }
 				void return_void() {}
@@ -94,7 +94,7 @@
 		};
 
 		std::atomic<size_t> m_count;
-		std::experimental::coroutine_handle<> m_continuation;
+		std::coroutine_handle<> m_continuation;
 
 	};
 }
Index: cppcoro-src/cppcoro/include/cppcoro/io_service.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/io_service.hpp b/cppcoro-src/cppcoro/include/cppcoro/io_service.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/io_service.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/io_service.hpp	(date 1745583016008)
@@ -19,7 +19,7 @@
 #include <atomic>
 #include <utility>
 #include <mutex>
-#include <experimental/coroutine>
+#include <coroutine>
 
 namespace cppcoro
 {
@@ -192,7 +192,7 @@
 		{}
 
 		bool await_ready() const noexcept { return false; }
-		void await_suspend(std::experimental::coroutine_handle<> awaiter) noexcept;
+		void await_suspend(std::coroutine_handle<> awaiter) noexcept;
 		void await_resume() const noexcept {}
 
 	private:
@@ -201,7 +201,7 @@
 		friend class io_service::timed_schedule_operation;
 
 		io_service& m_service;
-		std::experimental::coroutine_handle<> m_awaiter;
+		std::coroutine_handle<> m_awaiter;
 		schedule_operation* m_next;
 
 	};
@@ -224,7 +224,7 @@
 		timed_schedule_operation& operator=(const timed_schedule_operation& other) = delete;
 
 		bool await_ready() const noexcept;
-		void await_suspend(std::experimental::coroutine_handle<> awaiter);
+		void await_suspend(std::coroutine_handle<> awaiter);
 		void await_resume();
 
 	private:
Index: cppcoro-src/cppcoro/include/cppcoro/sequence_barrier.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/sequence_barrier.hpp b/cppcoro-src/cppcoro/include/cppcoro/sequence_barrier.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/sequence_barrier.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/sequence_barrier.hpp	(date 1745583016008)
@@ -15,7 +15,7 @@
 #include <cstdint>
 #include <limits>
 #include <optional>
-#include <experimental/coroutine>
+#include <coroutine>
 
 namespace cppcoro
 {
@@ -161,7 +161,7 @@
 			return !TRAITS::precedes(m_lastKnownPublished, m_targetSequence);
 		}
 
-		bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+		bool await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 		{
 			m_awaitingCoroutine = awaitingCoroutine;
 			m_barrier.add_awaiter(this);
@@ -192,7 +192,7 @@
 		const SEQUENCE m_targetSequence;
 		SEQUENCE m_lastKnownPublished;
 		sequence_barrier_wait_operation_base* m_next;
-		std::experimental::coroutine_handle<> m_awaitingCoroutine;
+		std::coroutine_handle<> m_awaitingCoroutine;
 		std::atomic<bool> m_readyToResume;
 
 	};
Index: cppcoro-src/cppcoro/include/cppcoro/async_manual_reset_event.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/async_manual_reset_event.hpp b/cppcoro-src/cppcoro/include/cppcoro/async_manual_reset_event.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/async_manual_reset_event.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/async_manual_reset_event.hpp	(date 1745583016008)
@@ -5,7 +5,7 @@
 #ifndef CPPCORO_ASYNC_MANUAL_RESET_EVENT_HPP_INCLUDED
 #define CPPCORO_ASYNC_MANUAL_RESET_EVENT_HPP_INCLUDED
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <atomic>
 #include <cstdint>
 
@@ -87,7 +87,7 @@
 		explicit async_manual_reset_event_operation(const async_manual_reset_event& event) noexcept;
 
 		bool await_ready() const noexcept;
-		bool await_suspend(std::experimental::coroutine_handle<> awaiter) noexcept;
+		bool await_suspend(std::coroutine_handle<> awaiter) noexcept;
 		void await_resume() const noexcept {}
 
 	private:
@@ -96,7 +96,7 @@
 
 		const async_manual_reset_event& m_event;
 		async_manual_reset_event_operation* m_next;
-		std::experimental::coroutine_handle<> m_awaiter;
+		std::coroutine_handle<> m_awaiter;
 
 	};
 }
Index: openbabel-src/openbabel/src/formats/json/pubchemjsonformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/json/pubchemjsonformat.cpp b/openbabel-src/openbabel/src/formats/json/pubchemjsonformat.cpp
--- a/openbabel-src/openbabel/src/formats/json/pubchemjsonformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/json/pubchemjsonformat.cpp	(date 1745583015820)
@@ -760,7 +760,7 @@
       // Coordinates
       // TODO: An option to round coordinates to n decimal places?
       xcoords.PushBack(rapidjson::Value(patom->GetX()).Move(), al);
-      ycoords.PushBack(rapidjson::Value(patom->GetX()).Move(), al);
+      ycoords.PushBack(rapidjson::Value(patom->GetY()).Move(), al);
       if (pmol->GetDimension() == 3) {
         zcoords.PushBack(rapidjson::Value(patom->GetZ()).Move(), al);
       }
Index: inchi-src/inchi/INCHI_BASE/src/inchi_api.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_BASE/src/inchi_api.h b/inchi-src/inchi/INCHI_BASE/src/inchi_api.h
--- a/inchi-src/inchi/INCHI_BASE/src/inchi_api.h	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_BASE/src/inchi_api.h	(date 1745583016039)
@@ -681,6 +681,7 @@
  *************************************************/
 
 
+#if 0
 #if (defined( _WIN32 ) && defined( _MSC_VER ) && defined(BUILD_LINK_AS_DLL) )
     /* Win32 & MS VC ++, compile and link as a DLL */
 #ifdef _USRDLL
@@ -700,6 +701,19 @@
 #define EXPIMP_TEMPLATE
 #define INCHI_DECL
 #endif
+#endif
+#include "inchi_export.h"
+#ifdef _MSC_VER
+#define EXPIMP_TEMPLATE extern
+#else
+#define EXPIMP_TEMPLATE
+#endif
+#ifndef INCHI_API
+#define INCHI_API INCHI_EXPORT
+#endif
+#ifndef INCHI_DECL
+#define INCHI_DECL
+#endif
 
 /* Return codes for
         GetINCHI
Index: cppcoro-src/cppcoro/include/cppcoro/read_write_file.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/read_write_file.hpp b/cppcoro-src/cppcoro/include/cppcoro/read_write_file.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/read_write_file.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/read_write_file.hpp	(date 1745583015976)
@@ -11,7 +11,7 @@
 #include <cppcoro/file_buffering_mode.hpp>
 #include <cppcoro/file_open_mode.hpp>
 
-#include <experimental/filesystem>
+#include <filesystem>
 
 namespace cppcoro
 {
@@ -49,7 +49,7 @@
 		[[nodiscard]]
 		static read_write_file open(
 			io_service& ioService,
-			const std::experimental::filesystem::path& path,
+			const std::filesystem::path& path,
 			file_open_mode openMode = file_open_mode::create_or_open,
 			file_share_mode shareMode = file_share_mode::none,
 			file_buffering_mode bufferingMode = file_buffering_mode::default_);
Index: inchi-src/inchi/INCHI_BASE/src/ichicano.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_BASE/src/ichicano.c b/inchi-src/inchi/INCHI_BASE/src/ichicano.c
--- a/inchi-src/inchi/INCHI_BASE/src/ichicano.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_BASE/src/ichicano.c	(date 1745583016039)
@@ -37,7 +37,6 @@
 #include <string.h>
 #include <ctype.h>
 #include <time.h>
-#include <sys/timeb.h>
 
 #include "mode.h"
 #include "ichicano.h"
Index: cppcoro-src/cppcoro/include/cppcoro/inline_scheduler.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/inline_scheduler.hpp b/cppcoro-src/cppcoro/include/cppcoro/inline_scheduler.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/inline_scheduler.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/inline_scheduler.hpp	(date 1745583016023)
@@ -5,7 +5,7 @@
 #ifndef CPPCORO_INLINE_SCHEDULER_HPP_INCLUDED
 #define CPPCORO_INLINE_SCHEDULER_HPP_INCLUDED
 
-#include <experimental/coroutine>
+#include <coroutine>
 
 namespace cppcoro
 {
@@ -15,7 +15,7 @@
 
 		inline_scheduler() noexcept = default;
 
-		std::experimental::suspend_never schedule() const noexcept
+		std::suspend_never schedule() const noexcept
 		{
 			return {};
 		}
Index: cppcoro-src/cppcoro/include/cppcoro/file_write_operation.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/file_write_operation.hpp b/cppcoro-src/cppcoro/include/cppcoro/file_write_operation.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/file_write_operation.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/file_write_operation.hpp	(date 1745583015992)
@@ -11,7 +11,7 @@
 
 #include <atomic>
 #include <optional>
-#include <experimental/coroutine>
+#include <coroutine>
 
 #if CPPCORO_OS_WINNT
 # include <cppcoro/detail/win32.hpp>
Index: inchi-src/inchi/INCHI_BASE/src/runichi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_BASE/src/runichi.c b/inchi-src/inchi/INCHI_BASE/src/runichi.c
--- a/inchi-src/inchi/INCHI_BASE/src/runichi.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_BASE/src/runichi.c	(date 1745583016023)
@@ -3083,7 +3083,9 @@
         (i.e., delete a whole connected component(s) comprising original atoms)
         */
         int natnums = 0;
-        atnums = (int *)inchi_calloc(max_atoms, sizeof(int));
+        if (max_atoms > 0) {
+            atnums = (int *) inchi_calloc(max_atoms, sizeof(int));
+        }
         if (!atnums)
         {
             return _IS_ERROR;
Index: openbabel-src/openbabel/src/formats/pdbqtformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/pdbqtformat.cpp b/openbabel-src/openbabel/src/formats/pdbqtformat.cpp
--- a/openbabel-src/openbabel/src/formats/pdbqtformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/pdbqtformat.cpp	(date 1745583016148)
@@ -483,7 +483,7 @@
     return mol.DeleteNonPolarHydrogens();
   }
 
-  bool OutputTree(OBConversion* pConv, OBMol& mol, ostream& ofs, map <unsigned int, branch> & tree, unsigned int depth, bool moves_many, bool preserve_original_index)
+  bool OutputTree(OBConversion* pConv, OBMol& mol, ostream& ofs, map <size_t, branch> & tree, unsigned int depth, bool moves_many, bool preserve_original_index)
   {
     if (tree.empty()) {return false;}
     if (depth>= tree.size()-1) {depth=tree.size()-1;}
@@ -607,7 +607,7 @@
     return true;
   }
 
-  void ConstructTree (map <unsigned int, branch>& tree, vector <vector <int> > rigid_fragments, unsigned int root_piece, const OBMol& mol, bool flexible)
+  void ConstructTree (map <size_t, branch>& tree, vector <vector <int> > rigid_fragments, unsigned int root_piece, const OBMol& mol, bool flexible)
   {
     unsigned int first_atom = 0;
     unsigned int second_atom = 0;
@@ -651,7 +651,7 @@
             sprog.rigid_with.insert(sprog.index);
 
             (*tree.find(position)).second.children.insert(tree.size()); //tells the current parent it has an extra child
-                        tree.insert(pair<unsigned int, branch> (tree.size(), sprog)); //adds the current branch to the tree
+                        tree.insert(std::make_pair(tree.size(), sprog)); //adds the current branch to the tree
 
             rigid_fragments.erase(rigid_fragments.begin() + i);
             sterile=false;
@@ -747,7 +747,7 @@
     return false;
   }
 
-  unsigned int AtomsSoFar(const map <unsigned int, branch> & tree, unsigned int depth)
+  unsigned int AtomsSoFar(const map <size_t, branch> & tree, unsigned int depth)
   {
     if (depth > tree.size()) {return 0;}
     unsigned int numberAtoms=0;
@@ -985,7 +985,7 @@
 
       vector <vector <int> > rigid_fragments; //the vector of all the rigid molecule fragments, using atom indexes
       unsigned int best_root_atom=1;
-      map <unsigned int, branch> tree;
+      map <size_t, branch> tree;
       unsigned int torsdof=0;
       unsigned int root_piece=0;
       unsigned int rotatable_bonds=0;
Index: cppcoro-src/cppcoro/include/cppcoro/task.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/task.hpp b/cppcoro-src/cppcoro/include/cppcoro/task.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/task.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/task.hpp	(date 1745583015992)
@@ -18,7 +18,7 @@
 #include <cstdint>
 #include <cassert>
 
-#include <experimental/coroutine>
+#include <coroutine>
 
 namespace cppcoro
 {
@@ -36,8 +36,8 @@
 
 #if CPPCORO_COMPILER_SUPPORTS_SYMMETRIC_TRANSFER
 				template<typename PROMISE>
-				std::experimental::coroutine_handle<> await_suspend(
-					std::experimental::coroutine_handle<PROMISE> coro) noexcept
+				std::coroutine_handle<> await_suspend(
+					std::coroutine_handle<PROMISE> coro) noexcept
 				{
 					return coro.promise().m_continuation;
 				}
@@ -49,7 +49,7 @@
 				// were crashing under x86 optimised builds.
 				template<typename PROMISE>
 				CPPCORO_NOINLINE
-				void await_suspend(std::experimental::coroutine_handle<PROMISE> coroutine)
+				void await_suspend(std::coroutine_handle<PROMISE> coroutine)
 				{
 					task_promise_base& promise = coroutine.promise();
 
@@ -79,7 +79,7 @@
 
 			auto initial_suspend() noexcept
 			{
-				return std::experimental::suspend_always{};
+				return std::suspend_always{};
 			}
 
 			auto final_suspend() noexcept
@@ -88,12 +88,12 @@
 			}
 
 #if CPPCORO_COMPILER_SUPPORTS_SYMMETRIC_TRANSFER
-			void set_continuation(std::experimental::coroutine_handle<> continuation) noexcept
+			void set_continuation(std::coroutine_handle<> continuation) noexcept
 			{
 				m_continuation = continuation;
 			}
 #else
-			bool try_set_continuation(std::experimental::coroutine_handle<> continuation)
+			bool try_set_continuation(std::coroutine_handle<> continuation)
 			{
 				m_continuation = continuation;
 				return !m_state.exchange(true, std::memory_order_acq_rel);
@@ -102,7 +102,7 @@
 
 		private:
 
-			std::experimental::coroutine_handle<> m_continuation;
+			std::coroutine_handle<> m_continuation;
 
 #if !CPPCORO_COMPILER_SUPPORTS_SYMMETRIC_TRANSFER
 			// Initially false. Set to true when either a continuation is registered
@@ -292,9 +292,9 @@
 
 		struct awaitable_base
 		{
-			std::experimental::coroutine_handle<promise_type> m_coroutine;
+			std::coroutine_handle<promise_type> m_coroutine;
 
-			awaitable_base(std::experimental::coroutine_handle<promise_type> coroutine) noexcept
+			awaitable_base(std::coroutine_handle<promise_type> coroutine) noexcept
 				: m_coroutine(coroutine)
 			{}
 
@@ -304,14 +304,14 @@
 			}
 
 #if CPPCORO_COMPILER_SUPPORTS_SYMMETRIC_TRANSFER
-			std::experimental::coroutine_handle<> await_suspend(
-				std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+			std::coroutine_handle<> await_suspend(
+				std::coroutine_handle<> awaitingCoroutine) noexcept
 			{
 				m_coroutine.promise().set_continuation(awaitingCoroutine);
 				return m_coroutine;
 			}
 #else
-			bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+			bool await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 			{
 				// NOTE: We are using the bool-returning version of await_suspend() here
 				// to work around a potential stack-overflow issue if a coroutine
@@ -341,7 +341,7 @@
 			: m_coroutine(nullptr)
 		{}
 
-		explicit task(std::experimental::coroutine_handle<promise_type> coroutine)
+		explicit task(std::coroutine_handle<promise_type> coroutine)
 			: m_coroutine(coroutine)
 		{}
 
@@ -446,7 +446,7 @@
 
 	private:
 
-		std::experimental::coroutine_handle<promise_type> m_coroutine;
+		std::coroutine_handle<promise_type> m_coroutine;
 
 	};
 
@@ -455,18 +455,18 @@
 		template<typename T>
 		task<T> task_promise<T>::get_return_object() noexcept
 		{
-			return task<T>{ std::experimental::coroutine_handle<task_promise>::from_promise(*this) };
+			return task<T>{ std::coroutine_handle<task_promise>::from_promise(*this) };
 		}
 
 		inline task<void> task_promise<void>::get_return_object() noexcept
 		{
-			return task<void>{ std::experimental::coroutine_handle<task_promise>::from_promise(*this) };
+			return task<void>{ std::coroutine_handle<task_promise>::from_promise(*this) };
 		}
 
 		template<typename T>
 		task<T&> task_promise<T&>::get_return_object() noexcept
 		{
-			return task<T&>{ std::experimental::coroutine_handle<task_promise>::from_promise(*this) };
+			return task<T&>{ std::coroutine_handle<task_promise>::from_promise(*this) };
 		}
 	}
 
Index: cppcoro-src/cppcoro/include/cppcoro/write_only_file.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/write_only_file.hpp b/cppcoro-src/cppcoro/include/cppcoro/write_only_file.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/write_only_file.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/write_only_file.hpp	(date 1745583016039)
@@ -10,7 +10,7 @@
 #include <cppcoro/file_buffering_mode.hpp>
 #include <cppcoro/file_open_mode.hpp>
 
-#include <experimental/filesystem>
+#include <filesystem>
 
 namespace cppcoro
 {
@@ -48,7 +48,7 @@
 		[[nodiscard]]
 		static write_only_file open(
 			io_service& ioService,
-			const std::experimental::filesystem::path& path,
+			const std::filesystem::path& path,
 			file_open_mode openMode = file_open_mode::create_or_open,
 			file_share_mode shareMode = file_share_mode::none,
 			file_buffering_mode bufferingMode = file_buffering_mode::default_);
Index: cppcoro-src/cppcoro/include/cppcoro/async_mutex.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/async_mutex.hpp b/cppcoro-src/cppcoro/include/cppcoro/async_mutex.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/async_mutex.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/async_mutex.hpp	(date 1745583016008)
@@ -5,7 +5,7 @@
 #ifndef CPPCORO_ASYNC_MUTEX_HPP_INCLUDED
 #define CPPCORO_ASYNC_MUTEX_HPP_INCLUDED
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <atomic>
 #include <cstdint>
 #include <mutex> // for std::adopt_lock_t
@@ -166,7 +166,7 @@
 		{}
 
 		bool await_ready() const noexcept { return false; }
-		bool await_suspend(std::experimental::coroutine_handle<> awaiter) noexcept;
+		bool await_suspend(std::coroutine_handle<> awaiter) noexcept;
 		void await_resume() const noexcept {}
 
 	protected:
@@ -178,7 +178,7 @@
 	private:
 
 		async_mutex_lock_operation* m_next;
-		std::experimental::coroutine_handle<> m_awaiter;
+		std::coroutine_handle<> m_awaiter;
 
 	};
 
Index: cppcoro-src/cppcoro/include/cppcoro/async_auto_reset_event.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/async_auto_reset_event.hpp b/cppcoro-src/cppcoro/include/cppcoro/async_auto_reset_event.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/async_auto_reset_event.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/async_auto_reset_event.hpp	(date 1745583015976)
@@ -5,7 +5,7 @@
 #ifndef CPPCORO_ASYNC_AUTO_RESET_EVENT_HPP_INCLUDED
 #define CPPCORO_ASYNC_AUTO_RESET_EVENT_HPP_INCLUDED
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <atomic>
 #include <cstdint>
 
@@ -80,7 +80,7 @@
 		async_auto_reset_event_operation(const async_auto_reset_event_operation& other) noexcept;
 
 		bool await_ready() const noexcept { return m_event == nullptr; }
-		bool await_suspend(std::experimental::coroutine_handle<> awaiter) noexcept;
+		bool await_suspend(std::coroutine_handle<> awaiter) noexcept;
 		void await_resume() const noexcept {}
 
 	private:
@@ -89,7 +89,7 @@
 
 		const async_auto_reset_event* m_event;
 		async_auto_reset_event_operation* m_next;
-		std::experimental::coroutine_handle<> m_awaiter;
+		std::coroutine_handle<> m_awaiter;
 		std::atomic<std::uint32_t> m_refCount;
 
 	};
Index: cppcoro-src/cppcoro/include/cppcoro/file.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/file.hpp b/cppcoro-src/cppcoro/include/cppcoro/file.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/file.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/file.hpp	(date 1745583016008)
@@ -15,7 +15,7 @@
 # include <cppcoro/detail/win32.hpp>
 #endif
 
-#include <experimental/filesystem>
+#include <filesystem>
 
 namespace cppcoro
 {
@@ -40,7 +40,7 @@
 		static detail::win32::safe_handle open(
 			detail::win32::dword_t fileAccess,
 			io_service& ioService,
-			const std::experimental::filesystem::path& path,
+			const std::filesystem::path& path,
 			file_open_mode openMode,
 			file_share_mode shareMode,
 			file_buffering_mode bufferingMode);
Index: cppcoro-src/cppcoro/include/cppcoro/single_consumer_async_auto_reset_event.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/single_consumer_async_auto_reset_event.hpp b/cppcoro-src/cppcoro/include/cppcoro/single_consumer_async_auto_reset_event.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/single_consumer_async_auto_reset_event.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/single_consumer_async_auto_reset_event.hpp	(date 1745583015976)
@@ -5,7 +5,7 @@
 #ifndef CPPCORO_SINGLE_CONSUMER_ASYNC_AUTO_RESET_EVENT_HPP_INCLUDED
 #define CPPCORO_SINGLE_CONSUMER_ASYNC_AUTO_RESET_EVENT_HPP_INCLUDED
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <atomic>
 #include <cstdint>
 #include <cassert>
@@ -26,7 +26,7 @@
 			if (oldValue != nullptr && oldValue != this)
 			{
 				// There was a waiting coroutine that we now need to resume.
-				auto handle = *static_cast<std::experimental::coroutine_handle<>*>(oldValue);
+				auto handle = *static_cast<std::coroutine_handle<>*>(oldValue);
 
 				// We also need to transition the state back to 'not set' before
 				// resuming the coroutine. This operation needs to be 'acquire'
@@ -54,7 +54,7 @@
 
 				bool await_ready() const noexcept { return false; }
 				
-				bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+				bool await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 				{
 					m_awaitingCoroutine = awaitingCoroutine;
 
@@ -82,7 +82,7 @@
 
 			private:
 				const single_consumer_async_auto_reset_event& m_event;
-				std::experimental::coroutine_handle<> m_awaitingCoroutine;
+				std::coroutine_handle<> m_awaitingCoroutine;
 			};
 
 			return awaiter{ *this };
Index: rdkit-src/rdkit/External/GA/util/export.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/External/GA/util/export.h b/rdkit-src/rdkit/External/GA/util/export.h
--- a/rdkit-src/rdkit/External/GA/util/export.h	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/External/GA/util/export.h	(date 1745583015898)
@@ -10,6 +10,6 @@
 
 #pragma once
 
-#include <RDGeneral/RDExportMacros.h>
+#include <RDGeneral/export.h>
 
-#define GA_EXPORT RDKIT_EXPORT_API
+#define GA_EXPORT RDKIT_GA_EXPORT
Index: rdkit-src/rdkit/External/GA/util/Util.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/External/GA/util/Util.cpp b/rdkit-src/rdkit/External/GA/util/Util.cpp
--- a/rdkit-src/rdkit/External/GA/util/Util.cpp	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/External/GA/util/Util.cpp	(date 1745583015898)
@@ -42,18 +42,7 @@
 }
 
 string getUserName() {
-#ifdef WIN32
-  return "UNKNOWN";
-#else
-  const int bufsize = 100;
-  char buffer[bufsize];
-
-  if (!getlogin_r(buffer, bufsize)) {
-    return string(buffer);
-  } else {
-    return string("");
-  }
-#endif
+    return "UNKNOWN";
 }
 
 string &removeTrailingLF(string &line) {
Index: cppcoro-src/cppcoro/include/cppcoro/generator.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/generator.hpp b/cppcoro-src/cppcoro/include/cppcoro/generator.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/generator.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/generator.hpp	(date 1745583015992)
@@ -5,7 +5,7 @@
 #ifndef CPPCORO_GENERATOR_HPP_INCLUDED
 #define CPPCORO_GENERATOR_HPP_INCLUDED
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <type_traits>
 #include <utility>
 #include <exception>
@@ -32,19 +32,19 @@
 
 			generator<T> get_return_object() noexcept;
 
-			constexpr std::experimental::suspend_always initial_suspend() const noexcept { return {}; }
-			constexpr std::experimental::suspend_always final_suspend() const noexcept { return {}; }
+			constexpr std::suspend_always initial_suspend() const noexcept { return {}; }
+			constexpr std::suspend_always final_suspend() const noexcept { return {}; }
 
 			template<
 				typename U = T,
 				std::enable_if_t<!std::is_rvalue_reference<U>::value, int> = 0>
-			std::experimental::suspend_always yield_value(std::remove_reference_t<T>& value) noexcept
+			std::suspend_always yield_value(std::remove_reference_t<T>& value) noexcept
 			{
 				m_value = std::addressof(value);
 				return {};
 			}
 
-			std::experimental::suspend_always yield_value(std::remove_reference_t<T>&& value) noexcept
+			std::suspend_always yield_value(std::remove_reference_t<T>&& value) noexcept
 			{
 				m_value = std::addressof(value);
 				return {};
@@ -66,7 +66,7 @@
 
 			// Don't allow any use of 'co_await' inside the generator coroutine.
 			template<typename U>
-			std::experimental::suspend_never await_transform(U&& value) = delete;
+			std::suspend_never await_transform(U&& value) = delete;
 
 			void rethrow_if_exception()
 			{
@@ -88,7 +88,7 @@
 		template<typename T>
 		class generator_iterator
 		{
-			using coroutine_handle = std::experimental::coroutine_handle<generator_promise<T>>;
+			using coroutine_handle = std::coroutine_handle<generator_promise<T>>;
 
 		public:
 
@@ -223,11 +223,11 @@
 
 		friend class detail::generator_promise<T>;
 
-		explicit generator(std::experimental::coroutine_handle<promise_type> coroutine) noexcept
+		explicit generator(std::coroutine_handle<promise_type> coroutine) noexcept
 			: m_coroutine(coroutine)
 		{}
 
-		std::experimental::coroutine_handle<promise_type> m_coroutine;
+		std::coroutine_handle<promise_type> m_coroutine;
 
 	};
 
@@ -242,7 +242,7 @@
 		template<typename T>
 		generator<T> generator_promise<T>::get_return_object() noexcept
 		{
-			using coroutine_handle = std::experimental::coroutine_handle<generator_promise<T>>;
+			using coroutine_handle = std::coroutine_handle<generator_promise<T>>;
 			return generator<T>{ coroutine_handle::from_promise(*this) };
 		}
 	}
Index: cppcoro-src/cppcoro/include/cppcoro/fmap.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/fmap.hpp b/cppcoro-src/cppcoro/include/cppcoro/fmap.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/fmap.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/fmap.hpp	(date 1745583015992)
@@ -40,7 +40,7 @@
 			}
 
 			template<typename PROMISE>
-			decltype(auto) await_suspend(std::experimental::coroutine_handle<PROMISE> coro)
+			decltype(auto) await_suspend(std::coroutine_handle<PROMISE> coro)
 				noexcept(noexcept(static_cast<awaiter_t&&>(m_awaiter).await_suspend(std::move(coro))))
 			{
 				return static_cast<awaiter_t&&>(m_awaiter).await_suspend(std::move(coro));
Index: cppcoro-src/cppcoro/include/cppcoro/shared_task.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/shared_task.hpp b/cppcoro-src/cppcoro/include/cppcoro/shared_task.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/shared_task.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/shared_task.hpp	(date 1745583016008)
@@ -17,7 +17,7 @@
 #include <utility>
 #include <type_traits>
 
-#include <experimental/coroutine>
+#include <coroutine>
 
 namespace cppcoro
 {
@@ -28,7 +28,7 @@
 	{
 		struct shared_task_waiter
 		{
-			std::experimental::coroutine_handle<> m_continuation;
+			std::coroutine_handle<> m_continuation;
 			shared_task_waiter* m_next;
 		};
 
@@ -41,7 +41,7 @@
 				bool await_ready() const noexcept { return false; }
 
 				template<typename PROMISE>
-				void await_suspend(std::experimental::coroutine_handle<PROMISE> h) noexcept
+				void await_suspend(std::coroutine_handle<PROMISE> h) noexcept
 				{
 					shared_task_promise_base& promise = h.promise();
 
@@ -79,7 +79,7 @@
 				, m_exception(nullptr)
 			{}
 
-			std::experimental::suspend_always initial_suspend() noexcept { return {}; }
+			std::suspend_always initial_suspend() noexcept { return {}; }
 			final_awaiter final_suspend() noexcept { return {}; }
 
 			void unhandled_exception() noexcept
@@ -124,7 +124,7 @@
 			/// waiter->m_coroutine will be resumed when the task completes.
 			/// false if the coroutine was already completed and the awaiting
 			/// coroutine can continue without suspending.
-			bool try_await(shared_task_waiter* waiter, std::experimental::coroutine_handle<> coroutine)
+			bool try_await(shared_task_waiter* waiter, std::coroutine_handle<> coroutine)
 			{
 				void* const valueReadyValue = this;
 				void* const notStartedValue = &this->m_waiters;
@@ -304,10 +304,10 @@
 
 		struct awaitable_base
 		{
-			std::experimental::coroutine_handle<promise_type> m_coroutine;
+			std::coroutine_handle<promise_type> m_coroutine;
 			detail::shared_task_waiter m_waiter;
 
-			awaitable_base(std::experimental::coroutine_handle<promise_type> coroutine) noexcept
+			awaitable_base(std::coroutine_handle<promise_type> coroutine) noexcept
 				: m_coroutine(coroutine)
 			{}
 
@@ -316,7 +316,7 @@
 				return !m_coroutine || m_coroutine.promise().is_ready();
 			}
 
-			bool await_suspend(std::experimental::coroutine_handle<> awaiter) noexcept
+			bool await_suspend(std::coroutine_handle<> awaiter) noexcept
 			{
 				m_waiter.m_continuation = awaiter;
 				return m_coroutine.promise().try_await(&m_waiter, m_coroutine);
@@ -329,7 +329,7 @@
 			: m_coroutine(nullptr)
 		{}
 
-		explicit shared_task(std::experimental::coroutine_handle<promise_type> coroutine)
+		explicit shared_task(std::coroutine_handle<promise_type> coroutine)
 			: m_coroutine(coroutine)
 		{
 			// Don't increment the ref-count here since it has already been
@@ -452,7 +452,7 @@
 			}
 		}
 
-		std::experimental::coroutine_handle<promise_type> m_coroutine;
+		std::coroutine_handle<promise_type> m_coroutine;
 
 	};
 
@@ -480,7 +480,7 @@
 		shared_task<T> shared_task_promise<T>::get_return_object() noexcept
 		{
 			return shared_task<T>{
-				std::experimental::coroutine_handle<shared_task_promise>::from_promise(*this)
+				std::coroutine_handle<shared_task_promise>::from_promise(*this)
 			};
 		}
 
@@ -488,14 +488,14 @@
 		shared_task<T&> shared_task_promise<T&>::get_return_object() noexcept
 		{
 			return shared_task<T&>{
-				std::experimental::coroutine_handle<shared_task_promise>::from_promise(*this)
+				std::coroutine_handle<shared_task_promise>::from_promise(*this)
 			};
 		}
 
 		inline shared_task<void> shared_task_promise<void>::get_return_object() noexcept
 		{
 			return shared_task<void>{
-				std::experimental::coroutine_handle<shared_task_promise>::from_promise(*this)
+				std::coroutine_handle<shared_task_promise>::from_promise(*this)
 			};
 		}
 	}
Index: cppcoro-src/cppcoro/include/cppcoro/file_read_operation.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/file_read_operation.hpp b/cppcoro-src/cppcoro/include/cppcoro/file_read_operation.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/file_read_operation.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/file_read_operation.hpp	(date 1745583016039)
@@ -11,7 +11,7 @@
 
 #include <atomic>
 #include <optional>
-#include <experimental/coroutine>
+#include <coroutine>
 
 #if CPPCORO_OS_WINNT
 # include <cppcoro/detail/win32.hpp>
Index: libxml2-src/libxml2/include/libxml/xmlexports.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libxml2-src/libxml2/include/libxml/xmlexports.h b/libxml2-src/libxml2/include/libxml/xmlexports.h
--- a/libxml2-src/libxml2/include/libxml/xmlexports.h	(revision 0e145ae4881c2a05ae00128a3bd90d76d4dadc4b)
+++ b/libxml2-src/libxml2/include/libxml/xmlexports.h	(date 1745583016039)
@@ -14,6 +14,7 @@
  * Symbol visibility
  */
 
+#if 0
 #if defined(_WIN32) || defined(__CYGWIN__)
   #ifdef LIBXML_STATIC
     #define XMLPUBLIC
@@ -25,6 +26,12 @@
 #else /* not Windows */
   #define XMLPUBLIC
 #endif /* platform switch */
+#endif
+
+#include "xml2_export.h"
+#ifndef XMLPUBLIC
+#define XMLPUBLIC XML2_EXPORT
+#endif
 
 #define XMLPUBFUN XMLPUBLIC
 
Index: inchi-src/inchi/INCHI_BASE/src/util.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_BASE/src/util.c b/inchi-src/inchi/INCHI_BASE/src/util.c
--- a/inchi-src/inchi/INCHI_BASE/src/util.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_BASE/src/util.c	(date 1745583016039)
@@ -38,10 +38,12 @@
 
 #include "mode.h"
 
+#if 0
 #if defined(COMPILE_ANSI_ONLY) && defined(__APPLE__)
 /*    For build under OSX, advice from Burt Leland */
 #include "ichicomp.h"    /* Needed for __isascii define */
 #endif
+#endif
 
 #include "util.h"
 #include "extr_ct.h"
@@ -1741,13 +1743,13 @@
 
     if (p && ( len = (int) strlen( p ) ))
     {
-        for (i = 0; i < len && __isascii( p[i] ) && isspace( p[i] ); i++)
+        for (i = 0; i < len && isascii( p[i] ) && isspace( p[i] ); i++)
         {
             ;
         }
         if (i)
             (memmove) ( p, p + i, ( len -= i ) + 1 );
-        for (; 0 < len && __isascii( p[len - 1] ) && isspace( p[len - 1] ); len--)
+        for (; 0 < len && isascii( p[len - 1] ) && isspace( p[len - 1] ); len--)
         {
             ;
         }
Index: cppcoro-src/cppcoro/include/cppcoro/recursive_generator.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/recursive_generator.hpp b/cppcoro-src/cppcoro/include/cppcoro/recursive_generator.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/recursive_generator.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/recursive_generator.hpp	(date 1745583015976)
@@ -7,7 +7,7 @@
 
 #include <cppcoro/generator.hpp>
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <type_traits>
 #include <utility>
 #include <cassert>
@@ -39,12 +39,12 @@
 				return recursive_generator<T>{ *this };
 			}
 
-			std::experimental::suspend_always initial_suspend() noexcept
+			std::suspend_always initial_suspend() noexcept
 			{
 				return {};
 			}
 
-			std::experimental::suspend_always final_suspend() noexcept
+			std::suspend_always final_suspend() noexcept
 			{
 				return {};
 			}
@@ -56,13 +56,13 @@
 
 			void return_void() noexcept {}
 
-			std::experimental::suspend_always yield_value(T& value) noexcept
+			std::suspend_always yield_value(T& value) noexcept
 			{
 				m_value = std::addressof(value);
 				return {};
 			}
 
-			std::experimental::suspend_always yield_value(T&& value) noexcept
+			std::suspend_always yield_value(T&& value) noexcept
 			{
 				m_value = std::addressof(value);
 				return {};
@@ -87,7 +87,7 @@
 						return this->m_childPromise == nullptr;
 					}
 
-					void await_suspend(std::experimental::coroutine_handle<promise_type>) noexcept
+					void await_suspend(std::coroutine_handle<promise_type>) noexcept
 					{}
 
 					void await_resume()
@@ -122,11 +122,11 @@
 
 			// Don't allow any use of 'co_await' inside the recursive_generator coroutine.
 			template<typename U>
-			std::experimental::suspend_never await_transform(U&& value) = delete;
+			std::suspend_never await_transform(U&& value) = delete;
 
 			void destroy() noexcept
 			{
-				std::experimental::coroutine_handle<promise_type>::from_promise(*this).destroy();
+				std::coroutine_handle<promise_type>::from_promise(*this).destroy();
 			}
 
 			void throw_if_exception()
@@ -139,7 +139,7 @@
 
 			bool is_complete() noexcept
 			{
-				return std::experimental::coroutine_handle<promise_type>::from_promise(*this).done();
+				return std::coroutine_handle<promise_type>::from_promise(*this).done();
 			}
 
 			T& value() noexcept
@@ -167,7 +167,7 @@
 
 			void resume() noexcept
 			{
-				std::experimental::coroutine_handle<promise_type>::from_promise(*this).resume();
+				std::coroutine_handle<promise_type>::from_promise(*this).resume();
 			}
 
 			std::add_pointer_t<T> m_value;
Index: cppcoro-src/cppcoro/include/cppcoro/static_thread_pool.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/static_thread_pool.hpp b/cppcoro-src/cppcoro/include/cppcoro/static_thread_pool.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/static_thread_pool.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/static_thread_pool.hpp	(date 1745583016008)
@@ -11,7 +11,7 @@
 #include <thread>
 #include <vector>
 #include <mutex>
-#include <experimental/coroutine>
+#include <coroutine>
 
 namespace cppcoro
 {
@@ -38,7 +38,7 @@
 			schedule_operation(static_thread_pool* tp) noexcept : m_threadPool(tp) {}
 
 			bool await_ready() noexcept { return false; }
-			void await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept;
+			void await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept;
 			void await_resume() noexcept {}
 
 		private:
@@ -46,7 +46,7 @@
 			friend class static_thread_pool;
 
 			static_thread_pool* m_threadPool;
-			std::experimental::coroutine_handle<> m_awaitingCoroutine;
+			std::coroutine_handle<> m_awaitingCoroutine;
 			schedule_operation* m_next;
 
 		};
Index: rdkit-src/rdkit/External/GA/ga/GaBase.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/External/GA/ga/GaBase.h b/rdkit-src/rdkit/External/GA/ga/GaBase.h
--- a/rdkit-src/rdkit/External/GA/ga/GaBase.h	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/External/GA/ga/GaBase.h	(date 1745583015867)
@@ -34,8 +34,8 @@
   GaBase &operator=(const GaBase &other) = delete;
 
  public:
-  GaBase() {};
-  virtual ~GaBase() {};
+  GaBase();
+  virtual ~GaBase();
 
   double getSelectionPressure() const { return selectionPressure; }
 
Index: cppcoro-src/cppcoro/include/cppcoro/async_generator.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/async_generator.hpp b/cppcoro-src/cppcoro/include/cppcoro/async_generator.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/async_generator.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/async_generator.hpp	(date 1745583016039)
@@ -12,7 +12,7 @@
 #include <atomic>
 #include <iterator>
 #include <type_traits>
-#include <experimental/coroutine>
+#include <coroutine>
 #include <functional>
 #include <cassert>
 
@@ -45,7 +45,7 @@
 			async_generator_promise_base(const async_generator_promise_base& other) = delete;
 			async_generator_promise_base& operator=(const async_generator_promise_base& other) = delete;
 
-			std::experimental::suspend_always initial_suspend() const noexcept
+			std::suspend_always initial_suspend() const noexcept
 			{
 				return {};
 			}
@@ -89,7 +89,7 @@
 
 			std::exception_ptr m_exception;
 
-			std::experimental::coroutine_handle<> m_consumerCoroutine;
+			std::coroutine_handle<> m_consumerCoroutine;
 
 		protected:
 
@@ -100,7 +100,7 @@
 		{
 		public:
 
-			async_generator_yield_operation(std::experimental::coroutine_handle<> consumer) noexcept
+			async_generator_yield_operation(std::coroutine_handle<> consumer) noexcept
 				: m_consumer(consumer)
 			{}
 
@@ -109,8 +109,8 @@
 				return false;
 			}
 
-			std::experimental::coroutine_handle<>
-			await_suspend([[maybe_unused]] std::experimental::coroutine_handle<> producer) noexcept
+			std::coroutine_handle<>
+			await_suspend([[maybe_unused]] std::coroutine_handle<> producer) noexcept
 			{
 				return m_consumer;
 			}
@@ -119,7 +119,7 @@
 
 		private:
 
-			std::experimental::coroutine_handle<> m_consumer;
+			std::coroutine_handle<> m_consumer;
 
 		};
 
@@ -145,7 +145,7 @@
 
 			async_generator_advance_operation(
 				async_generator_promise_base& promise,
-				std::experimental::coroutine_handle<> producerCoroutine) noexcept
+				std::coroutine_handle<> producerCoroutine) noexcept
 				: m_promise(std::addressof(promise))
 				, m_producerCoroutine(producerCoroutine)
 			{
@@ -155,8 +155,8 @@
 
 			bool await_ready() const noexcept { return false; }
 
-			std::experimental::coroutine_handle<>
-				await_suspend(std::experimental::coroutine_handle<> consumerCoroutine) noexcept
+			std::coroutine_handle<>
+				await_suspend(std::coroutine_handle<> consumerCoroutine) noexcept
 			{
 				m_promise->m_consumerCoroutine = consumerCoroutine;
 				return m_producerCoroutine;
@@ -165,7 +165,7 @@
 		protected:
 
 			async_generator_promise_base* m_promise;
-			std::experimental::coroutine_handle<> m_producerCoroutine;
+			std::coroutine_handle<> m_producerCoroutine;
 
 		};
 
@@ -242,7 +242,7 @@
 		class async_generator_iterator final
 		{
 			using promise_type = async_generator_promise<T>;
-			using handle_type = std::experimental::coroutine_handle<promise_type>;
+			using handle_type = std::coroutine_handle<promise_type>;
 
 		public:
 
@@ -307,7 +307,7 @@
 		class async_generator_begin_operation final : public async_generator_advance_operation
 		{
 			using promise_type = async_generator_promise<T>;
-			using handle_type = std::experimental::coroutine_handle<promise_type>;
+			using handle_type = std::coroutine_handle<promise_type>;
 
 		public:
 
@@ -358,7 +358,7 @@
 		{}
 
 		explicit async_generator(promise_type& promise) noexcept
-			: m_coroutine(std::experimental::coroutine_handle<promise_type>::from_promise(promise))
+			: m_coroutine(std::coroutine_handle<promise_type>::from_promise(promise))
 		{}
 
 		async_generator(async_generator&& other) noexcept
@@ -408,7 +408,7 @@
 
 	private:
 
-		std::experimental::coroutine_handle<promise_type> m_coroutine;
+		std::coroutine_handle<promise_type> m_coroutine;
 
 	};
 
@@ -451,7 +451,7 @@
 			async_generator_promise_base(const async_generator_promise_base& other) = delete;
 			async_generator_promise_base& operator=(const async_generator_promise_base& other) = delete;
 
-			std::experimental::suspend_always initial_suspend() const noexcept
+			std::suspend_always initial_suspend() const noexcept
 			{
 				return {};
 			}
@@ -556,7 +556,7 @@
 
 			std::exception_ptr m_exception;
 
-			std::experimental::coroutine_handle<> m_consumerCoroutine;
+			std::coroutine_handle<> m_consumerCoroutine;
 
 		protected:
 
@@ -579,7 +579,7 @@
 				return m_initialState == state::value_not_ready_consumer_suspended;
 			}
 
-			bool await_suspend(std::experimental::coroutine_handle<> producer) noexcept;
+			bool await_suspend(std::coroutine_handle<> producer) noexcept;
 
 			void await_resume() noexcept {}
 
@@ -625,7 +625,7 @@
 		}
 
 		inline bool async_generator_yield_operation::await_suspend(
-			std::experimental::coroutine_handle<> producer) noexcept
+			std::coroutine_handle<> producer) noexcept
 		{
 			state currentState = m_initialState;
 			if (currentState == state::value_not_ready_consumer_active)
@@ -711,7 +711,7 @@
 
 			async_generator_advance_operation(
 				async_generator_promise_base& promise,
-				std::experimental::coroutine_handle<> producerCoroutine) noexcept
+				std::coroutine_handle<> producerCoroutine) noexcept
 				: m_promise(std::addressof(promise))
 				, m_producerCoroutine(producerCoroutine)
 			{
@@ -740,7 +740,7 @@
 				return m_initialState == state::value_ready_producer_suspended;
 			}
 
-			bool await_suspend(std::experimental::coroutine_handle<> consumerCoroutine) noexcept
+			bool await_suspend(std::coroutine_handle<> consumerCoroutine) noexcept
 			{
 				m_promise->m_consumerCoroutine = consumerCoroutine;
 
@@ -791,7 +791,7 @@
 		protected:
 
 			async_generator_promise_base* m_promise;
-			std::experimental::coroutine_handle<> m_producerCoroutine;
+			std::coroutine_handle<> m_producerCoroutine;
 
 		private:
 
@@ -872,7 +872,7 @@
 		class async_generator_iterator final
 		{
 			using promise_type = async_generator_promise<T>;
-			using handle_type = std::experimental::coroutine_handle<promise_type>;
+			using handle_type = std::coroutine_handle<promise_type>;
 
 		public:
 
@@ -937,7 +937,7 @@
 		class async_generator_begin_operation final : public async_generator_advance_operation
 		{
 			using promise_type = async_generator_promise<T>;
-			using handle_type = std::experimental::coroutine_handle<promise_type>;
+			using handle_type = std::coroutine_handle<promise_type>;
 
 		public:
 
@@ -988,7 +988,7 @@
 		{}
 
 		explicit async_generator(promise_type& promise) noexcept
-			: m_coroutine(std::experimental::coroutine_handle<promise_type>::from_promise(promise))
+			: m_coroutine(std::coroutine_handle<promise_type>::from_promise(promise))
 		{}
 
 		async_generator(async_generator&& other) noexcept
@@ -1041,7 +1041,7 @@
 
 	private:
 
-		std::experimental::coroutine_handle<promise_type> m_coroutine;
+		std::coroutine_handle<promise_type> m_coroutine;
 
 	};
 
Index: svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_presentation_attributes.inc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_presentation_attributes.inc b/svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_presentation_attributes.inc
--- a/svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_presentation_attributes.inc	(revision 5f1870aa7b757718ff5f86bdfb55966fa4f217f9)
+++ b/svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_presentation_attributes.inc	(date 1745583015851)
@@ -16,6 +16,9 @@
 SVGPP_ON(color_rendering)
 SVGPP_ON(color)
 SVGPP_ON(cursor)
+SVGPP_ON(data_c)
+SVGPP_ON(data_mjx_texclass)
+SVGPP_ON(data_mml_node)
 SVGPP_ON(direction)
 SVGPP_ON(display)
 SVGPP_ON(dominant_baseline)
Index: svgpp-src/svgpp/include/svgpp/parser/number.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/parser/number.hpp b/svgpp-src/svgpp/include/svgpp/parser/number.hpp
--- a/svgpp-src/svgpp/include/svgpp/parser/number.hpp	(revision 5f1870aa7b757718ff5f86bdfb55966fa4f217f9)
+++ b/svgpp-src/svgpp/include/svgpp/parser/number.hpp	(date 1745583015867)
@@ -105,7 +105,7 @@
           number [phx::ref(value1) = _1] 
           >> -(
               comma_wsp 
-              >> number [phx::ref(value2) = _1, phx::ref(two_values) = true]
+              >> number [(phx::ref(value2) = _1, phx::ref(two_values) = true)]
               )
       ) && it == end)
     {
Index: svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_all_attributes.inc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_all_attributes.inc b/svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_all_attributes.inc
--- a/svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_all_attributes.inc	(revision 5f1870aa7b757718ff5f86bdfb55966fa4f217f9)
+++ b/svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_all_attributes.inc	(date 1745583015851)
@@ -43,6 +43,9 @@
 SVGPP_ON      (cx                                 , cx)
 SVGPP_ON      (cy                                 , cy)
 SVGPP_ON      (d                                  , d)
+SVGPP_ON_STYLE(data_c                             , data-c)
+SVGPP_ON_STYLE(data_mjx_texclass                  , data-mjx-texclass)
+SVGPP_ON_STYLE(data_mml_node                      , data-mml-node)
 SVGPP_ON      (descent                            , descent)
 SVGPP_ON      (diffuseConstant                    , diffuseConstant)
 SVGPP_ON_STYLE(direction                          , direction)
Index: cppcoro-src/cppcoro/include/cppcoro/read_only_file.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/read_only_file.hpp b/cppcoro-src/cppcoro/include/cppcoro/read_only_file.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/read_only_file.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/read_only_file.hpp	(date 1745583016023)
@@ -9,7 +9,7 @@
 #include <cppcoro/file_share_mode.hpp>
 #include <cppcoro/file_buffering_mode.hpp>
 
-#include <experimental/filesystem>
+#include <filesystem>
 
 namespace cppcoro
 {
@@ -43,7 +43,7 @@
 		[[nodiscard]]
 		static read_only_file open(
 			io_service& ioService,
-			const std::experimental::filesystem::path& path,
+			const std::filesystem::path& path,
 			file_share_mode shareMode = file_share_mode::read,
 			file_buffering_mode bufferingMode = file_buffering_mode::default_);
 
Index: cairo-src/cairo/src/cairo-ps-surface.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cairo-src/cairo/src/cairo-ps-surface.c b/cairo-src/cairo/src/cairo-ps-surface.c
--- a/cairo-src/cairo/src/cairo-ps-surface.c	(revision 4541e0cd3a751b85e52e2a83d02ac6145a5efa85)
+++ b/cairo-src/cairo/src/cairo-ps-surface.c	(date 1745583015976)
@@ -102,7 +102,7 @@
 #define DEBUG_FALLBACK(s)
 #endif
 
-#ifndef HAVE_CTIME_R
+#if !defined(HAVE_CTIME_R) && !defined(unix)
 static char *ctime_r(const time_t *timep, char *buf)
 {
     (void)buf;
Index: cppcoro-src/cppcoro/include/cppcoro/net/socket_accept_operation.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/net/socket_accept_operation.hpp b/cppcoro-src/cppcoro/include/cppcoro/net/socket_accept_operation.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/net/socket_accept_operation.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/net/socket_accept_operation.hpp	(date 1745583016054)
@@ -15,7 +15,7 @@
 
 # include <atomic>
 # include <optional>
-# include <experimental/coroutine>
+# include <coroutine>
 
 namespace cppcoro
 {
Index: cppcoro-src/cppcoro/include/cppcoro/detail/sync_wait_task.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/detail/sync_wait_task.hpp b/cppcoro-src/cppcoro/include/cppcoro/detail/sync_wait_task.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/detail/sync_wait_task.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/detail/sync_wait_task.hpp	(date 1745583016039)
@@ -9,7 +9,7 @@
 #include <cppcoro/awaitable_traits.hpp>
 #include <cppcoro/detail/lightweight_manual_reset_event.hpp>
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <cassert>
 #include <exception>
 #include <utility>
@@ -24,7 +24,7 @@
 		template<typename RESULT>
 		class sync_wait_task_promise final
 		{
-			using coroutine_handle_t = std::experimental::coroutine_handle<sync_wait_task_promise<RESULT>>;
+			using coroutine_handle_t = std::coroutine_handle<sync_wait_task_promise<RESULT>>;
 
 		public:
 
@@ -44,7 +44,7 @@
 				return coroutine_handle_t::from_promise(*this);
 			}
 
-			std::experimental::suspend_always initial_suspend() noexcept
+			std::suspend_always initial_suspend() noexcept
 			{
 				return{};
 			}
@@ -89,7 +89,7 @@
 					bool await_ready() noexcept {
 						return true;
 					}
-					void await_suspend(std::experimental::coroutine_handle<>) noexcept {}
+					void await_suspend(std::coroutine_handle<>) noexcept {}
 					sync_wait_task_promise& await_resume() noexcept
 					{
 						return *m_promise;
@@ -140,7 +140,7 @@
 		template<>
 		class sync_wait_task_promise<void>
 		{
-			using coroutine_handle_t = std::experimental::coroutine_handle<sync_wait_task_promise<void>>;
+			using coroutine_handle_t = std::coroutine_handle<sync_wait_task_promise<void>>;
 
 		public:
 
@@ -158,7 +158,7 @@
 				return coroutine_handle_t::from_promise(*this);
 			}
 
-			std::experimental::suspend_always initial_suspend() noexcept
+			std::suspend_always initial_suspend() noexcept
 			{
 				return{};
 			}
@@ -211,7 +211,7 @@
 
 			using promise_type = sync_wait_task_promise<RESULT>;
 
-			using coroutine_handle_t = std::experimental::coroutine_handle<promise_type>;
+			using coroutine_handle_t = std::coroutine_handle<promise_type>;
 
 			sync_wait_task(coroutine_handle_t coroutine) noexcept
 				: m_coroutine(coroutine)
Index: rdkit-src/rdkit/Code/RDGeneral/Invariant.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/RDGeneral/Invariant.h b/rdkit-src/rdkit/Code/RDGeneral/Invariant.h
--- a/rdkit-src/rdkit/Code/RDGeneral/Invariant.h	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Code/RDGeneral/Invariant.h	(date 1745583015851)
@@ -26,9 +26,9 @@
 // Enable RDDEBUG for testing whether rdcast
 //  conversions are within numerical limits
 #include <RDGeneral/BoostStartInclude.h>
-#include <boost/numeric/conversion/cast.hpp>
 #include <RDGeneral/BoostEndInclude.h>
 #endif
+#include <boost/numeric/conversion/cast.hpp>
 //
 // What if no invariant method is defined?
 //
Index: cppcoro-src/cppcoro/include/cppcoro/detail/is_awaiter.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/detail/is_awaiter.hpp b/cppcoro-src/cppcoro/include/cppcoro/detail/is_awaiter.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/detail/is_awaiter.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/detail/is_awaiter.hpp	(date 1745583016070)
@@ -6,7 +6,7 @@
 #define CPPCORO_DETAIL_IS_AWAITER_HPP_INCLUDED
 
 #include <type_traits>
-#include <experimental/coroutine>
+#include <coroutine>
 
 namespace cppcoro
 {
@@ -18,7 +18,7 @@
 		{};
 
 		template<typename PROMISE>
-		struct is_coroutine_handle<std::experimental::coroutine_handle<PROMISE>>
+		struct is_coroutine_handle<std::coroutine_handle<PROMISE>>
 			: std::true_type
 		{};
 
@@ -42,12 +42,12 @@
 		template<typename T>
 		struct is_awaiter<T, std::void_t<
 			decltype(std::declval<T>().await_ready()),
-			decltype(std::declval<T>().await_suspend(std::declval<std::experimental::coroutine_handle<>>())),
+			decltype(std::declval<T>().await_suspend(std::declval<std::coroutine_handle<>>())),
 			decltype(std::declval<T>().await_resume())>> :
 			std::conjunction<
 				std::is_constructible<bool, decltype(std::declval<T>().await_ready())>,
 				detail::is_valid_await_suspend_return_value<
-					decltype(std::declval<T>().await_suspend(std::declval<std::experimental::coroutine_handle<>>()))>>
+					decltype(std::declval<T>().await_suspend(std::declval<std::coroutine_handle<>>()))>>
 		{};
 	}
 }
Index: openbabel-src/openbabel/src/descriptors/groupcontrib.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/descriptors/groupcontrib.cpp b/openbabel-src/openbabel/src/descriptors/groupcontrib.cpp
--- a/openbabel-src/openbabel/src/descriptors/groupcontrib.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/descriptors/groupcontrib.cpp	(date 1745583015836)
@@ -55,7 +55,7 @@
     OBSmartsPattern *sp;
 
     // open data file
-    ifstream ifs;
+    istringstream ifs;
 
     if (OpenDatafile(ifs, _filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, " Could not find contribution data file.", obError);
Index: cppcoro-src/cppcoro/include/cppcoro/detail/win32_overlapped_operation.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/detail/win32_overlapped_operation.hpp b/cppcoro-src/cppcoro/include/cppcoro/detail/win32_overlapped_operation.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/detail/win32_overlapped_operation.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/detail/win32_overlapped_operation.hpp	(date 1745583016070)
@@ -13,7 +13,7 @@
 
 #include <optional>
 #include <system_error>
-#include <experimental/coroutine>
+#include <coroutine>
 #include <cassert>
 
 namespace cppcoro
@@ -100,7 +100,7 @@
 			bool await_ready() const noexcept { return false; }
 
 			CPPCORO_NOINLINE
-			bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine)
+			bool await_suspend(std::coroutine_handle<> awaitingCoroutine)
 			{
 				static_assert(std::is_base_of_v<win32_overlapped_operation, OPERATION>);
 
@@ -127,7 +127,7 @@
 				operation->m_awaitingCoroutine.resume();
 			}
 
-			std::experimental::coroutine_handle<> m_awaitingCoroutine;
+			std::coroutine_handle<> m_awaitingCoroutine;
 
 		};
 
@@ -186,7 +186,7 @@
 			}
 
 			CPPCORO_NOINLINE
-			bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine)
+			bool await_suspend(std::coroutine_handle<> awaitingCoroutine)
 			{
 				static_assert(std::is_base_of_v<win32_overlapped_operation_cancellable, OPERATION>);
 
@@ -367,7 +367,7 @@
 			std::atomic<state> m_state;
 			cppcoro::cancellation_token m_cancellationToken;
 			std::optional<cppcoro::cancellation_registration> m_cancellationCallback;
-			std::experimental::coroutine_handle<> m_awaitingCoroutine;
+			std::coroutine_handle<> m_awaitingCoroutine;
 
 		};
 	}
Index: cppcoro-src/cppcoro/include/cppcoro/detail/when_all_counter.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_counter.hpp b/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_counter.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_counter.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_counter.hpp	(date 1745583016039)
@@ -5,7 +5,7 @@
 #ifndef CPPCORO_DETAIL_WHEN_ALL_COUNTER_HPP_INCLUDED
 #define CPPCORO_DETAIL_WHEN_ALL_COUNTER_HPP_INCLUDED
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <atomic>
 #include <cstdint>
 
@@ -29,7 +29,7 @@
 				return static_cast<bool>(m_awaitingCoroutine);
 			}
 
-			bool try_await(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+			bool try_await(std::coroutine_handle<> awaitingCoroutine) noexcept
 			{
 				m_awaitingCoroutine = awaitingCoroutine;
 				return m_count.fetch_sub(1, std::memory_order_acq_rel) > 1;
@@ -46,7 +46,7 @@
 		protected:
 
 			std::atomic<std::size_t> m_count;
-			std::experimental::coroutine_handle<> m_awaitingCoroutine;
+			std::coroutine_handle<> m_awaitingCoroutine;
 
 		};
 	}
Index: libxml2-src/libxml2/include/libxml/xmlerror.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libxml2-src/libxml2/include/libxml/xmlerror.h b/libxml2-src/libxml2/include/libxml/xmlerror.h
--- a/libxml2-src/libxml2/include/libxml/xmlerror.h	(revision 0e145ae4881c2a05ae00128a3bd90d76d4dadc4b)
+++ b/libxml2-src/libxml2/include/libxml/xmlerror.h	(date 1745583016054)
@@ -941,7 +941,7 @@
 /*
  * Extended error information routines
  */
-XMLPUBFUN const xmlError *
+XMLPUBFUN xmlError *
     xmlGetLastError		(void);
 XMLPUBFUN void
     xmlResetLastError		(void);
Index: cppcoro-src/cppcoro/include/cppcoro/detail/when_all_task.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_task.hpp b/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_task.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_task.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_task.hpp	(date 1745583016070)
@@ -10,7 +10,7 @@
 #include <cppcoro/detail/when_all_counter.hpp>
 #include <cppcoro/detail/void_value.hpp>
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <cassert>
 
 namespace cppcoro
@@ -28,7 +28,7 @@
 		{
 		public:
 
-			using coroutine_handle_t = std::experimental::coroutine_handle<when_all_task_promise<RESULT>>;
+			using coroutine_handle_t = std::coroutine_handle<when_all_task_promise<RESULT>>;
 
 			when_all_task_promise() noexcept
 			{}
@@ -38,7 +38,7 @@
 				return coroutine_handle_t::from_promise(*this);
 			}
 
-			std::experimental::suspend_always initial_suspend() noexcept
+			std::suspend_always initial_suspend() noexcept
 			{
 				return{};
 			}
@@ -97,7 +97,7 @@
 					bool await_ready() noexcept {
 						return true;
 					}
-					void await_suspend(std::experimental::coroutine_handle<>) noexcept {}
+					void await_suspend(std::coroutine_handle<>) noexcept {}
 					when_all_task_promise& await_resume() noexcept
 					{
 						return *m_promise;
@@ -155,7 +155,7 @@
 		{
 		public:
 
-			using coroutine_handle_t = std::experimental::coroutine_handle<when_all_task_promise<void>>;
+			using coroutine_handle_t = std::coroutine_handle<when_all_task_promise<void>>;
 
 			when_all_task_promise() noexcept
 			{}
@@ -165,7 +165,7 @@
 				return coroutine_handle_t::from_promise(*this);
 			}
 
-			std::experimental::suspend_always initial_suspend() noexcept
+			std::suspend_always initial_suspend() noexcept
 			{
 				return{};
 			}
Index: cppcoro-src/cppcoro/include/cppcoro/detail/when_all_ready_awaitable.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_ready_awaitable.hpp b/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_ready_awaitable.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_ready_awaitable.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_ready_awaitable.hpp	(date 1745583016039)
@@ -7,7 +7,7 @@
 
 #include <cppcoro/detail/when_all_counter.hpp>
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <tuple>
 
 namespace cppcoro
@@ -26,7 +26,7 @@
 			explicit constexpr when_all_ready_awaitable(std::tuple<>) noexcept {}
 
 			constexpr bool await_ready() const noexcept { return true; }
-			void await_suspend(std::experimental::coroutine_handle<>) noexcept {}
+			void await_suspend(std::coroutine_handle<>) noexcept {}
 			std::tuple<> await_resume() const noexcept { return {}; }
 
 		};
@@ -66,7 +66,7 @@
 						return m_awaitable.is_ready();
 					}
 
-					bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+					bool await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 					{
 						return m_awaitable.try_await(awaitingCoroutine);
 					}
@@ -98,7 +98,7 @@
 						return m_awaitable.is_ready();
 					}
 
-					bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+					bool await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 					{
 						return m_awaitable.try_await(awaitingCoroutine);
 					}
@@ -124,7 +124,7 @@
 				return m_counter.is_ready();
 			}
 
-			bool try_await(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+			bool try_await(std::coroutine_handle<> awaitingCoroutine) noexcept
 			{
 				start_tasks(std::make_integer_sequence<std::size_t, sizeof...(TASKS)>{});
 				return m_counter.try_await(awaitingCoroutine);
@@ -177,7 +177,7 @@
 						return m_awaitable.is_ready();
 					}
 
-					bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+					bool await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 					{
 						return m_awaitable.try_await(awaitingCoroutine);
 					}
@@ -212,7 +212,7 @@
 						return m_awaitable.is_ready();
 					}
 
-					bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+					bool await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 					{
 						return m_awaitable.try_await(awaitingCoroutine);
 					}
@@ -238,7 +238,7 @@
 				return m_counter.is_ready();
 			}
 
-			bool try_await(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+			bool try_await(std::coroutine_handle<> awaitingCoroutine) noexcept
 			{
 				for (auto&& task : m_tasks)
 				{
Index: openbabel-src/openbabel/src/fingerprints/finger3.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/fingerprints/finger3.cpp b/openbabel-src/openbabel/src/fingerprints/finger3.cpp
--- a/openbabel-src/openbabel/src/fingerprints/finger3.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/fingerprints/finger3.cpp	(date 1745583015836)
@@ -159,7 +159,7 @@
   bool ReadPatternFile(string& ver)
   {
     //Reads three types of file. See below
-    ifstream ifs;
+    istringstream ifs;
 	  stringstream errorMsg;
 
     if (OpenDatafile(ifs, _patternsfile).length() == 0)
@@ -238,8 +238,6 @@
       }
     }while(getline(ifs,line));
 
-    if (ifs)
-      ifs.close();
     return true;
   }
 
@@ -255,7 +253,8 @@
       int num =  ppat->numbits, div = ppat->numoccurrences+1, ngrp;
       while(num) //for each group of bits
       {
-        ngrp = (num + div -1)/div--; //rounds up
+        ngrp = (num + div -1)/div; //rounds up
+        --div;
         num -= ngrp;
         if(GetBit(fp, n) == bSet)
         {
Index: rdkit-src/rdkit/Code/RDGeneral/export.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/RDGeneral/export.h b/rdkit-src/rdkit/Code/RDGeneral/export.h
new file mode 100644
--- /dev/null	(date 1745583015945)
+++ b/rdkit-src/rdkit/Code/RDGeneral/export.h	(date 1745583015945)
@@ -0,0 +1,78 @@
+#pragma once
+
+#include <Abbreviations/rdkit_export.hpp>
+#include <Alignment/rdkit_export.hpp>
+#include <AvalonLib/rdkit_export.hpp>
+#include <Catalogs/rdkit_export.hpp>
+#include <ChemicalFeatures/rdkit_export.hpp>
+#include <ChemReactions/rdkit_export.hpp>
+#include <ChemTransforms/rdkit_export.hpp>
+#include <CIPLabeler/rdkit_export.hpp>
+#include <ConformerParser/rdkit_export.hpp>
+#include <DataStructs/rdkit_export.hpp>
+#include <Depictor/rdkit_export.hpp>
+#include <Deprotect/rdkit_export.hpp>
+#include <Descriptors/rdkit_export.hpp>
+#include <DetermineBonds/rdkit_export.hpp>
+#include <DistGeometry/rdkit_export.hpp>
+#include <DistGeomHelpers/rdkit_export.hpp>
+#include <EHTLIB/rdkit_export.hpp>
+#include <EigenSolvers/rdkit_export.hpp>
+#include <Features/rdkit_export.hpp>
+#include <FileParsers/rdkit_export.hpp>
+#include <FilterCatalog/rdkit_export.hpp>
+#include <Fingerprints/rdkit_export.hpp>
+#include <FMCS/rdkit_export.hpp>
+#include <ForceField/rdkit_export.hpp>
+#include <ForceFieldHelpers/rdkit_export.hpp>
+#include <FragCatalog/rdkit_export.hpp>
+#include <GeneralizedSubstruct/rdkit_export.hpp>
+#include <FreeSASALib/rdkit_export.hpp>
+#include <ga/rdkit_export.hpp>
+#include <GenericGroups/rdkit_export.hpp>
+#include <GraphMol/rdkit_export.hpp>
+#include <InfoTheory/rdkit_export.hpp>
+#include <MMPA/rdkit_export.hpp>
+#include <MolAlign/rdkit_export.hpp>
+#include <MolCatalog/rdkit_export.hpp>
+#include <MolChemicalFeatures/rdkit_export.hpp>
+#include <MolDraw2D/rdkit_export.hpp>
+#include <MolEnumerator/rdkit_export.hpp>
+#include <MolHash/rdkit_export.hpp>
+#include <MolInterchange/rdkit_export.hpp>
+#include <MolStandardize/rdkit_export.hpp>
+#include <MolTransforms/rdkit_export.hpp>
+#include <O3AAlign/rdkit_export.hpp>
+#include <Optimizer/rdkit_export.hpp>
+#include <PartialCharges/rdkit_export.hpp>
+#include <PBF/rdkit_export.hpp>
+#include <RDGeneral/rdkit_export.hpp>
+#include <RDGeometryLib/rdkit_export.hpp>
+#include <RDInchiLib/rdkit_export.hpp>
+#include <RDStreams/rdkit_export.hpp>
+#include <ReducedGraphs/rdkit_export.hpp>
+#include <RGroupDecomposition/rdkit_export.hpp>
+#include <ScaffoldNetwork/rdkit_export.hpp>
+#include <ShapeHelpers/rdkit_export.hpp>
+#include <SimDivPickers/rdkit_export.hpp>
+#include <SLNParse/rdkit_export.hpp>
+#include <SmilesParse/rdkit_export.hpp>
+#include <StructChecker/rdkit_export.hpp>
+#include <Subgraphs/rdkit_export.hpp>
+#include <SubstructLibrary/rdkit_export.hpp>
+#include <SubstructMatch/rdkit_export.hpp>
+#include <TautomerQuery/rdkit_export.hpp>
+#include <Trajectory/rdkit_export.hpp>
+
+#include <RDGeneral/RDConfig.h>
+
+#define RDKIT_EXPORT // unused
+
+#define RDKIT_INCHI_EXPORT RDKIT_EXPORT
+#define RDKIT_RDBOOST_EXPORT RDKIT_EXPORT
+#define RDKIT_RINGDECOMPOSERLIB_EXPORT RDKIT_EXPORT
+#define RDKIT_AVALON_CLIB_EXPORT RDKIT_EXPORT
+#define RDKIT_COORDGEN_EXPORT RDKIT_EXPORT
+#define RDKIT_FREESASA_CLIB_EXPORT RDKIT_EXPORT
+#define RDKIT_MAEPARSER_EXPORT RDKIT_EXPORT
+#define RDKIT_QUERY_EXPORT RDKIT_EXPORT
Index: openbabel-src/openbabel/src/forcefields/forcefieldmmff94.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/forcefields/forcefieldmmff94.cpp b/openbabel-src/openbabel/src/forcefields/forcefieldmmff94.cpp
--- a/openbabel-src/openbabel/src/forcefields/forcefieldmmff94.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/forcefields/forcefieldmmff94.cpp	(date 1745583015836)
@@ -874,7 +874,7 @@
     char buffer[80];
 
     // open data/_parFile
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, _parFile).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open parameter file", obError);
       return false;
@@ -913,8 +913,6 @@
         ParseParamVDW(vs[1]);
     }
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
@@ -929,7 +927,7 @@
     OBFFParameter parameter;
 
     // open data/mmffbond.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffbond.par", obError);
       return false;
@@ -950,8 +948,6 @@
       _ffbondparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -964,7 +960,7 @@
     OBFFParameter parameter;
 
     // open data/mmffbndk.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffbndk.par", obError);
       return false;
@@ -984,8 +980,6 @@
       _ffbndkparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -998,7 +992,7 @@
     OBFFParameter parameter;
 
     // open data/mmffang.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffang.par", obError);
       return false;
@@ -1020,8 +1014,6 @@
       _ffangleparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1034,7 +1026,7 @@
     OBFFParameter parameter;
 
     // open data/mmffstbn.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffstbn.par", obError);
       return false;
@@ -1056,8 +1048,6 @@
       _ffstrbndparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1070,7 +1060,7 @@
     OBFFParameter parameter;
 
     // open data/mmffdfsb.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffdfsb.par", obError);
       return false;
@@ -1091,8 +1081,6 @@
       _ffdfsbparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1105,7 +1093,7 @@
     OBFFParameter parameter;
 
     // open data/mmffoop.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffoop.par", obError);
       return false;
@@ -1126,8 +1114,6 @@
       _ffoopparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1140,7 +1126,7 @@
     OBFFParameter parameter;
 
     // open data/mmfftor.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmfftor.par", obError);
       return false;
@@ -1164,8 +1150,6 @@
       _fftorsionparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1178,7 +1162,7 @@
     OBFFParameter parameter;
 
     // open data/mmffvdw.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffvdw.par", obError);
       return false;
@@ -1205,8 +1189,6 @@
       _ffvdwparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1219,7 +1201,7 @@
     OBFFParameter parameter;
 
     // open data/mmffchg.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffchg.par", obError);
       return false;
@@ -1239,8 +1221,6 @@
       _ffchgparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1253,7 +1233,7 @@
     OBFFParameter parameter;
 
     // open data/mmffpbci.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffpbci", obError);
       return false;
@@ -1272,8 +1252,6 @@
       _ffpbciparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1286,7 +1264,7 @@
     OBFFParameter parameter;
 
     // open data/mmffprop.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffprop.par", obError);
       return false;
@@ -1321,8 +1299,6 @@
       _ffpropparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1335,7 +1311,7 @@
     OBFFParameter parameter;
 
     // open data/mmffdef.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffdef.par", obError);
       return false;
@@ -1356,8 +1332,6 @@
       _ffdefparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
Index: rdkit-src/rdkit/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/.gitignore b/rdkit-src/rdkit/.gitignore
--- a/rdkit-src/rdkit/.gitignore	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/.gitignore	(date 1745647492829)
@@ -46,7 +46,6 @@
 /Code/RDBoost/test.h
 /Code/RDGeneral/RDConfig.h
 /Code/RDGeneral/enum.h
-/Code/RDGeneral/export.h
 /Code/RDGeneral/test.h
 /Code/RDGeneral/versions.h
 /Code/RDGeneral/versions.cpp
Index: openbabel-src/openbabel/src/forcefields/forcefielduff.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/forcefields/forcefielduff.cpp b/openbabel-src/openbabel/src/forcefields/forcefielduff.cpp
--- a/openbabel-src/openbabel/src/forcefields/forcefielduff.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/forcefields/forcefielduff.cpp	(date 1745583015836)
@@ -1614,7 +1614,7 @@
     OBFFParameter parameter;
 
     // open data/UFF.prm
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "UFF.prm").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open UFF.prm", obError);
       return false;
@@ -1647,7 +1647,10 @@
         parameter.b = 0; // used for tracking number of angles in 5-coordinate
         parameter.c = 0;
 
-        char coord = vs[1][2]; // 3rd character of atom type
+        char coord = '\0';
+        if (vs[1].size() > 2) {
+          coord = vs[1][2]; // 3rd character of atom type
+        }
         switch (coord) {
         case '1': // linear
           parameter._ipar.push_back(1);
@@ -1680,8 +1683,6 @@
       }
     }
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
@@ -1702,7 +1703,7 @@
     _mol.SetAtomTypesPerceived();
 
     // open data/UFF.prm
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "UFF.prm").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open UFF.prm", obError);
       return false;
@@ -1771,8 +1772,6 @@
 
     }
 
-    if (ifs)
-      ifs.close();
 
     // Free memory
     for (i = _vexttyp.begin();i != _vexttyp.end();++i) {
Index: rdkit-src/rdkit/Code/RDGeneral/RDLog.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/RDGeneral/RDLog.cpp b/rdkit-src/rdkit/Code/RDGeneral/RDLog.cpp
--- a/rdkit-src/rdkit/Code/RDGeneral/RDLog.cpp	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Code/RDGeneral/RDLog.cpp	(date 1745583015945)
@@ -25,9 +25,7 @@
 namespace RDLog {
 
 namespace {
-const std::vector<RDLogger *> allLogs = {&rdAppLog,     &rdDebugLog,
-                                         &rdInfoLog,    &rdErrorLog,
-                                         &rdWarningLog, &rdStatusLog};
+std::vector<RDLogger *> allLogs;
 }
 
 LogStateSetter::LogStateSetter() {
@@ -147,13 +145,18 @@
   rdInfoLog->df_enabled = false;
   rdWarningLog = std::make_shared<boost::logging::rdLogger>(&std::cerr);
   rdErrorLog = std::make_shared<boost::logging::rdLogger>(&std::cerr);
+  rdAppLog = rdInfoLog;
+  rdStatusLog = rdInfoLog;
+  allLogs = {&rdAppLog,     &rdDebugLog,
+             &rdInfoLog,    &rdErrorLog,
+             &rdWarningLog, &rdStatusLog};
 }
 
 std::ostream &toStream(std::ostream &logstrm) {
   char buffer[16];
   time_t t = time(nullptr);
 // localtime() is thread safe on windows, but not on *nix
-#ifdef WIN32
+#if defined(WIN32) || defined(__MINGW32__)
   strftime(buffer, 16, "[%T] ", localtime(&t));
 #else
   struct tm buf;
Index: openbabel-src/openbabel/src/forcefields/forcefieldghemical.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/forcefields/forcefieldghemical.cpp b/openbabel-src/openbabel/src/forcefields/forcefieldghemical.cpp
--- a/openbabel-src/openbabel/src/forcefields/forcefieldghemical.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/forcefields/forcefieldghemical.cpp	(date 1745583015836)
@@ -858,7 +858,7 @@
     OBFFParameter parameter;
 
     // open data/ghemical.prm
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "ghemical.prm").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open ghemical.prm", obError);
       return false;
@@ -942,8 +942,6 @@
       }
     }
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
@@ -964,7 +962,7 @@
     _mol.SetAtomTypesPerceived();
 
     // open data/ghemical.prm
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "ghemical.prm").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open ghemical.prm", obError);
       return false;
@@ -1026,8 +1024,6 @@
     //  else
     //    cout << "ATOMTYPE " << a->GetType() << endl;
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
Index: openbabel-src/openbabel/src/forcefields/forcefieldmm2.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/forcefields/forcefieldmm2.cpp b/openbabel-src/openbabel/src/forcefields/forcefieldmm2.cpp
--- a/openbabel-src/openbabel/src/forcefields/forcefieldmm2.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/forcefields/forcefieldmm2.cpp	(date 1745583015836)
@@ -18,6 +18,10 @@
 #include <openbabel/babelconfig.h>
 #include <openbabel/mol.h>
 #include <openbabel/locale.h>
+#include <openbabel/obiter.h>
+#include <openbabel/bond.h>
+#include <openbabel/oberror.h>
+#include <openbabel/data.h>
 #include "forcefieldmm2.h"
 
 using namespace std;
@@ -498,8 +502,8 @@
     {
       _mol = src._mol;
       _init = src._init;
-      return *this;
-    }
+    }
+    return *this;
   }
 
   bool OBForceFieldMM2::Setup(OBMol &mol)
@@ -522,7 +526,7 @@
     OBFFParameter parameter;
 
     // open data/mm2.prm
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "mm2.prm").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mm2.prm", obError);
       return false;
@@ -667,8 +671,6 @@
       }
     }
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
Index: openbabel-src/openbabel/src/forcefields/forcefieldgaff.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/forcefields/forcefieldgaff.cpp b/openbabel-src/openbabel/src/forcefields/forcefieldgaff.cpp
--- a/openbabel-src/openbabel/src/forcefields/forcefieldgaff.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/forcefields/forcefieldgaff.cpp	(date 1745583015836)
@@ -1081,7 +1081,7 @@
     OBFFParameter parameter;
 
     // open data/gaff.dat
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "gaff.dat").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open gaff.dat", obError);
       return false;
@@ -1204,8 +1204,6 @@
 	    ifs.getline(buffer, BUFF_SIZE);
       }
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
@@ -1230,7 +1228,7 @@
     _mol.SetAtomTypesPerceived();
 
     // open data/gaff.prm
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "gaff.prm").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open gaff.prm", obError);
       return false;
@@ -1412,8 +1410,6 @@
     }
 
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
Index: svgpp-src/svgpp/include/svgpp/parser/external_function/parse_paint_impl.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/parser/external_function/parse_paint_impl.hpp b/svgpp-src/svgpp/include/svgpp/parser/external_function/parse_paint_impl.hpp
--- a/svgpp-src/svgpp/include/svgpp/parser/external_function/parse_paint_impl.hpp	(revision 5f1870aa7b757718ff5f86bdfb55966fa4f217f9)
+++ b/svgpp-src/svgpp/include/svgpp/parser/external_function/parse_paint_impl.hpp	(date 1745583015898)
@@ -51,13 +51,13 @@
       | qi::lit("currentColor")   [phx::ref(out_main_option) = paint_option_currentColor]
       | qi::lit("inherit")        [phx::ref(out_main_option) = paint_option_inherit]
       | color_optional_icc_color(boost::phoenix::ref(icc_color_factory))  
-          [phx::ref(out_color) = qi::_1, phx::ref(out_main_option) = paint_option_color]
+          [(phx::ref(out_color) = qi::_1, phx::ref(out_main_option) = paint_option_color)]
       | ( funciri_rule [phx::ref(out_iri) = qi::_1]
           >> - ( +space
                   >> ( qi::lit("none")          [phx::ref(out_funciri_suboption) = paint_option_none]
                       | qi::lit("currentColor")  [phx::ref(out_funciri_suboption) = paint_option_currentColor]
                       | color_optional_icc_color(boost::phoenix::ref(icc_color_factory)) 
-                        [phx::ref(out_color) = qi::_1, phx::ref(out_funciri_suboption) = paint_option_color]
+                        [(phx::ref(out_color) = qi::_1, phx::ref(out_funciri_suboption) = paint_option_color)]
                       )
                 )
         ) [phx::ref(out_main_option) = paint_option_funciri]
Index: arrow-src/arrow/cpp/src/arrow/util/visibility.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/arrow-src/arrow/cpp/src/arrow/util/visibility.h b/arrow-src/arrow/cpp/src/arrow/util/visibility.h
--- a/arrow-src/arrow/cpp/src/arrow/util/visibility.h	(revision 272715f6df2a042d69881ffa03d5078c58e4b345)
+++ b/arrow-src/arrow/cpp/src/arrow/util/visibility.h	(date 1745671318567)
@@ -17,6 +17,8 @@
 
 #pragma once
 
+#include <arrow_export.h>
+
 #if defined(_WIN32) || defined(__CYGWIN__)
 // Windows
 
@@ -26,6 +28,7 @@
 #    pragma GCC diagnostic ignored "-Wattributes"
 #  endif
 
+#if 0
 #  if defined(__cplusplus) && defined(__GNUC__) && !defined(__clang__)
 // Use C++ attribute syntax where possible to avoid GCC parser bug
 // (https://stackoverflow.com/questions/57993818/gcc-how-to-combine-attribute-dllexport-and-nodiscard-in-a-struct-de)
@@ -55,11 +58,15 @@
 #  endif
 
 #  define ARROW_NO_EXPORT
+#  endif
+#define ARROW_FRIEND_EXPORT ARROW_EXPORT
+#define ARROW_TEMPLATE_EXPORT ARROW_EXPORT
 
 #else
 
 // Non-Windows
 
+#if 0
 #  if defined(__cplusplus) && (defined(__GNUC__) || defined(__clang__))
 #    ifndef ARROW_EXPORT
 #      define ARROW_EXPORT [[gnu::visibility("default")]]
@@ -76,6 +83,7 @@
 #      define ARROW_NO_EXPORT
 #    endif
 #  endif
+#endif
 
 #  define ARROW_FRIEND_EXPORT
 #  define ARROW_TEMPLATE_EXPORT
Index: libxml2-src/libxml2/error.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libxml2-src/libxml2/error.c b/libxml2-src/libxml2/error.c
--- a/libxml2-src/libxml2/error.c	(revision 0e145ae4881c2a05ae00128a3bd90d76d4dadc4b)
+++ b/libxml2-src/libxml2/error.c	(date 1745755944119)
@@ -930,10 +930,10 @@
  *
  * Returns a pointer to the error
  */
-const xmlError *
+xmlError *
 xmlGetLastError(void)
 {
-    const xmlError *error = xmlGetLastErrorInternal();
+    xmlError *error = xmlGetLastErrorInternal();
 
     if (error->code == XML_ERR_OK)
         return(NULL);
Index: openbabel-src/openbabel/data/patty.rules
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/data/patty.rules b/openbabel-src/openbabel/data/patty.rules
--- a/openbabel-src/openbabel/data/patty.rules	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/data/patty.rules	(date 1745583015836)
@@ -133,9 +133,9 @@
 # diaminopyrimidine (ring Ns are POL)
 #
 #        *==*
-#       /    \  
+#       /    \
 #     :N      C--NH2            (aromatic)
-#      \\    #  
+#      \\    #
 #        C--N:
 #       /
 #       NH2
@@ -186,7 +186,7 @@
 [#8,#16,#34;D1]C=[#8,#16,#34]           ANI
 [#8,#16,#34]=C[#8,#16,#34;D1]           ANI
 #        *==*
-#       /    \  
+#       /    \
 #      *      C==O              (aromatic)
 #      \\    /
 #        C--C                   And 4 Cs away
Index: rdkit-src/rdkit/Code/ML/Cluster/Murtagh/f2c.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/ML/Cluster/Murtagh/f2c.h b/rdkit-src/rdkit/Code/ML/Cluster/Murtagh/f2c.h
--- a/rdkit-src/rdkit/Code/ML/Cluster/Murtagh/f2c.h	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Code/ML/Cluster/Murtagh/f2c.h	(date 1745583016179)
@@ -4,7 +4,6 @@
 
         - From The Shogakukan DICTIONARY OF NEW ENGLISH (Second edition) */
 
-#include <RDGeneral/export.h>
 #ifndef F2C_INCLUDE
 #define F2C_INCLUDE
 
Index: rdkit-src/rdkit/Code/ForceField/UFF/Params.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/ForceField/UFF/Params.cpp b/rdkit-src/rdkit/Code/ForceField/UFF/Params.cpp
--- a/rdkit-src/rdkit/Code/ForceField/UFF/Params.cpp	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Code/ForceField/UFF/Params.cpp	(date 1745583016008)
@@ -7,7 +7,7 @@
 //  which is included in the file license.txt, found at the root
 //  of the RDKit source tree.
 //
-#ifdef WIN32
+#if defined(WIN32) && !defined(_USE_MATH_DEFINES)
 #define _USE_MATH_DEFINES
 #endif
 #include <cmath>
Index: svgpp-src/svgpp/include/svgpp/traits/attribute_type.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/traits/attribute_type.hpp b/svgpp-src/svgpp/include/svgpp/traits/attribute_type.hpp
--- a/svgpp-src/svgpp/include/svgpp/traits/attribute_type.hpp	(revision 5f1870aa7b757718ff5f86bdfb55966fa4f217f9)
+++ b/svgpp-src/svgpp/include/svgpp/traits/attribute_type.hpp	(date 1745583015976)
@@ -432,6 +432,9 @@
 template<class Element> struct attribute_type<Element, tag::attribute::class_                > { typedef tag::type::string type; }; // TODO: parse list of strings
 template<class Element> struct attribute_type<Element, tag::attribute::contentScriptType     > { typedef tag::type::string type; };
 template<class Element> struct attribute_type<Element, tag::attribute::contentStyleType      > { typedef tag::type::string type; };
+template<class Element> struct attribute_type<Element, tag::attribute::data_c                > { typedef tag::type::string type; };
+template<class Element> struct attribute_type<Element, tag::attribute::data_mjx_texclass     > { typedef tag::type::string type; };
+template<class Element> struct attribute_type<Element, tag::attribute::data_mml_node         > { typedef tag::type::string type; };
 template<class Element> struct attribute_type<Element, tag::attribute::id                    > { typedef tag::type::string type; };
 template<class Element> struct attribute_type<Element, tag::attribute::attributeName         > { typedef tag::type::string type; };
 template<class Element> struct attribute_type<Element, tag::attribute::font_family           > { typedef tag::type::string type; };
Index: openbabel-src/openbabel/data/gaff.prm
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/data/gaff.prm b/openbabel-src/openbabel/data/gaff.prm
--- a/openbabel-src/openbabel/data/gaff.prm	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/data/gaff.prm	(date 1745583015851)
@@ -91,7 +91,7 @@
 atom [#6X3;R](=*)-*=*   						    ca "sp2 C in aromatic ring"
 atom [#6X3;R](=[#6X3])([#6])[#1]					    ca "sp2 C in aromatic ring"	
 atom [#6X3;R](=[#6])([#6])[F,Cl,Br,I]   				    c2 "sp2 C in a ring with 1 electron-withdrawal group"
-atom [#6X3;R](=[#6X3])([#6X4])[#6]					    c2 "sp2 C in a ring"		
+atom [#6X3;R](=[#6X3])([#6X4])[#6]					    c2 "sp2 C in a ring"
 atom [#6X3;R](=*)-*#*   						    cc "sp2 C in a conjugated ring"
 atom [#6X3;R](#*)-*#*   						    cc "sp2 C in a conjugated ring"
 atom [#6X3;R]:[#7,#8,#16]     	     	      				    cc "sp2 C in a ring with 1 electron-withdrawal group"
Index: rdkit-src/rdkit/Code/ForceField/MMFF/Params.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/ForceField/MMFF/Params.cpp b/rdkit-src/rdkit/Code/ForceField/MMFF/Params.cpp
--- a/rdkit-src/rdkit/Code/ForceField/MMFF/Params.cpp	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Code/ForceField/MMFF/Params.cpp	(date 1745583016054)
@@ -10,7 +10,7 @@
 //  which is included in the file license.txt, found at the root
 //  of the RDKit source tree.
 //
-#ifdef WIN32
+#if defined(WIN32) && !defined(_USE_MATH_DEFINES)
 #define _USE_MATH_DEFINES
 #endif
 #include <cmath>
Index: rdkit-src/rdkit/Code/ForceField/MMFF/TorsionAngle.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/ForceField/MMFF/TorsionAngle.h b/rdkit-src/rdkit/Code/ForceField/MMFF/TorsionAngle.h
--- a/rdkit-src/rdkit/Code/ForceField/MMFF/TorsionAngle.h	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Code/ForceField/MMFF/TorsionAngle.h	(date 1745722064785)
@@ -12,6 +12,7 @@
 #define RD_MMFFTORSIONANGLE_H
 
 #include <ForceField/Contrib.h>
+#include <cstdint>
 #include <tuple>
 #include <vector>
 
Index: svgpp-src/svgpp/include/svgpp/utility/gil/mask.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/utility/gil/mask.hpp b/svgpp-src/svgpp/include/svgpp/utility/gil/mask.hpp
--- a/svgpp-src/svgpp/include/svgpp/utility/gil/mask.hpp	(revision 5f1870aa7b757718ff5f86bdfb55966fa4f217f9)
+++ b/svgpp-src/svgpp/include/svgpp/utility/gil/mask.hpp	(date 1745583016023)
@@ -28,6 +28,7 @@
   GrayChannelValue operator()(const RedChannel& red, const GreenChannel& green, const BlueChannel& blue) const 
   {
     using namespace boost::gil;
+    using boost::gil::float32_t;
     return channel_convert<GrayChannelValue>(
       channel_convert<float32_t>(red  )*0.2125f +
       channel_convert<float32_t>(green)*0.7154f +
Index: arrow-src/arrow/cpp/src/arrow/util/macros.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/arrow-src/arrow/cpp/src/arrow/util/macros.h b/arrow-src/arrow/cpp/src/arrow/util/macros.h
--- a/arrow-src/arrow/cpp/src/arrow/util/macros.h	(revision 272715f6df2a042d69881ffa03d5078c58e4b345)
+++ b/arrow-src/arrow/cpp/src/arrow/util/macros.h	(date 1745583016054)
@@ -134,6 +134,7 @@
 // clang-format off
 // [[deprecated]] is only available in C++14, use this for the time being
 // This macro takes an optional deprecation message
+#undef ARROW_DEPRECATED
 #ifdef __COVERITY__
 #  define ARROW_DEPRECATED(...)
 #else
Index: openbabel-src/openbabel/include/RDKitConv.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/RDKitConv.h b/openbabel-src/openbabel/include/RDKitConv.h
--- a/openbabel-src/openbabel/include/RDKitConv.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/RDKitConv.h	(date 1745583015820)
@@ -1,7 +1,7 @@
 #include <openbabel/mol.h>
 #include <openbabel/obiter.h>
-#include <graphmol/RWMol.h>
-#include <graphmol/Atom.h>
+#include <GraphMol/RWMol.h>
+#include <GraphMol/Atom.h>
 
 ///Convert OpenBabel OBMol to and from RGKit molecules
 RDKit::RWMol OBMolToRWMol(OpenBabel::OBMol* pOBMol);
Index: freetype-src/freetype/include/freetype/config/ftoption.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/freetype-src/freetype/include/freetype/config/ftoption.h b/freetype-src/freetype/include/freetype/config/ftoption.h
--- a/freetype-src/freetype/include/freetype/config/ftoption.h	(revision 42608f77f20749dd6ddc9e0536788eaad70ea4b5)
+++ b/freetype-src/freetype/include/freetype/config/ftoption.h	(date 1745583016148)
@@ -273,7 +273,7 @@
    *   options set by those programs have precedence, overwriting the value
    *   here with the configured one.
    */
-/* #define FT_CONFIG_OPTION_USE_PNG */
+#define FT_CONFIG_OPTION_USE_PNG
 
 
   /**************************************************************************
Index: rdkit-src/rdkit/Code/ForceField/MMFF/StretchBend.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/ForceField/MMFF/StretchBend.h b/rdkit-src/rdkit/Code/ForceField/MMFF/StretchBend.h
--- a/rdkit-src/rdkit/Code/ForceField/MMFF/StretchBend.h	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Code/ForceField/MMFF/StretchBend.h	(date 1745722064718)
@@ -10,6 +10,7 @@
 #ifndef __RD_MMFFSTRETCHBEND_H__
 #define __RD_MMFFSTRETCHBEND_H__
 
+#include <cstdint>
 #include <utility>
 #include <vector>
 
Index: skia-src/skia/src/ports/SkScalerContext_win_dw.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/src/ports/SkScalerContext_win_dw.cpp b/skia-src/skia/src/ports/SkScalerContext_win_dw.cpp
--- a/skia-src/skia/src/ports/SkScalerContext_win_dw.cpp	(revision 482de011c920d85fdbe21a81c45852655df6a809)
+++ b/skia-src/skia/src/ports/SkScalerContext_win_dw.cpp	(date 1745583016070)
@@ -1715,8 +1715,10 @@
     }
 
     DWRITE_GLYPH_IMAGE_FORMATS imageFormats;
+#if not defined(__MINGW64__)
     HRBM(fontFace4->GetGlyphImageFormats(glyph.getGlyphID(), 0, UINT32_MAX, &imageFormats),
          "Cannot get glyph image formats.");
+#endif
     if (!(imageFormats & DWRITE_GLYPH_IMAGE_FORMATS_PNG)) {
         return false;
     }
@@ -2263,8 +2265,10 @@
     }
 
     DWRITE_GLYPH_IMAGE_FORMATS imageFormats;
+#if not defined(__MINGW64__)
     HRBM(fontFace4->GetGlyphImageFormats(glyph.getGlyphID(), 0, UINT32_MAX, &imageFormats),
          "Cannot get glyph image formats.");
+#endif
     if (!(imageFormats & DWRITE_GLYPH_IMAGE_FORMATS_SVG)) {
         return false;
     }
Index: arrow-src/arrow/cpp/src/arrow/util/io_util.cc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/arrow-src/arrow/cpp/src/arrow/util/io_util.cc b/arrow-src/arrow/cpp/src/arrow/util/io_util.cc
--- a/arrow-src/arrow/cpp/src/arrow/util/io_util.cc	(revision 272715f6df2a042d69881ffa03d5078c58e4b345)
+++ b/arrow-src/arrow/cpp/src/arrow/util/io_util.cc	(date 1745726332655)
@@ -120,8 +120,10 @@
 #ifdef _WIN32
 #  include <windows.h>
 #else
+#if 0
 #  include <dlfcn.h>
 #endif
+#endif
 
 namespace arrow::internal {
 
@@ -2229,6 +2231,7 @@
   ARROW_ASSIGN_OR_RAISE(auto platform_path, PlatformFilename::FromString(path));
   return LoadDynamicLibrary(platform_path);
 #else
+#if 0
   constexpr int kFlags =
       // All undefined symbols in the shared object are resolved before dlopen() returns.
       RTLD_NOW
@@ -2240,6 +2243,9 @@
   // There is no null-returning non-error condition.
   auto* error = dlerror();
   return Status::IOError("dlopen(", path, ") failed: ", error ? error : "unknown error");
+#else
+  return Status::IOError("Not Implemented");
+#endif
 #endif
 }
 
@@ -2270,11 +2276,15 @@
   // There is no null-returning non-error condition.
   return IOErrorFromWinError(GetLastError(), "GetProcAddress(", name, ") failed.");
 #else
+#if 0
   if (void* sym = dlsym(handle, name)) return sym;
   // dlsym(3) man page: "On failure, they return NULL"
   // There is no null-returning non-error condition.
   auto* error = dlerror();
   return Status::IOError("dlsym(", name, ") failed: ", error ? error : "unknown error");
+#else
+  return Status::IOError("Not Implemented");
+#endif
 #endif
 }
 
Index: arrow-src/arrow/cpp/src/parquet/size_statistics.cc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/arrow-src/arrow/cpp/src/parquet/size_statistics.cc b/arrow-src/arrow/cpp/src/parquet/size_statistics.cc
--- a/arrow-src/arrow/cpp/src/parquet/size_statistics.cc	(revision 272715f6df2a042d69881ffa03d5078c58e4b345)
+++ b/arrow-src/arrow/cpp/src/parquet/size_statistics.cc	(date 1745659717208)
@@ -17,6 +17,7 @@
 
 #include "parquet/size_statistics.h"
 
+#include <array>
 #include <algorithm>
 #include <numeric>
 #include <ostream>
Index: yaehmop-src/yaehmop/tightbind/abfns.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/yaehmop-src/yaehmop/tightbind/abfns.c b/yaehmop-src/yaehmop/tightbind/abfns.c
--- a/yaehmop-src/yaehmop/tightbind/abfns.c	(revision 44967ec9fca7d2a84bd6bd991ae253d6f5eb17ba)
+++ b/yaehmop-src/yaehmop/tightbind/abfns.c	(date 1745583016023)
@@ -2,7 +2,15 @@
 Produced by gmFortran V30.59(10/26/17) on 9/17/18 at 9:45:37
 */
 #define LPROTOTYPE
-#include "fortran.h"
+#include <math.h>
+#include <stdlib.h>
+#ifndef min
+#define min(x, y) ({				\
+	typeof(x) _min1 = (x);			\
+	typeof(y) _min2 = (y);			\
+	(void) (&_min1 == &_min2);		\
+	_min1 < _min2 ? _min1 : _min2; })
+#endif
 /*
 */
 void abfns(double *a,double *b,double *sk1,double *sk2,double *rr,int *l1,
@@ -55,7 +63,7 @@
     }
     ix = j;
     ir = fabs(2.e0*rho2);
-    is = fifmin0(ir+1,19);
+    is = min(ir+1,19);
     if(rho2 == 0) goto S35;
     d = exp(rho2);
     h = 1.e0/d;
Index: skia-src/skia/src/gpu/ganesh/GrDistanceFieldGenFromVector.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/src/gpu/ganesh/GrDistanceFieldGenFromVector.cpp b/skia-src/skia/src/gpu/ganesh/GrDistanceFieldGenFromVector.cpp
--- a/skia-src/skia/src/gpu/ganesh/GrDistanceFieldGenFromVector.cpp	(revision 482de011c920d85fdbe21a81c45852655df6a809)
+++ b/skia-src/skia/src/gpu/ganesh/GrDistanceFieldGenFromVector.cpp	(date 1745583015820)
@@ -75,12 +75,14 @@
     kRight_SegSide =  1,
     kNA_SegSide    =  2,
 };
+namespace {
 
 struct DFData {
     float fDistSq;            // distance squared to nearest (so far) edge
     int   fDeltaWindingScore; // +1 or -1 whenever a scanline cross over a segment
 };
 
+}
 ///////////////////////////////////////////////////////////////////////////////
 
 /*
Index: ncnn-src/ncnn/cmake/ncnn_add_shader.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/cmake/ncnn_add_shader.cmake b/ncnn-src/ncnn/cmake/ncnn_add_shader.cmake
--- a/ncnn-src/ncnn/cmake/ncnn_add_shader.cmake	(revision 528589571085b673be7313a9c6e65801f150f607)
+++ b/ncnn-src/ncnn/cmake/ncnn_add_shader.cmake	(date 1745583015914)
@@ -1,11 +1,11 @@
-
+set(_CURRENT_DIR ${CMAKE_CURRENT_LIST_DIR})
 macro(ncnn_add_shader NCNN_SHADER_SRC)
     get_filename_component(NCNN_SHADER_SRC_NAME_WE ${NCNN_SHADER_SRC} NAME_WE)
-    set(NCNN_SHADER_COMP_HEADER ${CMAKE_CURRENT_BINARY_DIR}/layer/vulkan/shader/${NCNN_SHADER_SRC_NAME_WE}.comp.hex.h)
+    set(NCNN_SHADER_COMP_HEADER ${CMAKE_CURRENT_BINARY_DIR}/generated/ncnn/include/ncnn/layer/vulkan/shader/${NCNN_SHADER_SRC_NAME_WE}.comp.hex.h)
 
     add_custom_command(
         OUTPUT ${NCNN_SHADER_COMP_HEADER}
-        COMMAND ${CMAKE_COMMAND} -DSHADER_SRC=${NCNN_SHADER_SRC} -DSHADER_COMP_HEADER=${NCNN_SHADER_COMP_HEADER} -P "${CMAKE_CURRENT_SOURCE_DIR}/../cmake/ncnn_generate_shader_comp_header.cmake"
+        COMMAND ${CMAKE_COMMAND} -DSHADER_SRC=${NCNN_SHADER_SRC} -DSHADER_COMP_HEADER=${NCNN_SHADER_COMP_HEADER} -P "${_CURRENT_DIR}/ncnn_generate_shader_comp_header.cmake"
         DEPENDS ${NCNN_SHADER_SRC}
         COMMENT "Preprocessing shader source ${NCNN_SHADER_SRC_NAME_WE}.comp"
         VERBATIM
Index: ncnn-src/ncnn/cmake/ncnn_add_layer.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/cmake/ncnn_add_layer.cmake b/ncnn-src/ncnn/cmake/ncnn_add_layer.cmake
--- a/ncnn-src/ncnn/cmake/ncnn_add_layer.cmake	(revision 528589571085b673be7313a9c6e65801f150f607)
+++ b/ncnn-src/ncnn/cmake/ncnn_add_layer.cmake	(date 1745638475833)
@@ -1,28 +1,28 @@
-
+set(_CURRENT_DIR ${CMAKE_CURRENT_LIST_DIR})
 macro(ncnn_add_arch_opt_layer class NCNN_TARGET_ARCH_OPT NCNN_TARGET_ARCH_OPT_CFLAGS)
-    set(NCNN_${NCNN_TARGET_ARCH}_HEADER ${CMAKE_CURRENT_SOURCE_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.h)
-    set(NCNN_${NCNN_TARGET_ARCH}_SOURCE ${CMAKE_CURRENT_SOURCE_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.cpp)
+    set(NCNN_${NCNN_TARGET_ARCH}_HEADER ${_CURRENT_DIR}/../src/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.h)
+    set(NCNN_${NCNN_TARGET_ARCH}_SOURCE ${_CURRENT_DIR}/../src/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.cpp)
 
-    if(WITH_LAYER_${name} AND EXISTS ${NCNN_${NCNN_TARGET_ARCH}_HEADER} AND EXISTS ${NCNN_${NCNN_TARGET_ARCH}_SOURCE})
+    if (WITH_LAYER_${name} AND EXISTS ${NCNN_${NCNN_TARGET_ARCH}_HEADER} AND EXISTS ${NCNN_${NCNN_TARGET_ARCH}_SOURCE})
 
-        set(NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER ${CMAKE_CURRENT_BINARY_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.h)
-        set(NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE ${CMAKE_CURRENT_BINARY_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.cpp)
+        set(NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER ${CMAKE_CURRENT_BINARY_DIR}/generated/ncnn/include/ncnn/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.h)
+        set(NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE ${CMAKE_CURRENT_BINARY_DIR}/generated/ncnn/src/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.cpp)
 
         add_custom_command(
-            OUTPUT ${NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER}
-            COMMAND ${CMAKE_COMMAND} -DSRC=${NCNN_${NCNN_TARGET_ARCH}_HEADER} -DDST=${NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER} -DCLASS=${class} -P "${CMAKE_CURRENT_SOURCE_DIR}/../cmake/ncnn_generate_${NCNN_TARGET_ARCH_OPT}_source.cmake"
-            DEPENDS ${NCNN_${NCNN_TARGET_ARCH}_HEADER}
-            COMMENT "Generating source ${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.h"
-            VERBATIM
+                OUTPUT ${NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER}
+                COMMAND ${CMAKE_COMMAND} -DSRC=${NCNN_${NCNN_TARGET_ARCH}_HEADER} -DDST=${NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER} -DCLASS=${class} -P "${_CURRENT_DIR}/ncnn_generate_${NCNN_TARGET_ARCH_OPT}_source.cmake"
+                DEPENDS ${NCNN_${NCNN_TARGET_ARCH}_HEADER}
+                COMMENT "Generating source ${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.h"
+                VERBATIM
         )
         set_source_files_properties(${NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER} PROPERTIES GENERATED TRUE)
 
         add_custom_command(
-            OUTPUT ${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE}
-            COMMAND ${CMAKE_COMMAND} -DSRC=${NCNN_${NCNN_TARGET_ARCH}_SOURCE} -DDST=${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE} -DCLASS=${class} -P "${CMAKE_CURRENT_SOURCE_DIR}/../cmake/ncnn_generate_${NCNN_TARGET_ARCH_OPT}_source.cmake"
-            DEPENDS ${NCNN_${NCNN_TARGET_ARCH}_SOURCE}
-            COMMENT "Generating source ${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.cpp"
-            VERBATIM
+                OUTPUT ${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE}
+                COMMAND ${CMAKE_COMMAND} -DSRC=${NCNN_${NCNN_TARGET_ARCH}_SOURCE} -DDST=${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE} -DCLASS=${class} -P "${_CURRENT_DIR}/ncnn_generate_${NCNN_TARGET_ARCH_OPT}_source.cmake"
+                DEPENDS ${NCNN_${NCNN_TARGET_ARCH}_SOURCE}
+                COMMENT "Generating source ${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.cpp"
+                VERBATIM
         )
         set_source_files_properties(${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE} PROPERTIES GENERATED TRUE)
 
@@ -46,7 +46,7 @@
 endmacro()
 
 macro(ncnn_add_arch_opt_source class NCNN_TARGET_ARCH_OPT NCNN_TARGET_ARCH_OPT_CFLAGS)
-    set(NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE ${CMAKE_CURRENT_SOURCE_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.cpp)
+    set(NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE ${_CURRENT_DIR}/../src/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.cpp)
 
     if(WITH_LAYER_${name} AND EXISTS ${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE})
         if(NCNN_RUNTIME_CPU)
@@ -84,9 +84,9 @@
 
     # WITH_LAYER_xxx option
     if(${ARGC} EQUAL 2)
-        option(WITH_LAYER_${name} "build with layer ${name}" ${ARGV1})
+        set(WITH_LAYER_${name} ${ARGV1})
     else()
-        option(WITH_LAYER_${name} "build with layer ${name}" ON)
+        set(WITH_LAYER_${name} ON)
     endif()
 
     if(NCNN_CMAKE_VERBOSE)
@@ -94,17 +94,17 @@
     endif()
 
     if(WITH_LAYER_${name})
-        list(APPEND ncnn_SRCS ${CMAKE_CURRENT_SOURCE_DIR}/layer/${name}.cpp)
+        list(APPEND ncnn_SRCS ${_CURRENT_DIR}/../src/layer/${name}.cpp)
 
         # look for arch specific implementation and append source
         # optimized implementation for armv7, aarch64 or x86
-        set(LAYER_ARCH_SRC ${CMAKE_CURRENT_SOURCE_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.cpp)
+        set(LAYER_ARCH_SRC ${_CURRENT_DIR}/../src/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.cpp)
         if(EXISTS ${LAYER_ARCH_SRC})
             set(WITH_LAYER_${name}_${NCNN_TARGET_ARCH} 1)
             list(APPEND ncnn_SRCS ${LAYER_ARCH_SRC})
         endif()
 
-        set(LAYER_VULKAN_SRC ${CMAKE_CURRENT_SOURCE_DIR}/layer/vulkan/${name}_vulkan.cpp)
+        set(LAYER_VULKAN_SRC ${_CURRENT_DIR}/../src/layer/vulkan/${name}_vulkan.cpp)
         if(NCNN_VULKAN AND EXISTS ${LAYER_VULKAN_SRC})
             set(WITH_LAYER_${name}_vulkan 1)
             list(APPEND ncnn_SRCS ${LAYER_VULKAN_SRC})
@@ -116,28 +116,28 @@
         set(layer_declaration "${layer_declaration}#include \"layer/${name}.h\"\n")
         set(layer_declaration "${layer_declaration}namespace ncnn { DEFINE_LAYER_CREATOR(${class}) }\n")
 
-        source_group ("sources\\\\layers" FILES "${CMAKE_CURRENT_SOURCE_DIR}/layer/${name}.cpp")
+        source_group ("sources\\\\layers" FILES "${_CURRENT_DIR}/../src/layer/${name}.cpp")
     endif()
 
     if(WITH_LAYER_${name}_${NCNN_TARGET_ARCH})
         set(layer_declaration "${layer_declaration}#include \"layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.h\"\n")
         set(layer_declaration "${layer_declaration}namespace ncnn { DEFINE_LAYER_CREATOR(${class}_${NCNN_TARGET_ARCH}) }\n")
 
-        source_group ("sources\\\\layers\\\\${NCNN_TARGET_ARCH}" FILES "${CMAKE_CURRENT_SOURCE_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.cpp")
+        source_group ("sources\\\\layers\\\\${NCNN_TARGET_ARCH}" FILES "${_CURRENT_DIR}/../src/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.cpp")
     endif()
 
     if(WITH_LAYER_${name}_vulkan)
         set(layer_declaration "${layer_declaration}#include \"layer/vulkan/${name}_vulkan.h\"\n")
         set(layer_declaration "${layer_declaration}namespace ncnn { DEFINE_LAYER_CREATOR(${class}_vulkan) }\n")
 
-        file(GLOB_RECURSE NCNN_SHADER_SRCS "layer/vulkan/shader/${name}.comp")
-        file(GLOB_RECURSE NCNN_SHADER_SUBSRCS "layer/vulkan/shader/${name}_*.comp")
+        file(GLOB_RECURSE NCNN_SHADER_SRCS "${_CURRENT_DIR}/../src/layer/vulkan/shader/${name}.comp")
+        file(GLOB_RECURSE NCNN_SHADER_SUBSRCS "${_CURRENT_DIR}/../src/layer/vulkan/shader/${name}_*.comp")
         list(APPEND NCNN_SHADER_SRCS ${NCNN_SHADER_SUBSRCS})
         foreach(NCNN_SHADER_SRC ${NCNN_SHADER_SRCS})
             ncnn_add_shader(${NCNN_SHADER_SRC})
         endforeach()
 
-        source_group ("sources\\\\layers\\\\vulkan" FILES "${CMAKE_CURRENT_SOURCE_DIR}/layer/vulkan/${name}_vulkan.cpp")
+        source_group ("sources\\\\layers\\\\vulkan" FILES "${_CURRENT_DIR}/../src/layer/vulkan/${name}_vulkan.cpp")
     endif()
 
     if(WITH_LAYER_${name})
Index: arrow-src/arrow/cpp/src/parquet/platform.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/arrow-src/arrow/cpp/src/parquet/platform.h b/arrow-src/arrow/cpp/src/parquet/platform.h
--- a/arrow-src/arrow/cpp/src/parquet/platform.h	(revision 272715f6df2a042d69881ffa03d5078c58e4b345)
+++ b/arrow-src/arrow/cpp/src/parquet/platform.h	(date 1745650978058)
@@ -25,6 +25,7 @@
 #include "arrow/status.h"         // IWYU pragma: export
 #include "arrow/type_fwd.h"       // IWYU pragma: export
 #include "arrow/util/macros.h"    // IWYU pragma: export
+#include <parquet_export.h>
 
 #if defined(_WIN32) || defined(__CYGWIN__)
 
@@ -43,6 +44,7 @@
 #    pragma GCC diagnostic ignored "-Wattributes"
 #  endif
 
+#if 0
 #  ifdef PARQUET_STATIC
 #    define PARQUET_EXPORT
 #  elif defined(PARQUET_EXPORTING)
@@ -61,6 +63,7 @@
 #    define PARQUET_NO_EXPORT __attribute__((visibility("hidden")))
 #  endif
 #endif  // Non-Windows
+#endif
 
 // This is a complicated topic, some reading on it:
 // http://www.codesynthesis.com/~boris/blog/2010/01/18/dll-export-cxx-templates/
@@ -75,7 +78,9 @@
 #define PARQUET_DISALLOW_COPY_AND_ASSIGN ARROW_DISALLOW_COPY_AND_ASSIGN
 
 #define PARQUET_NORETURN ARROW_NORETURN
+#if 0
 #define PARQUET_DEPRECATED ARROW_DEPRECATED
+#endif
 
 // If ARROW_VALGRIND set when compiling unit tests, also define
 // PARQUET_VALGRIND
Index: ncnn-src/ncnn/cmake/ncnn_generate_shader_comp_header.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/cmake/ncnn_generate_shader_comp_header.cmake b/ncnn-src/ncnn/cmake/ncnn_generate_shader_comp_header.cmake
--- a/ncnn-src/ncnn/cmake/ncnn_generate_shader_comp_header.cmake	(revision 528589571085b673be7313a9c6e65801f150f607)
+++ b/ncnn-src/ncnn/cmake/ncnn_generate_shader_comp_header.cmake	(date 1745583015929)
@@ -18,8 +18,8 @@
 get_filename_component(SHADER_SRC_NAME_WE ${SHADER_SRC} NAME_WE)
 
 # text to hex
-file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/layer/vulkan/shader/${SHADER_SRC_NAME_WE}.text2hex.txt "${comp_data}")
-file(READ ${CMAKE_CURRENT_BINARY_DIR}/layer/vulkan/shader/${SHADER_SRC_NAME_WE}.text2hex.txt comp_data_hex HEX)
+file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/generated/ncnn/tmp/${SHADER_SRC_NAME_WE}.text2hex.txt "${comp_data}")
+file(READ ${CMAKE_CURRENT_BINARY_DIR}/generated/ncnn/tmp/${SHADER_SRC_NAME_WE}.text2hex.txt comp_data_hex HEX)
 string(REGEX REPLACE "([0-9a-f][0-9a-f])" "0x\\1," comp_data_hex ${comp_data_hex})
 string(FIND "${comp_data_hex}" "," tail_comma REVERSE)
 string(SUBSTRING "${comp_data_hex}" 0 ${tail_comma} comp_data_hex)
Index: yaehmop-src/yaehmop/tightbind/cboris.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/yaehmop-src/yaehmop/tightbind/cboris.c b/yaehmop-src/yaehmop/tightbind/cboris.c
--- a/yaehmop-src/yaehmop/tightbind/cboris.c	(revision 44967ec9fca7d2a84bd6bd991ae253d6f5eb17ba)
+++ b/yaehmop-src/yaehmop/tightbind/cboris.c	(date 1745583016039)
@@ -2,7 +2,7 @@
 Produced by gmFortran V30.59(10/26/17) on 9/18/18 at 9:02:32
 */
 #define LPROTOTYPE
-#include "fortran.h"
+#include <math.h>
 void cboris(int *n,int *nd,double *a,double *b,double *c,double *d,double *e,
     double *f,int *fail)
 {
Index: skia-src/skia/src/base/SkVx.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/src/base/SkVx.h b/skia-src/skia/src/base/SkVx.h
--- a/skia-src/skia/src/base/SkVx.h	(revision 482de011c920d85fdbe21a81c45852655df6a809)
+++ b/skia-src/skia/src/base/SkVx.h	(date 1745667302764)
@@ -46,6 +46,7 @@
     #elif SK_CPU_SSE_LEVEL >= SK_CPU_SSE_LEVEL_SSE41
         #include <smmintrin.h>
     #elif SK_CPU_SSE_LEVEL >= SK_CPU_SSE_LEVEL_SSE1
+        #include <immintrin.h>
         #include <xmmintrin.h>
     #elif defined(SK_ARM_HAS_NEON)
         #include <arm_neon.h>
Index: yaehmop-src/yaehmop/tightbind/lovlap.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/yaehmop-src/yaehmop/tightbind/lovlap.c b/yaehmop-src/yaehmop/tightbind/lovlap.c
--- a/yaehmop-src/yaehmop/tightbind/lovlap.c	(revision 44967ec9fca7d2a84bd6bd991ae253d6f5eb17ba)
+++ b/yaehmop-src/yaehmop/tightbind/lovlap.c	(date 1745583015992)
@@ -2,7 +2,7 @@
 Produced by gmFortran V30.59(10/26/17) on 9/17/18 at 9:45:37
 */
 #define LPROTOTYPE
-#include "fortran.h"
+#include <math.h>
 /*
 */
 void lovlap(double *strad,double *a,double *b,double *sk1,double *sk2,double *r,
Index: skia-src/skia/include/private/base/SkAttributes.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/include/private/base/SkAttributes.h b/skia-src/skia/include/private/base/SkAttributes.h
--- a/skia-src/skia/include/private/base/SkAttributes.h	(revision 482de011c920d85fdbe21a81c45852655df6a809)
+++ b/skia-src/skia/include/private/base/SkAttributes.h	(date 1745583016086)
@@ -24,7 +24,7 @@
  *     SK_ALWAYS_INLINE void someMethod() { ... }   // should always be inlined
  */
 #if !defined(SK_ALWAYS_INLINE)
-#  if defined(SK_BUILD_FOR_WIN)
+#  if defined(SK_BUILD_FOR_WIN) && !defined(__MINGW32__)
 #    define SK_ALWAYS_INLINE __forceinline
 #  else
 #    define SK_ALWAYS_INLINE SK_ATTRIBUTE(always_inline) inline
Index: openbabel-src/openbabel/include/openbabel/typer.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/typer.h b/openbabel-src/openbabel/include/openbabel/typer.h
--- a/openbabel-src/openbabel/include/openbabel/typer.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/typer.h	(date 1745583015867)
@@ -67,7 +67,7 @@
 #endif
 //! Global OBAtomTyper for marking internal valence, hybridization,
 //!  and atom types (for internal and external use)
-THREAD_LOCAL OB_EXTERN OBAtomTyper      atomtyper;
+THREAD_LOCAL extern OBAtomTyper      atomtyper;
 
 // class introduction in typer.cpp
 class OBAPI OBAromaticTyper
@@ -81,7 +81,7 @@
 };
 
 //! Global OBAromaticTyper for detecting aromatic atoms and bonds
-THREAD_LOCAL OB_EXTERN OBAromaticTyper  aromtyper;
+THREAD_LOCAL extern OBAromaticTyper  aromtyper;
 
 // class introduction in typer.cpp
 class OBAPI OBRingTyper : public OBGlobalDataBase
Index: openbabel-src/openbabel/include/openbabel/plugin.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/plugin.h b/openbabel-src/openbabel/include/openbabel/plugin.h
--- a/openbabel-src/openbabel/include/openbabel/plugin.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/plugin.h	(date 1745583015851)
@@ -20,7 +20,6 @@
 #define OB_PLUGIN_H
 
 #include <openbabel/babelconfig.h>
-#include <openbabel/dlhandler.h>
 #include <string>
 #include <iostream>
 #include <vector>
@@ -38,7 +37,7 @@
 ///@{
 
 /// @brief Case insensitive string comparison for PluginMapType key.
-struct OBERROR CharPtrLess : public std::binary_function<const char*,const char*, bool>
+struct OBERROR CharPtrLess
 {
   bool operator()(const char* p1,const char* p2) const
   { return strcasecmp(p1,p2)<0; }
@@ -150,53 +149,13 @@
   const char* _id;
 };
 
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-
 //Macro to be added to definition of the base class
 #define MAKE_PLUGIN(BaseClass)\
-protected:\
-  static PluginMapType& Map();\
-  virtual PluginMapType& GetMap() const {\
-    return Map();\
-  }\
-public:\
-  static BaseClass*& Default() {\
-    static BaseClass* d;\
-    return d;\
-  }\
-  BaseClass(const char* ID, bool IsDefault=false) {\
-    _id=ID;\
-    if (ID&&*ID) {\
-      if (IsDefault || Map().empty()) {\
-        Default() = this;\
-      }\
-      if (Map().count(ID) == 0) {\
-        Map()[ID] = this;\
-        PluginMap()[TypeID()] = this;\
-      }\
-    }\
-  }\
-  static BaseClass* FindType(const char* ID) {\
-    if (!ID || *ID==0 || *ID==' ') {\
-      return Default();\
-    }\
-    return static_cast<BaseClass*>(BaseFindType(Map(),ID));\
-  }
-
-#define PLUGIN_CPP_FILE(BaseClass)\
-OBPlugin::PluginMapType& BaseClass::Map() {\
-  static OBPlugin::PluginMapType map;\
-  return map;\
-}
-
-#else // __CYGWIN__ || __MINGW32__
-
-//Macro to be added to definition of the base class
-#define MAKE_PLUGIN(BaseClass)\
+private:\
+   inline static PluginMapType mPluginMapHolder;\
 protected:\
   static PluginMapType& Map() {\
-    static PluginMapType m;\
-    return m;\
+    return mPluginMapHolder;\
   }\
   virtual PluginMapType& GetMap() const {\
     return Map();\
@@ -223,9 +182,8 @@
       return Default();\
     }\
     return static_cast<BaseClass*>(BaseFindType(Map(),ID));\
-  }
-
-#endif // __CYGWIN__ || __MINGW32__
+  }\
+  private:
 
 /** \file plugin.h
    \brief Simplify 'plugin' classes to be discovered and/or loaded at runtime.
@@ -371,7 +329,7 @@
 
 #define OB_STATIC_PLUGIN(className,instanceName) \
   class className; \
-  OBAPI OB_EXTERN className instanceName;
+  OB_EXTERN className instanceName;
 
   // formats
   OB_STATIC_PLUGIN(ABINITFormat, theABINITFormat)
@@ -430,6 +388,8 @@
   OB_STATIC_PLUGIN(HINFormat, theHINFormat)
   OB_STATIC_PLUGIN(JaguarOutputFormat, theJaguarOutputFormat)
   OB_STATIC_PLUGIN(JaguarInputFormat, theJaguarInputFormat)
+  OB_STATIC_PLUGIN(ChemDoodleJSONFormat, theChemDoodleJSONFormat)
+  OB_STATIC_PLUGIN(PubChemJSONFormat, thePubChemJSONFormat)
   OB_STATIC_PLUGIN(LMPDATFormat, theLMPDATFormat)
   OB_STATIC_PLUGIN(MCDLFormat, theMCDLFormat)
   OB_STATIC_PLUGIN(MOLFormat, theMOLFormat)
@@ -463,6 +423,7 @@
   OB_STATIC_PLUGIN(PDBQTFormat, thePDBQTFormat)
 #ifdef HAVE_LIBZ
   OB_STATIC_PLUGIN(PNGFormat, thePNGFormat)
+  OB_STATIC_PLUGIN(PNG2Format, thePNG2Format)
 #endif
   OB_STATIC_PLUGIN(PointCloudFormat, thePointCloudFormat)
   OB_STATIC_PLUGIN(PovrayFormat, thePovrayFormat)
@@ -502,6 +463,8 @@
 #endif
 #ifdef HAVE_STATIC_INCHI
   OB_STATIC_PLUGIN(InChIFormat, theInChIFormat)
+  OB_STATIC_PLUGIN(InChICompareFormat, theInChICompareFormat)
+  OB_STATIC_PLUGIN(InChIKeyFormat, theInChIKeyFormat)
 #endif
 #ifdef HAVE_REGEX_H
   OB_STATIC_PLUGIN(GAMESSUKInputFormat, theGAMESSUKInputFormat)
@@ -560,6 +523,7 @@
   OB_STATIC_PLUGIN(OpFillUC, theOpFillUC)
   OB_STATIC_PLUGIN(OpEnergy, theOpEnergy)
   OB_STATIC_PLUGIN(OpMinimize, theOpMinimize)
+  OB_STATIC_PLUGIN(Op2D, theOp2D)
   OB_STATIC_PLUGIN(OpGen2D, theOpGen2D)
   OB_STATIC_PLUGIN(OpGen3D, theOpGen3D)
   OB_STATIC_PLUGIN(OpNewS, theOpNewS)
Index: thrift-src/thrift/lib/cpp/src/thrift/thrift_export.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/thrift-src/thrift/lib/cpp/src/thrift/thrift_export.h b/thrift-src/thrift/lib/cpp/src/thrift/thrift_export.h
--- a/thrift-src/thrift/lib/cpp/src/thrift/thrift_export.h	(revision 1a31d9051d35b732a5fce258955ef95f576694ba)
+++ b/thrift-src/thrift/lib/cpp/src/thrift/thrift_export.h	(date 1745583016086)
@@ -1,3 +1,4 @@
+#if 0
 #ifndef THRIFT_EXPORT_H
 #define THRIFT_EXPORT_H
 
@@ -18,3 +19,8 @@
 #endif
 
 #endif /* THRIFT_EXPORT_H */
+#endif
+
+#pragma once
+
+#include "thrift_export.hpp"
Index: openbabel-src/openbabel/include/openbabel/inchiformat.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/inchiformat.h b/openbabel-src/openbabel/include/openbabel/inchiformat.h
--- a/openbabel-src/openbabel/include/openbabel/inchiformat.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/inchiformat.h	(date 1745583015851)
@@ -131,7 +131,6 @@
   // and "CH4" is less than "C2H6"
   // and "CH4" is less than "ClH" (hydrogen chloride)
   struct InchiLess
-    : public std::binary_function<const std::string&, const std::string&, bool>
   {
     bool operator()(const std::string& s1, const std::string& s2) const
     {
@@ -146,12 +145,14 @@
           {
             n1 = atoi(&*p1);
             //skip over number
-            while(p1!=s1.end() && isdigit(*p1++)); --p1;
+            while(p1!=s1.end() && isdigit(*p1++)) {}
+            --p1;
           }
         if(isdigit(*p2))
           {
             n2 = atoi(&*p2);
-            while(p2!=s2.end() && isdigit(*p2++)); --p2;
+            while(p2!=s2.end() && isdigit(*p2++)) {}
+            --p2;
           }
         if(n1<0 && n2 < 0)
           {
Index: pixman-src/pixman/pixman/pixman-compiler.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pixman-src/pixman/pixman/pixman-compiler.h b/pixman-src/pixman/pixman/pixman-compiler.h
--- a/pixman-src/pixman/pixman/pixman-compiler.h	(revision 54cad71674ec485cbbbf49876feaa8a69b97c828)
+++ b/pixman-src/pixman/pixman/pixman-compiler.h	(date 1745583016148)
@@ -89,6 +89,7 @@
 #   endif
 #endif
 
+#if 0
 /* GCC visibility */
 #if defined(__GNUC__) && __GNUC__ >= 4 && !defined(_WIN32)
 #   define PIXMAN_EXPORT __attribute__ ((visibility("default")))
@@ -100,6 +101,7 @@
 #else
 #   define PIXMAN_EXPORT
 #endif
+#endif
 
 /* member offsets */
 #define CONTAINER_OF(type, member, data)				\
Index: yaehmop-src/yaehmop/tightbind/diag.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/yaehmop-src/yaehmop/tightbind/diag.c b/yaehmop-src/yaehmop/tightbind/diag.c
--- a/yaehmop-src/yaehmop/tightbind/diag.c	(revision 44967ec9fca7d2a84bd6bd991ae253d6f5eb17ba)
+++ b/yaehmop-src/yaehmop/tightbind/diag.c	(date 1745583016039)
@@ -2,7 +2,9 @@
 Produced by gmFortran V30.59(10/26/17) on 9/18/18 at 9:02:32
 */
 #define LPROTOTYPE
-#include "fortran.h"
+#include "bind.h"
+#include <math.h>
+
 void cchol(int *n,int *nd,double *a,int *fail)
 {
 static int i,ia,j,k,ka;
@@ -431,7 +433,7 @@
 */
         p = (d[l]-d[l-1])/(2.0e0*e[l-1]);
         r = sqrt(1.0e0+p*p);
-        h = d[l-1]-e[l-1]/(p+fdsign(r,p));
+        h = d[l-1]-e[l-1]/(p+d_sign(r,p));
 /*
 */
         for(i=l; i<=*n; i++) {
Index: openbabel-src/openbabel/include/openbabel/obmolecformat.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/obmolecformat.h b/openbabel-src/openbabel/include/openbabel/obmolecformat.h
--- a/openbabel-src/openbabel/include/openbabel/obmolecformat.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/obmolecformat.h	(date 1745583015883)
@@ -142,7 +142,7 @@
 #endif
 
 #ifdef _MSC_VER
-  typedef std::tr1::unordered_map<std::string, unsigned> NameIndexType;
+  typedef std::unordered_map<std::string, unsigned> NameIndexType;
 #elif defined(_LIBCPP_VERSION)
   typedef std::unordered_map<std::string, unsigned> NameIndexType;
 #elif (__GNUC__ == 4 && __GNUC_MINOR__ >= 1 && !defined(__APPLE_CC__)) || defined (USE_BOOST)
Index: openbabel-src/openbabel/include/openbabel/tokenst.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/tokenst.h b/openbabel-src/openbabel/include/openbabel/tokenst.h
--- a/openbabel-src/openbabel/include/openbabel/tokenst.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/tokenst.h	(date 1745583015883)
@@ -25,7 +25,6 @@
 #include <vector>
 #include <sstream>
 #include <string>
-#include <fstream>
 
 namespace OpenBabel
 {
@@ -56,7 +55,7 @@
 
   //! Opens a datafile in a directory where OpenBabel expects to find it.
   // full documentation in tokenst.cpp
-  OBERROR std::string OpenDatafile(std::ifstream& fs,
+  OBERROR std::string OpenDatafile(std::istringstream& iss,
                                  const std::string& filename,
                                  const std::string& envvar = "BABEL_DATADIR");
 
Index: opencv-src/opencv/modules/core/include/opencv2/core/utils/filesystem.private.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/core/include/opencv2/core/utils/filesystem.private.hpp b/opencv-src/opencv/modules/core/include/opencv2/core/utils/filesystem.private.hpp
--- a/opencv-src/opencv/modules/core/include/opencv2/core/utils/filesystem.private.hpp	(revision 31b0eeea0b44b370fd0712312df4214d4ae1b158)
+++ b/opencv-src/opencv/modules/core/include/opencv2/core/utils/filesystem.private.hpp	(date 1745583016023)
@@ -27,6 +27,7 @@
 #    define OPENCV_HAVE_FILESYSTEM_SUPPORT 0
 #  endif
 #endif
+#undef OPENCV_HAVE_FILESYSTEM_SUPPORT
 
 #if OPENCV_HAVE_FILESYSTEM_SUPPORT
 namespace cv { namespace utils { namespace fs {
Index: pixman-src/pixman/pixman/pixman-version.h.in
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pixman-src/pixman/pixman/pixman-version.h.in b/pixman-src/pixman/pixman/pixman-version.h.in
--- a/pixman-src/pixman/pixman/pixman-version.h.in	(revision 54cad71674ec485cbbbf49876feaa8a69b97c828)
+++ b/pixman-src/pixman/pixman/pixman-version.h.in	(date 1745583016179)
@@ -27,6 +27,7 @@
 #ifndef PIXMAN_VERSION_H__
 #define PIXMAN_VERSION_H__
 
+#include "pixman_export.h"
 #ifndef PIXMAN_H__
 #  error pixman-version.h should only be included by pixman.h
 #endif
@@ -48,7 +49,7 @@
 	PIXMAN_VERSION_MICRO)
 
 #ifndef PIXMAN_API
-# define PIXMAN_API
+# define PIXMAN_API PIXMAN_EXPORT
 #endif
 
 #endif /* PIXMAN_VERSION_H__ */
Index: openbabel-src/openbabel/include/openbabel/obutil.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/obutil.h b/openbabel-src/openbabel/include/openbabel/obutil.h
--- a/openbabel-src/openbabel/include/openbabel/obutil.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/obutil.h	(date 1745583015851)
@@ -24,6 +24,7 @@
 
 #include <string>
 #include <iosfwd>
+#include <fstream>
 
 #if TIME_WITH_SYS_TIME
 #include <sys/time.h>
Index: thrift-src/thrift/lib/cpp/src/thrift/windows/Sync.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/thrift-src/thrift/lib/cpp/src/thrift/windows/Sync.h b/thrift-src/thrift/lib/cpp/src/thrift/windows/Sync.h
--- a/thrift-src/thrift/lib/cpp/src/thrift/windows/Sync.h	(revision 1a31d9051d35b732a5fce258955ef95f576694ba)
+++ b/thrift-src/thrift/lib/cpp/src/thrift/windows/Sync.h	(date 1745583016164)
@@ -37,7 +37,7 @@
 #define WIN32_LEAN_AND_MEAN
 #define _THRIFT_UNDEF_WIN32_LEAN_AND_MEAN
 #endif
-#include <Windows.h>
+#include <windows.h>
 #ifdef _THRIFT_UNDEF_NOMINMAX
 #undef NOMINMAX
 #undef _THRIFT_UNDEF_NOMINMAX
Index: openbabel-src/openbabel/include/openbabel/tree/tree.hh
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/tree/tree.hh b/openbabel-src/openbabel/include/openbabel/tree/tree.hh
--- a/openbabel-src/openbabel/include/openbabel/tree/tree.hh	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/tree/tree.hh	(date 1745583015898)
@@ -542,8 +542,8 @@
 template <class T, class tree_node_allocator>
 void tree<T, tree_node_allocator>::head_initialise_()
    {
-   head = alloc_.allocate(1,nullptr); // MSVC does not have default second argument
-	feet = alloc_.allocate(1,nullptr);
+   head = alloc_.allocate(1);
+   feet = alloc_.allocate(1);
 
    head->parent=nullptr;
    head->first_child=nullptr;
@@ -869,7 +869,7 @@
 	assert(position.node!=head);
 	assert(position.node);
 
-	tree_node *tmp=alloc_.allocate(1,0);
+	tree_node *tmp=alloc_.allocate(1);
 	kp::constructor(&tmp->data);
 	tmp->first_child=0;
 	tmp->last_child=0;
@@ -894,7 +894,7 @@
 	assert(position.node!=head);
 	assert(position.node);
 
-	tree_node *tmp=alloc_.allocate(1,0);
+	tree_node *tmp=alloc_.allocate(1);
 	kp::constructor(&tmp->data);
 	tmp->first_child=0;
 	tmp->last_child=0;
@@ -923,7 +923,7 @@
 	assert(position.node!=head);
 	assert(position.node);
 
-	tree_node* tmp = alloc_.allocate(1,nullptr);
+	tree_node* tmp = alloc_.allocate(1);
 	kp::constructor(&tmp->data, x);
 	tmp->first_child=nullptr;
 	tmp->last_child=nullptr;
@@ -948,7 +948,7 @@
 	assert(position.node!=head);
 	assert(position.node);
 
-	tree_node* tmp = alloc_.allocate(1,0);
+	tree_node* tmp = alloc_.allocate(1);
 	kp::constructor(&tmp->data, x);
 	tmp->first_child=0;
 	tmp->last_child=0;
@@ -1035,7 +1035,7 @@
 		position.node=feet; // Backward compatibility: when calling insert on a null node,
 		                    // insert before the feet.
 		}
-	tree_node* tmp = alloc_.allocate(1,nullptr);
+	tree_node* tmp = alloc_.allocate(1);
 	kp::constructor(&tmp->data, x);
 	tmp->first_child=nullptr;
 	tmp->last_child=nullptr;
@@ -1057,7 +1057,7 @@
 template <class T, class tree_node_allocator>
 typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::insert(sibling_iterator position, const T& x)
 	{
-	tree_node* tmp = alloc_.allocate(1,0);
+	tree_node* tmp = alloc_.allocate(1);
 	kp::constructor(&tmp->data, x);
 	tmp->first_child=0;
 	tmp->last_child=0;
@@ -1087,7 +1087,7 @@
 template <class iter>
 iter tree<T, tree_node_allocator>::insert_after(iter position, const T& x)
 	{
-	tree_node* tmp = alloc_.allocate(1,0);
+	tree_node* tmp = alloc_.allocate(1);
 	kp::constructor(&tmp->data, x);
 	tmp->first_child=0;
 	tmp->last_child=0;
@@ -1159,7 +1159,7 @@
 //	std::cout << "warning!" << position.node << std::endl;
 	erase_children(position);
 //	std::cout << "no warning!" << std::endl;
-	tree_node* tmp = alloc_.allocate(1,0);
+	tree_node* tmp = alloc_.allocate(1);
 	kp::constructor(&tmp->data, (*from));
 	tmp->first_child=0;
 	tmp->last_child=0;
Index: openbabel-src/openbabel/include/openbabel/math/matrix3x3.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/math/matrix3x3.h b/openbabel-src/openbabel/include/openbabel/math/matrix3x3.h
--- a/openbabel-src/openbabel/include/openbabel/math/matrix3x3.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/math/matrix3x3.h	(date 1745583015867)
@@ -281,7 +281,7 @@
       friend OBAPI std::ostream& operator<< ( std::ostream&, const matrix3x3 & ) ;
 
       //! Eigenvalue calculation
-      static void jacobi(unsigned int n, double *a, double *d, double *v);
+      static void jacobi(int n, double *a, double *d, double *v);
     };
 
 #ifndef SWIG
Index: thrift-src/thrift/lib/cpp/src/thrift/transport/THttpServer.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/thrift-src/thrift/lib/cpp/src/thrift/transport/THttpServer.cpp b/thrift-src/thrift/lib/cpp/src/thrift/transport/THttpServer.cpp
--- a/thrift-src/thrift/lib/cpp/src/thrift/transport/THttpServer.cpp	(revision 1a31d9051d35b732a5fce258955ef95f576694ba)
+++ b/thrift-src/thrift/lib/cpp/src/thrift/transport/THttpServer.cpp	(date 1745583015820)
@@ -25,7 +25,7 @@
 #include <thrift/transport/THttpServer.h>
 #include <thrift/transport/TSocket.h>
 #if defined(_MSC_VER) || defined(__MINGW32__)
-  #include <Shlwapi.h>
+  #include <shlwapi.h>
 #endif
 
 using std::string;
Index: coordgen-src/coordgen/CoordgenConfig.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/coordgen-src/coordgen/CoordgenConfig.hpp b/coordgen-src/coordgen/CoordgenConfig.hpp
--- a/coordgen-src/coordgen/CoordgenConfig.hpp	(revision c4dd5b0e1f1971c06c7ab85725c185e47211814e)
+++ b/coordgen-src/coordgen/CoordgenConfig.hpp	(date 1745583016086)
@@ -1,5 +1,6 @@
 #pragma once
 
+#if 0
 #ifndef STATIC_COORDGEN
 
 #ifdef WIN32
@@ -20,3 +21,9 @@
 #define EXPORT_COORDGEN
 
 #endif // STATIC_COORDGEN
+#endif
+#include <coordgenlibs_export.hpp>
+
+#ifndef EXPORT_COORDGEN
+#define EXPORT_COORDGEN COORDGENLIBS_EXPORT
+#endif
Index: thrift-src/thrift/lib/cpp/src/thrift/transport/TPipeServer.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/thrift-src/thrift/lib/cpp/src/thrift/transport/TPipeServer.cpp b/thrift-src/thrift/lib/cpp/src/thrift/transport/TPipeServer.cpp
--- a/thrift-src/thrift/lib/cpp/src/thrift/transport/TPipeServer.cpp	(revision 1a31d9051d35b732a5fce258955ef95f576694ba)
+++ b/thrift-src/thrift/lib/cpp/src/thrift/transport/TPipeServer.cpp	(date 1745583015836)
@@ -27,8 +27,8 @@
 #ifdef _WIN32
 #include <thrift/windows/OverlappedSubmissionThread.h>
 #include <thrift/windows/Sync.h>
-#include <AccCtrl.h>
-#include <Aclapi.h>
+#include <accctrl.h>
+#include <aclapi.h>
 #include <sddl.h>
 #endif //_WIN32
 
Index: arrow-src/arrow/cpp/src/arrow/acero/visibility.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/arrow-src/arrow/cpp/src/arrow/acero/visibility.h b/arrow-src/arrow/cpp/src/arrow/acero/visibility.h
--- a/arrow-src/arrow/cpp/src/arrow/acero/visibility.h	(revision 272715f6df2a042d69881ffa03d5078c58e4b345)
+++ b/arrow-src/arrow/cpp/src/arrow/acero/visibility.h	(date 1745649465006)
@@ -19,6 +19,7 @@
 
 #pragma once
 
+#if 0
 #if defined(_WIN32) || defined(__CYGWIN__)
 #  if defined(_MSC_VER)
 #    pragma warning(push)
@@ -48,3 +49,15 @@
 #if defined(_MSC_VER)
 #  pragma warning(pop)
 #endif
+
+#endif
+
+#include <arrow/util/visibility.h>
+
+#ifndef ARROW_ACERO_EXPORT
+#define ARROW_ACERO_EXPORT ARROW_EXPORT
+#endif
+
+#ifndef ARROW_ACERO_NO_EXPORT
+#define ARROW_ACERO_NO_EXPORT ARROW_NO_EXPORT
+#endif
Index: quickjs-src/quickjs/quickjs-libc.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/quickjs-libc.c b/quickjs-src/quickjs/src/quickjs-libc.c
rename from quickjs-src/quickjs/quickjs-libc.c
rename to quickjs-src/quickjs/src/quickjs-libc.c
--- a/quickjs-src/quickjs/quickjs-libc.c	(revision 6e2e68fd0896957f92eb6c242a2e048c1ef3cae0)
+++ b/quickjs-src/quickjs/src/quickjs-libc.c	(date 1727695851047)
@@ -28,50 +28,29 @@
 #include <inttypes.h>
 #include <string.h>
 #include <assert.h>
-#include <unistd.h>
 #include <errno.h>
 #include <fcntl.h>
-#include <sys/time.h>
 #include <time.h>
 #include <signal.h>
 #include <limits.h>
 #include <sys/stat.h>
-#include <dirent.h>
 #if defined(_WIN32)
 #include <windows.h>
 #include <conio.h>
-#include <utime.h>
+#ifndef PATH_MAX
+#define PATH_MAX MAX_PATH
+#endif
 #else
+#include <unistd.h>
+#include <dirent.h>
 #include <dlfcn.h>
 #include <termios.h>
 #include <sys/ioctl.h>
+#include <sys/time.h>
 #include <sys/wait.h>
-
-#if defined(__FreeBSD__)
-extern char **environ;
-#endif
-
-#if defined(__APPLE__) || defined(__FreeBSD__)
-typedef sig_t sighandler_t;
-#endif
-
 #if defined(__APPLE__)
-#if !defined(environ)
-#include <crt_externs.h>
-#define environ (*_NSGetEnviron())
+typedef sig_t sighandler_t;
 #endif
-#endif /* __APPLE__ */
-
-#endif
-
-#if !defined(_WIN32)
-/* enable the os.Worker API. IT relies on POSIX threads */
-#define USE_WORKER
-#endif
-
-#ifdef USE_WORKER
-#include <pthread.h>
-#include <stdatomic.h>
 #endif
 
 #include "cutils.h"
@@ -101,6 +80,7 @@
 typedef struct {
     struct list_head link;
     int timer_id;
+    BOOL has_object;
     int64_t timeout;
     JSValue func;
 } JSOSTimer;
@@ -161,7 +141,7 @@
     uint8_t cbuf[UTF8_CHAR_LEN_MAX+1];
     JSValue res;
     DynBuf dbuf;
-    const char *fmt_str = NULL;
+    const char *fmt_str;
     const uint8_t *fmt, *fmt_end;
     const uint8_t *p;
     char *q;
@@ -466,6 +446,7 @@
                                         const char *module_name);
 
 
+#if 0
 #if defined(_WIN32)
 static JSModuleDef *js_module_loader_so(JSContext *ctx,
                                         const char *module_name)
@@ -523,6 +504,7 @@
     return m;
 }
 #endif /* !_WIN32 */
+#endif
 
 int js_module_set_import_meta(JSContext *ctx, JSValueConst func_val,
                               JS_BOOL use_realpath, JS_BOOL is_main)
@@ -577,6 +559,7 @@
     return 0;
 }
 
+#if 0
 JSModuleDef *js_module_loader(JSContext *ctx,
                               const char *module_name, void *opaque)
 {
@@ -610,6 +593,7 @@
     }
     return m;
 }
+#endif
 
 static JSValue js_std_exit(JSContext *ctx, JSValueConst this_val,
                            int argc, JSValueConst *argv)
@@ -688,6 +672,7 @@
     return JS_UNDEFINED;
 }
 
+#if 0
 /* return an object containing the list of the available environment
    variables. */
 static JSValue js_std_getenviron(JSContext *ctx, JSValueConst this_val,
@@ -726,6 +711,7 @@
     JS_FreeValue(ctx, obj);
     return JS_EXCEPTION;
 }
+#endif
 
 static JSValue js_std_gc(JSContext *ctx, JSValueConst this_val,
                          int argc, JSValueConst *argv)
@@ -803,6 +789,7 @@
     return ret;
 }
 
+#if 0
 static JSClassID js_std_file_class_id;
 
 typedef struct {
@@ -824,6 +811,7 @@
         js_free_rt(rt, s);
     }
 }
+#endif
 
 static ssize_t js_get_errno(ssize_t ret)
 {
@@ -856,6 +844,7 @@
     return obj;
 }
 
+#if 0
 static JSValue js_new_std_file(JSContext *ctx, FILE *f,
                                BOOL close_in_finalizer,
                                BOOL is_popen)
@@ -876,6 +865,7 @@
     JS_SetOpaque(obj, s);
     return obj;
 }
+#endif
 
 static void js_set_error_object(JSContext *ctx, JSValue obj, int err)
 {
@@ -884,6 +874,7 @@
     }
 }
 
+#if 0
 static JSValue js_std_open(JSContext *ctx, JSValueConst this_val,
                            int argc, JSValueConst *argv)
 {
@@ -1000,6 +991,7 @@
         return JS_NULL;
     return js_new_std_file(ctx, f, TRUE, FALSE);
 }
+#endif
 
 static JSValue js_std_sprintf(JSContext *ctx, JSValueConst this_val,
                           int argc, JSValueConst *argv)
@@ -1013,6 +1005,7 @@
     return js_printf_internal(ctx, argc, argv, stdout);
 }
 
+#if 0
 static FILE *js_std_file_get(JSContext *ctx, JSValueConst obj)
 {
     JSSTDFile *s = JS_GetOpaque2(ctx, obj, js_std_file_class_id);
@@ -1290,6 +1283,7 @@
     c = fputc(c, f);
     return JS_NewInt32(ctx, c);
 }
+#endif
 
 /* urlGet */
 
@@ -1330,6 +1324,7 @@
     return atoi(p);
 }
 
+#if 0
 static JSValue js_std_urlGet(JSContext *ctx, JSValueConst this_val,
                              int argc, JSValueConst *argv)
 {
@@ -1490,6 +1485,7 @@
     "FILE",
     .finalizer = js_std_file_finalizer,
 };
+#endif
 
 static const JSCFunctionListEntry js_std_error_props[] = {
     /* various errno values */
@@ -1516,18 +1512,22 @@
     JS_CFUNC_DEF("getenv", 1, js_std_getenv ),
     JS_CFUNC_DEF("setenv", 1, js_std_setenv ),
     JS_CFUNC_DEF("unsetenv", 1, js_std_unsetenv ),
+#if 0
     JS_CFUNC_DEF("getenviron", 1, js_std_getenviron ),
     JS_CFUNC_DEF("urlGet", 1, js_std_urlGet ),
+#endif
     JS_CFUNC_DEF("loadFile", 1, js_std_loadFile ),
     JS_CFUNC_DEF("strerror", 1, js_std_strerror ),
     JS_CFUNC_DEF("parseExtJSON", 1, js_std_parseExtJSON ),
 
     /* FILE I/O */
+#if 0
     JS_CFUNC_DEF("open", 2, js_std_open ),
     JS_CFUNC_DEF("popen", 2, js_std_popen ),
     JS_CFUNC_DEF("fdopen", 2, js_std_fdopen ),
     JS_CFUNC_DEF("tmpfile", 0, js_std_tmpfile ),
     JS_CFUNC_MAGIC_DEF("puts", 1, js_std_file_puts, 0 ),
+#endif
     JS_CFUNC_DEF("printf", 1, js_std_printf ),
     JS_CFUNC_DEF("sprintf", 1, js_std_sprintf ),
     JS_PROP_INT32_DEF("SEEK_SET", SEEK_SET, JS_PROP_CONFIGURABLE ),
@@ -1536,6 +1536,7 @@
     JS_OBJECT_DEF("Error", js_std_error_props, countof(js_std_error_props), JS_PROP_CONFIGURABLE),
 };
 
+#if 0
 static const JSCFunctionListEntry js_std_file_proto_funcs[] = {
     JS_CFUNC_DEF("close", 0, js_std_file_close ),
     JS_CFUNC_MAGIC_DEF("puts", 1, js_std_file_puts, 1 ),
@@ -1556,26 +1557,33 @@
     JS_CFUNC_DEF("putByte", 1, js_std_file_putByte ),
     /* setvbuf, ...  */
 };
+#endif
 
 static int js_std_init(JSContext *ctx, JSModuleDef *m)
 {
     JSValue proto;
 
     /* FILE class */
+#if 0
     /* the class ID is created once */
     JS_NewClassID(&js_std_file_class_id);
     /* the class is created once per runtime */
     JS_NewClass(JS_GetRuntime(ctx), js_std_file_class_id, &js_std_file_class);
+#endif
     proto = JS_NewObject(ctx);
+#if 0
     JS_SetPropertyFunctionList(ctx, proto, js_std_file_proto_funcs,
                                countof(js_std_file_proto_funcs));
     JS_SetClassProto(ctx, js_std_file_class_id, proto);
+#endif
 
     JS_SetModuleExportList(ctx, m, js_std_funcs,
                            countof(js_std_funcs));
+#if 0
     JS_SetModuleExport(ctx, m, "in", js_new_std_file(ctx, stdin, FALSE, FALSE));
     JS_SetModuleExport(ctx, m, "out", js_new_std_file(ctx, stdout, FALSE, FALSE));
     JS_SetModuleExport(ctx, m, "err", js_new_std_file(ctx, stderr, FALSE, FALSE));
+#endif
     return 0;
 }
 
@@ -1595,6 +1603,7 @@
 /**********************************************************/
 /* 'os' object */
 
+#if 0
 static JSValue js_os_open(JSContext *ctx, JSValueConst this_val,
                           int argc, JSValueConst *argv)
 {
@@ -1844,6 +1853,7 @@
     JS_FreeCString(ctx, newpath);
     return JS_NewInt32(ctx, ret);
 }
+#endif
 
 static BOOL is_main_thread(JSRuntime *rt)
 {
@@ -1944,6 +1954,7 @@
 typedef void (*sighandler_t)(int sig_num);
 #endif
 
+#if 0
 static JSValue js_os_signal(JSContext *ctx, JSValueConst this_val,
                             int argc, JSValueConst *argv)
 {
@@ -1990,6 +2001,7 @@
     }
     return JS_UNDEFINED;
 }
+#endif
 
 #if defined(__linux__) || defined(__APPLE__)
 static int64_t get_time_ms(void)
@@ -2007,6 +2019,7 @@
 }
 #else
 /* more portable, but does not work if the date is updated */
+int gettimeofday(struct timeval *tp, void *tzp);
 static int64_t get_time_ms(void)
 {
     struct timeval tv;
@@ -2427,6 +2440,7 @@
     return make_obj_error(ctx, JS_NewString(ctx, buf), err);
 }
 
+#if 0
 /* return [cwd, errorcode] */
 static JSValue js_os_getcwd(JSContext *ctx, JSValueConst this_val,
                             int argc, JSValueConst *argv)
@@ -2668,6 +2682,7 @@
     JS_FreeCString(ctx, path);
     return JS_NewInt32(ctx, ret);
 }
+#endif
 
 /* sleep(delay_ms) */
 static JSValue js_os_sleep(JSContext *ctx, JSValueConst this_val,
@@ -2893,6 +2908,7 @@
     return -1;
 }
 
+#if 0
 /* exec(args[, options]) -> exitcode */
 static JSValue js_os_exec(JSContext *ctx, JSValueConst this_val,
                           int argc, JSValueConst *argv)
@@ -3108,6 +3124,7 @@
     ret_val = JS_EXCEPTION;
     goto done;
 }
+#endif
 
 /* getpid() -> pid */
 static JSValue js_os_getpid(JSContext *ctx, JSValueConst this_val,
@@ -3670,7 +3687,9 @@
 #define OS_FLAG(x) JS_PROP_INT32_DEF(#x, x, JS_PROP_CONFIGURABLE )
 
 static const JSCFunctionListEntry js_os_funcs[] = {
+#if 0
     JS_CFUNC_DEF("open", 2, js_os_open ),
+#endif
     OS_FLAG(O_RDONLY),
     OS_FLAG(O_WRONLY),
     OS_FLAG(O_RDWR),
@@ -3682,6 +3701,7 @@
     OS_FLAG(O_BINARY),
     OS_FLAG(O_TEXT),
 #endif
+#if 0
     JS_CFUNC_DEF("close", 1, js_os_close ),
     JS_CFUNC_DEF("seek", 3, js_os_seek ),
     JS_CFUNC_MAGIC_DEF("read", 4, js_os_read_write, 0 ),
@@ -3691,9 +3711,12 @@
     JS_CFUNC_DEF("ttySetRaw", 1, js_os_ttySetRaw ),
     JS_CFUNC_DEF("remove", 1, js_os_remove ),
     JS_CFUNC_DEF("rename", 2, js_os_rename ),
+#endif
     JS_CFUNC_MAGIC_DEF("setReadHandler", 2, js_os_setReadHandler, 0 ),
     JS_CFUNC_MAGIC_DEF("setWriteHandler", 2, js_os_setReadHandler, 1 ),
+#if 0
     JS_CFUNC_DEF("signal", 2, js_os_signal ),
+#endif
     OS_FLAG(SIGINT),
     OS_FLAG(SIGABRT),
     OS_FLAG(SIGFPE),
@@ -3713,22 +3736,33 @@
     OS_FLAG(SIGTTIN),
     OS_FLAG(SIGTTOU),
 #endif
+#if 0
     JS_CFUNC_DEF("now", 0, js_os_now ),
+#endif
     JS_CFUNC_DEF("setTimeout", 2, js_os_setTimeout ),
     JS_CFUNC_DEF("clearTimeout", 1, js_os_clearTimeout ),
+#if 0
     JS_CFUNC_DEF("sleepAsync", 1, js_os_sleepAsync ),
+#endif
     JS_PROP_STRING_DEF("platform", OS_PLATFORM, 0 ),
+#if 0
     JS_CFUNC_DEF("getcwd", 0, js_os_getcwd ),
     JS_CFUNC_DEF("chdir", 0, js_os_chdir ),
     JS_CFUNC_DEF("mkdir", 1, js_os_mkdir ),
     JS_CFUNC_DEF("readdir", 1, js_os_readdir ),
+#endif
     /* st_mode constants */
     OS_FLAG(S_IFMT),
+#if 0
     OS_FLAG(S_IFIFO),
+#endif
     OS_FLAG(S_IFCHR),
     OS_FLAG(S_IFDIR),
+#if 0
     OS_FLAG(S_IFBLK),
+#endif
     OS_FLAG(S_IFREG),
+#if 0
 #if !defined(_WIN32)
     OS_FLAG(S_IFSOCK),
     OS_FLAG(S_IFLNK),
@@ -3737,14 +3771,19 @@
 #endif
     JS_CFUNC_MAGIC_DEF("stat", 1, js_os_stat, 0 ),
     JS_CFUNC_DEF("utimes", 3, js_os_utimes ),
+#endif
     JS_CFUNC_DEF("sleep", 1, js_os_sleep ),
     JS_CFUNC_DEF("realpath", 1, js_os_realpath ),
 #if !defined(_WIN32)
+#if 0
     JS_CFUNC_MAGIC_DEF("lstat", 1, js_os_stat, 1 ),
+#endif
     JS_CFUNC_DEF("symlink", 2, js_os_symlink ),
     JS_CFUNC_DEF("readlink", 1, js_os_readlink ),
+#if 0
     JS_CFUNC_DEF("exec", 1, js_os_exec ),
     JS_CFUNC_DEF("getpid", 0, js_os_getpid ),
+#endif
     JS_CFUNC_DEF("waitpid", 2, js_os_waitpid ),
     OS_FLAG(WNOHANG),
     JS_CFUNC_DEF("pipe", 0, js_os_pipe ),
@@ -3987,6 +4026,7 @@
     }
 }
 
+#if 0
 /* Wait for a promise and execute pending jobs while waiting for
    it. Return the promise result or JS_EXCEPTION in case of promise
    rejection. */
@@ -4022,7 +4062,9 @@
     }
     return ret;
 }
+#endif
 
+#if 0
 void js_std_eval_binary(JSContext *ctx, const uint8_t *buf, size_t buf_len,
                         int load_only)
 {
@@ -4054,3 +4096,4 @@
         JS_FreeValue(ctx, val);
     }
 }
+#endif
Index: quickjs-src/quickjs/libbf.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/libbf.h b/quickjs-src/quickjs/src/libbf.h
rename from quickjs-src/quickjs/libbf.h
rename to quickjs-src/quickjs/src/libbf.h
--- a/quickjs-src/quickjs/libbf.h	(revision 6e2e68fd0896957f92eb6c242a2e048c1ef3cae0)
+++ b/quickjs-src/quickjs/src/libbf.h	(date 1727612068256)
@@ -24,10 +24,15 @@
 #ifndef LIBBF_H
 #define LIBBF_H
 
+#include "quickjs-defs.h"
 #include <stddef.h>
 #include <stdint.h>
 
-#if defined(__SIZEOF_INT128__) && (INTPTR_MAX >= INT64_MAX)
+#if _MSC_VER
+#undef __AVX2__
+#endif
+
+#if INTPTR_MAX >= INT64_MAX && __AVX2__
 #define LIMB_LOG2_BITS 6
 #else
 #define LIMB_LOG2_BITS 5
Index: quickjs-src/quickjs/libregexp.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/libregexp.c b/quickjs-src/quickjs/src/libregexp.c
rename from quickjs-src/quickjs/libregexp.c
rename to quickjs-src/quickjs/src/libregexp.c
--- a/quickjs-src/quickjs/libregexp.c	(revision 6e2e68fd0896957f92eb6c242a2e048c1ef3cae0)
+++ b/quickjs-src/quickjs/src/libregexp.c	(date 1727612068256)
@@ -347,7 +347,7 @@
     dbuf_put_u16(&s->byte_code, val);
 }
 
-static int __attribute__((format(printf, 2, 3))) re_parse_error(REParseState *s, const char *fmt, ...)
+static int PLATFORM_PRINTF_LIKE(2, 3) re_parse_error(REParseState *s, const char *fmt, ...)
 {
     va_list ap;
     va_start(ap, fmt);
Index: quickjs-src/quickjs/quickjs.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/quickjs.h b/quickjs-src/quickjs/include/quickjs/quickjs.h
rename from quickjs-src/quickjs/quickjs.h
rename to quickjs-src/quickjs/include/quickjs/quickjs.h
--- a/quickjs-src/quickjs/quickjs.h	(revision 6e2e68fd0896957f92eb6c242a2e048c1ef3cae0)
+++ b/quickjs-src/quickjs/include/quickjs/quickjs.h	(date 1727612068261)
@@ -25,6 +25,7 @@
 #ifndef QUICKJS_H
 #define QUICKJS_H
 
+#include "quickjs-defs.h"
 #include <stdio.h>
 #include <stdint.h>
 
@@ -32,17 +33,10 @@
 extern "C" {
 #endif
 
-#if defined(__GNUC__) || defined(__clang__)
-#define js_likely(x)          __builtin_expect(!!(x), 1)
-#define js_unlikely(x)        __builtin_expect(!!(x), 0)
-#define js_force_inline       inline __attribute__((always_inline))
-#define __js_printf_like(f, a)   __attribute__((format(printf, f, a)))
-#else
-#define js_likely(x)     (x)
-#define js_unlikely(x)   (x)
-#define js_force_inline  inline
-#define __js_printf_like(a, b)
-#endif
+#define js_likely(x)           PLATFORM_LIKELY(x)
+#define js_unlikely(x)         PLATFORM_UNLIKELY(x)
+#define js_force_inline        PLATFORM_FORCE_INLINE
+#define __js_printf_like(f, a) PLATFORM_PRINTF_LIKE(f, a)
 
 #define JS_BOOL int
 
@@ -215,8 +209,14 @@
 #define JS_VALUE_GET_FLOAT64(v) ((v).u.float64)
 #define JS_VALUE_GET_PTR(v) ((v).u.ptr)
 
+// error C4576: a parenthesized type followed by an initializer list is a non-standard explicit type conversion syntax
+#if _MSC_VER && __cplusplus
+#define JS_MKVAL(tag, val) JSValue{ JSValueUnion{ .int32 = val }, tag }
+#define JS_MKPTR(tag, p) JSValue{ JSValueUnion{ .ptr = p }, tag }
+#else
 #define JS_MKVAL(tag, val) (JSValue){ (JSValueUnion){ .int32 = val }, tag }
 #define JS_MKPTR(tag, p) (JSValue){ (JSValueUnion){ .ptr = p }, tag }
+#endif
 
 #define JS_TAG_IS_FLOAT64(tag) ((unsigned)(tag) == JS_TAG_FLOAT64)
 
@@ -501,8 +501,7 @@
 
 #define JS_INVALID_CLASS_ID 0
 JSClassID JS_NewClassID(JSClassID *pclass_id);
-/* Returns the class ID if `v` is an object, otherwise returns JS_INVALID_CLASS_ID. */
-JSClassID JS_GetClassID(JSValue v);
+JSClassID JS_GetClassID(JSValueConst v);
 int JS_NewClass(JSRuntime *rt, JSClassID class_id, const JSClassDef *class_def);
 int JS_IsRegisteredClass(JSRuntime *rt, JSClassID class_id);
 
@@ -550,6 +549,7 @@
 
 static js_force_inline JSValue JS_NewFloat64(JSContext *ctx, double d)
 {
+    JSValue v;
     int32_t val;
     union {
         double d;
@@ -672,7 +672,7 @@
         JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);
         p->ref_count++;
     }
-    return (JSValue)v;
+    return v;
 }
 
 static inline JSValue JS_DupValueRT(JSRuntime *rt, JSValueConst v)
@@ -681,7 +681,7 @@
         JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);
         p->ref_count++;
     }
-    return (JSValue)v;
+    return v;
 }
 
 JS_BOOL JS_StrictEq(JSContext *ctx, JSValueConst op1, JSValueConst op2);
@@ -875,6 +875,7 @@
                                            JSValueConst reason,
                                            JS_BOOL is_handled, void *opaque);
 void JS_SetHostPromiseRejectionTracker(JSRuntime *rt, JSHostPromiseRejectionTracker *cb, void *opaque);
+void JS_SetHostUnhandledPromiseRejectionTracker(JSRuntime *rt, JSHostPromiseRejectionTracker *cb, void *opaque);
 
 /* return != 0 if the JS code needs to be interrupted */
 typedef int JSInterruptHandler(JSRuntime *rt, void *opaque);
@@ -939,9 +940,11 @@
 
 /* only exported for os.Worker() */
 JSAtom JS_GetScriptOrModuleName(JSContext *ctx, int n_stack_levels);
+#if 0
 /* only exported for os.Worker() */
 JSValue JS_LoadModule(JSContext *ctx, const char *basename,
                       const char *filename);
+#endif
 
 /* C function definition */
 typedef enum JSCFunctionEnum {  /* XXX: should rename for namespace isolation */
Index: quickjs-src/quickjs/cutils.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/cutils.c b/quickjs-src/quickjs/src/cutils.c
rename from quickjs-src/quickjs/cutils.c
rename to quickjs-src/quickjs/src/cutils.c
--- a/quickjs-src/quickjs/cutils.c	(revision 6e2e68fd0896957f92eb6c242a2e048c1ef3cae0)
+++ b/quickjs-src/quickjs/src/cutils.c	(date 1727612068250)
@@ -166,8 +166,7 @@
     return dbuf_put(s, (const uint8_t *)str, strlen(str));
 }
 
-int __attribute__((format(printf, 2, 3))) dbuf_printf(DynBuf *s,
-                                                      const char *fmt, ...)
+int PLATFORM_PRINTF_LIKE(2, 3) dbuf_printf(DynBuf *s, const char *fmt, ...)
 {
     va_list ap;
     char buf[128];
Index: quickjs-src/quickjs/cutils.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/cutils.h b/quickjs-src/quickjs/src/cutils.h
rename from quickjs-src/quickjs/cutils.h
rename to quickjs-src/quickjs/src/cutils.h
--- a/quickjs-src/quickjs/cutils.h	(revision 6e2e68fd0896957f92eb6c242a2e048c1ef3cae0)
+++ b/quickjs-src/quickjs/src/cutils.h	(date 1727612068250)
@@ -25,15 +25,18 @@
 #ifndef CUTILS_H
 #define CUTILS_H
 
+#include "quickjs-defs.h"
 #include <stdlib.h>
-#include <string.h>
 #include <inttypes.h>
 
-#define likely(x)       __builtin_expect(!!(x), 1)
-#define unlikely(x)     __builtin_expect(!!(x), 0)
-#define force_inline inline __attribute__((always_inline))
-#define no_inline __attribute__((noinline))
-#define __maybe_unused __attribute__((unused))
+/* set if CPU is big endian */
+#undef WORDS_BIGENDIAN
+
+#define likely(x)       PLATFORM_LIKELY(x)
+#define unlikely(x)     PLATFORM_UNLIKELY(x)
+#define force_inline    PLATFORM_FORCE_INLINE
+#define no_inline       PLATFORM_NO_INLINE
+#define __maybe_unused  PLATFORM_MAYBE_UNUSED
 
 #define xglue(x, y) x ## y
 #define glue(x, y) xglue(x, y)
@@ -128,27 +131,65 @@
 /* WARNING: undefined if a = 0 */
 static inline int clz32(unsigned int a)
 {
+#if defined(PLATFORM_GNUC_LIKE)
     return __builtin_clz(a);
+#else
+    unsigned long idx;
+    _BitScanReverse(&idx, a);
+    return 31 ^ idx;
+#endif
 }
 
 /* WARNING: undefined if a = 0 */
 static inline int clz64(uint64_t a)
 {
+#if defined(PLATFORM_GNUC_LIKE)
     return __builtin_clzll(a);
+#else
+    unsigned long idx;
+#  if defined(_WIN64)
+    _BitScanReverse64(&idx, a);
+#  else
+    if (_BitScanReverse(&idx, (uint32_t)(a >> 32)))
+        return 63 ^ (idx + 32);
+    _BitScanReverse(&idx, (uint32_t)(a));
+#  endif
+    return 63 ^ idx;
+#endif
 }
 
 /* WARNING: undefined if a = 0 */
 static inline int ctz32(unsigned int a)
 {
+#if defined(PLATFORM_GNUC_LIKE)
     return __builtin_ctz(a);
+#else
+    unsigned long idx;
+    _BitScanForward(&idx, a);
+    return idx;
+#endif
 }
 
 /* WARNING: undefined if a = 0 */
 static inline int ctz64(uint64_t a)
 {
+#if defined(PLATFORM_GNUC_LIKE)
     return __builtin_ctzll(a);
+#else
+    unsigned long idx;
+#  if defined(_WIN64)
+    _BitScanForward64(&idx, a);
+    return idx;
+#  else
+    if (_BitScanForward(&idx, (uint32_t)(a)))
+        return idx;
+    _BitScanForward(&idx, (uint32_t)(a >> 32));
+    return idx + 32;
+#  endif
+#endif
 }
 
+#if defined(PLATFORM_GNUC_LIKE)
 struct __attribute__((packed)) packed_u64 {
     uint64_t v;
 };
@@ -160,6 +201,21 @@
 struct __attribute__((packed)) packed_u16 {
     uint16_t v;
 };
+#else
+#pragma pack(push, 1)
+struct packed_u64 {
+    uint64_t v;
+};
+
+struct packed_u32 {
+    uint32_t v;
+};
+
+struct packed_u16 {
+    uint16_t v;
+};
+#pragma pack(pop)
+#endif
 
 static inline uint64_t get_u64(const uint8_t *tab)
 {
@@ -282,8 +338,7 @@
 {
     return dbuf_put(s, (uint8_t *)&val, 8);
 }
-int __attribute__((format(printf, 2, 3))) dbuf_printf(DynBuf *s,
-                                                      const char *fmt, ...);
+int PLATFORM_PRINTF_LIKE(2, 3) dbuf_printf(DynBuf *s, const char *fmt, ...);
 void dbuf_free(DynBuf *s);
 static inline BOOL dbuf_error(DynBuf *s) {
     return s->error;
Index: quickjs-src/quickjs/include/quickjspp.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/include/quickjspp.hpp b/quickjs-src/quickjs/include/quickjspp.hpp
new file mode 100644
--- /dev/null	(date 1727612068261)
+++ b/quickjs-src/quickjs/include/quickjspp.hpp	(date 1727612068261)
@@ -0,0 +1,2232 @@
+#pragma once
+
+#include "quickjs/quickjs.h"
+
+#include <vector>
+#include <string_view>
+#include <string>
+#include <cassert>
+#include <memory>
+#include <cstddef>
+#include <algorithm>
+#include <tuple>
+#include <functional>
+#include <stdexcept>
+#include <variant>
+#include <optional>
+#include <type_traits>
+#include <unordered_map>
+#include <fstream>
+#include <ios>
+#include <sstream>
+#include <filesystem>
+
+
+#if defined(__cpp_rtti)
+#define QJSPP_TYPENAME(...) (typeid(__VA_ARGS__).name())
+#else
+#define QJSPP_TYPENAME(...) #__VA_ARGS__
+#endif
+
+
+namespace qjs {
+
+class Context;
+class Value;
+
+/** Exception type.
+ * Indicates that exception has occured in JS context.
+ */
+class exception {
+    JSContext * ctx;
+public:
+    exception(JSContext * ctx) : ctx(ctx) {}
+    Context & context() const;
+
+    /// Clears and returns the occurred exception.
+    Value get();
+};
+
+/** std::shared_ptr, for compatibility with quickjspp v2. */
+template <class T> using shared_ptr = std::shared_ptr<T>;
+/** std::make_shared, for compatibility with quickjspp v2. */
+template <class T, typename... Args>
+shared_ptr<T> make_shared(JSContext *, Args&&... args)
+{
+    return std::make_shared<T>(std::forward<Args>(args)...);
+}
+
+/** Javascript conversion traits.
+ * Describes how to convert type R to/from JSValue. Second template argument can be used for SFINAE/enable_if type filters.
+ */
+template <typename R, typename /*_SFINAE*/ = void>
+struct js_traits
+{
+    /** Create an object of C++ type R given JSValue v and JSContext.
+     * This function is intentionally not implemented. User should implement this function for their own type.
+     * @param v This value is passed as JSValueConst so it should be freed by the caller.
+     * @throws exception in case of conversion error
+     */
+    static R unwrap(JSContext * ctx, JSValueConst v) = delete;
+
+    /** Create JSValue from an object of type R and JSContext.
+     * This function is intentionally not implemented. User should implement this function for their own type.
+     * @return Returns JSValue which should be freed by the caller or JS_EXCEPTION in case of error.
+     */
+    static JSValue wrap(JSContext * ctx, R value) = delete;
+};
+
+/** Conversion traits for JSValue (identity).
+ */
+template <>
+struct js_traits<JSValue>
+{
+    static JSValue unwrap(JSContext * ctx, JSValueConst v) noexcept
+    {
+        return JS_DupValue(ctx, v);
+    }
+
+    static JSValue wrap(JSContext * ctx, JSValue&& v) noexcept
+    {
+        return v;
+    }
+};
+
+/** Conversion traits for integers.
+ * Intentionally doesn't define traits for uint64_t since it can be typedefed to JSValue. (@see JS_NAN_BOXING)
+ */
+template <typename Int>
+struct js_traits<Int, std::enable_if_t<std::is_integral_v<Int> && sizeof(Int) <= sizeof(int64_t) && !std::is_same_v<Int, uint64_t>>>
+{
+    /// @throws exception
+    static Int unwrap(JSContext * ctx, JSValueConst v)
+    {
+        if constexpr (sizeof(Int) > sizeof(int32_t))
+        {
+            int64_t r;
+            if(JS_ToInt64(ctx, &r, v))
+                throw exception{ctx};
+            return static_cast<Int>(r);
+        }
+        else
+        {
+            int32_t r;
+            if(JS_ToInt32(ctx, &r, v))
+                throw exception{ctx};
+            return static_cast<Int>(r);
+        }
+    }
+
+    static JSValue wrap(JSContext * ctx, Int i) noexcept
+    {
+        if constexpr (std::is_same_v<Int, uint32_t> || sizeof(Int) > sizeof(int32_t))
+            return JS_NewInt64(ctx, static_cast<Int>(i));
+        else
+            return JS_NewInt32(ctx, static_cast<Int>(i));
+    }
+};
+
+/** Conversion traits for boolean.
+ */
+template <>
+struct js_traits<bool>
+{
+    static bool unwrap(JSContext * ctx, JSValueConst v) noexcept
+    {
+        // TODO: is this behaviour correct?
+        return JS_ToBool(ctx, v) > 0;
+    }
+
+    static JSValue wrap(JSContext * ctx, bool i) noexcept
+    {
+        return JS_NewBool(ctx, i);
+    }
+};
+
+/** Conversion trait for void.
+ */
+template <>
+struct js_traits<void>
+{
+    /// @throws exception if jsvalue is neither undefined nor null
+    static void unwrap(JSContext * ctx, JSValueConst value)
+    {
+        if(JS_IsException(value))
+            throw exception{ctx};
+    }
+};
+
+/** Conversion traits for float64/double.
+ */
+template <>
+struct js_traits<double>
+{
+    /// @throws exception
+    static double unwrap(JSContext * ctx, JSValueConst v)
+    {
+        double r;
+        if(JS_ToFloat64(ctx, &r, v))
+            throw exception{ctx};
+        return r;
+    }
+
+    static JSValue wrap(JSContext * ctx, double i) noexcept
+    {
+        return JS_NewFloat64(ctx, i);
+    }
+};
+
+namespace detail {
+/** Fake std::string_view which frees the string on destruction.
+*/
+class js_string : public std::string_view
+{
+    using Base = std::string_view;
+    JSContext * ctx = nullptr;
+
+    friend struct js_traits<std::string_view>;
+
+    js_string(JSContext * ctx, const char * ptr, std::size_t len) : Base(ptr, len), ctx(ctx) {}
+
+public:
+
+    template <typename... Args>
+    js_string(Args&& ... args) : Base(std::forward<Args>(args)...), ctx(nullptr) {}
+
+    js_string(const js_string& other) = delete;
+
+    operator const char *() const
+    {
+        return this->data();
+    }
+
+    ~js_string()
+    {
+        if(ctx)
+            JS_FreeCString(ctx, this->data());
+    }
+};
+} // namespace detail
+
+/** Conversion traits from std::string_view and to detail::js_string. */
+template <>
+struct js_traits<std::string_view>
+{
+    static detail::js_string unwrap(JSContext * ctx, JSValueConst v)
+    {
+        size_t plen;
+        const char * ptr = JS_ToCStringLen(ctx, &plen, v);
+        if(!ptr)
+            throw exception{ctx};
+        return detail::js_string{ctx, ptr, plen};
+    }
+
+    static JSValue wrap(JSContext * ctx, std::string_view str) noexcept
+    {
+        return JS_NewStringLen(ctx, str.data(), str.size());
+    }
+};
+
+/** Conversion traits for std::string */
+template <> // slower
+struct js_traits<std::string>
+{
+    static std::string unwrap(JSContext * ctx, JSValueConst v)
+    {
+        auto str_view = js_traits<std::string_view>::unwrap(ctx, v);
+        return std::string{str_view.data(), str_view.size()};
+    }
+
+    static JSValue wrap(JSContext * ctx, const std::string& str) noexcept
+    {
+        return JS_NewStringLen(ctx, str.data(), str.size());
+    }
+};
+
+/** Conversion from const char * */
+template <>
+struct js_traits<const char *>
+{
+    static JSValue wrap(JSContext * ctx, const char * str) noexcept
+    {
+        return JS_NewString(ctx, str);
+    }
+
+    static detail::js_string unwrap(JSContext * ctx, JSValueConst v)
+    {
+        return js_traits<std::string_view>::unwrap(ctx, v);
+    }
+};
+
+
+/** Conversion from const std::variant */
+template <typename ... Ts>
+struct js_traits<std::variant<Ts...>>
+{
+    static JSValue wrap(JSContext * ctx, std::variant<Ts...> value) noexcept
+    {
+        return std::visit([ctx](auto&& value) {
+            using T = std::decay_t<decltype(value)>;
+            return js_traits<T>::wrap(ctx, value);
+        }, std::move(value));
+    }
+
+
+    /* Useful type traits */
+    template <typename T> struct is_shared_ptr : std::false_type {};
+    template <typename T> struct is_shared_ptr<std::shared_ptr<T>> : std::true_type {};
+    template <typename T> struct is_string
+    {
+        static constexpr bool value = std::is_same_v<T, const char *> || std::is_same_v<std::decay_t<T>, std::string> ||
+                                      std::is_same_v<std::decay_t<T>, std::string_view>;
+    };
+    template <typename T> struct is_boolean { static constexpr bool value = std::is_same_v<std::decay_t<T>, bool>; };
+    template <typename T> struct is_double { static constexpr bool value = std::is_same_v<std::decay_t<T>, double>; };
+    template <typename T> struct is_vector : std::false_type {};
+    template <typename T> struct is_vector<std::vector<T>> : std::true_type {};
+    template <typename T> struct is_pair : std::false_type {};
+    template <typename U, typename V> struct is_pair<std::pair<U, V>> : std::true_type {};
+    template <typename T> struct is_variant : std::false_type {};
+    template <typename ... Us> struct is_variant<std::variant<Us...>> : std::true_type {};
+
+    /** Attempt to match common types (integral, floating-point, string, etc.) */
+    template <template <typename R> typename Trait, typename U, typename ... Us>
+    static std::optional<std::variant<Ts...>> unwrapImpl(JSContext * ctx, JSValueConst v)
+    {
+        if constexpr (Trait<U>::value)
+        {
+            return js_traits<U>::unwrap(ctx, v);
+        }
+        if constexpr ((sizeof ... (Us)) > 0)
+        {
+            return unwrapImpl<Trait, Us...>(ctx, v);
+        }
+        return std::nullopt;
+    }
+
+    /** Attempt to match class ID with type */
+    template <typename U, typename ... Us>
+    static std::optional<std::variant<Ts...>> unwrapObj(JSContext * ctx, JSValueConst v, JSClassID class_id)
+    {
+        if constexpr (is_shared_ptr<U>::value)
+        {
+            if(class_id == js_traits<U>::QJSClassId)
+            {
+                return js_traits<U>::unwrap(ctx, v);
+            }
+        }
+
+        // try to unwrap embedded variant (variant<variant<...>>), might be slow
+        if constexpr (is_variant<U>::value)
+        {
+            if(auto opt = js_traits<std::optional<U>>::unwrap(ctx, v))
+                return *opt;
+        }
+
+        if constexpr (is_vector<U>::value)
+        {
+            if(JS_IsArray(ctx, v) == 1)
+            {
+                auto firstElement = JS_GetPropertyUint32(ctx, v, 0);
+                bool ok = isCompatible<std::decay_t<typename U::value_type>>(ctx, firstElement);
+                JS_FreeValue(ctx, firstElement);
+                if(ok)
+                {
+                    return U{js_traits<U>::unwrap(ctx, v)};
+                }
+            }
+        }
+
+        if constexpr (is_pair<U>::value)
+        {
+            if(JS_IsArray(ctx, v) == 1)
+            {
+                // todo: check length?
+                auto firstElement = JS_GetPropertyUint32(ctx, v, 0);
+                auto secondElement = JS_GetPropertyUint32(ctx, v, 1);
+                bool ok = isCompatible<std::decay_t<typename U::first_type>>(ctx, firstElement)
+                          && isCompatible<std::decay_t<typename U::second_type>>(ctx, secondElement);
+                JS_FreeValue(ctx, firstElement);
+                JS_FreeValue(ctx, secondElement);
+                if(ok)
+                {
+                    return U{js_traits<U>::unwrap(ctx, v)};
+                }
+            }
+        }
+
+        if constexpr ((sizeof ... (Us)) > 0)
+        {
+            return unwrapObj<Us...>(ctx, v, class_id);
+        }
+        return std::nullopt;
+    }
+
+    /** Attempt to cast to types satisfying traits, ordered in terms of priority */
+    template <template <typename T> typename Trait, template <typename T> typename ... Traits>
+    static std::variant<Ts...> unwrapPriority(JSContext * ctx, JSValueConst v)
+    {
+        if(auto result = unwrapImpl<Trait, Ts...>(ctx, v))
+        {
+            return *result;
+        }
+        if constexpr ((sizeof ... (Traits)) > 0)
+        {
+            return unwrapPriority<Traits...>(ctx, v);
+        }
+        JS_ThrowTypeError(ctx, "Expected type %s", QJSPP_TYPENAME(std::variant<Ts...>));
+        throw exception{ctx};
+    }
+
+    template <typename T>
+    static bool isCompatible(JSContext * ctx, JSValueConst v) noexcept
+    {
+        //const char * type_name = typeid(T).name();
+        switch(JS_VALUE_GET_TAG(v))
+        {
+            case JS_TAG_STRING:
+                return is_string<T>::value;
+
+            case JS_TAG_FUNCTION_BYTECODE:
+                return std::is_function<T>::value;
+            case JS_TAG_OBJECT:
+                if(JS_IsArray(ctx, v) == 1)
+                    return is_vector<T>::value || is_pair<T>::value;
+                if constexpr (is_shared_ptr<T>::value)
+                {
+                    if(JS_GetClassID(v) == js_traits<T>::QJSClassId)
+                        return true;
+                }
+                return false;
+
+            case JS_TAG_INT:
+                [[fallthrough]];
+            case JS_TAG_BIG_INT:
+                return std::is_integral_v<T> || std::is_floating_point_v<T>;
+            case JS_TAG_BOOL:
+                return is_boolean<T>::value || std::is_integral_v<T> || std::is_floating_point_v<T>;
+
+            case JS_TAG_BIG_DECIMAL:
+                [[fallthrough]];
+            case JS_TAG_BIG_FLOAT:
+                [[fallthrough]];
+            case JS_TAG_FLOAT64:
+            default: // >JS_TAG_FLOAT64 (JS_NAN_BOXING)
+                return is_double<T>::value || std::is_floating_point_v<T>;
+
+            case JS_TAG_SYMBOL:
+                [[fallthrough]];
+            case JS_TAG_MODULE:
+                [[fallthrough]];
+            case JS_TAG_NULL:
+                [[fallthrough]];
+            case JS_TAG_UNDEFINED:
+                [[fallthrough]];
+            case JS_TAG_UNINITIALIZED:
+                [[fallthrough]];
+            case JS_TAG_CATCH_OFFSET:
+                [[fallthrough]];
+            case JS_TAG_EXCEPTION:
+                break;
+        }
+        return false;
+    }
+
+    static std::variant<Ts...> unwrap(JSContext * ctx, JSValueConst v)
+    {
+        const auto tag = JS_VALUE_GET_TAG(v);
+        switch(tag)
+        {
+            case JS_TAG_STRING:
+                return unwrapPriority<is_string>(ctx, v);
+
+            case JS_TAG_FUNCTION_BYTECODE:
+                return unwrapPriority<std::is_function>(ctx, v);
+            case JS_TAG_OBJECT:
+                if(auto result = unwrapObj<Ts...>(ctx, v, JS_GetClassID(v)))
+                {
+                    return *result;
+                }
+                JS_ThrowTypeError(ctx, "Expected type %s, got object with classid %d",
+                                  QJSPP_TYPENAME(std::variant<Ts...>), JS_GetClassID(v));
+                break;
+
+            case JS_TAG_INT:
+                [[fallthrough]];
+            case JS_TAG_BIG_INT:
+                return unwrapPriority<std::is_integral, std::is_floating_point>(ctx, v);
+            case JS_TAG_BOOL:
+                return unwrapPriority<is_boolean, std::is_integral, std::is_floating_point>(ctx, v);
+
+            case JS_TAG_SYMBOL:
+                [[fallthrough]];
+            case JS_TAG_MODULE:
+                [[fallthrough]];
+            case JS_TAG_NULL:
+                [[fallthrough]];
+            case JS_TAG_UNDEFINED:
+                [[fallthrough]];
+            case JS_TAG_UNINITIALIZED:
+                [[fallthrough]];
+            case JS_TAG_CATCH_OFFSET:
+                JS_ThrowTypeError(ctx, "Expected type %s, got tag %d", QJSPP_TYPENAME(std::variant<Ts...>), tag);
+                [[fallthrough]];
+            case JS_TAG_EXCEPTION:
+                break;
+
+            case JS_TAG_BIG_DECIMAL:
+                [[fallthrough]];
+            case JS_TAG_BIG_FLOAT:
+                [[fallthrough]];
+
+            case JS_TAG_FLOAT64:
+                [[fallthrough]];
+            default: // more than JS_TAG_FLOAT64 (nan boxing)
+                return unwrapPriority<is_double, std::is_floating_point>(ctx, v);
+        }
+
+        throw exception{ctx};
+    }
+};
+
+template <typename T>
+struct rest : std::vector<T>
+{
+    using std::vector<T>::vector;
+    using std::vector<T>::operator=;
+};
+
+namespace detail {
+
+/** Helper function to convert and then free JSValue. */
+template <typename T>
+T unwrap_free(JSContext * ctx, JSValue val)
+{
+    if constexpr(std::is_same_v<T, void>)
+    {
+        JS_FreeValue(ctx, val);
+        return js_traits<T>::unwrap(ctx, val);
+    }
+    else
+    {
+        try
+        {
+            T result = js_traits<std::decay_t<T>>::unwrap(ctx, val);
+            JS_FreeValue(ctx, val);
+            return result;
+        }
+        catch(...)
+        {
+            JS_FreeValue(ctx, val);
+            throw;
+        }
+    }
+}
+
+template <typename T, size_t I, size_t NArgs>
+struct unwrap_arg_impl {
+    static auto unwrap(JSContext * ctx, int argc, JSValueConst * argv)
+    {
+        if (size_t(argc) <= I) {
+            JS_ThrowTypeError(ctx, "Expected at least %lu arguments but received %d",
+                              (unsigned long)NArgs, argc);
+            throw exception{ctx};
+        }
+        return js_traits<std::decay_t<T>>::unwrap(ctx, argv[I]);
+    }
+};
+
+template <typename T, size_t I, size_t NArgs>
+struct unwrap_arg_impl<rest<T>, I, NArgs> {
+    static rest<T> unwrap(JSContext * ctx, int argc, JSValueConst * argv) {
+        static_assert(I == NArgs - 1, "The `rest` argument must be the last function argument.");
+        rest<T> result;
+        result.reserve(argc - I);
+        for (size_t i = I; i < size_t(argc); ++i)
+            result.push_back(js_traits<T>::unwrap(ctx, argv[i]));
+        return result;
+    }
+};
+
+template <class Tuple, std::size_t... I>
+Tuple unwrap_args_impl(JSContext * ctx, int argc, JSValueConst * argv, std::index_sequence<I...>)
+{
+    return Tuple{unwrap_arg_impl<std::tuple_element_t<I, Tuple>, I, sizeof...(I)>::unwrap(ctx, argc, argv)...};
+}
+
+/** Helper function to convert an array of JSValues to a tuple.
+ * @tparam Args C++ types of the argv array
+ */
+template <typename... Args>
+std::tuple<std::decay_t<Args>...> unwrap_args(JSContext * ctx, int argc, JSValueConst * argv)
+{
+    return unwrap_args_impl<std::tuple<std::decay_t<Args>...>>(ctx, argc, argv, std::make_index_sequence<sizeof...(Args)>());
+}
+
+/** Helper function to call f with an array of JSValues.
+ * @tparam R return type of f
+ * @tparam Args argument types of f
+ * @tparam Callable type of f (inferred)
+ * @param ctx JSContext
+ * @param f callable object
+ * @param argv array of JSValue's
+ * @return converted return value of f or JS_NULL if f returns void
+ */
+template <typename R, typename... Args, typename Callable>
+JSValue wrap_call(JSContext * ctx, Callable&& f, int argc, JSValueConst * argv) noexcept
+{
+    try
+    {
+        if constexpr(std::is_same_v<R, void>)
+        {
+            std::apply(std::forward<Callable>(f), unwrap_args<Args...>(ctx, argc, argv));
+            return JS_NULL;
+        }
+        else
+        {
+            return js_traits<std::decay_t<R>>::wrap(ctx,
+                                                    std::apply(std::forward<Callable>(f),
+                                                               unwrap_args<Args...>(ctx, argc, argv)));
+        }
+    }
+    catch(exception)
+    {
+        return JS_EXCEPTION;
+    }
+    catch (std::exception const & err)
+    {
+        JS_ThrowInternalError(ctx, "%s", err.what());
+        return JS_EXCEPTION;
+    }
+    catch (...)
+    {
+        JS_ThrowInternalError(ctx, "Unknown error");
+        return JS_EXCEPTION;
+    }
+}
+
+/** Same as wrap_call, but pass this_value as first argument.
+ * @tparam FirstArg type of this_value
+ */
+template <typename R, typename FirstArg, typename... Args, typename Callable>
+JSValue wrap_this_call(JSContext * ctx, Callable&& f, JSValueConst this_value, int argc, JSValueConst * argv) noexcept
+{
+    try
+    {
+        if constexpr(std::is_same_v<R, void>)
+        {
+            std::apply(std::forward<Callable>(f), std::tuple_cat(unwrap_args<FirstArg>(ctx, 1, &this_value),
+                                                                 unwrap_args<Args...>(ctx, argc, argv)));
+            return JS_NULL;
+        }
+        else
+        {
+            return js_traits<std::decay_t<R>>::wrap(ctx,
+                                                    std::apply(std::forward<Callable>(f),
+                                                               std::tuple_cat(
+                                                                       unwrap_args<FirstArg>(ctx, 1, &this_value),
+                                                                       unwrap_args<Args...>(ctx, argc, argv))));
+        }
+    }
+    catch(exception)
+    {
+        return JS_EXCEPTION;
+    }
+    catch (std::exception const & err)
+    {
+        JS_ThrowInternalError(ctx, "%s", err.what());
+        return JS_EXCEPTION;
+    }
+    catch (...)
+    {
+        JS_ThrowInternalError(ctx, "Unknown error");
+        return JS_EXCEPTION;
+    }
+}
+
+template <class Tuple, std::size_t... I>
+void wrap_args_impl(JSContext * ctx, JSValue * argv, Tuple tuple, std::index_sequence<I...>)
+{
+    ((argv[I] = js_traits<std::decay_t<std::tuple_element_t<I, Tuple>>>::wrap(ctx, std::get<I>(tuple))), ...);
+}
+
+/** Converts C++ args to JSValue array.
+ * @tparam Args argument types
+ * @param argv array of size at least sizeof...(Args)
+ */
+template <typename... Args>
+void wrap_args(JSContext * ctx, JSValue * argv, Args&& ... args)
+{
+    wrap_args_impl(ctx, argv, std::make_tuple(std::forward<Args>(args)...),
+                   std::make_index_sequence<sizeof...(Args)>());
+}
+
+// Helper trait to obtain `T` in `T::*` expressions
+template<typename T> struct class_from_member_pointer { using type = void; };
+template<typename T, typename U> struct class_from_member_pointer<T U::*> { using type = U; };
+template<typename T> using class_from_member_pointer_t = typename class_from_member_pointer<T>::type;
+
+} // namespace detail
+
+/** A wrapper type for free and class member functions.
+ * Pointer to function F is a template argument.
+ * @tparam F either a pointer to free function or a pointer to class member function
+ * @tparam PassThis if true and F is a pointer to free function, passes Javascript "this" value as first argument:
+ */
+template <auto F, bool PassThis = false /* pass this as the first argument */>
+struct fwrapper
+{
+    /// "name" property of the JS function object (not defined if nullptr)
+    const char * name = nullptr;
+};
+
+/** Conversion to JSValue for free function in fwrapper. */
+template <typename R, typename... Args, R (* F)(Args...), bool PassThis>
+struct js_traits<fwrapper<F, PassThis>>
+{
+    static JSValue wrap(JSContext * ctx, fwrapper<F, PassThis> fw) noexcept
+    {
+        return JS_NewCFunction(ctx, [](JSContext * ctx, JSValueConst this_value, int argc,
+                                       JSValueConst * argv) noexcept -> JSValue {
+            if constexpr(PassThis)
+                return detail::wrap_this_call<R, Args...>(ctx, F, this_value, argc, argv);
+            else
+                return detail::wrap_call<R, Args...>(ctx, F, argc, argv);
+        }, fw.name, sizeof...(Args));
+
+    }
+};
+
+/** Conversion to JSValue for class member function in fwrapper. PassThis is ignored and treated as true */
+template <typename R, class T, typename... Args, R (T::*F)(Args...), bool PassThis/*=ignored*/>
+struct js_traits<fwrapper<F, PassThis>>
+{
+    static JSValue wrap(JSContext * ctx, fwrapper<F, PassThis> fw) noexcept
+    {
+        return JS_NewCFunction(ctx, [](JSContext * ctx, JSValueConst this_value, int argc,
+                                       JSValueConst * argv) noexcept -> JSValue {
+            return detail::wrap_this_call<R, std::shared_ptr<T>, Args...>(ctx, F, this_value, argc, argv);
+        }, fw.name, sizeof...(Args));
+
+    }
+};
+
+/** Conversion to JSValue for const class member function in fwrapper. PassThis is ignored and treated as true */
+template <typename R, class T, typename... Args, R (T::*F)(Args...) const, bool PassThis/*=ignored*/>
+struct js_traits<fwrapper<F, PassThis>>
+{
+    static JSValue wrap(JSContext * ctx, fwrapper<F, PassThis> fw) noexcept
+    {
+        return JS_NewCFunction(ctx, [](JSContext * ctx, JSValueConst this_value, int argc,
+                                       JSValueConst * argv) noexcept -> JSValue {
+            return detail::wrap_this_call<R, std::shared_ptr<T>, Args...>(ctx, F, this_value, argc, argv);
+        }, fw.name, sizeof...(Args));
+
+    }
+};
+
+/** A wrapper type for constructor of type T with arguments Args.
+ * Compilation fails if no such constructor is defined.
+ * @tparam Args constructor arguments
+ */
+template <class T, typename... Args>
+struct ctor_wrapper
+{
+    static_assert(std::is_constructible<T, Args...>::value, "no such constructor!");
+    /// "name" property of JS constructor object
+    const char * name = nullptr;
+};
+
+namespace detail {
+/// equivalent to JS_GetPropertyStr(ctx, this_value, "prototype");
+inline JSValue GetPropertyPrototype(JSContext * ctx, JSValueConst this_value)
+{
+    // constant atom: doesn't need to be freed and doesn't change with context
+    static const JSAtom JS_ATOM_prototype = JS_NewAtom(ctx, "prototype");
+    return JS_GetProperty(ctx, this_value, JS_ATOM_prototype);
+}
+} // namespace detail
+
+/** Conversion to JSValue for ctor_wrapper. */
+template <class T, typename... Args>
+struct js_traits<ctor_wrapper<T, Args...>>
+{
+    static JSValue wrap(JSContext * ctx, ctor_wrapper<T, Args...> cw) noexcept
+    {
+        return JS_NewCFunction2(ctx, [](JSContext * ctx, JSValueConst this_value, int argc,
+                                        JSValueConst * argv) noexcept -> JSValue {
+
+            if(js_traits<std::shared_ptr<T>>::QJSClassId == 0) // not registered
+            {
+#if defined(__cpp_rtti)
+                // automatically register class on first use (no prototype)
+                js_traits<std::shared_ptr<T>>::register_class(ctx, typeid(T).name());
+#else
+                JS_ThrowTypeError(ctx, "quickjspp ctor_wrapper<T>::wrap: Class is not registered");
+                return JS_EXCEPTION;
+#endif
+            }
+
+            auto proto = detail::GetPropertyPrototype(ctx, this_value);
+            if(JS_IsException(proto))
+                return proto;
+            auto jsobj = JS_NewObjectProtoClass(ctx, proto, js_traits<std::shared_ptr<T>>::QJSClassId);
+            JS_FreeValue(ctx, proto);
+            if(JS_IsException(jsobj))
+                return jsobj;
+
+            try
+            {
+                std::shared_ptr<T> ptr = std::apply(std::make_shared<T, Args...>, detail::unwrap_args<Args...>(ctx, argc, argv));
+                JS_SetOpaque(jsobj, new std::shared_ptr<T>(std::move(ptr)));
+                return jsobj;
+            }
+            catch (exception)
+            {
+                JS_FreeValue(ctx, jsobj);
+                return JS_EXCEPTION;
+            }
+            catch (std::exception const & err)
+            {
+                JS_FreeValue(ctx, jsobj);
+                JS_ThrowInternalError(ctx, "%s", err.what());
+                return JS_EXCEPTION;
+            }
+            catch (...)
+            {
+                JS_FreeValue(ctx, jsobj);
+                JS_ThrowInternalError(ctx, "Unknown error");
+                return JS_EXCEPTION;
+            }
+
+            // return detail::wrap_call<std::shared_ptr<T>, Args...>(ctx, std::make_shared<T, Args...>, argv);
+        }, cw.name, sizeof...(Args), JS_CFUNC_constructor, 0);
+    }
+};
+
+
+/** Conversions for std::shared_ptr<T>. Empty shared_ptr corresponds to JS_NULL.
+ * T should be registered to a context before conversions.
+ * @tparam T class type
+ */
+template <class T>
+struct js_traits<std::shared_ptr<T>>
+{
+    /// Registered class id in QuickJS.
+    inline static JSClassID QJSClassId = 0;
+
+    /// Signature of the function to obtain the std::shared_ptr from the JSValue.
+    using ptr_cast_fcn_t = std::function<std::shared_ptr<T>(JSContext*, JSValueConst)>;
+
+    /// Used by registerDerivedClass to register new derived classes with this class' base type.
+    inline static std::function<void(JSClassID, ptr_cast_fcn_t)> registerWithBase;
+
+    /// Mapping between derived class' JSClassID and function to obtain the std::shared_ptr from the JSValue.
+    inline static std::unordered_map<JSClassID, ptr_cast_fcn_t> ptrCastFcnMap;
+
+    /** Register a class as a derived class.
+     *
+     * @tparam D type of the derived class
+     * @param derived_class_id class id of the derived class
+     * @param ptr_cast_fcn function to obtain a std::shared_ptr from the JSValue
+     */
+    template<typename D>
+    static void registerDerivedClass(JSClassID derived_class_id, ptr_cast_fcn_t ptr_cast_fcn) {
+        static_assert(std::is_base_of<T,D>::value && !std::is_same<T,D>::value, "Type is not a derived class");
+        using derived_ptr_cast_fcn_t = typename js_traits<std::shared_ptr<D>>::ptr_cast_fcn_t;
+
+        // Register how to obtain the std::shared_ptr from the derived class.
+        ptrCastFcnMap[derived_class_id] = ptr_cast_fcn;
+
+        // Propagate the registration to our base class (if any).
+        if (registerWithBase) registerWithBase(derived_class_id, ptr_cast_fcn);
+
+        // Instrument the derived class so that it can propagate new derived classes to us.
+        auto old_registerWithBase = js_traits<std::shared_ptr<D>>::registerWithBase;
+        js_traits<std::shared_ptr<D>>::registerWithBase =
+            [old_registerWithBase = std::move(old_registerWithBase)]
+            (JSClassID derived_class_id, derived_ptr_cast_fcn_t derived_ptr_cast_fcn){
+                if (old_registerWithBase) old_registerWithBase(derived_class_id, derived_ptr_cast_fcn);
+                registerDerivedClass<D>(derived_class_id, [derived_cast_fcn = std::move(derived_ptr_cast_fcn)](JSContext * ctx, JSValueConst v) {
+                    return std::shared_ptr<T>(derived_cast_fcn(ctx, v));
+                });
+            };
+    }
+
+    template <typename B>
+    static
+    std::enable_if_t<std::is_same_v<B, T> || std::is_same_v<B, void>>
+    ensureCanCastToBase() { }
+
+    template <typename B>
+    static
+    std::enable_if_t<!std::is_same_v<B, T> && !std::is_same_v<B, void>>
+    ensureCanCastToBase() {
+        static_assert(std::is_base_of_v<B, T>, "Type is not a derived class");
+
+        if(js_traits<std::shared_ptr<T>>::QJSClassId == 0)
+            JS_NewClassID(&js_traits<std::shared_ptr<T>>::QJSClassId);
+
+        js_traits<std::shared_ptr<B>>::template registerDerivedClass<T>(QJSClassId, unwrap);
+    }
+
+    template <auto M>
+    static void ensureCanCastToBase() {
+        ensureCanCastToBase<detail::class_from_member_pointer_t<decltype(M)>>();
+    }
+
+    /** Stores offsets to qjs::Value members of T.
+     * These values should be marked by class_registrar::mark for QuickJS garbage collector
+     * so that the cycle removal algorithm can find the other objects referenced by this object.
+     */
+    static inline std::vector<Value T::*> markOffsets;
+
+    /** Register class in QuickJS context.
+     *
+     * @param ctx context
+     * @param name class name
+     * @param proto class prototype or JS_NULL
+     * @param call QJS call function. see quickjs doc
+     * @param exotic pointer to QJS exotic methods(static lifetime) which allow custom property handling. see quickjs doc
+     * @throws exception
+     */
+    static void register_class(JSContext * ctx, const char * name, JSValue proto = JS_NULL,
+                               JSClassCall * call = nullptr, JSClassExoticMethods * exotic = nullptr)
+    {
+        if(QJSClassId == 0)
+        {
+            JS_NewClassID(&QJSClassId);
+        }
+        auto rt = JS_GetRuntime(ctx);
+        if(!JS_IsRegisteredClass(rt, QJSClassId))
+        {
+            JSClassGCMark * marker = nullptr;
+            if(!markOffsets.empty())
+            {
+                marker = [](JSRuntime *rt, JSValueConst val, JS_MarkFunc *mark_func) {
+                    auto pptr = static_cast<std::shared_ptr<T> *>(JS_GetOpaque(val, QJSClassId));
+                    assert(pptr);
+                    const T * ptr = pptr->get();
+                    assert(ptr);
+                    for(Value T::* member : markOffsets)
+                    {
+                        JS_MarkValue(rt, (*ptr.*member).v, mark_func);
+                    }
+                };
+            }
+            JSClassDef def{
+                    name,
+                    // destructor (finalizer)
+                    [](JSRuntime * rt, JSValue obj) noexcept {
+                        auto pptr = static_cast<std::shared_ptr<T> *>(JS_GetOpaque(obj, QJSClassId));
+                        delete pptr;
+                    },
+                    // mark
+                    marker,
+                    // call
+                    call,
+                    // exotic
+                    exotic
+            };
+            int e = JS_NewClass(rt, QJSClassId, &def);
+            if(e < 0)
+            {
+                JS_ThrowInternalError(ctx, "Can't register class %s", name);
+                throw exception{ctx};
+            }
+        }
+        JS_SetClassProto(ctx, QJSClassId, proto);
+    }
+
+    /** Create a JSValue from std::shared_ptr<T>.
+     * Creates an object with class if #QJSClassId and sets its opaque pointer to a new copy of #ptr.
+     */
+    static JSValue wrap(JSContext * ctx, std::shared_ptr<T> ptr)
+    {
+        if(!ptr)
+            return JS_NULL;
+        if(QJSClassId == 0) // not registered
+        {
+#if defined(__cpp_rtti)
+            // automatically register class on first use (no prototype)
+            register_class(ctx, typeid(T).name());
+#else
+            JS_ThrowTypeError(ctx, "quickjspp std::shared_ptr<T>::wrap: Class is not registered");
+            return JS_EXCEPTION;
+#endif
+        }
+        auto jsobj = JS_NewObjectClass(ctx, QJSClassId);
+        if(JS_IsException(jsobj))
+            return jsobj;
+
+        auto pptr = new std::shared_ptr<T>(std::move(ptr));
+        JS_SetOpaque(jsobj, pptr);
+        return jsobj;
+    }
+
+    /// @throws exception if #v doesn't have the correct class id
+    static std::shared_ptr<T> unwrap(JSContext * ctx, JSValueConst v)
+    {
+        std::shared_ptr<T> ptr = nullptr;
+        if (JS_IsNull(v)) {
+            return ptr;
+        }
+        auto obj_class_id = JS_GetClassID(v);
+
+        if (obj_class_id == QJSClassId) {
+            // The JS object is of class T
+            void * opaque = JS_GetOpaque2(ctx, v, obj_class_id);
+            assert(opaque && "No opaque pointer in object");
+            ptr = *static_cast<std::shared_ptr<T> *>(opaque);
+        } else if (ptrCastFcnMap.count(obj_class_id)) {
+            // The JS object is of a class derived from T
+            ptr = ptrCastFcnMap[obj_class_id](ctx, v);
+        } else {
+            // The JS object does not derives from T
+            JS_ThrowTypeError(ctx, "Expected type %s, got object with classid %d",
+                              QJSPP_TYPENAME(T), obj_class_id);
+            throw exception{ctx};
+        }
+        if(!ptr) {
+            JS_ThrowInternalError(ctx, "Object's opaque pointer is NULL");
+            throw exception{ctx};
+        }
+        return ptr;
+    }
+};
+
+/** Conversions for non-owning pointers to class T. nullptr corresponds to JS_NULL.
+ * @tparam T class type
+ */
+template <class T>
+struct js_traits<T *, std::enable_if_t<std::is_class_v<T>>>
+{
+    static JSValue wrap(JSContext * ctx, T * ptr)
+    {
+        if (ptr == nullptr) {
+            return JS_NULL;
+        }
+        if(js_traits<std::shared_ptr<T>>::QJSClassId == 0) // not registered
+        {
+#if defined(__cpp_rtti)
+            // If you have an error here with T=JSValueConst
+            // it probably means you are passing JSValueConst to where JSValue is expected
+            js_traits<std::shared_ptr<T>>::register_class(ctx, typeid(T).name());
+#else
+            JS_ThrowTypeError(ctx, "quickjspp js_traits<T *>::wrap: Class is not registered");
+            return JS_EXCEPTION;
+#endif
+        }
+        auto jsobj = JS_NewObjectClass(ctx, js_traits<std::shared_ptr<T>>::QJSClassId);
+        if(JS_IsException(jsobj))
+            return jsobj;
+
+        // shared_ptr with empty deleter since we don't own T*
+        auto pptr = new std::shared_ptr<T>(ptr, [](T *) {});
+        JS_SetOpaque(jsobj, pptr);
+        return jsobj;
+    }
+
+    static T * unwrap(JSContext * ctx, JSValueConst v)
+    {
+        if (JS_IsNull(v)) {
+            return nullptr;
+        }
+        auto ptr = js_traits<std::shared_ptr<T>>::unwrap(ctx, v);
+        return ptr.get();
+    }
+};
+
+/** Conversions for enums. */
+template <typename E>
+struct js_traits<E, std::enable_if_t<std::is_enum_v<E>>> {
+    using T = std::underlying_type_t<E>;
+    static E unwrap(JSContext* ctx, JSValue v) noexcept {
+        return static_cast<E>(js_traits<T>::unwrap(ctx, v));
+    }
+
+    static JSValue wrap(JSContext* ctx, E t) noexcept {
+        return js_traits<T>::wrap(ctx, static_cast<T>(t));;
+    }
+};
+
+namespace detail {
+/** A faster std::function-like object with type erasure.
+ * Used to convert any callable objects (including lambdas) to JSValue.
+ */
+struct function
+{
+    JSValue
+    (* invoker)(function * self, JSContext * ctx, JSValueConst this_value, int argc, JSValueConst * argv) = nullptr;
+
+    void (* destroyer)(function * self) = nullptr;
+
+    alignas(std::max_align_t) char functor[];
+
+    template <typename Functor>
+    static function * create(JSRuntime * rt, Functor&& f)
+    {
+        using Functor_t = std::decay_t<Functor>;
+        auto fptr = static_cast<function *>(js_malloc_rt(rt, sizeof(function) + sizeof(Functor_t)));
+        if(!fptr)
+            throw std::bad_alloc{};
+        new(fptr) function;
+        auto functorptr = reinterpret_cast<Functor_t *>(fptr->functor);
+        new(functorptr) Functor_t(std::forward<Functor>(f));
+        fptr->destroyer = nullptr;
+        if constexpr(!std::is_trivially_destructible_v<Functor_t>)
+        {
+            fptr->destroyer = [](function * fptr) {
+                auto functorptr = reinterpret_cast<Functor_t *>(fptr->functor);
+                functorptr->~Functor_t();
+            };
+        }
+        return fptr;
+    }
+};
+
+static_assert(std::is_trivially_destructible_v<function>);
+}
+
+template <>
+struct js_traits<detail::function>
+{
+    inline static JSClassID QJSClassId = 0;
+
+    // TODO: replace ctx with rt
+    static void register_class(JSContext * ctx, const char * name)
+    {
+        if(QJSClassId == 0)
+        {
+            JS_NewClassID(&QJSClassId);
+        }
+        auto rt = JS_GetRuntime(ctx);
+        if(JS_IsRegisteredClass(rt, QJSClassId))
+            return;
+        JSClassDef def{
+                name,
+                // destructor
+                [](JSRuntime * rt, JSValue obj) noexcept {
+                    auto fptr = static_cast<detail::function *>(JS_GetOpaque(obj, QJSClassId));
+                    assert(fptr);
+                    if(fptr->destroyer)
+                        fptr->destroyer(fptr);
+                    js_free_rt(rt, fptr);
+                },
+                nullptr, // mark
+                // call
+                [](JSContext * ctx, JSValueConst func_obj, JSValueConst this_val, int argc,
+                   JSValueConst * argv, int flags) -> JSValue {
+                    auto ptr = static_cast<detail::function *>(JS_GetOpaque2(ctx, func_obj, QJSClassId));
+                    if(!ptr)
+                        return JS_EXCEPTION;
+                    return ptr->invoker(ptr, ctx, this_val, argc, argv);
+                },
+                nullptr
+        };
+        int e = JS_NewClass(rt, QJSClassId, &def);
+        if(e < 0)
+            throw std::runtime_error{"Cannot register C++ function class"};
+    }
+};
+
+
+/** Traits for accessing object properties.
+ * @tparam Key property key type (uint32 and strings are supported)
+ */
+template <typename Key>
+struct js_property_traits
+{
+    static void set_property(JSContext * ctx, JSValue this_obj, Key key, JSValue value);
+
+    static JSValue get_property(JSContext * ctx, JSValue this_obj, Key key);
+};
+
+template <>
+struct js_property_traits<const char *>
+{
+    static void set_property(JSContext * ctx, JSValue this_obj, const char * name, JSValue value)
+    {
+        int err = JS_SetPropertyStr(ctx, this_obj, name, value);
+        if(err < 0)
+            throw exception{ctx};
+    }
+
+    static JSValue get_property(JSContext * ctx, JSValue this_obj, const char * name) noexcept
+    {
+        return JS_GetPropertyStr(ctx, this_obj, name);
+    }
+};
+
+template <>
+struct js_property_traits<uint32_t>
+{
+    static void set_property(JSContext * ctx, JSValue this_obj, uint32_t idx, JSValue value)
+    {
+        int err = JS_SetPropertyUint32(ctx, this_obj, idx, value);
+        if(err < 0)
+            throw exception{ctx};
+    }
+
+    static JSValue get_property(JSContext * ctx, JSValue this_obj, uint32_t idx) noexcept
+    {
+        return JS_GetPropertyUint32(ctx, this_obj, idx);
+    }
+};
+
+template <>
+struct js_property_traits<int> : js_property_traits<uint32_t> {};
+
+
+namespace detail {
+template <typename Key>
+struct property_proxy
+{
+    JSContext * ctx;
+    JSValue this_obj;
+    Key key;
+
+    /** Conversion helper function */
+    template <typename T>
+    T as() const
+    {
+        return unwrap_free<T>(ctx, js_property_traits<Key>::get_property(ctx, this_obj, key));
+    }
+
+    /** Explicit conversion operator (to any type) */
+    template <typename T>
+    explicit operator T() const { return as<T>(); }
+
+    /** Implicit converion to qjs::Value */
+    operator Value() const; // defined later due to Value being incomplete type
+
+    /// noncopyable
+    property_proxy& operator =(property_proxy) = delete;
+
+    template <typename T>
+    property_proxy& operator =(T&& value)
+    {
+        js_property_traits<Key>::set_property(ctx, this_obj, key,
+                                              js_traits<std::decay_t<T>>::wrap(ctx, std::forward<T>(value)));
+        return *this;
+    }
+
+    template <typename Key2>
+    property_proxy<Key2> operator[](Key2 key2) const
+    {
+        return {ctx, as<JSValue>(), std::move(key2)};
+    }
+
+    ~property_proxy() noexcept { JS_FreeValue(ctx, this_obj); }
+};
+
+
+// class member variable getter/setter
+template <auto M>
+struct get_set {};
+
+// M -  member object
+template <class T, typename R, R T::*M>
+struct get_set<M>
+{
+    using is_const = std::is_const<R>;
+
+    static const R& get(std::shared_ptr<T> ptr)
+    {
+        return *ptr.*M;
+    }
+
+    static R& set(std::shared_ptr<T> ptr, R value)
+    {
+        return *ptr.*M = std::move(value);
+    }
+
+};
+
+// M - static member object
+template <typename R, R *M>
+struct get_set<M>
+{
+    using is_const = std::is_const<R>;
+
+    static const R& get(bool)
+    {
+        return *M;
+    }
+
+    static R& set(bool, R value)
+    {
+        return *M = std::move(value);
+    }
+
+};
+
+} // namespace detail
+
+/** JSValue with RAAI semantics.
+ * A wrapper over (JSValue v, JSContext * ctx).
+ * Calls JS_FreeValue(ctx, v) on destruction. Can be copied and moved.
+ * A JSValue can be released by either JSValue x = std::move(value); or JSValue x = value.release(), then the Value becomes invalid and FreeValue won't be called
+ * Can be converted to C++ type, for example: auto string = value.as<std::string>(); qjs::exception would be thrown on error
+ * Properties can be accessed (read/write): value["property1"] = 1; value[2] = "2";
+ */
+class Value
+{
+public:
+    JSValue v;
+    JSContext * ctx = nullptr;
+
+public:
+    /** Use context.newValue(val) instead */
+    template <typename T>
+    Value(JSContext * ctx, T&& val) : ctx(ctx)
+    {
+        v = js_traits<std::decay_t<T>>::wrap(ctx, std::forward<T>(val));
+        if(JS_IsException(v))
+            throw exception{ctx};
+    }
+
+    Value(JSValue&& v) noexcept : v(std::move(v)), ctx(nullptr) {}
+
+    Value(const Value& rhs) noexcept
+    {
+        ctx = rhs.ctx;
+        v = JS_DupValue(ctx, rhs.v);
+    }
+
+    Value(Value&& rhs) noexcept
+    {
+        std::swap(ctx, rhs.ctx);
+        v = rhs.v;
+    }
+
+    Value& operator =(Value rhs) noexcept
+    {
+        std::swap(ctx, rhs.ctx);
+        std::swap(v, rhs.v);
+        return *this;
+    }
+
+    bool operator ==(JSValueConst other) const
+    {
+        return JS_VALUE_GET_TAG(v) == JS_VALUE_GET_TAG(other) && JS_VALUE_GET_PTR(v) == JS_VALUE_GET_PTR(other);
+    }
+
+    bool operator !=(JSValueConst other) const { return !((*this) == other); }
+
+    /** Returns true if 2 values are the same (equality for arithmetic types or point to the same object) */
+    bool operator ==(const Value& rhs) const
+    {
+        return (*this == rhs.v);
+    }
+
+    bool operator !=(const Value& rhs) const { return !((*this) == rhs); }
+
+
+    ~Value()
+    {
+        if(ctx) JS_FreeValue(ctx, v);
+    }
+
+    bool isError() const { return JS_IsError(ctx, v); }
+
+    /** Conversion helper function: value.as<T>()
+     * @tparam T type to convert to
+     * @return type returned by js_traits<std::decay_t<T>>::unwrap that should be implicitly convertible to T
+     * */
+    template <typename T>
+    auto as() const { return js_traits<std::decay_t<T>>::unwrap(ctx, v); }
+
+    /** Explicit conversion: static_cast<T>(value) or (T)value */
+    template <typename T>
+    explicit operator T() const { return as<T>(); }
+
+    JSValue release() noexcept// dont call freevalue
+    {
+        ctx = nullptr;
+        return v;
+    }
+
+    /** Implicit conversion to JSValue (rvalue only). Example: JSValue v = std::move(value); */
+    operator JSValue()&& noexcept { return release(); }
+
+
+    /** Access JS properties. Returns proxy type which is implicitly convertible to qjs::Value */
+    template <typename Key>
+    detail::property_proxy<Key> operator [](Key key)
+    {
+        assert(ctx && "Trying to access properties of Value with no JSContext");
+        return {ctx, JS_DupValue(ctx, v), std::move(key)};
+    }
+
+
+    // add("f", []() {...});
+    template <typename Function>
+    Value& add(const char * name, Function&& f)
+    {
+        (*this)[name] = js_traits<decltype(std::function{std::forward<Function>(f)})>::wrap(ctx,
+                                                                                            std::forward<Function>(f));
+        return *this;
+    }
+
+    // add<&f>("f");
+    // add<&T::f>("f");
+    template <auto F>
+    std::enable_if_t<std::is_member_function_pointer_v<decltype(F)> || std::is_function_v<std::remove_pointer_t<decltype(F)>>, Value&>
+    add(const char * name)
+    {
+        (*this)[name] = fwrapper<F>{name};
+        return *this;
+    }
+
+    // add_getter_setter<&T::get_member, &T::set_member>("member");
+    template <auto FGet, auto FSet>
+    Value& add_getter_setter(const char * name)
+    {
+        auto prop = JS_NewAtom(ctx, name);
+        using fgetter = fwrapper<FGet, true>;
+        using fsetter = fwrapper<FSet, true>;
+        int ret = JS_DefinePropertyGetSet(ctx, v, prop,
+                                          js_traits<fgetter>::wrap(ctx, fgetter{name}),
+                                          js_traits<fsetter>::wrap(ctx, fsetter{name}),
+                                          JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE | JS_PROP_ENUMERABLE
+        );
+        JS_FreeAtom(ctx, prop);
+        if(ret < 0)
+            throw exception{ctx};
+        return *this;
+    }
+
+    // add_getter<&T::get_member>("member");
+    template <auto FGet>
+    Value& add_getter(const char * name)
+    {
+        auto prop = JS_NewAtom(ctx, name);
+        using fgetter = fwrapper<FGet, true>;
+        int ret = JS_DefinePropertyGetSet(ctx, v, prop,
+                                          js_traits<fgetter>::wrap(ctx, fgetter{name}),
+                                          JS_UNDEFINED,
+                                          JS_PROP_CONFIGURABLE | JS_PROP_ENUMERABLE
+        );
+        JS_FreeAtom(ctx, prop);
+        if(ret < 0)
+            throw exception{ctx};
+        return *this;
+    }
+
+    // add<&T::member>("member");
+    template <auto M>
+    std::enable_if_t<std::is_member_object_pointer_v<decltype(M)>, Value&>
+    add(const char * name)
+    {
+        if constexpr (detail::get_set<M>::is_const::value)
+            return add_getter<detail::get_set<M>::get>(name);
+        else
+            return add_getter_setter<detail::get_set<M>::get, detail::get_set<M>::set>(name);
+    }
+
+    // add<&T::static_member>("static_member");
+    template <auto M>
+    std::enable_if_t<std::is_pointer_v<decltype(M)> && !std::is_function_v<std::remove_pointer_t<decltype(M)>> , Value&>
+    add(const char * name)
+    {
+        if constexpr (detail::get_set<M>::is_const::value)
+            return add_getter<detail::get_set<M>::get>(name);
+        else
+            return add_getter_setter<detail::get_set<M>::get, detail::get_set<M>::set>(name);
+    }
+
+    std::string
+    toJSON(const Value& replacer = JS_UNDEFINED, const Value& space = JS_UNDEFINED)
+    {
+        assert(ctx);
+        assert(!replacer.ctx || ctx == replacer.ctx);
+        assert(!space.ctx || ctx == space.ctx);
+        return (std::string) Value{ctx, JS_JSONStringify(ctx, v, replacer.v, space.v)};
+    }
+
+    /** same as Context::eval() but with this Value as 'this' */
+    Value evalThis(std::string_view buffer, const char * filename = "<evalThis>", int flags = 0)
+    {
+        assert(buffer.data()[buffer.size()] == '\0' && "eval buffer is not null-terminated"); // JS_Eval requirement
+        assert(ctx);
+        return Value{ctx, JS_EvalThis(ctx, v, buffer.data(), buffer.size(), filename, flags)};
+    }
+
+};
+
+/** Thin wrapper over JSRuntime * rt
+ * Calls JS_FreeRuntime on destruction. noncopyable.
+ */
+class Runtime
+{
+public:
+    JSRuntime * rt;
+
+    Runtime()
+    {
+        rt = JS_NewRuntime();
+        if(!rt)
+            throw std::runtime_error{"qjs: Cannot create runtime"};
+
+        JS_SetHostUnhandledPromiseRejectionTracker(rt, promise_unhandled_rejection_tracker, NULL);
+        JS_SetModuleLoaderFunc(rt, nullptr, module_loader, nullptr);
+    }
+
+    // noncopyable
+    Runtime(const Runtime&) = delete;
+
+    ~Runtime()
+    {
+        JS_FreeRuntime(rt);
+    }
+
+    /// @return pointer to qjs::Context of the executed job or nullptr if no job is pending
+    Context * executePendingJob();
+
+    bool isJobPending() const {
+        return JS_IsJobPending(rt);
+    }
+
+private:
+    static void promise_unhandled_rejection_tracker(JSContext *ctx, JSValueConst promise,
+                                                    JSValueConst reason, JS_BOOL is_handled, void *opaque);
+
+    static JSModuleDef *module_loader(JSContext *ctx,
+                                      const char *module_name, void *opaque);
+};
+
+namespace detail {
+
+inline std::optional<std::string> readFile(std::filesystem::path const & filepath)
+{
+    if (!std::filesystem::exists(filepath)) return std::nullopt;
+    std::ifstream f(filepath, std::ios::in | std::ios::binary);
+    if (!f.is_open()) return std::nullopt;
+    std::stringstream sstream;
+    sstream << f.rdbuf();
+    return sstream.str();
+}
+
+inline std::string toUri(std::string_view filename) {
+    auto fname = std::string{filename};
+    if (fname.find("://") < fname.find("/")) return fname;
+
+    auto fpath = std::filesystem::path(fname);
+    if (!fpath.is_absolute()) {
+        fpath = "." / fpath;
+    }
+    fpath = std::filesystem::weakly_canonical(fpath);
+    fname = "file://" + fpath.generic_string();
+    return fname;
+}
+
+}
+
+/** Wrapper over JSContext * ctx
+ * Calls JS_SetContextOpaque(ctx, this); on construction and JS_FreeContext on destruction
+ */
+class Context
+{
+public:
+    JSContext * ctx;
+
+    /** Module wrapper
+     * Workaround for lack of opaque pointer for module load function by keeping a list of modules in qjs::Context.
+     */
+    class Module
+    {
+        friend class Context;
+
+        JSModuleDef * m;
+        JSContext * ctx;
+        const char * name;
+
+        using nvp = std::pair<const char *, Value>;
+        std::vector<nvp> exports;
+    public:
+        Module(JSContext * ctx, const char * name) : ctx(ctx), name(name)
+        {
+            m = JS_NewCModule(ctx, name, [](JSContext * ctx, JSModuleDef * m) noexcept {
+                auto& context = Context::get(ctx);
+                auto it = std::find_if(context.modules.begin(), context.modules.end(),
+                                       [m](const Module& module) { return module.m == m; });
+                if(it == context.modules.end())
+                    return -1;
+                for(const auto& e : it->exports)
+                {
+                    if(JS_SetModuleExport(ctx, m, e.first, JS_DupValue(ctx, e.second.v)) != 0)
+                        return -1;
+                }
+                return 0;
+            });
+            if(!m)
+                throw exception{ctx};
+        }
+
+        Module& add(const char * name, JSValue&& value)
+        {
+            exports.push_back({name, {ctx, std::move(value)}});
+            JS_AddModuleExport(ctx, m, name);
+            return *this;
+        }
+
+
+        template <typename T>
+        Module& add(const char * name, T&& value)
+        {
+            return add(name, js_traits<T>::wrap(ctx, std::forward<T>(value)));
+        }
+
+        Module(const Module&) = delete;
+
+        Module(Module&&) = default;
+        //Module& operator=(Module&&) = default;
+
+
+        // function wrappers
+
+        /** Add free function F.
+         * Example:
+         * module.function<static_cast<double (*)(double)>(&::sin)>("sin");
+         */
+        template <auto F>
+        Module& function(const char * name)
+        {
+            return add(name, qjs::fwrapper<F>{name});
+        }
+
+        /** Add function object f.
+         * Slower than template version.
+         * Example: module.function("sin", [](double x) { return ::sin(x); });
+         */
+        template <typename F>
+        Module& function(const char * name, F&& f)
+        {
+            return add(name, js_traits<decltype(std::function{std::forward<F>(f)})>::wrap(ctx, std::forward<F>(f)));
+        }
+
+        // class register wrapper
+    private:
+        /** Helper class to register class members and constructors.
+         * See fun, constructor.
+         * Actual registration occurs at object destruction.
+         */
+        template <class T>
+        class class_registrar
+        {
+            const char * name;
+            qjs::Value prototype;
+            qjs::Context::Module& module;
+            qjs::Context& context;
+            qjs::Value ctor; // last added constructor
+        public:
+            explicit class_registrar(const char * name, qjs::Context::Module& module, qjs::Context& context) :
+                    name(name),
+                    prototype(context.newObject()),
+                    module(module),
+                    context(context),
+                    ctor(JS_NULL)
+            {
+            }
+
+            class_registrar(const class_registrar&) = delete;
+
+            /** Add functional object f
+             */
+            template <typename F>
+            class_registrar& fun(const char * name, F&& f)
+            {
+                prototype[name] = std::forward<F>(f);
+                return *this;
+            }
+
+            /** Add class member function or class member variable F
+             * Example:
+             * struct T { int var; int func(); }
+             * auto& module = context.addModule("module");
+             * module.class_<T>("T").fun<&T::var>("var").fun<&T::func>("func");
+             */
+            template <auto F>
+            class_registrar& fun(const char * name)
+            {
+                js_traits<std::shared_ptr<T>>::template ensureCanCastToBase<F>();
+                prototype.add<F>(name);
+                return *this;
+            }
+
+            /** Add a static member or function to the last added constructor.
+             * Example:
+             *  struct T { static int var; static int func(); }
+             *  module.class_<T>("T").contructor<>("T").static_fun<&T::var>("var").static_fun<&T::func>("func");
+             */
+            template <auto F>
+            class_registrar& static_fun(const char * name)
+            {
+                assert(!JS_IsNull(ctor.v) && "You should call .constructor before .static_fun");
+                js_traits<qjs::shared_ptr<T>>::template ensureCanCastToBase<F>();
+                ctor.add<F>(name);
+                return *this;
+            }
+
+            /** Add a property with custom getter and setter.
+             * Example:
+             * module.class_<T>("T").property<&T::getX, &T::setX>("x");
+             */
+            template <auto FGet, auto FSet = nullptr>
+            class_registrar& property(const char * name)
+            {
+                js_traits<std::shared_ptr<T>>::template ensureCanCastToBase<FGet>();
+                js_traits<std::shared_ptr<T>>::template ensureCanCastToBase<FSet>();
+                if constexpr (std::is_same_v<decltype(FSet), std::nullptr_t>)
+                    prototype.add_getter<FGet>(name);
+                else
+                    prototype.add_getter_setter<FGet, FSet>(name);
+                return *this;
+            }
+
+            /** Add class constructor
+             * @tparam Args contructor arguments
+             * @param name constructor name (if not specified class name will be used)
+             */
+            template <typename... Args>
+            class_registrar& constructor(const char * name = nullptr)
+            {
+                if(!name)
+                    name = this->name;
+                ctor = context.newValue(qjs::ctor_wrapper<T, Args...>{name});
+                JS_SetConstructor(context.ctx, ctor.v, prototype.v);
+                module.add(name, qjs::Value{ctor});
+                return *this;
+            }
+
+            /** Sets the base class
+             * @tparam B base class
+             */
+            template <class B>
+            class_registrar& base()
+            {
+                static_assert(!std::is_same_v<B, T>, "Type cannot be a base of itself");
+                assert(js_traits<std::shared_ptr<B>>::QJSClassId && "base class is not registered");
+                js_traits<std::shared_ptr<T>>::template ensureCanCastToBase<B>();
+                auto base_proto = JS_GetClassProto(context.ctx, js_traits<std::shared_ptr<B>>::QJSClassId);
+                int err = JS_SetPrototype(context.ctx, prototype.v, base_proto);
+                JS_FreeValue(context.ctx, base_proto);
+                if(err < 0)
+                    throw exception{context.ctx};
+                return *this;
+            }
+
+            /** All qjs::Value members of T should be marked by mark<> for QuickJS garbage collector
+             * so that the cycle removal algorithm can find the other objects referenced by this object.
+             */
+            template <Value T::* V>
+            class_registrar& mark()
+            {
+                js_traits<std::shared_ptr<T>>::markOffsets.push_back(V);
+                return *this;
+            }
+
+
+            ~class_registrar()
+            {
+                context.registerClass<T>(name, std::move(prototype));
+            }
+        };
+
+    public:
+        /** Add class to module.
+         * See \ref class_registrar.
+         */
+        template <class T>
+        class_registrar<T> class_(const char * name)
+        {
+            return class_registrar<T>{name, *this, qjs::Context::get(ctx)};
+        }
+
+    };
+
+    std::vector<Module> modules;
+private:
+    void init()
+    {
+        JS_SetContextOpaque(ctx, this);
+        js_traits<detail::function>::register_class(ctx, "C++ function");
+    }
+
+public:
+    Context(Runtime& rt) : Context(rt.rt) {}
+
+    Context(JSRuntime * rt)
+    {
+        ctx = JS_NewContext(rt);
+        if(!ctx)
+            throw std::runtime_error{"qjs: Cannot create context"};
+        init();
+    }
+
+    Context(JSContext * ctx) : ctx{ctx}
+    {
+        init();
+    }
+
+    // noncopyable
+    Context(const Context&) = delete;
+
+    ~Context()
+    {
+        modules.clear();
+        JS_FreeContext(ctx);
+    }
+
+    /** Callback triggered when a Promise rejection won't ever be handled */
+    std::function<void(Value)> onUnhandledPromiseRejection;
+
+    /** Data type returned by the moduleLoader function */
+    struct ModuleData {
+        std::optional<std::string> source, url;
+        ModuleData() : source(std::nullopt), url(std::nullopt) {}
+        ModuleData(std::optional<std::string> source) : source(std::move(source)), url(std::nullopt) {}
+        ModuleData(std::optional<std::string> url, std::optional<std::string> source) : source(std::move(source)), url(std::move(url)) {}
+    };
+
+    /** Function called to obtain the source of a module */
+    std::function<ModuleData(std::string_view)> moduleLoader =
+        [](std::string_view filename) -> ModuleData {
+            return ModuleData{ detail::toUri(filename), detail::readFile(filename) };
+        };
+
+    template <typename Function>
+    void enqueueJob(Function && job);
+
+    /** Create module and return a reference to it */
+    Module& addModule(const char * name)
+    {
+        modules.emplace_back(ctx, name);
+        return modules.back();
+    }
+
+    /** returns globalThis */
+    Value global() { return Value{ctx, JS_GetGlobalObject(ctx)}; }
+
+    /** returns new Object() */
+    Value newObject() { return Value{ctx, JS_NewObject(ctx)}; }
+
+    /** returns JS value converted from c++ object val */
+    template <typename T>
+    Value newValue(T&& val) { return Value{ctx, std::forward<T>(val)}; }
+
+    /** returns current exception associated with context and clears it. Should be called when qjs::exception is caught */
+    Value getException() { return Value{ctx, JS_GetException(ctx)}; }
+
+    /** Register class T for conversions to/from std::shared_ptr<T> to work.
+     * Wherever possible module.class_<T>("T")... should be used instead.
+     * @tparam T class type
+     * @param name class name in JS engine
+     * @param proto JS class prototype or JS_UNDEFINED
+     */
+    template <class T>
+    void registerClass(const char * name, JSValue proto = JS_NULL)
+    {
+        js_traits<std::shared_ptr<T>>::register_class(ctx, name, proto);
+    }
+
+    /// @see JS_Eval
+    Value eval(std::string_view buffer, const char * filename = "<eval>", int flags = 0)
+    {
+        assert(buffer.data()[buffer.size()] == '\0' && "eval buffer is not null-terminated"); // JS_Eval requirement
+        JSValue v = JS_Eval(ctx, buffer.data(), buffer.size(), filename, flags);
+        return Value{ctx, std::move(v)};
+    }
+
+    Value evalFile(const char * filename, int flags = 0)
+    {
+        auto buf = detail::readFile(filename);
+        if (!buf)
+            throw std::runtime_error{std::string{"evalFile: can't read file: "} + filename};
+        return eval(*buf, filename, flags);
+    }
+
+    /// @see JS_ParseJSON2
+    Value fromJSON(std::string_view buffer, const char * filename = "<fromJSON>", int flags = 0)
+    {
+        assert(buffer.data()[buffer.size()] == '\0' &&
+               "fromJSON buffer is not null-terminated"); // JS_ParseJSON requirement
+        return Value{ctx, JS_ParseJSON2(ctx, buffer.data(), buffer.size(), filename, flags)};
+    }
+
+    /** Get qjs::Context from JSContext opaque pointer */
+    static Context& get(JSContext * ctx)
+    {
+        void * ptr = JS_GetContextOpaque(ctx);
+        assert(ptr);
+        return *static_cast<Context *>(ptr);
+    }
+};
+
+/** Conversion traits for Value.
+ */
+template <>
+struct js_traits<Value>
+{
+    static Value unwrap(JSContext * ctx, JSValueConst v)
+    {
+        return Value{ctx, JS_DupValue(ctx, v)};
+    }
+
+    static JSValue wrap(JSContext * ctx, Value v) noexcept
+    {
+        assert(JS_GetRuntime(ctx) == JS_GetRuntime(v.ctx));
+        return v.release();
+    }
+};
+
+/** Convert to/from std::function. Actually accepts/returns callable object that is compatible with function<R (Args...)>.
+ * @tparam R return type
+ * @tparam Args argument types
+ */
+template <typename R, typename... Args>
+struct js_traits<std::function<R(Args...)>, int>
+{
+    static auto unwrap(JSContext * ctx, JSValueConst fun_obj)
+    {
+        const int argc = sizeof...(Args);
+        if constexpr(argc == 0)
+        {
+            return [jsfun_obj = Value{ctx, JS_DupValue(ctx, fun_obj)}]() -> R {
+                JSValue result = JS_Call(jsfun_obj.ctx, jsfun_obj.v, JS_UNDEFINED, 0, nullptr);
+                if(JS_IsException(result))
+                    throw exception{jsfun_obj.ctx};
+                return detail::unwrap_free<R>(jsfun_obj.ctx, result);
+            };
+        }
+        else
+        {
+            return [jsfun_obj = Value{ctx, JS_DupValue(ctx, fun_obj)}](Args ... args) -> R {
+                const int argc = sizeof...(Args);
+                JSValue argv[argc];
+                detail::wrap_args(jsfun_obj.ctx, argv, std::forward<Args>(args)...);
+                JSValue result = JS_Call(jsfun_obj.ctx, jsfun_obj.v, JS_UNDEFINED, argc,
+                                         const_cast<JSValueConst *>(argv));
+                for(int i = 0; i < argc; i++) JS_FreeValue(jsfun_obj.ctx, argv[i]);
+                if(JS_IsException(result))
+                    throw exception{jsfun_obj.ctx};
+                return detail::unwrap_free<R>(jsfun_obj.ctx, result);
+            };
+        }
+    }
+
+    /** Convert from function object functor to JSValue.
+     * Uses detail::function for type-erasure.
+     */
+    template <typename Functor>
+    static JSValue wrap(JSContext * ctx, Functor&& functor) noexcept
+    {
+        using detail::function;
+        assert(js_traits<function>::QJSClassId);
+        auto obj = JS_NewObjectClass(ctx, js_traits<function>::QJSClassId);
+        if(JS_IsException(obj))
+            return obj;
+        try
+        {
+            auto fptr = function::create(JS_GetRuntime(ctx), std::forward<Functor>(functor));
+            fptr->invoker = [](function * self, JSContext * ctx, JSValueConst this_value, int argc,
+                               JSValueConst * argv) {
+                assert(self);
+                auto f = reinterpret_cast<std::decay_t<Functor> *>(&self->functor);
+                return detail::wrap_call<R, Args...>(ctx, *f, argc, argv);
+            };
+            JS_SetOpaque(obj, fptr);
+            return obj;
+        }
+        catch(const std::exception& e)
+        {
+            JS_ThrowInternalError(ctx, "%s", e.what());
+            return JS_EXCEPTION;
+        }
+        catch(...)
+        {
+            JS_ThrowInternalError(ctx, "Unknown errror");
+            return JS_EXCEPTION;
+        }
+    }
+};
+
+namespace detail {
+
+template<typename T, typename = void>
+struct is_callable : std::is_function<T> { };
+
+template<typename T>
+struct is_callable<T, std::enable_if_t<std::is_same_v<decltype(void(&T::operator())), void>>> : std::true_type { };
+
+template<typename T>
+inline constexpr bool is_callable_v = is_callable<T>::value;
+
+}
+
+template <typename Function>
+struct js_traits<Function, std::enable_if_t<detail::is_callable_v<Function>>> {
+    static auto unwrap(JSContext * ctx, JSValueConst fun_obj)
+    {
+        return js_traits<
+            decltype(std::function{std::declval<Function>()}),
+            int
+        >::unwrap(ctx, fun_obj);
+    }
+
+    template <typename Functor>
+    static JSValue wrap(JSContext * ctx, Functor&& functor)
+    {
+        return js_traits<
+            decltype(std::function{std::declval<Function>()}),
+            int
+        >::wrap(ctx, std::forward<Functor>(functor));
+    }
+};
+
+/** Convert from std::vector<T> to Array and vice-versa. If Array holds objects that are non-convertible to T throws qjs::exception */
+template <class T>
+struct js_traits<std::vector<T>>
+{
+    static JSValue wrap(JSContext * ctx, const std::vector<T>& arr) noexcept
+    {
+        try
+        {
+            auto jsarray = Value{ctx, JS_NewArray(ctx)};
+            for(uint32_t i = 0; i < (uint32_t) arr.size(); i++)
+                jsarray[i] = arr[i];
+            return jsarray.release();
+        }
+        catch(exception)
+        {
+            return JS_EXCEPTION;
+        }
+        catch (std::exception const & err)
+        {
+            JS_ThrowInternalError(ctx, "%s", err.what());
+            return JS_EXCEPTION;
+        }
+        catch (...)
+        {
+            JS_ThrowInternalError(ctx, "Unknown error");
+            return JS_EXCEPTION;
+        }
+    }
+
+    static std::vector<T> unwrap(JSContext * ctx, JSValueConst jsarr)
+    {
+        int e = JS_IsArray(ctx, jsarr);
+        if(e == 0)
+            JS_ThrowTypeError(ctx, "js_traits<std::vector<T>>::unwrap expects array");
+        if(e <= 0)
+            throw exception{ctx};
+        Value jsarray{ctx, JS_DupValue(ctx, jsarr)};
+        std::vector<T> arr;
+        auto len = static_cast<int32_t>(jsarray["length"]);
+        arr.reserve((uint32_t) len);
+        for(uint32_t i = 0; i < (uint32_t) len; i++)
+            arr.push_back(static_cast<T>(jsarray[i]));
+        return arr;
+    }
+};
+
+
+template <typename U, typename V>
+struct js_traits<std::pair<U, V>>
+{
+    static JSValue wrap(JSContext * ctx, std::pair<U, V> obj) noexcept
+    {
+        try
+        {
+            auto jsarray = Value{ctx, JS_NewArray(ctx)};
+            jsarray[uint32_t(0)] = std::move(obj.first);
+            jsarray[uint32_t(1)] = std::move(obj.second);
+            return jsarray.release();
+        }
+        catch(exception)
+        {
+            return JS_EXCEPTION;
+        }
+        catch (std::exception const & err)
+        {
+            JS_ThrowInternalError(ctx, "%s", err.what());
+            return JS_EXCEPTION;
+        }
+        catch (...)
+        {
+            JS_ThrowInternalError(ctx, "Unknown error");
+            return JS_EXCEPTION;
+        }
+    }
+
+    static std::pair<U, V> unwrap(JSContext * ctx, JSValueConst jsarr)
+    {
+        int e = JS_IsArray(ctx, jsarr);
+        if(e == 0)
+            JS_ThrowTypeError(ctx, "js_traits<%s>::unwrap expects array", QJSPP_TYPENAME(std::pair<U, V>));
+        if(e <= 0)
+            throw exception{ctx};
+        Value jsarray{ctx, JS_DupValue(ctx, jsarr)};
+        const auto len = static_cast<uint32_t>(jsarray["length"]);
+        if(len != 2)
+        {
+            JS_ThrowTypeError(ctx, "js_traits<%s>::unwrap expected array of length 2, got length %d",
+                              QJSPP_TYPENAME(std::pair<U, V>), len);
+            throw exception{ctx};
+        }
+        return std::pair<U, V>{
+                static_cast<U>(jsarray[uint32_t(0)]),
+                static_cast<V>(jsarray[uint32_t(1)])
+        };
+    }
+};
+
+/** Conversions for std::optional.
+ * Unlike other types does not throw on unwrap but returns nullopt.
+ * Converts std::nullopt to null.
+ */
+template <typename T>
+struct js_traits<std::optional<T>>
+{
+    /** Wraps T or null. */
+    static JSValue wrap(JSContext * ctx, std::optional<T> obj) noexcept
+    {
+        if(obj)
+            return js_traits<std::decay_t<T>>::wrap(ctx, *obj);
+        return JS_NULL;
+    }
+
+    /** If conversion to T fails returns std::nullopt. */
+    static auto unwrap(JSContext * ctx, JSValueConst v) noexcept -> std::optional<decltype(js_traits<std::decay_t<T>>::unwrap(ctx, v))>
+    {
+        try
+        {
+            if(JS_IsNull(v))
+                return std::nullopt;
+            return js_traits<std::decay_t<T>>::unwrap(ctx, v);
+        }
+        catch(exception)
+        {
+            // ignore and clear exception
+            JS_FreeValue(ctx, JS_GetException(ctx));
+        }
+        return std::nullopt;
+    }
+};
+
+
+namespace detail {
+template <typename Key>
+property_proxy<Key>::operator Value() const
+{
+    return as<Value>();
+}
+}
+
+template <typename Function>
+void Context::enqueueJob(Function && job) {
+    JSValue job_val = js_traits<std::function<void()>>::wrap(ctx, std::forward<Function>(job));
+    JSValueConst arg = job_val;
+    int err = JS_EnqueueJob(ctx, [](JSContext *ctx, int argc, JSValueConst *argv){
+        try
+        {
+            assert(argc >= 1);
+            js_traits<std::function<void()>>::unwrap(ctx, argv[0])();
+        }
+        catch (exception)
+        {
+            return JS_EXCEPTION;
+        }
+        catch (std::exception const & err)
+        {
+            JS_ThrowInternalError(ctx, "%s", err.what());
+            return JS_EXCEPTION;
+        }
+        catch (...)
+        {
+            JS_ThrowInternalError(ctx, "Unknown error");
+            return JS_EXCEPTION;
+        }
+        return JS_UNDEFINED;
+    }, 1, &arg);
+    JS_FreeValue(ctx, job_val);
+    if(err < 0)
+        throw exception{ctx};
+}
+
+inline Context & exception::context() const {
+    return Context::get(ctx);
+}
+
+inline Value exception::get() {
+    return context().getException();
+}
+
+inline void Runtime::promise_unhandled_rejection_tracker(JSContext *ctx, JSValueConst promise,
+                                                         JSValueConst reason, JS_BOOL is_handled, void *opaque)
+{
+    auto & context = Context::get(ctx);
+    if (context.onUnhandledPromiseRejection) {
+        context.onUnhandledPromiseRejection(context.newValue(JS_DupValue(ctx, reason)));
+    }
+}
+
+inline JSModuleDef * Runtime::module_loader(JSContext *ctx,
+                                            const char *module_name, void *opaque)
+{
+    Context::ModuleData data;
+    auto & context = Context::get(ctx);
+
+    try {
+        if (context.moduleLoader) data = context.moduleLoader(module_name);
+
+        if (!data.source) {
+            JS_ThrowReferenceError(ctx, "could not load module filename '%s'", module_name);
+            return NULL;
+        }
+
+        if (!data.url) data.url = module_name;
+
+        // compile the module
+        auto func_val = context.eval(*data.source, module_name, JS_EVAL_TYPE_MODULE | JS_EVAL_FLAG_COMPILE_ONLY);
+        assert(JS_VALUE_GET_TAG(func_val.v) == JS_TAG_MODULE);
+        JSModuleDef * m = reinterpret_cast<JSModuleDef *>(JS_VALUE_GET_PTR(func_val.v));
+
+        // set import.meta
+        auto meta = context.newValue(JS_GetImportMeta(ctx, m));
+        meta["url"] = *data.url;
+        meta["main"] = false;
+
+        return m;
+    }
+    catch(exception)
+    {
+        return NULL;
+    }
+    catch (std::exception const & err)
+    {
+        JS_ThrowInternalError(ctx, "%s", err.what());
+        return NULL;
+    }
+    catch (...)
+    {
+        JS_ThrowInternalError(ctx, "Unknown error");
+        return NULL;
+    }
+}
+
+
+inline Context * Runtime::executePendingJob() {
+    JSContext * ctx;
+    auto err = JS_ExecutePendingJob(rt, &ctx);
+    if (err == 0) {
+        // There was no job to run
+        return nullptr;
+    } else if (err < 0) {
+        throw exception{ctx};
+    }
+    return &Context::get(ctx);
+}
+
+} // namespace qjs
Index: quickjs-src/quickjs/include/quickjs/quickjs-defs.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/include/quickjs/quickjs-defs.h b/quickjs-src/quickjs/include/quickjs/quickjs-defs.h
new file mode 100644
--- /dev/null	(date 1727612068261)
+++ b/quickjs-src/quickjs/include/quickjs/quickjs-defs.h	(date 1727612068261)
@@ -0,0 +1,116 @@
+#pragma once
+
+#include <stdint.h>
+
+//////////////////////////////////////////////////////////////////////////
+#if defined(_DEBUG) || defined(FORCE_DEBUG)
+#  define PLATFORM_IS_DEBUG 1
+#else
+#  define PLATFORM_IS_NDEBUG 1
+#endif
+
+#if defined(_WIN32)
+#  include <intrin.h>
+#  define PLATFORM_IS_WINDOWS 1
+#  if defined(_WIN64)
+#    define PLATFORM_IS_WIN64 1
+#  endif
+#endif
+
+#if defined(__ANDROID__)
+#  define PLATFORM_IS_ANDROID 1
+#endif
+
+#if defined(__APPLE__)
+#  define PLATFORM_IS_APPLE 1
+#  include <TargetConditionals.h>
+#  if TARGET_IPHONE_SIMULATOR
+#    define PLATFORM_IS_IPHONE 1
+#    define PLATFORM_IS_IPHONE_SIMULATOR 1
+#  elif TARGET_OS_IPHONE
+#    define PLATFORM_IS_IPHONE 1
+#  elif TARGET_OS_MAC
+#    define PLATFORM_IS_MAC 1
+#  endif
+#endif
+
+#if defined(__linux__)
+#  define PLATFORM_IS_LINUX 1
+#endif
+
+#if defined(__FreeBSD__)
+#  define PLATFORM_IS_FREEBSD 1
+#endif
+
+#if defined(__unix__)
+#  define PLATFORM_IS_UNIX 1
+#endif
+
+#if defined(__x86_64__) || defined(_M_X64)
+#  define PLATFORM_ARCH_X86 1
+#  define PLATFORM_IS_X64 1
+#elif defined(__i386__) || defined(_M_IX86)
+#  define PLATFORM_ARCH_X86 1
+#  define PLATFORM_IS_X86 1
+#endif
+
+#if defined(__aarch64__)
+#  define PLATFORM_ARCH_ARM 1
+#  define PLATFORM_IS_ARM64 1
+#elif defined(__arm__) || defined(_M_ARM)
+#  define PLATFORM_ARCH_ARM 1
+#  define PLATFORM_IS_ARM32 1
+#endif
+
+//////////////////////////////////////////////////////////////////////////
+#if UINTPTR_MAX == UINT32_MAX
+#  define PLATFORM_IS_32BIT 1
+#else
+#  define PLATFORM_IS_64BIT 1
+#endif
+
+//////////////////////////////////////////////////////////////////////////
+#if defined(__clang__) || defined(__GNUC__)
+#  define PLATFORM_GNUC_LIKE 1
+#  if defined(PLATFORM_ARCH_X86)
+#    include <x86intrin.h>
+#  elif defined(PLATFORM_ARCH_ARM)
+#    include <arm_acle.h>
+#    if defined(__ARM_NEON__)
+#      include <arm_neon.h>
+#    endif
+#  endif
+#elif defined(_MSC_VER)
+#  define PLATFORM_MSVC_LIKE 1
+#else
+#  error Cannot detect compiler environment!
+#endif
+
+//////////////////////////////////////////////////////////////////////////
+#if defined(PLATFORM_GNUC_LIKE)
+#  define PLATFORM_LIKELY(x)			__builtin_expect(!!(x), 1)
+#  define PLATFORM_UNLIKELY(x)			__builtin_expect(!!(x), 0)
+#  define PLATFORM_FORCE_INLINE			inline __attribute__((always_inline))
+#  define PLATFORM_NO_INLINE			__attribute__((noinline))
+#  define PLATFORM_MAYBE_UNUSED			__attribute__((unused))
+#  define PLATFORM_WARN_UNUSED			__attribute__((warn_unused_result))
+#  define PLATFORM_PRINTF_LIKE(f, a)	__attribute__((format(printf, f, a)))
+#else
+#  define PLATFORM_LIKELY(x)			x
+#  define PLATFORM_UNLIKELY(x)			x
+#  define PLATFORM_FORCE_INLINE			__forceinline
+#  define PLATFORM_NO_INLINE			__declspec(noinline)
+#  define PLATFORM_MAYBE_UNUSED
+#  define PLATFORM_WARN_UNUSED
+#  define PLATFORM_PRINTF_LIKE(f, a)
+#endif
+
+//////////////////////////////////////////////////////////////////////////
+#if defined(PLATFORM_IS_WINDOWS)
+
+typedef intptr_t ssize_t;
+
+
+#endif
+
+//////////////////////////////////////////////////////////////////////////
Index: ggml-src/ggml/src/ggml-impl.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ggml-src/ggml/src/ggml-impl.h b/ggml-src/ggml/src/ggml-impl.h
--- a/ggml-src/ggml/src/ggml-impl.h	(revision 3e7e5e26f90fecf4f7c2808df7d94454630b219c)
+++ b/ggml-src/ggml/src/ggml-impl.h	(date 1727618793450)
@@ -437,6 +437,7 @@
 
 #ifdef __wasm_simd128__
 #include <wasm_simd128.h>
+#include <immintrin.h>
 #else
 #ifdef __POWER9_VECTOR__
 #include <altivec.h>
Index: spdlog-src/spdlog/src/file_sinks.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/spdlog-src/spdlog/src/file_sinks.cpp b/spdlog-src/spdlog/src/file_sinks.cpp
--- a/spdlog-src/spdlog/src/file_sinks.cpp	(revision 7e635fca68d014934b4af8a1cf874f63989352b7)
+++ b/spdlog-src/spdlog/src/file_sinks.cpp	(date 1745583015851)
@@ -8,7 +8,6 @@
 #include <spdlog/details/null_mutex.h>
 #include <spdlog/details/file_helper-inl.h>
 #include <spdlog/sinks/basic_file_sink-inl.h>
-#include <spdlog/sinks/base_sink-inl.h>
 
 #include <mutex>
 
Index: eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h b/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h
--- a/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	(revision 3147391d946bb4b6c68edd901f2add6ac1f31f8c)
+++ b/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	(date 1745583015976)
@@ -207,7 +207,7 @@
     // block_count leaves that do actual computations.
     Barrier barrier(static_cast<unsigned int>(block.count));
     std::function<void(Index, Index)> handleRange;
-    handleRange = [=, &handleRange, &barrier, &f](Index firstIdx,
+    handleRange = [=, &handleRange, &barrier, &f, this](Index firstIdx,
                                                   Index lastIdx) {
       while (lastIdx - firstIdx > block.size) {
         // Split into halves and schedule the second half on a different thread.
Index: ggml-src/ggml/src/ggml.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ggml-src/ggml/src/ggml.c b/ggml-src/ggml/src/ggml.c
--- a/ggml-src/ggml/src/ggml.c	(revision 3e7e5e26f90fecf4f7c2808df7d94454630b219c)
+++ b/ggml-src/ggml/src/ggml.c	(date 1727618793458)
@@ -1,5 +1,4 @@
 #define _CRT_SECURE_NO_DEPRECATE // Disables ridiculous "unsafe" warnings on Windows
-#define _USE_MATH_DEFINES // For M_PI on MSVC
 
 #include "ggml-impl.h"
 #include "ggml-quants.h"
Index: ggml-src/ggml/src/ggml-backend-impl.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ggml-src/ggml/src/ggml-backend-impl.h b/ggml-src/ggml/src/ggml-backend-impl.h
--- a/ggml-src/ggml/src/ggml-backend-impl.h	(revision 3e7e5e26f90fecf4f7c2808df7d94454630b219c)
+++ b/ggml-src/ggml/src/ggml-backend-impl.h	(date 1727618793391)
@@ -57,7 +57,7 @@
         enum ggml_backend_buffer_usage usage;
     };
 
-    GGML_CALL ggml_backend_buffer_t ggml_backend_buffer_init(
+    GGML_API GGML_CALL ggml_backend_buffer_t ggml_backend_buffer_init(
                    ggml_backend_buffer_type_t      buft,
             struct ggml_backend_buffer_i           iface,
                    ggml_backend_buffer_context_t   context,
@@ -146,7 +146,7 @@
 
     typedef ggml_backend_t (*GGML_CALL ggml_backend_init_fn)(const char * params, void * user_data);
 
-    GGML_CALL void ggml_backend_register(const char * name, ggml_backend_init_fn init_fn, ggml_backend_buffer_type_t default_buffer_type, void * user_data);
+    GGML_API GGML_CALL void ggml_backend_register(const char * name, ggml_backend_init_fn init_fn, ggml_backend_buffer_type_t default_buffer_type, void * user_data);
 
 #ifdef  __cplusplus
 }
Index: ggml-src/ggml/src/ggml-cuda.cu
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ggml-src/ggml/src/ggml-cuda.cu b/ggml-src/ggml/src/ggml-cuda.cu
--- a/ggml-src/ggml/src/ggml-cuda.cu	(revision 3e7e5e26f90fecf4f7c2808df7d94454630b219c)
+++ b/ggml-src/ggml/src/ggml-cuda.cu	(date 1727618793393)
@@ -60,7 +60,7 @@
 ggml_log_callback ggml_cuda_log_callback = ggml_cuda_default_log_callback;
 void * ggml_cuda_log_user_data = NULL;
 
-GGML_API void ggml_backend_cuda_log_set_callback(ggml_log_callback log_callback, void * user_data) {
+void ggml_backend_cuda_log_set_callback(ggml_log_callback log_callback, void * user_data) {
     ggml_cuda_log_callback = log_callback;
     ggml_cuda_log_user_data = user_data;
 }
Index: quickjs-src/quickjs/quickjs.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/quickjs.c b/quickjs-src/quickjs/src/quickjs.c
rename from quickjs-src/quickjs/quickjs.c
rename to quickjs-src/quickjs/src/quickjs.c
--- a/quickjs-src/quickjs/quickjs.c	(revision 6e2e68fd0896957f92eb6c242a2e048c1ef3cae0)
+++ b/quickjs-src/quickjs/src/quickjs.c	(date 1727695851047)
@@ -22,13 +22,13 @@
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  * THE SOFTWARE.
  */
+#include "quickjs-defs.h"
 #include <stdlib.h>
 #include <stdio.h>
 #include <stdarg.h>
 #include <inttypes.h>
 #include <string.h>
 #include <assert.h>
-#include <sys/time.h>
 #include <time.h>
 #include <fenv.h>
 #include <math.h>
@@ -36,8 +36,12 @@
 #include <malloc/malloc.h>
 #elif defined(__linux__) || defined(__GLIBC__)
 #include <malloc.h>
-#elif defined(__FreeBSD__)
-#include <malloc_np.h>
+#endif
+
+#if defined(PLATFORM_IS_WINDOWS)
+# include <windows.h>
+#else
+# include <sys/time.h>
 #endif
 
 #include "cutils.h"
@@ -45,13 +49,15 @@
 #include "quickjs.h"
 #include "libregexp.h"
 #include "libunicode.h"
+#ifdef CONFIG_BIGNUM
 #include "libbf.h"
+#endif
 
 #define OPTIMIZE         1
 #define SHORT_OPCODES    1
 #if defined(EMSCRIPTEN)
 #define DIRECT_DISPATCH  0
-#else
+#elif defined(PLATFORM_GNUC_LIKE)
 #define DIRECT_DISPATCH  1
 #endif
 
@@ -68,11 +74,11 @@
 
 /* define to include Atomics.* operations which depend on the OS
    threads */
-#if !defined(EMSCRIPTEN)
+#if !defined(EMSCRIPTEN) && !defined(_WIN32)
 #define CONFIG_ATOMICS
 #endif
 
-#if !defined(EMSCRIPTEN)
+#if !defined(EMSCRIPTEN) && !_MSC_VER && 0
 /* enable stack limitation */
 #define CONFIG_STACK_CHECK
 #endif
@@ -202,7 +208,7 @@
 #define JS_STACK_SIZE_MAX 65534
 #define JS_STRING_LEN_MAX ((1 << 30) - 1)
 
-#define __exception __attribute__((warn_unused_result))
+#define __exception PLATFORM_WARN_UNUSED
 
 typedef struct JSShape JSShape;
 typedef struct JSString JSString;
@@ -278,6 +284,8 @@
 
     JSHostPromiseRejectionTracker *host_promise_rejection_tracker;
     void *host_promise_rejection_tracker_opaque;
+    JSHostPromiseRejectionTracker *host_unhandled_promise_rejection_tracker;
+    void *host_unhandled_promise_rejection_tracker_opaque;
 
     struct list_head job_list; /* list of JSJobEntry.link */
 
@@ -1042,7 +1050,7 @@
                                             JSValue val, BOOL is_array_ctor);
 static JSValue JS_EvalObject(JSContext *ctx, JSValueConst this_obj,
                              JSValueConst val, int flags, int scope_idx);
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...);
+JSValue PLATFORM_PRINTF_LIKE(2, 3) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...);
 static __maybe_unused void JS_DumpAtoms(JSRuntime *rt);
 static __maybe_unused void JS_DumpString(JSRuntime *rt, const JSString *p);
 static __maybe_unused void JS_DumpObjectHeader(JSRuntime *rt);
@@ -1110,7 +1118,9 @@
 #define HINT_NUMBER  1
 #define HINT_NONE    2
 #define HINT_FORCE_ORDINARY (1 << 4) // don't try Symbol.toPrimitive
+#if 0
 static JSValue JS_ToPrimitiveFree(JSContext *ctx, JSValue val, int hint);
+#endif
 static JSValue JS_ToStringFree(JSContext *ctx, JSValue val);
 static int JS_ToBoolFree(JSContext *ctx, JSValue val);
 static int JS_ToInt32Free(JSContext *ctx, int32_t *pres, JSValue val);
@@ -1196,10 +1206,12 @@
                                           JSValueConst this_val,
                                           int argc, JSValueConst *argv,
                                           int classid);
+#if 0
 static JSValue js_typed_array_constructor_ta(JSContext *ctx,
                                              JSValueConst new_target,
                                              JSValueConst src_obj,
                                              int classid);
+#endif
 static BOOL typed_array_is_detached(JSContext *ctx, JSObject *p);
 static uint32_t typed_array_get_length(JSContext *ctx, JSObject *p);
 static JSValue JS_ThrowTypeErrorDetachedArrayBuffer(JSContext *ctx);
@@ -1611,7 +1623,11 @@
 /* Note: OS and CPU dependent */
 static inline uintptr_t js_get_stack_pointer(void)
 {
+#if defined(PLATFORM_GNUC_LIKE)
     return (uintptr_t)__builtin_frame_address(0);
+#else
+    return 0;
+#endif
 }
 
 static inline BOOL js_check_stack_overflow(JSRuntime *rt, size_t alloca_size)
@@ -1776,7 +1792,18 @@
     js_def_malloc,
     js_def_free,
     js_def_realloc,
-    js_def_malloc_usable_size,
+#if defined(__APPLE__)
+    malloc_size,
+#elif defined(_WIN32)
+    (size_t (*)(const void *))_msize,
+#elif defined(EMSCRIPTEN)
+    NULL,
+#elif defined(__linux__)
+    (size_t (*)(const void *))malloc_usable_size,
+#else
+    /* change this to `NULL,` if compilation fails */
+    malloc_usable_size,
+#endif
 };
 
 JSRuntime *JS_NewRuntime(void)
@@ -3399,7 +3426,7 @@
     return class_id;
 }
 
-JSClassID JS_GetClassID(JSValue v)
+JSClassID JS_GetClassID(JSValueConst v)
 {
     JSObject *p;
     if (JS_VALUE_GET_TAG(v) != JS_TAG_OBJECT)
@@ -6670,7 +6697,7 @@
     return JS_ThrowError2(ctx, error_num, fmt, ap, add_backtrace);
 }
 
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowSyntaxError(JSContext *ctx, const char *fmt, ...)
+JSValue PLATFORM_PRINTF_LIKE(2, 3) JS_ThrowSyntaxError(JSContext *ctx, const char *fmt, ...)
 {
     JSValue val;
     va_list ap;
@@ -6681,7 +6708,7 @@
     return val;
 }
 
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowTypeError(JSContext *ctx, const char *fmt, ...)
+JSValue PLATFORM_PRINTF_LIKE(2, 3) JS_ThrowTypeError(JSContext *ctx, const char *fmt, ...)
 {
     JSValue val;
     va_list ap;
@@ -6692,7 +6719,7 @@
     return val;
 }
 
-static int __attribute__((format(printf, 3, 4))) JS_ThrowTypeErrorOrFalse(JSContext *ctx, int flags, const char *fmt, ...)
+static int PLATFORM_PRINTF_LIKE(3, 4) JS_ThrowTypeErrorOrFalse(JSContext *ctx, int flags, const char *fmt, ...)
 {
     va_list ap;
 
@@ -6708,7 +6735,7 @@
 }
 
 /* never use it directly */
-static JSValue __attribute__((format(printf, 3, 4))) __JS_ThrowTypeErrorAtom(JSContext *ctx, JSAtom atom, const char *fmt, ...)
+static JSValue PLATFORM_PRINTF_LIKE(3, 4) __JS_ThrowTypeErrorAtom(JSContext *ctx, JSAtom atom, const char *fmt, ...)
 {
     char buf[ATOM_GET_STR_BUF_SIZE];
     return JS_ThrowTypeError(ctx, fmt,
@@ -6716,7 +6743,7 @@
 }
 
 /* never use it directly */
-static JSValue __attribute__((format(printf, 3, 4))) __JS_ThrowSyntaxErrorAtom(JSContext *ctx, JSAtom atom, const char *fmt, ...)
+static JSValue PLATFORM_PRINTF_LIKE(3, 4) __JS_ThrowSyntaxErrorAtom(JSContext *ctx, JSAtom atom, const char *fmt, ...)
 {
     char buf[ATOM_GET_STR_BUF_SIZE];
     return JS_ThrowSyntaxError(ctx, fmt,
@@ -6739,7 +6766,7 @@
     }
 }
 
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowReferenceError(JSContext *ctx, const char *fmt, ...)
+JSValue PLATFORM_PRINTF_LIKE(2, 3) JS_ThrowReferenceError(JSContext *ctx, const char *fmt, ...)
 {
     JSValue val;
     va_list ap;
@@ -6750,7 +6777,7 @@
     return val;
 }
 
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowRangeError(JSContext *ctx, const char *fmt, ...)
+JSValue PLATFORM_PRINTF_LIKE(2, 3) JS_ThrowRangeError(JSContext *ctx, const char *fmt, ...)
 {
     JSValue val;
     va_list ap;
@@ -6761,7 +6788,7 @@
     return val;
 }
 
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...)
+JSValue PLATFORM_PRINTF_LIKE(2, 3) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...)
 {
     JSValue val;
     va_list ap;
@@ -7308,7 +7335,7 @@
         JS_ThrowTypeErrorNotASymbol(ctx);
         goto fail;
     }
-    prop = js_symbol_to_atom(ctx, (JSValue)name);
+    prop = js_symbol_to_atom(ctx, name);
     p = JS_VALUE_GET_OBJ(obj);
     prs = find_own_property(&pr, p, prop);
     if (prs) {
@@ -7339,7 +7366,7 @@
     /* safety check */
     if (unlikely(JS_VALUE_GET_TAG(name) != JS_TAG_SYMBOL))
         return JS_ThrowTypeErrorNotASymbol(ctx);
-    prop = js_symbol_to_atom(ctx, (JSValue)name);
+    prop = js_symbol_to_atom(ctx, name);
     p = JS_VALUE_GET_OBJ(obj);
     prs = find_own_property(&pr, p, prop);
     if (!prs) {
@@ -7366,7 +7393,7 @@
         JS_ThrowTypeErrorNotASymbol(ctx);
         goto fail;
     }
-    prop = js_symbol_to_atom(ctx, (JSValue)name);
+    prop = js_symbol_to_atom(ctx, name);
     p = JS_VALUE_GET_OBJ(obj);
     prs = find_own_property(&pr, p, prop);
     if (!prs) {
@@ -7465,7 +7492,7 @@
         return -1;
     }
     p = JS_VALUE_GET_OBJ(obj);
-    prs = find_own_property(&pr, p, js_symbol_to_atom(ctx, (JSValue)brand));
+    prs = find_own_property(&pr, p, js_symbol_to_atom(ctx, brand));
     return (prs != NULL);
 }
 
@@ -9085,7 +9112,7 @@
                 return -1;
             }
             /* this code relies on the fact that Uint32 are never allocated */
-            val = (JSValueConst)JS_NewUint32(ctx, array_length);
+            val = JS_NewUint32(ctx, array_length);
             /* prs may have been modified */
             prs = find_own_property(&pr, p, prop);
             assert(prs != NULL);
@@ -10292,7 +10319,7 @@
             } else
 #endif
             {
-                double d = 1.0 / 0.0;
+                double d = INFINITY;
                 if (is_neg)
                     d = -d;
                 val = JS_NewFloat64(ctx, d);
@@ -16002,7 +16029,7 @@
 #else
     sf->js_mode = 0;
 #endif
-    sf->cur_func = (JSValue)func_obj;
+    sf->cur_func = func_obj;
     sf->arg_count = argc;
     arg_buf = argv;
 
@@ -16247,7 +16274,7 @@
     sf->js_mode = b->js_mode;
     arg_buf = argv;
     sf->arg_count = argc;
-    sf->cur_func = (JSValue)func_obj;
+    sf->cur_func = func_obj;
     init_list_head(&sf->var_ref_list);
     var_refs = p->u.func.var_refs;
 
@@ -20174,7 +20201,7 @@
     }
 }
 
-static void __attribute((unused)) dump_token(JSParseState *s,
+static void PLATFORM_MAYBE_UNUSED dump_token(JSParseState *s,
                                              const JSToken *token)
 {
     switch(token->val) {
@@ -20235,7 +20262,7 @@
     }
 }
 
-int __attribute__((format(printf, 2, 3))) js_parse_error(JSParseState *s, const char *fmt, ...)
+int PLATFORM_PRINTF_LIKE(2, 3) js_parse_error(JSParseState *s, const char *fmt, ...)
 {
     JSContext *ctx = s->ctx;
     va_list ap;
@@ -28897,7 +28924,8 @@
     JS_FreeValue(ctx, promise);
     return 0;
 }
-
+JSValue JS_PromiseResult(JSContext *ctx, JSValue promise);
+JSPromiseStateEnum JS_PromiseState(JSContext *ctx, JSValue promise);
 /* return < 0 in case of exception. *pvalue contains the exception. */
 static int js_execute_sync_module(JSContext *ctx, JSModuleDef *m,
                                   JSValue *pvalue)
@@ -35656,7 +35684,7 @@
 } BCReaderState;
 
 #ifdef DUMP_READ_OBJECT
-static void __attribute__((format(printf, 2, 3))) bc_read_trace(BCReaderState *s, const char *fmt, ...) {
+static void PLATFORM_PRINTF_LIKE(2, 3) bc_read_trace(BCReaderState *s, const char *fmt, ...) {
     va_list ap;
     int i, n, n0;
 
@@ -40442,8 +40470,8 @@
         if (!JS_IsUndefined(mapperFunction)) {
             JSValueConst args[3] = { element, JS_NewInt64(ctx, sourceIndex), source };
             element = JS_Call(ctx, mapperFunction, thisArg, 3, args);
-            JS_FreeValue(ctx, (JSValue)args[0]);
-            JS_FreeValue(ctx, (JSValue)args[1]);
+            JS_FreeValue(ctx, args[0]);
+            JS_FreeValue(ctx, args[1]);
             if (JS_IsException(element))
                 return -1;
         }
@@ -42009,7 +42037,7 @@
         str = JS_NewString(ctx, "g");
         if (JS_IsException(str))
             goto fail;
-        args[args_len++] = (JSValueConst)str;
+        args[args_len++] = str;
     }
     rx = JS_CallConstructor(ctx, ctx->regexp_ctor, args_len, args);
     JS_FreeValue(ctx, str);
@@ -43140,7 +43168,7 @@
     uint32_t tag;
 
     if (unlikely(argc == 0)) {
-        return __JS_NewFloat64(ctx, is_max ? -1.0 / 0.0 : 1.0 / 0.0);
+        return __JS_NewFloat64(ctx, is_max ? -INFINITY : INFINITY);
     }
 
     tag = JS_VALUE_GET_TAG(argv[0]);
@@ -43292,6 +43320,28 @@
     return x * 0x2545F4914F6CDD1D;
 }
 
+#if defined(PLATFORM_IS_WINDOWS)
+// From: https://stackoverflow.com/a/26085827
+int gettimeofday(struct timeval *tp, void *tzp)
+{
+    static const uint64_t EPOCH = ((uint64_t)116444736000000000ULL);
+
+    SYSTEMTIME system_time;
+    FILETIME file_time;
+    uint64_t time;
+
+    GetSystemTime(&system_time);
+    SystemTimeToFileTime(&system_time, &file_time);
+    time = ((uint64_t)file_time.dwLowDateTime);
+    time += ((uint64_t)file_time.dwHighDateTime) << 32;
+
+    tp->tv_sec = (long)((time - EPOCH) / 10000000L);
+    tp->tv_usec = (long)(system_time.wMilliseconds * 1000);
+
+    return 0;
+}
+#endif
+
 static void js_random_init(JSContext *ctx)
 {
     struct timeval tv;
@@ -43313,13 +43363,16 @@
     u.u64 = ((uint64_t)0x3ff << 52) | (v >> 12);
     return __JS_NewFloat64(ctx, u.d - 1.0);
 }
+static double js_math_floor(double value) { return floor(value); }
+static double js_math_ceil(double value) { return ceil(value); }
+static double js_math_log2(double value) { return log2(value); }
 
 static const JSCFunctionListEntry js_math_funcs[] = {
     JS_CFUNC_MAGIC_DEF("min", 2, js_math_min_max, 0 ),
     JS_CFUNC_MAGIC_DEF("max", 2, js_math_min_max, 1 ),
     JS_CFUNC_SPECIAL_DEF("abs", 1, f_f, fabs ),
-    JS_CFUNC_SPECIAL_DEF("floor", 1, f_f, floor ),
-    JS_CFUNC_SPECIAL_DEF("ceil", 1, f_f, ceil ),
+    JS_CFUNC_SPECIAL_DEF("floor", 1, f_f, js_math_floor ),
+    JS_CFUNC_SPECIAL_DEF("ceil", 1, f_f, js_math_ceil ),
     JS_CFUNC_SPECIAL_DEF("round", 1, f_f, js_math_round ),
     JS_CFUNC_SPECIAL_DEF("sqrt", 1, f_f, sqrt ),
 
@@ -43344,7 +43397,7 @@
     JS_CFUNC_SPECIAL_DEF("atanh", 1, f_f, atanh ),
     JS_CFUNC_SPECIAL_DEF("expm1", 1, f_f, expm1 ),
     JS_CFUNC_SPECIAL_DEF("log1p", 1, f_f, log1p ),
-    JS_CFUNC_SPECIAL_DEF("log2", 1, f_f, log2 ),
+    JS_CFUNC_SPECIAL_DEF("log2", 1, f_f, js_math_log2 ),
     JS_CFUNC_SPECIAL_DEF("log10", 1, f_f, log10 ),
     JS_CFUNC_SPECIAL_DEF("cbrt", 1, f_f, cbrt ),
     JS_CFUNC_DEF("hypot", 2, js_math_hypot ),
@@ -47225,7 +47278,7 @@
     } else {
         JS_DupValue(ctx, key);
     }
-    mr->key = (JSValue)key;
+    mr->key = key;
     h = map_hash_key(ctx, key) & (s->hash_size - 1);
     list_add_tail(&mr->hash_link, &s->hash_table[h]);
     list_add_tail(&mr->link, &s->records);
@@ -47447,7 +47500,7 @@
                 args[0] = args[1];
             else
                 args[0] = JS_DupValue(ctx, mr->value);
-            args[2] = (JSValue)this_val;
+            args[2] = this_val;
             ret = JS_Call(ctx, func, this_arg, 3, (JSValueConst *)args);
             JS_FreeValue(ctx, args[0]);
             if (!magic)
@@ -47888,6 +47941,7 @@
     struct list_head promise_reactions[2];
     BOOL is_handled; /* Note: only useful to debug */
     JSValue promise_result;
+    JSContext * ctx;
 } JSPromiseData;
 
 typedef struct JSPromiseFunctionDataResolved {
@@ -47984,6 +48038,15 @@
     rt->host_promise_rejection_tracker_opaque = opaque;
 }
 
+void JS_SetHostUnhandledPromiseRejectionTracker(JSRuntime *rt,
+                                       JSHostPromiseRejectionTracker *cb,
+                                       void *opaque)
+{
+    rt->host_unhandled_promise_rejection_tracker = cb;
+    rt->host_unhandled_promise_rejection_tracker_opaque = opaque;
+}
+
+
 static void fulfill_or_reject_promise(JSContext *ctx, JSValueConst promise,
                                       JSValueConst value, BOOL is_reject)
 {
@@ -48188,6 +48251,14 @@
 
     if (!s)
         return;
+    if (s->promise_state == JS_PROMISE_REJECTED && !s->is_handled) {
+        if (rt->host_unhandled_promise_rejection_tracker) {
+            rt->host_unhandled_promise_rejection_tracker(s->ctx, val, s->promise_result, FALSE,
+                                                         rt->host_unhandled_promise_rejection_tracker_opaque);
+        }
+    }
+
+
     for(i = 0; i < 2; i++) {
         list_for_each_safe(el, el1, &s->promise_reactions[i]) {
             JSPromiseReactionData *rd =
@@ -48238,6 +48309,7 @@
     s = js_mallocz(ctx, sizeof(*s));
     if (!s)
         goto fail;
+    s->ctx = ctx;
     s->promise_state = JS_PROMISE_PENDING;
     s->is_handled = FALSE;
     for(i = 0; i < 2; i++)
@@ -48549,7 +48621,7 @@
                 goto fail_reject;
             }
             resolve_element_data[0] = JS_NewBool(ctx, FALSE);
-            resolve_element_data[1] = (JSValueConst)JS_NewInt32(ctx, index);
+            resolve_element_data[1] = JS_NewInt32(ctx, index);
             resolve_element_data[2] = values;
             resolve_element_data[3] = resolving_funcs[is_promise_any];
             resolve_element_data[4] = resolve_element_env;
@@ -48908,7 +48980,7 @@
 {
     JSValueConst func_data[1];
 
-    func_data[0] = (JSValueConst)JS_NewBool(ctx, done);
+    func_data[0] = JS_NewBool(ctx, done);
     return JS_NewCFunctionData(ctx, js_async_from_sync_iterator_unwrap,
                                1, 0, 1, func_data);
 }
@@ -49213,7 +49285,7 @@
     return c < 0x100 && memchr(";/?:@&=+$,#", c, sizeof(";/?:@&=+$,#") - 1) != NULL;
 }
 
-static int __attribute__((format(printf, 2, 3))) js_throw_URIError(JSContext *ctx, const char *fmt, ...)
+static int PLATFORM_PRINTF_LIKE(2, 3) js_throw_URIError(JSContext *ctx, const char *fmt, ...)
 {
     va_list ap;
 
@@ -49485,7 +49557,7 @@
     JS_CFUNC_MAGIC_DEF("encodeURIComponent", 1, js_global_encodeURI, 1 ),
     JS_CFUNC_DEF("escape", 1, js_global_escape ),
     JS_CFUNC_DEF("unescape", 1, js_global_unescape ),
-    JS_PROP_DOUBLE_DEF("Infinity", 1.0 / 0.0, 0 ),
+    JS_PROP_DOUBLE_DEF("Infinity", INFINITY, 0 ),
     JS_PROP_DOUBLE_DEF("NaN", NAN, 0 ),
     JS_PROP_UNDEFINED_DEF("undefined", 0 ),
     JS_PROP_STRING_DEF("[Symbol.toStringTag]", "global", JS_PROP_CONFIGURABLE ),
@@ -53583,7 +53655,10 @@
         return JS_UNDEFINED;
     return JS_GetPropertyInt64(ctx, this_val, idx);
 }
-
+static JSValue js_typed_array_constructor_ta(JSContext *ctx,
+                                             JSValueConst new_target,
+                                             JSValueConst src_obj,
+                                             int classid);
 static JSValue js_typed_array_with(JSContext *ctx, JSValueConst this_val,
                                    int argc, JSValueConst *argv)
 {
@@ -54678,8 +54753,8 @@
             psc->exception = 2;
         }
     done:
-        JS_FreeValue(ctx, (JSValue)argv[0]);
-        JS_FreeValue(ctx, (JSValue)argv[1]);
+        JS_FreeValue(ctx, argv[0]);
+        JS_FreeValue(ctx, argv[1]);
     }
     return cmp;
 }
Index: skia-src/skia/src/core/SkDistanceFieldGen.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/src/core/SkDistanceFieldGen.cpp b/skia-src/skia/src/core/SkDistanceFieldGen.cpp
--- a/skia-src/skia/src/core/SkDistanceFieldGen.cpp	(revision 482de011c920d85fdbe21a81c45852655df6a809)
+++ b/skia-src/skia/src/core/SkDistanceFieldGen.cpp	(date 1745583016054)
@@ -23,6 +23,7 @@
 using namespace skia_private;
 
 #if !defined(SK_DISABLE_SDF_TEXT)
+namespace {
 
 struct DFData {
     float   fAlpha;      // alpha value of source texel
@@ -30,6 +31,7 @@
     SkPoint fDistVector; // distance vector to nearest (so far) edge texel
 };
 
+}
 enum NeighborFlags {
     kLeft_NeighborFlag        = 0x01,
     kRight_NeighborFlag       = 0x02,
Index: eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h b/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h
--- a/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	(revision 3147391d946bb4b6c68edd901f2add6ac1f31f8c)
+++ b/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	(date 1745583016023)
@@ -1006,7 +1006,7 @@
       } else {
         eigen_assert(!use_thread_local);
         device_.enqueueNoNotification(
-            [=]() { kernel(m, n, k, use_thread_local); });
+            [=, this]() { kernel(m, n, k, use_thread_local); });
       }
     }
 
@@ -1060,7 +1060,7 @@
         while (end - start > 1) {
           Index mid = (start + end) / 2;
           device_.enqueueNoNotification(
-              [=]() { enqueue_packing_helper(mid, end, k, rhs); });
+              [=, this]() { enqueue_packing_helper(mid, end, k, rhs); });
           end = mid;
         }
 
@@ -1079,7 +1079,7 @@
 
         if (pack_async) {
           device_.enqueueNoNotification(
-              [=]() { enqueue_packing_helper(start, end, k, rhs); });
+              [=, this]() { enqueue_packing_helper(start, end, k, rhs); });
         } else {
           enqueue_packing_helper(start, end, k, rhs);
         }
Index: fluentui-src/fluentui/src/FluWatermark.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/FluWatermark.cpp b/fluentui-src/fluentui/src/FluWatermark.cpp
--- a/fluentui-src/fluentui/src/FluWatermark.cpp	(revision 4e4016ae3fed7d1a3534760b44313e8fb0b8fd29)
+++ b/fluentui-src/fluentui/src/FluWatermark.cpp	(date 1745583016164)
@@ -9,12 +9,12 @@
     _textColor = QColor(222, 222, 222, 222);
     _textSize = 16;
     setZ(9999);
-    connect(this, &FluWatermark::textColorChanged, this, [=] { update(); });
-    connect(this, &FluWatermark::gapChanged, this, [=] { update(); });
-    connect(this, &FluWatermark::offsetChanged, this, [=] { update(); });
-    connect(this, &FluWatermark::textChanged, this, [=] { update(); });
-    connect(this, &FluWatermark::rotateChanged, this, [=] { update(); });
-    connect(this, &FluWatermark::textSizeChanged, this, [=] { update(); });
+    connect(this, &FluWatermark::textColorChanged, this, [=, this] { update(); });
+    connect(this, &FluWatermark::gapChanged, this, [=, this] { update(); });
+    connect(this, &FluWatermark::offsetChanged, this, [=, this] { update(); });
+    connect(this, &FluWatermark::textChanged, this, [=, this] { update(); });
+    connect(this, &FluWatermark::rotateChanged, this, [=, this] { update(); });
+    connect(this, &FluWatermark::textSizeChanged, this, [=, this] { update(); });
 }
 
 
Index: fluentui-src/fluentui/src/FluRectangle.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/FluRectangle.cpp b/fluentui-src/fluentui/src/FluRectangle.cpp
--- a/fluentui-src/fluentui/src/FluRectangle.cpp	(revision 4e4016ae3fed7d1a3534760b44313e8fb0b8fd29)
+++ b/fluentui-src/fluentui/src/FluRectangle.cpp	(date 1745583016164)
@@ -4,8 +4,8 @@
 FluRectangle::FluRectangle(QQuickItem *parent) : QQuickPaintedItem(parent) {
     color(QColor(255, 255, 255, 255));
     radius({0, 0, 0, 0});
-    connect(this, &FluRectangle::colorChanged, this, [=] { update(); });
-    connect(this, &FluRectangle::radiusChanged, this, [=] { update(); });
+    connect(this, &FluRectangle::colorChanged, this, [=, this] { update(); });
+    connect(this, &FluRectangle::radiusChanged, this, [=, this] { update(); });
 }
 
 
Index: abseil-src/abseil/absl/container/internal/raw_hash_set.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/abseil-src/abseil/absl/container/internal/raw_hash_set.h b/abseil-src/abseil/absl/container/internal/raw_hash_set.h
--- a/abseil-src/abseil/absl/container/internal/raw_hash_set.h	(revision d9e4955c65cd4367dd6bf46f4ccb8cd3d100540b)
+++ b/abseil-src/abseil/absl/container/internal/raw_hash_set.h	(date 1745646576532)
@@ -3026,12 +3026,15 @@
   //   s.insert({"abc", 42});
   std::pair<iterator, bool> insert(init_type&& value)
       ABSL_ATTRIBUTE_LIFETIME_BOUND
+#if 0  // fix Cpp17Destructible requirement for UntypedMessage class in protobuf
 #if __cplusplus >= 202002L
     requires(!IsLifetimeBoundAssignmentFrom<init_type>::value)
 #endif
+#endif
   {
     return emplace(std::move(value));
   }
+#if 0  // fix Cpp17Destructible requirement for UntypedMessage class in protobuf
 #if __cplusplus >= 202002L
   std::pair<iterator, bool> insert(
       init_type&& value ABSL_INTERNAL_ATTRIBUTE_CAPTURED_BY(this))
@@ -3041,6 +3044,7 @@
     return emplace(std::move(value));
   }
 #endif
+#endif
 
   template <class T,
             std::enable_if_t<IsDecomposableAndInsertable<T>::value &&
Index: fluentui-src/fluentui/src/FluTheme.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/FluTheme.cpp b/fluentui-src/fluentui/src/FluTheme.cpp
--- a/fluentui-src/fluentui/src/FluTheme.cpp	(revision 4e4016ae3fed7d1a3534760b44313e8fb0b8fd29)
+++ b/fluentui-src/fluentui/src/FluTheme.cpp	(date 1745583016179)
@@ -24,13 +24,13 @@
     _blurBehindWindowEnabled = false;
     QGuiApplication::instance()->installEventFilter(this);
     refreshColors();
-    connect(this, &FluTheme::darkModeChanged, this, [=] { Q_EMIT darkChanged(); });
-    connect(this, &FluTheme::darkChanged, this, [=] { refreshColors(); });
-    connect(this, &FluTheme::accentColorChanged, this, [=] { refreshColors(); });
+    connect(this, &FluTheme::darkModeChanged, this, [=, this] { Q_EMIT darkChanged(); });
+    connect(this, &FluTheme::darkChanged, this, [=, this] { refreshColors(); });
+    connect(this, &FluTheme::accentColorChanged, this, [=, this] { refreshColors(); });
     connect(&_watcher, &QFileSystemWatcher::fileChanged, this,
-            [=](const QString &path) { Q_EMIT desktopImagePathChanged(); });
+            [=, this](const QString &path) { Q_EMIT desktopImagePathChanged(); });
     connect(this, &FluTheme::blurBehindWindowEnabledChanged, this,
-            [=] { checkUpdateDesktopImage(); });
+            [=, this] { checkUpdateDesktopImage(); });
     startTimer(1000);
 }
 
@@ -81,7 +81,7 @@
     if (!_blurBehindWindowEnabled) {
         return;
     }
-    QThreadPool::globalInstance()->start([=]() {
+    QThreadPool::globalInstance()->start([=, this]() {
         _mutex.lock();
         auto path = FluTools::getInstance()->getWallpaperFilePath();
         if (_desktopImagePath != path) {
Index: rdkit-src/rdkit/Code/GraphMol/FileParsers/MolSGroupParsing.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/FileParsers/MolSGroupParsing.h b/rdkit-src/rdkit/Code/GraphMol/FileParsers/MolSGroupParsing.h
--- a/rdkit-src/rdkit/Code/GraphMol/FileParsers/MolSGroupParsing.h	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Code/GraphMol/FileParsers/MolSGroupParsing.h	(date 1745583016070)
@@ -131,7 +131,7 @@
 template <class T>
 RDKIT_FILEPARSERS_EXPORT std::vector<T> ParseV3000Array(
     std::stringstream &stream, int maxV = -1, bool strictParsing = false);
-#if defined(_MSC_VER) && defined(RDKIT_DYN_LINK)
+#if defined(_MSC_VER)
 template RDKIT_FILEPARSERS_EXPORT std::vector<int> ParseV3000Array(
     std::stringstream &, int, bool);
 template RDKIT_FILEPARSERS_EXPORT std::vector<unsigned int> ParseV3000Array(
Index: fluentui-src/fluentui/src/FluTools.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/FluTools.cpp b/fluentui-src/fluentui/src/FluTools.cpp
--- a/fluentui-src/fluentui/src/FluTools.cpp	(revision 4e4016ae3fed7d1a3534760b44313e8fb0b8fd29)
+++ b/fluentui-src/fluentui/src/FluTools.cpp	(date 1745583015851)
@@ -283,6 +283,7 @@
             return path;
         }
     }
+    return {};
 #elif defined(Q_OS_MACOS)
     QProcess process;
     QStringList args;
Index: arrow-src/arrow/cpp/src/arrow/engine/substrait/visibility.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/arrow-src/arrow/cpp/src/arrow/engine/substrait/visibility.h b/arrow-src/arrow/cpp/src/arrow/engine/substrait/visibility.h
--- a/arrow-src/arrow/cpp/src/arrow/engine/substrait/visibility.h	(revision 272715f6df2a042d69881ffa03d5078c58e4b345)
+++ b/arrow-src/arrow/cpp/src/arrow/engine/substrait/visibility.h	(date 1745649553898)
@@ -21,6 +21,7 @@
 
 #pragma once
 
+#if 0
 #if defined(_WIN32) || defined(__CYGWIN__)
 #  if defined(_MSC_VER)
 #    pragma warning(push)
@@ -50,3 +51,14 @@
 #if defined(_MSC_VER)
 #  pragma warning(pop)
 #endif
+#endif
+
+#include <arrow/util/visibility.h>
+
+#ifndef ARROW_ENGINE_EXPORT
+#define ARROW_ENGINE_EXPORT ARROW_EXPORT
+#endif
+
+#ifndef ARROW_ENGINE_NO_EXPORT
+#define ARROW_ENGINE_NO_EXPORT ARROW_NO_EXPORT
+#endif
Index: protobuf-src/protobuf/third_party/utf8_range/range2-sse.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/protobuf-src/protobuf/third_party/utf8_range/range2-sse.c b/protobuf-src/protobuf/third_party/utf8_range/range2-sse.c
--- a/protobuf-src/protobuf/third_party/utf8_range/range2-sse.c	(revision 1be1c9d0ea6efa2a25bd7b76186844d1669be78a)
+++ b/protobuf-src/protobuf/third_party/utf8_range/range2-sse.c	(date 1745646848566)
@@ -6,7 +6,7 @@
 
 #include <stdio.h>
 #include <stdint.h>
-#include <x86intrin.h>
+#include <smmintrin.h>
 
 int utf8_naive(const unsigned char *data, int len);
 
Index: fluentui-src/fluentui/src/FluTableSortProxyModel.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/FluTableSortProxyModel.cpp b/fluentui-src/fluentui/src/FluTableSortProxyModel.cpp
--- a/fluentui-src/fluentui/src/FluTableSortProxyModel.cpp	(revision 4e4016ae3fed7d1a3534760b44313e8fb0b8fd29)
+++ b/fluentui-src/fluentui/src/FluTableSortProxyModel.cpp	(date 1745583016148)
@@ -5,7 +5,7 @@
 FluTableSortProxyModel::FluTableSortProxyModel(QSortFilterProxyModel *parent)
     : QSortFilterProxyModel{parent} {
     connect(this, &FluTableSortProxyModel::modelChanged, this,
-            [=] { setSourceModel(this->model().value<QAbstractTableModel *>()); });
+            [=, this] { setSourceModel(this->model().value<QAbstractTableModel *>()); });
 }
 
 bool FluTableSortProxyModel::filterAcceptsRow(int source_row,
Index: fluentui-src/fluentui/src/FluQrCodeItem.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/FluQrCodeItem.cpp b/fluentui-src/fluentui/src/FluQrCodeItem.cpp
--- a/fluentui-src/fluentui/src/FluQrCodeItem.cpp	(revision 4e4016ae3fed7d1a3534760b44313e8fb0b8fd29)
+++ b/fluentui-src/fluentui/src/FluQrCodeItem.cpp	(date 1745583016179)
@@ -8,10 +8,10 @@
     _size = 100;
     setWidth(_size);
     setHeight(_size);
-    connect(this, &FluQrCodeItem::textChanged, this, [=] { update(); });
-    connect(this, &FluQrCodeItem::colorChanged, this, [=] { update(); });
-    connect(this, &FluQrCodeItem::bgColorChanged, this, [=] { update(); });
-    connect(this, &FluQrCodeItem::sizeChanged, this, [=] {
+    connect(this, &FluQrCodeItem::textChanged, this, [=, this] { update(); });
+    connect(this, &FluQrCodeItem::colorChanged, this, [=, this] { update(); });
+    connect(this, &FluQrCodeItem::bgColorChanged, this, [=, this] { update(); });
+    connect(this, &FluQrCodeItem::sizeChanged, this, [=, this] {
         setWidth(_size);
         setHeight(_size);
         update();
Index: libpng-src/libpng/pngconf.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/pngconf.h b/libpng-src/libpng/pngconf.h
--- a/libpng-src/libpng/pngconf.h	(revision 872555f4ba910252783af1507f9e7fe1653be252)
+++ b/libpng-src/libpng/pngconf.h	(date 1745583015851)
@@ -20,6 +20,7 @@
 #ifndef PNGCONF_H
 #define PNGCONF_H
 
+#include "libpng_export.h"
 #ifndef PNG_BUILDING_SYMBOL_TABLE /* else includes may cause problems */
 
 /* From libpng 1.6.0 libpng requires an ANSI X3.159-1989 ("ISOC90") compliant C
@@ -222,6 +223,7 @@
 #     error "PNG_USER_PRIVATEBUILD must be defined if PNGAPI is changed"
 #  endif
 
+#if 0
 #  if (defined(_MSC_VER) && _MSC_VER < 800) ||\
       (defined(__BORLANDC__) && __BORLANDC__ < 0x500)
    /* older Borland and MSC
@@ -238,6 +240,7 @@
 #      define PNG_DLL_IMPORT __declspec(dllimport)
 #    endif
 #  endif /* compiler */
+#endif
 
 #else /* !Windows */
 #  if (defined(__IBMC__) || defined(__IBMCPP__)) && defined(__OS2__)
@@ -264,6 +267,7 @@
  * then in an internal header file when building the library, otherwise (when
  * using the library) it is set here.
  */
+#if 0
 #ifndef PNG_IMPEXP
 #  if defined(PNG_USE_DLL) && defined(PNG_DLL_IMPORT)
    /* This forces use of a DLL, disallowing static linking */
@@ -274,6 +278,10 @@
 #    define PNG_IMPEXP
 #  endif
 #endif
+#endif
+#  ifndef PNG_IMPEXP
+#    define PNG_IMPEXP LIBPNG_EXPORT
+#  endif
 
 /* In 1.5.2 the definition of PNG_FUNCTION has been changed to always treat
  * 'attributes' as a storage class - the attributes go at the start of the
Index: indigo-src/indigo/core/indigo-core/common/base_c/defs.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/common/base_c/defs.h b/indigo-src/indigo/core/indigo-core/common/base_c/defs.h
--- a/indigo-src/indigo/core/indigo-core/common/base_c/defs.h	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/core/indigo-core/common/base_c/defs.h	(date 1745583015976)
@@ -19,9 +19,12 @@
 #ifndef __defs_h__
 #define __defs_h__
 
+#include "indigo_core_export.h"
+#if 0
 #if !defined(__sign)
 #define __sign(a) (a > 0 ? 1 : (a < 0 ? -1 : 0))
 #endif
+#endif
 
 #if defined(_WIN32) && !defined(__MINGW32__)
 // #define vsnprintf _vsnprintf
@@ -67,6 +70,7 @@
 #endif
 
 #ifndef EXPORT_SYMBOL
+#if 0
 #ifdef _WIN32
 #define EXPORT_SYMBOL __declspec(dllexport)
 #elif (defined __GNUC__ || defined __APPLE__)
@@ -75,8 +79,11 @@
 #define EXPORT_SYMBOL
 #endif
 #endif
+#define EXPORT_SYMBOL INDIGO_CORE_EXPORT
+#endif
 
 #ifndef DLLEXPORT
+#if 0
 #ifdef _WIN32
 #ifdef INDIGO_PLUGIN
 #define DLLEXPORT __declspec(dllimport)
@@ -87,6 +94,8 @@
 #define DLLEXPORT EXPORT_SYMBOL
 #endif
 #endif
+#define DLLEXPORT EXPORT_SYMBOL
+#endif
 
 #ifndef CEXPORT
 #ifndef __cplusplus
Index: fluentui-src/fluentui/src/FluTreeModel.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/FluTreeModel.cpp b/fluentui-src/fluentui/src/FluTreeModel.cpp
--- a/fluentui-src/fluentui/src/FluTreeModel.cpp	(revision 4e4016ae3fed7d1a3534760b44313e8fb0b8fd29)
+++ b/fluentui-src/fluentui/src/FluTreeModel.cpp	(date 1745583016179)
@@ -90,7 +90,7 @@
             QList<FluTreeNode *> children = item->_children;
             if (!children.isEmpty()) {
                 std::reverse(children.begin(), children.end());
-                foreach (auto c, children) {
+                Q_FOREACH (auto c, children) {
                     stack.append(c);
                 }
             }
@@ -183,7 +183,7 @@
         QList<FluTreeNode *> children = item->_children;
         if (!children.isEmpty()) {
             std::reverse(children.begin(), children.end());
-            foreach (auto c, children) {
+            Q_FOREACH (auto c, children) {
                 stack.append(c);
             }
         }
@@ -222,7 +222,7 @@
         QList<FluTreeNode *> children = item->_children;
         if (!children.isEmpty()) {
             std::reverse(children.begin(), children.end());
-            foreach (auto c, children) {
+            Q_FOREACH (auto c, children) {
                 stack.append(c);
             }
         }
@@ -244,7 +244,7 @@
         QList<FluTreeNode *> children = item->_children;
         if (!children.isEmpty()) {
             std::reverse(children.begin(), children.end());
-            foreach (auto c, children) {
+            Q_FOREACH (auto c, children) {
                 stack.append(c);
             }
         }
@@ -255,7 +255,7 @@
 
 QVariant FluTreeModel::selectionModel() {
     QList<FluTreeNode *> data;
-    foreach (auto item, _dataSource) {
+    Q_FOREACH (auto item, _dataSource) {
         if (item->checked()) {
             data.append(item);
         }
Index: skia-src/skia/modules/skcms/src/skcms_TransformBaseline.cc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/modules/skcms/src/skcms_TransformBaseline.cc b/skia-src/skia/modules/skcms/src/skcms_TransformBaseline.cc
--- a/skia-src/skia/modules/skcms/src/skcms_TransformBaseline.cc	(revision 482de011c920d85fdbe21a81c45852655df6a809)
+++ b/skia-src/skia/modules/skcms/src/skcms_TransformBaseline.cc	(date 1745583015867)
@@ -19,7 +19,7 @@
 #elif defined(__SSE__)
     #include <immintrin.h>
 
-    #if defined(__clang__)
+    #if defined(__clang__) && !defined(__EMSCRIPTEN__)
         // That #include <immintrin.h> is usually enough, but Clang's headers
         // avoid #including the whole kitchen sink when _MSC_VER is defined,
         // because lots of programs on Windows would include that and it'd be
Index: skia-src/skia/modules/skcms/src/skcms_TransformSkx.cc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/modules/skcms/src/skcms_TransformSkx.cc b/skia-src/skia/modules/skcms/src/skcms_TransformSkx.cc
--- a/skia-src/skia/modules/skcms/src/skcms_TransformSkx.cc	(revision 482de011c920d85fdbe21a81c45852655df6a809)
+++ b/skia-src/skia/modules/skcms/src/skcms_TransformSkx.cc	(date 1745583015867)
@@ -19,7 +19,7 @@
 #elif defined(__SSE__)
     #include <immintrin.h>
 
-    #if defined(__clang__)
+    #if defined(__clang__) && !defined(__EMSCRIPTEN__)
         // That #include <immintrin.h> is usually enough, but Clang's headers
         // avoid #including the whole kitchen sink when _MSC_VER is defined,
         // because lots of programs on Windows would include that and it'd be
Index: skia-src/skia/modules/skcms/src/skcms_TransformHsw.cc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/modules/skcms/src/skcms_TransformHsw.cc b/skia-src/skia/modules/skcms/src/skcms_TransformHsw.cc
--- a/skia-src/skia/modules/skcms/src/skcms_TransformHsw.cc	(revision 482de011c920d85fdbe21a81c45852655df6a809)
+++ b/skia-src/skia/modules/skcms/src/skcms_TransformHsw.cc	(date 1745583015851)
@@ -19,7 +19,7 @@
 #elif defined(__SSE__)
     #include <immintrin.h>
 
-    #if defined(__clang__)
+    #if defined(__clang__) && !defined(__EMSCRIPTEN__)
         // That #include <immintrin.h> is usually enough, but Clang's headers
         // avoid #including the whole kitchen sink when _MSC_VER is defined,
         // because lots of programs on Windows would include that and it'd be
Index: openssl-src/openssl/crypto/bn_conf.h.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openssl-src/openssl/crypto/bn_conf.h.cmake b/openssl-src/openssl/crypto/bn_conf.h.cmake
new file mode 100644
--- /dev/null	(date 1745583015976)
+++ b/openssl-src/openssl/crypto/bn_conf.h.cmake	(date 1745583015976)
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2016 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://www.openssl.org/source/license.html
+ */
+
+#ifndef OSSL_CRYPTO_BN_CONF_H
+# define OSSL_CRYPTO_BN_CONF_H
+
+/*
+ * The contents of this file are not used in the UEFI build, as
+ * both 32-bit and 64-bit builds are supported from a single run
+ * of the Configure script.
+ */
+
+/* Should we define BN_DIV2W here? */
+
+/* Only one for the following should be defined */
+#cmakedefine SIXTY_FOUR_BIT_LONG
+#cmakedefine SIXTY_FOUR_BIT
+#cmakedefine THIRTY_TWO_BIT
+
+#endif
Index: skia-src/skia/modules/skcms/src/skcms_internals.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/modules/skcms/src/skcms_internals.h b/skia-src/skia/modules/skcms/src/skcms_internals.h
--- a/skia-src/skia/modules/skcms/src/skcms_internals.h	(revision 482de011c920d85fdbe21a81c45852655df6a809)
+++ b/skia-src/skia/modules/skcms/src/skcms_internals.h	(date 1745583015867)
@@ -94,7 +94,7 @@
 
 // If we are in SKCMS_PORTABLE mode or running on a non-x86-64 platform, we can't enable HSW or SKX.
 // We also disable HSW/SKX on Android, even if it's Android on x64, since it's unlikely to benefit.
-#if defined(SKCMS_PORTABLE) || !defined(__x86_64__) || defined(ANDROID) || defined(__ANDROID__)
+#if defined(SKCMS_PORTABLE) || !defined(__x86_64__) || defined(ANDROID) || defined(__ANDROID__) || defined(__MINGW64__)
     #undef SKCMS_FORCE_HSW
     #if !defined(SKCMS_DISABLE_HSW)
         #define SKCMS_DISABLE_HSW 1
@@ -105,6 +105,18 @@
         #define SKCMS_DISABLE_SKX 1
     #endif
 #endif
+
+#if !defined(__AVX2__) || !defined(__AVX__) || !defined(__F16C__)
+#if !defined(SKCMS_DISABLE_HSW)
+#define SKCMS_DISABLE_HSW 1
+#endif
+#endif
+
+#if !defined(__AVX512__) || !defined(__AVX512F__)
+#if !defined(SKCMS_DISABLE_SKX)
+#define SKCMS_DISABLE_SKX 1
+#endif
+#endif
 
 // ~~~~ Shared ~~~~
 typedef struct skcms_ICCTag {
Index: skia-src/skia/modules/skcms/skcms.cc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/modules/skcms/skcms.cc b/skia-src/skia/modules/skcms/skcms.cc
--- a/skia-src/skia/modules/skcms/skcms.cc	(revision 482de011c920d85fdbe21a81c45852655df6a809)
+++ b/skia-src/skia/modules/skcms/skcms.cc	(date 1745583015867)
@@ -19,7 +19,7 @@
 #elif defined(__SSE__)
     #include <immintrin.h>
 
-    #if defined(__clang__)
+    #if defined(__clang__) && !defined(__EMSCRIPTEN__)
         // That #include <immintrin.h> is usually enough, but Clang's headers
         // "helpfully" skip including the whole kitchen sink when _MSC_VER is
         // defined, because lots of programs on Windows would include that and
Index: fluentui-src/fluentui/src/Qt6/CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/Qt6/CMakeLists.txt b/fluentui-src/fluentui/src/Qt6/CMakeLists.txt
new file mode 100644
--- /dev/null	(date 1745662832946)
+++ b/fluentui-src/fluentui/src/Qt6/CMakeLists.txt	(date 1745662832946)
@@ -0,0 +1,62 @@
+project(fluentui)
+
+# fluentui
+set(ROOT_DIR ${CMAKE_CURRENT_SOURCE_DIR})
+set(INC_DIR ${ROOT_DIR}/../)
+set(SRC_DIR ${ROOT_DIR}/../)
+
+file(GLOB_RECURSE QML_PATHS ${ROOT_DIR}/*.qml)
+foreach (filepath ${QML_PATHS})
+    string(REPLACE "${ROOT_DIR}/" "" filename ${filepath})
+    list(APPEND qml_files ${filename})
+endforeach (filepath)
+
+file(GLOB_RECURSE RES_PATHS
+        ${ROOT_DIR}/*.png ${ROOT_DIR}/*.jpg
+        ${ROOT_DIR}/*.svg ${ROOT_DIR}/*.ico
+        ${ROOT_DIR}/*.ttf ${ROOT_DIR}/*.webp
+        ${ROOT_DIR}/*.js)
+foreach (filepath ${RES_PATHS})
+    string(REPLACE "${ROOT_DIR}/" "" filename ${filepath})
+    list(APPEND resource_files ${filename})
+endforeach (filepath)
+
+foreach (filepath IN LISTS qml_files resource_files)
+    string(REPLACE "imports/FluentUI/" "" filename ${filepath})
+    set_source_files_properties(${filepath} PROPERTIES QT_RESOURCE_ALIAS ${filename})
+endforeach ()
+
+if (CMAKE_RUNTIME_OUTPUT_DIRECTORY)
+    set(OUTPUT_DIRECTORY "${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/FluentUI")
+else ()
+    set(OUTPUT_DIRECTORY FluentUI)
+endif ()
+
+#set(CMAKE_AUTOMOC ON)
+#set(CMAKE_AUTORCC ON)
+
+xgd_add_library(${PROJECT_NAME} PRIVATE_INCLUDE_DIRS ${INC_DIR})
+xgd_link_qt(${PROJECT_NAME} PRIVATE Quick)
+
+aux_source_directory(${SRC_DIR} source_files)
+aux_source_directory(${SRC_DIR}/qrcode source_files)
+list(REMOVE_ITEM source_files
+        "${SRC_DIR}/FluHotkey.cpp"
+        "${SRC_DIR}/fluentuiplugin.cpp")
+
+# create target ${PROJECT_NAME}plugin
+qt_add_qml_module(${PROJECT_NAME}
+        OUTPUT_DIRECTORY "${OUTPUT_DIRECTORY}"
+        VERSION 1.0
+        URI FluentUI
+        TYPEINFO "plugins.qmltypes"
+        NO_GENERATE_EXTRA_QMLDIRS
+        SOURCES ${source_files}
+        QML_FILES ${qml_files}
+        RESOURCES ${resource_files}
+        RESOURCE_PREFIX "/")
+
+target_compile_definitions(fluentui PRIVATE HAVE_CONFIG_H)
+if (NOT BUILD_SHARED_LIBS)
+    target_compile_definitions(fluentui PRIVATE FLUENTUI_BUILD_STATIC_LIB)
+endif ()
Index: openssl-src/openssl/crypto/buildinf.h.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openssl-src/openssl/crypto/buildinf.h.cmake b/openssl-src/openssl/crypto/buildinf.h.cmake
new file mode 100644
--- /dev/null	(date 1745583015867)
+++ b/openssl-src/openssl/crypto/buildinf.h.cmake	(date 1745583015867)
@@ -0,0 +1,5 @@
+/* auto-generated for crypto/cversion.c */
+#define CFLAGS "compiler: @CMAKE_C_COMPILER_ID@ @CMAKE_C_FLAGS@"
+#define PLATFORM "platform: @CMAKE_SYSTEM_NAME@"
+#define DATE "built on: @BUILDINF_DATE@"
+static const char *compiler_flags = CFLAGS;
Index: rdkit-src/rdkit/External/GA/ga/GaBase.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/External/GA/ga/GaBase.cpp b/rdkit-src/rdkit/External/GA/ga/GaBase.cpp
new file mode 100644
--- /dev/null	(date 1745583015883)
+++ b/rdkit-src/rdkit/External/GA/ga/GaBase.cpp	(date 1745583015883)
@@ -0,0 +1,9 @@
+#include "GaBase.h"
+
+using namespace GapeGa;
+
+GaBase::GaBase() {
+};
+
+GaBase::~GaBase() {
+};
\ No newline at end of file
Index: spdlog-src/spdlog/include/spdlog/fmt/bundled/core.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/spdlog-src/spdlog/include/spdlog/fmt/bundled/core.h b/spdlog-src/spdlog/include/spdlog/fmt/bundled/core.h
--- a/spdlog-src/spdlog/include/spdlog/fmt/bundled/core.h	(revision 7e635fca68d014934b4af8a1cf874f63989352b7)
+++ b/spdlog-src/spdlog/include/spdlog/fmt/bundled/core.h	(date 1745583015867)
@@ -94,7 +94,7 @@
 #ifndef FMT_USE_CONSTEXPR
 #  if (FMT_HAS_FEATURE(cxx_relaxed_constexpr) || FMT_MSC_VERSION >= 1912 || \
        (FMT_GCC_VERSION >= 600 && FMT_CPLUSPLUS >= 201402L)) &&             \
-      !FMT_ICC_VERSION && !defined(__NVCC__)
+      !FMT_ICC_VERSION && (!defined(__NVCC__) || __CUDACC_VER_MAJOR__ >= 12)
 #    define FMT_USE_CONSTEXPR 1
 #  else
 #    define FMT_USE_CONSTEXPR 0
Index: cairo-src/cairo/boilerplate/cairo-boilerplate.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cairo-src/cairo/boilerplate/cairo-boilerplate.c b/cairo-src/cairo/boilerplate/cairo-boilerplate.c
--- a/cairo-src/cairo/boilerplate/cairo-boilerplate.c	(revision 4541e0cd3a751b85e52e2a83d02ac6145a5efa85)
+++ b/cairo-src/cairo/boilerplate/cairo-boilerplate.c	(date 1745583016070)
@@ -498,6 +498,10 @@
 #endif
 }
 
+void
+_cairo_boilerplate_register_all (void)
+{}
+
 void
 _cairo_boilerplate_register_backend (const cairo_boilerplate_target_t *targets,
 				     unsigned int		       count)
Index: indigo-src/indigo/core/indigo-core/common/base_cpp/output.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/common/base_cpp/output.cpp b/indigo-src/indigo/core/indigo-core/common/base_cpp/output.cpp
--- a/indigo-src/indigo/core/indigo-core/common/base_cpp/output.cpp	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/core/indigo-core/common/base_cpp/output.cpp	(date 1745583016023)
@@ -61,7 +61,7 @@
     write(&value, sizeof(word));
 }
 
-void Output::writeBinaryUInt16(uint16_t value)
+void Output::writeBinaryUInt16(std::uint16_t value)
 {
     // value = htons(value);
     write(&value, sizeof(value));
Index: indigo-src/indigo/core/indigo-core/common/base_cpp/output.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/common/base_cpp/output.h b/indigo-src/indigo/core/indigo-core/common/base_cpp/output.h
--- a/indigo-src/indigo/core/indigo-core/common/base_cpp/output.h	(revision 5286cc77309f0705e026fdf6bca5d68d6fd234bc)
+++ b/indigo-src/indigo/core/indigo-core/common/base_cpp/output.h	(date 1745583016008)
@@ -24,6 +24,7 @@
 #include "base_cpp/array.h"
 #include "base_cpp/exception.h"
 #include "base_cpp/io_base.h"
+#include <cstdint>
 
 namespace indigo
 {
@@ -51,7 +52,7 @@
         void writeChar(char value);
         void writeBinaryInt(int value);
         void writeBinaryWord(word value);
-        void writeBinaryUInt16(uint16_t value);
+        void writeBinaryUInt16(std::uint16_t value);
 
         void writeBinaryFloat(float value);
         void writePackedShort(short value);
Index: openssl-src/openssl/opensslconf.h.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openssl-src/openssl/opensslconf.h.cmake b/openssl-src/openssl/opensslconf.h.cmake
new file mode 100644
--- /dev/null	(date 1745583016086)
+++ b/openssl-src/openssl/opensslconf.h.cmake	(date 1745583016086)
@@ -0,0 +1,203 @@
+/*
+ * Copyright 2016-2020 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://www.openssl.org/source/license.html
+ */
+
+#include <openssl/opensslv.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#ifdef OPENSSL_ALGORITHM_DEFINES
+# error OPENSSL_ALGORITHM_DEFINES no longer supported
+#endif
+
+/*
+ * OpenSSL was configured with the following options:
+ */
+
+#ifndef OPENSSL_NO_MD2
+# define OPENSSL_NO_MD2
+#endif
+#ifndef OPENSSL_NO_RC5
+# define OPENSSL_NO_RC5
+#endif
+#ifndef OPENSSL_THREADS
+# define OPENSSL_THREADS
+#endif
+#ifndef OPENSSL_RAND_SEED_OS
+# define OPENSSL_RAND_SEED_OS
+#endif
+#ifndef OPENSSL_NO_ASAN
+# define OPENSSL_NO_ASAN
+#endif
+#ifndef OPENSSL_NO_ASM
+# define OPENSSL_NO_ASM
+#endif
+#ifndef OPENSSL_NO_CRYPTO_MDEBUG
+# define OPENSSL_NO_CRYPTO_MDEBUG
+#endif
+#ifndef OPENSSL_NO_CRYPTO_MDEBUG_BACKTRACE
+# define OPENSSL_NO_CRYPTO_MDEBUG_BACKTRACE
+#endif
+#ifndef OPENSSL_NO_DEVCRYPTOENG
+# define OPENSSL_NO_DEVCRYPTOENG
+#endif
+#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128
+# define OPENSSL_NO_EC_NISTP_64_GCC_128
+#endif
+#ifndef OPENSSL_NO_EGD
+# define OPENSSL_NO_EGD
+#endif
+#ifndef OPENSSL_NO_EXTERNAL_TESTS
+# define OPENSSL_NO_EXTERNAL_TESTS
+#endif
+#ifndef OPENSSL_NO_FUZZ_AFL
+# define OPENSSL_NO_FUZZ_AFL
+#endif
+#ifndef OPENSSL_NO_FUZZ_LIBFUZZER
+# define OPENSSL_NO_FUZZ_LIBFUZZER
+#endif
+#ifndef OPENSSL_NO_HEARTBEATS
+# define OPENSSL_NO_HEARTBEATS
+#endif
+#ifndef OPENSSL_NO_MSAN
+# define OPENSSL_NO_MSAN
+#endif
+#ifndef OPENSSL_NO_SCTP
+# define OPENSSL_NO_SCTP
+#endif
+#ifndef OPENSSL_NO_SSL_TRACE
+# define OPENSSL_NO_SSL_TRACE
+#endif
+#ifndef OPENSSL_NO_SSL3
+# define OPENSSL_NO_SSL3
+#endif
+#ifndef OPENSSL_NO_SSL3_METHOD
+# define OPENSSL_NO_SSL3_METHOD
+#endif
+#ifndef OPENSSL_NO_UBSAN
+# define OPENSSL_NO_UBSAN
+#endif
+#ifndef OPENSSL_NO_UNIT_TEST
+# define OPENSSL_NO_UNIT_TEST
+#endif
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
+# define OPENSSL_NO_WEAK_SSL_CIPHERS
+#endif
+#ifndef OPENSSL_NO_STATIC_ENGINE
+# define OPENSSL_NO_STATIC_ENGINE
+#endif
+#ifndef OPENSSL_NO_AFALGENG
+# define OPENSSL_NO_AFALGENG
+#endif
+
+/*
+ * Sometimes OPENSSSL_NO_xxx ends up with an empty file and some compilers
+ * don't like that.  This will hopefully silence them.
+ */
+#define NON_EMPTY_TRANSLATION_UNIT static void *dummy = &dummy;
+
+/*
+ * Applications should use -DOPENSSL_API_COMPAT=<version> to suppress the
+ * declarations of functions deprecated in or before <version>. Otherwise, they
+ * still won't see them if the library has been built to disable deprecated
+ * functions.
+ */
+#ifndef DECLARE_DEPRECATED
+# define DECLARE_DEPRECATED(f)   f;
+# ifdef __GNUC__
+#  if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 0)
+#   undef DECLARE_DEPRECATED
+#   define DECLARE_DEPRECATED(f)    f __attribute__ ((deprecated));
+#  endif
+# elif defined(__SUNPRO_C)
+#  if (__SUNPRO_C >= 0x5130)
+#   undef DECLARE_DEPRECATED
+#   define DECLARE_DEPRECATED(f)    f __attribute__ ((deprecated));
+#  endif
+# endif
+#endif
+
+#ifndef OPENSSL_FILE
+# ifdef OPENSSL_NO_FILENAMES
+#  define OPENSSL_FILE ""
+#  define OPENSSL_LINE 0
+# else
+#  define OPENSSL_FILE __FILE__
+#  define OPENSSL_LINE __LINE__
+# endif
+#endif
+
+#ifndef OPENSSL_MIN_API
+# define OPENSSL_MIN_API 0
+#endif
+
+#if !defined(OPENSSL_API_COMPAT) || OPENSSL_API_COMPAT < OPENSSL_MIN_API
+# undef OPENSSL_API_COMPAT
+# define OPENSSL_API_COMPAT OPENSSL_MIN_API
+#endif
+
+/*
+ * Do not deprecate things to be deprecated in version 1.2.0 before the
+ * OpenSSL version number matches.
+ */
+#if OPENSSL_VERSION_NUMBER < 0x10200000L
+# define DEPRECATEDIN_1_2_0(f)   f;
+#elif OPENSSL_API_COMPAT < 0x10200000L
+# define DEPRECATEDIN_1_2_0(f)   DECLARE_DEPRECATED(f)
+#else
+# define DEPRECATEDIN_1_2_0(f)
+#endif
+
+#if OPENSSL_API_COMPAT < 0x10100000L
+# define DEPRECATEDIN_1_1_0(f)   DECLARE_DEPRECATED(f)
+#else
+# define DEPRECATEDIN_1_1_0(f)
+#endif
+
+#if OPENSSL_API_COMPAT < 0x10000000L
+# define DEPRECATEDIN_1_0_0(f)   DECLARE_DEPRECATED(f)
+#else
+# define DEPRECATEDIN_1_0_0(f)
+#endif
+
+#if OPENSSL_API_COMPAT < 0x00908000L
+# define DEPRECATEDIN_0_9_8(f)   DECLARE_DEPRECATED(f)
+#else
+# define DEPRECATEDIN_0_9_8(f)
+#endif
+
+/* Generate 80386 code? */
+#undef I386_ONLY
+
+#undef OPENSSL_UNISTD
+#define OPENSSL_UNISTD <unistd.h>
+
+#undef OPENSSL_EXPORT_VAR_AS_FUNCTION
+#cmakedefine OPENSSL_EXPORT_VAR_AS_FUNCTION
+
+/*
+ * The following are cipher-specific, but are part of the public API.
+ */
+#if !defined(OPENSSL_SYS_UEFI)
+#undef BN_LLONG
+/* Only one for the following should be defined */
+#undef SIXTY_FOUR_BIT_LONG
+#cmakedefine SIXTY_FOUR_BIT_LONG
+#undef SIXTY_FOUR_BIT
+#cmakedefine SIXTY_FOUR_BIT
+#undef THIRTY_TWO_BIT
+#cmakedefine THIRTY_TWO_BIT
+#endif
+
+#define RC4_INT unsigned int
+
+#ifdef  __cplusplus
+}
+#endif
Index: libpng-src/libpng/pngpriv.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/pngpriv.h b/libpng-src/libpng/pngpriv.h
--- a/libpng-src/libpng/pngpriv.h	(revision 872555f4ba910252783af1507f9e7fe1653be252)
+++ b/libpng-src/libpng/pngpriv.h	(date 1745583015867)
@@ -324,6 +324,7 @@
  * PNG_IMPEXP must be set here when building the library to prevent pngconf.h
  * setting it to the "import" setting for a DLL build.
  */
+#if 0
 #ifndef PNG_IMPEXP
 #  ifdef PNG_BUILD_DLL
 #     define PNG_IMPEXP PNG_DLL_EXPORT
@@ -334,6 +335,10 @@
 #     define PNG_IMPEXP
 #  endif
 #endif
+#endif
+#  ifndef PNG_IMPEXP
+#    define PNG_IMPEXP LIBPNG_EXPORT
+#  endif
 
 /* No warnings for private or deprecated functions in the build: */
 #ifndef PNG_DEPRECATED
@@ -393,10 +398,12 @@
 
 #include "png.h"
 
+#if 0
 /* pngconf.h does not set PNG_DLL_EXPORT unless it is required, so: */
 #ifndef PNG_DLL_EXPORT
 #  define PNG_DLL_EXPORT
 #endif
+#endif
 
 /* This is a global switch to set the compilation for an installed system
  * (a release build).  It can be set for testing debug builds to ensure that
Index: boost-src/boost/libs/stacktrace/src/noop.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/stacktrace/src/noop.cpp b/boost-src/boost/libs/stacktrace/src/noop.cpp
--- a/boost-src/boost/libs/stacktrace/src/noop.cpp	(revision d6499f26d471158b6e6f65eea7425200f842b547)
+++ b/boost-src/boost/libs/stacktrace/src/noop.cpp	(date 1745583015820)
@@ -6,6 +6,8 @@
 
 #define BOOST_STACKTRACE_INTERNAL_BUILD_LIBS
 #define BOOST_STACKTRACE_LINK
+#ifndef BOOST_STACKTRACE_USE_NOOP
 #define BOOST_STACKTRACE_USE_NOOP
+#endif
 #include <boost/stacktrace/detail/frame_noop.ipp>
 #include <boost/stacktrace/detail/safe_dump_noop.ipp>
Index: openssl-src/openssl/crypto/dso_conf.h.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openssl-src/openssl/crypto/dso_conf.h.cmake b/openssl-src/openssl/crypto/dso_conf.h.cmake
new file mode 100644
--- /dev/null	(date 1745583015883)
+++ b/openssl-src/openssl/crypto/dso_conf.h.cmake	(date 1745583015883)
@@ -0,0 +1,17 @@
+/*
+ * Copyright 2016-2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://www.openssl.org/source/license.html
+ */
+
+#ifndef OSSL_CRYPTO_DSO_CONF_H
+# define OSSL_CRYPTO_DSO_CONF_H
+# define DSO_EXTENSION "@DSO_EXTENSION@"
+#cmakedefine DSO_NONE
+#cmakedefine DSO_WIN32
+#cmakedefine DSO_DLFCN
+#cmakedefine HAVE_DLFCN_H
+#endif
Index: ncnn-src/ncnn/src/modelbin.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/src/modelbin.cpp b/ncnn-src/ncnn/src/modelbin.cpp
--- a/ncnn-src/ncnn/src/modelbin.cpp	(revision 528589571085b673be7313a9c6e65801f150f607)
+++ b/ncnn-src/ncnn/src/modelbin.cpp	(date 1745583015851)
@@ -92,7 +92,6 @@
 
 Mat ModelBinFromDataReader::load(int w, int type) const
 {
-    Mat m;
 
     if (type == 0)
     {
@@ -117,10 +116,6 @@
             return Mat();
         }
 
-#if __BIG_ENDIAN__
-        swap_endianness_32(&flag_struct.tag);
-#endif
-
         unsigned int flag = (int)flag_struct.f0 + flag_struct.f1 + flag_struct.f2 + flag_struct.f3;
 
         if (flag_struct.tag == 0x01306B47)
@@ -128,17 +123,6 @@
             // half-precision data
             size_t align_data_size = alignSize(w * sizeof(unsigned short), 4);
 
-#if !__BIG_ENDIAN__
-            // try reference data
-            const void* refbuf = 0;
-            nread = d->dr.reference(align_data_size, &refbuf);
-            if (nread == align_data_size)
-            {
-                m = Mat::from_float16((const unsigned short*)refbuf, w);
-            }
-            else
-#endif
-            {
                 std::vector<unsigned short> float16_weights;
                 float16_weights.resize(align_data_size);
                 nread = d->dr.read(&float16_weights[0], align_data_size);
@@ -148,34 +132,12 @@
                     return Mat();
                 }
 
-#if __BIG_ENDIAN__
-                for (int i = 0; i < w; i++)
-                {
-                    swap_endianness_16(&float16_weights[i]);
-                }
-#endif
-
-                m = Mat::from_float16(&float16_weights[0], w);
-            }
-
-            return m;
+                return Mat::from_float16(float16_weights.data(), w);
         }
         else if (flag_struct.tag == 0x000D4B38)
         {
             // int8 data
             size_t align_data_size = alignSize(w, 4);
-
-#if !__BIG_ENDIAN__
-            // try reference data
-            const void* refbuf = 0;
-            nread = d->dr.reference(align_data_size, &refbuf);
-            if (nread == align_data_size)
-            {
-                m = Mat(w, (void*)refbuf, (size_t)1u);
-            }
-            else
-#endif
-            {
                 std::vector<signed char> int8_weights;
                 int8_weights.resize(align_data_size);
                 nread = d->dr.read(&int8_weights[0], align_data_size);
@@ -185,29 +147,17 @@
                     return Mat();
                 }
 
-                m.create(w, (size_t)1u);
+                Mat m(w, (size_t)1u);
                 if (m.empty())
                     return m;
 
                 memcpy(m.data, &int8_weights[0], w);
-            }
 
             return m;
         }
         else if (flag_struct.tag == 0x0002C056)
         {
-#if !__BIG_ENDIAN__
-            // try reference data
-            const void* refbuf = 0;
-            nread = d->dr.reference(w * sizeof(float), &refbuf);
-            if (nread == w * sizeof(float))
-            {
-                m = Mat(w, (void*)refbuf);
-            }
-            else
-#endif
-            {
-                m.create(w);
+            Mat m(w);
                 if (m.empty())
                     return m;
 
@@ -219,23 +169,13 @@
                     return Mat();
                 }
 
-#if __BIG_ENDIAN__
-                for (int i = 0; i < w; i++)
-                {
-                    swap_endianness_32((float*)m + i);
-                }
-#endif
-            }
-
             return m;
         }
-
-        if (flag != 0)
-        {
-            m.create(w);
+        Mat m(w);
             if (m.empty())
                 return m;
-
+        if (flag != 0)
+        {
             // quantized data
             float quantization_value[256];
             nread = d->dr.read(quantization_value, 256 * sizeof(float));
@@ -245,13 +185,6 @@
                 return Mat();
             }
 
-#if __BIG_ENDIAN__
-            for (int i = 0; i < 256; i++)
-            {
-                swap_endianness_32(&quantization_value[i]);
-            }
-#endif
-
             size_t align_weight_data_size = alignSize(w * sizeof(unsigned char), 4);
             std::vector<unsigned char> index_array;
             index_array.resize(align_weight_data_size);
@@ -270,21 +203,6 @@
         }
         else if (flag_struct.f0 == 0)
         {
-#if !__BIG_ENDIAN__
-            // try reference data
-            const void* refbuf = 0;
-            nread = d->dr.reference(w * sizeof(float), &refbuf);
-            if (nread == w * sizeof(float))
-            {
-                m = Mat(w, (void*)refbuf);
-            }
-            else
-#endif
-            {
-                m.create(w);
-                if (m.empty())
-                    return m;
-
                 // raw data
                 nread = d->dr.read(m, w * sizeof(float));
                 if (nread != w * sizeof(float))
@@ -292,32 +210,12 @@
                     NCNN_LOGE("ModelBin read weight_data failed %zd", nread);
                     return Mat();
                 }
-
-#if __BIG_ENDIAN__
-                for (int i = 0; i < w; i++)
-                {
-                    swap_endianness_32((float*)m + i);
-                }
-#endif
             }
-        }
-
         return m;
     }
     else if (type == 1)
     {
-#if !__BIG_ENDIAN__
-        // try reference data
-        const void* refbuf = 0;
-        size_t nread = d->dr.reference(w * sizeof(float), &refbuf);
-        if (nread == w * sizeof(float))
-        {
-            m = Mat(w, (void*)refbuf);
-        }
-        else
-#endif
-        {
-            m.create(w);
+            Mat m(w);
             if (m.empty())
                 return m;
 
@@ -328,15 +226,6 @@
                 NCNN_LOGE("ModelBin read weight_data failed %zd", nread);
                 return Mat();
             }
-
-#if __BIG_ENDIAN__
-            for (int i = 0; i < w; i++)
-            {
-                swap_endianness_32((float*)m + i);
-            }
-#endif
-        }
-
         return m;
     }
     else
Index: rdkit-src/rdkit/Code/GraphMol/Canon.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/Canon.cpp b/rdkit-src/rdkit/Code/GraphMol/Canon.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/Canon.cpp	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Code/GraphMol/Canon.cpp	(date 1745583016133)
@@ -82,7 +82,7 @@
            !details::isUnsaturated(atom, mol)));
 }
 
-auto _possibleCompare = [](const PossibleType &arg1, const PossibleType &arg2) {
+const auto _possibleCompare = [](const PossibleType &arg1, const PossibleType &arg2) {
   return (std::get<0>(arg1) < std::get<0>(arg2));
 };
 
Index: maeparser-src/maeparser/MaeParserConfig.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/maeparser-src/maeparser/MaeParserConfig.hpp b/maeparser-src/maeparser/MaeParserConfig.hpp
--- a/maeparser-src/maeparser/MaeParserConfig.hpp	(revision 09cf37d75fad674018b656a7282197d3c0263e68)
+++ b/maeparser-src/maeparser/MaeParserConfig.hpp	(date 1745583015851)
@@ -1,5 +1,6 @@
 #pragma once
 
+#if 0
 #ifndef STATIC_MAEPARSER
 
 #ifdef WIN32
@@ -19,3 +20,9 @@
 #define EXPORT_MAEPARSER
 
 #endif // STATIC_MAEPARSER
+#endif
+#include <maeparser_export.hpp>
+
+#ifndef EXPORT_MAEPARSER
+#define EXPORT_MAEPARSER MAEPARSER_EXPORT
+#endif
Index: skia-src/skia/src/core/SkFontStream.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/src/core/SkFontStream.cpp b/skia-src/skia/src/core/SkFontStream.cpp
--- a/skia-src/skia/src/core/SkFontStream.cpp	(revision 482de011c920d85fdbe21a81c45852655df6a809)
+++ b/skia-src/skia/src/core/SkFontStream.cpp	(date 1745583016008)
@@ -15,6 +15,7 @@
 
 #include <cstdint>
 
+namespace {
 struct SkSFNTHeader {
     uint32_t    fVersion;
     uint16_t    fNumTables;
@@ -22,6 +23,7 @@
     uint16_t    fEntrySelector;
     uint16_t    fRangeShift;
 };
+}
 
 struct SkTTCFHeader {
     uint32_t    fTag;
Index: ncnn-src/ncnn/src/gpu.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/src/gpu.h b/ncnn-src/ncnn/src/gpu.h
--- a/ncnn-src/ncnn/src/gpu.h	(revision 528589571085b673be7313a9c6e65801f150f607)
+++ b/ncnn-src/ncnn/src/gpu.h	(date 1745583015851)
@@ -321,7 +321,7 @@
     GpuInfo& operator=(const GpuInfo&);
 
 private:
-    friend int create_gpu_instance(const char* driver_path);
+    friend int NCNN_EXPORT create_gpu_instance(const char* driver_path);
     GpuInfoPrivate* const d;
 };
 
Index: ncnn-src/ncnn/src/datareader.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/src/datareader.h b/ncnn-src/ncnn/src/datareader.h
--- a/ncnn-src/ncnn/src/datareader.h	(revision 528589571085b673be7313a9c6e65801f150f607)
+++ b/ncnn-src/ncnn/src/datareader.h	(date 1745583015851)
@@ -44,10 +44,6 @@
     // read binary param and model data
     // return bytes read
     virtual size_t read(void* buf, size_t size) const;
-
-    // get model data reference
-    // return bytes referenced
-    virtual size_t reference(size_t size, const void** buf) const;
 };
 
 #if NCNN_STDIO
@@ -83,7 +79,6 @@
     virtual int scan(const char* format, void* p) const;
 #endif // NCNN_STRING
     virtual size_t read(void* buf, size_t size) const;
-    virtual size_t reference(size_t size, const void** buf) const;
 
 private:
     DataReaderFromMemory(const DataReaderFromMemory&);
Index: protobuf-src/protobuf/src/google/protobuf/repeated_ptr_field.cc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/protobuf-src/protobuf/src/google/protobuf/repeated_ptr_field.cc b/protobuf-src/protobuf/src/google/protobuf/repeated_ptr_field.cc
--- a/protobuf-src/protobuf/src/google/protobuf/repeated_ptr_field.cc	(revision 1be1c9d0ea6efa2a25bd7b76186844d1669be78a)
+++ b/protobuf-src/protobuf/src/google/protobuf/repeated_ptr_field.cc	(date 1745646848566)
@@ -131,7 +131,7 @@
     char* PROTOBUF_RESTRICT, char* PROTOBUF_RESTRICT);
 
 template <>
-void RepeatedPtrFieldBase::MergeFrom<std::string>(
+PROTOBUF_EXPORT_TEMPLATE_DEFINE void RepeatedPtrFieldBase::MergeFrom<std::string>(
     const RepeatedPtrFieldBase& from) {
   Prefetch5LinesFrom1Line(&from);
   ABSL_DCHECK_NE(&from, this);
Index: rdkit-src/rdkit/Code/GraphMol/MolProps.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/MolProps.cpp b/rdkit-src/rdkit/Code/GraphMol/MolProps.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/MolProps.cpp	(revision d32c919066bd46fa54521be7eee57a91d16d348b)
+++ b/rdkit-src/rdkit/Code/GraphMol/MolProps.cpp	(date 1745583016008)
@@ -10,7 +10,7 @@
 #include <GraphMol/RDKitBase.h>
 #include <map>
 #include <string>
-#include <strstream>
+#include <sstream>
 
 namespace RDKit {
 namespace MolOps {
Index: ncnn-src/ncnn/src/datareader.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/src/datareader.cpp b/ncnn-src/ncnn/src/datareader.cpp
--- a/ncnn-src/ncnn/src/datareader.cpp	(revision 528589571085b673be7313a9c6e65801f150f607)
+++ b/ncnn-src/ncnn/src/datareader.cpp	(date 1745583015851)
@@ -38,11 +38,6 @@
     return 0;
 }
 
-size_t DataReader::reference(size_t /*size*/, const void** /*buf*/) const
-{
-    return 0;
-}
-
 #if NCNN_STDIO
 class DataReaderFromStdioPrivate
 {
@@ -141,13 +136,6 @@
     d->mem += size;
     return size;
 }
-
-size_t DataReaderFromMemory::reference(size_t size, const void** buf) const
-{
-    *buf = d->mem;
-    d->mem += size;
-    return size;
-}
 
 #if NCNN_PLATFORM_API
 #if __ANDROID_API__ >= 9
Index: opencv-src/opencv/modules/highgui/src/window_QT.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/highgui/src/window_QT.h b/opencv-src/opencv/modules/highgui/src/window_QT.h
--- a/opencv-src/opencv/modules/highgui/src/window_QT.h	(revision 31b0eeea0b44b370fd0712312df4214d4ae1b158)
+++ b/opencv-src/opencv/modules/highgui/src/window_QT.h	(date 1745583015836)
@@ -68,7 +68,7 @@
 #include <QBoxLayout>
 #include <QSettings>
 #include <qtimer.h>
-#include <QtConcurrentRun>
+#include <QtConcurrent/QtConcurrentRun>
 #include <QWaitCondition>
 #include <QKeyEvent>
 #include <QMetaObject>
@@ -96,17 +96,17 @@
 enum { CV_MODE_NORMAL = 0, CV_MODE_OPENGL = 1 };
 
 //we can change the keyboard shortcuts from here !
-enum {	shortcut_zoom_normal 	= Qt::CTRL + Qt::Key_Z,
-        shortcut_zoom_imgRegion = Qt::CTRL + Qt::Key_X,
-        shortcut_save_img		= Qt::CTRL + Qt::Key_S,
-        shortcut_copy_clipbrd   = Qt::CTRL + Qt::Key_C,
-        shortcut_properties_win	= Qt::CTRL + Qt::Key_P,
-        shortcut_zoom_in 		= Qt::CTRL + Qt::Key_Plus,//QKeySequence(QKeySequence::ZoomIn),
-        shortcut_zoom_out		= Qt::CTRL + Qt::Key_Minus,//QKeySequence(QKeySequence::ZoomOut),
-        shortcut_panning_left 	= Qt::CTRL + Qt::Key_Left,
-        shortcut_panning_right 	= Qt::CTRL + Qt::Key_Right,
-        shortcut_panning_up 	= Qt::CTRL + Qt::Key_Up,
-        shortcut_panning_down 	= Qt::CTRL + Qt::Key_Down
+enum {	shortcut_zoom_normal 	= (int)Qt::CTRL + Qt::Key_Z,
+        shortcut_zoom_imgRegion = (int)Qt::CTRL + Qt::Key_X,
+        shortcut_save_img		= (int)Qt::CTRL + Qt::Key_S,
+        shortcut_copy_clipbrd   = (int)Qt::CTRL + Qt::Key_C,
+        shortcut_properties_win	= (int)Qt::CTRL + Qt::Key_P,
+        shortcut_zoom_in 		= (int)Qt::CTRL + Qt::Key_Plus,//QKeySequence(QKeySequence::ZoomIn),
+        shortcut_zoom_out		= (int)Qt::CTRL + Qt::Key_Minus,//QKeySequence(QKeySequence::ZoomOut),
+        shortcut_panning_left 	= (int)Qt::CTRL + Qt::Key_Left,
+        shortcut_panning_right 	= (int)Qt::CTRL + Qt::Key_Right,
+        shortcut_panning_up 	= (int)Qt::CTRL + Qt::Key_Up,
+        shortcut_panning_down 	= (int)Qt::CTRL + Qt::Key_Down
     };
 //end enum
 
@@ -128,7 +128,7 @@
     bool bTimeOut;
     QTimer* timer;
 
-public slots:
+public Q_SLOTS:
     void createWindow( QString name, int flags = 0 );
     void destroyWindow(QString name);
     void destroyAllWindow();
@@ -204,7 +204,7 @@
     CvButtonCallback callback;
     void* userdata;
 
-private slots:
+private Q_SLOTS:
     void callCallBack(bool);
 };
 
@@ -221,7 +221,7 @@
     CvButtonCallback callback;
     void* userdata;
 
-private slots:
+private Q_SLOTS:
     void callCallBack(bool);
 };
 
@@ -238,7 +238,7 @@
     CvButtonCallback callback;
     void* userdata;
 
-private slots:
+private Q_SLOTS:
     void callCallBack(bool);
 };
 
@@ -252,7 +252,7 @@
 
     QPointer<QSlider> slider;
 
-private slots:
+private Q_SLOTS:
     void createDialog();
     void update(int myvalue);
 
@@ -377,7 +377,7 @@
     void showTools();
     QSize getAvailableSize();
 
-private slots:
+private Q_SLOTS:
     void displayPropertiesWin();
 };
 
@@ -518,7 +518,7 @@
 
     void setSize(QSize size_) CV_OVERRIDE;
 
-public slots:
+public Q_SLOTS:
     //reference:
     //http://www.qtcentre.org/wiki/index.php?title=QGraphicsView:_Smooth_Panning_and_Zooming
     //http://doc.qt.nokia.com/4.6/gestures-imagegestures-imagewidget-cpp.html
@@ -585,7 +585,7 @@
 
     void icvmouseProcessing(QPointF pt, int cv_event, int flags) CV_OVERRIDE;
 
-private slots:
+private Q_SLOTS:
     void stopDisplayInfo();
 };
 
Index: fluentui-src/fluentui/src/Qt6/imports/FluentUI/Controls/FluAcrylic.qml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/Qt6/imports/FluentUI/Controls/FluAcrylic.qml b/fluentui-src/fluentui/src/Qt6/imports/FluentUI/Controls/FluAcrylic.qml
--- a/fluentui-src/fluentui/src/Qt6/imports/FluentUI/Controls/FluAcrylic.qml	(revision 4e4016ae3fed7d1a3534760b44313e8fb0b8fd29)
+++ b/fluentui-src/fluentui/src/Qt6/imports/FluentUI/Controls/FluAcrylic.qml	(date 1745662832946)
@@ -34,7 +34,7 @@
     }
     Image {
         anchors.fill: parent
-        source: "qrc:/qt/qml/FluentUI/Image/noise.png"
+        source: "qrc:/FluentUI/Image/noise.png"
         fillMode: Image.Tile
         opacity: control.noiseOpacity
     }
diff --git a/nodeeditor-src/nodeeditor/src/UndoCommands.hpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/UndoCommands.hpp
rename from nodeeditor-src/nodeeditor/src/UndoCommands.hpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/UndoCommands.hpp
diff --git a/nodeeditor-src/nodeeditor/src/ConnectionPainter.hpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionPainter.hpp
rename from nodeeditor-src/nodeeditor/src/ConnectionPainter.hpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionPainter.hpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeConnectionInteraction.hpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeConnectionInteraction.hpp
rename from nodeeditor-src/nodeeditor/src/NodeConnectionInteraction.hpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeConnectionInteraction.hpp
diff --git a/nodeeditor-src/nodeeditor/src/DefaultVerticalNodeGeometry.hpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultVerticalNodeGeometry.hpp
rename from nodeeditor-src/nodeeditor/src/DefaultVerticalNodeGeometry.hpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultVerticalNodeGeometry.hpp
diff --git a/nodeeditor-src/nodeeditor/src/DefaultHorizontalNodeGeometry.hpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultHorizontalNodeGeometry.hpp
rename from nodeeditor-src/nodeeditor/src/DefaultHorizontalNodeGeometry.hpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultHorizontalNodeGeometry.hpp
diff --git a/quickjs-src/quickjs/list.h b/quickjs-src/quickjs/src/list.h
rename from quickjs-src/quickjs/list.h
rename to quickjs-src/quickjs/src/list.h
diff --git a/quickjs-src/quickjs/quickjs-atom.h b/quickjs-src/quickjs/src/quickjs-atom.h
rename from quickjs-src/quickjs/quickjs-atom.h
rename to quickjs-src/quickjs/src/quickjs-atom.h
diff --git a/quickjs-src/quickjs/quickjs-opcode.h b/quickjs-src/quickjs/src/quickjs-opcode.h
rename from quickjs-src/quickjs/quickjs-opcode.h
rename to quickjs-src/quickjs/src/quickjs-opcode.h
diff --git a/quickjs-src/quickjs/libregexp.h b/quickjs-src/quickjs/src/libregexp.h
rename from quickjs-src/quickjs/libregexp.h
rename to quickjs-src/quickjs/src/libregexp.h
diff --git a/quickjs-src/quickjs/libunicode-table.h b/quickjs-src/quickjs/src/libunicode-table.h
rename from quickjs-src/quickjs/libunicode-table.h
rename to quickjs-src/quickjs/src/libunicode-table.h
diff --git a/quickjs-src/quickjs/libunicode.c b/quickjs-src/quickjs/src/libunicode.c
rename from quickjs-src/quickjs/libunicode.c
rename to quickjs-src/quickjs/src/libunicode.c
diff --git a/quickjs-src/quickjs/libunicode.h b/quickjs-src/quickjs/src/libunicode.h
rename from quickjs-src/quickjs/libunicode.h
rename to quickjs-src/quickjs/src/libunicode.h
diff --git a/quickjs-src/quickjs/libbf.c b/quickjs-src/quickjs/src/libbf.c
rename from quickjs-src/quickjs/libbf.c
rename to quickjs-src/quickjs/src/libbf.c
diff --git a/quickjs-src/quickjs/libregexp-opcode.h b/quickjs-src/quickjs/src/libregexp-opcode.h
rename from quickjs-src/quickjs/libregexp-opcode.h
rename to quickjs-src/quickjs/src/libregexp-opcode.h
diff --git a/quickjs-src/quickjs/quickjs-libc.h b/quickjs-src/quickjs/include/quickjs/quickjs-libc.h
rename from quickjs-src/quickjs/quickjs-libc.h
rename to quickjs-src/quickjs/include/quickjs/quickjs-libc.h
diff --git a/nodeeditor-src/nodeeditor/src/DataFlowGraphModel.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DataFlowGraphModel.cpp
rename from nodeeditor-src/nodeeditor/src/DataFlowGraphModel.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DataFlowGraphModel.cpp
diff --git a/nodeeditor-src/nodeeditor/src/GraphicsViewStyle.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/GraphicsViewStyle.cpp
rename from nodeeditor-src/nodeeditor/src/GraphicsViewStyle.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/GraphicsViewStyle.cpp
diff --git a/nodeeditor-src/nodeeditor/src/ConnectionGraphicsObject.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionGraphicsObject.cpp
rename from nodeeditor-src/nodeeditor/src/ConnectionGraphicsObject.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionGraphicsObject.cpp
diff --git a/nodeeditor-src/nodeeditor/src/ConnectionStyle.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionStyle.cpp
rename from nodeeditor-src/nodeeditor/src/ConnectionStyle.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionStyle.cpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeState.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeState.cpp
rename from nodeeditor-src/nodeeditor/src/NodeState.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeState.cpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeGraphicsObject.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeGraphicsObject.cpp
rename from nodeeditor-src/nodeeditor/src/NodeGraphicsObject.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeGraphicsObject.cpp
diff --git a/nodeeditor-src/nodeeditor/src/DefaultNodePainter.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultNodePainter.cpp
rename from nodeeditor-src/nodeeditor/src/DefaultNodePainter.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultNodePainter.cpp
diff --git a/nodeeditor-src/nodeeditor/src/DefaultHorizontalNodeGeometry.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultHorizontalNodeGeometry.cpp
rename from nodeeditor-src/nodeeditor/src/DefaultHorizontalNodeGeometry.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultHorizontalNodeGeometry.cpp
diff --git a/nodeeditor-src/nodeeditor/src/BasicGraphicsScene.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/BasicGraphicsScene.cpp
rename from nodeeditor-src/nodeeditor/src/BasicGraphicsScene.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/BasicGraphicsScene.cpp
diff --git a/nodeeditor-src/nodeeditor/src/ConnectionState.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionState.cpp
rename from nodeeditor-src/nodeeditor/src/ConnectionState.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionState.cpp
diff --git a/nodeeditor-src/nodeeditor/src/AbstractNodeGeometry.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/AbstractNodeGeometry.cpp
rename from nodeeditor-src/nodeeditor/src/AbstractNodeGeometry.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/AbstractNodeGeometry.cpp
diff --git a/nodeeditor-src/nodeeditor/src/Definitions.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/Definitions.cpp
rename from nodeeditor-src/nodeeditor/src/Definitions.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/Definitions.cpp
diff --git a/nodeeditor-src/nodeeditor/src/DataFlowGraphicsScene.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DataFlowGraphicsScene.cpp
rename from nodeeditor-src/nodeeditor/src/DataFlowGraphicsScene.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DataFlowGraphicsScene.cpp
diff --git a/nodeeditor-src/nodeeditor/src/UndoCommands.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/UndoCommands.cpp
rename from nodeeditor-src/nodeeditor/src/UndoCommands.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/UndoCommands.cpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeDelegateModel.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeDelegateModel.cpp
rename from nodeeditor-src/nodeeditor/src/NodeDelegateModel.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeDelegateModel.cpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeDelegateModelRegistry.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeDelegateModelRegistry.cpp
rename from nodeeditor-src/nodeeditor/src/NodeDelegateModelRegistry.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeDelegateModelRegistry.cpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeStyle.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeStyle.cpp
rename from nodeeditor-src/nodeeditor/src/NodeStyle.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeStyle.cpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeConnectionInteraction.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeConnectionInteraction.cpp
rename from nodeeditor-src/nodeeditor/src/NodeConnectionInteraction.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeConnectionInteraction.cpp
diff --git a/nodeeditor-src/nodeeditor/src/DefaultVerticalNodeGeometry.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultVerticalNodeGeometry.cpp
rename from nodeeditor-src/nodeeditor/src/DefaultVerticalNodeGeometry.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultVerticalNodeGeometry.cpp
diff --git a/nodeeditor-src/nodeeditor/src/ConnectionPainter.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionPainter.cpp
rename from nodeeditor-src/nodeeditor/src/ConnectionPainter.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionPainter.cpp
diff --git a/nodeeditor-src/nodeeditor/src/StyleCollection.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/StyleCollection.cpp
rename from nodeeditor-src/nodeeditor/src/StyleCollection.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/StyleCollection.cpp
diff --git a/nodeeditor-src/nodeeditor/src/locateNode.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/locateNode.cpp
rename from nodeeditor-src/nodeeditor/src/locateNode.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/locateNode.cpp
diff --git a/nodeeditor-src/nodeeditor/src/GraphicsView.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/GraphicsView.cpp
rename from nodeeditor-src/nodeeditor/src/GraphicsView.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/GraphicsView.cpp
diff --git a/nodeeditor-src/nodeeditor/src/AbstractGraphModel.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/AbstractGraphModel.cpp
rename from nodeeditor-src/nodeeditor/src/AbstractGraphModel.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/AbstractGraphModel.cpp
