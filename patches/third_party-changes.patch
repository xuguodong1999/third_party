Subject: [PATCH] third_party-changes
---
Index: openbabel-src/openbabel/src/formats/gamessukformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/gamessukformat.cpp b/openbabel-src/openbabel/src/formats/gamessukformat.cpp
--- a/openbabel-src/openbabel/src/formats/gamessukformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/gamessukformat.cpp	(date 1714440647078)
@@ -23,12 +23,7 @@
 
 #include <algorithm>
 #include <cmath>
-
-#ifdef _MSC_VER
 #include <regex>
-#else
-#include <regex.h>
-#endif
 
 using namespace std;
 
@@ -797,20 +792,15 @@
     //                     ------label--------   -------charge-------- < seems enough for a match
     string pattern(" *\\* *[a-zA-Z]{1,2}[0-9]* *[0-9]{1,3}\\.[0-9]{1}");
     bool iok;
-#ifdef _MSC_VER
-    std::tr1::regex myregex;
+    std::regex myregex;
     try {
       myregex.assign(pattern,
-                     std::tr1::regex_constants::extended |
-                     std::tr1::regex_constants::nosubs);
+                     std::regex_constants::extended |
+                     std::regex_constants::nosubs);
       iok = true;
-    } catch (std::tr1::regex_error ex) {
+    } catch (std::regex_error ex) {
       iok = false;
     }
-#else
-    regex_t *myregex = new regex_t;
-    iok = regcomp(myregex, pattern.c_str(), REG_EXTENDED | REG_NOSUB)==0;
-#endif
     if (!iok) cerr << "Error compiling regex in GUK OUTPUT!\n";
 
     // Read in the coordinates - we process them directly rather
@@ -820,11 +810,7 @@
 
       // End of geometry block
       if (strstr(buffer, "*************************") != nullptr) break;
-#ifdef _MSC_VER
-      if (std::tr1::regex_search(buffer, myregex)) {
-#else
-        if (regexec(myregex, buffer, 0, nullptr, 0) == 0) {
-#endif
+      if (std::regex_search(buffer, myregex)) {
           //cerr << "Got Coord line: " << buffer << endl;
           OBAtom *atom = mol.NewAtom();
           tokenize(tokens,buffer," ");
@@ -841,9 +827,6 @@
         }
       }
       mol.EndModify();
-#ifndef _MSC_VER
-      regfree(myregex);
-#endif
       return true;
     } // End ReadInitalCartesian
 
Index: openbabel-src/openbabel/src/formats/chemkinformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/chemkinformat.cpp b/openbabel-src/openbabel/src/formats/chemkinformat.cpp
--- a/openbabel-src/openbabel/src/formats/chemkinformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/chemkinformat.cpp	(date 1714440647078)
@@ -726,7 +726,7 @@
 
   string missing; // list of molecules which do not have thermodata
   OBConversion StdThermConv;
-  ifstream stdthermo;
+  istringstream stdthermo;
   OpenDatafile(stdthermo, datafilename);
   if(!stdthermo)
   {
Index: spdlog-src/spdlog/include/spdlog/fmt/bundled/core.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/spdlog-src/spdlog/include/spdlog/fmt/bundled/core.h b/spdlog-src/spdlog/include/spdlog/fmt/bundled/core.h
--- a/spdlog-src/spdlog/include/spdlog/fmt/bundled/core.h	(revision 7e635fca68d014934b4af8a1cf874f63989352b7)
+++ b/spdlog-src/spdlog/include/spdlog/fmt/bundled/core.h	(date 1714440647078)
@@ -94,7 +94,7 @@
 #ifndef FMT_USE_CONSTEXPR
 #  if (FMT_HAS_FEATURE(cxx_relaxed_constexpr) || FMT_MSC_VERSION >= 1912 || \
        (FMT_GCC_VERSION >= 600 && FMT_CPLUSPLUS >= 201402L)) &&             \
-      !FMT_ICC_VERSION && !defined(__NVCC__)
+      !FMT_ICC_VERSION && (!defined(__NVCC__) || __CUDACC_VER_MAJOR__ >= 12)
 #    define FMT_USE_CONSTEXPR 1
 #  else
 #    define FMT_USE_CONSTEXPR 0
Index: openbabel-src/openbabel/src/formats/svgformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/svgformat.cpp b/openbabel-src/openbabel/src/formats/svgformat.cpp
--- a/openbabel-src/openbabel/src/formats/svgformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/svgformat.cpp	(date 1714440647078)
@@ -513,7 +513,7 @@
 //returns true if the file "svgformat.script" was inserted into the output
 bool SVGFormat::EmbedScript(ostream& ofs)
 {
-  ifstream ifs;
+  istringstream ifs;
   if(!ifs || OpenDatafile(ifs, "svgformat.script").empty())
     return false;
   ofs << ifs.rdbuf(); //copy whole file
Index: openbabel-src/openbabel/src/formats/pdbqtformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/pdbqtformat.cpp b/openbabel-src/openbabel/src/formats/pdbqtformat.cpp
--- a/openbabel-src/openbabel/src/formats/pdbqtformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/pdbqtformat.cpp	(date 1714440647078)
@@ -483,7 +483,7 @@
     return mol.DeleteNonPolarHydrogens();
   }
 
-  bool OutputTree(OBConversion* pConv, OBMol& mol, ostream& ofs, map <unsigned int, branch> & tree, unsigned int depth, bool moves_many, bool preserve_original_index)
+  bool OutputTree(OBConversion* pConv, OBMol& mol, ostream& ofs, map <size_t, branch> & tree, unsigned int depth, bool moves_many, bool preserve_original_index)
   {
     if (tree.empty()) {return false;}
     if (depth>= tree.size()-1) {depth=tree.size()-1;}
@@ -607,7 +607,7 @@
     return true;
   }
 
-  void ConstructTree (map <unsigned int, branch>& tree, vector <vector <int> > rigid_fragments, unsigned int root_piece, const OBMol& mol, bool flexible)
+  void ConstructTree (map <size_t, branch>& tree, vector <vector <int> > rigid_fragments, unsigned int root_piece, const OBMol& mol, bool flexible)
   {
     unsigned int first_atom = 0;
     unsigned int second_atom = 0;
@@ -651,7 +651,7 @@
             sprog.rigid_with.insert(sprog.index);
 
             (*tree.find(position)).second.children.insert(tree.size()); //tells the current parent it has an extra child
-                        tree.insert(pair<unsigned int, branch> (tree.size(), sprog)); //adds the current branch to the tree
+                        tree.insert(std::make_pair(tree.size(), sprog)); //adds the current branch to the tree
 
             rigid_fragments.erase(rigid_fragments.begin() + i);
             sterile=false;
@@ -747,7 +747,7 @@
     return false;
   }
 
-  unsigned int AtomsSoFar(const map <unsigned int, branch> & tree, unsigned int depth)
+  unsigned int AtomsSoFar(const map <size_t, branch> & tree, unsigned int depth)
   {
     if (depth > tree.size()) {return 0;}
     unsigned int numberAtoms=0;
@@ -985,7 +985,7 @@
 
       vector <vector <int> > rigid_fragments; //the vector of all the rigid molecule fragments, using atom indexes
       unsigned int best_root_atom=1;
-      map <unsigned int, branch> tree;
+      map <size_t, branch> tree;
       unsigned int torsdof=0;
       unsigned int root_piece=0;
       unsigned int rotatable_bonds=0;
Index: openbabel-src/openbabel/src/formats/vaspformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/vaspformat.cpp b/openbabel-src/openbabel/src/formats/vaspformat.cpp
--- a/openbabel-src/openbabel/src/formats/vaspformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/vaspformat.cpp	(date 1714440647078)
@@ -532,7 +532,7 @@
             for (size_t natom = 0; natom < pmol->NumAtoms(); ++natom) {
               const vector3 dxyz = currXyz[natom] - prevXyz[natom];
               vector3::const_iterator iter = std::find_if(dxyz.begin(), dxyz.end(),
-                      std::bind2nd(std::not_equal_to<double>(), 0.0));
+                      std::bind(std::not_equal_to<double>(), std::placeholders::_1, 0.0));
               if (iter != dxyz.end()) dipGrad[natom].SetRow(iter - dxyz.begin(),
                                                             (currDm - prevDm) / *iter);
             }
@@ -586,7 +586,7 @@
       if (max != 0.0) {
         // Normalize
         std::transform(Intensities.begin(), Intensities.end(), Intensities.begin(),
-                       std::bind2nd(std::divides<double>(), max / 100.0));
+                       std::bind(std::divides<double>(), std::placeholders::_1, max / 100.0));
       } else {
         Intensities.clear();
       }
Index: openbabel-src/openbabel/src/formats/orcaformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/orcaformat.cpp b/openbabel-src/openbabel/src/formats/orcaformat.cpp
--- a/openbabel-src/openbabel/src/formats/orcaformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/orcaformat.cpp	(date 1714440647078)
@@ -24,11 +24,7 @@
 #include <openbabel/generic.h>
 #include <cstdlib>
 
-#ifdef _MSC_VER
 #include <regex>
-#else
-#include <regex.h>
-#endif
 
 #include <iomanip>
 
@@ -696,38 +692,22 @@
 
 // small function to avoid wrong parsing
 // if there is no whitespace between the numbers in the column structure
-#ifdef _MSC_VER
   string OrcaOutputFormat::checkColumns(string checkBuffer)
   {
     string pattern ("[0-9]-");
-    std::tr1::regex myregex;
-    std::tr1::smatch pm;
+    std::regex myregex;
+    std::smatch pm;
     try {
       myregex.assign(pattern,
-                     std::tr1::regex_constants::extended);
+                     std::regex_constants::extended);
       //iok = true;
-    } catch (std::tr1::regex_error ex) {
+    } catch (std::regex_error ex) {
         return (checkBuffer); // do nothing
       //iok = false;
     }
-    while (std::tr1::regex_search (checkBuffer,pm,myregex)) {
+    while (std::regex_search (checkBuffer,pm,myregex)) {
         checkBuffer.insert(pm.position(0)+1, " ");
     }
     return (checkBuffer);
   }
-#else
-  string OrcaOutputFormat::checkColumns(string checkBuffer)
-  {
-      string pattern ("[0-9]-");
-      regmatch_t pm;
-      regex_t myregex;
-      int pos = regcomp(&myregex, pattern.c_str(), REG_EXTENDED);
-      if (pos !=0) return (checkBuffer); // do nothing
-
-      while (regexec(&myregex, checkBuffer.c_str(), 1, &pm, REG_EXTENDED) == 0) {
-          checkBuffer.insert(pm.rm_eo-1, " ");  // insert whitespace to separate the columns
-      }
-      return (checkBuffer);
-  }
-#endif
 } //namespace OpenBabel
Index: openbabel-src/openbabel/src/formats/exampleformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/exampleformat.cpp b/openbabel-src/openbabel/src/formats/exampleformat.cpp
--- a/openbabel-src/openbabel/src/formats/exampleformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/exampleformat.cpp	(date 1714440647078)
@@ -32,6 +32,7 @@
 
 #include <openbabel/babelconfig.h>
 #include <openbabel/obmolecformat.h>
+#include <openbabel/mol.h>
 
 using namespace std;
 namespace OpenBabel
Index: openbabel-src/openbabel/src/formats/nwchemformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/nwchemformat.cpp b/openbabel-src/openbabel/src/formats/nwchemformat.cpp
--- a/openbabel-src/openbabel/src/formats/nwchemformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/nwchemformat.cpp	(date 1714440647078)
@@ -303,10 +303,11 @@
         blank_line = false;
         if (vs[0][0] == '0')
             charge = atoi(vs[4].c_str());
-        else if (vs[0][0] == '1')
+        else if (vs[0][0] == '1') {
             for (unsigned int i = 0; i < 3; i++)
                 if (vs[i+1][0] == '1')
                     dipole[i] = atof(vs[4].c_str());
+        }
         else if (vs[0][0] == '2')
         {
             double value = atof(vs[4].c_str());
Index: opencv-src/opencv/modules/highgui/src/window_QT.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/highgui/src/window_QT.cpp b/opencv-src/opencv/modules/highgui/src/window_QT.cpp
--- a/opencv-src/opencv/modules/highgui/src/window_QT.cpp	(revision dad8af6b17f8e60d7b95a1203a1b4d22f56574cf)
+++ b/opencv-src/opencv/modules/highgui/src/window_QT.cpp	(date 1714440647078)
@@ -438,7 +438,7 @@
 
     //This is not a very clean way to do the stuff. Indeed, QAction automatically generate toolTil (QLabel)
     //that can be grabbed here and crash the code at 'w->param_name==name'.
-    foreach (QWidget* widget, QApplication::topLevelWidgets())
+    Q_FOREACH (QWidget* widget, QApplication::topLevelWidgets())
     {
         if (widget->isWindow() && !widget->parentWidget())//is a window without parent
         {
@@ -529,7 +529,7 @@
     //"For any GUI application using Qt, there is precisely one QApplication object"
     if (!QApplication::instance())
     {
-#if QT_VERSION >= QT_VERSION_CHECK(5, 6, 0)
+#if QT_VERSION >= QT_VERSION_CHECK(5, 6, 0) and QT_VERSION <= QT_VERSION_CHECK(6, 0, 0)
         QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling, true);
 #endif
         new QApplication(*c, v);
@@ -1182,7 +1182,7 @@
 void GuiReceiver::enablePropertiesButtonEachWindow()
 {
     //For each window, enable window property button
-    foreach (QWidget* widget, QApplication::topLevelWidgets())
+    Q_FOREACH (QWidget* widget, QApplication::topLevelWidgets())
     {
         if (widget->isWindow() && !widget->parentWidget()) //is a window without parent
         {
@@ -2133,7 +2133,7 @@
     myToolBar = new QToolBar(this);
     myToolBar->setFloatable(false); //is not a window
 
-    foreach (QAction *a, vect_QActions)
+    Q_FOREACH (QAction *a, vect_QActions)
         myToolBar->addAction(a);
 }
 
@@ -2801,7 +2801,7 @@
     {
         QMenu menu(this);
 
-        foreach (QAction *a, centralWidget->vect_QActions)
+        Q_FOREACH (QAction *a, centralWidget->vect_QActions)
             menu.addAction(a);
 
         menu.exec(evnt->globalPos());
Index: openbabel-src/openbabel/src/formats/fchkformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/fchkformat.cpp b/openbabel-src/openbabel/src/formats/fchkformat.cpp
--- a/openbabel-src/openbabel/src/formats/fchkformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/fchkformat.cpp	(date 1714440647078)
@@ -665,16 +665,16 @@
            no atom numbers < 0 or > Natoms */
         if (NBond.end() != find_if(NBond.begin(),
                                    NBond.end(),
-                                   bind2nd(less_equal<int>(), 0)) ||
+                                   bind(less_equal<int>(), std::placeholders::_1, 0)) ||
             NBond.end() != find_if(NBond.begin(),
                                    NBond.end(),
-                                   bind2nd(greater<int>(), MxBond)) ||
+                                   bind(greater<int>(), std::placeholders::_1, MxBond)) ||
             IBond.end() != find_if(IBond.begin(),
                                    IBond.end(),
-                                   bind2nd(less<int>(), 0)) ||
+                                   bind(less<int>(), std::placeholders::_1, 0)) ||
             IBond.end() != find_if(IBond.begin(),
                                    IBond.end(),
-                                   bind2nd(greater<int>(), Natoms)))
+                                   bind(greater<int>(), std::placeholders::_1, Natoms)))
           {
             error_msg << "Invalid connectivity : check the \"NBond\" and/or"
                       << " \"IBond\" section(s).";
Index: openbabel-src/openbabel/src/formats/mdffformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/mdffformat.cpp b/openbabel-src/openbabel/src/formats/mdffformat.cpp
--- a/openbabel-src/openbabel/src/formats/mdffformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/mdffformat.cpp	(date 1714440647078)
@@ -30,9 +30,13 @@
 #include <algorithm>
 
 #ifdef _MSC_VER
+#ifndef INFINITY
 #define INFINITY (DBL_MAX+DBL_MAX)
+#endif
+#ifndef NAN
 #define NAN (INFINITY-INFINITY)
 #endif
+#endif
 
 using namespace std;
 namespace OpenBabel {
@@ -133,7 +137,7 @@
     //    path = buffer;
     string full_path = pConv->GetInFilename();
     size_t found = full_path.rfind("/");
-    string path = (found == string::npos) ? "" : path.substr(0, found);
+    string path = (found == string::npos) ? "" : full_path.substr(0, found);
     string short_fn = full_path.substr(path.length(), string::npos);
 
     // Open files
Index: ncnn-src/ncnn/cmake/ncnn_generate_shader_comp_header.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/cmake/ncnn_generate_shader_comp_header.cmake b/ncnn-src/ncnn/cmake/ncnn_generate_shader_comp_header.cmake
--- a/ncnn-src/ncnn/cmake/ncnn_generate_shader_comp_header.cmake	(revision 56775de50990ab7f16627efdcf5529b49541206f)
+++ b/ncnn-src/ncnn/cmake/ncnn_generate_shader_comp_header.cmake	(date 1714440647078)
@@ -18,8 +18,8 @@
 get_filename_component(SHADER_SRC_NAME_WE ${SHADER_SRC} NAME_WE)
 
 # text to hex
-file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/layer/vulkan/shader/${SHADER_SRC_NAME_WE}.text2hex.txt "${comp_data}")
-file(READ ${CMAKE_CURRENT_BINARY_DIR}/layer/vulkan/shader/${SHADER_SRC_NAME_WE}.text2hex.txt comp_data_hex HEX)
+file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/generated/ncnn/tmp/${SHADER_SRC_NAME_WE}.text2hex.txt "${comp_data}")
+file(READ ${CMAKE_CURRENT_BINARY_DIR}/generated/ncnn/tmp/${SHADER_SRC_NAME_WE}.text2hex.txt comp_data_hex HEX)
 string(REGEX REPLACE "([0-9a-f][0-9a-f])" "0x\\1," comp_data_hex ${comp_data_hex})
 string(FIND "${comp_data_hex}" "," tail_comma REVERSE)
 string(SUBSTRING "${comp_data_hex}" 0 ${tail_comma} comp_data_hex)
Index: opencv-src/opencv/modules/highgui/src/window_QT.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/highgui/src/window_QT.h b/opencv-src/opencv/modules/highgui/src/window_QT.h
--- a/opencv-src/opencv/modules/highgui/src/window_QT.h	(revision dad8af6b17f8e60d7b95a1203a1b4d22f56574cf)
+++ b/opencv-src/opencv/modules/highgui/src/window_QT.h	(date 1714440647078)
@@ -68,7 +68,7 @@
 #include <QBoxLayout>
 #include <QSettings>
 #include <qtimer.h>
-#include <QtConcurrentRun>
+#include <QtConcurrent/QtConcurrentRun>
 #include <QWaitCondition>
 #include <QKeyEvent>
 #include <QMetaObject>
@@ -96,17 +96,17 @@
 enum { CV_MODE_NORMAL = 0, CV_MODE_OPENGL = 1 };
 
 //we can change the keyboard shortcuts from here !
-enum {	shortcut_zoom_normal 	= Qt::CTRL + Qt::Key_Z,
-        shortcut_zoom_imgRegion = Qt::CTRL + Qt::Key_X,
-        shortcut_save_img		= Qt::CTRL + Qt::Key_S,
-        shortcut_copy_clipbrd   = Qt::CTRL + Qt::Key_C,
-        shortcut_properties_win	= Qt::CTRL + Qt::Key_P,
-        shortcut_zoom_in 		= Qt::CTRL + Qt::Key_Plus,//QKeySequence(QKeySequence::ZoomIn),
-        shortcut_zoom_out		= Qt::CTRL + Qt::Key_Minus,//QKeySequence(QKeySequence::ZoomOut),
-        shortcut_panning_left 	= Qt::CTRL + Qt::Key_Left,
-        shortcut_panning_right 	= Qt::CTRL + Qt::Key_Right,
-        shortcut_panning_up 	= Qt::CTRL + Qt::Key_Up,
-        shortcut_panning_down 	= Qt::CTRL + Qt::Key_Down
+enum {	shortcut_zoom_normal 	= (int)Qt::CTRL + Qt::Key_Z,
+        shortcut_zoom_imgRegion = (int)Qt::CTRL + Qt::Key_X,
+        shortcut_save_img		= (int)Qt::CTRL + Qt::Key_S,
+        shortcut_copy_clipbrd   = (int)Qt::CTRL + Qt::Key_C,
+        shortcut_properties_win	= (int)Qt::CTRL + Qt::Key_P,
+        shortcut_zoom_in 		= (int)Qt::CTRL + Qt::Key_Plus,//QKeySequence(QKeySequence::ZoomIn),
+        shortcut_zoom_out		= (int)Qt::CTRL + Qt::Key_Minus,//QKeySequence(QKeySequence::ZoomOut),
+        shortcut_panning_left 	= (int)Qt::CTRL + Qt::Key_Left,
+        shortcut_panning_right 	= (int)Qt::CTRL + Qt::Key_Right,
+        shortcut_panning_up 	= (int)Qt::CTRL + Qt::Key_Up,
+        shortcut_panning_down 	= (int)Qt::CTRL + Qt::Key_Down
     };
 //end enum
 
@@ -128,7 +128,7 @@
     bool bTimeOut;
     QTimer* timer;
 
-public slots:
+public Q_SLOTS:
     void createWindow( QString name, int flags = 0 );
     void destroyWindow(QString name);
     void destroyAllWindow();
@@ -204,7 +204,7 @@
     CvButtonCallback callback;
     void* userdata;
 
-private slots:
+private Q_SLOTS:
     void callCallBack(bool);
 };
 
@@ -221,7 +221,7 @@
     CvButtonCallback callback;
     void* userdata;
 
-private slots:
+private Q_SLOTS:
     void callCallBack(bool);
 };
 
@@ -238,7 +238,7 @@
     CvButtonCallback callback;
     void* userdata;
 
-private slots:
+private Q_SLOTS:
     void callCallBack(bool);
 };
 
@@ -252,7 +252,7 @@
 
     QPointer<QSlider> slider;
 
-private slots:
+private Q_SLOTS:
     void createDialog();
     void update(int myvalue);
 
@@ -377,7 +377,7 @@
     void showTools();
     QSize getAvailableSize();
 
-private slots:
+private Q_SLOTS:
     void displayPropertiesWin();
 };
 
@@ -518,7 +518,7 @@
 
     void setSize(QSize size_) CV_OVERRIDE;
 
-public slots:
+public Q_SLOTS:
     //reference:
     //http://www.qtcentre.org/wiki/index.php?title=QGraphicsView:_Smooth_Panning_and_Zooming
     //http://doc.qt.nokia.com/4.6/gestures-imagegestures-imagewidget-cpp.html
@@ -585,7 +585,7 @@
 
     void icvmouseProcessing(QPointF pt, int cv_event, int flags) CV_OVERRIDE;
 
-private slots:
+private Q_SLOTS:
     void stopDisplayInfo();
 };
 
Index: rdkit-src/rdkit/Contrib/PBF/PBFRDKit.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Contrib/PBF/PBFRDKit.cpp b/rdkit-src/rdkit/Contrib/PBF/PBFRDKit.cpp
--- a/rdkit-src/rdkit/Contrib/PBF/PBFRDKit.cpp	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Contrib/PBF/PBFRDKit.cpp	(date 1714440647078)
@@ -114,7 +114,7 @@
   if (eigensolver.info() != Eigen::Success) {
     BOOST_LOG(rdErrorLog) << "eigenvalue calculation did not converge"
                           << std::endl;
-    return 0.0;
+    return false;
   }
   RDGeom::Point3D normal;
   normal.x = eigensolver.eigenvectors()(0, 0);
@@ -125,6 +125,7 @@
   plane[1] = normal.y;
   plane[2] = normal.z;
   plane[3] = -1 * normal.dotProduct(origin);
+  return true;
 }
 
 double PBFRD(ROMol &mol, int confId) {
Index: ncnn-src/ncnn/cmake/ncnn_add_layer.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/cmake/ncnn_add_layer.cmake b/ncnn-src/ncnn/cmake/ncnn_add_layer.cmake
--- a/ncnn-src/ncnn/cmake/ncnn_add_layer.cmake	(revision 56775de50990ab7f16627efdcf5529b49541206f)
+++ b/ncnn-src/ncnn/cmake/ncnn_add_layer.cmake	(date 1714440647078)
@@ -1,28 +1,28 @@
-
+set(_CURRENT_DIR ${CMAKE_CURRENT_LIST_DIR})
 macro(ncnn_add_arch_opt_layer class NCNN_TARGET_ARCH_OPT NCNN_TARGET_ARCH_OPT_CFLAGS)
-    set(NCNN_${NCNN_TARGET_ARCH}_HEADER ${CMAKE_CURRENT_SOURCE_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.h)
-    set(NCNN_${NCNN_TARGET_ARCH}_SOURCE ${CMAKE_CURRENT_SOURCE_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.cpp)
+    set(NCNN_${NCNN_TARGET_ARCH}_HEADER ${_CURRENT_DIR}/../src/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.h)
+    set(NCNN_${NCNN_TARGET_ARCH}_SOURCE ${_CURRENT_DIR}/../src/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.cpp)
 
-    if(WITH_LAYER_${name} AND EXISTS ${NCNN_${NCNN_TARGET_ARCH}_HEADER} AND EXISTS ${NCNN_${NCNN_TARGET_ARCH}_SOURCE})
+    if (WITH_LAYER_${name} AND EXISTS ${NCNN_${NCNN_TARGET_ARCH}_HEADER} AND EXISTS ${NCNN_${NCNN_TARGET_ARCH}_SOURCE})
 
-        set(NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER ${CMAKE_CURRENT_BINARY_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.h)
-        set(NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE ${CMAKE_CURRENT_BINARY_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.cpp)
+        set(NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER ${CMAKE_CURRENT_BINARY_DIR}/generated/ncnn/include/ncnn/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.h)
+        set(NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE ${CMAKE_CURRENT_BINARY_DIR}/generated/ncnn/src/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.cpp)
 
         add_custom_command(
-            OUTPUT ${NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER}
-            COMMAND ${CMAKE_COMMAND} -DSRC=${NCNN_${NCNN_TARGET_ARCH}_HEADER} -DDST=${NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER} -DCLASS=${class} -P "${CMAKE_CURRENT_SOURCE_DIR}/../cmake/ncnn_generate_${NCNN_TARGET_ARCH_OPT}_source.cmake"
-            DEPENDS ${NCNN_${NCNN_TARGET_ARCH}_HEADER}
-            COMMENT "Generating source ${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.h"
-            VERBATIM
+                OUTPUT ${NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER}
+                COMMAND ${CMAKE_COMMAND} -DSRC=${NCNN_${NCNN_TARGET_ARCH}_HEADER} -DDST=${NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER} -DCLASS=${class} -P "${_CURRENT_DIR}/ncnn_generate_${NCNN_TARGET_ARCH_OPT}_source.cmake"
+                DEPENDS ${NCNN_${NCNN_TARGET_ARCH}_HEADER}
+                COMMENT "Generating source ${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.h"
+                VERBATIM
         )
         set_source_files_properties(${NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER} PROPERTIES GENERATED TRUE)
 
         add_custom_command(
-            OUTPUT ${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE}
-            COMMAND ${CMAKE_COMMAND} -DSRC=${NCNN_${NCNN_TARGET_ARCH}_SOURCE} -DDST=${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE} -DCLASS=${class} -P "${CMAKE_CURRENT_SOURCE_DIR}/../cmake/ncnn_generate_${NCNN_TARGET_ARCH_OPT}_source.cmake"
-            DEPENDS ${NCNN_${NCNN_TARGET_ARCH}_SOURCE}
-            COMMENT "Generating source ${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.cpp"
-            VERBATIM
+                OUTPUT ${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE}
+                COMMAND ${CMAKE_COMMAND} -DSRC=${NCNN_${NCNN_TARGET_ARCH}_SOURCE} -DDST=${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE} -DCLASS=${class} -P "${_CURRENT_DIR}/ncnn_generate_${NCNN_TARGET_ARCH_OPT}_source.cmake"
+                DEPENDS ${NCNN_${NCNN_TARGET_ARCH}_SOURCE}
+                COMMENT "Generating source ${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.cpp"
+                VERBATIM
         )
         set_source_files_properties(${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE} PROPERTIES GENERATED TRUE)
 
@@ -46,7 +46,7 @@
 endmacro()
 
 macro(ncnn_add_arch_opt_source class NCNN_TARGET_ARCH_OPT NCNN_TARGET_ARCH_OPT_CFLAGS)
-    set(NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE ${CMAKE_CURRENT_SOURCE_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.cpp)
+    set(NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE ${_CURRENT_DIR}/../src/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.cpp)
 
     if(WITH_LAYER_${name} AND EXISTS ${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE})
         set_source_files_properties(${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE} PROPERTIES COMPILE_FLAGS ${NCNN_TARGET_ARCH_OPT_CFLAGS})
@@ -59,9 +59,9 @@
 
     # WITH_LAYER_xxx option
     if(${ARGC} EQUAL 2)
-        option(WITH_LAYER_${name} "build with layer ${name}" ${ARGV1})
+        set(WITH_LAYER_${name} ${ARGV1})
     else()
-        option(WITH_LAYER_${name} "build with layer ${name}" ON)
+        set(WITH_LAYER_${name} ON)
     endif()
 
     if(NCNN_CMAKE_VERBOSE)
@@ -69,17 +69,17 @@
     endif()
 
     if(WITH_LAYER_${name})
-        list(APPEND ncnn_SRCS ${CMAKE_CURRENT_SOURCE_DIR}/layer/${name}.cpp)
+        list(APPEND ncnn_SRCS ${_CURRENT_DIR}/../src/layer/${name}.cpp)
 
         # look for arch specific implementation and append source
         # optimized implementation for armv7, aarch64 or x86
-        set(LAYER_ARCH_SRC ${CMAKE_CURRENT_SOURCE_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.cpp)
+        set(LAYER_ARCH_SRC ${_CURRENT_DIR}/../src/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.cpp)
         if(EXISTS ${LAYER_ARCH_SRC})
             set(WITH_LAYER_${name}_${NCNN_TARGET_ARCH} 1)
             list(APPEND ncnn_SRCS ${LAYER_ARCH_SRC})
         endif()
 
-        set(LAYER_VULKAN_SRC ${CMAKE_CURRENT_SOURCE_DIR}/layer/vulkan/${name}_vulkan.cpp)
+        set(LAYER_VULKAN_SRC ${_CURRENT_DIR}/../src/layer/vulkan/${name}_vulkan.cpp)
         if(NCNN_VULKAN AND EXISTS ${LAYER_VULKAN_SRC})
             set(WITH_LAYER_${name}_vulkan 1)
             list(APPEND ncnn_SRCS ${LAYER_VULKAN_SRC})
@@ -91,28 +91,28 @@
         set(layer_declaration "${layer_declaration}#include \"layer/${name}.h\"\n")
         set(layer_declaration "${layer_declaration}namespace ncnn { DEFINE_LAYER_CREATOR(${class}) }\n")
 
-        source_group ("sources\\\\layers" FILES "${CMAKE_CURRENT_SOURCE_DIR}/layer/${name}.cpp")
+        source_group ("sources\\\\layers" FILES "${_CURRENT_DIR}/../src/layer/${name}.cpp")
     endif()
 
     if(WITH_LAYER_${name}_${NCNN_TARGET_ARCH})
         set(layer_declaration "${layer_declaration}#include \"layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.h\"\n")
         set(layer_declaration "${layer_declaration}namespace ncnn { DEFINE_LAYER_CREATOR(${class}_${NCNN_TARGET_ARCH}) }\n")
 
-        source_group ("sources\\\\layers\\\\${NCNN_TARGET_ARCH}" FILES "${CMAKE_CURRENT_SOURCE_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.cpp")
+        source_group ("sources\\\\layers\\\\${NCNN_TARGET_ARCH}" FILES "${_CURRENT_DIR}/../src/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.cpp")
     endif()
 
     if(WITH_LAYER_${name}_vulkan)
         set(layer_declaration "${layer_declaration}#include \"layer/vulkan/${name}_vulkan.h\"\n")
         set(layer_declaration "${layer_declaration}namespace ncnn { DEFINE_LAYER_CREATOR(${class}_vulkan) }\n")
 
-        file(GLOB_RECURSE NCNN_SHADER_SRCS "layer/vulkan/shader/${name}.comp")
-        file(GLOB_RECURSE NCNN_SHADER_SUBSRCS "layer/vulkan/shader/${name}_*.comp")
+        file(GLOB_RECURSE NCNN_SHADER_SRCS "${_CURRENT_DIR}/../src/layer/vulkan/shader/${name}.comp")
+        file(GLOB_RECURSE NCNN_SHADER_SUBSRCS "${_CURRENT_DIR}/../src/layer/vulkan/shader/${name}_*.comp")
         list(APPEND NCNN_SHADER_SRCS ${NCNN_SHADER_SUBSRCS})
         foreach(NCNN_SHADER_SRC ${NCNN_SHADER_SRCS})
             ncnn_add_shader(${NCNN_SHADER_SRC})
         endforeach()
 
-        source_group ("sources\\\\layers\\\\vulkan" FILES "${CMAKE_CURRENT_SOURCE_DIR}/layer/vulkan/${name}_vulkan.cpp")
+        source_group ("sources\\\\layers\\\\vulkan" FILES "${_CURRENT_DIR}/../src/layer/vulkan/${name}_vulkan.cpp")
     endif()
 
     if(WITH_LAYER_${name})
Index: openbabel-src/openbabel/src/formats/xtcformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/xtcformat.cpp b/openbabel-src/openbabel/src/formats/xtcformat.cpp
--- a/openbabel-src/openbabel/src/formats/xtcformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/xtcformat.cpp	(date 1714440647078)
@@ -29,7 +29,7 @@
 #include <vector>
 
 #define MAXID 20
-#define MAXABS INT_MAX-2
+#define MAXABS float(INT_MAX-2)
 
 #ifndef MIN
 #define MIN(x,y) ((x) < (y) ? (x):(y))
Index: ncnn-src/ncnn/cmake/ncnn_add_shader.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/cmake/ncnn_add_shader.cmake b/ncnn-src/ncnn/cmake/ncnn_add_shader.cmake
--- a/ncnn-src/ncnn/cmake/ncnn_add_shader.cmake	(revision 56775de50990ab7f16627efdcf5529b49541206f)
+++ b/ncnn-src/ncnn/cmake/ncnn_add_shader.cmake	(date 1714440647078)
@@ -1,11 +1,11 @@
-
+set(_CURRENT_DIR ${CMAKE_CURRENT_LIST_DIR})
 macro(ncnn_add_shader NCNN_SHADER_SRC)
     get_filename_component(NCNN_SHADER_SRC_NAME_WE ${NCNN_SHADER_SRC} NAME_WE)
-    set(NCNN_SHADER_COMP_HEADER ${CMAKE_CURRENT_BINARY_DIR}/layer/vulkan/shader/${NCNN_SHADER_SRC_NAME_WE}.comp.hex.h)
+    set(NCNN_SHADER_COMP_HEADER ${CMAKE_CURRENT_BINARY_DIR}/generated/ncnn/include/ncnn/layer/vulkan/shader/${NCNN_SHADER_SRC_NAME_WE}.comp.hex.h)
 
     add_custom_command(
         OUTPUT ${NCNN_SHADER_COMP_HEADER}
-        COMMAND ${CMAKE_COMMAND} -DSHADER_SRC=${NCNN_SHADER_SRC} -DSHADER_COMP_HEADER=${NCNN_SHADER_COMP_HEADER} -P "${CMAKE_CURRENT_SOURCE_DIR}/../cmake/ncnn_generate_shader_comp_header.cmake"
+        COMMAND ${CMAKE_COMMAND} -DSHADER_SRC=${NCNN_SHADER_SRC} -DSHADER_COMP_HEADER=${NCNN_SHADER_COMP_HEADER} -P "${_CURRENT_DIR}/ncnn_generate_shader_comp_header.cmake"
         DEPENDS ${NCNN_SHADER_SRC}
         COMMENT "Preprocessing shader source ${NCNN_SHADER_SRC_NAME_WE}.comp"
         VERBATIM
Index: rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupFingerprintScore.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupFingerprintScore.cpp b/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupFingerprintScore.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupFingerprintScore.cpp	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupFingerprintScore.cpp	(date 1714440647078)
@@ -12,7 +12,7 @@
 #include "GraphMol/Fingerprints/Fingerprints.h"
 #include "GraphMol//Fingerprints/MorganFingerprints.h"
 #include <GraphMol/SmilesParse/SmilesParse.h>
-#include "../../../External/GA/util/Util.h"
+#include "GA/util/Util.h"
 #include <memory>
 #include <utility>
 #include <vector>
Index: arrow-src/arrow/cpp/src/arrow/status.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/arrow-src/arrow/cpp/src/arrow/status.h b/arrow-src/arrow/cpp/src/arrow/status.h
--- a/arrow-src/arrow/cpp/src/arrow/status.h	(revision 6a28035c2b49b432dc63f5ee7524d76b4ed2d762)
+++ b/arrow-src/arrow/cpp/src/arrow/status.h	(date 1714440647078)
@@ -129,7 +129,7 @@
 ///
 /// Additionally, if an error occurred, a specific error message is generally
 /// attached.
-class ARROW_EXPORT [[nodiscard]] Status : public util::EqualityComparable<Status>,
+class ARROW_EXPORT Status : public util::EqualityComparable<Status>,
                                           public util::ToStringOstreamable<Status> {
  public:
   // Create a success status.
Index: indigo-src/indigo/api/c/indigo/indigo.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/indigo.h b/indigo-src/indigo/api/c/indigo/indigo.h
--- a/indigo-src/indigo/api/c/indigo/indigo.h	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/indigo.h	(date 1714440647078)
@@ -20,36 +20,22 @@
 #define __indigo__
 
 #include <stdint.h>
+#include "indigo_export.h"
 
 #if defined(_WIN32) && !defined(__MINGW32__)
 #define qword unsigned __int64
 #else
 #define qword unsigned long long
 #endif
-
-#ifndef EXPORT_SYMBOL
-#ifdef _WIN32
-#define EXPORT_SYMBOL __declspec(dllexport)
-#elif (defined __GNUC__ || defined __APPLE__)
-#define EXPORT_SYMBOL __attribute__((visibility("default")))
-#else
-#define EXPORT_SYMBOL
-#endif
-#endif
-
-#ifndef CEXPORT
-#ifndef __cplusplus
-#define CEXPORT EXPORT_SYMBOL
-#else
-#define CEXPORT extern "C" EXPORT_SYMBOL
-#endif
-#endif
 
 #ifndef __byte_typedef__
 #define __byte_typedef__
 typedef unsigned char byte;
 #endif
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 /* All integer and float functions return -1 on error. */
 /* All string functions return zero pointer on error. */
 
@@ -58,55 +44,55 @@
 
 /* System */
 
-CEXPORT const char* indigoVersion();
-CEXPORT const char* indigoVersionInfo();
+INDIGO_EXPORT const char* indigoVersion();
+INDIGO_EXPORT const char* indigoVersionInfo();
 
 // Allocate a new session. Each session has its own
 // set of objects created and options set up.
-CEXPORT qword indigoAllocSessionId();
+INDIGO_EXPORT qword indigoAllocSessionId();
 // Switch to another session. The session, if was not allocated
 // previously, is allocated automatically and initialized with
 // empty set of objects and default options.
-CEXPORT void indigoSetSessionId(qword id);
+INDIGO_EXPORT void indigoSetSessionId(qword id);
 // Release session. The memory used by the released session
 // is not freed, but the number will be reused on
 // further allocations.
-CEXPORT void indigoReleaseSessionId(qword id);
+INDIGO_EXPORT void indigoReleaseSessionId(qword id);
 
 // Get the last error message
-CEXPORT const char* indigoGetLastError(void);
+INDIGO_EXPORT const char *indigoGetLastError(void);
 
-typedef void (*INDIGO_ERROR_HANDLER)(const char* message, void* context);
-CEXPORT void indigoSetErrorHandler(INDIGO_ERROR_HANDLER handler, void* context);
+typedef void (*INDIGO_ERROR_HANDLER)(const char *message, void *context);
+INDIGO_EXPORT void indigoSetErrorHandler(INDIGO_ERROR_HANDLER handler, void *context);
 
 // Free an object
-CEXPORT int indigoFree(int handle);
+INDIGO_EXPORT int indigoFree(int handle);
 // Clone an object
-CEXPORT int indigoClone(int object);
+INDIGO_EXPORT int indigoClone(int object);
 // Count object currently allocated
-CEXPORT int indigoCountReferences(void);
+INDIGO_EXPORT int indigoCountReferences(void);
 
 // Deallocate all the objects in the current session
-CEXPORT int indigoFreeAllObjects();
+INDIGO_EXPORT int indigoFreeAllObjects();
 
 /* Options */
 
-CEXPORT int indigoSetOption(const char* name, const char* value);
-CEXPORT int indigoSetOptionInt(const char* name, int value);
-CEXPORT int indigoSetOptionBool(const char* name, int value);
-CEXPORT int indigoSetOptionFloat(const char* name, float value);
-CEXPORT int indigoSetOptionColor(const char* name, float r, float g, float b);
-CEXPORT int indigoSetOptionXY(const char* name, int x, int y);
-CEXPORT int indigoResetOptions();
+INDIGO_EXPORT int indigoSetOption(const char *name, const char *value);
+INDIGO_EXPORT int indigoSetOptionInt(const char *name, int value);
+INDIGO_EXPORT int indigoSetOptionBool(const char *name, int value);
+INDIGO_EXPORT int indigoSetOptionFloat(const char *name, float value);
+INDIGO_EXPORT int indigoSetOptionColor(const char *name, float r, float g, float b);
+INDIGO_EXPORT int indigoSetOptionXY(const char *name, int x, int y);
+INDIGO_EXPORT int indigoResetOptions();
 
-CEXPORT const char* indigoGetOption(const char* name);
-CEXPORT int indigoGetOptionInt(const char* name, int* value);
-CEXPORT int indigoGetOptionBool(const char* name, int* value);
-CEXPORT int indigoGetOptionFloat(const char* name, float* value);
-CEXPORT int indigoGetOptionColor(const char* name, float* r, float* g, float* b);
-CEXPORT int indigoGetOptionXY(const char* name, int* x, int* y);
+INDIGO_EXPORT const char *indigoGetOption(const char *name);
+INDIGO_EXPORT int indigoGetOptionInt(const char *name, int *value);
+INDIGO_EXPORT int indigoGetOptionBool(const char *name, int *value);
+INDIGO_EXPORT int indigoGetOptionFloat(const char *name, float *value);
+INDIGO_EXPORT int indigoGetOptionColor(const char *name, float *r, float *g, float *b);
+INDIGO_EXPORT int indigoGetOptionXY(const char *name, int *x, int *y);
 
-CEXPORT const char* indigoGetOptionType(const char* name);
+INDIGO_EXPORT const char *indigoGetOptionType(const char *name);
 
 /* Basic input-output */
 
@@ -116,19 +102,19 @@
 // string/buffer. All these functions are low-level and
 // rarely needed to anyone.
 
-CEXPORT int indigoReadFile(const char* filename);
-CEXPORT int indigoReadString(const char* str);
-CEXPORT int indigoLoadString(const char* str);
-CEXPORT int indigoReadBuffer(const char* buffer, int size);
-CEXPORT int indigoLoadBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoReadFile(const char *filename);
+INDIGO_EXPORT int indigoReadString(const char *str);
+INDIGO_EXPORT int indigoLoadString(const char *str);
+INDIGO_EXPORT int indigoReadBuffer(const char *buffer, int size);
+INDIGO_EXPORT int indigoLoadBuffer(const char *buffer, int size);
 
 // indigoWrite*** return a new writer object.
 
-CEXPORT int indigoWriteFile(const char* filename);
-CEXPORT int indigoWriteBuffer(void);
+INDIGO_EXPORT int indigoWriteFile(const char *filename);
+INDIGO_EXPORT int indigoWriteBuffer(void);
 
 // Closes the file output stream but does not delete the object
-CEXPORT int indigoClose(int output);
+INDIGO_EXPORT int indigoClose(int output);
 
 /* Iterators */
 
@@ -160,78 +146,78 @@
  */
 
 // Obtains the next element, returns zero if there is no next element
-CEXPORT int indigoNext(int iter);
+INDIGO_EXPORT int indigoNext(int iter);
 // Does not obtain the next element, just tells if there is one
-CEXPORT int indigoHasNext(int iter);
+INDIGO_EXPORT int indigoHasNext(int iter);
 // Returns the index of the element
-CEXPORT int indigoIndex(int item);
+INDIGO_EXPORT int indigoIndex(int item);
 
 // Removes the item from its container (usually a molecule)
-CEXPORT int indigoRemove(int item);
+INDIGO_EXPORT int indigoRemove(int item);
 
 /* Molecules, query molecules, SMARTS */
 
-CEXPORT const char* indigoGetOriginalFormat(int item);
+INDIGO_EXPORT const char* indigoGetOriginalFormat(int item);
 
-CEXPORT int indigoCreateMolecule(void);
-CEXPORT int indigoCreateQueryMolecule(void);
+INDIGO_EXPORT int indigoCreateMolecule(void);
+INDIGO_EXPORT int indigoCreateQueryMolecule(void);
 
-CEXPORT int indigoLoadStructureFromString(const char* string, const char* params);
-CEXPORT int indigoLoadStructureFromBuffer(const byte* string, int bufferSize, const char* params);
-CEXPORT int indigoLoadStructureFromFile(const char* filename, const char* params);
+INDIGO_EXPORT int indigoLoadStructureFromString(const char* string, const char* params);
+INDIGO_EXPORT int indigoLoadStructureFromBuffer(const byte* string, int bufferSize, const char* params);
+INDIGO_EXPORT int indigoLoadStructureFromFile(const char* filename, const char* params);
 
-CEXPORT int indigoLoadMolecule(int source);
-CEXPORT int indigoLoadMoleculeFromString(const char* string);
-CEXPORT int indigoLoadMoleculeFromFile(const char* filename);
-CEXPORT int indigoLoadMoleculeFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadMolecule(int source);
+INDIGO_EXPORT int indigoLoadMoleculeFromString(const char* string);
+INDIGO_EXPORT int indigoLoadMoleculeFromFile(const char* filename);
+INDIGO_EXPORT int indigoLoadMoleculeFromBuffer(const char* buffer, int size);
 
-CEXPORT int indigoLoadQueryMolecule(int source);
-CEXPORT int indigoLoadQueryMoleculeFromString(const char* string);
-CEXPORT int indigoLoadQueryMoleculeFromFile(const char* filename);
-CEXPORT int indigoLoadQueryMoleculeFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadQueryMolecule(int source);
+INDIGO_EXPORT int indigoLoadQueryMoleculeFromString(const char* string);
+INDIGO_EXPORT int indigoLoadQueryMoleculeFromFile(const char* filename);
+INDIGO_EXPORT int indigoLoadQueryMoleculeFromBuffer(const char* buffer, int size);
 
-CEXPORT int indigoLoadSmarts(int source);
-CEXPORT int indigoLoadSmartsFromString(const char* string);
-CEXPORT int indigoLoadSmartsFromFile(const char* filename);
-CEXPORT int indigoLoadSmartsFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadSmarts(int source);
+INDIGO_EXPORT int indigoLoadSmartsFromString(const char* string);
+INDIGO_EXPORT int indigoLoadSmartsFromFile(const char* filename);
+INDIGO_EXPORT int indigoLoadSmartsFromBuffer(const char* buffer, int size);
 
-CEXPORT int indigoLoadSequence(int source, const char* seq_type);
-CEXPORT int indigoLoadSequenceFromString(const char* string, const char* seq_type);
-CEXPORT int indigoLoadSequenceFromFile(const char* filename, const char* seq_type);
+INDIGO_EXPORT int indigoLoadSequence(int source, const char* seq_type);
+INDIGO_EXPORT int indigoLoadSequenceFromString(const char* string, const char* seq_type);
+INDIGO_EXPORT int indigoLoadSequenceFromFile(const char* filename, const char* seq_type);
 
-CEXPORT int indigoSaveMolfile(int molecule, int output);
-CEXPORT int indigoSaveMolfileToFile(int molecule, const char* filename);
-CEXPORT const char* indigoMolfile(int molecule);
+INDIGO_EXPORT int indigoSaveMolfile(int molecule, int output);
+INDIGO_EXPORT int indigoSaveMolfileToFile(int molecule, const char* filename);
+INDIGO_EXPORT const char* indigoMolfile(int molecule);
 
-CEXPORT int indigoSaveSequence(int molecule, int output);
-CEXPORT int indigoSaveSequenceToFile(int molecule, const char* filename);
-CEXPORT const char* indigoSequence(int molecule);
+INDIGO_EXPORT int indigoSaveSequence(int molecule, int output);
+INDIGO_EXPORT int indigoSaveSequenceToFile(int molecule, const char* filename);
+INDIGO_EXPORT const char* indigoSequence(int molecule);
 
-CEXPORT int indigoSaveJsonToFile(int item, const char* filename);
-CEXPORT int indigoSaveJson(int item, int output);
+INDIGO_EXPORT int indigoSaveJsonToFile(int item, const char* filename);
+INDIGO_EXPORT int indigoSaveJson(int item, int output);
 
 // accepts molecules and reactions (but not query ones)
-CEXPORT int indigoSaveCml(int object, int output);
-CEXPORT int indigoSaveCmlToFile(int object, const char* filename);
-CEXPORT const char* indigoCml(int object);
-CEXPORT const char* indigoCdxBase64(int object);
+INDIGO_EXPORT int indigoSaveCml(int object, int output);
+INDIGO_EXPORT int indigoSaveCmlToFile(int object, const char* filename);
+INDIGO_EXPORT const char* indigoCml(int object);
+INDIGO_EXPORT const char* indigoCdxBase64(int object);
 
 // accepts molecules and reactions
-CEXPORT int indigoSaveCdxml(int object, int output);
-CEXPORT int indigoSaveCdx(int item, int output);
+INDIGO_EXPORT int indigoSaveCdxml(int object, int output);
+INDIGO_EXPORT int indigoSaveCdx(int item, int output);
 
-CEXPORT const char* indigoCdxml(int item);
+INDIGO_EXPORT const char* indigoCdxml(int item);
 
-CEXPORT int indigoSaveCdxmlToFile(int object, const char* filename);
-CEXPORT int indigoSaveCdxToFile(int item, const char* filename);
+INDIGO_EXPORT int indigoSaveCdxmlToFile(int object, const char* filename);
+INDIGO_EXPORT int indigoSaveCdxToFile(int item, const char* filename);
 
-CEXPORT const char* indigoCdxml(int object);
+INDIGO_EXPORT const char* indigoCdxml(int object);
 
 // the output must be a file or a buffer, but not a string
 // (because MDLCT data usually contains zeroes)
-CEXPORT int indigoSaveMDLCT(int item, int output);
+INDIGO_EXPORT int indigoSaveMDLCT(int item, int output);
 
-CEXPORT const char* indigoJson(int object);
+INDIGO_EXPORT const char* indigoJson(int object);
 
 /*
 Converts a chemical name into a corresponding structure
@@ -240,7 +226,7 @@
    name - a name to parse
    params - a string containing parsing options or nullptr if no options are changed
 */
-CEXPORT int indigoNameToStructure(const char* name, const char* params);
+INDIGO_EXPORT int indigoNameToStructure(const char *name, const char *params);
 
 /* Reactions, query reactions */
 /*
@@ -255,66 +241,66 @@
     INDIGO_RC_MADE_OR_BROKEN = 4,
     INDIGO_RC_ORDER_CHANGED = 8
 };
-CEXPORT int indigoLoadReaction(int source);
-CEXPORT int indigoLoadReactionFromString(const char* string);
-CEXPORT int indigoLoadReactionFromFile(const char* filename);
-CEXPORT int indigoLoadReactionFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadReaction(int source);
+INDIGO_EXPORT int indigoLoadReactionFromString(const char *string);
+INDIGO_EXPORT int indigoLoadReactionFromFile(const char *filename);
+INDIGO_EXPORT int indigoLoadReactionFromBuffer(const char *buffer, int size);
 
-CEXPORT int indigoLoadQueryReaction(int source);
-CEXPORT int indigoLoadQueryReactionFromString(const char* string);
-CEXPORT int indigoLoadQueryReactionFromFile(const char* filename);
-CEXPORT int indigoLoadQueryReactionFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadQueryReaction(int source);
+INDIGO_EXPORT int indigoLoadQueryReactionFromString(const char *string);
+INDIGO_EXPORT int indigoLoadQueryReactionFromFile(const char *filename);
+INDIGO_EXPORT int indigoLoadQueryReactionFromBuffer(const char *buffer, int size);
 
-CEXPORT int indigoLoadReactionSmarts(int source);
-CEXPORT int indigoLoadReactionSmartsFromString(const char* string);
-CEXPORT int indigoLoadReactionSmartsFromFile(const char* filename);
-CEXPORT int indigoLoadReactionSmartsFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadReactionSmarts(int source);
+INDIGO_EXPORT int indigoLoadReactionSmartsFromString(const char *string);
+INDIGO_EXPORT int indigoLoadReactionSmartsFromFile(const char *filename);
+INDIGO_EXPORT int indigoLoadReactionSmartsFromBuffer(const char *buffer, int size);
 
-CEXPORT int indigoCreateReaction(void);
-CEXPORT int indigoCreateQueryReaction(void);
+INDIGO_EXPORT int indigoCreateReaction(void);
+INDIGO_EXPORT int indigoCreateQueryReaction(void);
 
-CEXPORT int indigoAddReactant(int reaction, int molecule);
-CEXPORT int indigoAddProduct(int reaction, int molecule);
-CEXPORT int indigoAddCatalyst(int reaction, int molecule);
+INDIGO_EXPORT int indigoAddReactant(int reaction, int molecule);
+INDIGO_EXPORT int indigoAddProduct(int reaction, int molecule);
+INDIGO_EXPORT int indigoAddCatalyst(int reaction, int molecule);
 
-CEXPORT int indigoCountReactants(int reaction);
-CEXPORT int indigoCountProducts(int reaction);
-CEXPORT int indigoCountCatalysts(int reaction);
+INDIGO_EXPORT int indigoCountReactants(int reaction);
+INDIGO_EXPORT int indigoCountProducts(int reaction);
+INDIGO_EXPORT int indigoCountCatalysts(int reaction);
 // Counts reactants, products, and catalysts.
-CEXPORT int indigoCountMolecules(int reaction);
-CEXPORT int indigoGetMolecule(int reaction, int index);
+INDIGO_EXPORT int indigoCountMolecules(int reaction);
+INDIGO_EXPORT int indigoGetMolecule(int reaction, int index);
 
-CEXPORT int indigoIterateReactants(int reaction);
-CEXPORT int indigoIterateProducts(int reaction);
-CEXPORT int indigoIterateCatalysts(int reaction);
+INDIGO_EXPORT int indigoIterateReactants(int reaction);
+INDIGO_EXPORT int indigoIterateProducts(int reaction);
+INDIGO_EXPORT int indigoIterateCatalysts(int reaction);
 // Returns an iterator for reactants, products, and catalysts.
-CEXPORT int indigoIterateMolecules(int reaction);
+INDIGO_EXPORT int indigoIterateMolecules(int reaction);
 
-CEXPORT int indigoSaveRxnfile(int reaction, int output);
-CEXPORT int indigoSaveRxnfileToFile(int reaction, const char* filename);
-CEXPORT const char* indigoRxnfile(int reaction);
+INDIGO_EXPORT int indigoSaveRxnfile(int reaction, int output);
+INDIGO_EXPORT int indigoSaveRxnfileToFile(int reaction, const char *filename);
+INDIGO_EXPORT const char *indigoRxnfile(int reaction);
 
 // Method for query optimizations for faster substructure search
 // (works for both query molecules and query reactions)
-CEXPORT int indigoOptimize(int query, const char* options);
+INDIGO_EXPORT int indigoOptimize(int query, const char *options);
 
 // Methods for structure normalization
 // It neutrailzes charges, resolves 5-valence Nitrogen, removes hydrogens and etc.
 // Default options is empty.
-CEXPORT int indigoNormalize(int structure, const char* options);
+INDIGO_EXPORT int indigoNormalize(int structure, const char *options);
 
 // Method for molecule and query standardizing
 // It stadrdize charges, stereo and etc.
-CEXPORT int indigoStandardize(int item);
+INDIGO_EXPORT int indigoStandardize(int item);
 
 // Method for structure ionization at specified pH and pH tollerance
-CEXPORT int indigoIonize(int item, float pH, float pH_toll);
+INDIGO_EXPORT int indigoIonize(int item, float pH, float pH_toll);
 
 // Method for building PKA model
-CEXPORT int indigoBuildPkaModel(int max_level, float threshold, const char* filename);
+INDIGO_EXPORT int indigoBuildPkaModel(int max_level, float threshold, const char *filename);
 
-CEXPORT float* indigoGetAcidPkaValue(int item, int atom, int level, int min_level);
-CEXPORT float* indigoGetBasicPkaValue(int item, int atom, int level, int min_level);
+INDIGO_EXPORT float *indigoGetAcidPkaValue(int item, int atom, int level, int min_level);
+INDIGO_EXPORT float *indigoGetBasicPkaValue(int item, int atom, int level, int min_level);
 
 // Automatic reaction atom-to-atom mapping
 // mode is one of the following (separated by a space):
@@ -329,23 +315,23 @@
 //    "ignore_isotopes" : do not consider atom isotopes while searching
 //    "ignore_valence" : do not consider atom valence while searching
 //    "ignore_radicals" : do not consider atom radicals while searching
-CEXPORT int indigoAutomap(int reaction, const char* mode);
+INDIGO_EXPORT int indigoAutomap(int reaction, const char *mode);
 
 // Returns mapping number. It might appear that there is more them
 // one atom with the same number in AAM
 // Value 0 means no mapping number has been specified.
-CEXPORT int indigoGetAtomMappingNumber(int reaction, int reaction_atom);
-CEXPORT int indigoSetAtomMappingNumber(int reaction, int reaction_atom, int number);
+INDIGO_EXPORT int indigoGetAtomMappingNumber(int reaction, int reaction_atom);
+INDIGO_EXPORT int indigoSetAtomMappingNumber(int reaction, int reaction_atom, int number);
 
 // Getters and setters for reacting centers
-CEXPORT int indigoGetReactingCenter(int reaction, int reaction_bond, int* rc);
-CEXPORT int indigoSetReactingCenter(int reaction, int reaction_bond, int rc);
+INDIGO_EXPORT int indigoGetReactingCenter(int reaction, int reaction_bond, int *rc);
+INDIGO_EXPORT int indigoSetReactingCenter(int reaction, int reaction_bond, int rc);
 
 // Clears all reaction AAM information
-CEXPORT int indigoClearAAM(int reaction);
+INDIGO_EXPORT int indigoClearAAM(int reaction);
 
 // Corrects reacting centers according to AAM
-CEXPORT int indigoCorrectReactingCenters(int reaction);
+INDIGO_EXPORT int indigoCorrectReactingCenters(int reaction);
 
 /* Accessing a molecule */
 
@@ -370,61 +356,61 @@
 
 // Returns an iterator for all atoms of the given
 // molecule, including r-sites and pseudoatoms.
-CEXPORT int indigoIterateAtoms(int molecule);
-CEXPORT int indigoIteratePseudoatoms(int molecule);
-CEXPORT int indigoIterateRSites(int molecule);
-CEXPORT int indigoIterateStereocenters(int molecule);
-CEXPORT int indigoIterateAlleneCenters(int molecule);
-CEXPORT int indigoIterateRGroups(int molecule);
+INDIGO_EXPORT int indigoIterateAtoms(int molecule);
+INDIGO_EXPORT int indigoIteratePseudoatoms(int molecule);
+INDIGO_EXPORT int indigoIterateRSites(int molecule);
+INDIGO_EXPORT int indigoIterateStereocenters(int molecule);
+INDIGO_EXPORT int indigoIterateAlleneCenters(int molecule);
+INDIGO_EXPORT int indigoIterateRGroups(int molecule);
 
-CEXPORT int indigoCountRGroups(int molecule);
-CEXPORT int indigoCopyRGroups(int molecule_from, int molecule_to);
+INDIGO_EXPORT int indigoCountRGroups(int molecule);
+INDIGO_EXPORT int indigoCopyRGroups(int molecule_from, int molecule_to);
 
-CEXPORT int indigoIsPseudoatom(int atom);
-CEXPORT int indigoIsRSite(int atom);
-CEXPORT int indigoIsTemplateAtom(int atom);
+INDIGO_EXPORT int indigoIsPseudoatom(int atom);
+INDIGO_EXPORT int indigoIsRSite(int atom);
+INDIGO_EXPORT int indigoIsTemplateAtom(int atom);
 
 // returns INDIGO_{ABS,OR,AND,EITHER}
 // or zero if the atom is not a stereoatom
-CEXPORT int indigoStereocenterType(int atom);
-CEXPORT int indigoChangeStereocenterType(int atom, int type);
+INDIGO_EXPORT int indigoStereocenterType(int atom);
+INDIGO_EXPORT int indigoChangeStereocenterType(int atom, int type);
 
-CEXPORT int indigoStereocenterGroup(int atom);
-CEXPORT int indigoSetStereocenterGroup(int atom, int group);
+INDIGO_EXPORT int indigoStereocenterGroup(int atom);
+INDIGO_EXPORT int indigoSetStereocenterGroup(int atom, int group);
 
 // returns 4 integers with atom indices that defines stereocenter pyramid
-CEXPORT const int* indigoStereocenterPyramid(int atom);
+INDIGO_EXPORT const int *indigoStereocenterPyramid(int atom);
 
-CEXPORT int indigoSingleAllowedRGroup(int rsite);
+INDIGO_EXPORT int indigoSingleAllowedRGroup(int rsite);
 
-CEXPORT int indigoAddStereocenter(int atom, int type, int v1, int v2, int v3, int v4);
+INDIGO_EXPORT int indigoAddStereocenter(int atom, int type, int v1, int v2, int v3, int v4);
 
 // Applicable to an R-Group, but not to a molecule
-CEXPORT int indigoIterateRGroupFragments(int rgroup);
+INDIGO_EXPORT int indigoIterateRGroupFragments(int rgroup);
 // Applicable to an R-Group and to a molecule
 // Returns maximal order of attachment points
-CEXPORT int indigoCountAttachmentPoints(int item);
-CEXPORT int indigoIterateAttachmentPoints(int item, int order);
+INDIGO_EXPORT int indigoCountAttachmentPoints(int item);
+INDIGO_EXPORT int indigoIterateAttachmentPoints(int item, int order);
 
-CEXPORT const char* indigoSymbol(int atom);
-CEXPORT int indigoDegree(int atom);
+INDIGO_EXPORT const char *indigoSymbol(int atom);
+INDIGO_EXPORT int indigoDegree(int atom);
 
 // Returns zero if the charge is ambiguous
 // If the charge is nonambiguous, returns 1 and writes *charge
-CEXPORT int indigoGetCharge(int atom, int* charge);
+INDIGO_EXPORT int indigoGetCharge(int atom, int *charge);
 // Same as indigoGetCharge
-CEXPORT int indigoGetExplicitValence(int atom, int* valence);
+INDIGO_EXPORT int indigoGetExplicitValence(int atom, int *valence);
 
-CEXPORT int indigoSetExplicitValence(int atom, int valence);
+INDIGO_EXPORT int indigoSetExplicitValence(int atom, int valence);
 
 // Returns a number of element from the periodic table.
 // Returns zero on ambiguous atom.
 // Can not be applied to pseudo-atoms and R-sites.
-CEXPORT int indigoAtomicNumber(int atom);
+INDIGO_EXPORT int indigoAtomicNumber(int atom);
 // Returns zero on unspecified or ambiguous isotope
-CEXPORT int indigoIsotope(int atom);
+INDIGO_EXPORT int indigoIsotope(int atom);
 // Not applicable to query molecules.
-CEXPORT int indigoValence(int atom);
+INDIGO_EXPORT int indigoValence(int atom);
 // Return atom hybridization
 // S = 1,
 // SP = 2,
@@ -435,326 +421,326 @@
 // SP3D3 = 7,
 // SP3D4 = 8,
 // SP2D = 9
-CEXPORT int indigoGetHybridization(int atom);
+INDIGO_EXPORT int indigoGetHybridization(int atom);
 // Returns zero if valence of the atom is wrong
-CEXPORT int indigoCheckValence(int atom);
+INDIGO_EXPORT int indigoCheckValence(int atom);
 
 // Returns one if atom or bond belongs Query or has any query feature
-CEXPORT int indigoCheckQuery(int item);
+INDIGO_EXPORT int indigoCheckQuery(int item);
 
 // Returns one if structure contains RGroup features (RSites, RGroups or attachment points
-CEXPORT int indigoCheckRGroups(int item);
+INDIGO_EXPORT int indigoCheckRGroups(int item);
 
 // Returns check result for Indigo object as text file for requested properties as JSON
-CEXPORT const char* indigoCheck(const char* item, const char* check_flags, const char* load_params);
+INDIGO_EXPORT const char* indigoCheck(const char* item, const char* check_flags, const char* load_params);
 
 // Returns check result for Indigo object for requested properties as JSON
-CEXPORT const char* indigoCheckObj(int item, const char* check_flags);
+INDIGO_EXPORT const char* indigoCheckObj(int item, const char* check_flags);
 
 // Returns check result for structure against requested properties
-CEXPORT const char* indigoCheckStructure(const char* structure, const char* props);
+INDIGO_EXPORT const char* indigoCheckStructure(const char* structure, const char* props);
 
 // Applicable to atoms, query atoms, and molecules. Can fail
 // (return zero) on query atoms where the number of hydrogens
 // is not definitely known. Otherwise, returns one and writes *hydro.
-CEXPORT int indigoCountHydrogens(int item, int* hydro);
+INDIGO_EXPORT int indigoCountHydrogens(int item, int* hydro);
 
 // Applicable to non-query molecules and atoms.
-CEXPORT int indigoCountImplicitHydrogens(int item);
+INDIGO_EXPORT int indigoCountImplicitHydrogens(int item);
 
 // On success, returns always the same pointer to a 3-element array;
 // you should not free() it, but rather memcpy() it if you want to keep it.
-CEXPORT float* indigoXYZ(int atom);
+INDIGO_EXPORT float* indigoXYZ(int atom);
 
-CEXPORT int indigoSetXYZ(int atom, float x, float y, float z);
+INDIGO_EXPORT int indigoSetXYZ(int atom, float x, float y, float z);
 
-CEXPORT int indigoClearXYZ(int molecule);
-CEXPORT int indigoCountSuperatoms(int molecule);
-CEXPORT int indigoCountDataSGroups(int molecule);
-CEXPORT int indigoCountRepeatingUnits(int molecule);
-CEXPORT int indigoCountMultipleGroups(int molecule);
-CEXPORT int indigoCountGenericSGroups(int molecule);
-CEXPORT int indigoIterateDataSGroups(int molecule);
-CEXPORT int indigoIterateSuperatoms(int molecule);
-CEXPORT int indigoIterateGenericSGroups(int molecule);
-CEXPORT int indigoIterateRepeatingUnits(int molecule);
-CEXPORT int indigoIterateMultipleGroups(int molecule);
+INDIGO_EXPORT int indigoClearXYZ(int molecule);
+INDIGO_EXPORT int indigoCountSuperatoms(int molecule);
+INDIGO_EXPORT int indigoCountDataSGroups(int molecule);
+INDIGO_EXPORT int indigoCountRepeatingUnits(int molecule);
+INDIGO_EXPORT int indigoCountMultipleGroups(int molecule);
+INDIGO_EXPORT int indigoCountGenericSGroups(int molecule);
+INDIGO_EXPORT int indigoIterateDataSGroups(int molecule);
+INDIGO_EXPORT int indigoIterateSuperatoms(int molecule);
+INDIGO_EXPORT int indigoIterateGenericSGroups(int molecule);
+INDIGO_EXPORT int indigoIterateRepeatingUnits(int molecule);
+INDIGO_EXPORT int indigoIterateMultipleGroups(int molecule);
 
-CEXPORT int indigoIterateTGroups(int molecule);
-CEXPORT int indigoIterateSGroups(int molecule);
+INDIGO_EXPORT int indigoIterateTGroups(int molecule);
+INDIGO_EXPORT int indigoIterateSGroups(int molecule);
 
-CEXPORT int indigoGetSuperatom(int molecule, int index);
-CEXPORT int indigoGetDataSGroup(int molecule, int index);
-CEXPORT int indigoGetGenericSGroup(int molecule, int index);
-CEXPORT int indigoGetMultipleGroup(int molecule, int index);
-CEXPORT int indigoGetRepeatingUnit(int molecule, int index);
+INDIGO_EXPORT int indigoGetSuperatom(int molecule, int index);
+INDIGO_EXPORT int indigoGetDataSGroup(int molecule, int index);
+INDIGO_EXPORT int indigoGetGenericSGroup(int molecule, int index);
+INDIGO_EXPORT int indigoGetMultipleGroup(int molecule, int index);
+INDIGO_EXPORT int indigoGetRepeatingUnit(int molecule, int index);
 
-CEXPORT const char* indigoDescription(int data_sgroup);
-CEXPORT const char* indigoData(int data_sgroup);
+INDIGO_EXPORT const char* indigoDescription(int data_sgroup);
+INDIGO_EXPORT const char* indigoData(int data_sgroup);
 
-CEXPORT int indigoAddDataSGroup(int molecule, int natoms, int* atoms, int nbonds, int* bonds, const char* description, const char* data);
+INDIGO_EXPORT int indigoAddDataSGroup(int molecule, int natoms, int* atoms, int nbonds, int* bonds, const char* description, const char* data);
 
-CEXPORT int indigoAddSuperatom(int molecule, int natoms, int* atoms, const char* name);
+INDIGO_EXPORT int indigoAddSuperatom(int molecule, int natoms, int* atoms, const char* name);
 
-CEXPORT int indigoSetDataSGroupXY(int sgroup, float x, float y, const char* options);
+INDIGO_EXPORT int indigoSetDataSGroupXY(int sgroup, float x, float y, const char* options);
 
-CEXPORT int indigoSetSGroupData(int sgroup, const char* data);
-CEXPORT int indigoSetSGroupCoords(int sgroup, float x, float y);
-CEXPORT int indigoSetSGroupDescription(int sgroup, const char* description);
-CEXPORT int indigoSetSGroupFieldName(int sgroup, const char* name);
-CEXPORT int indigoSetSGroupQueryCode(int sgroup, const char* querycode);
-CEXPORT int indigoSetSGroupQueryOper(int sgroup, const char* queryoper);
-CEXPORT int indigoSetSGroupDisplay(int sgroup, const char* option);
-CEXPORT int indigoSetSGroupLocation(int sgroup, const char* option);
-CEXPORT int indigoSetSGroupTag(int sgroup, const char* tag);
-CEXPORT int indigoSetSGroupTagAlign(int sgroup, int tag_align);
-CEXPORT int indigoSetSGroupDataType(int sgroup, const char* type);
-CEXPORT int indigoSetSGroupXCoord(int sgroup, float x);
-CEXPORT int indigoSetSGroupYCoord(int sgroup, float y);
+INDIGO_EXPORT int indigoSetSGroupData(int sgroup, const char* data);
+INDIGO_EXPORT int indigoSetSGroupCoords(int sgroup, float x, float y);
+INDIGO_EXPORT int indigoSetSGroupDescription(int sgroup, const char* description);
+INDIGO_EXPORT int indigoSetSGroupFieldName(int sgroup, const char* name);
+INDIGO_EXPORT int indigoSetSGroupQueryCode(int sgroup, const char* querycode);
+INDIGO_EXPORT int indigoSetSGroupQueryOper(int sgroup, const char* queryoper);
+INDIGO_EXPORT int indigoSetSGroupDisplay(int sgroup, const char* option);
+INDIGO_EXPORT int indigoSetSGroupLocation(int sgroup, const char* option);
+INDIGO_EXPORT int indigoSetSGroupTag(int sgroup, const char* tag);
+INDIGO_EXPORT int indigoSetSGroupTagAlign(int sgroup, int tag_align);
+INDIGO_EXPORT int indigoSetSGroupDataType(int sgroup, const char* type);
+INDIGO_EXPORT int indigoSetSGroupXCoord(int sgroup, float x);
+INDIGO_EXPORT int indigoSetSGroupYCoord(int sgroup, float y);
 
-CEXPORT int indigoCreateSGroup(const char* type, int mapping, const char* name);
-CEXPORT const char* indigoGetSGroupClass(int sgroup);
-CEXPORT const char* indigoGetSGroupName(int sgroup);
-CEXPORT int indigoSetSGroupClass(int sgroup, const char* sgclass);
-CEXPORT int indigoSetSGroupName(int sgroup, const char* sgname);
-CEXPORT int indigoGetSGroupNumCrossBonds(int sgroup);
+INDIGO_EXPORT int indigoCreateSGroup(const char* type, int mapping, const char* name);
+INDIGO_EXPORT const char* indigoGetSGroupClass(int sgroup);
+INDIGO_EXPORT const char* indigoGetSGroupName(int sgroup);
+INDIGO_EXPORT int indigoSetSGroupClass(int sgroup, const char* sgclass);
+INDIGO_EXPORT int indigoSetSGroupName(int sgroup, const char* sgname);
+INDIGO_EXPORT int indigoGetSGroupNumCrossBonds(int sgroup);
 
-CEXPORT int indigoAddSGroupAttachmentPoint(int sgroup, int aidx, int lvidx, const char* apid);
-CEXPORT int indigoDeleteSGroupAttachmentPoint(int sgroup, int index);
-CEXPORT int indigoGetSGroupDisplayOption(int sgroup);
-CEXPORT int indigoSetSGroupDisplayOption(int sgroup, int option);
-CEXPORT int indigoGetSGroupSeqId(int sgroup);
-CEXPORT float* indigoGetSGroupCoords(int sgroup);
+INDIGO_EXPORT int indigoAddSGroupAttachmentPoint(int sgroup, int aidx, int lvidx, const char* apid);
+INDIGO_EXPORT int indigoDeleteSGroupAttachmentPoint(int sgroup, int index);
+INDIGO_EXPORT int indigoGetSGroupDisplayOption(int sgroup);
+INDIGO_EXPORT int indigoSetSGroupDisplayOption(int sgroup, int option);
+INDIGO_EXPORT int indigoGetSGroupSeqId(int sgroup);
+INDIGO_EXPORT float* indigoGetSGroupCoords(int sgroup);
 
-CEXPORT int indigoGetSGroupMultiplier(int sgroup);
-CEXPORT int indigoSetSGroupMultiplier(int sgroup, int multiplier);
+INDIGO_EXPORT int indigoGetSGroupMultiplier(int sgroup);
+INDIGO_EXPORT int indigoSetSGroupMultiplier(int sgroup, int multiplier);
 
-CEXPORT const char* indigoGetRepeatingUnitSubscript(int sgroup);
-CEXPORT int indigoGetRepeatingUnitConnectivity(int sgroup);
+INDIGO_EXPORT const char* indigoGetRepeatingUnitSubscript(int sgroup);
+INDIGO_EXPORT int indigoGetRepeatingUnitConnectivity(int sgroup);
 
-CEXPORT int indigoSetSGroupBrackets(int sgroup, int brk_style, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);
+INDIGO_EXPORT int indigoSetSGroupBrackets(int sgroup, int brk_style, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);
 
-CEXPORT int indigoFindSGroups(int item, const char* property, const char* value);
+INDIGO_EXPORT int indigoFindSGroups(int item, const char* property, const char* value);
 
-CEXPORT int indigoGetSGroupType(int item);
-CEXPORT int indigoGetSGroupIndex(int item);
+INDIGO_EXPORT int indigoGetSGroupType(int item);
+INDIGO_EXPORT int indigoGetSGroupIndex(int item);
 
-CEXPORT int indigoGetSGroupOriginalId(int sgroup);
-CEXPORT int indigoSetSGroupOriginalId(int sgroup, int original);
-CEXPORT int indigoGetSGroupParentId(int sgroup);
-CEXPORT int indigoSetSGroupParentId(int sgroup, int parent);
+INDIGO_EXPORT int indigoGetSGroupOriginalId(int sgroup);
+INDIGO_EXPORT int indigoSetSGroupOriginalId(int sgroup, int original);
+INDIGO_EXPORT int indigoGetSGroupParentId(int sgroup);
+INDIGO_EXPORT int indigoSetSGroupParentId(int sgroup, int parent);
 
-CEXPORT int indigoAddTemplate(int molecule, int templates, const char* tname);
-CEXPORT int indigoRemoveTemplate(int molecule, const char* tname);
-CEXPORT int indigoFindTemplate(int molecule, const char* tname);
+INDIGO_EXPORT int indigoAddTemplate(int molecule, int templates, const char* tname);
+INDIGO_EXPORT int indigoRemoveTemplate(int molecule, const char* tname);
+INDIGO_EXPORT int indigoFindTemplate(int molecule, const char* tname);
 
-CEXPORT const char* indigoGetTGroupClass(int tgroup);
-CEXPORT const char* indigoGetTGroupName(int tgroup);
-CEXPORT const char* indigoGetTGroupAlias(int tgroup);
+INDIGO_EXPORT const char* indigoGetTGroupClass(int tgroup);
+INDIGO_EXPORT const char* indigoGetTGroupName(int tgroup);
+INDIGO_EXPORT const char* indigoGetTGroupAlias(int tgroup);
 
-CEXPORT int indigoTransformSCSRtoCTAB(int item);
-CEXPORT int indigoTransformCTABtoSCSR(int molecule, int templates);
+INDIGO_EXPORT int indigoTransformSCSRtoCTAB(int item);
+INDIGO_EXPORT int indigoTransformCTABtoSCSR(int molecule, int templates);
 
-CEXPORT int indigoResetCharge(int atom);
-CEXPORT int indigoResetExplicitValence(int atom);
-CEXPORT int indigoResetIsotope(int atom);
+INDIGO_EXPORT int indigoResetCharge(int atom);
+INDIGO_EXPORT int indigoResetExplicitValence(int atom);
+INDIGO_EXPORT int indigoResetIsotope(int atom);
 
-CEXPORT int indigoSetAttachmentPoint(int atom, int order);
-CEXPORT int indigoClearAttachmentPoints(int item);
+INDIGO_EXPORT int indigoSetAttachmentPoint(int atom, int order);
+INDIGO_EXPORT int indigoClearAttachmentPoints(int item);
 
-CEXPORT int indigoRemoveConstraints(int item, const char* type);
-CEXPORT int indigoAddConstraint(int item, const char* type, const char* value);
-CEXPORT int indigoAddConstraintNot(int item, const char* type, const char* value);
-CEXPORT int indigoAddConstraintOr(int atom, const char* type, const char* value);
+INDIGO_EXPORT int indigoRemoveConstraints(int item, const char* type);
+INDIGO_EXPORT int indigoAddConstraint(int item, const char* type, const char* value);
+INDIGO_EXPORT int indigoAddConstraintNot(int item, const char* type, const char* value);
+INDIGO_EXPORT int indigoAddConstraintOr(int atom, const char* type, const char* value);
 
-CEXPORT int indigoResetStereo(int item);
-CEXPORT int indigoInvertStereo(int item);
+INDIGO_EXPORT int indigoResetStereo(int item);
+INDIGO_EXPORT int indigoInvertStereo(int item);
 
-CEXPORT int indigoCountAtoms(int molecule);
-CEXPORT int indigoCountBonds(int molecule);
-CEXPORT int indigoCountPseudoatoms(int molecule);
-CEXPORT int indigoCountRSites(int molecule);
+INDIGO_EXPORT int indigoCountAtoms(int molecule);
+INDIGO_EXPORT int indigoCountBonds(int molecule);
+INDIGO_EXPORT int indigoCountPseudoatoms(int molecule);
+INDIGO_EXPORT int indigoCountRSites(int molecule);
 
-CEXPORT int indigoIterateBonds(int molecule);
+INDIGO_EXPORT int indigoIterateBonds(int molecule);
 // Returns 1/2/3 if the bond is a single/double/triple bond
 // Returns 4 if the bond is an aromatic bond
 // Returns zero if the bond is ambiguous (query bond)
-CEXPORT int indigoBondOrder(int bond);
+INDIGO_EXPORT int indigoBondOrder(int bond);
 
 // Returns INDIGO_{UP/DOWN/EITHER/CIS/TRANS},
 // or zero if the bond is not a stereobond
-CEXPORT int indigoBondStereo(int bond);
+INDIGO_EXPORT int indigoBondStereo(int bond);
 
 // Returns INDIGO_{CHAIN/RING},
-CEXPORT int indigoTopology(int bond);
+INDIGO_EXPORT int indigoTopology(int bond);
 
 // Returns an iterator whose elements can be treated as atoms.
 // At the same time, they support indigoBond() call.
-CEXPORT int indigoIterateNeighbors(int atom);
+INDIGO_EXPORT int indigoIterateNeighbors(int atom);
 
 // Applicable exclusively to the "atom neighbors iterator".
 // Returns a bond to the neighbor atom.
-CEXPORT int indigoBond(int nei);
+INDIGO_EXPORT int indigoBond(int nei);
 
 // Accessing atoms and bonds by index
-CEXPORT int indigoGetAtom(int molecule, int idx);
-CEXPORT int indigoGetBond(int molecule, int idx);
+INDIGO_EXPORT int indigoGetAtom(int molecule, int idx);
+INDIGO_EXPORT int indigoGetBond(int molecule, int idx);
 
-CEXPORT int indigoSource(int bond);
-CEXPORT int indigoDestination(int bond);
+INDIGO_EXPORT int indigoSource(int bond);
+INDIGO_EXPORT int indigoDestination(int bond);
 
-CEXPORT int indigoClearCisTrans(int handle);
-CEXPORT int indigoClearStereocenters(int handle);
-CEXPORT int indigoCountStereocenters(int molecule);
-CEXPORT int indigoClearAlleneCenters(int molecule);
-CEXPORT int indigoCountAlleneCenters(int molecule);
+INDIGO_EXPORT int indigoClearCisTrans(int handle);
+INDIGO_EXPORT int indigoClearStereocenters(int handle);
+INDIGO_EXPORT int indigoCountStereocenters(int molecule);
+INDIGO_EXPORT int indigoClearAlleneCenters(int molecule);
+INDIGO_EXPORT int indigoCountAlleneCenters(int molecule);
 
-CEXPORT int indigoResetSymmetricCisTrans(int handle);
-CEXPORT int indigoResetSymmetricStereocenters(int handle);
-CEXPORT int indigoMarkEitherCisTrans(int handle);
-CEXPORT int indigoMarkStereobonds(int handle);
+INDIGO_EXPORT int indigoResetSymmetricCisTrans(int handle);
+INDIGO_EXPORT int indigoResetSymmetricStereocenters(int handle);
+INDIGO_EXPORT int indigoMarkEitherCisTrans(int handle);
+INDIGO_EXPORT int indigoMarkStereobonds(int handle);
 
-CEXPORT int indigoValidateChirality(int handle);
+INDIGO_EXPORT int indigoValidateChirality(int handle);
 
 // Accepts a symbol from the periodic table (like "C" or "Br"),
 // or a pseudoatom symbol, like "Pol". Returns the added atom.
-CEXPORT int indigoAddAtom(int molecule, const char* symbol);
+INDIGO_EXPORT int indigoAddAtom(int molecule, const char* symbol);
 // Set a new atom instead of specified
-CEXPORT int indigoResetAtom(int atom, const char* symbol);
+INDIGO_EXPORT int indigoResetAtom(int atom, const char* symbol);
 
-CEXPORT const char* indigoGetTemplateAtomClass(int atom);
-CEXPORT int indigoSetTemplateAtomClass(int atom, const char* name);
+INDIGO_EXPORT const char* indigoGetTemplateAtomClass(int atom);
+INDIGO_EXPORT int indigoSetTemplateAtomClass(int atom, const char* name);
 
 // Accepts Rsite name "R" (or just ""), "R1", "R2" or list with names "R1 R3"
-CEXPORT int indigoAddRSite(int molecule, const char* name);
-CEXPORT int indigoSetRSite(int atom, const char* name);
+INDIGO_EXPORT int indigoAddRSite(int molecule, const char* name);
+INDIGO_EXPORT int indigoSetRSite(int atom, const char* name);
 
-CEXPORT int indigoSetCharge(int atom, int charge);
-CEXPORT int indigoSetIsotope(int atom, int isotope);
+INDIGO_EXPORT int indigoSetCharge(int atom, int charge);
+INDIGO_EXPORT int indigoSetIsotope(int atom, int isotope);
 
 // If the radical is nonambiguous, returns 1 and writes *electrons
-CEXPORT int indigoGetRadicalElectrons(int atom, int* electrons);
+INDIGO_EXPORT int indigoGetRadicalElectrons(int atom, int* electrons);
 // If the radical is nonambiguous, returns 1 and writes *radical
-CEXPORT int indigoGetRadical(int atom, int* radical);
-CEXPORT int indigoSetRadical(int atom, int radical);
-CEXPORT int indigoResetRadical(int atom);
+INDIGO_EXPORT int indigoGetRadical(int atom, int* radical);
+INDIGO_EXPORT int indigoSetRadical(int atom, int radical);
+INDIGO_EXPORT int indigoResetRadical(int atom);
 
 // Used for hacks with aromatic molecules; not recommended to use
 // in other situations
-CEXPORT int indigoSetImplicitHCount(int atom, int impl_h);
+INDIGO_EXPORT int indigoSetImplicitHCount(int atom, int impl_h);
 
 // Accepts two atoms (source and destination) and the order of the new bond
 // (1/2/3/4 = single/double/triple/aromatic). Returns the added bond.
-CEXPORT int indigoAddBond(int source, int destination, int order);
+INDIGO_EXPORT int indigoAddBond(int source, int destination, int order);
 
-CEXPORT int indigoSetBondOrder(int bond, int order);
+INDIGO_EXPORT int indigoSetBondOrder(int bond, int order);
 
-CEXPORT int indigoMerge(int where_to, int what);
+INDIGO_EXPORT int indigoMerge(int where_to, int what);
 
 /* Highlighting */
 
 // Access atoms and bonds
-CEXPORT int indigoHighlight(int item);
+INDIGO_EXPORT int indigoHighlight(int item);
 
 // Access atoms, bonds, molecules, and reactions
-CEXPORT int indigoUnhighlight(int item);
+INDIGO_EXPORT int indigoUnhighlight(int item);
 
 // Access atoms and bonds
-CEXPORT int indigoIsHighlighted(int item);
+INDIGO_EXPORT int indigoIsHighlighted(int item);
 
 /* Selection */
 
 // Access atoms and bonds
-CEXPORT int indigoSelect(int item);
+INDIGO_EXPORT int indigoSelect(int item);
 
 // Access atoms, bonds, molecules, and reactions
-CEXPORT int indigoUnselect(int item);
+INDIGO_EXPORT int indigoUnselect(int item);
 
 // Access atoms and bonds
-CEXPORT int indigoIsSelected(int item);
+INDIGO_EXPORT int indigoIsSelected(int item);
 
 /* Connected components of molecules */
 
-CEXPORT int indigoCountComponents(int molecule);
-CEXPORT int indigoComponentIndex(int atom);
-CEXPORT int indigoIterateComponents(int molecule);
+INDIGO_EXPORT int indigoCountComponents(int molecule);
+INDIGO_EXPORT int indigoComponentIndex(int atom);
+INDIGO_EXPORT int indigoIterateComponents(int molecule);
 
 // Returns a 'molecule component' object, which can not be used as a
 // [query] molecule, but supports the indigo{Count,Iterate}{Atoms,Bonds} calls,
 // and also the indigoClone() call, which returns a [query] molecule.
-CEXPORT int indigoComponent(int molecule, int index);
+INDIGO_EXPORT int indigoComponent(int molecule, int index);
 
 /* Smallest Set of Smallest Rings */
 
-CEXPORT int indigoCountSSSR(int molecule);
-CEXPORT int indigoIterateSSSR(int molecule);
+INDIGO_EXPORT int indigoCountSSSR(int molecule);
+INDIGO_EXPORT int indigoIterateSSSR(int molecule);
 
-CEXPORT int indigoIterateSubtrees(int molecule, int min_atoms, int max_atoms);
-CEXPORT int indigoIterateRings(int molecule, int min_atoms, int max_atoms);
-CEXPORT int indigoIterateEdgeSubmolecules(int molecule, int min_bonds, int max_bonds);
+INDIGO_EXPORT int indigoIterateSubtrees(int molecule, int min_atoms, int max_atoms);
+INDIGO_EXPORT int indigoIterateRings(int molecule, int min_atoms, int max_atoms);
+INDIGO_EXPORT int indigoIterateEdgeSubmolecules(int molecule, int min_bonds, int max_bonds);
 
 /* Calculation on molecules */
 
-CEXPORT int indigoCountHeavyAtoms(int molecule);
-CEXPORT int indigoGrossFormula(int molecule);
-CEXPORT double indigoMolecularWeight(int molecule);
-CEXPORT double indigoMostAbundantMass(int molecule);
-CEXPORT double indigoMonoisotopicMass(int molecule);
-CEXPORT const char* indigoMassComposition(int molecule);
-CEXPORT double indigoTPSA(int molecule, int includeSP);
-CEXPORT int indigoNumRotatableBonds(int molecule);
-CEXPORT int indigoNumHydrogenBondAcceptors(int molecule);
-CEXPORT int indigoNumHydrogenBondDonors(int molecule);
-CEXPORT double indigoLogP(int molecule);
-CEXPORT double indigoMolarRefractivity(int molecule);
-CEXPORT double indigoPka(int molecule);
+INDIGO_EXPORT int indigoCountHeavyAtoms(int molecule);
+INDIGO_EXPORT int indigoGrossFormula(int molecule);
+INDIGO_EXPORT double indigoMolecularWeight(int molecule);
+INDIGO_EXPORT double indigoMostAbundantMass(int molecule);
+INDIGO_EXPORT double indigoMonoisotopicMass(int molecule);
+INDIGO_EXPORT const char* indigoMassComposition(int molecule);
+INDIGO_EXPORT double indigoTPSA(int molecule, int includeSP);
+INDIGO_EXPORT int indigoNumRotatableBonds(int molecule);
+INDIGO_EXPORT int indigoNumHydrogenBondAcceptors(int molecule);
+INDIGO_EXPORT int indigoNumHydrogenBondDonors(int molecule);
+INDIGO_EXPORT double indigoLogP(int molecule);
+INDIGO_EXPORT double indigoMolarRefractivity(int molecule);
+INDIGO_EXPORT double indigoPka(int molecule);
 
-CEXPORT const char* indigoCanonicalSmiles(int molecule);
-CEXPORT const char* indigoLayeredCode(int molecule);
+INDIGO_EXPORT const char* indigoCanonicalSmiles(int molecule);
+INDIGO_EXPORT const char* indigoLayeredCode(int molecule);
 
-CEXPORT int64_t indigoHash(int chemicalObject);
+INDIGO_EXPORT int64_t indigoHash(int chemicalObject);
 
-CEXPORT const int* indigoSymmetryClasses(int molecule, int* count_out);
+INDIGO_EXPORT const int* indigoSymmetryClasses(int molecule, int* count_out);
 
-CEXPORT int indigoHasCoord(int molecule);
-CEXPORT int indigoHasZCoord(int molecule);
-CEXPORT int indigoIsChiral(int molecule);
-CEXPORT int indigoCheckChirality(int molecule);
-CEXPORT int indigoCheck3DStereo(int molecule);
-CEXPORT int indigoCheckStereo(int molecule);
+INDIGO_EXPORT int indigoHasCoord(int molecule);
+INDIGO_EXPORT int indigoHasZCoord(int molecule);
+INDIGO_EXPORT int indigoIsChiral(int molecule);
+INDIGO_EXPORT int indigoCheckChirality(int molecule);
+INDIGO_EXPORT int indigoCheck3DStereo(int molecule);
+INDIGO_EXPORT int indigoCheckStereo(int molecule);
 
-CEXPORT int indigoIsPossibleFischerProjection(int molecule, const char* options);
+INDIGO_EXPORT int indigoIsPossibleFischerProjection(int molecule, const char* options);
 
-CEXPORT int indigoCreateSubmolecule(int molecule, int nvertices, int* vertices);
-CEXPORT int indigoCreateEdgeSubmolecule(int molecule, int nvertices, int* vertices, int nedges, int* edges);
+INDIGO_EXPORT int indigoCreateSubmolecule(int molecule, int nvertices, int* vertices);
+INDIGO_EXPORT int indigoCreateEdgeSubmolecule(int molecule, int nvertices, int* vertices, int nedges, int* edges);
 
-CEXPORT int indigoGetSubmolecule(int molecule, int nvertices, int* vertices);
+INDIGO_EXPORT int indigoGetSubmolecule(int molecule, int nvertices, int* vertices);
 
-CEXPORT int indigoRemoveAtoms(int molecule, int nvertices, int* vertices);
-CEXPORT int indigoRemoveBonds(int molecule, int nbonds, int* bonds);
+INDIGO_EXPORT int indigoRemoveAtoms(int molecule, int nvertices, int* vertices);
+INDIGO_EXPORT int indigoRemoveBonds(int molecule, int nbonds, int* bonds);
 
 // Determines and applies the best transformation to the given molecule
 // so that the specified atoms move as close as possible to the desired
 // positions. The size of desired_xyz is equal to 3 * natoms.
 // The return value is the root-mean-square measure of the difference
 // between the desired and obtained positions.
-CEXPORT float indigoAlignAtoms(int molecule, int natoms, int* atom_ids, float* desired_xyz);
+INDIGO_EXPORT float indigoAlignAtoms(int molecule, int natoms, int* atom_ids, float* desired_xyz);
 
 /* Things that work for both molecules and reactions */
 
-CEXPORT int indigoAromatize(int item);
-CEXPORT int indigoDearomatize(int item);
+INDIGO_EXPORT int indigoAromatize(int item);
+INDIGO_EXPORT int indigoDearomatize(int item);
 
-CEXPORT int indigoFoldHydrogens(int item);
-CEXPORT int indigoUnfoldHydrogens(int item);
-CEXPORT int indigoFoldUnfoldHydrogens(int item);
+INDIGO_EXPORT int indigoFoldHydrogens(int item);
+INDIGO_EXPORT int indigoUnfoldHydrogens(int item);
+INDIGO_EXPORT int indigoFoldUnfoldHydrogens(int item);
 
-CEXPORT int indigoLayout(int object);
-CEXPORT int indigoClean2d(int object);
+INDIGO_EXPORT int indigoLayout(int object);
+INDIGO_EXPORT int indigoClean2d(int object);
 
-CEXPORT const char* indigoSmiles(int item);
-CEXPORT const char* indigoSmarts(int item);
-CEXPORT const char* indigoCanonicalSmarts(int item);
+INDIGO_EXPORT const char* indigoSmiles(int item);
+INDIGO_EXPORT const char* indigoSmarts(int item);
+INDIGO_EXPORT const char* indigoCanonicalSmarts(int item);
 
 // Returns a "mapping" if there is an exact match, zero otherwise
 // The flags string consists of space-separated flags.
@@ -765,55 +751,55 @@
 // "FRA": Connected fragments: disallows match of separate ions in salts
 // "ALL": All of the above
 // By default (with null or empty flags string) all flags are on.
-CEXPORT int indigoExactMatch(int item1, int item2, const char* flags);
+INDIGO_EXPORT int indigoExactMatch(int item1, int item2, const char *flags);
 
 // "beg" and "end" refer to the two ends of the tautomeric chain. Allowed
 // elements are separated by commas. '1' at the beginning means an aromatic
 // atom, while '0' means an aliphatic atom.
-CEXPORT int indigoSetTautomerRule(int id, const char* beg, const char* end);
+INDIGO_EXPORT int indigoSetTautomerRule(int id, const char *beg, const char *end);
 
-CEXPORT int indigoRemoveTautomerRule(int id);
+INDIGO_EXPORT int indigoRemoveTautomerRule(int id);
 
-CEXPORT int indigoClearTautomerRules();
+INDIGO_EXPORT int indigoClearTautomerRules();
 
-CEXPORT const char* indigoName(int handle);
-CEXPORT int indigoSetName(int handle, const char* name);
+INDIGO_EXPORT const char *indigoName(int handle);
+INDIGO_EXPORT int indigoSetName(int handle, const char *name);
 
 // You should not free() the obtained buffer, but rather memcpy() it if you want to keep it
-CEXPORT int indigoSerialize(int handle, byte** buf, int* size);
+INDIGO_EXPORT int indigoSerialize(int handle, byte **buf, int *size);
 
-CEXPORT int indigoUnserialize(const byte* buf, int size);
+INDIGO_EXPORT int indigoUnserialize(const byte *buf, int size);
 
 // Applicable to molecules/reactions obtained from SDF or RDF files,
 // and to their clones, and to their R-Group deconvolutions.
-CEXPORT int indigoHasProperty(int handle, const char* prop);
-CEXPORT const char* indigoGetProperty(int handle, const char* prop);
+INDIGO_EXPORT int indigoHasProperty(int handle, const char *prop);
+INDIGO_EXPORT const char *indigoGetProperty(int handle, const char *prop);
 
 // Applicable to newly created or cloned molecules/reactions,
 // and also to molecules/reactions obtained from SDF or RDF files.
 // If the property with the given name does not exist, it is created automatically.
-CEXPORT int indigoSetProperty(int item, const char* prop, const char* value);
+INDIGO_EXPORT int indigoSetProperty(int item, const char *prop, const char *value);
 
 // Does not raise an error if the given property does not exist
-CEXPORT int indigoRemoveProperty(int item, const char* prop);
+INDIGO_EXPORT int indigoRemoveProperty(int item, const char *prop);
 
 // Returns an iterator that one can pass to indigoName() to
 // know the name of the property. The value of the property can be
 // obtained via indigoGetProperty() call to the object
-CEXPORT int indigoIterateProperties(int handle);
+INDIGO_EXPORT int indigoIterateProperties(int handle);
 
 // Clears all properties of the molecule
-CEXPORT int indigoClearProperties(int handle);
+INDIGO_EXPORT int indigoClearProperties(int handle);
 
 // Accepts a molecule or reaction (but not query molecule or query reaction).
 // Returns a string describing the first encountered mistake with valence.
 // Returns an empty string if the input molecule/reaction is fine.
-CEXPORT const char* indigoCheckBadValence(int handle);
+INDIGO_EXPORT const char *indigoCheckBadValence(int handle);
 
 // Accepts a molecule or reaction (but not query molecule or query reaction).
 // Returns a string describing the first encountered mistake with ambiguous H counter.
 // Returns an empty string if the input molecule/reaction is fine.
-CEXPORT const char* indigoCheckAmbiguousH(int handle);
+INDIGO_EXPORT const char *indigoCheckAmbiguousH(int handle);
 
 /* Fingerprints */
 
@@ -831,119 +817,119 @@
 //                 substructure screening
 //   "full"    -- "Full fingerprint", which has all the mentioned
 //                 fingerprint types included
-CEXPORT int indigoFingerprint(int item, const char* type);
+INDIGO_EXPORT int indigoFingerprint(int item, const char *type);
 
 // Counts the nonzero (i.e. one) bits in a fingerprint
-CEXPORT int indigoCountBits(int fingerprint);
+INDIGO_EXPORT int indigoCountBits(int fingerprint);
 
 // Counts the number of the coinincident in two fingerprints
-CEXPORT int indigoCommonBits(int fingerprint1, int fingerprint2);
+INDIGO_EXPORT int indigoCommonBits(int fingerprint1, int fingerprint2);
 
 // Return one bits string for the fingerprint object
-CEXPORT const char* indigoOneBitsList(int fingerprint);
+INDIGO_EXPORT const char *indigoOneBitsList(int fingerprint);
 
 // Returns a 'fingerprint' object with data from 'buffer'
-CEXPORT int indigoLoadFingerprintFromBuffer(const byte* buffer, int size);
+INDIGO_EXPORT int indigoLoadFingerprintFromBuffer(const byte *buffer, int size);
 
 // Constructs a 'fingerprint' object from a normalized array of double descriptors
-CEXPORT int indigoLoadFingerprintFromDescriptors(const double* arr, int arr_len, int size, double density);
+INDIGO_EXPORT int indigoLoadFingerprintFromDescriptors(const double *arr, int arr_len, int size, double density);
 
 // Accepts two molecules, two reactions, or two fingerprints.
 // Returns the similarity measure between them.
 // Metrics: "tanimoto", "tversky", "tversky <alpha> <beta>", "euclid-sub" or "normalized-edit"
 // Zero pointer or empty string defaults to "tanimoto".
 // "tversky" without numbers defaults to alpha = beta = 0.5
-CEXPORT float indigoSimilarity(int item1, int item2, const char* metrics);
+INDIGO_EXPORT float indigoSimilarity(int item1, int item2, const char *metrics);
 
 /* Working with SDF/RDF/SMILES/CML/CDX files  */
 
-CEXPORT int indigoIterateSDF(int reader);
-CEXPORT int indigoIterateRDF(int reader);
-CEXPORT int indigoIterateSmiles(int reader);
-CEXPORT int indigoIterateCML(int reader);
-CEXPORT int indigoIterateCDX(int reader);
+INDIGO_EXPORT int indigoIterateSDF(int reader);
+INDIGO_EXPORT int indigoIterateRDF(int reader);
+INDIGO_EXPORT int indigoIterateSmiles(int reader);
+INDIGO_EXPORT int indigoIterateCML(int reader);
+INDIGO_EXPORT int indigoIterateCDX(int reader);
 
-CEXPORT int indigoIterateSDFile(const char* filename);
-CEXPORT int indigoIterateRDFile(const char* filename);
-CEXPORT int indigoIterateSmilesFile(const char* filename);
-CEXPORT int indigoIterateCMLFile(const char* filename);
-CEXPORT int indigoIterateCDXFile(const char* filename);
+INDIGO_EXPORT int indigoIterateSDFile(const char *filename);
+INDIGO_EXPORT int indigoIterateRDFile(const char *filename);
+INDIGO_EXPORT int indigoIterateSmilesFile(const char *filename);
+INDIGO_EXPORT int indigoIterateCMLFile(const char *filename);
+INDIGO_EXPORT int indigoIterateCDXFile(const char *filename);
 
 // Applicable to items returned by SDF/RDF iterators.
 // Returns the content of SDF/RDF item.
-CEXPORT const char* indigoRawData(int item);
+INDIGO_EXPORT const char *indigoRawData(int item);
 
 // Applicable to items returned by SDF/RDF iterators.
 // Returns the offset in the SDF/RDF file.
-CEXPORT int indigoTell(int handle);
-CEXPORT long long indigoTell64(int handle);
+INDIGO_EXPORT int indigoTell(int handle);
+INDIGO_EXPORT long long indigoTell64(int handle);
 
 // Saves the molecule to an SDF output stream
-CEXPORT int indigoSdfAppend(int output, int item);
+INDIGO_EXPORT int indigoSdfAppend(int output, int item);
 // Saves the molecule to a multiline SMILES output stream
-CEXPORT int indigoSmilesAppend(int output, int item);
+INDIGO_EXPORT int indigoSmilesAppend(int output, int item);
 
 // Similarly for RDF files, except that the header should be written first
-CEXPORT int indigoRdfHeader(int output);
-CEXPORT int indigoRdfAppend(int output, int item);
+INDIGO_EXPORT int indigoRdfHeader(int output);
+INDIGO_EXPORT int indigoRdfAppend(int output, int item);
 
 // Similarly for CML files, except that they have both header and footer
-CEXPORT int indigoCmlHeader(int output);
-CEXPORT int indigoCmlAppend(int output, int item);
-CEXPORT int indigoCmlFooter(int output);
+INDIGO_EXPORT int indigoCmlHeader(int output);
+INDIGO_EXPORT int indigoCmlAppend(int output, int item);
+INDIGO_EXPORT int indigoCmlFooter(int output);
 
 // Create saver objects that can be used to save molecules or reactions
 // Supported formats: 'sdf', 'smi' or 'smiles', 'cml', 'rdf'
 // Format argument is case-insensitive
 // Saver should be closed with indigoClose function
-CEXPORT int indigoCreateSaver(int output, const char* format);
-CEXPORT int indigoCreateFileSaver(const char* filename, const char* format);
+INDIGO_EXPORT int indigoCreateSaver(int output, const char *format);
+INDIGO_EXPORT int indigoCreateFileSaver(const char *filename, const char *format);
 
 // Append object to a specified saver stream
-CEXPORT int indigoAppend(int saver, int object);
+INDIGO_EXPORT int indigoAppend(int saver, int object);
 
 /* Arrays */
 
-CEXPORT int indigoCreateArray();
+INDIGO_EXPORT int indigoCreateArray();
 // Note: a clone of the object is added, not the object itself
-CEXPORT int indigoArrayAdd(int arr, int object);
-CEXPORT int indigoAt(int item, int index);
-CEXPORT int indigoCount(int item);
-CEXPORT int indigoClear(int arr);
-CEXPORT int indigoIterateArray(int arr);
+INDIGO_EXPORT int indigoArrayAdd(int arr, int object);
+INDIGO_EXPORT int indigoAt(int item, int index);
+INDIGO_EXPORT int indigoCount(int item);
+INDIGO_EXPORT int indigoClear(int arr);
+INDIGO_EXPORT int indigoIterateArray(int arr);
 
 /* Substructure matching */
 
 // Returns a new 'matcher' object
 // 'mode' is reserved for future use; currently its value is ignored
-CEXPORT int indigoSubstructureMatcher(int target, const char* mode);
+INDIGO_EXPORT int indigoSubstructureMatcher(int target, const char *mode);
 
 // Ignore target atom in the substructure matcher
-CEXPORT int indigoIgnoreAtom(int matcher, int atom_object);
+INDIGO_EXPORT int indigoIgnoreAtom(int matcher, int atom_object);
 
 // Ignore target atom in the substructure matcher
-CEXPORT int indigoUnignoreAtom(int matcher, int atom_object);
+INDIGO_EXPORT int indigoUnignoreAtom(int matcher, int atom_object);
 
 // Clear list of ignored target atoms in the substructure matcher
-CEXPORT int indigoUnignoreAllAtoms(int matcher);
+INDIGO_EXPORT int indigoUnignoreAllAtoms(int matcher);
 
 // Returns a new 'match' object on success, zero on fail
 //    matcher is an matcher object returned by indigoSubstructureMatcher
-CEXPORT int indigoMatch(int matcher, int query);
+INDIGO_EXPORT int indigoMatch(int matcher, int query);
 
 // Counts the number of embeddings of the query structure into the target
-CEXPORT int indigoCountMatches(int matcher, int query);
+INDIGO_EXPORT int indigoCountMatches(int matcher, int query);
 
 // Counts the number of embeddings of the query structure into the target
 // If number of embeddings is more then limit then limit is returned
-CEXPORT int indigoCountMatchesWithLimit(int matcher, int query, int embeddings_limit);
+INDIGO_EXPORT int indigoCountMatchesWithLimit(int matcher, int query, int embeddings_limit);
 
 // Returns substructure matches iterator
-CEXPORT int indigoIterateMatches(int matcher, int query);
+INDIGO_EXPORT int indigoIterateMatches(int matcher, int query);
 
 // Accepts a 'match' object obtained from indigoMatchSubstructure.
 // Returns a new molecule which has the query highlighted.
-CEXPORT int indigoHighlightedTarget(int match);
+INDIGO_EXPORT int indigoHighlightedTarget(int match);
 
 // Accepts an atom from the query, not an atom index.
 //   You can use indigoGetAtom() to obtain the atom by its index.
@@ -951,7 +937,7 @@
 // atom doesn't match particular atom in the target (R-group or explicit
 // hydrogen) then return value is zero.
 //   You can use indigoIndex() to obtain the index of the returned atom.
-CEXPORT int indigoMapAtom(int handle, int atom);
+INDIGO_EXPORT int indigoMapAtom(int handle, int atom);
 
 // Accepts a bond from the query, not a bond index.
 //   You can use indigoGetBond() to obtain the bond by its index.
@@ -959,7 +945,7 @@
 // bond doesn't match particular bond in the target (R-group or explicit
 // hydrogen) then return value is zero.
 //   You can use indigoIndex() to obtain the index of the returned bond.
-CEXPORT int indigoMapBond(int handle, int bond);
+INDIGO_EXPORT int indigoMapBond(int handle, int bond);
 
 // Accepts a molecule from the query reaction, not a molecule index.
 //   You can use indigoGetMolecule() to obtain the bond by its index.
@@ -967,11 +953,11 @@
 // molecule doesn't match particular molecule in the target then return
 // value is zero.
 //   You can use indigoIndex() to obtain the index of the returned molecule.
-CEXPORT int indigoMapMolecule(int handle, int molecule);
+INDIGO_EXPORT int indigoMapMolecule(int handle, int molecule);
 
 // Accepts a molecule and options for tautomer enumeration algorithms
 // Returns an iterator object over the molecules that are tautomers of this molecule.
-CEXPORT int indigoIterateTautomers(int molecule, const char* options);
+INDIGO_EXPORT int indigoIterateTautomers(int molecule, const char *options);
 
 /* Scaffold detection */
 
@@ -980,91 +966,93 @@
 //   (i) treated as a structure: the maximum (by the number of rings) common
 //       substructure of the given structures.
 //  (ii) passed to indigoAllScaffolds()
-CEXPORT int indigoExtractCommonScaffold(int structures, const char* options);
+INDIGO_EXPORT int indigoExtractCommonScaffold(int structures, const char *options);
 
 // Returns an array of all possible scaffolds.
 // The input parameter is the value returned by indigoExtractCommonScaffold().
-CEXPORT int indigoAllScaffolds(int extracted);
+INDIGO_EXPORT int indigoAllScaffolds(int extracted);
 
 /* R-Group deconvolution */
 
 // Returns a ``decomposition'' object that can be passed to
 // indigoDecomposedMoleculeScaffold() and
 // indigoIterateDecomposedMolecules()
-CEXPORT int indigoDecomposeMolecules(int scaffold, int structures);
+INDIGO_EXPORT int indigoDecomposeMolecules(int scaffold, int structures);
 
 // Returns a scaffold molecule with r-sites marking the place
 // for substituents to add to form the structures given above.
-CEXPORT int indigoDecomposedMoleculeScaffold(int decomp);
+INDIGO_EXPORT int indigoDecomposedMoleculeScaffold(int decomp);
 
 // Returns an iterator which corresponds to the given collection of structures.
 // indigoDecomposedMoleculeHighlighted() and
 // indigoDecomposedMoleculeWithRGroups() are applicable to the
 // values returned by the iterator.
-CEXPORT int indigoIterateDecomposedMolecules(int decomp);
+INDIGO_EXPORT int indigoIterateDecomposedMolecules(int decomp);
 
 // Returns a molecule with highlighted scaffold
-CEXPORT int indigoDecomposedMoleculeHighlighted(int decomp);
+INDIGO_EXPORT int indigoDecomposedMoleculeHighlighted(int decomp);
 
 // Returns a query molecule with r-sites and "R1=...", "R2=..."
 // substituents defined. The 'scaffold' part of the molecule
 // is identical to the indigoDecomposedMoleculeScaffold()
-CEXPORT int indigoDecomposedMoleculeWithRGroups(int decomp);
+INDIGO_EXPORT int indigoDecomposedMoleculeWithRGroups(int decomp);
 
 /*
  * Decomposition Iteration API
  */
 // Returns a 'decomposition' object
-CEXPORT int indigoCreateDecomposer(int scaffold);
+INDIGO_EXPORT int indigoCreateDecomposer(int scaffold);
 // Returns a 'decomposition' item
-CEXPORT int indigoDecomposeMolecule(int decomp, int mol);
+INDIGO_EXPORT int indigoDecomposeMolecule(int decomp, int mol);
 // Returns decomposition iterator
-CEXPORT int indigoIterateDecompositions(int deco_item);
+INDIGO_EXPORT int indigoIterateDecompositions(int deco_item);
 // Adds the input decomposition to a full scaffold
-CEXPORT int indigoAddDecomposition(int decomp, int q_match);
+INDIGO_EXPORT int indigoAddDecomposition(int decomp, int q_match);
 
 /* R-Group convolution */
 
-CEXPORT int indigoGetFragmentedMolecule(int elem, const char* options);
-CEXPORT int indigoRGroupComposition(int molecule, const char* options);
+INDIGO_EXPORT int indigoGetFragmentedMolecule(int elem, const char *options);
+INDIGO_EXPORT int indigoRGroupComposition(int molecule, const char *options);
 
 /*
  * Abbreviations
  */
-CEXPORT int indigoExpandAbbreviations(int molecule);
+INDIGO_EXPORT int indigoExpandAbbreviations(int molecule);
 
 /* Other */
 
-CEXPORT const char* indigoToString(int handle);
-CEXPORT const char* indigoToBase64String(int handle);
-CEXPORT int indigoToBuffer(int handle, char** buf, int* size);
+INDIGO_EXPORT const char *indigoToString(int handle);
+INDIGO_EXPORT const char *indigoToBase64String(int handle);
+INDIGO_EXPORT int indigoToBuffer(int handle, char **buf, int *size);
 
 /* Reaction products enumeration */
 
 // Accepts a query reaction with markd R-sites, and array of arrays
 // of substituents corresponding to the R-Sites. Returns an array of
 // reactions with R-Sites replaced by the actual substituents.
-CEXPORT int indigoReactionProductEnumerate(int reaction, int monomers);
+INDIGO_EXPORT int indigoReactionProductEnumerate(int reaction, int monomers);
 
-CEXPORT int indigoTransform(int reaction, int monomers);
+INDIGO_EXPORT int indigoTransform(int reaction, int monomers);
 
-CEXPORT int indigoTransformHELMtoSCSR(int monomer);
+INDIGO_EXPORT int indigoTransformHELMtoSCSR(int monomer);
 
 /* Debug functionality */
 
 // Returns internal type of an object
-CEXPORT const char* indigoDbgInternalType(int object);
+INDIGO_EXPORT const char *indigoDbgInternalType(int object);
 
 // Internal breakpoint
-CEXPORT void indigoDbgBreakpoint(void);
+INDIGO_EXPORT void indigoDbgBreakpoint(void);
 
 // Methods that returns profiling infromation in a human readable format
-CEXPORT const char* indigoDbgProfiling(int /*bool*/ whole_session);
+INDIGO_EXPORT const char *indigoDbgProfiling(int /*bool*/ whole_session);
 
 // Reset profiling counters either for the current state or for the whole session
-CEXPORT int indigoDbgResetProfiling(int /*bool*/ whole_session);
+INDIGO_EXPORT int indigoDbgResetProfiling(int /*bool*/ whole_session);
 
 // Methods that returns profiling counter value for a particular counter
-CEXPORT qword indigoDbgProfilingGetCounter(const char* name, int /*bool*/ whole_session);
-
+INDIGO_EXPORT qword indigoDbgProfilingGetCounter(const char *name, int /*bool*/ whole_session);
+#ifdef __cplusplus
+}
+#endif
 #endif
Index: openbabel-src/openbabel/src/formats/chemdrawcdx.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/chemdrawcdx.cpp b/openbabel-src/openbabel/src/formats/chemdrawcdx.cpp
--- a/openbabel-src/openbabel/src/formats/chemdrawcdx.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/chemdrawcdx.cpp	(date 1714440647078)
@@ -810,7 +810,7 @@
 ///////////////////////////////////////////////////////////////////////
 bool CDXReader::ParseEnums(map<CDXTag, string>& enummap, const string& filename)
 {
-  ifstream ihs;
+  istringstream ihs;
   if(OpenDatafile(ihs, filename).empty())
   {
     obErrorLog.ThrowError(__FUNCTION__, 
Index: rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.cpp b/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.cpp	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.cpp	(date 1714440647078)
@@ -7,7 +7,7 @@
 //  which is included in the file license.txt, found at the root
 //  of the RDKit source tree.
 //
-
+#include <RDGeneral/export.h>
 #include <ctime>
 #include <limits>
 #ifdef RDK_BUILD_THREADSAFE_SSS
@@ -18,7 +18,7 @@
 #include "RGroupDecompData.h"
 #include "RGroupDecomp.h"
 #include "RGroupFingerprintScore.h"
-#include "../../../External/GA/util/Util.h"
+#include "GA/util/Util.h"
 
 // #define DEBUG
 
Index: openbabel-src/openbabel/src/formats/povrayformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/povrayformat.cpp b/openbabel-src/openbabel/src/formats/povrayformat.cpp
--- a/openbabel-src/openbabel/src/formats/povrayformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/povrayformat.cpp	(date 1714440647078)
@@ -523,7 +523,7 @@
 
         /* ---- Add a pigment - statement for start-atom of bond ---- */
         bond_type = bond->GetBeginAtom() -> GetType();
-        bond_type.erase(remove_if(bond_type.begin(), bond_type.end(), bind1st(equal_to<char>(), '.')), bond_type.end());
+        bond_type.erase(remove(bond_type.begin(), bond_type.end(), '.'), bond_type.end());
         ofs << "\t    pigment{color Color_"
             << bond_type
             << "}" << endl;
@@ -584,7 +584,7 @@
 
         /* ---- Add a pigment - statement for end-atom of bond i ---- */
         bond_type = bond->GetEndAtom() -> GetType();
-        bond_type.erase(remove_if(bond_type.begin(), bond_type.end(), bind1st(equal_to<char>(), '.')), bond_type.end());
+        bond_type.erase(remove(bond_type.begin(), bond_type.end(), '.'), bond_type.end());
 
         ofs << "\t    pigment{color Color_"
             << bond_type
Index: rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.h b/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.h
--- a/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.h	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.h	(date 1714440647078)
@@ -16,11 +16,11 @@
 #include <map>
 #include <chrono>
 
-#include "../../../External/GA/ga/StringChromosome.h"
-#include "../../../External/GA/ga/GaBase.h"
-#include "../../../External/GA/ga/GaOperation.h"
-#include "../../../External/GA/ga/LinkedPopLinearSel.h"
-#include "../../../External/GA/ga/IntegerStringChromosomePolicy.h"
+#include "GA/ga/StringChromosome.h"
+#include "GA/ga/GaBase.h"
+#include "GA/ga/GaOperation.h"
+#include "GA/ga/LinkedPopLinearSel.h"
+#include "GA/ga/IntegerStringChromosomePolicy.h"
 #include "RGroupFingerprintScore.h"
 #include "RGroupScore.h"
 
Index: rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTreeUtils.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTreeUtils.cpp b/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTreeUtils.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTreeUtils.cpp	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTreeUtils.cpp	(date 1714440647078)
@@ -16,7 +16,7 @@
 #include "FeatTree.h"
 
 #include <boost/graph/biconnected_components.hpp>
-#include <boost/property_map.hpp>
+#include <boost/property_map/property_map.hpp>
 #include <map>
 #include <set>
 
Index: openbabel-src/openbabel/src/formats/json/pubchemjsonformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/json/pubchemjsonformat.cpp b/openbabel-src/openbabel/src/formats/json/pubchemjsonformat.cpp
--- a/openbabel-src/openbabel/src/formats/json/pubchemjsonformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/json/pubchemjsonformat.cpp	(date 1714440647078)
@@ -760,7 +760,7 @@
       // Coordinates
       // TODO: An option to round coordinates to n decimal places?
       xcoords.PushBack(rapidjson::Value(patom->GetX()).Move(), al);
-      ycoords.PushBack(rapidjson::Value(patom->GetX()).Move(), al);
+      ycoords.PushBack(rapidjson::Value(patom->GetY()).Move(), al);
       if (pmol->GetDimension() == 3) {
         zcoords.PushBack(rapidjson::Value(patom->GetZ()).Move(), al);
       }
Index: indigo-src/indigo/api/c/indigo/src/indigo_product_enumerator.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_product_enumerator.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_product_enumerator.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_product_enumerator.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_product_enumerator.cpp	(date 1714440647078)
@@ -66,7 +66,7 @@
     indices.copy(monomers_indices);
 }
 
-CEXPORT int indigoReactionProductEnumerate(int reaction, int monomers)
+int indigoReactionProductEnumerate(int reaction, int monomers)
 {
     INDIGO_BEGIN
     {
@@ -155,7 +155,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoTransform(int reaction, int monomers)
+int indigoTransform(int reaction, int monomers)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/core/indigo-core/molecule/metadata_storage.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/molecule/metadata_storage.h b/indigo-src/indigo/core/indigo-core/molecule/metadata_storage.h
--- a/indigo-src/indigo/core/indigo-core/molecule/metadata_storage.h	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/core/indigo-core/molecule/metadata_storage.h	(date 1714440647078)
@@ -21,13 +21,14 @@
 #include <cstdint>
 
 #include "base_cpp/ptr_array.h"
+#include <cstdint>
 
 namespace indigo
 {
     class MetaObject
     {
     public:
-        explicit MetaObject(uint32_t class_id) : _class_id(class_id)
+        explicit MetaObject(std::uint32_t class_id) : _class_id(class_id)
         {
         }
         uint32_t _class_id;
Index: indigo-src/indigo/api/c/indigo/src/indigo_io.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_io.h b/indigo-src/indigo/api/c/indigo/src/indigo_io.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_io.h	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_io.h	(date 1714440647078)
@@ -27,7 +27,7 @@
 #pragma warning(disable : 4251)
 #endif
 
-class DLLEXPORT IndigoScanner : public IndigoObject
+class INDIGO_EXPORT IndigoScanner : public IndigoObject
 {
 public:
     IndigoScanner(Scanner* scanner);
@@ -44,7 +44,7 @@
     Array<char> _buf;
 };
 
-class DLLEXPORT IndigoOutput : public IndigoObject
+class INDIGO_EXPORT IndigoOutput : public IndigoObject
 {
 public:
     IndigoOutput();
Index: indigo-src/indigo/api/c/indigo/src/indigo_layout.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_layout.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_layout.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_layout.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_layout.cpp	(date 1714440647078)
@@ -28,7 +28,7 @@
 #include <algorithm>
 #include <vector>
 
-CEXPORT int indigoLayout(int object)
+int indigoLayout(int object)
 {
     INDIGO_BEGIN
     {
@@ -132,7 +132,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClean2d(int object)
+int indigoClean2d(int object)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.cpp	(date 1714440647078)
@@ -118,7 +118,7 @@
         throw IndigoError("unknown molecule fingerprint type: %s", type);
 }
 
-CEXPORT int indigoFingerprint(int item, const char* type)
+int indigoFingerprint(int item, const char* type)
 {
     INDIGO_BEGIN
     {
@@ -153,7 +153,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadFingerprintFromBuffer(const byte* buffer, int size)
+int indigoLoadFingerprintFromBuffer(const byte* buffer, int size)
 {
     INDIGO_BEGIN
     {
@@ -164,7 +164,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadFingerprintFromDescriptors(const double* arr, int arr_len, int size, double density)
+int indigoLoadFingerprintFromDescriptors(const double* arr, int arr_len, int size, double density)
 {
     INDIGO_BEGIN
     {
@@ -402,7 +402,7 @@
     return 1;
 }
 
-CEXPORT float indigoSimilarity(int item1, int item2, const char* metrics)
+float indigoSimilarity(int item1, int item2, const char* metrics)
 {
     INDIGO_BEGIN
     {
@@ -459,7 +459,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountBits(int fingerprint)
+int indigoCountBits(int fingerprint)
 {
     INDIGO_BEGIN
     {
@@ -469,7 +469,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCommonBits(int fingerprint1, int fingerprint2)
+int indigoCommonBits(int fingerprint1, int fingerprint2)
 {
     INDIGO_BEGIN
     {
@@ -484,7 +484,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoOneBitsList(int fingerprint)
+const char* indigoOneBitsList(int fingerprint)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_array.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_array.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_array.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_array.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_array.cpp	(date 1714440647078)
@@ -139,7 +139,7 @@
     return _idx + 1 < _arr->objects.size();
 }
 
-CEXPORT int indigoCreateArray()
+int indigoCreateArray()
 {
     INDIGO_BEGIN
     {
@@ -148,7 +148,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoArrayAdd(int arr, int handle)
+int indigoArrayAdd(int arr, int handle)
 {
     INDIGO_BEGIN
     {
@@ -163,7 +163,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateArray(int arr)
+int indigoIterateArray(int arr)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_match.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_match.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_match.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_match.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_match.cpp	(date 1714440647078)
@@ -72,7 +72,7 @@
     label_list.push(Element::fromString(buf.ptr()));
 }
 
-CEXPORT int indigoSetTautomerRule(int n, const char* beg, const char* end)
+int indigoSetTautomerRule(int n, const char* beg, const char* end)
 {
     INDIGO_BEGIN
     {
@@ -91,7 +91,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearTautomerRules()
+int indigoClearTautomerRules()
 {
     INDIGO_BEGIN
     {
@@ -101,7 +101,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRemoveTautomerRule(int n)
+int indigoRemoveTautomerRule(int n)
 {
     INDIGO_BEGIN
     {
@@ -111,7 +111,7 @@
     INDIGO_END(-1);
 }
 
-DLLEXPORT bool _indigoParseTautomerFlags(const char* flags, IndigoTautomerParams& params)
+bool _indigoParseTautomerFlags(const char* flags, IndigoTautomerParams& params)
 {
     if (flags == 0)
         return false;
@@ -135,7 +135,7 @@
     return true;
 }
 
-DLLEXPORT int _indigoParseExactFlags(const char* flags, bool reaction, float* rms_threshold)
+int _indigoParseExactFlags(const char* flags, bool reaction, float* rms_threshold)
 {
     if (flags == 0)
         throw IndigoError("_indigoParseExactFlags(): zero string pointer");
@@ -243,7 +243,7 @@
     return res;
 }
 
-CEXPORT int indigoExactMatch(int handler1, int handler2, const char* flags)
+int indigoExactMatch(int handler1, int handler2, const char* flags)
 {
     INDIGO_BEGIN
     {
@@ -727,7 +727,7 @@
     return true;
 }
 
-CEXPORT int indigoSubstructureMatcher(int target, const char* mode_str)
+int indigoSubstructureMatcher(int target, const char* mode_str)
 {
     INDIGO_BEGIN
     {
@@ -797,7 +797,7 @@
                                        method);
 }
 
-CEXPORT int indigoIgnoreAtom(int target_matcher, int atom_object)
+int indigoIgnoreAtom(int target_matcher, int atom_object)
 {
     INDIGO_BEGIN
     {
@@ -811,7 +811,7 @@
 }
 
 // Ignore target atom in the substructure matcher
-CEXPORT int indigoUnignoreAtom(int target_matcher, int atom_object)
+int indigoUnignoreAtom(int target_matcher, int atom_object)
 {
     INDIGO_BEGIN
     {
@@ -824,7 +824,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoUnignoreAllAtoms(int target_matcher)
+int indigoUnignoreAllAtoms(int target_matcher)
 {
     INDIGO_BEGIN
     {
@@ -835,7 +835,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoMatch(int target_matcher, int query)
+int indigoMatch(int target_matcher, int query)
 {
     INDIGO_BEGIN
     {
@@ -947,7 +947,7 @@
     return indigoCountMatchesWithLimit(target_matcher, query, 0);
 }
 
-CEXPORT int indigoCountMatchesWithLimit(int target_matcher, int query, int embeddings_limit)
+int indigoCountMatchesWithLimit(int target_matcher, int query, int embeddings_limit)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_structure_checker.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_structure_checker.h b/indigo-src/indigo/api/c/indigo/src/indigo_structure_checker.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_structure_checker.h	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_structure_checker.h	(date 1714440647078)
@@ -28,7 +28,7 @@
 namespace indigo
 {
 
-    class DLLEXPORT IndigoStructureChecker : public StructureChecker
+    class INDIGO_EXPORT IndigoStructureChecker : public StructureChecker
     {
     public:
         IndigoStructureChecker();
Index: indigo-src/indigo/api/c/indigo/src/indigo_properties.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_properties.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_properties.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_properties.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_properties.cpp	(date 1714440647078)
@@ -19,7 +19,7 @@
 #include "indigo_properties.h"
 #include "base_cpp/properties_map.h"
 
-CEXPORT int indigoHasProperty(int handle, const char* prop)
+int indigoHasProperty(int handle, const char* prop)
 {
     INDIGO_BEGIN
     {
@@ -35,7 +35,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetProperty(int handle, const char* prop)
+const char* indigoGetProperty(int handle, const char* prop)
 {
     INDIGO_BEGIN
     {
@@ -52,7 +52,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoSetProperty(int handle, const char* prop, const char* value)
+int indigoSetProperty(int handle, const char* prop, const char* value)
 {
     INDIGO_BEGIN
     {
@@ -70,7 +70,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRemoveProperty(int handle, const char* prop)
+int indigoRemoveProperty(int handle, const char* prop)
 {
     INDIGO_BEGIN
     {
@@ -138,7 +138,7 @@
     return new IndigoProperty(_props, _idx);
 }
 
-CEXPORT int indigoIterateProperties(int handle)
+int indigoIterateProperties(int handle)
 {
     INDIGO_BEGIN
     {
@@ -150,7 +150,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearProperties(int handle)
+int indigoClearProperties(int handle)
 {
     INDIGO_BEGIN
     {
Index: rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTree.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTree.h b/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTree.h
--- a/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTree.h	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTree.h	(date 1714440647078)
@@ -13,7 +13,7 @@
 #define _RD_FEATTREE_H_
 
 #include <boost/graph/adjacency_list.hpp>
-#include <boost/property_map.hpp>
+#include <boost/property_map/property_map.hpp>
 #include <boost/shared_ptr.hpp>
 #include <set>
 
Index: indigo-src/indigo/api/c/indigo/src/indigo_abbreviations_expand.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_abbreviations_expand.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_abbreviations_expand.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_abbreviations_expand.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_abbreviations_expand.cpp	(date 1714440647078)
@@ -769,7 +769,7 @@
         //
         // Interface functions
         //
-        CEXPORT int indigoExpandAbbreviations(int molecule)
+        int indigoExpandAbbreviations(int molecule)
         {
             INDIGO_BEGIN
             {
Index: indigo-src/indigo/api/c/indigo/src/indigo_composition.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_composition.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_composition.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_composition.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_composition.cpp	(date 1714440647078)
@@ -23,7 +23,7 @@
 
 using MoleculeIter = MoleculeRGroupsComposition::MoleculeIter;
 
-class DLLEXPORT IndigoCompositionElem : public IndigoObject
+class IndigoCompositionElem : public IndigoObject
 {
 public:
     IndigoCompositionElem() : IndigoObject(COMPOSITION_ELEM)
@@ -37,7 +37,7 @@
     MoleculeRGroups variants[RGCOMP_OPT_COUNT];
 };
 
-CEXPORT int indigoGetFragmentedMolecule(int elem, const char* options)
+int indigoGetFragmentedMolecule(int elem, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -72,7 +72,7 @@
     INDIGO_END(-1);
 }
 
-class DLLEXPORT IndigoCompositionIter : public IndigoObject
+class IndigoCompositionIter : public IndigoObject
 {
 public:
     IndigoCompositionIter(BaseMolecule& mol) : IndigoObject(COMPOSITION_ITER), _composition(mol), _it(_composition.begin()), _end(_composition.end())
@@ -112,7 +112,7 @@
     bool _hasNext = true;
 };
 
-CEXPORT int indigoRGroupComposition(int molecule, const char* options)
+int indigoRGroupComposition(int molecule, const char* options)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_misc.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_misc.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_misc.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_misc.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_misc.cpp	(date 1714440647078)
@@ -43,7 +43,7 @@
 #include "indigo_savers.h"
 #include "indigo_structure_checker.h"
 
-CEXPORT int indigoAromatize(int object)
+int indigoAromatize(int object)
 {
     INDIGO_BEGIN
     {
@@ -59,7 +59,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDearomatize(int object)
+int indigoDearomatize(int object)
 {
     INDIGO_BEGIN
     {
@@ -79,7 +79,7 @@
 }
 
 #define INDIGO_SET_OPTION(SUFFIX, TYPE)                                                                                                                        \
-    CEXPORT int indigoSetOption##SUFFIX(const char* name, TYPE value)                                                                                          \
+    int indigoSetOption##SUFFIX(const char* name, TYPE value)                                                                                          \
     {                                                                                                                                                          \
         INDIGO_BEGIN                                                                                                                                           \
         {                                                                                                                                                      \
@@ -94,7 +94,7 @@
 INDIGO_SET_OPTION(Bool, int)
 INDIGO_SET_OPTION(Float, float)
 
-CEXPORT int indigoSetOptionColor(const char* name, float r, float g, float b)
+int indigoSetOptionColor(const char* name, float r, float g, float b)
 {
     INDIGO_BEGIN
     {
@@ -103,7 +103,7 @@
     }
     INDIGO_END(-1);
 }
-CEXPORT int indigoSetOptionXY(const char* name, int x, int y)
+int indigoSetOptionXY(const char* name, int x, int y)
 {
     INDIGO_BEGIN
     {
@@ -113,7 +113,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetOption(const char* name)
+const char* indigoGetOption(const char* name)
 {
     INDIGO_BEGIN
     {
@@ -124,7 +124,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoGetOptionInt(const char* name, int* value)
+int indigoGetOptionInt(const char* name, int* value)
 {
     INDIGO_BEGIN
     {
@@ -137,7 +137,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetOptionBool(const char* name, int* value)
+int indigoGetOptionBool(const char* name, int* value)
 {
     INDIGO_BEGIN
     {
@@ -150,7 +150,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetOptionFloat(const char* name, float* value)
+int indigoGetOptionFloat(const char* name, float* value)
 {
     INDIGO_BEGIN
     {
@@ -163,7 +163,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetOptionColor(const char* name, float* r, float* g, float* b)
+int indigoGetOptionColor(const char* name, float* r, float* g, float* b)
 {
     INDIGO_BEGIN
     {
@@ -176,7 +176,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetOptionXY(const char* name, int* x, int* y)
+int indigoGetOptionXY(const char* name, int* x, int* y)
 {
     INDIGO_BEGIN
     {
@@ -189,7 +189,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetOptionType(const char* name)
+const char* indigoGetOptionType(const char* name)
 {
     INDIGO_BEGIN
     {
@@ -200,7 +200,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoResetOptions()
+int indigoResetOptions()
 {
     INDIGO_BEGIN
     {
@@ -230,7 +230,7 @@
     }
 }
 
-CEXPORT const char* indigoCheckBadValence(int handle)
+const char* indigoCheckBadValence(int handle)
 {
     INDIGO_BEGIN
     {
@@ -319,7 +319,7 @@
         }
 }
 
-CEXPORT const char* indigoCheckAmbiguousH(int handle)
+const char* indigoCheckAmbiguousH(int handle)
 {
     INDIGO_BEGIN
     {
@@ -376,7 +376,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoSmiles(int item)
+const char* indigoSmiles(int item)
 {
     INDIGO_BEGIN
     {
@@ -388,7 +388,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoCanonicalSmiles(int item)
+const char* indigoCanonicalSmiles(int item)
 {
     INDIGO_BEGIN
     {
@@ -401,7 +401,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int64_t indigoHash(int item)
+int64_t indigoHash(int item)
 {
     INDIGO_BEGIN
     {
@@ -422,7 +422,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoSmarts(int item)
+const char* indigoSmarts(int item)
 {
     INDIGO_BEGIN
     {
@@ -435,7 +435,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoCanonicalSmarts(int item)
+const char* indigoCanonicalSmarts(int item)
 {
     INDIGO_BEGIN
     {
@@ -486,7 +486,7 @@
     return false;
 }
 
-CEXPORT int indigoUnfoldHydrogens(int item)
+int indigoUnfoldHydrogens(int item)
 {
     INDIGO_BEGIN
     {
@@ -544,7 +544,7 @@
     return false;
 }
 
-CEXPORT int indigoFoldUnfoldHydrogens(int item)
+int indigoFoldUnfoldHydrogens(int item)
 {
     INDIGO_BEGIN
     {
@@ -617,7 +617,7 @@
     return to_remove.size() > 0;
 }
 
-CEXPORT int indigoFoldHydrogens(int item)
+int indigoFoldHydrogens(int item)
 {
     INDIGO_BEGIN
     {
@@ -651,7 +651,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetName(int handle, const char* name)
+int indigoSetName(int handle, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -668,7 +668,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoName(int handle)
+const char* indigoName(int handle)
 {
     INDIGO_BEGIN
     {
@@ -677,7 +677,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoRawData(int handler)
+const char* indigoRawData(int handler)
 {
     INDIGO_BEGIN
     {
@@ -707,7 +707,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoRemove(int item)
+int indigoRemove(int item)
 {
     INDIGO_BEGIN
     {
@@ -719,7 +719,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAt(int item, int index)
+int indigoAt(int item, int index)
 {
     INDIGO_BEGIN
     {
@@ -764,7 +764,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCount(int item)
+int indigoCount(int item)
 {
     INDIGO_BEGIN
     {
@@ -787,7 +787,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSerialize(int item, byte** buf, int* size)
+int indigoSerialize(int item, byte** buf, int* size)
 {
     INDIGO_BEGIN
     {
@@ -824,7 +824,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoUnserialize(const byte* buf, int size)
+int indigoUnserialize(const byte* buf, int size)
 {
     INDIGO_BEGIN
     {
@@ -850,7 +850,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClear(int item)
+int indigoClear(int item)
 {
     INDIGO_BEGIN
     {
@@ -873,7 +873,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoHighlight(int item)
+int indigoHighlight(int item)
 {
     INDIGO_BEGIN
     {
@@ -899,7 +899,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoUnhighlight(int item)
+int indigoUnhighlight(int item)
 {
     INDIGO_BEGIN
     {
@@ -937,7 +937,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIsHighlighted(int item)
+int indigoIsHighlighted(int item)
 {
     INDIGO_BEGIN
     {
@@ -963,7 +963,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSelect(int item)
+int indigoSelect(int item)
 {
     INDIGO_BEGIN
     {
@@ -989,7 +989,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoUnselect(int item)
+int indigoUnselect(int item)
 {
     INDIGO_BEGIN
     {
@@ -1027,7 +1027,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIsSelected(int item)
+int indigoIsSelected(int item)
 {
     INDIGO_BEGIN
     {
@@ -1053,7 +1053,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoOptimize(int query, const char* options)
+int indigoOptimize(int query, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -1109,17 +1109,17 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoHasZCoord(int item)
+int indigoHasZCoord(int item)
 {
     return _indigoHasCoord(item, BaseMolecule::hasZCoord, "indigoHasZCoord");
 }
 
-CEXPORT int indigoHasCoord(int item)
+int indigoHasCoord(int item)
 {
     return _indigoHasCoord(item, BaseMolecule::hasCoord, "indigoHasCoord");
 }
 
-CEXPORT const char* indigoDbgInternalType(int object)
+const char* indigoDbgInternalType(int object)
 {
     INDIGO_BEGIN
     {
@@ -1134,7 +1134,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoNormalize(int structure, const char* options)
+int indigoNormalize(int structure, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -1185,7 +1185,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoStandardize(int object)
+int indigoStandardize(int object)
 {
     INDIGO_BEGIN
     {
@@ -1210,7 +1210,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIonize(int object, float pH, float pH_toll)
+int indigoIonize(int object, float pH, float pH_toll)
 {
     INDIGO_BEGIN
     {
@@ -1222,7 +1222,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoBuildPkaModel(int max_level, float threshold, const char* filename)
+int indigoBuildPkaModel(int max_level, float threshold, const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -1234,7 +1234,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT float* indigoGetAcidPkaValue(int object, int atom, int level, int min_level)
+float* indigoGetAcidPkaValue(int object, int atom, int level, int min_level)
 {
     INDIGO_BEGIN
     {
@@ -1257,7 +1257,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT float* indigoGetBasicPkaValue(int object, int atom, int level, int min_level)
+float* indigoGetBasicPkaValue(int object, int atom, int level, int min_level)
 {
     INDIGO_BEGIN
     {
@@ -1280,7 +1280,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoIsPossibleFischerProjection(int object, const char* options)
+int indigoIsPossibleFischerProjection(int object, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -1333,7 +1333,7 @@
     }
 }
 
-CEXPORT int indigoTransformHELMtoSCSR(int object)
+int indigoTransformHELMtoSCSR(int object)
 {
     INDIGO_BEGIN
     {
@@ -1382,7 +1382,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCheckQuery(int item)
+int indigoCheckQuery(int item)
 {
     INDIGO_BEGIN
     {
@@ -1425,7 +1425,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCheckChirality(int item)
+int indigoCheckChirality(int item)
 {
     INDIGO_BEGIN
     {
@@ -1449,7 +1449,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCheck3DStereo(int item)
+int indigoCheck3DStereo(int item)
 {
     INDIGO_BEGIN
     {
@@ -1486,7 +1486,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCheckStereo(int item)
+int indigoCheckStereo(int item)
 {
     INDIGO_BEGIN
     {
@@ -1529,7 +1529,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoCheck(const char* item, const char* check_flags, const char* load_params)
+const char* indigoCheck(const char* item, const char* check_flags, const char* load_params)
 {
     INDIGO_BEGIN
     {
@@ -1544,7 +1544,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoCheckObj(int item, const char* check_flags)
+const char* indigoCheckObj(int item, const char* check_flags)
 {
     INDIGO_BEGIN
     {
@@ -1558,7 +1558,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoCheckStructure(const char* structure, const char* props)
+const char* indigoCheckStructure(const char* structure, const char* props)
 {
     INDIGO_BEGIN
     {
@@ -1584,7 +1584,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoJson(int item)
+const char* indigoJson(int item)
 {
     INDIGO_BEGIN
     {
@@ -1613,7 +1613,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoGetOriginalFormat(int item)
+const char* indigoGetOriginalFormat(int item)
 {
     INDIGO_BEGIN
     {
Index: cppcoro-src/cppcoro/lib/async_mutex.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/async_mutex.cpp b/cppcoro-src/cppcoro/lib/async_mutex.cpp
--- a/cppcoro-src/cppcoro/lib/async_mutex.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/async_mutex.cpp	(date 1714440647078)
@@ -85,7 +85,7 @@
 	waitersHead->m_awaiter.resume();
 }
 
-bool cppcoro::async_mutex_lock_operation::await_suspend(std::experimental::coroutine_handle<> awaiter) noexcept
+bool cppcoro::async_mutex_lock_operation::await_suspend(std::coroutine_handle<> awaiter) noexcept
 {
 	m_awaiter = awaiter;
 
Index: indigo-src/indigo/api/c/indigo/src/indigo_mapping.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_mapping.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_mapping.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_mapping.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_mapping.cpp	(date 1714440647078)
@@ -62,7 +62,7 @@
     return res_ptr.release();
 }
 
-CEXPORT int indigoMapAtom(int handle, int atom)
+int indigoMapAtom(int handle, int atom)
 {
     INDIGO_BEGIN
     {
@@ -105,7 +105,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoMapBond(int handle, int bond)
+int indigoMapBond(int handle, int bond)
 {
     INDIGO_BEGIN
     {
@@ -190,7 +190,7 @@
     }
 }
 
-CEXPORT int indigoHighlightedTarget(int item)
+int indigoHighlightedTarget(int item)
 {
     INDIGO_BEGIN
     {
Index: cppcoro-src/cppcoro/lib/socket_recv_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_recv_operation.cpp b/cppcoro-src/cppcoro/lib/socket_recv_operation.cpp
--- a/cppcoro-src/cppcoro/lib/socket_recv_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_recv_operation.cpp	(date 1714440647078)
@@ -7,10 +7,10 @@
 #include <cppcoro/net/socket.hpp>
 
 #if CPPCORO_OS_WINNT
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 
 bool cppcoro::net::socket_recv_operation_impl::try_start(
 	cppcoro::detail::win32_overlapped_operation_base& operation) noexcept
Index: indigo-src/indigo/api/c/indigo/src/indigo_stereo.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_stereo.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_stereo.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_stereo.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_stereo.cpp	(date 1714440647078)
@@ -22,7 +22,7 @@
 #include "molecule/molecule_exact_matcher.h"
 #include "reaction/reaction.h"
 
-CEXPORT int indigoStereocenterType(int atom)
+int indigoStereocenterType(int atom)
 {
     INDIGO_BEGIN
     {
@@ -65,7 +65,7 @@
     }
 }
 
-CEXPORT int indigoStereocenterGroup(int atom)
+int indigoStereocenterGroup(int atom)
 {
     INDIGO_BEGIN
     {
@@ -79,7 +79,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetStereocenterGroup(int atom, int group)
+int indigoSetStereocenterGroup(int atom, int group)
 {
     INDIGO_BEGIN
     {
@@ -94,7 +94,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoChangeStereocenterType(int atom, int type)
+int indigoChangeStereocenterType(int atom, int type)
 {
     INDIGO_BEGIN
     {
@@ -113,7 +113,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddStereocenter(int atom, int type, int v1, int v2, int v3, int v4)
+int indigoAddStereocenter(int atom, int type, int v1, int v2, int v3, int v4)
 {
     INDIGO_BEGIN
     {
@@ -145,7 +145,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const int* indigoStereocenterPyramid(int atom)
+const int* indigoStereocenterPyramid(int atom)
 {
     INDIGO_BEGIN
     {
@@ -159,7 +159,7 @@
     INDIGO_END(NULL);
 }
 
-CEXPORT int indigoCountStereocenters(int molecule)
+int indigoCountStereocenters(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -170,7 +170,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearAlleneCenters(int molecule)
+int indigoClearAlleneCenters(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -182,7 +182,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountAlleneCenters(int molecule)
+int indigoCountAlleneCenters(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -193,7 +193,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoBondStereo(int bond)
+int indigoBondStereo(int bond)
 {
     INDIGO_BEGIN
     {
@@ -220,7 +220,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoInvertStereo(int item)
+int indigoInvertStereo(int item)
 {
     INDIGO_BEGIN
     {
@@ -261,7 +261,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetStereo(int item)
+int indigoResetStereo(int item)
 {
     INDIGO_BEGIN
     {
@@ -290,7 +290,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearStereocenters(int object)
+int indigoClearStereocenters(int object)
 {
     INDIGO_BEGIN
     {
@@ -319,7 +319,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearCisTrans(int object)
+int indigoClearCisTrans(int object)
 {
     INDIGO_BEGIN
     {
@@ -433,7 +433,7 @@
     return sum;
 }
 
-CEXPORT int indigoResetSymmetricCisTrans(int handle)
+int indigoResetSymmetricCisTrans(int handle)
 {
     INDIGO_BEGIN
     {
@@ -455,7 +455,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetSymmetricStereocenters(int handle)
+int indigoResetSymmetricStereocenters(int handle)
 {
     INDIGO_BEGIN
     {
@@ -477,7 +477,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoMarkEitherCisTrans(int handle)
+int indigoMarkEitherCisTrans(int handle)
 {
     INDIGO_BEGIN
     {
@@ -499,7 +499,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoMarkStereobonds(int handle)
+int indigoMarkStereobonds(int handle)
 {
     INDIGO_BEGIN
     {
@@ -552,7 +552,7 @@
     }
 }
 
-CEXPORT int indigoValidateChirality(int handle)
+int indigoValidateChirality(int handle)
 {
     INDIGO_BEGIN
     {
Index: cppcoro-src/cppcoro/lib/async_auto_reset_event.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/async_auto_reset_event.cpp b/cppcoro-src/cppcoro/lib/async_auto_reset_event.cpp
--- a/cppcoro-src/cppcoro/lib/async_auto_reset_event.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/async_auto_reset_event.cpp	(date 1714440647078)
@@ -241,7 +241,7 @@
 {}
 
 bool cppcoro::async_auto_reset_event_operation::await_suspend(
-	std::experimental::coroutine_handle<> awaiter) noexcept
+	std::coroutine_handle<> awaiter) noexcept
 {
 	m_awaiter = awaiter;
 
Index: indigo-src/indigo/api/c/indigo/src/indigo_macros.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_macros.c b/indigo-src/indigo/api/c/indigo/src/indigo_macros.c
--- a/indigo-src/indigo/api/c/indigo/src/indigo_macros.c	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_macros.c	(date 1714440647078)
@@ -19,7 +19,7 @@
 #include "indigo.h"
 
 #define WRAPPER_LOAD_FROM_STRING(name)                                                                                                                         \
-    CEXPORT int name##FromString(const char* string)                                                                                                           \
+    INDIGO_EXPORT int name##FromString(const char* string)                                                                                                           \
     {                                                                                                                                                          \
         int source = indigoReadString(string);                                                                                                                 \
         int result;                                                                                                                                            \
@@ -33,7 +33,7 @@
     }
 
 #define WRAPPER_LOAD_FROM_FILE(name)                                                                                                                           \
-    CEXPORT int name##FromFile(const char* filename)                                                                                                           \
+    INDIGO_EXPORT int name##FromFile(const char* filename)                                                                                                           \
     {                                                                                                                                                          \
         int source = indigoReadFile(filename);                                                                                                                 \
         int result;                                                                                                                                            \
@@ -47,7 +47,7 @@
     }
 
 #define WRAPPER_LOAD_FROM_BUFFER(name)                                                                                                                         \
-    CEXPORT int name##FromBuffer(const char* buf, int size)                                                                                                    \
+    INDIGO_EXPORT int name##FromBuffer(const char* buf, int size)                                                                                                    \
     {                                                                                                                                                          \
         int source = indigoReadBuffer(buf, size);                                                                                                              \
         int result;                                                                                                                                            \
@@ -84,7 +84,7 @@
 WRAPPER_LOAD_FROM_FILE(indigoLoadReactionSmarts)
 WRAPPER_LOAD_FROM_BUFFER(indigoLoadReactionSmarts)
 
-CEXPORT int indigoSaveMolfileToFile(int molecule, const char* filename)
+INDIGO_EXPORT int indigoSaveMolfileToFile(int molecule, const char* filename)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -98,7 +98,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveJsonToFile(int item, const char* filename)
+INDIGO_EXPORT int indigoSaveJsonToFile(int item, const char* filename)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -112,7 +112,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveSequenceToFile(int item, const char* filename)
+INDIGO_EXPORT int indigoSaveSequenceToFile(int item, const char* filename)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -126,7 +126,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveCmlToFile(int molecule, const char* filename)
+INDIGO_EXPORT int indigoSaveCmlToFile(int molecule, const char* filename)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -140,7 +140,7 @@
     return res;
 }
 
-CEXPORT const char* indigoMolfile(int molecule)
+INDIGO_EXPORT const char* indigoMolfile(int molecule)
 {
     int b = indigoWriteBuffer();
     const char* res;
@@ -156,7 +156,7 @@
     return res;
 }
 
-CEXPORT const char* indigoSequence(int molecule)
+INDIGO_EXPORT const char* indigoSequence(int molecule)
 {
     int b = indigoWriteBuffer();
     const char* res;
@@ -172,7 +172,7 @@
     return res;
 }
 
-CEXPORT const char* indigoCdxBase64(int object)
+INDIGO_EXPORT const char* indigoCdxBase64(int object)
 {
     int b = indigoWriteBuffer();
     const char* res;
@@ -188,7 +188,7 @@
     return res;
 }
 
-CEXPORT const char* indigoCml(int molecule)
+INDIGO_EXPORT const char* indigoCml(int molecule)
 {
     int b = indigoWriteBuffer();
     const char* res;
@@ -204,7 +204,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveRxnfileToFile(int reaction, const char* filename)
+INDIGO_EXPORT int indigoSaveRxnfileToFile(int reaction, const char* filename)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -218,7 +218,7 @@
     return res;
 }
 
-CEXPORT const char* indigoRxnfile(int molecule)
+INDIGO_EXPORT const char* indigoRxnfile(int molecule)
 {
     int b = indigoWriteBuffer();
     const char* res;
@@ -234,7 +234,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveCdxmlToFile(int item, const char* filename)
+INDIGO_EXPORT int indigoSaveCdxmlToFile(int item, const char* filename)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -248,7 +248,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveCdxToFile(int item, const char* filename)
+INDIGO_EXPORT int indigoSaveCdxToFile(int item, const char* filename)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -262,7 +262,7 @@
     return res;
 }
 
-CEXPORT const char* indigoCdxml(int item)
+INDIGO_EXPORT const char* indigoCdxml(int item)
 {
     int b = indigoWriteBuffer();
     const char* res;
Index: cppcoro-src/cppcoro/lib/socket_helpers.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_helpers.hpp b/cppcoro-src/cppcoro/lib/socket_helpers.hpp
--- a/cppcoro-src/cppcoro/lib/socket_helpers.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_helpers.hpp	(date 1714440647078)
@@ -13,6 +13,9 @@
 struct sockaddr_storage;
 #endif
 
+# include <cstring>
+# include <memory>
+
 namespace cppcoro
 {
 	namespace net
Index: cppcoro-src/cppcoro/lib/read_write_file.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/read_write_file.cpp b/cppcoro-src/cppcoro/lib/read_write_file.cpp
--- a/cppcoro-src/cppcoro/lib/read_write_file.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/read_write_file.cpp	(date 1714440647078)
@@ -3,17 +3,17 @@
 // Licenced under MIT license. See LICENSE.txt for details.
 ///////////////////////////////////////////////////////////////////////////////
 
-#include <cppcoro\read_write_file.hpp>
+#include <cppcoro/read_write_file.hpp>
 
 #if CPPCORO_OS_WINNT
 # ifndef WIN32_LEAN_AND_MEAN
 #  define WIN32_LEAN_AND_MEAN
 # endif
-# include <Windows.h>
+# include <windows.h>
 
 cppcoro::read_write_file cppcoro::read_write_file::open(
 	io_service& ioService,
-	const std::experimental::filesystem::path& path,
+	const std::filesystem::path& path,
 	file_open_mode openMode,
 	file_share_mode shareMode,
 	file_buffering_mode bufferingMode)
Index: cppcoro-src/cppcoro/lib/win32.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/win32.cpp b/cppcoro-src/cppcoro/lib/win32.cpp
--- a/cppcoro-src/cppcoro/lib/win32.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/win32.cpp	(date 1714440647078)
@@ -8,7 +8,7 @@
 #ifndef WIN32_LEAN_AND_MEAN
 # define WIN32_LEAN_AND_MEAN
 #endif
-#include <Windows.h>
+#include <windows.h>
 
 void cppcoro::detail::win32::safe_handle::close() noexcept
 {
Index: indigo-src/indigo/api/c/indigo/src/indigo_basic.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_basic.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_basic.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_basic.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_basic.cpp	(date 1714440647078)
@@ -21,7 +21,7 @@
 #include "indigo_internal.h"
 #include <memory>
 
-CEXPORT int indigoNext(int iter)
+int indigoNext(int iter)
 {
     INDIGO_BEGIN
     {
@@ -35,7 +35,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoHasNext(int iter)
+int indigoHasNext(int iter)
 {
     INDIGO_BEGIN
     {
@@ -44,7 +44,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIndex(int handle)
+int indigoIndex(int handle)
 {
     INDIGO_BEGIN
     {
@@ -53,7 +53,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClone(int object)
+int indigoClone(int object)
 {
     INDIGO_BEGIN
     {
Index: cppcoro-src/cppcoro/lib/socket_helpers.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_helpers.cpp b/cppcoro-src/cppcoro/lib/socket_helpers.cpp
--- a/cppcoro-src/cppcoro/lib/socket_helpers.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_helpers.cpp	(date 1714440647078)
@@ -11,10 +11,10 @@
 #include <cstring>
 #include <cassert>
 
-#include <WinSock2.h>
-#include <WS2tcpip.h>
-#include <MSWSock.h>
-#include <Windows.h>
+#include <winsock2.h>
+#include <ws2tcpip.h>
+#include <mswsock.h>
+#include <windows.h>
 
 
 cppcoro::net::ip_endpoint
@@ -74,7 +74,11 @@
 		std::memcpy(&ipv6Address.sin6_addr, ipv6EndPoint.address().bytes(), 16);
 		ipv6Address.sin6_port = htons(ipv6EndPoint.port());
 		ipv6Address.sin6_flowinfo = 0;
+#ifdef SCOPEID_UNSPECIFIED_INIT
 		ipv6Address.sin6_scope_struct = SCOPEID_UNSPECIFIED_INIT;
+#else
+		ipv6Address.sin6_scope_struct = {0};
+#endif
 
 		std::memcpy(&address.get(), &ipv6Address, sizeof(ipv6Address));
 
Index: protobuf-src/protobuf/src/google/protobuf/repeated_ptr_field.cc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/protobuf-src/protobuf/src/google/protobuf/repeated_ptr_field.cc b/protobuf-src/protobuf/src/google/protobuf/repeated_ptr_field.cc
--- a/protobuf-src/protobuf/src/google/protobuf/repeated_ptr_field.cc	(revision 2434ef2adf0c74149b9d547ac5fb545a1ff8b6b5)
+++ b/protobuf-src/protobuf/src/google/protobuf/repeated_ptr_field.cc	(date 1714440647078)
@@ -166,7 +166,7 @@
     char* PROTOBUF_RESTRICT, char* PROTOBUF_RESTRICT);
 
 template <>
-void RepeatedPtrFieldBase::MergeFrom<std::string>(
+PROTOBUF_EXPORT_TEMPLATE_DEFINE void RepeatedPtrFieldBase::MergeFrom<std::string>(
     const RepeatedPtrFieldBase& from) {
   ABSL_DCHECK_NE(&from, this);
   int new_size = current_size_ + from.current_size_;
Index: protobuf-src/protobuf/src/google/protobuf/map_entry.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/protobuf-src/protobuf/src/google/protobuf/map_entry.h b/protobuf-src/protobuf/src/google/protobuf/map_entry.h
--- a/protobuf-src/protobuf/src/google/protobuf/map_entry.h	(revision 2434ef2adf0c74149b9d547ac5fb545a1ff8b6b5)
+++ b/protobuf-src/protobuf/src/google/protobuf/map_entry.h	(date 1714536001016)
@@ -50,7 +50,11 @@
   using Message::Message;

   const ClassData* GetClassData() const final {
+#ifdef _MSC_VER
+    static const ClassDataFull data = {
+#else
     ABSL_CONST_INIT static const ClassDataFull data = {
+#endif
         {
             nullptr,  // on_demand_register_arena_dtor
             PROTOBUF_FIELD_OFFSET(MapEntryBase, _cached_size_),
Index: indigo-src/indigo/api/c/indigo/src/indigo_match.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_match.h b/indigo-src/indigo/api/c/indigo/src/indigo_match.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_match.h	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_match.h	(date 1714440647078)
@@ -101,7 +101,7 @@
 };
 
 // Matcher class for matching queries on a specified target molecule
-class DLLEXPORT IndigoMoleculeSubstructureMatcher : public IndigoObject
+class INDIGO_EXPORT IndigoMoleculeSubstructureMatcher : public IndigoObject
 {
 public:
     enum
@@ -145,7 +145,7 @@
     MoleculeAtomNeighbourhoodCounters _nei_counters, _nei_counters_h_unfolded;
 };
 
-class DLLEXPORT IndigoReactionSubstructureMatcher : public IndigoObject
+class INDIGO_EXPORT IndigoReactionSubstructureMatcher : public IndigoObject
 {
 public:
     IndigoReactionSubstructureMatcher(Reaction& target);
@@ -164,8 +164,8 @@
     Array<int> mol_mapping;
 };
 
-DLLEXPORT bool _indigoParseTautomerFlags(const char* flags, IndigoTautomerParams& params);
-DLLEXPORT int _indigoParseExactFlags(const char* flags, bool reaction, float* rms_threshold);
+INDIGO_EXPORT bool _indigoParseTautomerFlags(const char* flags, IndigoTautomerParams& params);
+INDIGO_EXPORT int _indigoParseExactFlags(const char* flags, bool reaction, float* rms_threshold);
 
 #ifdef _WIN32
 #pragma warning(pop)
Index: indigo-src/indigo/api/c/indigo/src/indigo_reaction.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_reaction.h b/indigo-src/indigo/api/c/indigo/src/indigo_reaction.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_reaction.h	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_reaction.h	(date 1714440647078)
@@ -29,7 +29,7 @@
 #pragma warning(disable : 4251)
 #endif
 
-class DLLEXPORT IndigoBaseReaction : public IndigoObject
+class INDIGO_EXPORT IndigoBaseReaction : public IndigoObject
 {
 public:
     explicit IndigoBaseReaction(int type_);
@@ -59,7 +59,7 @@
     indigo::PropertiesMap _properties;
 };
 
-class DLLEXPORT IndigoReaction : public IndigoBaseReaction
+class INDIGO_EXPORT IndigoReaction : public IndigoBaseReaction
 {
 public:
     IndigoReaction();
@@ -78,7 +78,7 @@
     Reaction rxn;
 };
 
-class DLLEXPORT IndigoQueryReaction : public IndigoBaseReaction
+class INDIGO_EXPORT IndigoQueryReaction : public IndigoBaseReaction
 {
 public:
     IndigoQueryReaction();
Index: cppcoro-src/cppcoro/lib/socket_disconnect_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_disconnect_operation.cpp b/cppcoro-src/cppcoro/lib/socket_disconnect_operation.cpp
--- a/cppcoro-src/cppcoro/lib/socket_disconnect_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_disconnect_operation.cpp	(date 1714440647078)
@@ -11,10 +11,10 @@
 #include <system_error>
 
 #if CPPCORO_OS_WINNT
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 
 bool cppcoro::net::socket_disconnect_operation_impl::try_start(
 	cppcoro::detail::win32_overlapped_operation_base& operation) noexcept
Index: openssl-src/openssl/crypto/buildinf.h.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openssl-src/openssl/crypto/buildinf.h.cmake b/openssl-src/openssl/crypto/buildinf.h.cmake
new file mode 100644
--- /dev/null	(date 1714440647086)
+++ b/openssl-src/openssl/crypto/buildinf.h.cmake	(date 1714440647086)
@@ -0,0 +1,5 @@
+/* auto-generated for crypto/cversion.c */
+#define CFLAGS "compiler: @CMAKE_C_COMPILER_ID@ @CMAKE_C_FLAGS@"
+#define PLATFORM "platform: @CMAKE_SYSTEM_NAME@"
+#define DATE "built on: @BUILDINF_DATE@"
+static const char *compiler_flags = CFLAGS;
Index: indigo-src/indigo/api/c/indigo/src/option_manager.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/option_manager.cpp b/indigo-src/indigo/api/c/indigo/src/option_manager.cpp
--- a/indigo-src/indigo/api/c/indigo/src/option_manager.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/option_manager.cpp	(date 1714440647078)
@@ -29,7 +29,7 @@
     return mgr;
 }
 
-DLLEXPORT sf::safe_shared_hide_obj<IndigoOptionManager>& indigoGetOptionManager(const qword id)
+sf::safe_shared_hide_obj<IndigoOptionManager>& indigoGetOptionManager(const qword id)
 {
     return IndigoOptionManager::getIndigoOptionManager().getLocalCopy(id);
 }
Index: openssl-src/openssl/crypto/bn_conf.h.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openssl-src/openssl/crypto/bn_conf.h.cmake b/openssl-src/openssl/crypto/bn_conf.h.cmake
new file mode 100644
--- /dev/null	(date 1714440647086)
+++ b/openssl-src/openssl/crypto/bn_conf.h.cmake	(date 1714440647086)
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2016 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://www.openssl.org/source/license.html
+ */
+
+#ifndef OSSL_CRYPTO_BN_CONF_H
+# define OSSL_CRYPTO_BN_CONF_H
+
+/*
+ * The contents of this file are not used in the UEFI build, as
+ * both 32-bit and 64-bit builds are supported from a single run
+ * of the Configure script.
+ */
+
+/* Should we define BN_DIV2W here? */
+
+/* Only one for the following should be defined */
+#cmakedefine SIXTY_FOUR_BIT_LONG
+#cmakedefine SIXTY_FOUR_BIT
+#cmakedefine THIRTY_TWO_BIT
+
+#endif
Index: indigo-src/indigo/api/c/indigo/src/indigo_loaders.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_loaders.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_loaders.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_loaders.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_loaders.cpp	(date 1714440647078)
@@ -511,7 +511,7 @@
     return next();
 }
 
-CEXPORT int indigoIterateSDF(int reader)
+int indigoIterateSDF(int reader)
 {
     INDIGO_BEGIN
     {
@@ -522,7 +522,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateRDF(int reader)
+int indigoIterateRDF(int reader)
 {
     INDIGO_BEGIN
     {
@@ -533,7 +533,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateSmiles(int reader)
+int indigoIterateSmiles(int reader)
 {
     INDIGO_BEGIN
     {
@@ -544,7 +544,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoTell(int handle)
+int indigoTell(int handle)
 {
     INDIGO_BEGIN
     {
@@ -585,7 +585,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT long long indigoTell64(int handle)
+long long indigoTell64(int handle)
 {
     INDIGO_BEGIN
     {
@@ -618,7 +618,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateSDFile(const char* filename)
+int indigoIterateSDFile(const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -627,7 +627,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateRDFile(const char* filename)
+int indigoIterateRDFile(const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -636,7 +636,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateSmilesFile(const char* filename)
+int indigoIterateSmilesFile(const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -775,7 +775,7 @@
         return new IndigoCmlMolecule(loader->data, counter, offset);
 }
 
-CEXPORT int indigoIterateCML(int reader)
+int indigoIterateCML(int reader)
 {
     INDIGO_BEGIN
     {
@@ -786,7 +786,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateCMLFile(const char* filename)
+int indigoIterateCMLFile(const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -937,7 +937,7 @@
         return new IndigoCdxMolecule(loader->data, loader->properties, index, 0);
 }
 
-CEXPORT int indigoIterateCDX(int reader)
+int indigoIterateCDX(int reader)
 {
     INDIGO_BEGIN
     {
@@ -948,7 +948,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateCDXFile(const char* filename)
+int indigoIterateCDXFile(const char* filename)
 {
     INDIGO_BEGIN
     {
Index: cppcoro-src/cppcoro/lib/socket_send_to_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_send_to_operation.cpp b/cppcoro-src/cppcoro/lib/socket_send_to_operation.cpp
--- a/cppcoro-src/cppcoro/lib/socket_send_to_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_send_to_operation.cpp	(date 1714440647078)
@@ -9,10 +9,10 @@
 #if CPPCORO_OS_WINNT
 # include "socket_helpers.hpp"
 
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 
 bool cppcoro::net::socket_send_to_operation_impl::try_start(
 	cppcoro::detail::win32_overlapped_operation_base& operation) noexcept
Index: indigo-src/indigo/api/c/indigo/src/indigo_internal.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_internal.h b/indigo-src/indigo/api/c/indigo/src/indigo_internal.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_internal.h	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_internal.h	(date 1714440647078)
@@ -70,9 +70,7 @@
     typedef ObjArray<PropertiesMap> MonomersProperties;
 } // namespace indigo
 
-extern DLLEXPORT sf::safe_shared_hide_obj<IndigoOptionManager>& indigoGetOptionManager(const qword id = TL_GET_SESSION_ID());
-
-class DLLEXPORT IndigoObject
+class INDIGO_EXPORT IndigoObject
 {
 public:
     explicit IndigoObject(int type_);
@@ -231,7 +229,7 @@
     std::unique_ptr<std::pair<PtrArray<GROSS_UNITS>, PtrArray<GROSS_UNITS>>> gross;
 };
 
-struct DLLEXPORT ProductEnumeratorParams
+struct INDIGO_EXPORT ProductEnumeratorParams
 {
     ProductEnumeratorParams()
     {
@@ -258,7 +256,7 @@
     int max_product_count;
 };
 
-class DLLEXPORT Indigo
+class INDIGO_EXPORT Indigo
 {
 public:
     Indigo();
@@ -383,7 +381,7 @@
     std::unique_ptr<abbreviations::IndigoAbbreviations> _abbreviations = nullptr;
 };
 
-class DLLEXPORT IndigoPluginContext
+class INDIGO_EXPORT IndigoPluginContext
 {
 public:
     IndigoPluginContext();
@@ -422,9 +420,9 @@
     return fail;                                                                                                                                               \
     }
 
-DLLEXPORT Indigo& indigoGetInstance();
+INDIGO_EXPORT Indigo& indigoGetInstance();
 
-class DLLEXPORT IndigoError : public Exception
+class INDIGO_EXPORT IndigoError : public Exception
 {
 public:
     explicit IndigoError(const char* format, ...);
Index: cppcoro-src/cppcoro/lib/static_thread_pool.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/static_thread_pool.cpp b/cppcoro-src/cppcoro/lib/static_thread_pool.cpp
--- a/cppcoro-src/cppcoro/lib/static_thread_pool.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/static_thread_pool.cpp	(date 1714440647078)
@@ -12,6 +12,7 @@
 #include <cassert>
 #include <mutex>
 #include <chrono>
+#include <utility>
 
 namespace
 {
@@ -319,7 +320,7 @@
 	};
 
 	void static_thread_pool::schedule_operation::await_suspend(
-		std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+		std::coroutine_handle<> awaitingCoroutine) noexcept
 	{
 		m_awaitingCoroutine = awaitingCoroutine;
 		m_threadPool->schedule_impl(this);
Index: indigo-src/indigo/api/c/indigo/src/indigo_properties.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_properties.h b/indigo-src/indigo/api/c/indigo/src/indigo_properties.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_properties.h	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_properties.h	(date 1714440647078)
@@ -25,7 +25,7 @@
     class PropertiesMap;
 }
 
-class DLLEXPORT IndigoProperty : public IndigoObject
+class INDIGO_EXPORT IndigoProperty : public IndigoObject
 {
 public:
     IndigoProperty(indigo::PropertiesMap& props, int idx);
Index: indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.h b/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.h	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.h	(date 1714440647078)
@@ -37,7 +37,7 @@
 class IndigoDeconvolutionElem;
 class IndigoDecompositionMatch;
 
-class DLLEXPORT IndigoDeconvolution : public IndigoObject
+class INDIGO_EXPORT IndigoDeconvolution : public IndigoObject
 {
 private:
     enum
@@ -143,7 +143,7 @@
     ObjArray<IndigoDeconvolutionElem> _deconvolutionElems;
 };
 
-class DLLEXPORT IndigoDeconvolutionElem : public IndigoObject
+class INDIGO_EXPORT IndigoDeconvolutionElem : public IndigoObject
 {
 public:
     IndigoDeconvolutionElem(Molecule& mol);
@@ -169,7 +169,7 @@
     indigo::PropertiesMap _properties;
 };
 
-class DLLEXPORT IndigoDecompositionMatch : public IndigoObject
+class INDIGO_EXPORT IndigoDecompositionMatch : public IndigoObject
 {
 public:
     IndigoDecompositionMatch();
@@ -205,7 +205,7 @@
     bool _completeScaffold;
 };
 
-class DLLEXPORT IndigoDeconvolutionIter : public IndigoObject
+class INDIGO_EXPORT IndigoDeconvolutionIter : public IndigoObject
 {
 public:
     IndigoDeconvolutionIter(ObjArray<IndigoDeconvolutionElem>& items);
@@ -218,7 +218,7 @@
     int _index;
     ObjArray<IndigoDeconvolutionElem>& _items;
 };
-class DLLEXPORT IndigoDecompositionMatchIter : public IndigoObject
+class INDIGO_EXPORT IndigoDecompositionMatchIter : public IndigoObject
 {
 public:
     IndigoDecompositionMatchIter(ObjArray<IndigoDecompositionMatch>& matches);
Index: indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.h b/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.h	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.h	(date 1714440647078)
@@ -26,7 +26,7 @@
 #pragma warning(disable : 4251)
 #endif
 
-class DLLEXPORT IndigoFingerprint : public IndigoObject
+class INDIGO_EXPORT IndigoFingerprint : public IndigoObject
 {
 public:
     IndigoFingerprint();
Index: cppcoro-src/cppcoro/lib/async_manual_reset_event.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/async_manual_reset_event.cpp b/cppcoro-src/cppcoro/lib/async_manual_reset_event.cpp
--- a/cppcoro-src/cppcoro/lib/async_manual_reset_event.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/async_manual_reset_event.cpp	(date 1714440647078)
@@ -72,7 +72,7 @@
 }
 
 bool cppcoro::async_manual_reset_event_operation::await_suspend(
-	std::experimental::coroutine_handle<> awaiter) noexcept
+	std::coroutine_handle<> awaiter) noexcept
 {
 	m_awaiter = awaiter;
 
Index: cppcoro-src/cppcoro/lib/write_only_file.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/write_only_file.cpp b/cppcoro-src/cppcoro/lib/write_only_file.cpp
--- a/cppcoro-src/cppcoro/lib/write_only_file.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/write_only_file.cpp	(date 1714440647078)
@@ -3,17 +3,17 @@
 // Licenced under MIT license. See LICENSE.txt for details.
 ///////////////////////////////////////////////////////////////////////////////
 
-#include <cppcoro\write_only_file.hpp>
+#include <cppcoro/write_only_file.hpp>
 
 #if CPPCORO_OS_WINNT
 # ifndef WIN32_LEAN_AND_MEAN
 #  define WIN32_LEAN_AND_MEAN
 # endif
-# include <Windows.h>
+# include <windows.h>
 
 cppcoro::write_only_file cppcoro::write_only_file::open(
 	io_service& ioService,
-	const std::experimental::filesystem::path& path,
+	const std::filesystem::path& path,
 	file_open_mode openMode,
 	file_share_mode shareMode,
 	file_buffering_mode bufferingMode)
Index: ringdecomposerlib-src/ringdecomposerlib/src/RingDecomposerLib/RingDecomposerLib.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ringdecomposerlib-src/ringdecomposerlib/src/RingDecomposerLib/RingDecomposerLib.h b/ringdecomposerlib-src/ringdecomposerlib/src/RingDecomposerLib/RingDecomposerLib.h
--- a/ringdecomposerlib-src/ringdecomposerlib/src/RingDecomposerLib/RingDecomposerLib.h	(revision 7b1629781cfb7fda29716d1af14a6110bb553892)
+++ b/ringdecomposerlib-src/ringdecomposerlib/src/RingDecomposerLib/RingDecomposerLib.h	(date 1714440647078)
@@ -27,13 +27,10 @@
 #ifndef RING_DECOMPOSER_LIB_H
 #define RING_DECOMPOSER_LIB_H
 
-#if (defined( _WIN32 ) && defined( _MSC_VER ) )
-    /* Win32 & MS VC ++ */
-    #define RDL_API __declspec(dllexport)
-#elif __GNUC__ >= 4 || defined(__clang__)
-    #define RDL_API __attribute__((visibility("default")))
-#else
-    #define RDL_API
+#include "ringdecomposerlib_export.h"
+
+#ifndef RDL_API
+#define RDL_API RINGDECOMPOSERLIB_EXPORT
 #endif
 
 #ifdef __cplusplus
Index: openbabel-src/openbabel/include/RDKitConv.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/RDKitConv.h b/openbabel-src/openbabel/include/RDKitConv.h
--- a/openbabel-src/openbabel/include/RDKitConv.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/RDKitConv.h	(date 1714440647078)
@@ -1,7 +1,7 @@
 #include <openbabel/mol.h>
 #include <openbabel/obiter.h>
-#include <graphmol/RWMol.h>
-#include <graphmol/Atom.h>
+#include <GraphMol/RWMol.h>
+#include <GraphMol/Atom.h>
 
 ///Convert OpenBabel OBMol to and from RGKit molecules
 RDKit::RWMol OBMolToRWMol(OpenBabel::OBMol* pOBMol);
Index: indigo-src/indigo/api/c/indigo/src/indigo_savers.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_savers.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_savers.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_savers.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_savers.cpp	(date 1714440647078)
@@ -147,7 +147,7 @@
     append(_output, object);
 }
 
-CEXPORT int indigoSdfAppend(int output, int molecule)
+int indigoSdfAppend(int output, int molecule)
 {
     INDIGO_BEGIN
     {
@@ -275,7 +275,7 @@
     append(_output, object);
 }
 
-CEXPORT int indigoSmilesAppend(int output, int item)
+int indigoSmilesAppend(int output, int item)
 {
     INDIGO_BEGIN
     {
@@ -420,7 +420,7 @@
     appendFooter(_output);
 }
 
-CEXPORT int indigoCmlHeader(int output)
+int indigoCmlHeader(int output)
 {
     INDIGO_BEGIN
     {
@@ -431,7 +431,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCmlFooter(int output)
+int indigoCmlFooter(int output)
 {
     INDIGO_BEGIN
     {
@@ -442,7 +442,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCmlAppend(int output, int item)
+int indigoCmlAppend(int output, int item)
 {
     INDIGO_BEGIN
     {
@@ -521,7 +521,7 @@
     appendHeader(_output);
 }
 
-CEXPORT int indigoRdfHeader(int output)
+int indigoRdfHeader(int output)
 {
     INDIGO_BEGIN
     {
@@ -532,7 +532,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRdfAppend(int output, int item)
+int indigoRdfAppend(int output, int item)
 {
     INDIGO_BEGIN
     {
@@ -547,7 +547,7 @@
 //
 // Saving functions
 //
-CEXPORT int indigoCreateSaver(int output, const char* format)
+int indigoCreateSaver(int output, const char* format)
 {
     INDIGO_BEGIN
     {
@@ -557,7 +557,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateFileSaver(const char* filename, const char* format)
+int indigoCreateFileSaver(const char* filename, const char* format)
 {
     INDIGO_BEGIN
     {
@@ -569,7 +569,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveMolfile(int molecule, int output)
+int indigoSaveMolfile(int molecule, int output)
 {
     INDIGO_BEGIN
     {
@@ -601,7 +601,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveJson(int item, int output)
+int indigoSaveJson(int item, int output)
 {
     INDIGO_BEGIN
     {
@@ -630,7 +630,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveCml(int item, int output)
+int indigoSaveCml(int item, int output)
 {
     INDIGO_BEGIN
     {
@@ -663,7 +663,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveMDLCT(int item, int output)
+int indigoSaveMDLCT(int item, int output)
 {
     INDIGO_BEGIN
     {
@@ -691,7 +691,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveRxnfile(int reaction, int output)
+int indigoSaveRxnfile(int reaction, int output)
 {
     INDIGO_BEGIN
     {
@@ -709,7 +709,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAppend(int saver_id, int object)
+int indigoAppend(int saver_id, int object)
 {
     INDIGO_BEGIN
     {
@@ -724,7 +724,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveCdxml(int item, int output)
+int indigoSaveCdxml(int item, int output)
 {
     INDIGO_BEGIN
     {
@@ -768,7 +768,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveCdx(int item, int output)
+int indigoSaveCdx(int item, int output)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_reaction.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_reaction.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_reaction.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_reaction.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_reaction.cpp	(date 1714440647078)
@@ -352,7 +352,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadReaction(int source)
+int indigoLoadReaction(int source)
 {
     INDIGO_BEGIN
     {
@@ -374,7 +374,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadQueryReaction(int source)
+int indigoLoadQueryReaction(int source)
 {
     INDIGO_BEGIN
     {
@@ -395,27 +395,27 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateReactants(int reaction)
+int indigoIterateReactants(int reaction)
 {
     return _indigoIterateReaction(reaction, IndigoReactionIter::REACTANTS);
 }
 
-CEXPORT int indigoIterateProducts(int reaction)
+int indigoIterateProducts(int reaction)
 {
     return _indigoIterateReaction(reaction, IndigoReactionIter::PRODUCTS);
 }
 
-CEXPORT int indigoIterateCatalysts(int reaction)
+int indigoIterateCatalysts(int reaction)
 {
     return _indigoIterateReaction(reaction, IndigoReactionIter::CATALYSTS);
 }
 
-CEXPORT int indigoIterateMolecules(int reaction)
+int indigoIterateMolecules(int reaction)
 {
     return _indigoIterateReaction(reaction, IndigoReactionIter::MOLECULES);
 }
 
-CEXPORT int indigoCreateReaction(void)
+int indigoCreateReaction(void)
 {
     INDIGO_BEGIN
     {
@@ -424,7 +424,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateQueryReaction(void)
+int indigoCreateQueryReaction(void)
 {
     INDIGO_BEGIN
     {
@@ -433,7 +433,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddReactant(int reaction, int molecule)
+int indigoAddReactant(int reaction, int molecule)
 {
     INDIGO_BEGIN
     {
@@ -445,7 +445,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddProduct(int reaction, int molecule)
+int indigoAddProduct(int reaction, int molecule)
 {
     INDIGO_BEGIN
     {
@@ -457,7 +457,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddCatalyst(int reaction, int molecule)
+int indigoAddCatalyst(int reaction, int molecule)
 {
     INDIGO_BEGIN
     {
@@ -469,7 +469,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountReactants(int reaction)
+int indigoCountReactants(int reaction)
 {
     INDIGO_BEGIN
     {
@@ -478,7 +478,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountProducts(int reaction)
+int indigoCountProducts(int reaction)
 {
     INDIGO_BEGIN
     {
@@ -487,7 +487,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountCatalysts(int reaction)
+int indigoCountCatalysts(int reaction)
 {
     INDIGO_BEGIN
     {
@@ -496,7 +496,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountMolecules(int handle)
+int indigoCountMolecules(int handle)
 {
     INDIGO_BEGIN
     {
@@ -510,7 +510,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetMolecule(int reaction, int index)
+int indigoGetMolecule(int reaction, int index)
 {
     INDIGO_BEGIN
     {
@@ -530,7 +530,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoMapMolecule(int handle, int molecule)
+int indigoMapMolecule(int handle, int molecule)
 {
     INDIGO_BEGIN
     {
@@ -596,7 +596,7 @@
     return nmode;
 }
 
-CEXPORT int indigoAutomap(int reaction, const char* mode)
+int indigoAutomap(int reaction, const char* mode)
 {
     INDIGO_BEGIN
     {
@@ -639,7 +639,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetAtomMappingNumber(int reaction, int reaction_atom)
+int indigoGetAtomMappingNumber(int reaction, int reaction_atom)
 {
     INDIGO_BEGIN
     {
@@ -656,7 +656,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetAtomMappingNumber(int reaction, int reaction_atom, int number)
+int indigoSetAtomMappingNumber(int reaction, int reaction_atom, int number)
 {
     INDIGO_BEGIN
     {
@@ -676,7 +676,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetReactingCenter(int reaction, int reaction_bond, int* rc)
+int indigoGetReactingCenter(int reaction, int reaction_bond, int* rc)
 {
     INDIGO_BEGIN
     {
@@ -694,7 +694,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetReactingCenter(int reaction, int reaction_bond, int rc)
+int indigoSetReactingCenter(int reaction, int reaction_bond, int rc)
 {
     INDIGO_BEGIN
     {
@@ -714,7 +714,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearAAM(int reaction)
+int indigoClearAAM(int reaction)
 {
     INDIGO_BEGIN
     {
@@ -725,7 +725,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCorrectReactingCenters(int reaction)
+int indigoCorrectReactingCenters(int reaction)
 {
     INDIGO_BEGIN
     {
@@ -738,7 +738,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadReactionSmarts(int source)
+int indigoLoadReactionSmarts(int source)
 {
     INDIGO_BEGIN
     {
@@ -756,7 +756,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoCanonicalRSmiles(int reaction)
+const char* indigoCanonicalRSmiles(int reaction)
 {
     INDIGO_BEGIN
     {
Index: cppcoro-src/cppcoro/lib/spin_wait.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/spin_wait.cpp b/cppcoro-src/cppcoro/lib/spin_wait.cpp
--- a/cppcoro-src/cppcoro/lib/spin_wait.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/spin_wait.cpp	(date 1714440647078)
@@ -10,7 +10,7 @@
 
 #if CPPCORO_OS_WINNT
 # define WIN32_LEAN_AND_MEAN
-# include <Windows.h>
+# include <windows.h>
 #endif
 
 namespace
Index: cppcoro-src/cppcoro/lib/auto_reset_event.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/auto_reset_event.cpp b/cppcoro-src/cppcoro/lib/auto_reset_event.cpp
--- a/cppcoro-src/cppcoro/lib/auto_reset_event.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/auto_reset_event.cpp	(date 1714440647078)
@@ -7,7 +7,7 @@
 
 #if CPPCORO_OS_WINNT
 # define WIN32_LEAN_AND_MEAN
-# include <Windows.h>
+# include <windows.h>
 # include <system_error>
 #endif
 
Index: skia-src/skia/src/core/SkPath.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/src/core/SkPath.cpp b/skia-src/skia/src/core/SkPath.cpp
--- a/skia-src/skia/src/core/SkPath.cpp	(revision 3d4e45907f9b239a54957001d619d2d4a6ca06b4)
+++ b/skia-src/skia/src/core/SkPath.cpp	(date 1714440647078)
@@ -2272,7 +2272,7 @@
 };
 
 SkPathConvexity SkPath::computeConvexity() const {
-    auto setComputedConvexity = [=](SkPathConvexity convexity){
+    auto setComputedConvexity = [=, this](SkPathConvexity convexity){
         SkASSERT(SkPathConvexity::kUnknown != convexity);
         this->setConvexity(convexity);
         return convexity;
Index: indigo-src/indigo/api/c/indigo/src/option_manager.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/option_manager.h b/indigo-src/indigo/api/c/indigo/src/option_manager.h
--- a/indigo-src/indigo/api/c/indigo/src/option_manager.h	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/option_manager.h	(date 1714440647078)
@@ -21,12 +21,13 @@
 
 #include "base_cpp/os_sync_wrapper.h"
 #include "base_cpp/red_black.h"
+#include "indigo.h"
 
 #include <sstream>
 
 using namespace indigo;
 
-#define DECL_SET_OPT_HANDLER(suffix, ftype, type, map) DLLEXPORT void setOptionHandler##suffix(const char* name, ftype func);
+#define DECL_SET_OPT_HANDLER(suffix, ftype, type, map) INDIGO_EXPORT void setOptionHandler##suffix(const char* name, ftype func);
 
 #define DEF_HANDLER(suffix, ftype, type, map)                                                                                                                  \
     void setOptionHandler##suffix(const char* name, ftype func)                                                                                                \
@@ -84,7 +85,7 @@
         value.push(0);                                                                                                                                         \
     }
 
-class DLLEXPORT IndigoOptionManager
+class INDIGO_EXPORT IndigoOptionManager
 {
 public:
     IndigoOptionManager() = default;
@@ -186,4 +187,7 @@
     IndigoOptionManager(const IndigoOptionManager&);
 };
 
+INDIGO_EXPORT sf::safe_shared_hide_obj<IndigoOptionManager> &
+indigoGetOptionManager(const qword id = TL_GET_SESSION_ID());
+
 #endif //__otion_manager_h__
Index: freetype-src/freetype/include/freetype/config/ftoption.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/freetype-src/freetype/include/freetype/config/ftoption.h b/freetype-src/freetype/include/freetype/config/ftoption.h
--- a/freetype-src/freetype/include/freetype/config/ftoption.h	(revision 920c5502cc3ddda88f6c7d85ee834ac611bb11cc)
+++ b/freetype-src/freetype/include/freetype/config/ftoption.h	(date 1714440647078)
@@ -273,7 +273,7 @@
    *   options set by those programs have precedence, overwriting the value
    *   here with the configured one.
    */
-/* #define FT_CONFIG_OPTION_USE_PNG */
+#define FT_CONFIG_OPTION_USE_PNG
 
 
   /**************************************************************************
Index: cppcoro-src/cppcoro/lib/socket.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket.cpp b/cppcoro-src/cppcoro/lib/socket.cpp
--- a/cppcoro-src/cppcoro/lib/socket.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket.cpp	(date 1714440647078)
@@ -17,10 +17,10 @@
 #include "socket_helpers.hpp"
 
 #if CPPCORO_OS_WINNT
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 
 namespace
 {
Index: indigo-src/indigo/api/c/indigo/src/indigo_savers.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_savers.h b/indigo-src/indigo/api/c/indigo/src/indigo_savers.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_savers.h	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_savers.h	(date 1714440647078)
@@ -26,7 +26,7 @@
 
 #include "indigo_internal.h"
 
-class DLLEXPORT IndigoSaver : public IndigoObject
+class INDIGO_EXPORT IndigoSaver : public IndigoObject
 {
 public:
     IndigoSaver(Output& output);
Index: indigo-src/indigo/api/c/indigo/src/indigo_molecule.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_molecule.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_molecule.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_molecule.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_molecule.cpp	(date 1714440647078)
@@ -471,7 +471,7 @@
     return new IndigoBond(_mol, _idx);
 }
 
-CEXPORT int indigoLoadMolecule(int source)
+int indigoLoadMolecule(int source)
 {
     INDIGO_BEGIN
     {
@@ -502,7 +502,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadQueryMolecule(int source)
+int indigoLoadQueryMolecule(int source)
 {
     INDIGO_BEGIN
     {
@@ -576,7 +576,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadSmarts(int source)
+int indigoLoadSmarts(int source)
 {
     INDIGO_BEGIN
     {
@@ -602,7 +602,7 @@
     return isIn(string, ">>") || startWith(string, "$RXN") || isIn(string, "<reactantList>");
 }
 
-CEXPORT int indigoLoadStructureFromString(const char* string, const char* params)
+int indigoLoadStructureFromString(const char* string, const char* params)
 {
     INDIGO_BEGIN
     {
@@ -655,7 +655,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadStructureFromBuffer(const byte* buff, int bufferSize, const char* params)
+int indigoLoadStructureFromBuffer(const byte* buff, int bufferSize, const char* params)
 {
     BufferScanner scanner(buff, bufferSize);
     Array<char> arr;
@@ -664,7 +664,7 @@
     return indigoLoadStructureFromString(arr.ptr(), params);
 }
 
-CEXPORT int indigoLoadStructureFromFile(const char* filename, const char* params)
+int indigoLoadStructureFromFile(const char* filename, const char* params)
 {
     INDIGO_BEGIN
     {
@@ -792,7 +792,7 @@
     return self.addObject(new IndigoAtomsIter(&self.getObject(molecule).getBaseMolecule(), type));
 }
 
-CEXPORT int indigoIterateAtoms(int molecule)
+int indigoIterateAtoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -839,7 +839,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateBonds(int molecule)
+int indigoIterateBonds(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -886,7 +886,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountAtoms(int molecule)
+int indigoCountAtoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -920,7 +920,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountBonds(int molecule)
+int indigoCountBonds(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -954,7 +954,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountPseudoatoms(int molecule)
+int indigoCountPseudoatoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -970,7 +970,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountRSites(int molecule)
+int indigoCountRSites(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -986,7 +986,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIteratePseudoatoms(int molecule)
+int indigoIteratePseudoatoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -995,7 +995,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateRSites(int molecule)
+int indigoIterateRSites(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1004,7 +1004,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateStereocenters(int molecule)
+int indigoIterateStereocenters(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1013,7 +1013,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateAlleneCenters(int molecule)
+int indigoIterateAlleneCenters(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1022,7 +1022,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoSymbol(int atom)
+const char* indigoSymbol(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1035,7 +1035,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoIsPseudoatom(int atom)
+int indigoIsPseudoatom(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1048,7 +1048,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIsRSite(int atom)
+int indigoIsRSite(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1061,7 +1061,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIsTemplateAtom(int atom)
+int indigoIsTemplateAtom(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1074,7 +1074,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSingleAllowedRGroup(int rsite)
+int indigoSingleAllowedRGroup(int rsite)
 {
     INDIGO_BEGIN
     {
@@ -1115,7 +1115,7 @@
 {
 }
 
-CEXPORT int indigoIterateRGroups(int molecule)
+int indigoIterateRGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1230,7 +1230,7 @@
     return new IndigoRGroupFragment(_mol, _rgroup_idx, _frag_idx);
 }
 
-CEXPORT int indigoIterateRGroupFragments(int rgroup)
+int indigoIterateRGroupFragments(int rgroup)
 {
     INDIGO_BEGIN
     {
@@ -1240,7 +1240,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountRGroups(int molecule)
+int indigoCountRGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1292,7 +1292,7 @@
     return rgroup.release();
 }
 
-CEXPORT int indigoCountAttachmentPoints(int rgroup)
+int indigoCountAttachmentPoints(int rgroup)
 {
     INDIGO_BEGIN
     {
@@ -1307,7 +1307,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDegree(int atom)
+int indigoDegree(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1318,7 +1318,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetCharge(int atom, int* charge)
+int indigoGetCharge(int atom, int* charge)
 {
     INDIGO_BEGIN
     {
@@ -1335,7 +1335,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoValence(int atom)
+int indigoValence(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1345,7 +1345,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetHybridization(int atom)
+int indigoGetHybridization(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1356,7 +1356,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCheckValence(int atom)
+int indigoCheckValence(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1372,7 +1372,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetExplicitValence(int atom, int* valence)
+int indigoGetExplicitValence(int atom, int* valence)
 {
     INDIGO_BEGIN
     {
@@ -1389,7 +1389,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetExplicitValence(int atom, int valence)
+int indigoSetExplicitValence(int atom, int valence)
 {
     INDIGO_BEGIN
     {
@@ -1400,7 +1400,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIsotope(int atom)
+int indigoIsotope(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1411,7 +1411,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAtomicNumber(int atom)
+int indigoAtomicNumber(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1428,7 +1428,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetRadicalElectrons(int atom, int* electrons)
+int indigoGetRadicalElectrons(int atom, int* electrons)
 {
     INDIGO_BEGIN
     {
@@ -1480,7 +1480,7 @@
     }
 }
 
-CEXPORT int indigoGetRadical(int atom, int* radical)
+int indigoGetRadical(int atom, int* radical)
 {
     INDIGO_BEGIN
     {
@@ -1498,7 +1498,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetRadical(int atom, int radical)
+int indigoSetRadical(int atom, int radical)
 {
     INDIGO_BEGIN
     {
@@ -1509,7 +1509,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT float* indigoXYZ(int atom)
+float* indigoXYZ(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1526,7 +1526,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoSetXYZ(int atom, float x, float y, float z)
+int indigoSetXYZ(int atom, float x, float y, float z)
 {
     INDIGO_BEGIN
     {
@@ -1540,7 +1540,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoResetCharge(int atom)
+int indigoResetCharge(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1556,7 +1556,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetExplicitValence(int atom)
+int indigoResetExplicitValence(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1572,7 +1572,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetRadical(int atom)
+int indigoResetRadical(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1588,7 +1588,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetIsotope(int atom)
+int indigoResetIsotope(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1604,7 +1604,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetRsite(int atom)
+int indigoResetRsite(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1617,7 +1617,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetAttachmentPoint(int atom, int order)
+int indigoSetAttachmentPoint(int atom, int order)
 {
     INDIGO_BEGIN
     {
@@ -1629,7 +1629,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearAttachmentPoints(int item)
+int indigoClearAttachmentPoints(int item)
 {
     INDIGO_BEGIN
     {
@@ -1640,7 +1640,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRemoveConstraints(int item, const char* str_type)
+int indigoRemoveConstraints(int item, const char* str_type)
 {
     INDIGO_BEGIN
     {
@@ -1664,7 +1664,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddConstraint(int atom, const char* type, const char* value)
+int indigoAddConstraint(int atom, const char* type, const char* value)
 {
     INDIGO_BEGIN
     {
@@ -1683,7 +1683,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddConstraintNot(int atom, const char* type, const char* value)
+int indigoAddConstraintNot(int atom, const char* type, const char* value)
 {
     INDIGO_BEGIN
     {
@@ -1702,7 +1702,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddConstraintOr(int atom, const char* type, const char* value)
+int indigoAddConstraintOr(int atom, const char* type, const char* value)
 {
     INDIGO_BEGIN
     {
@@ -1722,7 +1722,7 @@
 }
 
 /*
-CEXPORT int indigoAddConstraintOrNot(int atom, const char* type, const char* value)
+int indigoAddConstraintOrNot(int atom, const char* type, const char* value)
 {
    INDIGO_BEGIN
    {
@@ -1742,7 +1742,7 @@
 }
  * */
 
-CEXPORT const int* indigoSymmetryClasses(int molecule, int* count_out)
+const int* indigoSymmetryClasses(int molecule, int* count_out)
 {
     INDIGO_BEGIN
     {
@@ -1780,7 +1780,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoLayeredCode(int molecule)
+const char* indigoLayeredCode(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1798,7 +1798,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoCreateSubmolecule(int molecule, int nvertices, int* vertices)
+int indigoCreateSubmolecule(int molecule, int nvertices, int* vertices)
 {
     INDIGO_BEGIN
     {
@@ -1826,7 +1826,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSubmolecule(int molecule, int nvertices, int* vertices)
+int indigoGetSubmolecule(int molecule, int nvertices, int* vertices)
 {
     INDIGO_BEGIN
     {
@@ -1855,7 +1855,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateEdgeSubmolecule(int molecule, int nvertices, int* vertices, int nedges, int* edges)
+int indigoCreateEdgeSubmolecule(int molecule, int nvertices, int* vertices, int nedges, int* edges)
 {
     INDIGO_BEGIN
     {
@@ -1885,7 +1885,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRemoveAtoms(int molecule, int nvertices, int* vertices)
+int indigoRemoveAtoms(int molecule, int nvertices, int* vertices)
 {
     INDIGO_BEGIN
     {
@@ -1900,7 +1900,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRemoveBonds(int molecule, int nbonds, int* bonds)
+int indigoRemoveBonds(int molecule, int nbonds, int* bonds)
 {
     INDIGO_BEGIN
     {
@@ -1948,7 +1948,7 @@
     return _nei_counters;
 }
 
-CEXPORT int indigoIsChiral(int molecule)
+int indigoIsChiral(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1958,7 +1958,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoBondOrder(int bond)
+int indigoBondOrder(int bond)
 {
     INDIGO_BEGIN
     {
@@ -1970,7 +1970,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoTopology(int bond)
+int indigoTopology(int bond)
 {
     INDIGO_BEGIN
     {
@@ -1986,7 +1986,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetAtom(int molecule, int idx)
+int indigoGetAtom(int molecule, int idx)
 {
     INDIGO_BEGIN
     {
@@ -1997,7 +1997,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetBond(int molecule, int idx)
+int indigoGetBond(int molecule, int idx)
 {
     INDIGO_BEGIN
     {
@@ -2008,7 +2008,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSource(int bond)
+int indigoSource(int bond)
 {
     INDIGO_BEGIN
     {
@@ -2018,7 +2018,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDestination(int bond)
+int indigoDestination(int bond)
 {
     INDIGO_BEGIN
     {
@@ -2077,7 +2077,7 @@
     return vertex.neiNext(_nei_idx) != vertex.neiEnd();
 }
 
-CEXPORT int indigoIterateNeighbors(int atom)
+int indigoIterateNeighbors(int atom)
 {
     INDIGO_BEGIN
     {
@@ -2088,7 +2088,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoBond(int nei)
+int indigoBond(int nei)
 {
     INDIGO_BEGIN
     {
@@ -2104,7 +2104,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT float indigoAlignAtoms(int molecule, int natoms, int* atom_ids, float* desired_xyz)
+float indigoAlignAtoms(int molecule, int natoms, int* atom_ids, float* desired_xyz)
 {
     INDIGO_BEGIN
     {
@@ -2155,7 +2155,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountSuperatoms(int molecule)
+int indigoCountSuperatoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2165,7 +2165,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountDataSGroups(int molecule)
+int indigoCountDataSGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2175,7 +2175,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountRepeatingUnits(int molecule)
+int indigoCountRepeatingUnits(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2185,7 +2185,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountMultipleGroups(int molecule)
+int indigoCountMultipleGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2195,7 +2195,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountGenericSGroups(int molecule)
+int indigoCountGenericSGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2236,7 +2236,7 @@
     return sgroup.release();
 }
 
-CEXPORT int indigoIterateDataSGroups(int molecule)
+int indigoIterateDataSGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2537,7 +2537,7 @@
     return sgroup.release();
 }
 
-CEXPORT int indigoIterateGenericSGroups(int molecule)
+int indigoIterateGenericSGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2623,7 +2623,7 @@
     return sgroup.release();
 }
 
-CEXPORT int indigoIterateSGroups(int molecule)
+int indigoIterateSGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2711,7 +2711,7 @@
     return tgroup.release();
 }
 
-CEXPORT int indigoIterateTGroups(int molecule)
+int indigoIterateTGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2721,7 +2721,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateRepeatingUnits(int molecule)
+int indigoIterateRepeatingUnits(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2734,7 +2734,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateMultipleGroups(int molecule)
+int indigoIterateMultipleGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2747,7 +2747,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateSuperatoms(int molecule)
+int indigoIterateSuperatoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2760,7 +2760,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSuperatom(int molecule, int index)
+int indigoGetSuperatom(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -2777,7 +2777,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetDataSGroup(int molecule, int index)
+int indigoGetDataSGroup(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -2794,7 +2794,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetGenericSGroup(int molecule, int index)
+int indigoGetGenericSGroup(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -2811,7 +2811,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetMultipleGroup(int molecule, int index)
+int indigoGetMultipleGroup(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -2828,7 +2828,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetRepeatingUnit(int molecule, int index)
+int indigoGetRepeatingUnit(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -2845,7 +2845,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoDescription(int data_sgroup)
+const char* indigoDescription(int data_sgroup)
 {
     INDIGO_BEGIN
     {
@@ -2857,7 +2857,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoData(int data_sgroup)
+const char* indigoData(int data_sgroup)
 {
     INDIGO_BEGIN
     {
@@ -2869,7 +2869,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoAddDataSGroup(int molecule, int natoms, int* atoms, int nbonds, int* bonds, const char* name, const char* data)
+int indigoAddDataSGroup(int molecule, int natoms, int* atoms, int nbonds, int* bonds, const char* name, const char* data)
 {
     INDIGO_BEGIN
     {
@@ -2893,7 +2893,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddSuperatom(int molecule, int natoms, int* atoms, const char* name)
+int indigoAddSuperatom(int molecule, int natoms, int* atoms, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -2912,7 +2912,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetDataSGroupXY(int sgroup, float x, float y, const char* options)
+int indigoSetDataSGroupXY(int sgroup, float x, float y, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -2937,7 +2937,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupData(int sgroup, const char* data)
+int indigoSetSGroupData(int sgroup, const char* data)
 {
     INDIGO_BEGIN
     {
@@ -2951,7 +2951,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupCoords(int sgroup, float x, float y)
+int indigoSetSGroupCoords(int sgroup, float x, float y)
 {
     INDIGO_BEGIN
     {
@@ -2965,7 +2965,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupDescription(int sgroup, const char* description)
+int indigoSetSGroupDescription(int sgroup, const char* description)
 {
     INDIGO_BEGIN
     {
@@ -2979,7 +2979,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupFieldName(int sgroup, const char* name)
+int indigoSetSGroupFieldName(int sgroup, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -2993,7 +2993,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupQueryCode(int sgroup, const char* querycode)
+int indigoSetSGroupQueryCode(int sgroup, const char* querycode)
 {
     INDIGO_BEGIN
     {
@@ -3007,7 +3007,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupQueryOper(int sgroup, const char* queryoper)
+int indigoSetSGroupQueryOper(int sgroup, const char* queryoper)
 {
     INDIGO_BEGIN
     {
@@ -3021,7 +3021,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupDisplay(int sgroup, const char* option)
+int indigoSetSGroupDisplay(int sgroup, const char* option)
 {
     INDIGO_BEGIN
     {
@@ -3042,7 +3042,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupLocation(int sgroup, const char* option)
+int indigoSetSGroupLocation(int sgroup, const char* option)
 {
     INDIGO_BEGIN
     {
@@ -3063,7 +3063,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupTag(int sgroup, const char* tag)
+int indigoSetSGroupTag(int sgroup, const char* tag)
 {
     INDIGO_BEGIN
     {
@@ -3079,7 +3079,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupTagAlign(int sgroup, int tag_align)
+int indigoSetSGroupTagAlign(int sgroup, int tag_align)
 {
     INDIGO_BEGIN
     {
@@ -3095,7 +3095,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupDataType(int sgroup, const char* data_type)
+int indigoSetSGroupDataType(int sgroup, const char* data_type)
 {
     INDIGO_BEGIN
     {
@@ -3111,7 +3111,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupXCoord(int sgroup, float x)
+int indigoSetSGroupXCoord(int sgroup, float x)
 {
     INDIGO_BEGIN
     {
@@ -3124,7 +3124,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupYCoord(int sgroup, float y)
+int indigoSetSGroupYCoord(int sgroup, float y)
 {
     INDIGO_BEGIN
     {
@@ -3137,7 +3137,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateSGroup(const char* type, int mapping, const char* name)
+int indigoCreateSGroup(const char* type, int mapping, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -3194,7 +3194,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupClass(int sgroup, const char* sgclass)
+int indigoSetSGroupClass(int sgroup, const char* sgclass)
 {
     INDIGO_BEGIN
     {
@@ -3206,7 +3206,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetSGroupClass(int sgroup)
+const char* indigoGetSGroupClass(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3218,7 +3218,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoSetSGroupName(int sgroup, const char* sgname)
+int indigoSetSGroupName(int sgroup, const char* sgname)
 {
     INDIGO_BEGIN
     {
@@ -3230,7 +3230,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetSGroupName(int sgroup)
+const char* indigoGetSGroupName(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3242,7 +3242,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoGetSGroupNumCrossBonds(int sgroup)
+int indigoGetSGroupNumCrossBonds(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3252,7 +3252,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddSGroupAttachmentPoint(int sgroup, int aidx, int lvidx, const char* apid)
+int indigoAddSGroupAttachmentPoint(int sgroup, int aidx, int lvidx, const char* apid)
 {
     INDIGO_BEGIN
     {
@@ -3267,7 +3267,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDeleteSGroupAttachmentPoint(int sgroup, int ap_idx)
+int indigoDeleteSGroupAttachmentPoint(int sgroup, int ap_idx)
 {
     INDIGO_BEGIN
     {
@@ -3278,7 +3278,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSGroupDisplayOption(int sgroup)
+int indigoGetSGroupDisplayOption(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3291,7 +3291,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupDisplayOption(int sgroup, int option)
+int indigoSetSGroupDisplayOption(int sgroup, int option)
 {
     INDIGO_BEGIN
     {
@@ -3303,7 +3303,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSGroupSeqId(int sgroup)
+int indigoGetSGroupSeqId(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3315,7 +3315,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT float* indigoGetSGroupCoords(int sgroup)
+float* indigoGetSGroupCoords(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3331,7 +3331,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoGetSGroupMultiplier(int sgroup)
+int indigoGetSGroupMultiplier(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3341,7 +3341,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetRepeatingUnitSubscript(int sgroup)
+const char* indigoGetRepeatingUnitSubscript(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3351,7 +3351,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoGetRepeatingUnitConnectivity(int sgroup)
+int indigoGetRepeatingUnitConnectivity(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3361,7 +3361,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupMultiplier(int sgroup, int multiplier)
+int indigoSetSGroupMultiplier(int sgroup, int multiplier)
 {
     INDIGO_BEGIN
     {
@@ -3373,7 +3373,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupBrackets(int sgroup, int brk_style, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4)
+int indigoSetSGroupBrackets(int sgroup, int brk_style, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4)
 {
     INDIGO_BEGIN
     {
@@ -3402,7 +3402,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoFindSGroups(int item, const char* property, const char* value)
+int indigoFindSGroups(int item, const char* property, const char* value)
 {
     INDIGO_BEGIN
     {
@@ -3417,7 +3417,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSGroupType(int sgroup)
+int indigoGetSGroupType(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3427,7 +3427,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSGroupIndex(int sgroup)
+int indigoGetSGroupIndex(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3437,7 +3437,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSGroupOriginalId(int sgroup)
+int indigoGetSGroupOriginalId(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3447,7 +3447,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupOriginalId(int sgroup, int new_original)
+int indigoSetSGroupOriginalId(int sgroup, int new_original)
 {
     INDIGO_BEGIN
     {
@@ -3477,7 +3477,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSGroupParentId(int sgroup)
+int indigoGetSGroupParentId(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3487,7 +3487,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupParentId(int sgroup, int parent)
+int indigoSetSGroupParentId(int sgroup, int parent)
 {
     INDIGO_BEGIN
     {
@@ -3510,7 +3510,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddTemplate(int molecule, int templates, const char* tname)
+int indigoAddTemplate(int molecule, int templates, const char* tname)
 {
     INDIGO_BEGIN
     {
@@ -3528,7 +3528,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRemoveTemplate(int molecule, const char* tname)
+int indigoRemoveTemplate(int molecule, const char* tname)
 {
     INDIGO_BEGIN
     {
@@ -3543,7 +3543,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoFindTemplate(int molecule, const char* tname)
+int indigoFindTemplate(int molecule, const char* tname)
 {
     INDIGO_BEGIN
     {
@@ -3558,7 +3558,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetTGroupClass(int tgroup)
+const char* indigoGetTGroupClass(int tgroup)
 {
     INDIGO_BEGIN
     {
@@ -3570,7 +3570,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoGetTGroupName(int tgroup)
+const char* indigoGetTGroupName(int tgroup)
 {
     INDIGO_BEGIN
     {
@@ -3582,7 +3582,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoGetTGroupAlias(int tgroup)
+const char* indigoGetTGroupAlias(int tgroup)
 {
     INDIGO_BEGIN
     {
@@ -3594,7 +3594,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoTransformSCSRtoCTAB(int molecule)
+int indigoTransformSCSRtoCTAB(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -3607,7 +3607,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoTransformCTABtoSCSR(int molecule, int templates)
+int indigoTransformCTABtoSCSR(int molecule, int templates)
 {
     INDIGO_BEGIN
     {
@@ -3629,7 +3629,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountHeavyAtoms(int molecule)
+int indigoCountHeavyAtoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -3645,7 +3645,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountComponents(int molecule)
+int indigoCountComponents(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -3656,7 +3656,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCloneComponent(int molecule, int index)
+int indigoCloneComponent(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -3672,7 +3672,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoComponentIndex(int atom)
+int indigoComponentIndex(int atom)
 {
     INDIGO_BEGIN
     {
@@ -3683,7 +3683,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoComponent(int molecule, int index)
+int indigoComponent(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -3790,7 +3790,7 @@
     return idx;
 }
 
-CEXPORT int indigoIterateComponents(int molecule)
+int indigoIterateComponents(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -3801,7 +3801,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateComponentAtoms(int molecule, int index)
+int indigoIterateComponentAtoms(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -3812,7 +3812,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateComponentBonds(int molecule, int index)
+int indigoIterateComponentBonds(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -3823,7 +3823,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountComponentAtoms(int molecule, int index)
+int indigoCountComponentAtoms(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -3834,7 +3834,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountComponentBonds(int molecule, int index)
+int indigoCountComponentBonds(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -3845,7 +3845,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateMolecule()
+int indigoCreateMolecule()
 {
     INDIGO_BEGIN
     {
@@ -3855,7 +3855,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateQueryMolecule()
+int indigoCreateQueryMolecule()
 {
     INDIGO_BEGIN
     {
@@ -3864,7 +3864,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoMerge(int where, int what)
+int indigoMerge(int where, int what)
 {
     INDIGO_BEGIN
     {
@@ -3880,7 +3880,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddAtom(int molecule, const char* symbol)
+int indigoAddAtom(int molecule, const char* symbol)
 {
     INDIGO_BEGIN
     {
@@ -3912,7 +3912,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetAtom(int atom, const char* symbol)
+int indigoResetAtom(int atom, const char* symbol)
 {
     INDIGO_BEGIN
     {
@@ -3950,7 +3950,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetTemplateAtomClass(int atom)
+const char* indigoGetTemplateAtomClass(int atom)
 {
     INDIGO_BEGIN
     {
@@ -3971,7 +3971,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoSetTemplateAtomClass(int atom, const char* name)
+int indigoSetTemplateAtomClass(int atom, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -4027,7 +4027,7 @@
         mol.allowRGroupOnRSite(atom_index, rsites[i]);
 }
 
-CEXPORT int indigoAddRSite(int molecule, const char* name)
+int indigoAddRSite(int molecule, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -4050,7 +4050,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetRSite(int atom, const char* name)
+int indigoSetRSite(int atom, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -4064,7 +4064,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetCharge(int atom, int charge)
+int indigoSetCharge(int atom, int charge)
 {
     INDIGO_BEGIN
     {
@@ -4076,7 +4076,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetIsotope(int atom, int isotope)
+int indigoSetIsotope(int atom, int isotope)
 {
     INDIGO_BEGIN
     {
@@ -4088,7 +4088,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetImplicitHCount(int atom, int impl_h)
+int indigoSetImplicitHCount(int atom, int impl_h)
 {
     INDIGO_BEGIN
     {
@@ -4100,7 +4100,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddBond(int source, int destination, int order)
+int indigoAddBond(int source, int destination, int order)
 {
     INDIGO_BEGIN
     {
@@ -4121,7 +4121,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetBondOrder(int bond, int order)
+int indigoSetBondOrder(int bond, int order)
 {
     INDIGO_BEGIN
     {
@@ -4260,7 +4260,7 @@
     return new IndigoBond(_submol.getOriginalMolecule(), _submol.edges[_idx]);
 }
 
-CEXPORT int indigoCountSSSR(int molecule)
+int indigoCountSSSR(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -4271,7 +4271,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateSSSR(int molecule)
+int indigoIterateSSSR(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -4350,7 +4350,7 @@
     return res.release();
 }
 
-CEXPORT int indigoIterateSubtrees(int molecule, int min_atoms, int max_atoms)
+int indigoIterateSubtrees(int molecule, int min_atoms, int max_atoms)
 {
     INDIGO_BEGIN
     {
@@ -4400,7 +4400,7 @@
     return res.release();
 }
 
-CEXPORT int indigoIterateRings(int molecule, int min_atoms, int max_atoms)
+int indigoIterateRings(int molecule, int min_atoms, int max_atoms)
 {
     INDIGO_BEGIN
     {
@@ -4453,7 +4453,7 @@
     return res.release();
 }
 
-CEXPORT int indigoIterateEdgeSubmolecules(int molecule, int min_bonds, int max_bonds)
+int indigoIterateEdgeSubmolecules(int molecule, int min_bonds, int max_bonds)
 {
     INDIGO_BEGIN
     {
@@ -4464,7 +4464,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountHydrogens(int item, int* hydro)
+int indigoCountHydrogens(int item, int* hydro)
 {
     INDIGO_BEGIN
     {
@@ -4502,7 +4502,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountImplicitHydrogens(int item)
+int indigoCountImplicitHydrogens(int item)
 {
     INDIGO_BEGIN
     {
@@ -4555,7 +4555,7 @@
     return _mol.getAttachmentPoint(_order, _index + 1) != -1;
 }
 
-CEXPORT int indigoIterateAttachmentPoints(int molecule, int order)
+int indigoIterateAttachmentPoints(int molecule, int order)
 {
     INDIGO_BEGIN
     {
@@ -4573,7 +4573,7 @@
 name - a name to parse
 params - a string containing parsing options or nullptr if no options are changed
 */
-CEXPORT int indigoNameToStructure(const char* name, const char* params)
+int indigoNameToStructure(const char* name, const char* params)
 {
     INDIGO_BEGIN
     {
@@ -4607,7 +4607,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCheckRGroups(int item)
+int indigoCheckRGroups(int item)
 {
     INDIGO_BEGIN
     {
Index: cppcoro-src/cppcoro/lib/io_service.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/io_service.cpp b/cppcoro-src/cppcoro/lib/io_service.cpp
--- a/cppcoro-src/cppcoro/lib/io_service.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/io_service.cpp	(date 1714440647078)
@@ -18,10 +18,10 @@
 # ifndef NOMINMAX
 #  define NOMINMAX
 # endif
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 #endif
 
 namespace
@@ -642,7 +642,7 @@
 			{
 				// This was a coroutine scheduled via a call to
 				// io_service::schedule().
-				std::experimental::coroutine_handle<>::from_address(
+				std::coroutine_handle<>::from_address(
 					reinterpret_cast<void*>(completionKey)).resume();
 				return true;
 			}
@@ -911,7 +911,7 @@
 }
 
 void cppcoro::io_service::schedule_operation::await_suspend(
-	std::experimental::coroutine_handle<> awaiter) noexcept
+	std::coroutine_handle<> awaiter) noexcept
 {
 	m_awaiter = awaiter;
 	m_service.schedule_impl(this);
@@ -947,7 +947,7 @@
 }
 
 void cppcoro::io_service::timed_schedule_operation::await_suspend(
-	std::experimental::coroutine_handle<> awaiter)
+	std::coroutine_handle<> awaiter)
 {
 	m_scheduleOperation.m_awaiter = awaiter;
 
Index: indigo-src/indigo/api/c/indigo/src/indigo_array.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_array.h b/indigo-src/indigo/api/c/indigo/src/indigo_array.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_array.h	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_array.h	(date 1714440647078)
@@ -26,7 +26,7 @@
 #pragma warning(disable : 4251)
 #endif
 
-class DLLEXPORT IndigoArray : public IndigoObject
+class INDIGO_EXPORT IndigoArray : public IndigoObject
 {
 public:
     IndigoArray();
@@ -41,7 +41,7 @@
     PtrArray<IndigoObject> objects;
 };
 
-class DLLEXPORT IndigoArrayElement : public IndigoObject
+class INDIGO_EXPORT IndigoArrayElement : public IndigoObject
 {
 public:
     IndigoArrayElement(IndigoArray& arr, int idx_);
Index: arrow-src/arrow/cpp/src/arrow/vendored/datetime/tz.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/arrow-src/arrow/cpp/src/arrow/vendored/datetime/tz.h b/arrow-src/arrow/cpp/src/arrow/vendored/datetime/tz.h
--- a/arrow-src/arrow/cpp/src/arrow/vendored/datetime/tz.h	(revision 6a28035c2b49b432dc63f5ee7524d76b4ed2d762)
+++ b/arrow-src/arrow/cpp/src/arrow/vendored/datetime/tz.h	(date 1714440647078)
@@ -104,6 +104,10 @@
 
 #include "date.h"
 
+#include <arrow_export.h>
+
+#define DATE_API ARROW_EXPORT
+
 #if defined(_MSC_VER) && (_MSC_VER < 1900)
 #include "tz_private.h"
 #endif
@@ -124,22 +128,6 @@
 #include <utility>
 #include <vector>
 
-#ifdef _WIN32
-#  ifdef DATE_BUILD_DLL
-#    define DATE_API __declspec(dllexport)
-#  elif defined(DATE_USE_DLL)
-#    define DATE_API __declspec(dllimport)
-#  else
-#    define DATE_API
-#  endif
-#else
-#  ifdef DATE_BUILD_DLL
-#    define DATE_API __attribute__ ((visibility ("default")))
-#  else
-#    define DATE_API
-#  endif
-#endif
-
 namespace arrow_vendored
 {
 namespace date
Index: indigo-src/indigo/api/c/indigo/src/indigo_molecule.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_molecule.h b/indigo-src/indigo/api/c/indigo/src/indigo_molecule.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_molecule.h	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_molecule.h	(date 1714440647078)
@@ -33,7 +33,7 @@
 #include "molecule/molecule_neighbourhood_counters.h"
 #include "molecule/query_molecule.h"
 
-class DLLEXPORT IndigoBaseMolecule : public IndigoObject
+class INDIGO_EXPORT IndigoBaseMolecule : public IndigoObject
 {
 public:
     explicit IndigoBaseMolecule(int type_);
@@ -52,7 +52,7 @@
     indigo::PropertiesMap _properties;
 };
 
-class DLLEXPORT IndigoQueryMolecule : public IndigoBaseMolecule
+class INDIGO_EXPORT IndigoQueryMolecule : public IndigoBaseMolecule
 {
 public:
     IndigoQueryMolecule();
@@ -80,7 +80,7 @@
     int _nei_counters_edit_revision;
 };
 
-class DLLEXPORT IndigoMolecule : public IndigoBaseMolecule
+class INDIGO_EXPORT IndigoMolecule : public IndigoBaseMolecule
 {
 public:
     IndigoMolecule();
@@ -102,7 +102,7 @@
     Molecule mol;
 };
 
-class DLLEXPORT IndigoAtom : public IndigoObject
+class INDIGO_EXPORT IndigoAtom : public IndigoObject
 {
 public:
     IndigoAtom(BaseMolecule& mol_, int idx_);
@@ -122,7 +122,7 @@
     const char* debugInfo() const override;
 };
 
-class DLLEXPORT IndigoRGroup : public IndigoObject
+class INDIGO_EXPORT IndigoRGroup : public IndigoObject
 {
 public:
     IndigoRGroup();
@@ -136,7 +136,7 @@
     int idx;
 };
 
-class DLLEXPORT IndigoRGroupFragment : public IndigoObject
+class INDIGO_EXPORT IndigoRGroupFragment : public IndigoObject
 {
 public:
     IndigoRGroupFragment(IndigoRGroup& rgp, int idx);
@@ -156,7 +156,7 @@
     int frag_idx;
 };
 
-class DLLEXPORT IndigoBond : public IndigoObject
+class INDIGO_EXPORT IndigoBond : public IndigoObject
 {
 public:
     IndigoBond(BaseMolecule& mol_, int idx_);
Index: indigo-src/indigo/api/c/indigo/src/indigo_scaffold.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_scaffold.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_scaffold.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_scaffold.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_scaffold.cpp	(date 1714440647078)
@@ -31,7 +31,7 @@
 {
 }
 
-CEXPORT int indigoExtractCommonScaffold(int structures, const char* options)
+int indigoExtractCommonScaffold(int structures, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -104,7 +104,7 @@
     return max_scaffold;
 }
 
-CEXPORT int indigoAllScaffolds(int extracted)
+int indigoAllScaffolds(int extracted)
 {
     INDIGO_BEGIN
     {
Index: cppcoro-src/cppcoro/lib/lightweight_manual_reset_event.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/lightweight_manual_reset_event.cpp b/cppcoro-src/cppcoro/lib/lightweight_manual_reset_event.cpp
--- a/cppcoro-src/cppcoro/lib/lightweight_manual_reset_event.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/lightweight_manual_reset_event.cpp	(date 1714440647078)
@@ -11,7 +11,7 @@
 # ifndef WIN32_LEAN_AND_MEAN
 #  define WIN32_LEAN_AND_MEAN
 # endif
-# include <Windows.h>
+# include <windows.h>
 
 # if CPPCORO_OS_WINNT >= 0x0602
 
Index: indigo-src/indigo/api/c/indigo/src/indigo_tautomer_enumerator.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_tautomer_enumerator.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_tautomer_enumerator.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_tautomer_enumerator.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_tautomer_enumerator.cpp	(date 1714440647078)
@@ -19,7 +19,7 @@
 #include "indigo_tautomer_enumerator.h"
 #include "indigo_molecule.h"
 
-CEXPORT int indigoIterateTautomers(int molecule, const char* options)
+int indigoIterateTautomers(int molecule, const char* options)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_io.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_io.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_io.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_io.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_io.cpp	(date 1714440647082)
@@ -86,7 +86,7 @@
     throw IndigoError("%s is not an output", obj.debugInfo());
 }
 
-CEXPORT int indigoReadFile(const char* filename)
+int indigoReadFile(const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -95,7 +95,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoReadString(const char* str)
+int indigoReadString(const char* str)
 {
     INDIGO_BEGIN
     {
@@ -104,7 +104,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoReadBuffer(const char* buffer, int size)
+int indigoReadBuffer(const char* buffer, int size)
 {
     INDIGO_BEGIN
     {
@@ -113,7 +113,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadString(const char* str)
+int indigoLoadString(const char* str)
 {
     INDIGO_BEGIN
     {
@@ -122,7 +122,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadBuffer(const char* buffer, int size)
+int indigoLoadBuffer(const char* buffer, int size)
 {
     INDIGO_BEGIN
     {
@@ -131,7 +131,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoWriteFile(const char* filename)
+int indigoWriteFile(const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -140,7 +140,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClose(int output)
+int indigoClose(int output)
 {
     INDIGO_BEGIN
     {
@@ -163,7 +163,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoWriteBuffer(void)
+int indigoWriteBuffer(void)
 {
     INDIGO_BEGIN
     {
@@ -172,7 +172,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoToString(int handle)
+const char* indigoToString(int handle)
 {
     INDIGO_BEGIN
     {
@@ -187,7 +187,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoToBase64String(int handle)
+const char* indigoToBase64String(int handle)
 {
     INDIGO_BEGIN
     {
@@ -200,7 +200,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoToBuffer(int handle, char** buf, int* size)
+int indigoToBuffer(int handle, char** buf, int* size)
 {
     INDIGO_BEGIN
     {
Index: cppcoro-src/cppcoro/lib/socket_recv_from_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_recv_from_operation.cpp b/cppcoro-src/cppcoro/lib/socket_recv_from_operation.cpp
--- a/cppcoro-src/cppcoro/lib/socket_recv_from_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_recv_from_operation.cpp	(date 1714440647082)
@@ -9,10 +9,10 @@
 #if CPPCORO_OS_WINNT
 # include "socket_helpers.hpp"
 
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 
 bool cppcoro::net::socket_recv_from_operation_impl::try_start(
 	cppcoro::detail::win32_overlapped_operation_base& operation) noexcept
Index: indigo-src/indigo/api/c/indigo/src/indigo_calc.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_calc.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_calc.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_calc.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_calc.cpp	(date 1714440647082)
@@ -37,7 +37,7 @@
     ReactionGrossFormula::toString_Hill(*gross, str, self.gross_formula_options.add_rsites);
 }
 
-CEXPORT int indigoGrossFormula(int object)
+int indigoGrossFormula(int object)
 {
     INDIGO_BEGIN
     {
@@ -81,7 +81,7 @@
     }
 }
 
-CEXPORT double indigoMolecularWeight(int molecule)
+double indigoMolecularWeight(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -93,7 +93,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT double indigoMostAbundantMass(int molecule)
+double indigoMostAbundantMass(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -105,7 +105,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT double indigoMonoisotopicMass(int molecule)
+double indigoMonoisotopicMass(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -117,7 +117,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoMassComposition(int molecule)
+const char* indigoMassComposition(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -133,7 +133,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT double indigoTPSA(const int molecule, const int includeSP)
+double indigoTPSA(const int molecule, const int includeSP)
 {
     INDIGO_BEGIN
     {
@@ -148,7 +148,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoNumRotatableBonds(const int molecule)
+int indigoNumRotatableBonds(const int molecule)
 {
     INDIGO_BEGIN
     {
@@ -163,7 +163,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoNumHydrogenBondAcceptors(const int molecule)
+int indigoNumHydrogenBondAcceptors(const int molecule)
 {
     INDIGO_BEGIN
     {
@@ -178,7 +178,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoNumHydrogenBondDonors(const int molecule)
+int indigoNumHydrogenBondDonors(const int molecule)
 {
     INDIGO_BEGIN
     {
@@ -193,7 +193,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT double indigoLogP(const int molecule)
+double indigoLogP(const int molecule)
 {
     INDIGO_BEGIN
     {
@@ -208,7 +208,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT double indigoMolarRefractivity(const int molecule)
+double indigoMolarRefractivity(const int molecule)
 {
     INDIGO_BEGIN
     {
@@ -223,7 +223,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT double indigoPka(const int molecule)
+double indigoPka(const int molecule)
 {
     INDIGO_BEGIN
     {
Index: cppcoro-src/cppcoro/lib/read_only_file.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/read_only_file.cpp b/cppcoro-src/cppcoro/lib/read_only_file.cpp
--- a/cppcoro-src/cppcoro/lib/read_only_file.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/read_only_file.cpp	(date 1714440647082)
@@ -3,17 +3,17 @@
 // Licenced under MIT license. See LICENSE.txt for details.
 ///////////////////////////////////////////////////////////////////////////////
 
-#include <cppcoro\read_only_file.hpp>
+#include <cppcoro/read_only_file.hpp>
 
 #if CPPCORO_OS_WINNT
 # ifndef WIN32_LEAN_AND_MEAN
 #  define WIN32_LEAN_AND_MEAN
 # endif
-# include <Windows.h>
+# include <windows.h>
 
 cppcoro::read_only_file cppcoro::read_only_file::open(
 	io_service& ioService,
-	const std::experimental::filesystem::path& path,
+	const std::filesystem::path& path,
 	file_share_mode shareMode,
 	file_buffering_mode bufferingMode)
 {
Index: indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.cpp	(date 1714440647082)
@@ -1564,7 +1564,7 @@
     return false;
 }
 
-CEXPORT int indigoDecomposeMolecules(int scaffold, int structures)
+int indigoDecomposeMolecules(int scaffold, int structures)
 {
     INDIGO_BEGIN
     {
@@ -1585,7 +1585,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateDecomposedMolecules(int decomp)
+int indigoIterateDecomposedMolecules(int decomp)
 {
     INDIGO_BEGIN
     {
@@ -1601,7 +1601,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDecomposedMoleculeScaffold(int decomp)
+int indigoDecomposedMoleculeScaffold(int decomp)
 {
     INDIGO_BEGIN
     {
@@ -1658,7 +1658,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDecomposedMoleculeHighlighted(int decomp)
+int indigoDecomposedMoleculeHighlighted(int decomp)
 {
     INDIGO_BEGIN
     {
@@ -1694,7 +1694,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDecomposedMoleculeSubstituents(int decomp)
+int indigoDecomposedMoleculeSubstituents(int decomp)
 {
     INDIGO_BEGIN
     {
@@ -1732,7 +1732,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDecomposedMoleculeWithRGroups(int decomp)
+int indigoDecomposedMoleculeWithRGroups(int decomp)
 {
     INDIGO_BEGIN
     {
@@ -1775,7 +1775,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateDecomposer(int scaffold)
+int indigoCreateDecomposer(int scaffold)
 {
     INDIGO_BEGIN
     {
@@ -1792,7 +1792,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDecomposeMolecule(int decomp, int mol)
+int indigoDecomposeMolecule(int decomp, int mol)
 {
     INDIGO_BEGIN
     {
@@ -1813,7 +1813,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateDecompositions(int deco_item)
+int indigoIterateDecompositions(int deco_item)
 {
     INDIGO_BEGIN
     {
@@ -1837,7 +1837,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddDecomposition(int decomp, int q_match)
+int indigoAddDecomposition(int decomp, int q_match)
 {
     INDIGO_BEGIN
     {
Index: cppcoro-src/cppcoro/lib/file.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/file.cpp b/cppcoro-src/cppcoro/lib/file.cpp
--- a/cppcoro-src/cppcoro/lib/file.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/file.cpp	(date 1714440647082)
@@ -13,7 +13,7 @@
 # ifndef WIN32_LEAN_AND_MEAN
 #  define WIN32_LEAN_AND_MEAN
 # endif
-# include <Windows.h>
+# include <windows.h>
 #endif
 
 cppcoro::file::~file()
@@ -47,7 +47,7 @@
 cppcoro::detail::win32::safe_handle cppcoro::file::open(
 	detail::win32::dword_t fileAccess,
 	io_service& ioService,
-	const std::experimental::filesystem::path& path,
+	const std::filesystem::path& path,
 	file_open_mode openMode,
 	file_share_mode shareMode,
 	file_buffering_mode bufferingMode)
Index: indigo-src/indigo/api/c/indigo/src/indigo.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo.cpp b/indigo-src/indigo/api/c/indigo/src/indigo.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo.cpp	(date 1714440647082)
@@ -41,12 +41,12 @@
 
 static _SessionLocalContainer<Indigo> indigo_self;
 
-DLLEXPORT Indigo& indigoGetInstance()
+Indigo& indigoGetInstance()
 {
     return indigo_self.getLocalCopy();
 }
 
-CEXPORT const char* indigoVersion()
+const char* indigoVersion()
 {
     return INDIGO_VERSION "-" INDIGO_PLATFORM;
 }
@@ -297,7 +297,7 @@
     };
 }
 
-CEXPORT qword indigoAllocSessionId()
+qword indigoAllocSessionId()
 {
     qword id = TL_ALLOC_SESSION_ID();
     TL_SET_SESSION_ID(id);
@@ -314,12 +314,12 @@
     return id;
 }
 
-CEXPORT void indigoSetSessionId(qword id)
+void indigoSetSessionId(qword id)
 {
     TL_SET_SESSION_ID(id);
 }
 
-CEXPORT void indigoReleaseSessionId(qword id)
+void indigoReleaseSessionId(qword id)
 {
     TL_SET_SESSION_ID(id);
     indigoGetInstance().removeAllObjects();
@@ -333,17 +333,17 @@
 #endif
 }
 
-CEXPORT const char* indigoGetLastError(void)
+const char* indigoGetLastError(void)
 {
     return Indigo::getErrorMessage().ptr();
 }
 
-CEXPORT void indigoSetErrorHandler(INDIGO_ERROR_HANDLER handler, void* context)
+void indigoSetErrorHandler(INDIGO_ERROR_HANDLER handler, void* context)
 {
     Indigo::setErrorHandler(handler, context);
 }
 
-CEXPORT int indigoFree(int handle)
+int indigoFree(int handle)
 {
     // In some runtimes (e.g. Python) session could be removed before objects during resource releasing stage)
     if (indigo_self.hasLocalCopy())
@@ -360,13 +360,13 @@
     return 1;
 }
 
-CEXPORT int indigoFreeAllObjects()
+int indigoFreeAllObjects()
 {
     indigoGetInstance().removeAllObjects();
     return 1;
 }
 
-CEXPORT int indigoCountReferences(void)
+int indigoCountReferences(void)
 {
     INDIGO_BEGIN
     {
@@ -375,7 +375,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT void indigoSetErrorMessage(const char* message)
+void indigoSetErrorMessage(const char* message)
 {
     Indigo& self = indigoGetInstance();
     self.setErrorMessage(message);
@@ -495,9 +495,9 @@
 // Debug methods
 //
 
-#ifdef _WIN32
+#if defined(_WIN32) && !defined(__MINGW32__)
 #include <Windows.h>
-#elif defined(__linux__)
+#elif defined(__linux__) || defined(__MINGW32__)
 #include <fcntl.h>
 #include <unistd.h>
 #elif defined(__APPLE__)
@@ -511,7 +511,7 @@
 {
     void sleepMs(int ms)
     {
-#ifdef _WIN32
+#if defined(_WIN32) && !defined(__MINGW32__)
         Sleep(ms);
 #else
         sleep(ms * 1e-3);
@@ -520,7 +520,7 @@
 
     bool debuggerIsAttached()
     {
-#ifdef _WIN32
+#if defined(_WIN32) && !defined(__MINGW32__)
         return IsDebuggerPresent();
 #elif defined(__APPLE__)
         int mib[4];
@@ -553,9 +553,9 @@
     }
 }
 
-CEXPORT void indigoDbgBreakpoint(void)
+void indigoDbgBreakpoint(void)
 {
-#ifdef _WIN32
+#if defined(_WIN32) && !defined(__MINGW32__)
     if (!IsDebuggerPresent())
     {
         char msg[200];
@@ -578,7 +578,7 @@
 #endif
 }
 
-CEXPORT const char* indigoDbgProfiling(int whole_session)
+const char* indigoDbgProfiling(int whole_session)
 {
     INDIGO_BEGIN
     {
@@ -592,7 +592,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoDbgResetProfiling(int whole_session)
+int indigoDbgResetProfiling(int whole_session)
 {
     INDIGO_BEGIN
     {
@@ -606,7 +606,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT qword indigoDbgProfilingGetCounter(const char* name, int whole_session)
+qword indigoDbgProfilingGetCounter(const char* name, int whole_session)
 {
     INDIGO_BEGIN
     {
Index: openbabel-src/openbabel/src/forcefields/forcefieldghemical.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/forcefields/forcefieldghemical.cpp b/openbabel-src/openbabel/src/forcefields/forcefieldghemical.cpp
--- a/openbabel-src/openbabel/src/forcefields/forcefieldghemical.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/forcefields/forcefieldghemical.cpp	(date 1714440647082)
@@ -858,7 +858,7 @@
     OBFFParameter parameter;
 
     // open data/ghemical.prm
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "ghemical.prm").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open ghemical.prm", obError);
       return false;
@@ -942,8 +942,6 @@
       }
     }
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
@@ -964,7 +962,7 @@
     _mol.SetAtomTypesPerceived();
 
     // open data/ghemical.prm
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "ghemical.prm").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open ghemical.prm", obError);
       return false;
@@ -1026,8 +1024,6 @@
     //  else
     //    cout << "ATOMTYPE " << a->GetType() << endl;
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
Index: cppcoro-src/cppcoro/lib/file_write_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/file_write_operation.cpp b/cppcoro-src/cppcoro/lib/file_write_operation.cpp
--- a/cppcoro-src/cppcoro/lib/file_write_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/file_write_operation.cpp	(date 1714440647082)
@@ -9,7 +9,7 @@
 # ifndef WIN32_LEAN_AND_MEAN
 #  define WIN32_LEAN_AND_MEAN
 # endif
-# include <Windows.h>
+# include <windows.h>
 
 bool cppcoro::file_write_operation_impl::try_start(
 	cppcoro::detail::win32_overlapped_operation_base& operation) noexcept
Index: rdkit-src/rdkit/Code/GraphMol/MolAlign/O3AAlignMolecules.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/MolAlign/O3AAlignMolecules.h b/rdkit-src/rdkit/Code/GraphMol/MolAlign/O3AAlignMolecules.h
--- a/rdkit-src/rdkit/Code/GraphMol/MolAlign/O3AAlignMolecules.h	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Code/GraphMol/MolAlign/O3AAlignMolecules.h	(date 1714440647082)
@@ -27,7 +27,7 @@
 
 namespace RDKit {
 namespace MolAlign {
-struct RDKIT_MOLALIGN_EXPORT O3AFuncData {
+struct RDKIT_O3AALIGN_EXPORT O3AFuncData {
   const Conformer *prbConf;
   const Conformer *refConf;
   void *prbProp;
@@ -46,7 +46,7 @@
 //! is defined by a pair of atom indexes (one for the probe,
 //! one for the reference) and a weight. Constraints can
 //! can be added via the O3AConstraintVect class.
-class RDKIT_MOLALIGN_EXPORT O3AConstraint {
+class RDKIT_O3AALIGN_EXPORT O3AConstraint {
   friend class O3AConstraintVect;
 
  public:
@@ -66,7 +66,7 @@
 //! method is invoked, the vector is sorted to make lookup faster.
 //! Hence, constraints are not necessarily stored in the same order
 //! they were appended.
-class RDKIT_MOLALIGN_EXPORT O3AConstraintVect {
+class RDKIT_O3AALIGN_EXPORT O3AConstraintVect {
  public:
   O3AConstraintVect() {}
   ~O3AConstraintVect() = default;
@@ -128,7 +128,7 @@
   O3_LOCAL_ONLY = (1 << 2)
 };
 
-class RDKIT_MOLALIGN_EXPORT MolHistogram {
+class RDKIT_O3AALIGN_EXPORT MolHistogram {
  public:
   MolHistogram(const ROMol &mol, const double *dmat, bool cleanupDmat = false);
   ~MolHistogram() = default;
@@ -142,7 +142,7 @@
   boost::multi_array<int, 2> d_h;
 };
 
-class RDKIT_MOLALIGN_EXPORT LAP {
+class RDKIT_O3AALIGN_EXPORT LAP {
  public:
   LAP(unsigned int dim)
       : d_rowSol(dim),
@@ -184,7 +184,7 @@
   boost::multi_array<int, 2> d_cost;
 };
 
-class RDKIT_MOLALIGN_EXPORT SDM {
+class RDKIT_O3AALIGN_EXPORT SDM {
  public:
   // constructor
   SDM(const Conformer *prbConf = nullptr, const Conformer *refConf = nullptr,
@@ -271,7 +271,7 @@
   }
 };
 
-class RDKIT_MOLALIGN_EXPORT O3A {
+class RDKIT_O3AALIGN_EXPORT O3A {
  public:
   //! pre-defined atom typing schemes
   typedef enum { MMFF94 = 0, CRIPPEN } AtomTypeScheme;
@@ -319,30 +319,30 @@
   double d_o3aScore;
 };
 
-RDKIT_MOLALIGN_EXPORT void randomTransform(ROMol &mol, const int cid = -1,
+RDKIT_O3AALIGN_EXPORT void randomTransform(ROMol &mol, const int cid = -1,
                                            const int seed = -1);
-RDKIT_MOLALIGN_EXPORT const RDGeom::POINT3D_VECT *reflect(
+RDKIT_O3AALIGN_EXPORT const RDGeom::POINT3D_VECT *reflect(
     const Conformer &conf);
-RDKIT_MOLALIGN_EXPORT int o3aMMFFCostFunc(const unsigned int prbIdx,
+RDKIT_O3AALIGN_EXPORT int o3aMMFFCostFunc(const unsigned int prbIdx,
                                           const unsigned int refIdx,
                                           double hSum, void *data);
-RDKIT_MOLALIGN_EXPORT double o3aMMFFWeightFunc(const unsigned int prbIdx,
+RDKIT_O3AALIGN_EXPORT double o3aMMFFWeightFunc(const unsigned int prbIdx,
                                                const unsigned int refIdx,
                                                void *data);
-RDKIT_MOLALIGN_EXPORT double o3aMMFFScoringFunc(const unsigned int prbIdx,
+RDKIT_O3AALIGN_EXPORT double o3aMMFFScoringFunc(const unsigned int prbIdx,
                                                 const unsigned int refIdx,
                                                 void *data);
-RDKIT_MOLALIGN_EXPORT int o3aCrippenCostFunc(const unsigned int prbIdx,
+RDKIT_O3AALIGN_EXPORT int o3aCrippenCostFunc(const unsigned int prbIdx,
                                              const unsigned int refIdx,
                                              double hSum, void *data);
-RDKIT_MOLALIGN_EXPORT double o3aCrippenWeightFunc(const unsigned int prbIdx,
+RDKIT_O3AALIGN_EXPORT double o3aCrippenWeightFunc(const unsigned int prbIdx,
                                                   const unsigned int refIdx,
                                                   void *data);
-RDKIT_MOLALIGN_EXPORT double o3aCrippenScoringFunc(const unsigned int prbIdx,
+RDKIT_O3AALIGN_EXPORT double o3aCrippenScoringFunc(const unsigned int prbIdx,
                                                    const unsigned int refIdx,
                                                    void *data);
 
-RDKIT_MOLALIGN_EXPORT void getO3AForProbeConfs(
+RDKIT_O3AALIGN_EXPORT void getO3AForProbeConfs(
     ROMol &prbMol, const ROMol &refMol, void *prbProp, void *refProp,
     std::vector<boost::shared_ptr<O3A>> &res, int numThreads = 1,
     O3A::AtomTypeScheme atomTypes = O3A::MMFF94, const int refCid = -1,
Index: openbabel-src/openbabel/src/descriptors/groupcontrib.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/descriptors/groupcontrib.cpp b/openbabel-src/openbabel/src/descriptors/groupcontrib.cpp
--- a/openbabel-src/openbabel/src/descriptors/groupcontrib.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/descriptors/groupcontrib.cpp	(date 1714440647082)
@@ -55,7 +55,7 @@
     OBSmartsPattern *sp;
 
     // open data file
-    ifstream ifs;
+    istringstream ifs;
 
     if (OpenDatafile(ifs, _filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, " Could not find contribution data file.", obError);
Index: indigo-src/indigo/api/c/bingo-nosql/bingo-nosql.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/bingo-nosql/bingo-nosql.h b/indigo-src/indigo/api/c/bingo-nosql/bingo-nosql.h
--- a/indigo-src/indigo/api/c/bingo-nosql/bingo-nosql.h	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/bingo-nosql/bingo-nosql.h	(date 1714440647082)
@@ -20,63 +20,64 @@
 #define __indigo_bingo__
 
 #include "indigo.h"
+#include "bingo_nosql_export.h"
 
-CEXPORT const char* bingoVersion();
+BINGO_NOSQL_EXPORT const char* bingoVersion();
 
 // options = "id: <property-name>"
-CEXPORT int bingoCreateDatabaseFile(const char* location, const char* type, const char* options);
-CEXPORT int bingoLoadDatabaseFile(const char* location, const char* options);
-CEXPORT int bingoCloseDatabase(int db);
+BINGO_NOSQL_EXPORT int bingoCreateDatabaseFile(const char* location, const char* type, const char* options);
+BINGO_NOSQL_EXPORT int bingoLoadDatabaseFile(const char* location, const char* options);
+BINGO_NOSQL_EXPORT int bingoCloseDatabase(int db);
 
 //
 // Record insertion/deletion
 //
-CEXPORT int bingoInsertRecordObj(int db, int obj);
-CEXPORT int bingoInsertIteratorObj(int db, int iterator_obj_id);
-CEXPORT int bingoInsertRecordObjWithId(int db, int obj, int id);
-CEXPORT int bingoInsertRecordObjWithExtFP(int db, int obj, int fp);
-CEXPORT int bingoInsertRecordObjWithIdAndExtFP(int db, int obj, int id, int fp);
-CEXPORT int bingoDeleteRecord(int db, int id);
-CEXPORT int bingoGetRecordObj(int db, int id);
+BINGO_NOSQL_EXPORT int bingoInsertRecordObj(int db, int obj);
+BINGO_NOSQL_EXPORT int bingoInsertIteratorObj(int db, int iterator_obj_id);
+BINGO_NOSQL_EXPORT int bingoInsertRecordObjWithId(int db, int obj, int id);
+BINGO_NOSQL_EXPORT int bingoInsertRecordObjWithExtFP(int db, int obj, int fp);
+BINGO_NOSQL_EXPORT int bingoInsertRecordObjWithIdAndExtFP(int db, int obj, int id, int fp);
+BINGO_NOSQL_EXPORT int bingoDeleteRecord(int db, int id);
+BINGO_NOSQL_EXPORT int bingoGetRecordObj(int db, int id);
 
-CEXPORT int bingoOptimize(int db);
+BINGO_NOSQL_EXPORT int bingoOptimize(int db);
 
 // Search methods that returns search object
 // Search object is an iterator
-CEXPORT int bingoSearchSub(int db, int query_obj, const char* options);
-CEXPORT int bingoSearchExact(int db, int query_obj, const char* options);
-CEXPORT int bingoSearchMolFormula(int db, const char* query, const char* options);
-CEXPORT int bingoSearchSim(int db, int query_obj, float min, float max, const char* options);
-CEXPORT int bingoSearchSimWithExtFP(int db, int query_obj, float min, float max, int fp, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchSub(int db, int query_obj, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchExact(int db, int query_obj, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchMolFormula(int db, const char* query, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchSim(int db, int query_obj, float min, float max, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchSimWithExtFP(int db, int query_obj, float min, float max, int fp, const char* options);
 
-CEXPORT int bingoSearchSimTopN(int db, int query_obj, int limit, float min, const char* options);
-CEXPORT int bingoSearchSimTopNWithExtFP(int db, int query_obj, int limit, float min, int fp, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchSimTopN(int db, int query_obj, int limit, float min, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchSimTopNWithExtFP(int db, int query_obj, int limit, float min, int fp, const char* options);
 
-CEXPORT int bingoEnumerateId(int db);
+BINGO_NOSQL_EXPORT int bingoEnumerateId(int db);
 
 //
 // Search object methods
 //
-CEXPORT int bingoNext(int search_obj);
-CEXPORT int bingoGetCurrentId(int search_obj);
-CEXPORT float bingoGetCurrentSimilarityValue(int search_obj);
+BINGO_NOSQL_EXPORT int bingoNext(int search_obj);
+BINGO_NOSQL_EXPORT int bingoGetCurrentId(int search_obj);
+BINGO_NOSQL_EXPORT float bingoGetCurrentSimilarityValue(int search_obj);
 
 // Estimation methods
-CEXPORT int bingoEstimateRemainingResultsCount(int search_obj);
-CEXPORT int bingoEstimateRemainingResultsCountError(int search_obj);
-CEXPORT int bingoEstimateRemainingTime(int search_obj, float* time_sec);
-CEXPORT int bingoContainersCount(int search_obj);
-CEXPORT int bingoCellsCount(int search_obj);
-CEXPORT int bingoCurrentCell(int search_obj);
-CEXPORT int bingoMinCell(int search_obj);
-CEXPORT int bingoMaxCell(int search_obj);
+BINGO_NOSQL_EXPORT int bingoEstimateRemainingResultsCount(int search_obj);
+BINGO_NOSQL_EXPORT int bingoEstimateRemainingResultsCountError(int search_obj);
+BINGO_NOSQL_EXPORT int bingoEstimateRemainingTime(int search_obj, float* time_sec);
+BINGO_NOSQL_EXPORT int bingoContainersCount(int search_obj);
+BINGO_NOSQL_EXPORT int bingoCellsCount(int search_obj);
+BINGO_NOSQL_EXPORT int bingoCurrentCell(int search_obj);
+BINGO_NOSQL_EXPORT int bingoMinCell(int search_obj);
+BINGO_NOSQL_EXPORT int bingoMaxCell(int search_obj);
 
 // This method return IndigoObject that represents current object.
 // After calling bingoNext this object automatically points to the next found result
-CEXPORT int bingoGetObject(int search_obj);
+BINGO_NOSQL_EXPORT int bingoGetObject(int search_obj);
 
-CEXPORT int bingoEndSearch(int search_obj);
+BINGO_NOSQL_EXPORT int bingoEndSearch(int search_obj);
 
-CEXPORT const char* bingoProfilingGetStatistics(int for_session);
+BINGO_NOSQL_EXPORT const char* bingoProfilingGetStatistics(int for_session);
 
 #endif // __indigo_bingo__
Index: cppcoro-src/cppcoro/lib/socket_connect_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_connect_operation.cpp b/cppcoro-src/cppcoro/lib/socket_connect_operation.cpp
--- a/cppcoro-src/cppcoro/lib/socket_connect_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_connect_operation.cpp	(date 1714440647082)
@@ -14,10 +14,10 @@
 #include <system_error>
 
 #if CPPCORO_OS_WINNT
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 
 bool cppcoro::net::socket_connect_operation_impl::try_start(
 	cppcoro::detail::win32_overlapped_operation_base& operation) noexcept
Index: arrow-src/arrow/cpp/src/arrow/vendored/datetime/date.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/arrow-src/arrow/cpp/src/arrow/vendored/datetime/date.h b/arrow-src/arrow/cpp/src/arrow/vendored/datetime/date.h
--- a/arrow-src/arrow/cpp/src/arrow/vendored/datetime/date.h	(revision 6a28035c2b49b432dc63f5ee7524d76b4ed2d762)
+++ b/arrow-src/arrow/cpp/src/arrow/vendored/datetime/date.h	(date 1714535987647)
@@ -4204,6 +4204,7 @@
     return hh_mm_ss<std::chrono::duration<Rep, Period>>(d);
 }

+#if !((defined(__APPLE__) && defined(__clang__)) || defined(__EMSCRIPTEN__))
 template <class CharT, class Traits, class Duration>
 inline
 typename std::enable_if
@@ -4216,6 +4217,7 @@
     auto const dp = date::floor<days>(tp);
     return os << year_month_day(dp) << ' ' << make_time(tp-dp);
 }
+#endif

 template <class CharT, class Traits>
 inline

Index: rdkit-src/rdkit/External/GA/ga/GaBase.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/External/GA/ga/GaBase.cpp b/rdkit-src/rdkit/External/GA/ga/GaBase.cpp
new file mode 100644
--- /dev/null	(date 1714440647090)
+++ b/rdkit-src/rdkit/External/GA/ga/GaBase.cpp	(date 1714440647090)
@@ -0,0 +1,9 @@
+#include "GaBase.h"
+
+using namespace GapeGa;
+
+GaBase::GaBase() {
+};
+
+GaBase::~GaBase() {
+};
\ No newline at end of file
Index: cppcoro-src/cppcoro/lib/socket_send_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_send_operation.cpp b/cppcoro-src/cppcoro/lib/socket_send_operation.cpp
--- a/cppcoro-src/cppcoro/lib/socket_send_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_send_operation.cpp	(date 1714440647082)
@@ -7,10 +7,10 @@
 #include <cppcoro/net/socket.hpp>
 
 #if CPPCORO_OS_WINNT
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 
 bool cppcoro::net::socket_send_operation_impl::try_start(
 	cppcoro::detail::win32_overlapped_operation_base& operation) noexcept
Index: openssl-src/openssl/crypto/dso_conf.h.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openssl-src/openssl/crypto/dso_conf.h.cmake b/openssl-src/openssl/crypto/dso_conf.h.cmake
new file mode 100644
--- /dev/null	(date 1714440647086)
+++ b/openssl-src/openssl/crypto/dso_conf.h.cmake	(date 1714440647086)
@@ -0,0 +1,17 @@
+/*
+ * Copyright 2016-2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://www.openssl.org/source/license.html
+ */
+
+#ifndef OSSL_CRYPTO_DSO_CONF_H
+# define OSSL_CRYPTO_DSO_CONF_H
+# define DSO_EXTENSION "@DSO_EXTENSION@"
+#cmakedefine DSO_NONE
+#cmakedefine DSO_WIN32
+#cmakedefine DSO_DLFCN
+#cmakedefine HAVE_DLFCN_H
+#endif
Index: cppcoro-src/cppcoro/lib/file_read_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/file_read_operation.cpp b/cppcoro-src/cppcoro/lib/file_read_operation.cpp
--- a/cppcoro-src/cppcoro/lib/file_read_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/file_read_operation.cpp	(date 1714440647082)
@@ -9,7 +9,7 @@
 # ifndef WIN32_LEAN_AND_MEAN
 #  define WIN32_LEAN_AND_MEAN
 # endif
-# include <Windows.h>
+# include <windows.h>
 
 bool cppcoro::file_read_operation_impl::try_start(
 	cppcoro::detail::win32_overlapped_operation_base& operation) noexcept
Index: cppcoro-src/cppcoro/lib/socket_accept_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_accept_operation.cpp b/cppcoro-src/cppcoro/lib/socket_accept_operation.cpp
--- a/cppcoro-src/cppcoro/lib/socket_accept_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_accept_operation.cpp	(date 1714440647082)
@@ -11,10 +11,10 @@
 #include <system_error>
 
 #if CPPCORO_OS_WINNT
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 
 // TODO: Eliminate duplication of implementation between socket_accept_operation
 // and socket_accept_operation_cancellable.
Index: cppcoro-src/cppcoro/lib/writable_file.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/writable_file.cpp b/cppcoro-src/cppcoro/lib/writable_file.cpp
--- a/cppcoro-src/cppcoro/lib/writable_file.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/writable_file.cpp	(date 1714440647082)
@@ -11,7 +11,7 @@
 # ifndef WIN32_LEAN_AND_MEAN
 #  define WIN32_LEAN_AND_MEAN
 # endif
-# include <Windows.h>
+# include <windows.h>
 
 void cppcoro::writable_file::set_size(
 	std::uint64_t fileSize)
Index: openbabel-src/openbabel/src/forcefields/forcefieldgaff.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/forcefields/forcefieldgaff.cpp b/openbabel-src/openbabel/src/forcefields/forcefieldgaff.cpp
--- a/openbabel-src/openbabel/src/forcefields/forcefieldgaff.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/forcefields/forcefieldgaff.cpp	(date 1714440647082)
@@ -1081,7 +1081,7 @@
     OBFFParameter parameter;
 
     // open data/gaff.dat
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "gaff.dat").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open gaff.dat", obError);
       return false;
@@ -1204,8 +1204,6 @@
 	    ifs.getline(buffer, BUFF_SIZE);
       }
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
@@ -1230,7 +1228,7 @@
     _mol.SetAtomTypesPerceived();
 
     // open data/gaff.prm
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "gaff.prm").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open gaff.prm", obError);
       return false;
@@ -1412,8 +1410,6 @@
     }
 
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
Index: openbabel-src/openbabel/src/forcefields/forcefielduff.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/forcefields/forcefielduff.cpp b/openbabel-src/openbabel/src/forcefields/forcefielduff.cpp
--- a/openbabel-src/openbabel/src/forcefields/forcefielduff.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/forcefields/forcefielduff.cpp	(date 1714440647082)
@@ -1614,7 +1614,7 @@
     OBFFParameter parameter;
 
     // open data/UFF.prm
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "UFF.prm").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open UFF.prm", obError);
       return false;
@@ -1647,7 +1647,10 @@
         parameter.b = 0; // used for tracking number of angles in 5-coordinate
         parameter.c = 0;
 
-        char coord = vs[1][2]; // 3rd character of atom type
+        char coord = '\0';
+        if (vs[1].size() > 2) {
+          coord = vs[1][2]; // 3rd character of atom type
+        }
         switch (coord) {
         case '1': // linear
           parameter._ipar.push_back(1);
@@ -1680,8 +1683,6 @@
       }
     }
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
@@ -1702,7 +1703,7 @@
     _mol.SetAtomTypesPerceived();
 
     // open data/UFF.prm
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "UFF.prm").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open UFF.prm", obError);
       return false;
@@ -1771,8 +1772,6 @@
 
     }
 
-    if (ifs)
-      ifs.close();
 
     // Free memory
     for (i = _vexttyp.begin();i != _vexttyp.end();++i) {
Index: openbabel-src/openbabel/src/forcefields/forcefieldmm2.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/forcefields/forcefieldmm2.cpp b/openbabel-src/openbabel/src/forcefields/forcefieldmm2.cpp
--- a/openbabel-src/openbabel/src/forcefields/forcefieldmm2.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/forcefields/forcefieldmm2.cpp	(date 1714440647082)
@@ -18,6 +18,10 @@
 #include <openbabel/babelconfig.h>
 #include <openbabel/mol.h>
 #include <openbabel/locale.h>
+#include <openbabel/obiter.h>
+#include <openbabel/bond.h>
+#include <openbabel/oberror.h>
+#include <openbabel/data.h>
 #include "forcefieldmm2.h"
 
 using namespace std;
@@ -498,8 +502,8 @@
     {
       _mol = src._mol;
       _init = src._init;
-      return *this;
-    }
+    }
+    return *this;
   }
 
   bool OBForceFieldMM2::Setup(OBMol &mol)
@@ -522,7 +526,7 @@
     OBFFParameter parameter;
 
     // open data/mm2.prm
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "mm2.prm").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mm2.prm", obError);
       return false;
@@ -667,8 +671,6 @@
       }
     }
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
Index: openbabel-src/openbabel/src/fingerprints/finger3.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/fingerprints/finger3.cpp b/openbabel-src/openbabel/src/fingerprints/finger3.cpp
--- a/openbabel-src/openbabel/src/fingerprints/finger3.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/fingerprints/finger3.cpp	(date 1714440647082)
@@ -159,7 +159,7 @@
   bool ReadPatternFile(string& ver)
   {
     //Reads three types of file. See below
-    ifstream ifs;
+    istringstream ifs;
 	  stringstream errorMsg;
 
     if (OpenDatafile(ifs, _patternsfile).length() == 0)
@@ -238,8 +238,6 @@
       }
     }while(getline(ifs,line));
 
-    if (ifs)
-      ifs.close();
     return true;
   }
 
@@ -255,7 +253,8 @@
       int num =  ppat->numbits, div = ppat->numoccurrences+1, ngrp;
       while(num) //for each group of bits
       {
-        ngrp = (num + div -1)/div--; //rounds up
+        ngrp = (num + div -1)/div; //rounds up
+        --div;
         num -= ngrp;
         if(GetBit(fp, n) == bSet)
         {
Index: openbabel-src/openbabel/src/forcefields/forcefieldmmff94.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/forcefields/forcefieldmmff94.cpp b/openbabel-src/openbabel/src/forcefields/forcefieldmmff94.cpp
--- a/openbabel-src/openbabel/src/forcefields/forcefieldmmff94.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/forcefields/forcefieldmmff94.cpp	(date 1714440647082)
@@ -874,7 +874,7 @@
     char buffer[80];
 
     // open data/_parFile
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, _parFile).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open parameter file", obError);
       return false;
@@ -913,8 +913,6 @@
         ParseParamVDW(vs[1]);
     }
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
@@ -929,7 +927,7 @@
     OBFFParameter parameter;
 
     // open data/mmffbond.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffbond.par", obError);
       return false;
@@ -950,8 +948,6 @@
       _ffbondparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -964,7 +960,7 @@
     OBFFParameter parameter;
 
     // open data/mmffbndk.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffbndk.par", obError);
       return false;
@@ -984,8 +980,6 @@
       _ffbndkparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -998,7 +992,7 @@
     OBFFParameter parameter;
 
     // open data/mmffang.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffang.par", obError);
       return false;
@@ -1020,8 +1014,6 @@
       _ffangleparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1034,7 +1026,7 @@
     OBFFParameter parameter;
 
     // open data/mmffstbn.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffstbn.par", obError);
       return false;
@@ -1056,8 +1048,6 @@
       _ffstrbndparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1070,7 +1060,7 @@
     OBFFParameter parameter;
 
     // open data/mmffdfsb.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffdfsb.par", obError);
       return false;
@@ -1091,8 +1081,6 @@
       _ffdfsbparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1105,7 +1093,7 @@
     OBFFParameter parameter;
 
     // open data/mmffoop.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffoop.par", obError);
       return false;
@@ -1126,8 +1114,6 @@
       _ffoopparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1140,7 +1126,7 @@
     OBFFParameter parameter;
 
     // open data/mmfftor.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmfftor.par", obError);
       return false;
@@ -1164,8 +1150,6 @@
       _fftorsionparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1178,7 +1162,7 @@
     OBFFParameter parameter;
 
     // open data/mmffvdw.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffvdw.par", obError);
       return false;
@@ -1205,8 +1189,6 @@
       _ffvdwparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1219,7 +1201,7 @@
     OBFFParameter parameter;
 
     // open data/mmffchg.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffchg.par", obError);
       return false;
@@ -1239,8 +1221,6 @@
       _ffchgparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1253,7 +1233,7 @@
     OBFFParameter parameter;
 
     // open data/mmffpbci.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffpbci", obError);
       return false;
@@ -1272,8 +1252,6 @@
       _ffpbciparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1286,7 +1264,7 @@
     OBFFParameter parameter;
 
     // open data/mmffprop.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffprop.par", obError);
       return false;
@@ -1321,8 +1299,6 @@
       _ffpropparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1335,7 +1311,7 @@
     OBFFParameter parameter;
 
     // open data/mmffdef.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffdef.par", obError);
       return false;
@@ -1356,8 +1332,6 @@
       _ffdefparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
Index: protobuf-src/protobuf/third_party/utf8_range/range2-sse.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/protobuf-src/protobuf/third_party/utf8_range/range2-sse.c b/protobuf-src/protobuf/third_party/utf8_range/range2-sse.c
--- a/protobuf-src/protobuf/third_party/utf8_range/range2-sse.c	(revision 2434ef2adf0c74149b9d547ac5fb545a1ff8b6b5)
+++ b/protobuf-src/protobuf/third_party/utf8_range/range2-sse.c	(date 1714440647082)
@@ -6,7 +6,7 @@
 
 #include <stdio.h>
 #include <stdint.h>
-#include <x86intrin.h>
+#include <smmintrin.h>
 
 int utf8_naive(const unsigned char *data, int len);
 
Index: indigo-src/indigo/api/c/bingo-nosql/src/bingo-nosql.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/bingo-nosql/src/bingo-nosql.cpp b/indigo-src/indigo/api/c/bingo-nosql/src/bingo-nosql.cpp
--- a/indigo-src/indigo/api/c/bingo-nosql/src/bingo-nosql.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/bingo-nosql/src/bingo-nosql.cpp	(date 1714440647082)
@@ -349,12 +349,12 @@
     auto matcher_ptr = sf::xlock_safe_ptr(searches_data->searches.at(id));                                                                                     \
     auto& matcher = **matcher_ptr;
 
-CEXPORT const char* bingoVersion()
+const char* bingoVersion()
 {
     return BINGO_VERSION;
 }
 
-CEXPORT int bingoCreateDatabaseFile(const char* location, const char* type, const char* options)
+int bingoCreateDatabaseFile(const char* location, const char* type, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -363,7 +363,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int bingoLoadDatabaseFile(const char* location, const char* options)
+int bingoLoadDatabaseFile(const char* location, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -372,7 +372,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int bingoCloseDatabase(int db)
+int bingoCloseDatabase(int db)
 {
 #ifdef INDIGO_DEBUG
     std::stringstream ss;
@@ -389,7 +389,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoInsertRecordObj(int db, int obj)
+int bingoInsertRecordObj(int db, int obj)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -414,7 +414,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoInsertIteratorObj(int db, int iterator_obj_id)
+int bingoInsertIteratorObj(int db, int iterator_obj_id)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -437,7 +437,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoInsertRecordObjWithId(int db, int obj, int id)
+int bingoInsertRecordObjWithId(int db, int obj, int id)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -447,7 +447,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoInsertRecordObjWithExtFP(int db, int obj, int fp)
+int bingoInsertRecordObjWithExtFP(int db, int obj, int fp)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -473,7 +473,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoInsertRecordObjWithIdAndExtFP(int db, int obj, int id, int fp)
+int bingoInsertRecordObjWithIdAndExtFP(int db, int obj, int id, int fp)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -484,7 +484,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoDeleteRecord(int db, int id)
+int bingoDeleteRecord(int db, int id)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -496,7 +496,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoGetRecordObj(int db, int id)
+int bingoGetRecordObj(int db, int id)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -538,7 +538,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoOptimize(int db)
+int bingoOptimize(int db)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -550,7 +550,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchSub(int db, int query_obj, const char* options)
+int bingoSearchSub(int db, int query_obj, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -601,7 +601,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchExact(int db, int query_obj, const char* options)
+int bingoSearchExact(int db, int query_obj, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -650,7 +650,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchMolFormula(int db, const char* query, const char* options)
+int bingoSearchMolFormula(int db, const char* query, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -674,7 +674,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchSim(int db, int query_obj, float min, float max, const char* options)
+int bingoSearchSim(int db, int query_obj, float min, float max, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -725,7 +725,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchSimWithExtFP(int db, int query_obj, float min, float max, int fp, const char* options)
+int bingoSearchSimWithExtFP(int db, int query_obj, float min, float max, int fp, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -777,7 +777,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchSimTopN(int db, int query_obj, int limit, float min, const char* options)
+int bingoSearchSimTopN(int db, int query_obj, int limit, float min, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -828,7 +828,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchSimTopNWithExtFP(int db, int query_obj, int limit, float min, int fp, const char* options)
+int bingoSearchSimTopNWithExtFP(int db, int query_obj, int limit, float min, int fp, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -880,7 +880,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoEnumerateId(int db)
+int bingoEnumerateId(int db)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -900,7 +900,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoEndSearch(int search_obj)
+int bingoEndSearch(int search_obj)
 {
 #ifdef INDIGO_DEBUG
     std::stringstream ss;
@@ -916,7 +916,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoNext(int search_obj)
+int bingoNext(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -926,7 +926,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoGetCurrentId(int search_obj)
+int bingoGetCurrentId(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -936,7 +936,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT float bingoGetCurrentSimilarityValue(int search_obj)
+float bingoGetCurrentSimilarityValue(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -946,7 +946,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoEstimateRemainingResultsCount(int search_obj)
+int bingoEstimateRemainingResultsCount(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -957,7 +957,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoContainersCount(int search_obj)
+int bingoContainersCount(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -967,7 +967,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoCellsCount(int search_obj)
+int bingoCellsCount(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -977,7 +977,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoCurrentCell(int search_obj)
+int bingoCurrentCell(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -987,7 +987,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoMinCell(int search_obj)
+int bingoMinCell(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -997,7 +997,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoMaxCell(int search_obj)
+int bingoMaxCell(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -1007,7 +1007,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoEstimateRemainingResultsCountError(int search_obj)
+int bingoEstimateRemainingResultsCountError(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -1019,7 +1019,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoEstimateRemainingTime(int search_obj, float* time_sec)
+int bingoEstimateRemainingTime(int search_obj, float* time_sec)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -1031,7 +1031,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoGetObject(int search_obj)
+int bingoGetObject(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -1042,7 +1042,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT const char* bingoProfilingGetStatistics(int for_session)
+const char* bingoProfilingGetStatistics(int for_session)
 {
     INDIGO_BEGIN
     {
Index: rdkit-src/rdkit/Code/GraphMol/StructChecker/StripSmallFragments.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/StructChecker/StripSmallFragments.cpp b/rdkit-src/rdkit/Code/GraphMol/StructChecker/StripSmallFragments.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/StructChecker/StripSmallFragments.cpp	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Code/GraphMol/StructChecker/StripSmallFragments.cpp	(date 1714440647082)
@@ -13,7 +13,7 @@
 #include "../Descriptors/MolDescriptors.h"
 #include "StripSmallFragments.h"
 #include "../SmilesParse/SmilesWrite.h"
-#include "../MolFileStereochem.h"
+#include "../FileParsers/MolFileStereochem.h"
 
 // define snprintf for msvc
 #if _MSC_VER
Index: rdkit-src/rdkit/Code/GraphMol/SLNParse/lex.yysln.cpp.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/SLNParse/lex.yysln.cpp.cmake b/rdkit-src/rdkit/Code/GraphMol/SLNParse/lex.yysln.cpp.cmake
--- a/rdkit-src/rdkit/Code/GraphMol/SLNParse/lex.yysln.cpp.cmake	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Code/GraphMol/SLNParse/lex.yysln.cpp.cmake	(date 1714440647082)
@@ -727,8 +727,8 @@
 #endif
 
 #include <cstdio>
-#ifdef WIN32
-#include <io.h> 	 
+#if defined(WIN32) || defined(__MINGW32__)
+#include <io.h>
 #endif
 
 #include <RDGeneral/Exceptions.h>
Index: libpng-src/libpng/pngconf.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/pngconf.h b/libpng-src/libpng/pngconf.h
--- a/libpng-src/libpng/pngconf.h	(revision ed217e3e601d8e462f7fd1e04bed43ac42212429)
+++ b/libpng-src/libpng/pngconf.h	(date 1714440647082)
@@ -21,6 +21,7 @@
 #ifndef PNGCONF_H
 #define PNGCONF_H
 
+#include "libpng_export.h"
 #ifndef PNG_BUILDING_SYMBOL_TABLE /* else includes may cause problems */
 
 /* From libpng 1.6.0 libpng requires an ANSI X3.159-1989 ("ISOC90") compliant C
@@ -162,14 +163,6 @@
  * PNG_EXPORT_TYPE(type) A macro that pre or appends PNG_IMPEXP to
  *                       'type', compiler specific.
  *
- * PNG_DLL_EXPORT Set to the magic to use during a libpng build to
- *                make a symbol exported from the DLL.  Not used in the
- *                public header files; see pngpriv.h for how it is used
- *                in the libpng build.
- *
- * PNG_DLL_IMPORT Set to the magic to force the libpng symbols to come
- *                from a DLL - used to define PNG_IMPEXP when
- *                PNG_USE_DLL is set.
  */
 
 /* System specific discovery.
@@ -180,6 +173,7 @@
  * compiler-specific macros to the values required to change the calling
  * conventions of the various functions.
  */
+
 #if defined(_WIN32) || defined(__WIN32__) || defined(__NT__) || \
     defined(__CYGWIN__)
   /* Windows system (DOS doesn't support DLLs).  Includes builds under Cygwin or
@@ -222,23 +216,6 @@
 #  if defined(PNGAPI) && !defined(PNG_USER_PRIVATEBUILD)
 #     error "PNG_USER_PRIVATEBUILD must be defined if PNGAPI is changed"
 #  endif
-
-#  if (defined(_MSC_VER) && _MSC_VER < 800) ||\
-      (defined(__BORLANDC__) && __BORLANDC__ < 0x500)
-   /* older Borland and MSC
-    * compilers used '__export' and required this to be after
-    * the type.
-    */
-#    ifndef PNG_EXPORT_TYPE
-#      define PNG_EXPORT_TYPE(type) type PNG_IMPEXP
-#    endif
-#    define PNG_DLL_EXPORT __export
-#  else /* newer compiler */
-#    define PNG_DLL_EXPORT __declspec(dllexport)
-#    ifndef PNG_DLL_IMPORT
-#      define PNG_DLL_IMPORT __declspec(dllimport)
-#    endif
-#  endif /* compiler */
 
 #else /* !Windows */
 #  if (defined(__IBMC__) || defined(__IBMCPP__)) && defined(__OS2__)
@@ -265,16 +242,9 @@
  * then in an internal header file when building the library, otherwise (when
  * using the library) it is set here.
  */
-#ifndef PNG_IMPEXP
-#  if defined(PNG_USE_DLL) && defined(PNG_DLL_IMPORT)
-   /* This forces use of a DLL, disallowing static linking */
-#    define PNG_IMPEXP PNG_DLL_IMPORT
-#  endif
-
 #  ifndef PNG_IMPEXP
-#    define PNG_IMPEXP
+#    define PNG_IMPEXP LIBPNG_EXPORT
 #  endif
-#endif
 
 /* In 1.5.2 the definition of PNG_FUNCTION has been changed to always treat
  * 'attributes' as a storage class - the attributes go at the start of the
Index: zlib-src/zlib/gzguts.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/zlib-src/zlib/gzguts.h b/zlib-src/zlib/gzguts.h
--- a/zlib-src/zlib/gzguts.h	(revision 51b7f2abdade71cd9bb0e7a373ef2610ec6f9daf)
+++ b/zlib-src/zlib/gzguts.h	(date 1714440647082)
@@ -36,6 +36,8 @@
 
 #if defined(__TURBOC__) || defined(_MSC_VER) || defined(_WIN32)
 #  include <io.h>
+#else
+#  include <unistd.h>
 #endif
 
 #if defined(_WIN32)
Index: libxml2-src/libxml2/include/libxml/xmlexports.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libxml2-src/libxml2/include/libxml/xmlexports.h b/libxml2-src/libxml2/include/libxml/xmlexports.h
--- a/libxml2-src/libxml2/include/libxml/xmlexports.h	(revision 505e2e872e767405be565aa9d47ae9d6d5677f79)
+++ b/libxml2-src/libxml2/include/libxml/xmlexports.h	(date 1714440647082)
@@ -8,18 +8,11 @@
 #ifndef __XML_EXPORTS_H__
 #define __XML_EXPORTS_H__
 
-/** DOC_DISABLE */
-#if defined(_WIN32) || defined(__CYGWIN__)
-  #ifdef LIBXML_STATIC
-    #define XMLPUBLIC
-  #elif defined(IN_LIBXML)
-    #define XMLPUBLIC __declspec(dllexport)
-  #else
-    #define XMLPUBLIC __declspec(dllimport)
-  #endif
-#else /* not Windows */
-  #define XMLPUBLIC
-#endif /* platform switch */
+#include "xml2_export.h"
+#ifndef XMLPUBLIC
+#define XMLPUBLIC XML2_EXPORT
+#endif
+
 /** DOC_ENABLE */
 
 /*
Index: opencv-src/opencv/modules/imgproc/src/generalized_hough.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/imgproc/src/generalized_hough.cpp b/opencv-src/opencv/modules/imgproc/src/generalized_hough.cpp
--- a/opencv-src/opencv/modules/imgproc/src/generalized_hough.cpp	(revision dad8af6b17f8e60d7b95a1203a1b4d22f56574cf)
+++ b/opencv-src/opencv/modules/imgproc/src/generalized_hough.cpp	(date 1714440647082)
@@ -692,7 +692,7 @@
         getContourPoints(edges, dx, dy, points);
 
         features.resize(levels_ + 1);
-        std::for_each(features.begin(), features.end(), [=](std::vector<Feature>& e) { e.clear(); e.reserve(maxBufferSize_); });
+        std::for_each(features.begin(), features.end(), [=, this](std::vector<Feature>& e) { e.clear(); e.reserve(maxBufferSize_); });
 
         for (size_t i = 0; i < points.size(); ++i)
         {
Index: zlib-src/zlib/zconf.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/zlib-src/zlib/zconf.h b/zlib-src/zlib/zconf.h
--- a/zlib-src/zlib/zconf.h	(revision 51b7f2abdade71cd9bb0e7a373ef2610ec6f9daf)
+++ b/zlib-src/zlib/zconf.h	(date 1714440647082)
@@ -8,6 +8,7 @@
 #ifndef ZCONF_H
 #define ZCONF_H
 
+#include "zlib_export.h"
 /*
  * If you *really* need a unique prefix for all types and library functions,
  * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
@@ -326,63 +327,15 @@
 #    endif
 #  endif
 #endif
-
-#if defined(WINDOWS) || defined(WIN32)
-   /* If building or using zlib as a DLL, define ZLIB_DLL.
-    * This is not mandatory, but it offers a little performance increase.
-    */
-#  ifdef ZLIB_DLL
-#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
-#      ifdef ZLIB_INTERNAL
-#        define ZEXTERN extern __declspec(dllexport)
-#      else
-#        define ZEXTERN extern __declspec(dllimport)
-#      endif
-#    endif
-#  endif  /* ZLIB_DLL */
-   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
-    * define ZLIB_WINAPI.
-    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
-    */
-#  ifdef ZLIB_WINAPI
-#    ifdef FAR
-#      undef FAR
-#    endif
-#    ifndef WIN32_LEAN_AND_MEAN
-#      define WIN32_LEAN_AND_MEAN
-#    endif
-#    include <windows.h>
-     /* No need for _export, use ZLIB.DEF instead. */
-     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
-#    define ZEXPORT WINAPI
-#    ifdef WIN32
-#      define ZEXPORTVA WINAPIV
-#    else
-#      define ZEXPORTVA FAR CDECL
-#    endif
-#  endif
-#endif
-
-#if defined (__BEOS__)
-#  ifdef ZLIB_DLL
-#    ifdef ZLIB_INTERNAL
-#      define ZEXPORT   __declspec(dllexport)
-#      define ZEXPORTVA __declspec(dllexport)
-#    else
-#      define ZEXPORT   __declspec(dllimport)
-#      define ZEXPORTVA __declspec(dllimport)
-#    endif
-#  endif
-#endif
 
 #ifndef ZEXTERN
-#  define ZEXTERN extern
+#define ZEXTERN extern ZLIB_EXPORT
 #endif
 #ifndef ZEXPORT
-#  define ZEXPORT
+#define ZEXPORT
 #endif
 #ifndef ZEXPORTVA
-#  define ZEXPORTVA
+#define ZEXPORTVA
 #endif
 
 #ifndef FAR
Index: libxml2-src/libxml2/error.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libxml2-src/libxml2/error.c b/libxml2-src/libxml2/error.c
--- a/libxml2-src/libxml2/error.c	(revision 505e2e872e767405be565aa9d47ae9d6d5677f79)
+++ b/libxml2-src/libxml2/error.c	(date 1714440647082)
@@ -882,7 +882,7 @@
  *
  * Returns a pointer to the error
  */
-const xmlError *
+xmlError *
 xmlGetLastError(void)
 {
     if (xmlLastError.code == XML_ERR_OK)
Index: arrow-src/arrow/cpp/src/arrow/dataset/visibility.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/arrow-src/arrow/cpp/src/arrow/dataset/visibility.h b/arrow-src/arrow/cpp/src/arrow/dataset/visibility.h
--- a/arrow-src/arrow/cpp/src/arrow/dataset/visibility.h	(revision 6a28035c2b49b432dc63f5ee7524d76b4ed2d762)
+++ b/arrow-src/arrow/cpp/src/arrow/dataset/visibility.h	(date 1714440647082)
@@ -18,6 +18,15 @@
 // This API is EXPERIMENTAL.
 
 #pragma once
+#include <arrow/util/visibility.h>
+
+#ifndef ARROW_DS_EXPORT
+#define ARROW_DS_EXPORT ARROW_EXPORT
+#endif
+
+#ifndef ARROW_DS_NO_EXPORT
+#define ARROW_DS_NO_EXPORT ARROW_NO_EXPORT
+#endif
 
 #if defined(_WIN32) || defined(__CYGWIN__)
 #if defined(_MSC_VER)
@@ -26,23 +35,6 @@
 #else
 #pragma GCC diagnostic ignored "-Wattributes"
 #endif
-
-#ifdef ARROW_DS_STATIC
-#define ARROW_DS_EXPORT
-#elif defined(ARROW_DS_EXPORTING)
-#define ARROW_DS_EXPORT __declspec(dllexport)
-#else
-#define ARROW_DS_EXPORT __declspec(dllimport)
-#endif
-
-#define ARROW_DS_NO_EXPORT
-#else  // Not Windows
-#ifndef ARROW_DS_EXPORT
-#define ARROW_DS_EXPORT __attribute__((visibility("default")))
-#endif
-#ifndef ARROW_DS_NO_EXPORT
-#define ARROW_DS_NO_EXPORT __attribute__((visibility("hidden")))
-#endif
 #endif  // Non-Windows
 
 #if defined(_MSC_VER)
Index: libpng-src/libpng/pngpriv.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/pngpriv.h b/libpng-src/libpng/pngpriv.h
--- a/libpng-src/libpng/pngpriv.h	(revision ed217e3e601d8e462f7fd1e04bed43ac42212429)
+++ b/libpng-src/libpng/pngpriv.h	(date 1714440647082)
@@ -366,16 +366,9 @@
  * PNG_IMPEXP must be set here when building the library to prevent pngconf.h
  * setting it to the "import" setting for a DLL build.
  */
-#ifndef PNG_IMPEXP
-#  ifdef PNG_BUILD_DLL
-#     define PNG_IMPEXP PNG_DLL_EXPORT
-#  else
-      /* Not building a DLL, or the DLL doesn't require specific export
-       * definitions.
-       */
-#     define PNG_IMPEXP
+#  ifndef PNG_IMPEXP
+#    define PNG_IMPEXP LIBPNG_EXPORT
 #  endif
-#endif
 
 /* No warnings for private or deprecated functions in the build: */
 #ifndef PNG_DEPRECATED
@@ -435,11 +428,6 @@
 
 #include "png.h"
 
-/* pngconf.h does not set PNG_DLL_EXPORT unless it is required, so: */
-#ifndef PNG_DLL_EXPORT
-#  define PNG_DLL_EXPORT
-#endif
-
 /* This is a global switch to set the compilation for an installed system
  * (a release build).  It can be set for testing debug builds to ensure that
  * they will compile when the build type is switched to RC or STABLE, the
Index: inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.h b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.h
--- a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.h	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.h	(date 1714440647082)
@@ -35,7 +35,7 @@
 #ifndef __INCHI_DLL_A_H__
 #define __INCHI_DLL_A_H__
 
-#include "../../../INCHI_BASE/src/ichicant.h"
+#include "ichicant.h"
 
 typedef struct tagCOMPONENT_TREAT_INFO
 {
@@ -128,25 +128,6 @@
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
 
 
-#if (defined( _WIN32 ) && defined( _MSC_VER ) && defined(BUILD_LINK_AS_DLL) )
-    /* Win32 & MS VC ++, compile and link as a DLL */
-#ifdef _USRDLL
-    /* InChI library dll */
-#define INCHI_API __declspec(dllexport)
-#define EXPIMP_TEMPLATE
-#define INCHI_DECL
-#else
-   /* calling the InChI dll program */
-#define INCHI_API __declspec(dllimport)
-#define EXPIMP_TEMPLATE extern
-#define INCHI_DECL
-#endif
-#else
-    /* create a statically linked InChI library or link to an executable */
-#define INCHI_API
-#define EXPIMP_TEMPLATE
-#define INCHI_DECL
-#endif
 
 
 
Index: inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll.c b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll.c	(date 1714440647082)
@@ -42,25 +42,25 @@
 #include <float.h>
 #include <math.h>
 
-#include "../../../INCHI_BASE/src/mode.h"
+#include "mode.h"
 
-#include "../../../INCHI_BASE/src/incomdef.h"
-#include "../../../INCHI_BASE/src/ichidrp.h"
-#include "../../../INCHI_BASE/src/inpdef.h"
-#include "../../../INCHI_BASE/src/ichi.h"
-#include "../../../INCHI_BASE/src/strutil.h"
-#include "../../../INCHI_BASE/src/util.h"
-#include "../../../INCHI_BASE/src/ichierr.h"
-#include "../../../INCHI_BASE/src/ichimain.h"
-#include "../../../INCHI_BASE/src/extr_ct.h"
-#include "../../../INCHI_BASE/src/ichi_io.h"
-#include "../../../INCHI_BASE/src/ichicomp.h"
-#include "../../../INCHI_BASE/src/inchi_api.h"
-#include "../../../INCHI_BASE/src/readinch.h"
+#include "incomdef.h"
+#include "ichidrp.h"
+#include "inpdef.h"
+#include "ichi.h"
+#include "strutil.h"
+#include "util.h"
+#include "ichierr.h"
+#include "ichimain.h"
+#include "extr_ct.h"
+#include "ichi_io.h"
+#include "ichicomp.h"
+#include "inchi_api.h"
+#include "readinch.h"
 
-#include "../../../INCHI_BASE/src/ichitaut.h"
-#include "../../../INCHI_BASE/src/ichicant.h"
-#include "../../../INCHI_BASE/src/ichitime.h"
+#include "ichitaut.h"
+#include "ichicant.h"
+#include "ichitime.h"
 
 #include "inchi_dll.h"
 
Index: openbabel-src/openbabel/data/gaff.prm
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/data/gaff.prm b/openbabel-src/openbabel/data/gaff.prm
--- a/openbabel-src/openbabel/data/gaff.prm	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/data/gaff.prm	(date 1714440647082)
@@ -91,7 +91,7 @@
 atom [#6X3;R](=*)-*=*   						    ca "sp2 C in aromatic ring"
 atom [#6X3;R](=[#6X3])([#6])[#1]					    ca "sp2 C in aromatic ring"	
 atom [#6X3;R](=[#6])([#6])[F,Cl,Br,I]   				    c2 "sp2 C in a ring with 1 electron-withdrawal group"
-atom [#6X3;R](=[#6X3])([#6X4])[#6]					    c2 "sp2 C in a ring"		
+atom [#6X3;R](=[#6X3])([#6X4])[#6]					    c2 "sp2 C in a ring"
 atom [#6X3;R](=*)-*#*   						    cc "sp2 C in a conjugated ring"
 atom [#6X3;R](#*)-*#*   						    cc "sp2 C in a conjugated ring"
 atom [#6X3;R]:[#7,#8,#16]     	     	      				    cc "sp2 C in a ring with 1 electron-withdrawal group"
Index: boost-src/boost/libs/stacktrace/src/noop.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/stacktrace/src/noop.cpp b/boost-src/boost/libs/stacktrace/src/noop.cpp
--- a/boost-src/boost/libs/stacktrace/src/noop.cpp	(revision 351b03d5220510a1b6738cc378659b6d85c8a4da)
+++ b/boost-src/boost/libs/stacktrace/src/noop.cpp	(date 1714440647086)
@@ -6,6 +6,8 @@
 
 #define BOOST_STACKTRACE_INTERNAL_BUILD_LIBS
 #define BOOST_STACKTRACE_LINK
+#ifndef BOOST_STACKTRACE_USE_NOOP
 #define BOOST_STACKTRACE_USE_NOOP
+#endif
 #include <boost/stacktrace/detail/frame_noop.ipp>
 #include <boost/stacktrace/detail/safe_dump_noop.ipp>
Index: quickjs-src/quickjs/quickjs-atom.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/quickjs-atom.h b/quickjs-src/quickjs/src/quickjs-atom.h
rename from quickjs-src/quickjs/quickjs-atom.h
rename to quickjs-src/quickjs/src/quickjs-atom.h
--- a/quickjs-src/quickjs/quickjs-atom.h	(revision 3b45d155c77bbdfe9177b1e03db830d2aff0b2a8)
+++ b/quickjs-src/quickjs/src/quickjs-atom.h	(date 1714440647082)
@@ -82,7 +82,6 @@
 DEF(fileName, "fileName")
 DEF(lineNumber, "lineNumber")
 DEF(message, "message")
-DEF(cause, "cause")
 DEF(errors, "errors")
 DEF(stack, "stack")
 DEF(name, "name")
@@ -167,7 +166,6 @@
 DEF(async, "async")
 DEF(exec, "exec")
 DEF(groups, "groups")
-DEF(indices, "indices")
 DEF(status, "status")
 DEF(reason, "reason")
 DEF(globalThis, "globalThis")
@@ -179,11 +177,11 @@
 DEF(maximumSignificantDigits, "maximumSignificantDigits")
 DEF(maximumFractionDigits, "maximumFractionDigits")
 #endif
-/* the following 3 atoms are only used with CONFIG_ATOMICS */
+#ifdef CONFIG_ATOMICS
 DEF(not_equal, "not-equal")
 DEF(timed_out, "timed-out")
 DEF(ok, "ok")
-/* */
+#endif
 DEF(toJSON, "toJSON")
 /* class names */
 DEF(Object, "Object")
Index: openbabel-src/openbabel/data/patty.rules
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/data/patty.rules b/openbabel-src/openbabel/data/patty.rules
--- a/openbabel-src/openbabel/data/patty.rules	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/data/patty.rules	(date 1714440647086)
@@ -133,9 +133,9 @@
 # diaminopyrimidine (ring Ns are POL)
 #
 #        *==*
-#       /    \  
+#       /    \
 #     :N      C--NH2            (aromatic)
-#      \\    #  
+#      \\    #
 #        C--N:
 #       /
 #       NH2
@@ -186,7 +186,7 @@
 [#8,#16,#34;D1]C=[#8,#16,#34]           ANI
 [#8,#16,#34]=C[#8,#16,#34;D1]           ANI
 #        *==*
-#       /    \  
+#       /    \
 #      *      C==O              (aromatic)
 #      \\    /
 #        C--C                   And 4 Cs away
Index: inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a2.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a2.c b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a2.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a2.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a2.c	(date 1714440647086)
@@ -43,31 +43,31 @@
 
 /*  */
 
-#include "../../../INCHI_BASE/src/mode.h"
-#include "../../../INCHI_BASE/src/ichitime.h"
-#include "../../../INCHI_BASE/src/incomdef.h"
-#include "../../../INCHI_BASE/src/ichidrp.h"
-#include "../../../INCHI_BASE/src/inpdef.h"
-#include "../../../INCHI_BASE/src/ichi.h"
-#include "../../../INCHI_BASE/src/strutil.h"
-#include "../../../INCHI_BASE/src/util.h"
-#include "../../../INCHI_BASE/src/ichidrp.h"
-#include "../../../INCHI_BASE/src/ichierr.h"
-#include "../../../INCHI_BASE/src/ichimain.h"
-#include "../../../INCHI_BASE/src/extr_ct.h"
-#include "../../../INCHI_BASE/src/ichitaut.h"
-#include "../../../INCHI_BASE/src/ichi_io.h"
-#include "../../../INCHI_BASE/src/ichinorm.h"
-#include "../../../INCHI_BASE/src/ichicant.h"
-#include "../../../INCHI_BASE/src/ichicano.h"
-#include "../../../INCHI_BASE/src/ichicomn.h"
-#include "../../../INCHI_BASE/src/ichimake.h"
-#include "../../../INCHI_BASE/src/ichister.h"
+#include "mode.h"
+#include "ichitime.h"
+#include "incomdef.h"
+#include "ichidrp.h"
+#include "inpdef.h"
+#include "ichi.h"
+#include "strutil.h"
+#include "util.h"
+#include "ichidrp.h"
+#include "ichierr.h"
+#include "ichimain.h"
+#include "extr_ct.h"
+#include "ichitaut.h"
+#include "ichi_io.h"
+#include "ichinorm.h"
+#include "ichicant.h"
+#include "ichicano.h"
+#include "ichicomn.h"
+#include "ichimake.h"
+#include "ichister.h"
 /* */
 #ifdef INCHI_LIB
 #include "ichi_lib.h"
 #endif
-#include "../../../INCHI_BASE/src/ichicomp.h"
+#include "ichicomp.h"
 
 /* for DisplayTheWholeStructure() */
 #define COMP_ORIG_0_MAIN  0x0001
@@ -77,9 +77,9 @@
 #define COMP_ORIG_1_MAIN  0x0010
 #define COMP_ORIG_1_RECN  0x0020
 
-#include "../../../INCHI_BASE/src/ichisize.h"
-#include "../../../INCHI_BASE/src/mode.h"
-#include "../../../INCHI_BASE/src/inchi_api.h"
+#include "ichisize.h"
+#include "mode.h"
+#include "inchi_api.h"
 #include "inchi_dll_a.h" /* not inchi_api.h as it hides internal data types */
 
 
Index: quickjs-src/quickjs/libregexp.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/libregexp.h b/quickjs-src/quickjs/src/libregexp.h
rename from quickjs-src/quickjs/libregexp.h
rename to quickjs-src/quickjs/src/libregexp.h
--- a/quickjs-src/quickjs/libregexp.h	(revision 3b45d155c77bbdfe9177b1e03db830d2aff0b2a8)
+++ b/quickjs-src/quickjs/src/libregexp.h	(date 1714440647082)
@@ -34,9 +34,9 @@
 #define LRE_FLAG_IGNORECASE (1 << 1)
 #define LRE_FLAG_MULTILINE  (1 << 2)
 #define LRE_FLAG_DOTALL     (1 << 3)
-#define LRE_FLAG_UNICODE    (1 << 4)
+#define LRE_FLAG_UTF16      (1 << 4)
 #define LRE_FLAG_STICKY     (1 << 5)
-#define LRE_FLAG_INDICES    (1 << 6) /* Unused by libregexp, just recorded. */
+
 #define LRE_FLAG_NAMED_GROUPS (1 << 7) /* named groups are present in the regexp */
 
 uint8_t *lre_compile(int *plen, char *error_msg, int error_msg_size,
Index: maeparser-src/maeparser/MaeParserConfig.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/maeparser-src/maeparser/MaeParserConfig.hpp b/maeparser-src/maeparser/MaeParserConfig.hpp
--- a/maeparser-src/maeparser/MaeParserConfig.hpp	(revision bfa41f087a92b72370893c9b36758487a18dc6a0)
+++ b/maeparser-src/maeparser/MaeParserConfig.hpp	(date 1714440647086)
@@ -1,21 +1,7 @@
 #pragma once
 
-#ifndef STATIC_MAEPARSER
-
-#ifdef WIN32
-#ifdef IN_MAEPARSER
-#define EXPORT_MAEPARSER __declspec(dllexport)
-#else
-#define EXPORT_MAEPARSER __declspec(dllimport)
-#endif // IN_MAEPARSER
+#include <maeparser_export.hpp>
 
-#else
-
-#define EXPORT_MAEPARSER __attribute__((visibility("default")))
-#endif // WIN32
-
-#else
-
-#define EXPORT_MAEPARSER
-
-#endif // STATIC_MAEPARSER
+#ifndef EXPORT_MAEPARSER
+#define EXPORT_MAEPARSER MAEPARSER_EXPORT
+#endif
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_builder.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_builder.c b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_builder.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_builder.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_builder.c	(date 1714440647086)
@@ -32,9 +32,9 @@
  */
 
 
-#include "../../../../INCHI_BASE/src/mode.h"
-#include "../../../../INCHI_BASE/src/inchi_api.h"
-#include "../../../../INCHI_BASE/src/inpdef.h"
+#include "mode.h"
+#include "inchi_api.h"
+#include "inpdef.h"
 #include "ixa_status.h"
 #include "ixa_mol.h"
 #include <ctype.h>
Index: skia-src/skia/src/core/SkTaskGroup.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/src/core/SkTaskGroup.cpp b/skia-src/skia/src/core/SkTaskGroup.cpp
--- a/skia-src/skia/src/core/SkTaskGroup.cpp	(revision 3d4e45907f9b239a54957001d619d2d4a6ca06b4)
+++ b/skia-src/skia/src/core/SkTaskGroup.cpp	(date 1714440647086)
@@ -24,7 +24,7 @@
     // TODO: I really thought we had some sort of more clever chunking logic.
     fPending.fetch_add(+N, std::memory_order_relaxed);
     for (int i = 0; i < N; i++) {
-        fExecutor.add([=] {
+        fExecutor.add([=, this] {
             fn(i);
             fPending.fetch_add(-1, std::memory_order_release);
         });
Index: quickjs-src/quickjs/cutils.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/cutils.c b/quickjs-src/quickjs/src/cutils.c
rename from quickjs-src/quickjs/cutils.c
rename to quickjs-src/quickjs/src/cutils.c
--- a/quickjs-src/quickjs/cutils.c	(revision 3b45d155c77bbdfe9177b1e03db830d2aff0b2a8)
+++ b/quickjs-src/quickjs/src/cutils.c	(date 1714440647082)
@@ -140,7 +140,7 @@
         if (dbuf_realloc(s, s->size + len))
             return -1;
     }
-    memcpy_no_ub(s->buf + s->size, data, len);
+    memcpy(s->buf + s->size, data, len);
     s->size += len;
     return 0;
 }
@@ -166,8 +166,7 @@
     return dbuf_put(s, (const uint8_t *)str, strlen(str));
 }
 
-int __attribute__((format(printf, 2, 3))) dbuf_printf(DynBuf *s,
-                                                      const char *fmt, ...)
+int PLATFORM_PRINTF_LIKE(2, 3) dbuf_printf(DynBuf *s, const char *fmt, ...)
 {
     va_list ap;
     char buf[128];
Index: inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_b.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_b.c b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_b.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_b.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_b.c	(date 1714440647086)
@@ -42,22 +42,22 @@
 #include <float.h>
 #include <math.h>
 
-#include "../../../INCHI_BASE/src/mode.h"
-#include "../../../INCHI_BASE/src/inchi_api.h"
-#include "../../../INCHI_BASE/src/incomdef.h"
-#include "../../../INCHI_BASE/src/ichidrp.h"
-#include "../../../INCHI_BASE/src/inpdef.h"
-#include "../../../INCHI_BASE/src/ichi.h"
-#include "../../../INCHI_BASE/src/strutil.h"
-#include "../../../INCHI_BASE/src/util.h"
-#include "../../../INCHI_BASE/src/ichierr.h"
-#include "../../../INCHI_BASE/src/ichimain.h"
-#include "../../../INCHI_BASE/src/extr_ct.h"
-#include "../../../INCHI_BASE/src/ichi_io.h"
-#include "../../../INCHI_BASE/src/ichicomp.h"
-#include "../../../INCHI_BASE/src/ichitime.h"
-#include "../../../INCHI_BASE/src/ichicant.h"
-#include "../../../INCHI_BASE/src/readinch.h"
+#include "mode.h"
+#include "inchi_api.h"
+#include "incomdef.h"
+#include "ichidrp.h"
+#include "inpdef.h"
+#include "ichi.h"
+#include "strutil.h"
+#include "util.h"
+#include "ichierr.h"
+#include "ichimain.h"
+#include "extr_ct.h"
+#include "ichi_io.h"
+#include "ichicomp.h"
+#include "ichitime.h"
+#include "ichicant.h"
+#include "readinch.h"
 
 #include "inchi_dll.h"
 #include "inchi_dll_b.h"
Index: skia-src/skia/include/private/base/SkAttributes.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/include/private/base/SkAttributes.h b/skia-src/skia/include/private/base/SkAttributes.h
--- a/skia-src/skia/include/private/base/SkAttributes.h	(revision 3d4e45907f9b239a54957001d619d2d4a6ca06b4)
+++ b/skia-src/skia/include/private/base/SkAttributes.h	(date 1714440647086)
@@ -24,7 +24,7 @@
  *     SK_ALWAYS_INLINE void someMethod() { ... }   // should always be inlined
  */
 #if !defined(SK_ALWAYS_INLINE)
-#  if defined(SK_BUILD_FOR_WIN)
+#  if defined(SK_BUILD_FOR_WIN) && !defined(__MINGW32__)
 #    define SK_ALWAYS_INLINE __forceinline
 #  else
 #    define SK_ALWAYS_INLINE SK_ATTRIBUTE(always_inline) inline
Index: quickjs-src/quickjs/libregexp.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/libregexp.c b/quickjs-src/quickjs/src/libregexp.c
rename from quickjs-src/quickjs/libregexp.c
rename to quickjs-src/quickjs/src/libregexp.c
--- a/quickjs-src/quickjs/libregexp.c	(revision 3b45d155c77bbdfe9177b1e03db830d2aff0b2a8)
+++ b/quickjs-src/quickjs/src/libregexp.c	(date 1714440647082)
@@ -34,6 +34,9 @@
 /*
   TODO:
 
+  - Add full unicode canonicalize rules for character ranges (not
+    really useful but needed for exact "ignorecase" compatibility).
+
   - Add a lock step execution mode (=linear time execution guaranteed)
     when the regular expression is "simple" i.e. no backreference nor
     complicated lookahead. The opcodes are designed for this execution
@@ -66,7 +69,7 @@
     const uint8_t *buf_end;
     const uint8_t *buf_start;
     int re_flags;
-    BOOL is_unicode;
+    BOOL is_utf16;
     BOOL ignore_case;
     BOOL dotall;
     int capture_count;
@@ -100,7 +103,6 @@
 #define RE_HEADER_FLAGS         0
 #define RE_HEADER_CAPTURE_COUNT 1
 #define RE_HEADER_STACK_SIZE    2
-#define RE_HEADER_BYTECODE_LEN  3
 
 #define RE_HEADER_LEN 7
 
@@ -118,6 +120,33 @@
     return 0;
 }
 
+/* canonicalize with the specific JS regexp rules */
+static uint32_t lre_canonicalize(uint32_t c, BOOL is_utf16)
+{
+    uint32_t res[LRE_CC_RES_LEN_MAX];
+    int len;
+    if (is_utf16) {
+        if (likely(c < 128)) {
+            if (c >= 'A' && c <= 'Z')
+                c = c - 'A' + 'a';
+        } else {
+            lre_case_conv(res, c, 2);
+            c = res[0];
+        }
+    } else {
+        if (likely(c < 128)) {
+            if (c >= 'a' && c <= 'z')
+                c = c - 'a' + 'A';
+        } else {
+            /* legacy regexp: to upper case if single char >= 128 */
+            len = lre_case_conv(res, c, FALSE);
+            if (len == 1 && res[0] >= 128)
+                c = res[0];
+        }
+    }
+    return c;
+}
+
 static const uint16_t char_range_d[] = {
     1,
     0x0030, 0x0039 + 1,
@@ -216,6 +245,31 @@
     return -1;
 }
 
+static int cr_canonicalize(CharRange *cr)
+{
+    CharRange a;
+    uint32_t pt[2];
+    int i, ret;
+
+    cr_init(&a, cr->mem_opaque, lre_realloc);
+    pt[0] = 'a';
+    pt[1] = 'z' + 1;
+    ret = cr_op(&a, cr->points, cr->len, pt, 2, CR_OP_INTER);
+    if (ret)
+        goto fail;
+    /* convert to upper case */
+    /* XXX: the generic unicode case would be much more complicated
+       and not really useful */
+    for(i = 0; i < a.len; i++) {
+        a.points[i] += 'A' - 'a';
+    }
+    /* Note: for simplicity we keep the lower case ranges */
+    ret = cr_union1(cr, a.points, a.len);
+ fail:
+    cr_free(&a);
+    return ret;
+}
+
 #ifdef DUMP_REOP
 static __maybe_unused void lre_dump_bytecode(const uint8_t *buf,
                                                      int buf_len)
@@ -225,16 +279,16 @@
 
     assert(buf_len >= RE_HEADER_LEN);
 
-    re_flags = lre_get_flags(buf);
-    bc_len = get_u32(buf + RE_HEADER_BYTECODE_LEN);
+    re_flags=  buf[0];
+    bc_len = get_u32(buf + 3);
     assert(bc_len + RE_HEADER_LEN <= buf_len);
     printf("flags: 0x%x capture_count=%d stack_size=%d\n",
-           re_flags, buf[RE_HEADER_CAPTURE_COUNT], buf[RE_HEADER_STACK_SIZE]);
+           re_flags, buf[1], buf[2]);
     if (re_flags & LRE_FLAG_NAMED_GROUPS) {
         const char *p;
         p = (char *)buf + RE_HEADER_LEN + bc_len;
         printf("named groups: ");
-        for(i = 1; i < buf[RE_HEADER_CAPTURE_COUNT]; i++) {
+        for(i = 1; i < buf[1]; i++) {
             if (i != 1)
                 printf(",");
             printf("<%s>", p);
@@ -281,6 +335,7 @@
         case REOP_loop:
         case REOP_lookahead:
         case REOP_negative_lookahead:
+        case REOP_bne_char_pos:
             val = get_u32(buf + pos + 1);
             val += (pos + 5);
             printf(" %u", val);
@@ -372,7 +427,7 @@
     dbuf_put_u16(&s->byte_code, val);
 }
 
-static int __attribute__((format(printf, 2, 3))) re_parse_error(REParseState *s, const char *fmt, ...)
+static int PLATFORM_PRINTF_LIKE(2, 3) re_parse_error(REParseState *s, const char *fmt, ...)
 {
     va_list ap;
     va_start(ap, fmt);
@@ -495,7 +550,7 @@
                     }
                     c = (c << 4) | h;
                 }
-                if (is_hi_surrogate(c) &&
+                if (c >= 0xd800 && c < 0xdc00 &&
                     allow_utf16 == 2 && p[0] == '\\' && p[1] == 'u') {
                     /* convert an escaped surrogate pair into a
                        unicode char */
@@ -506,9 +561,9 @@
                             break;
                         c1 = (c1 << 4) | h;
                     }
-                    if (i == 4 && is_lo_surrogate(c1)) {
+                    if (i == 4 && c1 >= 0xdc00 && c1 < 0xe000) {
                         p += 6;
-                        c = from_surrogate(c, c1);
+                        c = (((c & 0x3ff) << 10) | (c1 & 0x3ff)) + 0x10000;
                     }
                 }
             }
@@ -697,10 +752,10 @@
             if ((c >= 'a' && c <= 'z') ||
                 (c >= 'A' && c <= 'Z') ||
                 (((c >= '0' && c <= '9') || c == '_') &&
-                 inclass && !s->is_unicode)) {   /* Annex B.1.4 */
+                 inclass && !s->is_utf16)) {   /* Annex B.1.4 */
                 c &= 0x1f;
                 p++;
-            } else if (s->is_unicode) {
+            } else if (s->is_utf16) {
                 goto invalid_escape;
             } else {
                 /* otherwise return '\' and 'c' */
@@ -711,7 +766,7 @@
 #ifdef CONFIG_ALL_UNICODE
         case 'p':
         case 'P':
-            if (s->is_unicode) {
+            if (s->is_utf16) {
                 if (parse_unicode_property(s, cr, &p, (c == 'P')))
                     return -1;
                 c = CLASS_RANGE_BASE;
@@ -721,14 +776,14 @@
 #endif
         default:
             p--;
-            ret = lre_parse_escape(&p, s->is_unicode * 2);
+            ret = lre_parse_escape(&p, s->is_utf16 * 2);
             if (ret >= 0) {
                 c = ret;
             } else {
                 if (ret == -2 && *p != '\0' && strchr("^$\\.*+?()[]{}|/", *p)) {
                     /* always valid to escape these characters */
                     goto normal_char;
-                } else if (s->is_unicode) {
+                } else if (s->is_utf16) {
                 invalid_escape:
                     return re_parse_error(s, "invalid escape sequence in regular expression");
                 } else {
@@ -750,7 +805,7 @@
         /* normal char */
         if (c >= 128) {
             c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
-            if ((unsigned)c > 0xffff && !s->is_unicode) {
+            if ((unsigned)c > 0xffff && !s->is_utf16) {
                 /* XXX: should handle non BMP-1 code points */
                 return re_parse_error(s, "malformed unicode char");
             }
@@ -812,13 +867,11 @@
     cr_init(cr, s->opaque, lre_realloc);
     p = *pp;
     p++;    /* skip '[' */
-
     invert = FALSE;
     if (*p == '^') {
         p++;
         invert = TRUE;
     }
-
     for(;;) {
         if (*p == ']')
             break;
@@ -828,7 +881,7 @@
         if (*p == '-' && p[1] != ']') {
             const uint8_t *p0 = p + 1;
             if (c1 >= CLASS_RANGE_BASE) {
-                if (s->is_unicode) {
+                if (s->is_utf16) {
                     cr_free(cr1);
                     goto invalid_class_range;
                 }
@@ -840,7 +893,7 @@
                 goto fail;
             if (c2 >= CLASS_RANGE_BASE) {
                 cr_free(cr1);
-                if (s->is_unicode) {
+                if (s->is_utf16) {
                     goto invalid_class_range;
                 }
                 /* Annex B: match '-' character */
@@ -869,7 +922,7 @@
         }
     }
     if (s->ignore_case) {
-        if (cr_regexp_canonicalize(cr, s->is_unicode))
+        if (cr_canonicalize(cr))
             goto memory_error;
     }
     if (invert) {
@@ -890,17 +943,22 @@
 }
 
 /* Return:
-   - true if the opcodes may not advance the char pointer
-   - false if the opcodes always advance the char pointer
+   1 if the opcodes in bc_buf[] always advance the character pointer.
+   0 if the character pointer may not be advanced.
+   -1 if the code may depend on side effects of its previous execution (backreference)
 */
-static BOOL re_need_check_advance(const uint8_t *bc_buf, int bc_buf_len)
+static int re_check_advance(const uint8_t *bc_buf, int bc_buf_len)
 {
-    int pos, opcode, len;
-    uint32_t val;
-    BOOL ret;
+    int pos, opcode, ret, len, i;
+    uint32_t val, last;
+    BOOL has_back_reference;
+    uint8_t capture_bitmap[CAPTURE_COUNT_MAX];
 
-    ret = TRUE;
+    ret = -2; /* not known yet */
     pos = 0;
+    has_back_reference = FALSE;
+    memset(capture_bitmap, 0, sizeof(capture_bitmap));
+
     while (pos < bc_buf_len) {
         opcode = bc_buf[pos];
         len = reopcode_info[opcode].size;
@@ -918,7 +976,8 @@
         case REOP_dot:
         case REOP_any:
         simple_char:
-            ret = FALSE;
+            if (ret == -2)
+                ret = 1;
             break;
         case REOP_line_start:
         case REOP_line_end:
@@ -932,16 +991,41 @@
             break;
         case REOP_save_start:
         case REOP_save_end:
+            val = bc_buf[pos + 1];
+            capture_bitmap[val] |= 1;
+            break;
         case REOP_save_reset:
+            {
+                val = bc_buf[pos + 1];
+                last = bc_buf[pos + 2];
+                while (val < last)
+                    capture_bitmap[val++] |= 1;
+            }
+            break;
         case REOP_back_reference:
         case REOP_backward_back_reference:
+            val = bc_buf[pos + 1];
+            capture_bitmap[val] |= 2;
+            has_back_reference = TRUE;
             break;
         default:
-            /* safe behavior: we cannot predict the outcome */
-            return TRUE;
+            /* safe behvior: we cannot predict the outcome */
+            if (ret == -2)
+                ret = 0;
+            break;
         }
         pos += len;
     }
+    if (has_back_reference) {
+        /* check if there is back reference which references a capture
+           made in the some code */
+        for(i = 0; i < CAPTURE_COUNT_MAX; i++) {
+            if (capture_bitmap[i] == 3)
+                return -1;
+        }
+    }
+    if (ret == -2)
+        ret = 0;
     return ret;
 }
 
@@ -987,10 +1071,11 @@
 }
 
 /* '*pp' is the first char after '<' */
-static int re_parse_group_name(char *buf, int buf_size, const uint8_t **pp)
+static int re_parse_group_name(char *buf, int buf_size,
+                               const uint8_t **pp, BOOL is_utf16)
 {
-    const uint8_t *p, *p1;
-    uint32_t c, d;
+    const uint8_t *p;
+    uint32_t c;
     char *q;
 
     p = *pp;
@@ -1001,18 +1086,11 @@
             p++;
             if (*p != 'u')
                 return -1;
-            c = lre_parse_escape(&p, 2); // accept surrogate pairs
+            c = lre_parse_escape(&p, is_utf16 * 2);
         } else if (c == '>') {
             break;
         } else if (c >= 128) {
             c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
-            if (is_hi_surrogate(c)) {
-                d = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p1);
-                if (is_lo_surrogate(d)) {
-                    c = from_surrogate(c, d);
-                    p = p1;
-                }
-            }
         } else {
             p++;
         }
@@ -1062,7 +1140,8 @@
                     /* potential named capture */
                     if (capture_name) {
                         p += 3;
-                        if (re_parse_group_name(name, sizeof(name), &p) == 0) {
+                        if (re_parse_group_name(name, sizeof(name), &p,
+                                                s->is_utf16) == 0) {
                             if (!strcmp(name, capture_name))
                                 return capture_index;
                         }
@@ -1117,10 +1196,9 @@
     size_t len, name_len;
     int capture_index;
 
+    name_len = strlen(name);
     p = (char *)s->group_names.buf;
-    if (!p) return -1;
     buf_end = (char *)s->group_names.buf + s->group_names.size;
-    name_len = strlen(name);
     capture_index = 1;
     while (p < buf_end) {
         len = strlen(p);
@@ -1165,7 +1243,7 @@
             re_emit_op(s, REOP_prev);
         break;
     case '{':
-        if (s->is_unicode) {
+        if (s->is_utf16) {
             return re_parse_error(s, "syntax error");
         } else if (!is_digit(p[1])) {
             /* Annex B: we accept '{' not followed by digits as a
@@ -1217,7 +1295,7 @@
             lookahead:
                 /* Annex B allows lookahead to be used as an atom for
                    the quantifiers */
-                if (!s->is_unicode && !is_backward_lookahead)  {
+                if (!s->is_utf16 && !is_backward_lookahead)  {
                     last_atom_start = s->byte_code.size;
                     last_capture_count = s->capture_count;
                 }
@@ -1236,7 +1314,7 @@
             } else if (p[2] == '<') {
                 p += 3;
                 if (re_parse_group_name(s->u.tmp_buf, sizeof(s->u.tmp_buf),
-                                        &p)) {
+                                        &p, s->is_utf16)) {
                     return re_parse_error(s, "invalid group name");
                 }
                 if (find_group_name(s, s->u.tmp_buf) > 0) {
@@ -1293,15 +1371,15 @@
                     /* annex B: we tolerate invalid group names in non
                        unicode mode if there is no named capture
                        definition */
-                    if (s->is_unicode || re_has_named_captures(s))
+                    if (s->is_utf16 || re_has_named_captures(s))
                         return re_parse_error(s, "expecting group name");
                     else
                         goto parse_class_atom;
                 }
                 p1 += 3;
                 if (re_parse_group_name(s->u.tmp_buf, sizeof(s->u.tmp_buf),
-                                        &p1)) {
-                    if (s->is_unicode || re_has_named_captures(s))
+                                        &p1, s->is_utf16)) {
+                    if (s->is_utf16 || re_has_named_captures(s))
                         return re_parse_error(s, "invalid group name");
                     else
                         goto parse_class_atom;
@@ -1312,7 +1390,7 @@
                        after (inefficient, but hopefully not common */
                     c = re_parse_captures(s, &dummy_res, s->u.tmp_buf);
                     if (c < 0) {
-                        if (s->is_unicode || re_has_named_captures(s))
+                        if (s->is_utf16 || re_has_named_captures(s))
                             return re_parse_error(s, "group name not defined");
                         else
                             goto parse_class_atom;
@@ -1324,7 +1402,7 @@
         case '0':
             p += 2;
             c = 0;
-            if (s->is_unicode) {
+            if (s->is_utf16) {
                 if (is_digit(*p)) {
                     return re_parse_error(s, "invalid decimal escape in regular expression");
                 }
@@ -1346,7 +1424,7 @@
 
                 c = parse_digits(&p, FALSE);
                 if (c < 0 || (c >= s->capture_count && c >= re_count_captures(s))) {
-                    if (!s->is_unicode) {
+                    if (!s->is_utf16) {
                         /* Annex B.1.4: accept legacy octal */
                         p = q;
                         if (*p <= '7') {
@@ -1388,7 +1466,7 @@
         break;
     case ']':
     case '}':
-        if (s->is_unicode)
+        if (s->is_utf16)
             return re_parse_error(s, "syntax error");
         goto parse_class_atom;
     default:
@@ -1410,7 +1488,7 @@
                 return -1;
         } else {
             if (s->ignore_case)
-                c = lre_canonicalize(c, s->is_unicode);
+                c = lre_canonicalize(c, s->is_utf16);
             if (c <= 0xffff)
                 re_emit_op_u16(s, REOP_char, c);
             else
@@ -1446,7 +1524,7 @@
                 /* As an extension (see ES6 annex B), we accept '{' not
                    followed by digits as a normal atom */
                 if (!is_digit(p[1])) {
-                    if (s->is_unicode)
+                    if (s->is_utf16)
                         goto invalid_quant_count;
                     break;
                 }
@@ -1465,7 +1543,7 @@
                         quant_max = INT32_MAX; /* infinity */
                     }
                 }
-                if (*p != '}' && !s->is_unicode) {
+                if (*p != '}' && !s->is_utf16) {
                     /* Annex B: normal atom if invalid '{' syntax */
                     p = p1;
                     break;
@@ -1513,12 +1591,8 @@
 
                 if (dbuf_error(&s->byte_code))
                     goto out_of_memory;
-                /* the spec tells that if there is no advance when
-                   running the atom after the first quant_min times,
-                   then there is no match. We remove this test when we
-                   are sure the atom always advances the position. */
-                add_zero_advance_check = re_need_check_advance(s->byte_code.buf + last_atom_start,
-                                                               s->byte_code.size - last_atom_start);
+                add_zero_advance_check = (re_check_advance(s->byte_code.buf + last_atom_start,
+                                                           s->byte_code.size - last_atom_start) == 0);
             } else {
                 add_zero_advance_check = FALSE;
             }
@@ -1538,34 +1612,38 @@
                     }
                     if (quant_max == 0) {
                         s->byte_code.size = last_atom_start;
-                    } else if (quant_max == 1 || quant_max == INT32_MAX) {
-                        BOOL has_goto = (quant_max == INT32_MAX);
+                    } else if (quant_max == 1) {
+                        if (dbuf_insert(&s->byte_code, last_atom_start, 5))
+                            goto out_of_memory;
+                        s->byte_code.buf[last_atom_start] = REOP_split_goto_first +
+                            greedy;
+                        put_u32(s->byte_code.buf + last_atom_start + 1, len);
+                    } else if (quant_max == INT32_MAX) {
                         if (dbuf_insert(&s->byte_code, last_atom_start, 5 + add_zero_advance_check))
                             goto out_of_memory;
                         s->byte_code.buf[last_atom_start] = REOP_split_goto_first +
                             greedy;
                         put_u32(s->byte_code.buf + last_atom_start + 1,
-                                len + 5 * has_goto + add_zero_advance_check * 2);
+                                len + 5 + add_zero_advance_check);
                         if (add_zero_advance_check) {
+                            /* avoid infinite loop by stoping the
+                               recursion if no advance was made in the
+                               atom (only works if the atom has no
+                               side effect) */
                             s->byte_code.buf[last_atom_start + 1 + 4] = REOP_push_char_pos;
-                            re_emit_op(s, REOP_check_advance);
-                        }
-                        if (has_goto)
+                            re_emit_goto(s, REOP_bne_char_pos, last_atom_start);
+                        } else {
                             re_emit_goto(s, REOP_goto, last_atom_start);
+                        }
                     } else {
-                        if (dbuf_insert(&s->byte_code, last_atom_start, 10 + add_zero_advance_check))
+                        if (dbuf_insert(&s->byte_code, last_atom_start, 10))
                             goto out_of_memory;
                         pos = last_atom_start;
                         s->byte_code.buf[pos++] = REOP_push_i32;
                         put_u32(s->byte_code.buf + pos, quant_max);
                         pos += 4;
                         s->byte_code.buf[pos++] = REOP_split_goto_first + greedy;
-                        put_u32(s->byte_code.buf + pos, len + 5 + add_zero_advance_check * 2);
-                        pos += 4;
-                        if (add_zero_advance_check) {
-                            s->byte_code.buf[pos++] = REOP_push_char_pos;
-                            re_emit_op(s, REOP_check_advance);
-                        }
+                        put_u32(s->byte_code.buf + pos, len + 5);
                         re_emit_goto(s, REOP_loop, last_atom_start + 5);
                         re_emit_op(s, REOP_drop);
                     }
@@ -1589,25 +1667,22 @@
                     if (quant_max == INT32_MAX) {
                         pos = s->byte_code.size;
                         re_emit_op_u32(s, REOP_split_goto_first + greedy,
-                                       len + 5 + add_zero_advance_check * 2);
+                                       len + 5 + add_zero_advance_check);
                         if (add_zero_advance_check)
                             re_emit_op(s, REOP_push_char_pos);
                         /* copy the atom */
                         dbuf_put_self(&s->byte_code, last_atom_start, len);
                         if (add_zero_advance_check)
-                            re_emit_op(s, REOP_check_advance);
-                        re_emit_goto(s, REOP_goto, pos);
+                            re_emit_goto(s, REOP_bne_char_pos, pos);
+                        else
+                            re_emit_goto(s, REOP_goto, pos);
                     } else if (quant_max > quant_min) {
                         re_emit_op_u32(s, REOP_push_i32, quant_max - quant_min);
                         pos = s->byte_code.size;
-                        re_emit_op_u32(s, REOP_split_goto_first + greedy,
-                                       len + 5 + add_zero_advance_check * 2);
-                        if (add_zero_advance_check)
-                            re_emit_op(s, REOP_push_char_pos);
+                        re_emit_op_u32(s, REOP_split_goto_first + greedy, len + 5);
                         /* copy the atom */
                         dbuf_put_self(&s->byte_code, last_atom_start, len);
-                        if (add_zero_advance_check)
-                            re_emit_op(s, REOP_check_advance);
+
                         re_emit_goto(s, REOP_loop, pos);
                         re_emit_op(s, REOP_drop);
                     }
@@ -1721,7 +1796,7 @@
             }
             break;
         case REOP_drop:
-        case REOP_check_advance:
+        case REOP_bne_char_pos:
             assert(stack_size > 0);
             stack_size--;
             break;
@@ -1757,7 +1832,7 @@
     s->buf_end = s->buf_ptr + buf_len;
     s->buf_start = s->buf_ptr;
     s->re_flags = re_flags;
-    s->is_unicode = ((re_flags & LRE_FLAG_UNICODE) != 0);
+    s->is_utf16 = ((re_flags & LRE_FLAG_UTF16) != 0);
     is_sticky = ((re_flags & LRE_FLAG_STICKY) != 0);
     s->ignore_case = ((re_flags & LRE_FLAG_IGNORECASE) != 0);
     s->dotall = ((re_flags & LRE_FLAG_DOTALL) != 0);
@@ -1815,8 +1890,7 @@
 
     s->byte_code.buf[RE_HEADER_CAPTURE_COUNT] = s->capture_count;
     s->byte_code.buf[RE_HEADER_STACK_SIZE] = stack_size;
-    put_u32(s->byte_code.buf + RE_HEADER_BYTECODE_LEN,
-            s->byte_code.size - RE_HEADER_LEN);
+    put_u32(s->byte_code.buf + 3, s->byte_code.size - RE_HEADER_LEN);
 
     /* add the named groups if needed */
     if (s->group_names.size > (s->capture_count - 1)) {
@@ -1847,86 +1921,93 @@
             (c == '_'));
 }
 
-#define GET_CHAR(c, cptr, cbuf_end, cbuf_type)                          \
+#define GET_CHAR(c, cptr, cbuf_end)                                     \
     do {                                                                \
         if (cbuf_type == 0) {                                           \
             c = *cptr++;                                                \
         } else {                                                        \
-            const uint16_t *_p = (const uint16_t *)cptr;                \
-            const uint16_t *_end = (const uint16_t *)cbuf_end;          \
-            c = *_p++;                                                  \
-            if (is_hi_surrogate(c) && cbuf_type == 2) {                 \
-                if (_p < _end && is_lo_surrogate(*_p)) {                \
-                    c = from_surrogate(c, *_p++);                       \
+            uint32_t __c1;                                              \
+            c = *(uint16_t *)cptr;                                      \
+            cptr += 2;                                                  \
+            if (c >= 0xd800 && c < 0xdc00 &&                            \
+                cbuf_type == 2 && cptr < cbuf_end) {                    \
+                __c1 = *(uint16_t *)cptr;                               \
+                if (__c1 >= 0xdc00 && __c1 < 0xe000) {                  \
+                    c = (((c & 0x3ff) << 10) | (__c1 & 0x3ff)) + 0x10000; \
+                    cptr += 2;                                          \
                 }                                                       \
             }                                                           \
-            cptr = (const void *)_p;                                    \
         }                                                               \
     } while (0)
 
-#define PEEK_CHAR(c, cptr, cbuf_end, cbuf_type)                         \
-    do {                                                                \
-        if (cbuf_type == 0) {                                           \
-            c = cptr[0];                                                \
-        } else {                                                        \
-            const uint16_t *_p = (const uint16_t *)cptr;                \
-            const uint16_t *_end = (const uint16_t *)cbuf_end;          \
-            c = *_p++;                                                  \
-            if (is_hi_surrogate(c) && cbuf_type == 2) {                 \
-                if (_p < _end && is_lo_surrogate(*_p)) {                \
-                    c = from_surrogate(c, *_p);                         \
+#define PEEK_CHAR(c, cptr, cbuf_end)             \
+    do {                                         \
+        if (cbuf_type == 0) {                    \
+            c = cptr[0];                         \
+        } else {                                 \
+            uint32_t __c1;                                              \
+            c = ((uint16_t *)cptr)[0];                                  \
+            if (c >= 0xd800 && c < 0xdc00 &&                            \
+                cbuf_type == 2 && (cptr + 2) < cbuf_end) {              \
+                __c1 = ((uint16_t *)cptr)[1];                           \
+                if (__c1 >= 0xdc00 && __c1 < 0xe000) {                  \
+                    c = (((c & 0x3ff) << 10) | (__c1 & 0x3ff)) + 0x10000; \
                 }                                                       \
             }                                                           \
-        }                                                               \
+        }                                        \
     } while (0)
 
-#define PEEK_PREV_CHAR(c, cptr, cbuf_start, cbuf_type)                  \
-    do {                                                                \
-        if (cbuf_type == 0) {                                           \
-            c = cptr[-1];                                               \
-        } else {                                                        \
-            const uint16_t *_p = (const uint16_t *)cptr - 1;            \
-            const uint16_t *_start = (const uint16_t *)cbuf_start;      \
-            c = *_p;                                                    \
-            if (is_lo_surrogate(c) && cbuf_type == 2) {                 \
-                if (_p > _start && is_hi_surrogate(_p[-1])) {           \
-                    c = from_surrogate(*--_p, c);                       \
+#define PEEK_PREV_CHAR(c, cptr, cbuf_start)                 \
+    do {                                         \
+        if (cbuf_type == 0) {                    \
+            c = cptr[-1];                        \
+        } else {                                 \
+            uint32_t __c1;                                              \
+            c = ((uint16_t *)cptr)[-1];                                 \
+            if (c >= 0xdc00 && c < 0xe000 &&                            \
+                cbuf_type == 2 && (cptr - 4) >= cbuf_start) {              \
+                __c1 = ((uint16_t *)cptr)[-2];                          \
+                if (__c1 >= 0xd800 && __c1 < 0xdc00 ) {                 \
+                    c = (((__c1 & 0x3ff) << 10) | (c & 0x3ff)) + 0x10000; \
                 }                                                       \
             }                                                           \
         }                                                               \
     } while (0)
 
-#define GET_PREV_CHAR(c, cptr, cbuf_start, cbuf_type)                   \
-    do {                                                                \
-        if (cbuf_type == 0) {                                           \
-            cptr--;                                                     \
-            c = cptr[0];                                                \
-        } else {                                                        \
-            const uint16_t *_p = (const uint16_t *)cptr - 1;            \
-            const uint16_t *_start = (const uint16_t *)cbuf_start;      \
-            c = *_p;                                                    \
-            if (is_lo_surrogate(c) && cbuf_type == 2) {                 \
-                if (_p > _start && is_hi_surrogate(_p[-1])) {           \
-                    c = from_surrogate(*--_p, c);                       \
+#define GET_PREV_CHAR(c, cptr, cbuf_start)       \
+    do {                                         \
+        if (cbuf_type == 0) {                    \
+            cptr--;                              \
+            c = cptr[0];                         \
+        } else {                                 \
+            uint32_t __c1;                                              \
+            cptr -= 2;                                                  \
+            c = ((uint16_t *)cptr)[0];                                 \
+            if (c >= 0xdc00 && c < 0xe000 &&                            \
+                cbuf_type == 2 && cptr > cbuf_start) {                  \
+                __c1 = ((uint16_t *)cptr)[-1];                          \
+                if (__c1 >= 0xd800 && __c1 < 0xdc00 ) {                 \
+                    cptr -= 2;                                          \
+                    c = (((__c1 & 0x3ff) << 10) | (c & 0x3ff)) + 0x10000; \
                 }                                                       \
             }                                                           \
-            cptr = (const void *)_p;                                    \
         }                                                               \
     } while (0)
 
-#define PREV_CHAR(cptr, cbuf_start, cbuf_type)                          \
-    do {                                                                \
-        if (cbuf_type == 0) {                                           \
-            cptr--;                                                     \
-        } else {                                                        \
-            const uint16_t *_p = (const uint16_t *)cptr - 1;            \
-            const uint16_t *_start = (const uint16_t *)cbuf_start;      \
-            if (is_lo_surrogate(*_p) && cbuf_type == 2) {               \
-                if (_p > _start && is_hi_surrogate(_p[-1])) {           \
-                    --_p;                                               \
+#define PREV_CHAR(cptr, cbuf_start)       \
+    do {                                  \
+        if (cbuf_type == 0) {             \
+            cptr--;                       \
+        } else {                          \
+            cptr -= 2;                          \
+            if (cbuf_type == 2) {                                       \
+                c = ((uint16_t *)cptr)[0];                              \
+                if (c >= 0xdc00 && c < 0xe000 && cptr > cbuf_start) {   \
+                    c = ((uint16_t *)cptr)[-1];                         \
+                    if (c >= 0xd800 && c < 0xdc00)                      \
+                        cptr -= 2;                                      \
                 }                                                       \
             }                                                           \
-            cptr = (const void *)_p;                                    \
         }                                                               \
     } while (0)
 
@@ -1957,7 +2038,7 @@
     int stack_size_max;
     BOOL multi_line;
     BOOL ignore_case;
-    BOOL is_unicode;
+    BOOL is_utf16;
     void *opaque; /* used for stack overflow check */
 
     size_t state_size;
@@ -2066,7 +2147,7 @@
                             /* go backward */
                             char_count = get_u32(pc + 12);
                             for(i = 0; i < char_count; i++) {
-                                PREV_CHAR(cptr, s->cbuf, cbuf_type);
+                                PREV_CHAR(cptr, s->cbuf);
                             }
                             pc = (pc + 16) + (int)get_u32(pc);
                             rs->cptr = cptr;
@@ -2101,9 +2182,9 @@
         test_char:
             if (cptr >= cbuf_end)
                 goto no_match;
-            GET_CHAR(c, cptr, cbuf_end, cbuf_type);
+            GET_CHAR(c, cptr, cbuf_end);
             if (s->ignore_case) {
-                c = lre_canonicalize(c, s->is_unicode);
+                c = lre_canonicalize(c, s->is_utf16);
             }
             if (val != c)
                 goto no_match;
@@ -2148,7 +2229,7 @@
                 break;
             if (!s->multi_line)
                 goto no_match;
-            PEEK_PREV_CHAR(c, cptr, s->cbuf, cbuf_type);
+            PEEK_PREV_CHAR(c, cptr, s->cbuf);
             if (!is_line_terminator(c))
                 goto no_match;
             break;
@@ -2157,21 +2238,21 @@
                 break;
             if (!s->multi_line)
                 goto no_match;
-            PEEK_CHAR(c, cptr, cbuf_end, cbuf_type);
+            PEEK_CHAR(c, cptr, cbuf_end);
             if (!is_line_terminator(c))
                 goto no_match;
             break;
         case REOP_dot:
             if (cptr == cbuf_end)
                 goto no_match;
-            GET_CHAR(c, cptr, cbuf_end, cbuf_type);
+            GET_CHAR(c, cptr, cbuf_end);
             if (is_line_terminator(c))
                 goto no_match;
             break;
         case REOP_any:
             if (cptr == cbuf_end)
                 goto no_match;
-            GET_CHAR(c, cptr, cbuf_end, cbuf_type);
+            GET_CHAR(c, cptr, cbuf_end);
             break;
         case REOP_save_start:
         case REOP_save_end:
@@ -2211,9 +2292,11 @@
         case REOP_push_char_pos:
             stack[stack_len++] = (uintptr_t)cptr;
             break;
-        case REOP_check_advance:
-            if (stack[--stack_len] == (uintptr_t)cptr)
-                goto no_match;
+        case REOP_bne_char_pos:
+            val = get_u32(pc);
+            pc += 4;
+            if (stack[--stack_len] != (uintptr_t)cptr)
+                pc += (int)val;
             break;
         case REOP_word_boundary:
         case REOP_not_word_boundary:
@@ -2223,14 +2306,14 @@
                 if (cptr == s->cbuf) {
                     v1 = FALSE;
                 } else {
-                    PEEK_PREV_CHAR(c, cptr, s->cbuf, cbuf_type);
+                    PEEK_PREV_CHAR(c, cptr, s->cbuf);
                     v1 = is_word_char(c);
                 }
                 /* current char */
                 if (cptr >= cbuf_end) {
                     v2 = FALSE;
                 } else {
-                    PEEK_CHAR(c, cptr, cbuf_end, cbuf_type);
+                    PEEK_CHAR(c, cptr, cbuf_end);
                     v2 = is_word_char(c);
                 }
                 if (v1 ^ v2 ^ (REOP_not_word_boundary - opcode))
@@ -2255,11 +2338,11 @@
                     while (cptr1 < cptr1_end) {
                         if (cptr >= cbuf_end)
                             goto no_match;
-                        GET_CHAR(c1, cptr1, cptr1_end, cbuf_type);
-                        GET_CHAR(c2, cptr, cbuf_end, cbuf_type);
+                        GET_CHAR(c1, cptr1, cptr1_end);
+                        GET_CHAR(c2, cptr, cbuf_end);
                         if (s->ignore_case) {
-                            c1 = lre_canonicalize(c1, s->is_unicode);
-                            c2 = lre_canonicalize(c2, s->is_unicode);
+                            c1 = lre_canonicalize(c1, s->is_utf16);
+                            c2 = lre_canonicalize(c2, s->is_utf16);
                         }
                         if (c1 != c2)
                             goto no_match;
@@ -2269,11 +2352,11 @@
                     while (cptr1 > cptr1_start) {
                         if (cptr == s->cbuf)
                             goto no_match;
-                        GET_PREV_CHAR(c1, cptr1, cptr1_start, cbuf_type);
-                        GET_PREV_CHAR(c2, cptr, s->cbuf, cbuf_type);
+                        GET_PREV_CHAR(c1, cptr1, cptr1_start);
+                        GET_PREV_CHAR(c2, cptr, s->cbuf);
                         if (s->ignore_case) {
-                            c1 = lre_canonicalize(c1, s->is_unicode);
-                            c2 = lre_canonicalize(c2, s->is_unicode);
+                            c1 = lre_canonicalize(c1, s->is_utf16);
+                            c2 = lre_canonicalize(c2, s->is_utf16);
                         }
                         if (c1 != c2)
                             goto no_match;
@@ -2290,9 +2373,9 @@
                 pc += 2;
                 if (cptr >= cbuf_end)
                     goto no_match;
-                GET_CHAR(c, cptr, cbuf_end, cbuf_type);
+                GET_CHAR(c, cptr, cbuf_end);
                 if (s->ignore_case) {
-                    c = lre_canonicalize(c, s->is_unicode);
+                    c = lre_canonicalize(c, s->is_utf16);
                 }
                 idx_min = 0;
                 low = get_u16(pc + 0 * 4);
@@ -2330,9 +2413,9 @@
                 pc += 2;
                 if (cptr >= cbuf_end)
                     goto no_match;
-                GET_CHAR(c, cptr, cbuf_end, cbuf_type);
+                GET_CHAR(c, cptr, cbuf_end);
                 if (s->ignore_case) {
-                    c = lre_canonicalize(c, s->is_unicode);
+                    c = lre_canonicalize(c, s->is_utf16);
                 }
                 idx_min = 0;
                 low = get_u32(pc + 0 * 8);
@@ -2362,7 +2445,7 @@
             /* go to the previous char */
             if (cptr == s->cbuf)
                 goto no_match;
-            PREV_CHAR(cptr, s->cbuf, cbuf_type);
+            PREV_CHAR(cptr, s->cbuf);
             break;
         case REOP_simple_greedy_quant:
             {
@@ -2421,16 +2504,16 @@
     int re_flags, i, alloca_size, ret;
     StackInt *stack_buf;
 
-    re_flags = lre_get_flags(bc_buf);
+    re_flags = bc_buf[RE_HEADER_FLAGS];
     s->multi_line = (re_flags & LRE_FLAG_MULTILINE) != 0;
     s->ignore_case = (re_flags & LRE_FLAG_IGNORECASE) != 0;
-    s->is_unicode = (re_flags & LRE_FLAG_UNICODE) != 0;
+    s->is_utf16 = (re_flags & LRE_FLAG_UTF16) != 0;
     s->capture_count = bc_buf[RE_HEADER_CAPTURE_COUNT];
     s->stack_size_max = bc_buf[RE_HEADER_STACK_SIZE];
     s->cbuf = cbuf;
     s->cbuf_end = cbuf + (clen << cbuf_type);
     s->cbuf_type = cbuf_type;
-    if (s->cbuf_type == 1 && s->is_unicode)
+    if (s->cbuf_type == 1 && s->is_utf16)
         s->cbuf_type = 2;
     s->opaque = opaque;
 
@@ -2468,8 +2551,8 @@
     uint32_t re_bytecode_len;
     if ((lre_get_flags(bc_buf) & LRE_FLAG_NAMED_GROUPS) == 0)
         return NULL;
-    re_bytecode_len = get_u32(bc_buf + RE_HEADER_BYTECODE_LEN);
-    return (const char *)(bc_buf + RE_HEADER_LEN + re_bytecode_len);
+    re_bytecode_len = get_u32(bc_buf + 3);
+    return (const char *)(bc_buf + 7 + re_bytecode_len);
 }
 
 #ifdef TEST
@@ -2486,26 +2569,25 @@
 
 int main(int argc, char **argv)
 {
-    int len, flags, ret, i;
+    int len, ret, i;
     uint8_t *bc;
     char error_msg[64];
     uint8_t *capture[CAPTURE_COUNT_MAX * 2];
     const char *input;
     int input_len, capture_count;
 
-    if (argc < 4) {
-        printf("usage: %s regexp flags input\n", argv[0]);
-        return 1;
+    if (argc < 3) {
+        printf("usage: %s regexp input\n", argv[0]);
+        exit(1);
     }
-    flags = atoi(argv[2]);
     bc = lre_compile(&len, error_msg, sizeof(error_msg), argv[1],
-                     strlen(argv[1]), flags, NULL);
+                     strlen(argv[1]), 0, NULL);
     if (!bc) {
         fprintf(stderr, "error: %s\n", error_msg);
         exit(1);
     }
 
-    input = argv[3];
+    input = argv[2];
     input_len = strlen(input);
 
     ret = lre_exec(capture, bc, (uint8_t *)input, 0, input_len, 0, NULL);
Index: indigo-src/indigo/api/c/indigo-renderer/indigo-renderer.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo-renderer/indigo-renderer.h b/indigo-src/indigo/api/c/indigo-renderer/indigo-renderer.h
--- a/indigo-src/indigo/api/c/indigo-renderer/indigo-renderer.h	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo-renderer/indigo-renderer.h	(date 1714440647086)
@@ -20,34 +20,35 @@
 #define __indigo_render__
 
 #include "indigo.h"
+#include "indigo_renderer_export.h"
 
-CEXPORT int indigoRendererInit(qword id);
-CEXPORT int indigoRendererDispose(qword id);
+INDIGO_RENDERER_EXPORT int indigoRendererInit(qword id);
+INDIGO_RENDERER_EXPORT int indigoRendererDispose(qword id);
 
 /* Rendering */
 
 // Returns an 'output' object for the given HDC
-CEXPORT int indigoRenderWriteHDC(void* hdc, int printingHdc);
+INDIGO_RENDERER_EXPORT int indigoRenderWriteHDC(void* hdc, int printingHdc);
 
 // output is either a file output obtained via indigoWriteFile(), or
 //        a buffer obtained via indigoWriteBuffer(), or
 //        an HDC obtained via indigoRenderWriteHDC
-CEXPORT int indigoRender(int object, int output);
+INDIGO_RENDERER_EXPORT int indigoRender(int object, int output);
 
 // objects  is an array of molecules created with indigoCreateArray)
 // refAtoms is an array of integers, whose size must be equal to the number
 //          of molecules if the array
 // nColumns is the number of columns in the grid
 // output -- see the comment for indigoRender
-CEXPORT int indigoRenderGrid(int objects, int* refAtoms, int nColumns, int output);
+INDIGO_RENDERER_EXPORT int indigoRenderGrid(int objects, int* refAtoms, int nColumns, int output);
 
 // Works like indigoRender(), but renders directly to file
-CEXPORT int indigoRenderToFile(int object, const char* filename);
+INDIGO_RENDERER_EXPORT int indigoRenderToFile(int object, const char* filename);
 
 // Works like indigoRenderGrid(), but renders directly to file
-CEXPORT int indigoRenderGridToFile(int objects, int* refAtoms, int nColumns, const char* filename);
+INDIGO_RENDERER_EXPORT int indigoRenderGridToFile(int objects, int* refAtoms, int nColumns, const char* filename);
 
 // Resets all the rendering settings
-CEXPORT int indigoRenderReset();
+INDIGO_RENDERER_EXPORT int indigoRenderReset();
 
 #endif
Index: inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.c b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.c	(date 1714440647086)
@@ -46,26 +46,26 @@
 #include <limits.h>
 #include <float.h>
 #include <math.h>
-#include "../../../INCHI_BASE/src/incomdef.h"
-#include "../../../INCHI_BASE/src/ichidrp.h"
-#include "../../../INCHI_BASE/src/inpdef.h"
-#include "../../../INCHI_BASE/src/ichi.h"
-#include "../../../INCHI_BASE/src/strutil.h"
-#include "../../../INCHI_BASE/src/util.h"
-#include "../../../INCHI_BASE/src/ichierr.h"
-#include "../../../INCHI_BASE/src/ichimain.h"
-#include "../../../INCHI_BASE/src/extr_ct.h"
-#include "../../../INCHI_BASE/src/ichi_io.h"
-#include "../../../INCHI_BASE/src/mol_fmt.h"
-#include "../../../INCHI_BASE/src/ichicomp.h"
-#include "../../../INCHI_BASE/src/ichitaut.h"
-#include "../../../INCHI_BASE/src/ichinorm.h"
+#include "incomdef.h"
+#include "ichidrp.h"
+#include "inpdef.h"
+#include "ichi.h"
+#include "strutil.h"
+#include "util.h"
+#include "ichierr.h"
+#include "ichimain.h"
+#include "extr_ct.h"
+#include "ichi_io.h"
+#include "mol_fmt.h"
+#include "ichicomp.h"
+#include "ichitaut.h"
+#include "ichinorm.h"
 
 
-#include "../../../INCHI_BASE/src/ichisize.h"
-#include "../../../INCHI_BASE/src/ichitime.h"
-#include "../../../INCHI_BASE/src/mode.h"
-#include "../../../INCHI_BASE/src/inchi_api.h"
+#include "ichisize.h"
+#include "ichitime.h"
+#include "mode.h"
+#include "inchi_api.h"
 
 #include "inchi_dll_a.h" /* not inchi_api.h as it hides internal data types */
 #include "inchi_dll.h"
Index: quickjs-src/quickjs/libregexp-opcode.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/libregexp-opcode.h b/quickjs-src/quickjs/src/libregexp-opcode.h
rename from quickjs-src/quickjs/libregexp-opcode.h
rename to quickjs-src/quickjs/src/libregexp-opcode.h
--- a/quickjs-src/quickjs/libregexp-opcode.h	(revision 3b45d155c77bbdfe9177b1e03db830d2aff0b2a8)
+++ b/quickjs-src/quickjs/src/libregexp-opcode.h	(date 1714440647086)
@@ -50,7 +50,8 @@
 DEF(lookahead, 5)
 DEF(negative_lookahead, 5)
 DEF(push_char_pos, 1) /* push the character position on the stack */
-DEF(check_advance, 1) /* pop one stack element and check that it is different from the character position */
+DEF(bne_char_pos, 5) /* pop one stack element and jump if equal to the character
+ position */
 DEF(prev, 1) /* go to the previous char */
 DEF(simple_greedy_quant, 17)
 
Index: inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_main.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_main.c b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_main.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_main.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_main.c	(date 1714440647086)
@@ -34,7 +34,7 @@
 
 /* inchi_dll_main.c : Defines the entry point for the DLL application. */
 
-#include "../../../INCHI_BASE/src/mode.h"
+#include "mode.h"
 
 #if defined(_WIN32) && defined(_USRDLL) && defined(_DEBUG) && !(defined(__STDC__) && __STDC__ == 1)
 #include "inchi_dll_main.h"
Index: rdkit-src/rdkit/Code/RDGeneral/RDLog.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/RDGeneral/RDLog.cpp b/rdkit-src/rdkit/Code/RDGeneral/RDLog.cpp
--- a/rdkit-src/rdkit/Code/RDGeneral/RDLog.cpp	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Code/RDGeneral/RDLog.cpp	(date 1714440647086)
@@ -25,9 +25,7 @@
 namespace RDLog {
 
 namespace {
-const std::vector<RDLogger *> allLogs = {&rdAppLog,     &rdDebugLog,
-                                         &rdInfoLog,    &rdErrorLog,
-                                         &rdWarningLog, &rdStatusLog};
+std::vector<RDLogger *> allLogs;
 }
 
 LogStateSetter::LogStateSetter() {
@@ -147,13 +145,18 @@
   rdInfoLog->df_enabled = false;
   rdWarningLog = std::make_shared<boost::logging::rdLogger>(&std::cerr);
   rdErrorLog = std::make_shared<boost::logging::rdLogger>(&std::cerr);
+  rdAppLog = rdInfoLog;
+  rdStatusLog = rdInfoLog;
+  allLogs = {&rdAppLog,     &rdDebugLog,
+             &rdInfoLog,    &rdErrorLog,
+             &rdWarningLog, &rdStatusLog};
 }
 
 std::ostream &toStream(std::ostream &logstrm) {
   char buffer[16];
   time_t t = time(nullptr);
 // localtime() is thread safe on windows, but not on *nix
-#ifdef WIN32
+#if defined(WIN32) || defined(__MINGW32__)
   strftime(buffer, 16, "[%T] ", localtime(&t));
 #else
   struct tm buf;
Index: quickjs-src/quickjs/libunicode.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/libunicode.c b/quickjs-src/quickjs/src/libunicode.c
rename from quickjs-src/quickjs/libunicode.c
rename to quickjs-src/quickjs/src/libunicode.c
--- a/quickjs-src/quickjs/libunicode.c	(revision 3b45d155c77bbdfe9177b1e03db830d2aff0b2a8)
+++ b/quickjs-src/quickjs/src/libunicode.c	(date 1714440647086)
@@ -43,226 +43,123 @@
     RUN_TYPE_UF_D1_EXT,
     RUN_TYPE_U_EXT,
     RUN_TYPE_LF_EXT,
-    RUN_TYPE_UF_EXT2,
-    RUN_TYPE_LF_EXT2,
-    RUN_TYPE_UF_EXT3,
+    RUN_TYPE_U_EXT2,
+    RUN_TYPE_L_EXT2,
+    RUN_TYPE_U_EXT3,
 };
 
-static int lre_case_conv1(uint32_t c, int conv_type)
+/* conv_type:
+   0 = to upper
+   1 = to lower
+   2 = case folding (= to lower with modifications)
+*/
+int lre_case_conv(uint32_t *res, uint32_t c, int conv_type)
 {
-    uint32_t res[LRE_CC_RES_LEN_MAX];
-    lre_case_conv(res, c, conv_type);
-    return res[0];
-}
+    if (c < 128) {
+        if (conv_type) {
+            if (c >= 'A' && c <= 'Z') {
+                c = c - 'A' + 'a';
+            }
+        } else {
+            if (c >= 'a' && c <= 'z') {
+                c = c - 'a' + 'A';
+            }
+        }
+    } else {
+        uint32_t v, code, data, type, len, a, is_lower;
+        int idx, idx_min, idx_max;
 
-/* case conversion using the table entry 'idx' with value 'v' */
-static int lre_case_conv_entry(uint32_t *res, uint32_t c, int conv_type, uint32_t idx, uint32_t v)
-{
-    uint32_t code, data, type, a, is_lower;
-    is_lower = (conv_type != 0);
-    type = (v >> (32 - 17 - 7 - 4)) & 0xf;
-    data = ((v & 0xf) << 8) | case_conv_table2[idx];
-    code = v >> (32 - 17);
-    switch(type) {
-    case RUN_TYPE_U:
-    case RUN_TYPE_L:
-    case RUN_TYPE_UF:
-    case RUN_TYPE_LF:
-        if (conv_type == (type & 1) ||
-            (type >= RUN_TYPE_UF && conv_type == 2)) {
-            c = c - code + (case_conv_table1[data] >> (32 - 17));
-        }
-        break;
-    case RUN_TYPE_UL:
-        a = c - code;
-        if ((a & 1) != (1 - is_lower))
-            break;
-        c = (a ^ 1) + code;
-        break;
-    case RUN_TYPE_LSU:
-        a = c - code;
-        if (a == 1) {
-            c += 2 * is_lower - 1;
-        } else if (a == (1 - is_lower) * 2) {
-            c += (2 * is_lower - 1) * 2;
-        }
-        break;
-    case RUN_TYPE_U2L_399_EXT2:
-        if (!is_lower) {
-            res[0] = c - code + case_conv_ext[data >> 6];
-            res[1] = 0x399;
-            return 2;
-        } else {
-            c = c - code + case_conv_ext[data & 0x3f];
-        }
-        break;
-    case RUN_TYPE_UF_D20:
-        if (conv_type == 1)
-            break;
-        c = data + (conv_type == 2) * 0x20;
-        break;
-    case RUN_TYPE_UF_D1_EXT:
-        if (conv_type == 1)
-            break;
-        c = case_conv_ext[data] + (conv_type == 2);
-        break;
-    case RUN_TYPE_U_EXT:
-    case RUN_TYPE_LF_EXT:
-        if (is_lower != (type - RUN_TYPE_U_EXT))
-            break;
-        c = case_conv_ext[data];
-        break;
-    case RUN_TYPE_LF_EXT2:
-        if (!is_lower)
-            break;
-        res[0] = c - code + case_conv_ext[data >> 6];
-        res[1] = case_conv_ext[data & 0x3f];
-        return 2;
-    case RUN_TYPE_UF_EXT2:
-        if (conv_type == 1)
-            break;
-        res[0] = c - code + case_conv_ext[data >> 6];
-        res[1] = case_conv_ext[data & 0x3f];
-        if (conv_type == 2) {
-            /* convert to lower */
-            res[0] = lre_case_conv1(res[0], 1);
-            res[1] = lre_case_conv1(res[1], 1);
-        }
-        return 2;
-    default:
-    case RUN_TYPE_UF_EXT3:
-        if (conv_type == 1)
-            break;
-        res[0] = case_conv_ext[data >> 8];
-        res[1] = case_conv_ext[(data >> 4) & 0xf];
-        res[2] = case_conv_ext[data & 0xf];
-        if (conv_type == 2) {
-            /* convert to lower */
-            res[0] = lre_case_conv1(res[0], 1);
-            res[1] = lre_case_conv1(res[1], 1);
-            res[2] = lre_case_conv1(res[2], 1);
-        }
-        return 3;
+        is_lower = (conv_type != 0);
+        idx_min = 0;
+        idx_max = countof(case_conv_table1) - 1;
+        while (idx_min <= idx_max) {
+            idx = (unsigned)(idx_max + idx_min) / 2;
+            v = case_conv_table1[idx];
+            code = v >> (32 - 17);
+            len = (v >> (32 - 17 - 7)) & 0x7f;
+            if (c < code) {
+                idx_max = idx - 1;
+            } else if (c >= code + len) {
+                idx_min = idx + 1;
+            } else {
+                type = (v >> (32 - 17 - 7 - 4)) & 0xf;
+                data = ((v & 0xf) << 8) | case_conv_table2[idx];
+                switch(type) {
+                case RUN_TYPE_U:
+                case RUN_TYPE_L:
+                case RUN_TYPE_UF:
+                case RUN_TYPE_LF:
+                    if (conv_type == (type & 1) ||
+                        (type >= RUN_TYPE_UF && conv_type == 2)) {
+                        c = c - code + (case_conv_table1[data] >> (32 - 17));
+                    }
+                    break;
+                case RUN_TYPE_UL:
+                    a = c - code;
+                    if ((a & 1) != (1 - is_lower))
+                        break;
+                    c = (a ^ 1) + code;
+                    break;
+                case RUN_TYPE_LSU:
+                    a = c - code;
+                    if (a == 1) {
+                        c += 2 * is_lower - 1;
+                    } else if (a == (1 - is_lower) * 2) {
+                        c += (2 * is_lower - 1) * 2;
+                    }
+                    break;
+                case RUN_TYPE_U2L_399_EXT2:
+                    if (!is_lower) {
+                        res[0] = c - code + case_conv_ext[data >> 6];
+                        res[1] = 0x399;
+                        return 2;
+                    } else {
+                        c = c - code + case_conv_ext[data & 0x3f];
+                    }
+                    break;
+                case RUN_TYPE_UF_D20:
+                    if (conv_type == 1)
+                        break;
+                    c = data + (conv_type == 2) * 0x20;
+                    break;
+                case RUN_TYPE_UF_D1_EXT:
+                    if (conv_type == 1)
+                        break;
+                    c = case_conv_ext[data] + (conv_type == 2);
+                    break;
+                case RUN_TYPE_U_EXT:
+                case RUN_TYPE_LF_EXT:
+                    if (is_lower != (type - RUN_TYPE_U_EXT))
+                        break;
+                    c = case_conv_ext[data];
+                    break;
+                case RUN_TYPE_U_EXT2:
+                case RUN_TYPE_L_EXT2:
+                    if (conv_type != (type - RUN_TYPE_U_EXT2))
+                        break;
+                    res[0] = c - code + case_conv_ext[data >> 6];
+                    res[1] = case_conv_ext[data & 0x3f];
+                    return 2;
+                default:
+                case RUN_TYPE_U_EXT3:
+                    if (conv_type != 0)
+                        break;
+                    res[0] = case_conv_ext[data >> 8];
+                    res[1] = case_conv_ext[(data >> 4) & 0xf];
+                    res[2] = case_conv_ext[data & 0xf];
+                    return 3;
+                }
+                break;
+            }
+        }
     }
     res[0] = c;
     return 1;
 }
 
-/* conv_type:
-   0 = to upper
-   1 = to lower
-   2 = case folding (= to lower with modifications)
-*/
-int lre_case_conv(uint32_t *res, uint32_t c, int conv_type)
-{
-    if (c < 128) {
-        if (conv_type) {
-            if (c >= 'A' && c <= 'Z') {
-                c = c - 'A' + 'a';
-            }
-        } else {
-            if (c >= 'a' && c <= 'z') {
-                c = c - 'a' + 'A';
-            }
-        }
-    } else {
-        uint32_t v, code, len;
-        int idx, idx_min, idx_max;
-
-        idx_min = 0;
-        idx_max = countof(case_conv_table1) - 1;
-        while (idx_min <= idx_max) {
-            idx = (unsigned)(idx_max + idx_min) / 2;
-            v = case_conv_table1[idx];
-            code = v >> (32 - 17);
-            len = (v >> (32 - 17 - 7)) & 0x7f;
-            if (c < code) {
-                idx_max = idx - 1;
-            } else if (c >= code + len) {
-                idx_min = idx + 1;
-            } else {
-                return lre_case_conv_entry(res, c, conv_type, idx, v);
-            }
-        }
-    }
-    res[0] = c;
-    return 1;
-}
-
-static int lre_case_folding_entry(uint32_t c, uint32_t idx, uint32_t v, BOOL is_unicode)
-{
-    uint32_t res[LRE_CC_RES_LEN_MAX];
-    int len;
-
-    if (is_unicode) {
-        len = lre_case_conv_entry(res, c, 2, idx, v);
-        if (len == 1) {
-            c = res[0];
-        } else {
-            /* handle the few specific multi-character cases (see
-               unicode_gen.c:dump_case_folding_special_cases()) */
-            if (c == 0xfb06) {
-                c = 0xfb05;
-            } else if (c == 0x01fd3) {
-                c = 0x390;
-            } else if (c == 0x01fe3) {
-                c = 0x3b0;
-            }
-        }
-    } else {
-        if (likely(c < 128)) {
-            if (c >= 'a' && c <= 'z')
-                c = c - 'a' + 'A';
-        } else {
-            /* legacy regexp: to upper case if single char >= 128 */
-            len = lre_case_conv_entry(res, c, FALSE, idx, v);
-            if (len == 1 && res[0] >= 128)
-                c = res[0];
-        }
-    }
-    return c;
-}
-
-/* JS regexp specific rules for case folding */
-int lre_canonicalize(uint32_t c, BOOL is_unicode)
-{
-    if (c < 128) {
-        /* fast case */
-        if (is_unicode) {
-            if (c >= 'A' && c <= 'Z') {
-                c = c - 'A' + 'a';
-            }
-        } else {
-            if (c >= 'a' && c <= 'z') {
-                c = c - 'a' + 'A';
-            }
-        }
-    } else {
-        uint32_t v, code, len;
-        int idx, idx_min, idx_max;
-
-        idx_min = 0;
-        idx_max = countof(case_conv_table1) - 1;
-        while (idx_min <= idx_max) {
-            idx = (unsigned)(idx_max + idx_min) / 2;
-            v = case_conv_table1[idx];
-            code = v >> (32 - 17);
-            len = (v >> (32 - 17 - 7)) & 0x7f;
-            if (c < code) {
-                idx_max = idx - 1;
-            } else if (c >= code + len) {
-                idx_min = idx + 1;
-            } else {
-                return lre_case_folding_entry(c, idx, v, is_unicode);
-            }
-        }
-    }
-    return c;
-}
-
 static uint32_t get_le24(const uint8_t *ptr)
 {
-#if defined(__x86__) || defined(__x86_64__)
+#if defined(__x86__) || defined(__x86_64__) || defined(PLATFORM_IS_64BIT)
     return *(uint16_t *)ptr | (ptr[2] << 16);
 #else
     return ptr[0] | (ptr[1] << 8) | (ptr[2] << 16);
@@ -1282,11 +1179,11 @@
 #define MR(x) (1 << RUN_TYPE_ ## x)
     const uint32_t tab_run_mask[3] = {
         MR(U) | MR(UF) | MR(UL) | MR(LSU) | MR(U2L_399_EXT2) | MR(UF_D20) |
-        MR(UF_D1_EXT) | MR(U_EXT) | MR(UF_EXT2) | MR(UF_EXT3),
+        MR(UF_D1_EXT) | MR(U_EXT) | MR(U_EXT2) | MR(U_EXT3),
 
-        MR(L) | MR(LF) | MR(UL) | MR(LSU) | MR(U2L_399_EXT2) | MR(LF_EXT) | MR(LF_EXT2),
+        MR(L) | MR(LF) | MR(UL) | MR(LSU) | MR(U2L_399_EXT2) | MR(LF_EXT) | MR(L_EXT2),
 
-        MR(UF) | MR(LF) | MR(UL) | MR(LSU) | MR(U2L_399_EXT2) | MR(LF_EXT) | MR(LF_EXT2) | MR(UF_D20) | MR(UF_D1_EXT) | MR(LF_EXT) | MR(UF_EXT2) | MR(UF_EXT3),
+        MR(UF) | MR(LF) | MR(UL) | MR(LSU) | MR(U2L_399_EXT2) | MR(LF_EXT) | MR(UF_D20) | MR(UF_D1_EXT) | MR(LF_EXT),
     };
 #undef MR
     uint32_t mask, v, code, type, len, i, idx;
@@ -1340,135 +1237,6 @@
     return 0;
 }
 
-static int point_cmp(const void *p1, const void *p2, void *arg)
-{
-    uint32_t v1 = *(uint32_t *)p1;
-    uint32_t v2 = *(uint32_t *)p2;
-    return (v1 > v2) - (v1 < v2);
-}
-
-static void cr_sort_and_remove_overlap(CharRange *cr)
-{
-    uint32_t start, end, start1, end1, i, j;
-
-    /* the resulting ranges are not necessarily sorted and may overlap */
-    rqsort(cr->points, cr->len / 2, sizeof(cr->points[0]) * 2, point_cmp, NULL);
-    j = 0;
-    for(i = 0; i < cr->len; ) {
-        start = cr->points[i];
-        end = cr->points[i + 1];
-        i += 2;
-        while (i < cr->len) {
-            start1 = cr->points[i];
-            end1 = cr->points[i + 1];
-            if (start1 > end) {
-                /* |------|
-                 *           |-------| */
-                break;
-            } else if (end1 <= end) {
-                /* |------|
-                 *    |--| */
-                i += 2;
-            } else {
-                /* |------|
-                 *     |-------| */
-                end = end1;
-                i += 2;
-            }
-        }
-        cr->points[j] = start;
-        cr->points[j + 1] = end;
-        j += 2;
-    }
-    cr->len = j;
-}
-
-/* canonicalize a character set using the JS regex case folding rules
-   (see lre_canonicalize()) */
-int cr_regexp_canonicalize(CharRange *cr, BOOL is_unicode)
-{
-    CharRange cr_inter, cr_mask, cr_result, cr_sub;
-    uint32_t v, code, len, i, idx, start, end, c, d_start, d_end, d;
-
-    cr_init(&cr_mask, cr->mem_opaque, cr->realloc_func);
-    cr_init(&cr_inter, cr->mem_opaque, cr->realloc_func);
-    cr_init(&cr_result, cr->mem_opaque, cr->realloc_func);
-    cr_init(&cr_sub, cr->mem_opaque, cr->realloc_func);
-
-    if (unicode_case1(&cr_mask, is_unicode ? CASE_F : CASE_U))
-        goto fail;
-    if (cr_op(&cr_inter, cr_mask.points, cr_mask.len, cr->points, cr->len, CR_OP_INTER))
-        goto fail;
-
-    if (cr_invert(&cr_mask))
-        goto fail;
-    if (cr_op(&cr_sub, cr_mask.points, cr_mask.len, cr->points, cr->len, CR_OP_INTER))
-        goto fail;
-
-    /* cr_inter = cr & cr_mask */
-    /* cr_sub = cr & ~cr_mask */
-
-    /* use the case conversion table to compute the result */
-    d_start = -1;
-    d_end = -1;
-    idx = 0;
-    v = case_conv_table1[idx];
-    code = v >> (32 - 17);
-    len = (v >> (32 - 17 - 7)) & 0x7f;
-    for(i = 0; i < cr_inter.len; i += 2) {
-        start = cr_inter.points[i];
-        end = cr_inter.points[i + 1];
-
-        for(c = start; c < end; c++) {
-            for(;;) {
-                if (c >= code && c < code + len)
-                    break;
-                idx++;
-                assert(idx < countof(case_conv_table1));
-                v = case_conv_table1[idx];
-                code = v >> (32 - 17);
-                len = (v >> (32 - 17 - 7)) & 0x7f;
-            }
-            d = lre_case_folding_entry(c, idx, v, is_unicode);
-            /* try to merge with the current interval */
-            if (d_start == -1) {
-                d_start = d;
-                d_end = d + 1;
-            } else if (d_end == d) {
-                d_end++;
-            } else {
-                cr_add_interval(&cr_result, d_start, d_end);
-                d_start = d;
-                d_end = d + 1;
-            }
-        }
-    }
-    if (d_start != -1) {
-        if (cr_add_interval(&cr_result, d_start, d_end))
-            goto fail;
-    }
-
-    /* the resulting ranges are not necessarily sorted and may overlap */
-    cr_sort_and_remove_overlap(&cr_result);
-
-    /* or with the character not affected by the case folding */
-    cr->len = 0;
-    if (cr_op(cr, cr_result.points, cr_result.len, cr_sub.points, cr_sub.len, CR_OP_UNION))
-        goto fail;
-
-    cr_free(&cr_inter);
-    cr_free(&cr_mask);
-    cr_free(&cr_result);
-    cr_free(&cr_sub);
-    return 0;
- fail:
-    cr_free(&cr_inter);
-    cr_free(&cr_mask);
-    cr_free(&cr_result);
-    cr_free(&cr_sub);
-    return -1;
-}
-
 typedef enum {
     POP_GC,
     POP_PROP,
Index: indigo-src/indigo/api/c/indigo-inchi/src/indigo_inchi_api.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo-inchi/src/indigo_inchi_api.cpp b/indigo-src/indigo/api/c/indigo-inchi/src/indigo_inchi_api.cpp
--- a/indigo-src/indigo/api/c/indigo-inchi/src/indigo_inchi_api.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo-inchi/src/indigo_inchi_api.cpp	(date 1714440647086)
@@ -29,7 +29,7 @@
 
 using namespace indigo;
 
-CEXPORT const char* indigoInchiVersion()
+const char* indigoInchiVersion()
 {
     return InchiWrapper::version();
 }
@@ -74,7 +74,7 @@
 // C interface functions
 //
 
-CEXPORT int indigoInchiInit(qword id)
+int indigoInchiInit(qword id)
 {
 #ifdef INDIGO_DEBUG
     std::stringstream ss;
@@ -89,7 +89,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoInchiDispose(qword id)
+int indigoInchiDispose(qword id)
 {
 #ifdef INDIGO_DEBUG
     std::stringstream ss;
@@ -104,14 +104,14 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoInchiResetOptions(void)
+int indigoInchiResetOptions(void)
 {
     IndigoInchiContext& inchi_context = indigoInchiGetInstance();
     inchi_context.init();
     return 0;
 }
 
-CEXPORT int indigoInchiLoadMolecule(const char* inchi_string)
+int indigoInchiLoadMolecule(const char* inchi_string)
 {
     INDIGO_BEGIN
     {
@@ -152,7 +152,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoInchiGetInchi(int molecule)
+const char* indigoInchiGetInchi(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -166,7 +166,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoInchiGetInchiKey(const char* inchi_string)
+const char* indigoInchiGetInchiKey(const char* inchi_string)
 {
     INDIGO_BEGIN
     {
@@ -177,7 +177,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoInchiGetWarning()
+const char* indigoInchiGetWarning()
 {
     InchiWrapper& inchi_wrapper = indigoInchiGetInstance().inchi;
     if (inchi_wrapper.warning.size() != 0)
@@ -185,7 +185,7 @@
     return "";
 }
 
-CEXPORT const char* indigoInchiGetLog()
+const char* indigoInchiGetLog()
 {
     InchiWrapper& inchi_wrapper = indigoInchiGetInstance().inchi;
     if (inchi_wrapper.log.size() != 0)
@@ -193,7 +193,7 @@
     return "";
 }
 
-CEXPORT const char* indigoInchiGetAuxInfo()
+const char* indigoInchiGetAuxInfo()
 {
     InchiWrapper& inchi_wrapper = indigoInchiGetInstance().inchi;
     if (inchi_wrapper.auxInfo.size() != 0)
Index: rdkit-src/rdkit/Code/RDGeneral/export.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/RDGeneral/export.h b/rdkit-src/rdkit/Code/RDGeneral/export.h
new file mode 100644
--- /dev/null	(date 1714440647086)
+++ b/rdkit-src/rdkit/Code/RDGeneral/export.h	(date 1714440647086)
@@ -0,0 +1,78 @@
+#pragma once
+
+#include <Abbreviations/rdkit_export.hpp>
+#include <Alignment/rdkit_export.hpp>
+#include <AvalonLib/rdkit_export.hpp>
+#include <Catalogs/rdkit_export.hpp>
+#include <ChemicalFeatures/rdkit_export.hpp>
+#include <ChemReactions/rdkit_export.hpp>
+#include <ChemTransforms/rdkit_export.hpp>
+#include <CIPLabeler/rdkit_export.hpp>
+#include <ConformerParser/rdkit_export.hpp>
+#include <DataStructs/rdkit_export.hpp>
+#include <Depictor/rdkit_export.hpp>
+#include <Deprotect/rdkit_export.hpp>
+#include <Descriptors/rdkit_export.hpp>
+#include <DetermineBonds/rdkit_export.hpp>
+#include <DistGeometry/rdkit_export.hpp>
+#include <DistGeomHelpers/rdkit_export.hpp>
+#include <EHTLIB/rdkit_export.hpp>
+#include <EigenSolvers/rdkit_export.hpp>
+#include <Features/rdkit_export.hpp>
+#include <FileParsers/rdkit_export.hpp>
+#include <FilterCatalog/rdkit_export.hpp>
+#include <Fingerprints/rdkit_export.hpp>
+#include <FMCS/rdkit_export.hpp>
+#include <ForceField/rdkit_export.hpp>
+#include <ForceFieldHelpers/rdkit_export.hpp>
+#include <FragCatalog/rdkit_export.hpp>
+#include <GeneralizedSubstruct/rdkit_export.hpp>
+#include <FreeSASALib/rdkit_export.hpp>
+#include <ga/rdkit_export.hpp>
+#include <GenericGroups/rdkit_export.hpp>
+#include <GraphMol/rdkit_export.hpp>
+#include <InfoTheory/rdkit_export.hpp>
+#include <MMPA/rdkit_export.hpp>
+#include <MolAlign/rdkit_export.hpp>
+#include <MolCatalog/rdkit_export.hpp>
+#include <MolChemicalFeatures/rdkit_export.hpp>
+#include <MolDraw2D/rdkit_export.hpp>
+#include <MolEnumerator/rdkit_export.hpp>
+#include <MolHash/rdkit_export.hpp>
+#include <MolInterchange/rdkit_export.hpp>
+#include <MolStandardize/rdkit_export.hpp>
+#include <MolTransforms/rdkit_export.hpp>
+#include <O3AAlign/rdkit_export.hpp>
+#include <Optimizer/rdkit_export.hpp>
+#include <PartialCharges/rdkit_export.hpp>
+#include <PBF/rdkit_export.hpp>
+#include <RDGeneral/rdkit_export.hpp>
+#include <RDGeometryLib/rdkit_export.hpp>
+#include <RDInchiLib/rdkit_export.hpp>
+#include <RDStreams/rdkit_export.hpp>
+#include <ReducedGraphs/rdkit_export.hpp>
+#include <RGroupDecomposition/rdkit_export.hpp>
+#include <ScaffoldNetwork/rdkit_export.hpp>
+#include <ShapeHelpers/rdkit_export.hpp>
+#include <SimDivPickers/rdkit_export.hpp>
+#include <SLNParse/rdkit_export.hpp>
+#include <SmilesParse/rdkit_export.hpp>
+#include <StructChecker/rdkit_export.hpp>
+#include <Subgraphs/rdkit_export.hpp>
+#include <SubstructLibrary/rdkit_export.hpp>
+#include <SubstructMatch/rdkit_export.hpp>
+#include <TautomerQuery/rdkit_export.hpp>
+#include <Trajectory/rdkit_export.hpp>
+
+#include <RDGeneral/RDConfig.h>
+
+#define RDKIT_EXPORT // unused
+
+#define RDKIT_INCHI_EXPORT RDKIT_EXPORT
+#define RDKIT_RDBOOST_EXPORT RDKIT_EXPORT
+#define RDKIT_RINGDECOMPOSERLIB_EXPORT RDKIT_EXPORT
+#define RDKIT_AVALON_CLIB_EXPORT RDKIT_EXPORT
+#define RDKIT_COORDGEN_EXPORT RDKIT_EXPORT
+#define RDKIT_FREESASA_CLIB_EXPORT RDKIT_EXPORT
+#define RDKIT_MAEPARSER_EXPORT RDKIT_EXPORT
+#define RDKIT_QUERY_EXPORT RDKIT_EXPORT
Index: quickjs-src/quickjs/quickjs.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/quickjs.c b/quickjs-src/quickjs/src/quickjs.c
rename from quickjs-src/quickjs/quickjs.c
rename to quickjs-src/quickjs/src/quickjs.c
--- a/quickjs-src/quickjs/quickjs.c	(revision 3b45d155c77bbdfe9177b1e03db830d2aff0b2a8)
+++ b/quickjs-src/quickjs/src/quickjs.c	(date 1714440647082)
@@ -22,13 +22,13 @@
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  * THE SOFTWARE.
  */
+#include "quickjs-defs.h"
 #include <stdlib.h>
 #include <stdio.h>
 #include <stdarg.h>
 #include <inttypes.h>
 #include <string.h>
 #include <assert.h>
-#include <sys/time.h>
 #include <time.h>
 #include <fenv.h>
 #include <math.h>
@@ -36,21 +36,27 @@
 #include <malloc/malloc.h>
 #elif defined(__linux__)
 #include <malloc.h>
-#elif defined(__FreeBSD__)
-#include <malloc_np.h>
+#endif
+
+#if defined(PLATFORM_IS_WINDOWS)
+# include <windows.h>
+#else
+# include <sys/time.h>
 #endif
 
 #include "cutils.h"
 #include "list.h"
 #include "quickjs.h"
 #include "libregexp.h"
+#ifdef CONFIG_BIGNUM
 #include "libbf.h"
+#endif
 
 #define OPTIMIZE         1
 #define SHORT_OPCODES    1
 #if defined(EMSCRIPTEN)
 #define DIRECT_DISPATCH  0
-#else
+#elif defined(PLATFORM_GNUC_LIKE)
 #define DIRECT_DISPATCH  1
 #endif
 
@@ -67,11 +73,11 @@
 
 /* define to include Atomics.* operations which depend on the OS
    threads */
-#if !defined(EMSCRIPTEN)
+#if !defined(EMSCRIPTEN) && !defined(_WIN32)
 #define CONFIG_ATOMICS
 #endif
 
-#if !defined(EMSCRIPTEN)
+#if !defined(EMSCRIPTEN) && !_MSC_VER && 0
 /* enable stack limitation */
 #define CONFIG_STACK_CHECK
 #endif
@@ -87,7 +93,6 @@
    8: dump stdlib functions
   16: dump bytecode in hex
   32: dump line number table
-  64: dump compute_stack_size
  */
 //#define DUMP_BYTECODE  (1)
 /* dump the occurence of the automatic GC */
@@ -197,11 +202,11 @@
     JS_NATIVE_ERROR_COUNT, /* number of different NativeError objects */
 } JSErrorEnum;
 
-#define JS_MAX_LOCAL_VARS 65535
+#define JS_MAX_LOCAL_VARS 65536
 #define JS_STACK_SIZE_MAX 65534
 #define JS_STRING_LEN_MAX ((1 << 30) - 1)
 
-#define __exception __attribute__((warn_unused_result))
+#define __exception PLATFORM_WARN_UNUSED
 
 typedef struct JSShape JSShape;
 typedef struct JSString JSString;
@@ -277,14 +282,14 @@
 
     JSHostPromiseRejectionTracker *host_promise_rejection_tracker;
     void *host_promise_rejection_tracker_opaque;
+    JSHostPromiseRejectionTracker *host_unhandled_promise_rejection_tracker;
+    void *host_unhandled_promise_rejection_tracker_opaque;
 
     struct list_head job_list; /* list of JSJobEntry.link */
 
     JSModuleNormalizeFunc *module_normalize_func;
     JSModuleLoaderFunc *module_loader_func;
     void *module_loader_opaque;
-    /* timestamp for internal use in module evaluation */
-    int64_t module_async_evaluation_next_timestamp;
 
     BOOL can_block : 8; /* TRUE if Atomics.wait can block */
     /* used to allocate, free and clone SharedArrayBuffers */
@@ -318,18 +323,17 @@
 #define JS_MODE_STRICT (1 << 0)
 #define JS_MODE_STRIP  (1 << 1)
 #define JS_MODE_MATH   (1 << 2)
-#define JS_MODE_ASYNC  (1 << 3) /* async function */
 
 typedef struct JSStackFrame {
     struct JSStackFrame *prev_frame; /* NULL if first stack frame */
     JSValue cur_func; /* current function, JS_UNDEFINED if the frame is detached */
     JSValue *arg_buf; /* arguments */
     JSValue *var_buf; /* variables */
-    struct list_head var_ref_list; /* list of JSVarRef.var_ref_link */
+    struct list_head var_ref_list; /* list of JSVarRef.link */
     const uint8_t *cur_pc; /* only used in bytecode functions : PC of the
                         instruction after the call */
     int arg_count;
-    int js_mode; /* for C functions, only JS_MODE_MATH may be set */
+    int js_mode; /* 0 or JS_MODE_MATH for C functions */
     /* only used in generators. Current stack pointer value. NULL if
        the function is running. */
     JSValue *cur_sp;
@@ -362,6 +366,11 @@
         struct {
             int __gc_ref_count; /* corresponds to header.ref_count */
             uint8_t __gc_mark; /* corresponds to header.mark/gc_obj_type */
+
+            /* 0 : the JSVarRef is on the stack. header.link is an element
+               of JSStackFrame.var_ref_list.
+               1 : the JSVarRef is detached. header.link has the normal meanning
+            */
             uint8_t is_detached : 1;
             uint8_t is_arg : 1;
             uint16_t var_idx; /* index of the corresponding function variable on
@@ -370,13 +379,7 @@
     };
     JSValue *pvalue; /* pointer to the value, either on the stack or
                         to 'value' */
-    union {
-        JSValue value; /* used when is_detached = TRUE */
-        struct {
-            struct list_head var_ref_link; /* JSStackFrame.var_ref_list list */
-            struct JSAsyncFunctionState *async_func; /* != NULL if async stack frame */
-        }; /* used when is_detached = FALSE */
-    };
+    JSValue value; /* used when the variable is no longer on the stack */
 } JSVarRef;
 
 /* the same structure is used for big integers and big floats. Big
@@ -444,6 +447,7 @@
 #endif
     /* when the counter reaches zero, JSRutime.interrupt_handler is called */
     int interrupt_counter;
+    BOOL is_error_property_enabled;
 
     struct list_head loaded_modules; /* list of JSModuleDef.link */
 
@@ -556,7 +560,6 @@
     uint8_t is_const : 1;
     uint8_t is_lexical : 1;
     uint8_t is_captured : 1;
-    uint8_t is_static_private : 1; /* only used during private class field parsing */
     uint8_t var_kind : 4; /* see JSVarKindEnum */
     /* only used during compilation: function pool index for lexical
        variables with var_kind =
@@ -597,8 +600,7 @@
     uint8_t has_debug : 1;
     uint8_t backtrace_barrier : 1; /* stop backtrace on this function */
     uint8_t read_only_bytecode : 1;
-    uint8_t is_direct_or_indirect_eval : 1; /* used by JS_GetScriptOrModuleName() */
-    /* XXX: 10 bits available */
+    /* XXX: 4 bits available */
     uint8_t *byte_code_buf; /* (self pointer) */
     int byte_code_len;
     JSAtom func_name;
@@ -638,11 +640,9 @@
 
 typedef struct JSForInIterator {
     JSValue obj;
+    BOOL is_array;
+    uint32_t array_length;
     uint32_t idx;
-    uint32_t atom_count;
-    uint8_t in_prototype_chain;
-    uint8_t is_array;
-    JSPropertyEnum *tab_atom; /* is_array = FALSE */
 } JSForInIterator;
 
 typedef struct JSRegExp {
@@ -676,16 +676,21 @@
 } JSTypedArray;
 
 typedef struct JSAsyncFunctionState {
-    JSGCObjectHeader header;
-    JSValue this_val; /* 'this' argument */
+    JSValue this_val; /* 'this' generator argument */
     int argc; /* number of function arguments */
     BOOL throw_flag; /* used to throw an exception in JS_CallInternal() */
-    BOOL is_completed; /* TRUE if the function has returned. The stack
-                          frame is no longer valid */
-    JSValue resolving_funcs[2]; /* only used in JS async functions */
     JSStackFrame frame;
 } JSAsyncFunctionState;
 
+/* XXX: could use an object instead to avoid the
+   JS_TAG_ASYNC_FUNCTION tag for the GC */
+typedef struct JSAsyncFunctionData {
+    JSGCObjectHeader header; /* must come first */
+    JSValue resolving_funcs[2];
+    BOOL is_active; /* true if the async function state is valid */
+    JSAsyncFunctionState func_state;
+} JSAsyncFunctionData;
+
 typedef enum {
    /* binary operators */
    JS_OVOP_ADD,
@@ -767,15 +772,6 @@
     int req_module_idx; /* in req_module_entries */
 } JSImportEntry;
 
-typedef enum {
-    JS_MODULE_STATUS_UNLINKED,
-    JS_MODULE_STATUS_LINKING,
-    JS_MODULE_STATUS_LINKED,
-    JS_MODULE_STATUS_EVALUATING,
-    JS_MODULE_STATUS_EVALUATING_ASYNC,
-    JS_MODULE_STATUS_EVALUATED,
-} JSModuleStatus;
-
 struct JSModuleDef {
     JSRefCountHeader header; /* must come first, 32-bit */
     JSAtom module_name;
@@ -800,24 +796,11 @@
     JSValue module_ns;
     JSValue func_obj; /* only used for JS modules */
     JSModuleInitFunc *init_func; /* only used for C modules */
-    BOOL has_tla : 8; /* true if func_obj contains await */
     BOOL resolved : 8;
     BOOL func_created : 8;
-    JSModuleStatus status : 8;
-    /* temp use during js_module_link() & js_module_evaluate() */
-    int dfs_index, dfs_ancestor_index;
-    JSModuleDef *stack_prev;
-    /* temp use during js_module_evaluate() */
-    JSModuleDef **async_parent_modules;
-    int async_parent_modules_count;
-    int async_parent_modules_size;
-    int pending_async_dependencies;
-    BOOL async_evaluation;
-    int64_t async_evaluation_timestamp;
-    JSModuleDef *cycle_root;
-    JSValue promise; /* corresponds to spec field: capability */
-    JSValue resolving_funcs[2]; /* corresponds to spec field: capability */
-
+    BOOL instantiated : 8;
+    BOOL evaluated : 8;
+    BOOL eval_mark : 8; /* temporary use during js_evaluate_module() */
     /* true if evaluation yielded an exception. It is saved in
        eval_exception */
     BOOL eval_has_exception : 8;
@@ -925,7 +908,7 @@
         struct JSProxyData *proxy_data; /* JS_CLASS_PROXY */
         struct JSPromiseData *promise_data; /* JS_CLASS_PROMISE */
         struct JSPromiseFunctionData *promise_function_data; /* JS_CLASS_PROMISE_RESOLVE_FUNCTION, JS_CLASS_PROMISE_REJECT_FUNCTION */
-        struct JSAsyncFunctionState *async_function_data; /* JS_CLASS_ASYNC_FUNCTION_RESOLVE, JS_CLASS_ASYNC_FUNCTION_REJECT */
+        struct JSAsyncFunctionData *async_function_data; /* JS_CLASS_ASYNC_FUNCTION_RESOLVE, JS_CLASS_ASYNC_FUNCTION_REJECT */
         struct JSAsyncFromSyncIteratorData *async_from_sync_iterator_data; /* JS_CLASS_ASYNC_FROM_SYNC_ITERATOR */
         struct JSAsyncGeneratorData *async_generator_data; /* JS_CLASS_ASYNC_GENERATOR */
         struct { /* JS_CLASS_BYTECODE_FUNCTION: 12/24 bytes */
@@ -968,7 +951,6 @@
     } u;
     /* byte sizes: 40/48/72 */
 };
-
 enum {
     __JS_ATOM_NULL = JS_ATOM_NULL,
 #define DEF(name, str) JS_ATOM_ ## name,
@@ -1041,13 +1023,15 @@
                                             JSValue val, BOOL is_array_ctor);
 static JSValue JS_EvalObject(JSContext *ctx, JSValueConst this_obj,
                              JSValueConst val, int flags, int scope_idx);
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...);
+JSValue PLATFORM_PRINTF_LIKE(2, 3) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...);
 static __maybe_unused void JS_DumpAtoms(JSRuntime *rt);
-static __maybe_unused void JS_DumpString(JSRuntime *rt, const JSString *p);
+static __maybe_unused void JS_DumpString(JSRuntime *rt,
+                                                  const JSString *p);
 static __maybe_unused void JS_DumpObjectHeader(JSRuntime *rt);
 static __maybe_unused void JS_DumpObject(JSRuntime *rt, JSObject *p);
 static __maybe_unused void JS_DumpGCObject(JSRuntime *rt, JSGCObjectHeader *p);
-static __maybe_unused void JS_DumpValueShort(JSRuntime *rt, JSValueConst val);
+static __maybe_unused void JS_DumpValueShort(JSRuntime *rt,
+                                                      JSValueConst val);
 static __maybe_unused void JS_DumpValue(JSContext *ctx, JSValueConst val);
 static __maybe_unused void JS_PrintValue(JSContext *ctx,
                                                   const char *str,
@@ -1056,11 +1040,14 @@
 static JSValue js_function_apply(JSContext *ctx, JSValueConst this_val,
                                  int argc, JSValueConst *argv, int magic);
 static void js_array_finalizer(JSRuntime *rt, JSValue val);
-static void js_array_mark(JSRuntime *rt, JSValueConst val, JS_MarkFunc *mark_func);
+static void js_array_mark(JSRuntime *rt, JSValueConst val,
+                          JS_MarkFunc *mark_func);
 static void js_object_data_finalizer(JSRuntime *rt, JSValue val);
-static void js_object_data_mark(JSRuntime *rt, JSValueConst val, JS_MarkFunc *mark_func);
+static void js_object_data_mark(JSRuntime *rt, JSValueConst val,
+                                JS_MarkFunc *mark_func);
 static void js_c_function_finalizer(JSRuntime *rt, JSValue val);
-static void js_c_function_mark(JSRuntime *rt, JSValueConst val, JS_MarkFunc *mark_func);
+static void js_c_function_mark(JSRuntime *rt, JSValueConst val,
+                               JS_MarkFunc *mark_func);
 static void js_bytecode_function_finalizer(JSRuntime *rt, JSValue val);
 static void js_bytecode_function_mark(JSRuntime *rt, JSValueConst val,
                                 JS_MarkFunc *mark_func);
@@ -1104,12 +1091,6 @@
 static void js_operator_set_mark(JSRuntime *rt, JSValueConst val,
                                  JS_MarkFunc *mark_func);
 #endif
-
-#define HINT_STRING  0
-#define HINT_NUMBER  1
-#define HINT_NONE    2
-#define HINT_FORCE_ORDINARY (1 << 4) // don't try Symbol.toPrimitive
-static JSValue JS_ToPrimitiveFree(JSContext *ctx, JSValue val, int hint);
 static JSValue JS_ToStringFree(JSContext *ctx, JSValue val);
 static int JS_ToBoolFree(JSContext *ctx, JSValue val);
 static int JS_ToInt32Free(JSContext *ctx, int32_t *pres, JSValue val);
@@ -1194,17 +1175,11 @@
                                           JSValueConst this_val,
                                           int argc, JSValueConst *argv,
                                           int classid);
-static JSValue js_typed_array_constructor_ta(JSContext *ctx,
-                                             JSValueConst new_target,
-                                             JSValueConst src_obj,
-                                             int classid);
 static BOOL typed_array_is_detached(JSContext *ctx, JSObject *p);
 static uint32_t typed_array_get_length(JSContext *ctx, JSObject *p);
 static JSValue JS_ThrowTypeErrorDetachedArrayBuffer(JSContext *ctx);
 static JSVarRef *get_var_ref(JSContext *ctx, JSStackFrame *sf, int var_idx,
                              BOOL is_arg);
-static void __async_func_free(JSRuntime *rt, JSAsyncFunctionState *s);
-static void async_func_free(JSRuntime *rt, JSAsyncFunctionState *s);
 static JSValue js_generator_function_call(JSContext *ctx, JSValueConst func_obj,
                                           JSValueConst this_obj,
                                           int argc, JSValueConst *argv,
@@ -1230,8 +1205,6 @@
                                             JSValueConst *cap_resolving_funcs);
 static JSValue js_promise_resolve(JSContext *ctx, JSValueConst this_val,
                                   int argc, JSValueConst *argv, int magic);
-static JSValue js_promise_then(JSContext *ctx, JSValueConst this_val,
-                               int argc, JSValueConst *argv);
 static int js_string_compare(JSContext *ctx,
                              const JSString *p1, const JSString *p2);
 static JSValue JS_ToNumber(JSContext *ctx, JSValueConst val);
@@ -1243,6 +1216,8 @@
 static int JS_GetOwnPropertyInternal(JSContext *ctx, JSPropertyDescriptor *desc,
                                      JSObject *p, JSAtom prop);
 static void js_free_desc(JSContext *ctx, JSPropertyDescriptor *desc);
+static void async_func_mark(JSRuntime *rt, JSAsyncFunctionState *s,
+                            JS_MarkFunc *mark_func);
 static void JS_AddIntrinsicBasicObjects(JSContext *ctx);
 static void js_free_shape(JSRuntime *rt, JSShape *sh);
 static void js_free_shape_null(JSRuntime *rt, JSShape *sh);
@@ -1270,14 +1245,13 @@
 static void add_gc_object(JSRuntime *rt, JSGCObjectHeader *h,
                           JSGCObjectTypeEnum type);
 static void remove_gc_object(JSGCObjectHeader *h);
+static void js_async_function_free0(JSRuntime *rt, JSAsyncFunctionData *s);
 static JSValue js_instantiate_prototype(JSContext *ctx, JSObject *p, JSAtom atom, void *opaque);
 static JSValue js_module_ns_autoinit(JSContext *ctx, JSObject *p, JSAtom atom,
                                  void *opaque);
 static JSValue JS_InstantiateFunctionListItem2(JSContext *ctx, JSObject *p,
                                                JSAtom atom, void *opaque);
 void JS_SetUncatchableError(JSContext *ctx, JSValueConst val, BOOL flag);
-static JSValue js_object_groupBy(JSContext *ctx, JSValueConst this_val,
-                                 int argc, JSValueConst *argv, int is_map);
 
 static const JSClassExoticMethods js_arguments_exotic_methods;
 static const JSClassExoticMethods js_string_exotic_methods;
@@ -1461,10 +1435,6 @@
     return c >= '0' && c <= '9';
 }
 
-static inline int string_get(const JSString *p, int idx) {
-    return p->is_wide_char ? p->u.str16[idx] : p->u.str8[idx];
-}
-
 typedef struct JSClassShortDef {
     JSAtom class_name;
     JSClassFinalizer *finalizer;
@@ -1610,7 +1580,11 @@
 /* Note: OS and CPU dependent */
 static inline uintptr_t js_get_stack_pointer(void)
 {
+#if defined(PLATFORM_GNUC_LIKE)
     return (uintptr_t)__builtin_frame_address(0);
+#else
+    return 0;
+#endif
 }
 
 static inline BOOL js_check_stack_overflow(JSRuntime *rt, size_t alloca_size)
@@ -1699,19 +1673,19 @@
 }
 
 /* default memory allocation functions with memory limitation */
-static size_t js_def_malloc_usable_size(const void *ptr)
+static inline size_t js_def_malloc_usable_size(void *ptr)
 {
 #if defined(__APPLE__)
     return malloc_size(ptr);
 #elif defined(_WIN32)
-    return _msize((void *)ptr);
+    return _msize(ptr);
 #elif defined(EMSCRIPTEN)
     return 0;
 #elif defined(__linux__)
-    return malloc_usable_size((void *)ptr);
+    return malloc_usable_size(ptr);
 #else
     /* change this to `return 0;` if compilation fails */
-    return malloc_usable_size((void *)ptr);
+    return malloc_usable_size(ptr);
 #endif
 }
 
@@ -1775,7 +1749,18 @@
     js_def_malloc,
     js_def_free,
     js_def_realloc,
-    js_def_malloc_usable_size,
+#if defined(__APPLE__)
+    malloc_size,
+#elif defined(_WIN32)
+    (size_t (*)(const void *))_msize,
+#elif defined(EMSCRIPTEN)
+    NULL,
+#elif defined(__linux__)
+    (size_t (*)(const void *))malloc_usable_size,
+#else
+    /* change this to `NULL,` if compilation fails */
+    malloc_usable_size,
+#endif
 };
 
 JSRuntime *JS_NewRuntime(void)
@@ -2218,6 +2203,7 @@
 typedef enum JSFreeModuleEnum {
     JS_FREE_MODULE_ALL,
     JS_FREE_MODULE_NOT_RESOLVED,
+    JS_FREE_MODULE_NOT_EVALUATED,
 } JSFreeModuleEnum;
 
 /* XXX: would be more efficient with separate module lists */
@@ -2227,7 +2213,8 @@
     list_for_each_safe(el, el1, &ctx->loaded_modules) {
         JSModuleDef *m = list_entry(el, JSModuleDef, link);
         if (flag == JS_FREE_MODULE_ALL ||
-            (flag == JS_FREE_MODULE_NOT_RESOLVED && !m->resolved)) {
+            (flag == JS_FREE_MODULE_NOT_RESOLVED && !m->resolved) ||
+            (flag == JS_FREE_MODULE_NOT_EVALUATED && !m->evaluated)) {
             js_free_module_def(ctx, m);
         }
     }
@@ -2438,7 +2425,10 @@
     len = p->len;
     if (len == 0 || len > 10)
         return FALSE;
-    c = string_get(p, 0);
+    if (p->is_wide_char)
+        c = p->u.str16[0];
+    else
+        c = p->u.str8[0];
     if (is_num(c)) {
         if (c == '0') {
             if (len != 1)
@@ -2447,7 +2437,10 @@
         } else {
             n = c - '0';
             for(i = 1; i < len; i++) {
-                c = string_get(p, i);
+                if (p->is_wide_char)
+                    c = p->u.str16[i];
+                else
+                    c = p->u.str8[i];
                 if (!is_num(c))
                     return FALSE;
                 n64 = (uint64_t)n * 10 + (c - '0');
@@ -2492,35 +2485,35 @@
     return h;
 }
 
-static __maybe_unused void JS_DumpChar(JSRuntime *rt, int c, int sep)
+static __maybe_unused void JS_DumpString(JSRuntime *rt,
+                                                  const JSString *p)
 {
-    if (c == sep || c == '\\') {
-        putchar('\\');
-        putchar(c);
-    } else if (c >= ' ' && c <= 126) {
-        putchar(c);
-    } else if (c == '\n') {
-        putchar('\\');
-        putchar('n');
-    } else {
-        printf("\\u%04x", c);
-    }
-}
-
-static __maybe_unused void JS_DumpString(JSRuntime *rt, const JSString *p)
-{
-    int i, sep;
-
-    if (p == NULL) {
-        printf("<null>");
-        return;
+    int i, c, sep;
+
+    if (p == NULL) {
+        printf("<null>");
+        return;
+    }
+    printf("%d", p->header.ref_count);
+    sep = (p->header.ref_count == 1) ? '\"' : '\'';
+    putchar(sep);
+    for(i = 0; i < p->len; i++) {
+        if (p->is_wide_char)
+            c = p->u.str16[i];
+        else
+            c = p->u.str8[i];
+        if (c == sep || c == '\\') {
+            putchar('\\');
+            putchar(c);
+        } else if (c >= ' ' && c <= 126) {
+            putchar(c);
+        } else if (c == '\n') {
+            putchar('\\');
+            putchar('n');
+        } else {
+            printf("\\u%04x", c);
+        }
     }
-    printf("%d", p->header.ref_count);
-    sep = (p->header.ref_count == 1) ? '\"' : '\'';
-    putchar(sep);
-    for(i = 0; i < p->len; i++) {
-        JS_DumpChar(rt, string_get(p, i), sep);
-    }
     putchar(sep);
 }
 
@@ -2862,7 +2855,6 @@
     return __JS_NewAtom(rt, p, atom_type);
 }
 
-/* Warning: str must be ASCII only */
 static JSAtom __JS_FindAtom(JSRuntime *rt, const char *str, size_t len,
                             int atom_type)
 {
@@ -2957,13 +2949,11 @@
     return __JS_NewAtom(rt, p, JS_ATOM_TYPE_STRING);
 }
 
-/* str is UTF-8 encoded */
 JSAtom JS_NewAtomLen(JSContext *ctx, const char *str, size_t len)
 {
     JSValue val;
 
     if (len == 0 || !is_digit(*str)) {
-        // XXX: this will not work if UTF-8 encoded str contains non ASCII bytes
         JSAtom atom = __JS_FindAtom(ctx->rt, str, len, JS_ATOM_TYPE_STRING);
         if (atom)
             return atom;
@@ -3069,7 +3059,10 @@
                         return (const char *)str->u.str8;
                 }
                 for(i = 0; i < str->len; i++) {
-                    c = string_get(str, i);
+                    if (str->is_wide_char)
+                        c = str->u.str16[i];
+                    else
+                        c = str->u.str8[i];
                     if ((q - buf) >= buf_size - UTF8_CHAR_LEN_MAX)
                         break;
                     if (c < 128) {
@@ -3376,34 +3369,27 @@
 
 /* JSClass support */
 
-#ifdef CONFIG_ATOMICS
-static pthread_mutex_t js_class_id_mutex = PTHREAD_MUTEX_INITIALIZER;
-#endif
-
 /* a new class ID is allocated if *pclass_id != 0 */
 JSClassID JS_NewClassID(JSClassID *pclass_id)
 {
     JSClassID class_id;
-#ifdef CONFIG_ATOMICS
-    pthread_mutex_lock(&js_class_id_mutex);
-#endif
+    /* XXX: make it thread safe */
     class_id = *pclass_id;
     if (class_id == 0) {
         class_id = js_class_id_alloc++;
         *pclass_id = class_id;
     }
-#ifdef CONFIG_ATOMICS
-    pthread_mutex_unlock(&js_class_id_mutex);
-#endif
     return class_id;
 }
 
-JSClassID JS_GetClassID(JSValue v)
+JSClassID JS_GetClassID(JSValueConst v)
 {
     JSObject *p;
+
     if (JS_VALUE_GET_TAG(v) != JS_TAG_OBJECT)
-        return JS_INVALID_CLASS_ID;
+        return 0;
     p = JS_VALUE_GET_OBJ(v);
+    assert(p != 0);
     return p->class_id;
 }
 
@@ -3701,23 +3687,28 @@
 {
     if (unlikely(c >= 0x10000)) {
         /* surrogate pair */
-        if (string_buffer_putc16(s, get_hi_surrogate(c)))
+        c -= 0x10000;
+        if (string_buffer_putc16(s, (c >> 10) + 0xd800))
             return -1;
-        c = get_lo_surrogate(c);
+        c = (c & 0x3ff) + 0xdc00;
     }
     return string_buffer_putc16(s, c);
 }
 
+static int string_get(const JSString *p, int idx) {
+    return p->is_wide_char ? p->u.str16[idx] : p->u.str8[idx];
+}
+
 static int string_getc(const JSString *p, int *pidx)
 {
     int idx, c, c1;
     idx = *pidx;
     if (p->is_wide_char) {
         c = p->u.str16[idx++];
-        if (is_hi_surrogate(c) && idx < p->len) {
+        if (c >= 0xd800 && c < 0xdc00 && idx < p->len) {
             c1 = p->u.str16[idx];
-            if (is_lo_surrogate(c1)) {
-                c = from_surrogate(c, c1);
+            if (c1 >= 0xdc00 && c1 < 0xe000) {
+                c = (((c & 0x3ff) << 10) | (c1 & 0x3ff)) + 0x10000;
                 idx++;
             }
         }
@@ -3915,8 +3906,9 @@
                 } else if (c <= 0x10FFFF) {
                     p = p_next;
                     /* surrogate pair */
-                    string_buffer_putc16(b, get_hi_surrogate(c));
-                    c = get_lo_surrogate(c);
+                    c -= 0x10000;
+                    string_buffer_putc16(b, (c >> 10) + 0xd800);
+                    c = (c & 0x3ff) + 0xdc00;
                 } else {
                     /* invalid char */
                     c = 0xfffd;
@@ -4054,12 +4046,13 @@
             if (c < 0x80) {
                 *q++ = c;
             } else {
-                if (is_hi_surrogate(c)) {
+                if (c >= 0xd800 && c < 0xdc00) {
                     if (pos < len && !cesu8) {
                         c1 = src[pos];
-                        if (is_lo_surrogate(c1)) {
+                        if (c1 >= 0xdc00 && c1 < 0xe000) {
                             pos++;
-                            c = from_surrogate(c, c1);
+                            /* surrogate pair */
+                            c = (((c & 0x3ff) << 10) | (c1 & 0x3ff)) + 0x10000;
                         } else {
                             /* Keep unmatched surrogate code points */
                             /* c = 0xfffd; */ /* error */
@@ -4092,7 +4085,7 @@
     if (!ptr)
         return;
     /* purposely removing constness */
-    p = container_of(ptr, JSString, u);
+    p = (JSString *)(void *)(ptr - offsetof(JSString, u));
     JS_FreeValue(ctx, JS_MKPTR(JS_TAG_STRING, p));
 }
 
@@ -4192,43 +4185,7 @@
     return JS_MKPTR(JS_TAG_STRING, p);
 }
 
-static BOOL JS_ConcatStringInPlace(JSContext *ctx, JSString *p1, JSValueConst op2) {
-    if (JS_VALUE_GET_TAG(op2) == JS_TAG_STRING) {
-        JSString *p2 = JS_VALUE_GET_STRING(op2);
-        size_t size1;
-
-        if (p2->len == 0)
-            return TRUE;
-        if (p1->header.ref_count != 1)
-            return FALSE;
-        size1 = js_malloc_usable_size(ctx, p1);
-        if (p1->is_wide_char) {
-            if (size1 >= sizeof(*p1) + ((p1->len + p2->len) << 1)) {
-                if (p2->is_wide_char) {
-                    memcpy(p1->u.str16 + p1->len, p2->u.str16, p2->len << 1);
-                    p1->len += p2->len;
-                    return TRUE;
-                } else {
-                    size_t i;
-                    for (i = 0; i < p2->len; i++) {
-                        p1->u.str16[p1->len++] = p2->u.str8[i];
-                    }
-                    return TRUE;
-                }
-            }
-        } else if (!p2->is_wide_char) {
-            if (size1 >= sizeof(*p1) + p1->len + p2->len + 1) {
-                memcpy(p1->u.str8 + p1->len, p2->u.str8, p2->len);
-                p1->len += p2->len;
-                p1->u.str8[p1->len] = '\0';
-                return TRUE;
-            }
-        }
-    }
-    return FALSE;
-}
-
-/* op1 and op2 are converted to strings. For convenience, op1 or op2 =
+/* op1 and op2 are converted to strings. For convience, op1 or op2 =
    JS_EXCEPTION are accepted and return JS_EXCEPTION.  */
 static JSValue JS_ConcatString(JSContext *ctx, JSValue op1, JSValue op2)
 {
@@ -4250,11 +4207,27 @@
         }
     }
     p1 = JS_VALUE_GET_STRING(op1);
-    if (JS_ConcatStringInPlace(ctx, p1, op2)) {
+    p2 = JS_VALUE_GET_STRING(op2);
+
+    /* XXX: could also check if p1 is empty */
+    if (p2->len == 0) {
+        goto ret_op1;
+    }
+    if (p1->header.ref_count == 1 && p1->is_wide_char == p2->is_wide_char
+    &&  js_malloc_usable_size(ctx, p1) >= sizeof(*p1) + ((p1->len + p2->len) << p2->is_wide_char) + 1 - p1->is_wide_char) {
+        /* Concatenate in place in available space at the end of p1 */
+        if (p1->is_wide_char) {
+            memcpy(p1->u.str16 + p1->len, p2->u.str16, p2->len << 1);
+            p1->len += p2->len;
+        } else {
+            memcpy(p1->u.str8 + p1->len, p2->u.str8, p2->len);
+            p1->len += p2->len;
+            p1->u.str8[p1->len] = '\0';
+        }
+    ret_op1:
         JS_FreeValue(ctx, op2);
         return op1;
     }
-    p2 = JS_VALUE_GET_STRING(op2);
     ret = JS_ConcatString1(ctx, p1, p2);
     JS_FreeValue(ctx, op1);
     JS_FreeValue(ctx, op2);
@@ -4491,7 +4464,6 @@
     JSShapeProperty *pr;
     void *sh_alloc;
     intptr_t h;
-    JSShape *old_sh;
 
     sh = *psh;
     new_size = max_int(count, sh->prop_size * 3 / 2);
@@ -4507,21 +4479,19 @@
     new_hash_size = sh->prop_hash_mask + 1;
     while (new_hash_size < new_size)
         new_hash_size = 2 * new_hash_size;
-    /* resize the property shapes. Using js_realloc() is not possible in
-       case the GC runs during the allocation */
-    old_sh = sh;
-    sh_alloc = js_malloc(ctx, get_shape_size(new_hash_size, new_size));
-    if (!sh_alloc)
-        return -1;
-    sh = get_shape_from_alloc(sh_alloc, new_hash_size);
-    list_del(&old_sh->header.link);
-    /* copy all the shape properties */
-    memcpy(sh, old_sh,
-           sizeof(JSShape) + sizeof(sh->prop[0]) * old_sh->prop_count);
-    list_add_tail(&sh->header.link, &ctx->rt->gc_obj_list);
-
-    if (new_hash_size != (sh->prop_hash_mask + 1)) {
-        /* resize the hash table and the properties */
+    if (new_hash_size != (sh->prop_hash_mask + 1)) {
+        JSShape *old_sh;
+        /* resize the hash table and the properties */
+        old_sh = sh;
+        sh_alloc = js_malloc(ctx, get_shape_size(new_hash_size, new_size));
+        if (!sh_alloc)
+            return -1;
+        sh = get_shape_from_alloc(sh_alloc, new_hash_size);
+        list_del(&old_sh->header.link);
+        /* copy all the fields and the properties */
+        memcpy(sh, old_sh,
+               sizeof(JSShape) + sizeof(sh->prop[0]) * old_sh->prop_count);
+        list_add_tail(&sh->header.link, &ctx->rt->gc_obj_list);
         new_hash_mask = new_hash_size - 1;
         sh->prop_hash_mask = new_hash_mask;
         memset(prop_hash_end(sh) - new_hash_size, 0,
@@ -4533,12 +4503,20 @@
                 prop_hash_end(sh)[-h - 1] = i + 1;
             }
         }
+        js_free(ctx, get_alloc_from_shape(old_sh));
     } else {
-        /* just copy the previous hash table */
-        memcpy(prop_hash_end(sh) - new_hash_size, prop_hash_end(old_sh) - new_hash_size,
-               sizeof(prop_hash_end(sh)[0]) * new_hash_size);
+        /* only resize the properties */
+        list_del(&sh->header.link);
+        sh_alloc = js_realloc(ctx, get_alloc_from_shape(sh),
+                              get_shape_size(new_hash_size, new_size));
+        if (unlikely(!sh_alloc)) {
+            /* insert again in the GC list */
+            list_add_tail(&sh->header.link, &ctx->rt->gc_obj_list);
+            return -1;
+        }
+        sh = get_shape_from_alloc(sh_alloc, new_hash_size);
+        list_add_tail(&sh->header.link, &ctx->rt->gc_obj_list);
     }
-    js_free(ctx, get_alloc_from_shape(old_sh));
     *psh = sh;
     sh->prop_size = new_size;
     return 0;
@@ -5268,12 +5246,10 @@
         if (--var_ref->header.ref_count == 0) {
             if (var_ref->is_detached) {
                 JS_FreeValueRT(rt, var_ref->value);
-            } else {
-                list_del(&var_ref->var_ref_link); /* still on the stack */
-                if (var_ref->async_func)
-                    async_func_free(rt, var_ref->async_func);
-            }
-            remove_gc_object(&var_ref->header);
+                remove_gc_object(&var_ref->header);
+            } else {
+                list_del(&var_ref->header.link); /* still on the stack */
+            }
             js_free_rt(rt, var_ref);
         }
     }
@@ -5371,7 +5347,7 @@
         if (var_refs) {
             for(i = 0; i < b->closure_var_count; i++) {
                 JSVarRef *var_ref = var_refs[i];
-                if (var_ref) {
+                if (var_ref && var_ref->is_detached) {
                     mark_func(rt, &var_ref->header);
                 }
             }
@@ -5413,15 +5389,7 @@
 {
     JSObject *p = JS_VALUE_GET_OBJ(val);
     JSForInIterator *it = p->u.for_in_iterator;
-    int i;
-
     JS_FreeValueRT(rt, it->obj);
-    if (!it->is_array) {
-        for(i = 0; i < it->atom_count; i++) {
-            JS_FreeAtomRT(rt, it->tab_atom[i].atom);
-        }
-        js_free_rt(rt, it->tab_atom);
-    }
     js_free_rt(rt, it);
 }
 
@@ -5488,9 +5456,6 @@
         break;
     case JS_GC_OBJ_TYPE_FUNCTION_BYTECODE:
         free_function_bytecode(rt, (JSFunctionBytecode *)gp);
-        break;
-    case JS_GC_OBJ_TYPE_ASYNC_FUNCTION:
-        __async_func_free(rt, (JSAsyncFunctionState *)gp);
         break;
     default:
         abort();
@@ -5650,9 +5615,11 @@
                             if (pr->u.getset.setter)
                                 mark_func(rt, &pr->u.getset.setter->header);
                         } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_VARREF) {
-                            /* Note: the tag does not matter
-                               provided it is a GC object */
-                            mark_func(rt, &pr->u.var_ref->header);
+                            if (pr->u.var_ref->is_detached) {
+                                /* Note: the tag does not matter
+                                   provided it is a GC object */
+                                mark_func(rt, &pr->u.var_ref->header);
+                            }
                         } else if ((prs->flags & JS_PROP_TMASK) == JS_PROP_AUTOINIT) {
                             js_autoinit_mark(rt, pr, mark_func);
                         }
@@ -5686,32 +5653,16 @@
     case JS_GC_OBJ_TYPE_VAR_REF:
         {
             JSVarRef *var_ref = (JSVarRef *)gp;
-            if (var_ref->is_detached) {
-                JS_MarkValue(rt, *var_ref->pvalue, mark_func);
-            } else if (var_ref->async_func) {
-                mark_func(rt, &var_ref->async_func->header);
-            }
+            /* only detached variable referenced are taken into account */
+            assert(var_ref->is_detached);
+            JS_MarkValue(rt, *var_ref->pvalue, mark_func);
         }
         break;
     case JS_GC_OBJ_TYPE_ASYNC_FUNCTION:
         {
-            JSAsyncFunctionState *s = (JSAsyncFunctionState *)gp;
-            JSStackFrame *sf = &s->frame;
-            JSValue *sp;
-
-            if (!s->is_completed) {
-                JS_MarkValue(rt, sf->cur_func, mark_func);
-                JS_MarkValue(rt, s->this_val, mark_func);
-                /* sf->cur_sp = NULL if the function is running */
-                if (sf->cur_sp) {
-                    /* if the function is running, cur_sp is not known so we
-                       cannot mark the stack. Marking the variables is not needed
-                       because a running function cannot be part of a removable
-                       cycle */
-                    for(sp = sf->arg_buf; sp < sf->cur_sp; sp++)
-                        JS_MarkValue(rt, *sp, mark_func);
-                }
-            }
+            JSAsyncFunctionData *s = (JSAsyncFunctionData *)gp;
+            if (s->is_active)
+                async_func_mark(rt, &s->func_state, mark_func);
             JS_MarkValue(rt, s->resolving_funcs[0], mark_func);
             JS_MarkValue(rt, s->resolving_funcs[1], mark_func);
         }
@@ -5819,13 +5770,12 @@
         if (el == &rt->tmp_obj_list)
             break;
         p = list_entry(el, JSGCObjectHeader, link);
-        /* Only need to free the GC object associated with JS values
-           or async functions. The rest will be automatically removed
-           because they must be referenced by them. */
+        /* Only need to free the GC object associated with JS
+           values. The rest will be automatically removed because they
+           must be referenced by them. */
         switch(p->gc_obj_type) {
         case JS_GC_OBJ_TYPE_JS_OBJECT:
         case JS_GC_OBJ_TYPE_FUNCTION_BYTECODE:
-        case JS_GC_OBJ_TYPE_ASYNC_FUNCTION:
 #ifdef DUMP_GC_FREE
             if (!header_done) {
                 printf("Freeing cycles:\n");
@@ -5847,8 +5797,7 @@
     list_for_each_safe(el, el1, &rt->gc_zero_ref_count_list) {
         p = list_entry(el, JSGCObjectHeader, link);
         assert(p->gc_obj_type == JS_GC_OBJ_TYPE_JS_OBJECT ||
-               p->gc_obj_type == JS_GC_OBJ_TYPE_FUNCTION_BYTECODE ||
-               p->gc_obj_type == JS_GC_OBJ_TYPE_ASYNC_FUNCTION);
+               p->gc_obj_type == JS_GC_OBJ_TYPE_FUNCTION_BYTECODE);
         js_free_rt(rt, p);
     }
 
@@ -6255,7 +6204,7 @@
             "BigNum "
 #endif
             CONFIG_VERSION " version, %d-bit, malloc limit: %"PRId64"\n\n",
-            (int)sizeof(void *) * 8, s->malloc_limit);
+            (int)sizeof(void *) * 8, (int64_t)(ssize_t)s->malloc_limit);
 #if 1
     if (rt) {
         static const struct {
@@ -6301,10 +6250,10 @@
             if (obj_classes[0])
                 fprintf(fp, "  %5d  %2.0d %s\n", obj_classes[0], 0, "none");
             for (class_id = 1; class_id < JS_CLASS_INIT_COUNT; class_id++) {
-                if (obj_classes[class_id] && class_id < rt->class_count) {
+                if (obj_classes[class_id]) {
                     char buf[ATOM_GET_STR_BUF_SIZE];
                     fprintf(fp, "  %5d  %2.0d %s\n", obj_classes[class_id], class_id,
-                            JS_AtomGetStrRT(rt, buf, sizeof(buf), rt->class_array[class_id].class_name));
+                            JS_AtomGetStrRT(rt, buf, sizeof(buf), js_std_class_def[class_id - 1].class_name));
                 }
             }
             if (obj_classes[JS_CLASS_INIT_COUNT])
@@ -6664,7 +6613,7 @@
     return JS_ThrowError2(ctx, error_num, fmt, ap, add_backtrace);
 }
 
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowSyntaxError(JSContext *ctx, const char *fmt, ...)
+JSValue PLATFORM_PRINTF_LIKE(2, 3) JS_ThrowSyntaxError(JSContext *ctx, const char *fmt, ...)
 {
     JSValue val;
     va_list ap;
@@ -6675,7 +6624,7 @@
     return val;
 }
 
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowTypeError(JSContext *ctx, const char *fmt, ...)
+JSValue PLATFORM_PRINTF_LIKE(2, 3) JS_ThrowTypeError(JSContext *ctx, const char *fmt, ...)
 {
     JSValue val;
     va_list ap;
@@ -6686,7 +6635,7 @@
     return val;
 }
 
-static int __attribute__((format(printf, 3, 4))) JS_ThrowTypeErrorOrFalse(JSContext *ctx, int flags, const char *fmt, ...)
+static int PLATFORM_PRINTF_LIKE(3, 4) JS_ThrowTypeErrorOrFalse(JSContext *ctx, int flags, const char *fmt, ...)
 {
     va_list ap;
 
@@ -6702,7 +6651,7 @@
 }
 
 /* never use it directly */
-static JSValue __attribute__((format(printf, 3, 4))) __JS_ThrowTypeErrorAtom(JSContext *ctx, JSAtom atom, const char *fmt, ...)
+static JSValue PLATFORM_PRINTF_LIKE(3, 4) __JS_ThrowTypeErrorAtom(JSContext *ctx, JSAtom atom, const char *fmt, ...)
 {
     char buf[ATOM_GET_STR_BUF_SIZE];
     return JS_ThrowTypeError(ctx, fmt,
@@ -6710,7 +6659,7 @@
 }
 
 /* never use it directly */
-static JSValue __attribute__((format(printf, 3, 4))) __JS_ThrowSyntaxErrorAtom(JSContext *ctx, JSAtom atom, const char *fmt, ...)
+static JSValue PLATFORM_PRINTF_LIKE(3, 4) __JS_ThrowSyntaxErrorAtom(JSContext *ctx, JSAtom atom, const char *fmt, ...)
 {
     char buf[ATOM_GET_STR_BUF_SIZE];
     return JS_ThrowSyntaxError(ctx, fmt,
@@ -6733,7 +6682,7 @@
     }
 }
 
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowReferenceError(JSContext *ctx, const char *fmt, ...)
+JSValue PLATFORM_PRINTF_LIKE(2, 3) JS_ThrowReferenceError(JSContext *ctx, const char *fmt, ...)
 {
     JSValue val;
     va_list ap;
@@ -6744,7 +6693,7 @@
     return val;
 }
 
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowRangeError(JSContext *ctx, const char *fmt, ...)
+JSValue PLATFORM_PRINTF_LIKE(2, 3) JS_ThrowRangeError(JSContext *ctx, const char *fmt, ...)
 {
     JSValue val;
     va_list ap;
@@ -6755,7 +6704,7 @@
     return val;
 }
 
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...)
+JSValue PLATFORM_PRINTF_LIKE(2, 3) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...)
 {
     JSValue val;
     va_list ap;
@@ -7302,7 +7251,7 @@
         JS_ThrowTypeErrorNotASymbol(ctx);
         goto fail;
     }
-    prop = js_symbol_to_atom(ctx, (JSValue)name);
+    prop = js_symbol_to_atom(ctx, name);
     p = JS_VALUE_GET_OBJ(obj);
     prs = find_own_property(&pr, p, prop);
     if (prs) {
@@ -7333,7 +7282,7 @@
     /* safety check */
     if (unlikely(JS_VALUE_GET_TAG(name) != JS_TAG_SYMBOL))
         return JS_ThrowTypeErrorNotASymbol(ctx);
-    prop = js_symbol_to_atom(ctx, (JSValue)name);
+    prop = js_symbol_to_atom(ctx, name);
     p = JS_VALUE_GET_OBJ(obj);
     prs = find_own_property(&pr, p, prop);
     if (!prs) {
@@ -7360,7 +7309,7 @@
         JS_ThrowTypeErrorNotASymbol(ctx);
         goto fail;
     }
-    prop = js_symbol_to_atom(ctx, (JSValue)name);
+    prop = js_symbol_to_atom(ctx, name);
     p = JS_VALUE_GET_OBJ(obj);
     prs = find_own_property(&pr, p, prop);
     if (!prs) {
@@ -7373,8 +7322,6 @@
     return 0;
 }
 
-/* add a private brand field to 'home_obj' if not already present and
-   if obj is != null add a private brand to it */
 static int JS_AddBrand(JSContext *ctx, JSValueConst obj, JSValueConst home_obj)
 {
     JSObject *p, *p1;
@@ -7390,10 +7337,10 @@
     p = JS_VALUE_GET_OBJ(home_obj);
     prs = find_own_property(&pr, p, JS_ATOM_Private_brand);
     if (!prs) {
-        /* if the brand is not present, add it */
         brand = JS_NewSymbolFromAtom(ctx, JS_ATOM_brand, JS_ATOM_TYPE_PRIVATE);
         if (JS_IsException(brand))
             return -1;
+        /* if the brand is not present, add it */
         pr = add_property(ctx, p, JS_ATOM_Private_brand, JS_PROP_C_W_E);
         if (!pr) {
             JS_FreeValue(ctx, brand);
@@ -7405,27 +7352,20 @@
     }
     brand_atom = js_symbol_to_atom(ctx, brand);
 
-    if (JS_IsObject(obj)) {
-        p1 = JS_VALUE_GET_OBJ(obj);
-        prs = find_own_property(&pr, p1, brand_atom);
-        if (unlikely(prs)) {
-            JS_FreeAtom(ctx, brand_atom);
-            JS_ThrowTypeError(ctx, "private method is already present");
-            return -1;
-        }
-        pr = add_property(ctx, p1, brand_atom, JS_PROP_C_W_E);
-        JS_FreeAtom(ctx, brand_atom);
-        if (!pr)
-            return -1;
-        pr->u.value = JS_UNDEFINED;
-    } else {
-        JS_FreeAtom(ctx, brand_atom);
-    }
+    if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)) {
+        JS_ThrowTypeErrorNotAnObject(ctx);
+        JS_FreeAtom(ctx, brand_atom);
+        return -1;
+    }
+    p1 = JS_VALUE_GET_OBJ(obj);
+    pr = add_property(ctx, p1, brand_atom, JS_PROP_C_W_E);
+    JS_FreeAtom(ctx, brand_atom);
+    if (!pr)
+        return -1;
+    pr->u.value = JS_UNDEFINED;
     return 0;
 }
 
-/* return a boolean telling if the brand of the home object of 'func'
-   is present on 'obj' or -1 in case of exception */
 static int JS_CheckBrand(JSContext *ctx, JSValueConst obj, JSValueConst func)
 {
     JSObject *p, *p1, *home_obj;
@@ -7434,8 +7374,11 @@
     JSValueConst brand;
 
     /* get the home object of 'func' */
-    if (unlikely(JS_VALUE_GET_TAG(func) != JS_TAG_OBJECT))
-        goto not_obj;
+    if (unlikely(JS_VALUE_GET_TAG(func) != JS_TAG_OBJECT)) {
+    not_obj:
+        JS_ThrowTypeErrorNotAnObject(ctx);
+        return -1;
+    }
     p1 = JS_VALUE_GET_OBJ(func);
     if (!js_class_has_bytecode(p1->class_id))
         goto not_obj;
@@ -7453,14 +7396,15 @@
         goto not_obj;
 
     /* get the brand array of 'obj' */
-    if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)) {
-    not_obj:
-        JS_ThrowTypeErrorNotAnObject(ctx);
+    if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT))
+        goto not_obj;
+    p = JS_VALUE_GET_OBJ(obj);
+    prs = find_own_property(&pr, p, js_symbol_to_atom(ctx, brand));
+    if (!prs) {
+        JS_ThrowTypeError(ctx, "invalid brand on object");
         return -1;
     }
-    p = JS_VALUE_GET_OBJ(obj);
-    prs = find_own_property(&pr, p, js_symbol_to_atom(ctx, (JSValue)brand));
-    return (prs != NULL);
+    return 0;
 }
 
 static uint32_t js_string_obj_get_length(JSContext *ctx,
@@ -7917,45 +7861,37 @@
     if (likely(JS_VALUE_GET_TAG(this_obj) == JS_TAG_OBJECT &&
                JS_VALUE_GET_TAG(prop) == JS_TAG_INT)) {
         JSObject *p;
-        uint32_t idx;
+        uint32_t idx, len;
         /* fast path for array access */
         p = JS_VALUE_GET_OBJ(this_obj);
         idx = JS_VALUE_GET_INT(prop);
+        len = (uint32_t)p->u.array.count;
+        if (unlikely(idx >= len))
+            goto slow_path;
         switch(p->class_id) {
         case JS_CLASS_ARRAY:
         case JS_CLASS_ARGUMENTS:
-            if (unlikely(idx >= p->u.array.count)) goto slow_path;
             return JS_DupValue(ctx, p->u.array.u.values[idx]);
         case JS_CLASS_INT8_ARRAY:
-            if (unlikely(idx >= p->u.array.count)) goto slow_path;
             return JS_NewInt32(ctx, p->u.array.u.int8_ptr[idx]);
         case JS_CLASS_UINT8C_ARRAY:
         case JS_CLASS_UINT8_ARRAY:
-            if (unlikely(idx >= p->u.array.count)) goto slow_path;
             return JS_NewInt32(ctx, p->u.array.u.uint8_ptr[idx]);
         case JS_CLASS_INT16_ARRAY:
-            if (unlikely(idx >= p->u.array.count)) goto slow_path;
             return JS_NewInt32(ctx, p->u.array.u.int16_ptr[idx]);
         case JS_CLASS_UINT16_ARRAY:
-            if (unlikely(idx >= p->u.array.count)) goto slow_path;
             return JS_NewInt32(ctx, p->u.array.u.uint16_ptr[idx]);
         case JS_CLASS_INT32_ARRAY:
-            if (unlikely(idx >= p->u.array.count)) goto slow_path;
             return JS_NewInt32(ctx, p->u.array.u.int32_ptr[idx]);
         case JS_CLASS_UINT32_ARRAY:
-            if (unlikely(idx >= p->u.array.count)) goto slow_path;
             return JS_NewUint32(ctx, p->u.array.u.uint32_ptr[idx]);
         case JS_CLASS_BIG_INT64_ARRAY:
-            if (unlikely(idx >= p->u.array.count)) goto slow_path;
             return JS_NewBigInt64(ctx, p->u.array.u.int64_ptr[idx]);
         case JS_CLASS_BIG_UINT64_ARRAY:
-            if (unlikely(idx >= p->u.array.count)) goto slow_path;
             return JS_NewBigUint64(ctx, p->u.array.u.uint64_ptr[idx]);
         case JS_CLASS_FLOAT32_ARRAY:
-            if (unlikely(idx >= p->u.array.count)) goto slow_path;
             return __JS_NewFloat64(ctx, p->u.array.u.float_ptr[idx]);
         case JS_CLASS_FLOAT64_ARRAY:
-            if (unlikely(idx >= p->u.array.count)) goto slow_path;
             return __JS_NewFloat64(ctx, p->u.array.u.double_ptr[idx]);
         default:
             goto slow_path;
@@ -8373,30 +8309,6 @@
     return TRUE;
 }
 
-/* Allocate a new fast array. Its 'length' property is set to zero. It
-   maximum size is 2^31-1 elements. For convenience, 'len' is a 64 bit
-   integer. WARNING: the content of the array is not initialized. */
-static JSValue js_allocate_fast_array(JSContext *ctx, int64_t len)
-{
-    JSValue arr;
-    JSObject *p;
-
-    if (len > INT32_MAX)
-        return JS_ThrowRangeError(ctx, "invalid array length");
-    arr = JS_NewArray(ctx);
-    if (JS_IsException(arr))
-        return arr;
-    if (len > 0) {
-        p = JS_VALUE_GET_OBJ(arr);
-        if (expand_fast_array(ctx, p, len) < 0) {
-            JS_FreeValue(ctx, arr);
-            return JS_EXCEPTION;
-        }
-        p->u.array.count = len;
-    }
-    return arr;
-}
-
 static void js_free_desc(JSContext *ctx, JSPropertyDescriptor *desc)
 {
     JS_FreeValue(ctx, desc->getter);
@@ -8404,14 +8316,119 @@
     JS_FreeValue(ctx, desc->value);
 }
 
+/* generic (and slower) version of JS_SetProperty() for
+ * Reflect.set(). 'obj' must be an object.  */
+static int JS_SetPropertyGeneric(JSContext *ctx,
+                                 JSValueConst obj, JSAtom prop,
+                                 JSValue val, JSValueConst this_obj,
+                                 int flags)
+{
+    int ret;
+    JSPropertyDescriptor desc;
+    JSValue obj1;
+    JSObject *p;
+
+    obj1 = JS_DupValue(ctx, obj);
+    for(;;) {
+        p = JS_VALUE_GET_OBJ(obj1);
+        if (p->is_exotic) {
+            const JSClassExoticMethods *em = ctx->rt->class_array[p->class_id].exotic;
+            if (em && em->set_property) {
+                ret = em->set_property(ctx, obj1, prop,
+                                       val, this_obj, flags);
+                JS_FreeValue(ctx, obj1);
+                JS_FreeValue(ctx, val);
+                return ret;
+            }
+        }
+
+        ret = JS_GetOwnPropertyInternal(ctx, &desc, p, prop);
+        if (ret < 0) {
+            JS_FreeValue(ctx, obj1);
+            JS_FreeValue(ctx, val);
+            return ret;
+        }
+        if (ret) {
+            if (desc.flags & JS_PROP_GETSET) {
+                JSObject *setter;
+                if (JS_IsUndefined(desc.setter))
+                    setter = NULL;
+                else
+                    setter = JS_VALUE_GET_OBJ(desc.setter);
+                ret = call_setter(ctx, setter, this_obj, val, flags);
+                JS_FreeValue(ctx, desc.getter);
+                JS_FreeValue(ctx, desc.setter);
+                JS_FreeValue(ctx, obj1);
+                return ret;
+            } else {
+                JS_FreeValue(ctx, desc.value);
+                if (!(desc.flags & JS_PROP_WRITABLE)) {
+                    JS_FreeValue(ctx, obj1);
+                    goto read_only_error;
+                }
+            }
+            break;
+        }
+        /* Note: at this point 'obj1' cannot be a proxy. XXX: may have
+           to check recursion */
+        obj1 = JS_GetPrototypeFree(ctx, obj1);
+        if (JS_IsNull(obj1))
+            break;
+    }
+    JS_FreeValue(ctx, obj1);
+
+    if (!JS_IsObject(this_obj)) {
+        JS_FreeValue(ctx, val);
+        return JS_ThrowTypeErrorOrFalse(ctx, flags, "receiver is not an object");
+    }
+
+    p = JS_VALUE_GET_OBJ(this_obj);
+
+    /* modify the property in this_obj if it already exists */
+    ret = JS_GetOwnPropertyInternal(ctx, &desc, p, prop);
+    if (ret < 0) {
+        JS_FreeValue(ctx, val);
+        return ret;
+    }
+    if (ret) {
+        if (desc.flags & JS_PROP_GETSET) {
+            JS_FreeValue(ctx, desc.getter);
+            JS_FreeValue(ctx, desc.setter);
+            JS_FreeValue(ctx, val);
+            return JS_ThrowTypeErrorOrFalse(ctx, flags, "setter is forbidden");
+        } else {
+            JS_FreeValue(ctx, desc.value);
+            if (!(desc.flags & JS_PROP_WRITABLE) ||
+                p->class_id == JS_CLASS_MODULE_NS) {
+            read_only_error:
+                JS_FreeValue(ctx, val);
+                return JS_ThrowTypeErrorReadOnly(ctx, flags, prop);
+            }
+        }
+        ret = JS_DefineProperty(ctx, this_obj, prop, val,
+                                JS_UNDEFINED, JS_UNDEFINED,
+                                JS_PROP_HAS_VALUE);
+        JS_FreeValue(ctx, val);
+        return ret;
+    }
+
+    ret = JS_CreateProperty(ctx, p, prop, val, JS_UNDEFINED, JS_UNDEFINED,
+                            flags |
+                            JS_PROP_HAS_VALUE |
+                            JS_PROP_HAS_ENUMERABLE |
+                            JS_PROP_HAS_WRITABLE |
+                            JS_PROP_HAS_CONFIGURABLE |
+                            JS_PROP_C_W_E);
+    JS_FreeValue(ctx, val);
+    return ret;
+}
+
 /* return -1 in case of exception or TRUE or FALSE. Warning: 'val' is
    freed by the function. 'flags' is a bitmask of JS_PROP_NO_ADD,
    JS_PROP_THROW or JS_PROP_THROW_STRICT. If JS_PROP_NO_ADD is set,
-   the new property is not added and an error is raised. 'this_obj' is
-   the receiver. If obj != this_obj, then obj must be an object
-   (Reflect.set case). */
-int JS_SetPropertyInternal(JSContext *ctx, JSValueConst obj,
-                           JSAtom prop, JSValue val, JSValueConst this_obj, int flags)
+   the new property is not added and an error is raised. */
+int JS_SetPropertyInternal(JSContext *ctx, JSValueConst this_obj,
+                           JSAtom prop, JSValue val, int flags)
 {
     JSObject *p, *p1;
     JSShapeProperty *prs;
@@ -8424,37 +8441,25 @@
 #endif
     tag = JS_VALUE_GET_TAG(this_obj);
     if (unlikely(tag != JS_TAG_OBJECT)) {
-        if (JS_VALUE_GET_TAG(obj) == JS_TAG_OBJECT) {
-            p = NULL;
-            p1 = JS_VALUE_GET_OBJ(obj);
-            goto prototype_lookup;
-        } else {
-            switch(tag) {
-            case JS_TAG_NULL:
-                JS_FreeValue(ctx, val);
-                JS_ThrowTypeErrorAtom(ctx, "cannot set property '%s' of null", prop);
-                return -1;
-            case JS_TAG_UNDEFINED:
-                JS_FreeValue(ctx, val);
-                JS_ThrowTypeErrorAtom(ctx, "cannot set property '%s' of undefined", prop);
-                return -1;
-            default:
-                /* even on a primitive type we can have setters on the prototype */
-                p = NULL;
-                p1 = JS_VALUE_GET_OBJ(JS_GetPrototypePrimitive(ctx, obj));
-                goto prototype_lookup;
-            }
-        }
-    } else {
-        p = JS_VALUE_GET_OBJ(this_obj);
-        p1 = JS_VALUE_GET_OBJ(obj);
-        if (unlikely(p != p1))
-            goto retry2;
-    }
-
-    /* fast path if obj == this_obj */
- retry:
-    prs = find_own_property(&pr, p1, prop);
+        switch(tag) {
+        case JS_TAG_NULL:
+            JS_FreeValue(ctx, val);
+            JS_ThrowTypeErrorAtom(ctx, "cannot set property '%s' of null", prop);
+            return -1;
+        case JS_TAG_UNDEFINED:
+            JS_FreeValue(ctx, val);
+            JS_ThrowTypeErrorAtom(ctx, "cannot set property '%s' of undefined", prop);
+            return -1;
+        default:
+            /* even on a primitive type we can have setters on the prototype */
+            p = NULL;
+            p1 = JS_VALUE_GET_OBJ(JS_GetPrototypePrimitive(ctx, this_obj));
+            goto prototype_lookup;
+        }
+    }
+    p = JS_VALUE_GET_OBJ(this_obj);
+retry:
+    prs = find_own_property(&pr, p, prop);
     if (prs) {
         if (likely((prs->flags & (JS_PROP_TMASK | JS_PROP_WRITABLE |
                                   JS_PROP_LENGTH)) == JS_PROP_WRITABLE)) {
@@ -8487,6 +8492,7 @@
         }
     }
 
+    p1 = p;
     for(;;) {
         if (p1->is_exotic) {
             if (p1->fast_array) {
@@ -8510,19 +8516,11 @@
                             return -1;
                         }
                     typed_array_oob:
-                        /* must convert the argument even if out of bound access */
-                        if (p1->class_id == JS_CLASS_BIG_INT64_ARRAY ||
-                            p1->class_id == JS_CLASS_BIG_UINT64_ARRAY) {
-                            int64_t v;
-                            if (JS_ToBigInt64Free(ctx, &v, val))
-                                return -1;
-                        } else {
-                            val = JS_ToNumberFree(ctx, val);
-                            JS_FreeValue(ctx, val);
-                            if (JS_IsException(val))
-                                return -1;
-                        }
-                        return TRUE;
+                        val = JS_ToNumberFree(ctx, val);
+                        JS_FreeValue(ctx, val);
+                        if (JS_IsException(val))
+                            return -1;
+                        return JS_ThrowTypeErrorOrFalse(ctx, flags, "out-of-bound numeric index");
                     }
                 }
             } else {
@@ -8594,7 +8592,9 @@
                     return -1;
                 goto retry2;
             } else if (!(prs->flags & JS_PROP_WRITABLE)) {
-                goto read_only_prop;
+            read_only_prop:
+                JS_FreeValue(ctx, val);
+                return JS_ThrowTypeErrorReadOnly(ctx, flags, prop);
             }
         }
     }
@@ -8615,56 +8615,16 @@
         return JS_ThrowTypeErrorOrFalse(ctx, flags, "object is not extensible");
     }
 
-    if (likely(p == JS_VALUE_GET_OBJ(obj))) {
-        if (p->is_exotic) {
-            if (p->class_id == JS_CLASS_ARRAY && p->fast_array &&
-                __JS_AtomIsTaggedInt(prop)) {
-                uint32_t idx = __JS_AtomToUInt32(prop);
-                if (idx == p->u.array.count) {
-                    /* fast case */
-                    return add_fast_array_element(ctx, p, val, flags);
-                } else {
-                    goto generic_create_prop;
-                }
+    if (p->is_exotic) {
+        if (p->class_id == JS_CLASS_ARRAY && p->fast_array &&
+            __JS_AtomIsTaggedInt(prop)) {
+            uint32_t idx = __JS_AtomToUInt32(prop);
+            if (idx == p->u.array.count) {
+                /* fast case */
+                return add_fast_array_element(ctx, p, val, flags);
             } else {
                 goto generic_create_prop;
             }
-        } else {
-            pr = add_property(ctx, p, prop, JS_PROP_C_W_E);
-            if (unlikely(!pr)) {
-                JS_FreeValue(ctx, val);
-                return -1;
-            }
-            pr->u.value = val;
-            return TRUE;
-        }
-    } else {
-        /* generic case: modify the property in this_obj if it already exists */
-        ret = JS_GetOwnPropertyInternal(ctx, &desc, p, prop);
-        if (ret < 0) {
-            JS_FreeValue(ctx, val);
-            return ret;
-        }
-        if (ret) {
-            if (desc.flags & JS_PROP_GETSET) {
-                JS_FreeValue(ctx, desc.getter);
-                JS_FreeValue(ctx, desc.setter);
-                JS_FreeValue(ctx, val);
-                return JS_ThrowTypeErrorOrFalse(ctx, flags, "setter is forbidden");
-            } else {
-                JS_FreeValue(ctx, desc.value);
-                if (!(desc.flags & JS_PROP_WRITABLE) ||
-                    p->class_id == JS_CLASS_MODULE_NS) {
-                read_only_prop:
-                    JS_FreeValue(ctx, val);
-                    return JS_ThrowTypeErrorReadOnly(ctx, flags, prop);
-                }
-            }
-            ret = JS_DefineProperty(ctx, this_obj, prop, val,
-                                    JS_UNDEFINED, JS_UNDEFINED,
-                                    JS_PROP_HAS_VALUE);
-            JS_FreeValue(ctx, val);
-            return ret;
         } else {
         generic_create_prop:
             ret = JS_CreateProperty(ctx, p, prop, val, JS_UNDEFINED, JS_UNDEFINED,
@@ -8678,6 +8638,14 @@
             return ret;
         }
     }
+
+    pr = add_property(ctx, p, prop, JS_PROP_C_W_E);
+    if (unlikely(!pr)) {
+        JS_FreeValue(ctx, val);
+        return -1;
+    }
+    pr->u.value = val;
+    return TRUE;
 }
 
 /* flags can be JS_PROP_THROW or JS_PROP_THROW_STRICT */
@@ -8786,7 +8754,7 @@
                 return -1;
             if (unlikely(idx >= (uint32_t)p->u.array.count)) {
             ta_out_of_bound:
-                return TRUE;
+                return JS_ThrowTypeErrorOrFalse(ctx, flags, "out-of-bound numeric index");
             }
             p->u.array.u.double_ptr[idx] = d;
             break;
@@ -8804,7 +8772,7 @@
             JS_FreeValue(ctx, val);
             return -1;
         }
-        ret = JS_SetPropertyInternal(ctx, this_obj, atom, val, this_obj, flags);
+        ret = JS_SetPropertyInternal(ctx, this_obj, atom, val, flags);
         JS_FreeAtom(ctx, atom);
         return ret;
     }
@@ -8844,7 +8812,7 @@
     JSAtom atom;
     int ret;
     atom = JS_NewAtom(ctx, prop);
-    ret = JS_SetPropertyInternal(ctx, this_obj, atom, val, this_obj, JS_PROP_THROW);
+    ret = JS_SetPropertyInternal(ctx, this_obj, atom, val, JS_PROP_THROW);
     JS_FreeAtom(ctx, atom);
     return ret;
 }
@@ -9079,7 +9047,7 @@
                 return -1;
             }
             /* this code relies on the fact that Uint32 are never allocated */
-            val = (JSValueConst)JS_NewUint32(ctx, array_length);
+            val = JS_NewUint32(ctx, array_length);
             /* prs may have been modified */
             prs = find_own_property(&pr, p, prop);
             assert(prs != NULL);
@@ -9184,19 +9152,15 @@
                                spaces. */
                             if (!js_same_value(ctx, val, *pr->u.var_ref->pvalue))
                                 goto not_configurable;
-                        } else {
-                            /* update the reference */
-                            set_value(ctx, pr->u.var_ref->pvalue,
-                                      JS_DupValue(ctx, val));
-                        }
+                        }
+                        /* update the reference */
+                        set_value(ctx, pr->u.var_ref->pvalue,
+                                  JS_DupValue(ctx, val));
                     }
                     /* if writable is set to false, no longer a
                        reference (for mapped arguments) */
                     if ((flags & (JS_PROP_HAS_WRITABLE | JS_PROP_WRITABLE)) == JS_PROP_HAS_WRITABLE) {
                         JSValue val1;
-                        if (p->class_id == JS_CLASS_MODULE_NS) {
-                            return JS_ThrowTypeErrorOrFalse(ctx, flags, "module namespace properties have writable = false");
-                        }
                         if (js_shape_prepare_update(ctx, p, &prs))
                             return -1;
                         val1 = JS_DupValue(ctx, *pr->u.var_ref->pvalue);
@@ -9305,7 +9269,7 @@
             }
             idx = __JS_AtomToUInt32(prop);
             /* if the typed array is detached, p->u.array.count = 0 */
-            if (idx >= p->u.array.count) {
+            if (idx >= typed_array_get_length(ctx, p)) {
             typed_array_oob:
                 return JS_ThrowTypeErrorOrFalse(ctx, flags, "out-of-bound index in typed array");
             }
@@ -9699,7 +9663,7 @@
     flags = JS_PROP_THROW_STRICT;
     if (is_strict_mode(ctx))
         flags |= JS_PROP_NO_ADD;
-    return JS_SetPropertyInternal(ctx, ctx->global_obj, prop, val, ctx->global_obj, flags);
+    return JS_SetPropertyInternal(ctx, ctx->global_obj, prop, val, flags);
 }
 
 /* return -1, FALSE or TRUE. return FALSE if not configurable or
@@ -9855,6 +9819,12 @@
     return p;
 }
 
+#define HINT_STRING  0
+#define HINT_NUMBER  1
+#define HINT_NONE    2
+/* don't try Symbol.toPrimitive */
+#define HINT_FORCE_ORDINARY (1 << 4)
+
 static JSValue JS_ToPrimitiveFree(JSContext *ctx, JSValue val, int hint)
 {
     int i;
@@ -10051,13 +10021,12 @@
 }
 
 /* XXX: remove */
-static double js_strtod(const char *str, int radix, BOOL is_float)
+static double js_strtod(const char *p, int radix, BOOL is_float)
 {
     double d;
     int c;
 
     if (!is_float || radix != 10) {
-        const char *p = str;
         uint64_t n_max, n;
         int int_exp, is_neg;
 
@@ -10084,8 +10053,6 @@
             if (n <= n_max) {
                 n = n * radix + c;
             } else {
-                if (radix == 10)
-                    goto strtod_case;
                 int_exp++;
             }
             p++;
@@ -10097,8 +10064,7 @@
         if (is_neg)
             d = -d;
     } else {
-    strtod_case:
-        d = strtod(str, NULL);
+        d = strtod(p, NULL);
     }
     return d;
 }
@@ -10195,6 +10161,7 @@
     }
     return val;
 }
+
 #endif
 
 /* return an exception in case of memory error. Return JS_NAN if
@@ -10286,7 +10253,7 @@
             } else
 #endif
             {
-                double d = 1.0 / 0.0;
+                double d = INFINITY;
                 if (is_neg)
                     d = -d;
                 val = JS_NewFloat64(ctx, d);
@@ -10366,15 +10333,15 @@
             p++;
             atod_type = ATOD_TYPE_BIG_DECIMAL;
         } else if (flags & ATOD_MODE_BIGINT) {
-            if (!is_float)
-                atod_type = ATOD_TYPE_BIG_INT;
-            if (has_legacy_octal)
-                goto fail;
+                if (!is_float)
+                    atod_type = ATOD_TYPE_BIG_INT;
+                if (has_legacy_octal)
+                    goto fail;
         } else
 #endif
         {
-            if (is_float && radix != 10)
-                goto fail;
+                if (is_float && radix != 10)
+                    goto fail;
         }
     } else {
         if (atod_type == ATOD_TYPE_FLOAT64) {
@@ -10787,7 +10754,7 @@
             } else {
                 if (d < INT64_MIN)
                     *pres = INT64_MIN;
-                else if (d >= 0x1p63) /* must use INT64_MAX + 1 because INT64_MAX cannot be exactly represented as a double */
+                else if (d > INT64_MAX)
                     *pres = INT64_MAX;
                 else
                     *pres = (int64_t)d;
@@ -11079,8 +11046,6 @@
         if (JS_TAG_IS_FLOAT64(tag)) {
             double d;
             d = JS_VALUE_GET_FLOAT64(val);
-            if (!(d >= 0 && d <= UINT32_MAX))
-                goto fail;
             len = (uint32_t)d;
             if (len != d)
                 goto fail;
@@ -11331,8 +11296,6 @@
 #endif /* CONFIG_BIGNUM */
 
 /* 2 <= base <= 36 */
-static char const digits[36] = "0123456789abcdefghijklmnopqrstuvwxyz";
-
 static char *i64toa(char *buf_end, int64_t n, unsigned int base)
 {
     char *q = buf_end;
@@ -11344,20 +11307,15 @@
         n = -n;
     }
     *--q = '\0';
-    if (base == 10) {
-        /* division by known base uses multiplication */
-        do {
-            digit = (uint64_t)n % 10;
-            n = (uint64_t)n / 10;
-            *--q = '0' + digit;
-        } while (n != 0);
-    } else {
-        do {
-            digit = (uint64_t)n % base;
-            n = (uint64_t)n / base;
-            *--q = digits[digit];
-        } while (n != 0);
-    }
+    do {
+        digit = (uint64_t)n % base;
+        n = (uint64_t)n / base;
+        if (digit < 10)
+            digit += '0';
+        else
+            digit += 'a' - 10;
+        *--q = digit;
+    } while (n != 0);
     if (is_neg)
         *--q = '-';
     return q;
@@ -11447,20 +11405,20 @@
     return n_digits;
 }
 
-static int js_fcvt1(char (*buf)[JS_DTOA_BUF_SIZE], double d, int n_digits,
+static int js_fcvt1(char *buf, int buf_size, double d, int n_digits,
                     int rounding_mode)
 {
     int n;
     if (rounding_mode != FE_TONEAREST)
         fesetround(rounding_mode);
-    n = snprintf(*buf, sizeof(*buf), "%.*f", n_digits, d);
+    n = snprintf(buf, buf_size, "%.*f", n_digits, d);
     if (rounding_mode != FE_TONEAREST)
         fesetround(FE_TONEAREST);
-    assert(n < sizeof(*buf));
+    assert(n < buf_size);
     return n;
 }
 
-static void js_fcvt(char (*buf)[JS_DTOA_BUF_SIZE], double d, int n_digits)
+static void js_fcvt(char *buf, int buf_size, double d, int n_digits)
 {
     int rounding_mode;
     rounding_mode = FE_TONEAREST;
@@ -11474,12 +11432,12 @@
            zero (RNDNA), but in printf the "ties" case is not specified
            (for example it is RNDN for glibc, RNDNA for Windows), so we
            must round manually. */
-        n1 = js_fcvt1(&buf1, d, n_digits + 1, FE_TONEAREST);
+        n1 = js_fcvt1(buf1, sizeof(buf1), d, n_digits + 1, FE_TONEAREST);
         rounding_mode = FE_TONEAREST;
         /* XXX: could use 2 digits to reduce the average running time */
         if (buf1[n1 - 1] == '5') {
-            n1 = js_fcvt1(&buf1, d, n_digits + 1, FE_DOWNWARD);
-            n2 = js_fcvt1(&buf2, d, n_digits + 1, FE_UPWARD);
+            n1 = js_fcvt1(buf1, sizeof(buf1), d, n_digits + 1, FE_DOWNWARD);
+            n2 = js_fcvt1(buf2, sizeof(buf2), d, n_digits + 1, FE_UPWARD);
             if (n1 == n2 && memcmp(buf1, buf2, n1) == 0) {
                 /* exact result: round away from zero */
                 if (buf1[0] == '-')
@@ -11490,7 +11448,7 @@
         }
     }
 #endif /* CONFIG_PRINTF_RNDN */
-    js_fcvt1(buf, d, n_digits, rounding_mode);
+    js_fcvt1(buf, buf_size, d, n_digits, rounding_mode);
 }
 
 /* radix != 10 is only supported with flags = JS_DTOA_VAR_FORMAT */
@@ -11506,35 +11464,33 @@
 /* XXX: slow and maybe not fully correct. Use libbf when it is fast enough.
    XXX: radix != 10 is only supported for small integers
 */
-static void js_dtoa1(char (*buf)[JS_DTOA_BUF_SIZE], double d,
-                     int radix, int n_digits, int flags)
+static void js_dtoa1(char *buf, double d, int radix, int n_digits, int flags)
 {
     char *q;
 
     if (!isfinite(d)) {
         if (isnan(d)) {
-            pstrcpy(*buf, sizeof(*buf), "NaN");
-        } else if (d < 0) {
-            pstrcpy(*buf, sizeof(*buf), "-Infinity");
+            strcpy(buf, "NaN");
         } else {
-            pstrcpy(*buf, sizeof(*buf), "Infinity");
+            q = buf;
+            if (d < 0)
+                *q++ = '-';
+            strcpy(q, "Infinity");
         }
     } else if (flags == JS_DTOA_VAR_FORMAT) {
         int64_t i64;
         char buf1[70], *ptr;
-        if (d > (double)MAX_SAFE_INTEGER || d < (double)-MAX_SAFE_INTEGER)
-            goto generic_conv;
         i64 = (int64_t)d;
-        if (d != i64)
+        if (d != i64 || i64 > MAX_SAFE_INTEGER || i64 < -MAX_SAFE_INTEGER)
             goto generic_conv;
         /* fast path for integers */
         ptr = i64toa(buf1 + sizeof(buf1), i64, radix);
-        pstrcpy(*buf, sizeof(*buf), ptr);
+        strcpy(buf, ptr);
     } else {
         if (d == 0.0)
             d = 0.0; /* convert -0 to 0 */
         if (flags == JS_DTOA_FRAC_FORMAT) {
-            js_fcvt(buf, d, n_digits);
+            js_fcvt(buf, JS_DTOA_BUF_SIZE, d, n_digits);
         } else {
             char buf1[JS_DTOA_BUF_SIZE];
             int sign, decpt, k, n, i, p, n_max;
@@ -11549,7 +11505,7 @@
             /* the number has k digits (k >= 1) */
             k = js_ecvt(d, n_digits, &decpt, &sign, buf1, is_fixed);
             n = decpt; /* d=10^(n-k)*(buf1) i.e. d= < x.yyyy 10^(n-1) */
-            q = *buf;
+            q = buf;
             if (sign)
                 *q++ = '-';
             if (flags & JS_DTOA_FORCE_EXP)
@@ -11591,7 +11547,7 @@
                 p = n - 1;
                 if (p >= 0)
                     *q++ = '+';
-                snprintf(q, *buf + sizeof(*buf) - q, "%d", p);
+                sprintf(q, "%d", p);
             }
         }
     }
@@ -11601,84 +11557,10 @@
                        double d, int radix, int n_digits, int flags)
 {
     char buf[JS_DTOA_BUF_SIZE];
-    js_dtoa1(&buf, d, radix, n_digits, flags);
+    js_dtoa1(buf, d, radix, n_digits, flags);
     return JS_NewString(ctx, buf);
 }
 
-static JSValue js_dtoa_radix(JSContext *ctx, double d, int radix)
-{
-    char buf[2200], *ptr, *ptr2;
-    /* d is finite */
-    int sign = d < 0;
-    int digit;
-    double frac, d0;
-    int64_t n0 = 0;
-    d = fabs(d);
-    d0 = trunc(d);
-    frac = d - d0;
-    ptr = buf + 1100;
-    *ptr = '\0';
-    if (d0 <= MAX_SAFE_INTEGER) {
-        int64_t n = n0 = (int64_t)d0;
-        while (n >= radix) {
-            digit = n % radix;
-            n = n / radix;
-            *--ptr = digits[digit];
-        }
-        *--ptr = digits[(int)n];
-    } else {
-        /* no decimals */
-        while (d0 >= radix) {
-            digit = fmod(d0, radix);
-            d0 = trunc(d0 / radix);
-            if (d0 >= MAX_SAFE_INTEGER)
-                digit = 0;
-            *--ptr = digits[digit];
-        }
-        *--ptr = digits[(int)d0];
-        goto done;
-    }
-    if (frac != 0) {
-        double log2_radix = log2(radix);
-        double prec = 1023 + 51;  // handle subnormals
-        ptr2 = buf + 1100;
-        *ptr2++ = '.';
-        while (frac != 0 && n0 <= MAX_SAFE_INTEGER/2 && prec > 0) {
-            frac *= radix;
-            digit = trunc(frac);
-            frac -= digit;
-            *ptr2++ = digits[digit];
-            n0 = n0 * radix + digit;
-            prec -= log2_radix;
-        }
-        *ptr2 = '\0';
-        if (frac * radix >= radix / 2) {
-            char nine = digits[radix - 1];
-            // round to closest
-            while (ptr2[-1] == nine)
-                *--ptr2 = '\0';
-            if (ptr2[-1] == '.') {
-                *--ptr2 = '\0';
-                while (ptr2[-1] == nine)
-                    *--ptr2 = '0';
-            }
-            if (ptr2 - 1 == ptr)
-                *--ptr = '1';
-            else
-                ptr2[-1] += 1;
-        } else {
-            while (ptr2[-1] == '0')
-                *--ptr2 = '\0';
-            if (ptr2[-1] == '.')
-                *--ptr2 = '\0';
-        }
-    }
-done:
-    ptr[-1] = '-';
-    ptr -= sign;
-    return JS_NewString(ctx, ptr);
-}
-
 JSValue JS_ToStringInternal(JSContext *ctx, JSValueConst val, BOOL is_ToPropertyKey)
 {
     uint32_t tag;
@@ -11819,7 +11701,7 @@
                 goto fail;
             break;
         default:
-            if (c < 32 || is_surrogate(c)) {
+            if (c < 32 || (c >= 0xd800 && c < 0xe000)) {
                 snprintf(buf, sizeof(buf), "\\u%04x", c);
                 if (string_buffer_puts8(b, buf))
                     goto fail;
@@ -12831,7 +12713,7 @@
 }
 
 static int js_unary_arith_bigfloat(JSContext *ctx,
-                                   JSValue *pres, OPCodeEnum op, JSValue op1)
+                                 JSValue *pres, OPCodeEnum op, JSValue op1)
 {
     bf_t a_s, *r, *a;
     int ret, v;
@@ -12885,7 +12767,7 @@
 }
 
 static int js_unary_arith_bigdecimal(JSContext *ctx,
-                                     JSValue *pres, OPCodeEnum op, JSValue op1)
+                                   JSValue *pres, OPCodeEnum op, JSValue op1)
 {
     bfdec_t *r, *a;
     int ret, v;
@@ -12939,7 +12821,7 @@
 #endif /* CONFIG_BIGNUM */
 
 static int js_unary_arith_bigint(JSContext *ctx,
-                                 JSValue *pres, OPCodeEnum op, JSValue op1)
+                                     JSValue *pres, OPCodeEnum op, JSValue op1)
 {
     bf_t a_s, *r, *a;
     int ret, v;
@@ -13676,7 +13558,7 @@
               tag1 != JS_TAG_STRING))) {
             JSValue res;
             int ret = js_call_binary_op_fallback(ctx, &res, op1, op2, OP_add,
-                                                 FALSE, HINT_NONE);
+                                             FALSE, HINT_NONE);
             if (ret != 0) {
                 JS_FreeValue(ctx, op1);
                 JS_FreeValue(ctx, op2);
@@ -14605,43 +14487,6 @@
     sp[-2] = JS_NewBool(ctx, ret);
     return 0;
 }
-
-static __exception int js_operator_private_in(JSContext *ctx, JSValue *sp)
-{
-    JSValue op1, op2;
-    int ret;
-
-    op1 = sp[-2]; /* object */
-    op2 = sp[-1]; /* field name or method function */
-
-    if (JS_VALUE_GET_TAG(op1) != JS_TAG_OBJECT) {
-        JS_ThrowTypeError(ctx, "invalid 'in' operand");
-        return -1;
-    }
-    if (JS_IsObject(op2)) {
-        /* method: use the brand */
-        ret = JS_CheckBrand(ctx, op1, op2);
-        if (ret < 0)
-            return -1;
-    } else {
-        JSAtom atom;
-        JSObject *p;
-        JSShapeProperty *prs;
-        JSProperty *pr;
-        /* field */
-        atom = JS_ValueToAtom(ctx, op2);
-        if (unlikely(atom == JS_ATOM_NULL))
-            return -1;
-        p = JS_VALUE_GET_OBJ(op1);
-        prs = find_own_property(&pr, p, atom);
-        JS_FreeAtom(ctx, atom);
-        ret = (prs != NULL);
-    }
-    JS_FreeValue(ctx, op1);
-    JS_FreeValue(ctx, op2);
-    sp[-2] = JS_NewBool(ctx, ret);
-    return 0;
-}
 
 static __exception int js_has_unscopable(JSContext *ctx, JSValueConst obj,
                                          JSAtom atom)
@@ -14941,10 +14786,10 @@
 
 static JSValue build_for_in_iterator(JSContext *ctx, JSValue obj)
 {
-    JSObject *p, *p1;
+    JSObject *p;
     JSPropertyEnum *tab_atom;
     int i;
-    JSValue enum_obj;
+    JSValue enum_obj, obj1;
     JSForInIterator *it;
     uint32_t tag, tab_atom_count;
 
@@ -14967,16 +14812,40 @@
     it->is_array = FALSE;
     it->obj = obj;
     it->idx = 0;
-    it->tab_atom = NULL;
-    it->atom_count = 0;
-    it->in_prototype_chain = FALSE;
-    p1 = JS_VALUE_GET_OBJ(enum_obj);
-    p1->u.for_in_iterator = it;
+    p = JS_VALUE_GET_OBJ(enum_obj);
+    p->u.for_in_iterator = it;
 
     if (tag == JS_TAG_NULL || tag == JS_TAG_UNDEFINED)
         return enum_obj;
 
+    /* fast path: assume no enumerable properties in the prototype chain */
+    obj1 = JS_DupValue(ctx, obj);
+    for(;;) {
+        obj1 = JS_GetPrototypeFree(ctx, obj1);
+        if (JS_IsNull(obj1))
+            break;
+        if (JS_IsException(obj1))
+            goto fail;
+        if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count,
+                                           JS_VALUE_GET_OBJ(obj1),
+                                           JS_GPN_STRING_MASK | JS_GPN_ENUM_ONLY)) {
+            JS_FreeValue(ctx, obj1);
+            goto fail;
+        }
+        js_free_prop_enum(ctx, tab_atom, tab_atom_count);
+        if (tab_atom_count != 0) {
+            JS_FreeValue(ctx, obj1);
+            goto slow_path;
+        }
+        /* must check for timeout to avoid infinite loop */
+        if (js_poll_interrupts(ctx)) {
+            JS_FreeValue(ctx, obj1);
+            goto fail;
+        }
+    }
+
     p = JS_VALUE_GET_OBJ(obj);
+
     if (p->fast_array) {
         JSShape *sh;
         JSShapeProperty *prs;
@@ -14988,90 +14857,61 @@
         }
         /* for fast arrays, we only store the number of elements */
         it->is_array = TRUE;
-        it->atom_count = p->u.array.count;
+        it->array_length = p->u.array.count;
     } else {
     normal_case:
         if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count, p,
-                                           JS_GPN_STRING_MASK | JS_GPN_SET_ENUM)) {
-            JS_FreeValue(ctx, enum_obj);
-            return JS_EXCEPTION;
+                                   JS_GPN_STRING_MASK | JS_GPN_ENUM_ONLY))
+            goto fail;
+        for(i = 0; i < tab_atom_count; i++) {
+            JS_SetPropertyInternal(ctx, enum_obj, tab_atom[i].atom, JS_NULL, 0);
         }
-        it->tab_atom = tab_atom;
-        it->atom_count = tab_atom_count;
+        js_free_prop_enum(ctx, tab_atom, tab_atom_count);
     }
     return enum_obj;
-}
-
-/* obj -> enum_obj */
-static __exception int js_for_in_start(JSContext *ctx, JSValue *sp)
-{
-    sp[-1] = build_for_in_iterator(ctx, sp[-1]);
-    if (JS_IsException(sp[-1]))
-        return -1;
-    return 0;
-}
 
-/* return -1 if exception, 0 if slow case, 1 if the enumeration is finished */
-static __exception int js_for_in_prepare_prototype_chain_enum(JSContext *ctx,
-                                                              JSValueConst enum_obj)
-{
-    JSObject *p;
-    JSForInIterator *it;
-    JSPropertyEnum *tab_atom;
-    uint32_t tab_atom_count, i;
-    JSValue obj1;
-
-    p = JS_VALUE_GET_OBJ(enum_obj);
-    it = p->u.for_in_iterator;
-
-    /* check if there are enumerable properties in the prototype chain (fast path) */
-    obj1 = JS_DupValue(ctx, it->obj);
+ slow_path:
+    /* non enumerable properties hide the enumerables ones in the
+       prototype chain */
+    obj1 = JS_DupValue(ctx, obj);
     for(;;) {
-        obj1 = JS_GetPrototypeFree(ctx, obj1);
-        if (JS_IsNull(obj1))
-            break;
-        if (JS_IsException(obj1))
-            goto fail;
         if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count,
                                            JS_VALUE_GET_OBJ(obj1),
-                                           JS_GPN_STRING_MASK | JS_GPN_ENUM_ONLY)) {
+                                           JS_GPN_STRING_MASK | JS_GPN_SET_ENUM)) {
             JS_FreeValue(ctx, obj1);
             goto fail;
         }
+        for(i = 0; i < tab_atom_count; i++) {
+            JS_DefinePropertyValue(ctx, enum_obj, tab_atom[i].atom, JS_NULL,
+                                   (tab_atom[i].is_enumerable ?
+                                    JS_PROP_ENUMERABLE : 0));
+        }
         js_free_prop_enum(ctx, tab_atom, tab_atom_count);
-        if (tab_atom_count != 0) {
-            JS_FreeValue(ctx, obj1);
-            goto slow_path;
-        }
+        obj1 = JS_GetPrototypeFree(ctx, obj1);
+        if (JS_IsNull(obj1))
+            break;
+        if (JS_IsException(obj1))
+            goto fail;
         /* must check for timeout to avoid infinite loop */
         if (js_poll_interrupts(ctx)) {
             JS_FreeValue(ctx, obj1);
             goto fail;
         }
     }
-    JS_FreeValue(ctx, obj1);
-    return 1;
-
- slow_path:
-    /* add the visited properties, even if they are not enumerable */
-    if (it->is_array) {
-        if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count,
-                                           JS_VALUE_GET_OBJ(it->obj),
-                                           JS_GPN_STRING_MASK | JS_GPN_SET_ENUM)) {
-            goto fail;
-        }
-        it->is_array = FALSE;
-        it->tab_atom = tab_atom;
-        it->atom_count = tab_atom_count;
-    }
-
-    for(i = 0; i < it->atom_count; i++) {
-        if (JS_DefinePropertyValue(ctx, enum_obj, it->tab_atom[i].atom, JS_NULL, JS_PROP_ENUMERABLE) < 0)
-            goto fail;
-    }
-    return 0;
+    return enum_obj;
+
  fail:
-    return -1;
+    JS_FreeValue(ctx, enum_obj);
+    return JS_EXCEPTION;
+}
+
+/* obj -> enum_obj */
+static __exception int js_for_in_start(JSContext *ctx, JSValue *sp)
+{
+    sp[-1] = build_for_in_iterator(ctx, sp[-1]);
+    if (JS_IsException(sp[-1]))
+        return -1;
+    return 0;
 }
 
 /* enum_obj -> enum_obj value done */
@@ -15081,8 +14921,6 @@
     JSObject *p;
     JSAtom prop;
     JSForInIterator *it;
-    JSPropertyEnum *tab_atom;
-    uint32_t tab_atom_count;
     int ret;
 
     enum_obj = sp[-1];
@@ -15095,68 +14933,28 @@
     it = p->u.for_in_iterator;
 
     for(;;) {
-        if (it->idx >= it->atom_count) {
-            if (JS_IsNull(it->obj) || JS_IsUndefined(it->obj))
-                goto done; /* not an object */
-            /* no more property in the current object: look in the prototype */
-            if (!it->in_prototype_chain) {
-                ret = js_for_in_prepare_prototype_chain_enum(ctx, enum_obj);
-                if (ret < 0)
-                    return -1;
-                if (ret)
-                    goto done;
-                it->in_prototype_chain = TRUE;
-            }
-            it->obj = JS_GetPrototypeFree(ctx, it->obj);
-            if (JS_IsException(it->obj))
-                return -1;
-            if (JS_IsNull(it->obj))
-                goto done; /* no more prototype */
-
-            /* must check for timeout to avoid infinite loop */
-            if (js_poll_interrupts(ctx))
-                return -1;
-
-            if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count,
-                                               JS_VALUE_GET_OBJ(it->obj),
-                                               JS_GPN_STRING_MASK | JS_GPN_SET_ENUM)) {
-                return -1;
-            }
-            js_free_prop_enum(ctx, it->tab_atom, it->atom_count);
-            it->tab_atom = tab_atom;
-            it->atom_count = tab_atom_count;
-            it->idx = 0;
-        } else {
-            if (it->is_array) {
-                prop = __JS_AtomFromUInt32(it->idx);
-                it->idx++;
-            } else {
-                BOOL is_enumerable;
-                prop = it->tab_atom[it->idx].atom;
-                is_enumerable = it->tab_atom[it->idx].is_enumerable;
-                it->idx++;
-                if (it->in_prototype_chain) {
-                    /* slow case: we are in the prototype chain */
-                    ret = JS_GetOwnPropertyInternal(ctx, NULL, JS_VALUE_GET_OBJ(enum_obj), prop);
-                    if (ret < 0)
-                        return ret;
-                    if (ret)
-                        continue; /* already visited */
-                    /* add to the visited property list */
-                    if (JS_DefinePropertyValue(ctx, enum_obj, prop, JS_NULL,
-                                               JS_PROP_ENUMERABLE) < 0)
-                        return -1;
-                }
-                if (!is_enumerable)
-                    continue;
-            }
-            /* check if the property was deleted */
-            ret = JS_GetOwnPropertyInternal(ctx, NULL, JS_VALUE_GET_OBJ(it->obj), prop);
-            if (ret < 0)
-                return ret;
-            if (ret)
-                break;
-        }
+        if (it->is_array) {
+            if (it->idx >= it->array_length)
+                goto done;
+            prop = __JS_AtomFromUInt32(it->idx);
+            it->idx++;
+        } else {
+            JSShape *sh = p->shape;
+            JSShapeProperty *prs;
+            if (it->idx >= sh->prop_count)
+                goto done;
+            prs = get_shape_prop(sh) + it->idx;
+            prop = prs->atom;
+            it->idx++;
+            if (prop == JS_ATOM_NULL || !(prs->flags & JS_PROP_ENUMERABLE))
+                continue;
+        }
+        /* check if the property was deleted */
+        ret = JS_HasProperty(ctx, it->obj, prop);
+        if (ret < 0)
+            return ret;
+        if (ret)
+            break;
     }
     /* return the property */
     sp[0] = JS_AtomToValue(ctx, prop);
@@ -15642,7 +15440,7 @@
     struct list_head *el;
 
     list_for_each(el, &sf->var_ref_list) {
-        var_ref = list_entry(el, JSVarRef, var_ref_link);
+        var_ref = list_entry(el, JSVarRef, header.link);
         if (var_ref->var_idx == var_idx && var_ref->is_arg == is_arg) {
             var_ref->header.ref_count++;
             return var_ref;
@@ -15653,29 +15451,15 @@
     if (!var_ref)
         return NULL;
     var_ref->header.ref_count = 1;
-    add_gc_object(ctx->rt, &var_ref->header, JS_GC_OBJ_TYPE_VAR_REF);
     var_ref->is_detached = FALSE;
     var_ref->is_arg = is_arg;
     var_ref->var_idx = var_idx;
-    list_add_tail(&var_ref->var_ref_link, &sf->var_ref_list);
-    if (sf->js_mode & JS_MODE_ASYNC) {
-        /* The stack frame is detached and may be destroyed at any
-           time so its reference count must be increased. Calling
-           close_var_refs() when destroying the stack frame is not
-           possible because it would change the graph between the GC
-           objects. Another solution could be to temporarily detach
-           the JSVarRef of async functions during the GC. It would
-           have the advantage of allowing the release of unused stack
-           frames in a cycle. */
-        var_ref->async_func = container_of(sf, JSAsyncFunctionState, frame);
-        var_ref->async_func->header.ref_count++;
-    } else {
-        var_ref->async_func = NULL;
-    }
+    list_add_tail(&var_ref->header.link, &sf->var_ref_list);
     if (is_arg)
         var_ref->pvalue = &sf->arg_buf[var_idx];
     else
         var_ref->pvalue = &sf->var_buf[var_idx];
+    var_ref->value = JS_UNDEFINED;
     return var_ref;
 }
 
@@ -15906,10 +15690,7 @@
     int var_idx;
 
     list_for_each_safe(el, el1, &sf->var_ref_list) {
-        var_ref = list_entry(el, JSVarRef, var_ref_link);
-        /* no need to unlink var_ref->var_ref_link as the list is never used afterwards */
-        if (var_ref->async_func)
-            async_func_free(rt, var_ref->async_func);
+        var_ref = list_entry(el, JSVarRef, header.link);
         var_idx = var_ref->var_idx;
         if (var_ref->is_arg)
             var_ref->value = JS_DupValueRT(rt, sf->arg_buf[var_idx]);
@@ -15918,6 +15699,7 @@
         var_ref->pvalue = &var_ref->value;
         /* the reference is no longer to a local variable */
         var_ref->is_detached = TRUE;
+        add_gc_object(rt, &var_ref->header, JS_GC_OBJ_TYPE_VAR_REF);
     }
 }
 
@@ -15928,15 +15710,14 @@
     int var_idx = idx;
 
     list_for_each_safe(el, el1, &sf->var_ref_list) {
-        var_ref = list_entry(el, JSVarRef, var_ref_link);
+        var_ref = list_entry(el, JSVarRef, header.link);
         if (var_idx == var_ref->var_idx && var_ref->is_arg == is_arg) {
-            list_del(&var_ref->var_ref_link);
-            if (var_ref->async_func)
-                async_func_free(ctx->rt, var_ref->async_func);
             var_ref->value = JS_DupValue(ctx, sf->var_buf[var_idx]);
             var_ref->pvalue = &var_ref->value;
+            list_del(&var_ref->header.link);
             /* the reference is no longer to a local variable */
             var_ref->is_detached = TRUE;
+            add_gc_object(ctx->rt, &var_ref->header, JS_GC_OBJ_TYPE_VAR_REF);
         }
     }
 }
@@ -15980,7 +15761,7 @@
 #else
     sf->js_mode = 0;
 #endif
-    sf->cur_func = (JSValue)func_obj;
+    sf->cur_func = func_obj;
     sf->arg_count = argc;
     arg_buf = argv;
 
@@ -16127,10 +15908,9 @@
     OP_SPECIAL_OBJECT_IMPORT_META,
 } OPSpecialObjectEnum;
 
-#define FUNC_RET_AWAIT         0
-#define FUNC_RET_YIELD         1
-#define FUNC_RET_YIELD_STAR    2
-#define FUNC_RET_INITIAL_YIELD 3
+#define FUNC_RET_AWAIT      0
+#define FUNC_RET_YIELD      1
+#define FUNC_RET_YIELD_STAR 2
 
 /* argv[] is modified if (flags & JS_CALL_FLAG_COPY_ARGV) = 0. */
 static JSValue JS_CallInternal(JSContext *caller_ctx, JSValueConst func_obj,
@@ -16225,7 +16005,7 @@
     sf->js_mode = b->js_mode;
     arg_buf = argv;
     sf->arg_count = argc;
-    sf->cur_func = (JSValue)func_obj;
+    sf->cur_func = func_obj;
     init_list_head(&sf->var_ref_list);
     var_refs = p->u.func.var_refs;
 
@@ -16692,15 +16472,8 @@
             }
             BREAK;
         CASE(OP_check_brand):
-            {
-                int ret = JS_CheckBrand(ctx, sp[-2], sp[-1]);
-                if (ret < 0)
-                    goto exception;
-                if (!ret) {
-                    JS_ThrowTypeError(ctx, "invalid brand on object");
-                    goto exception;
-                }
-            }
+            if (JS_CheckBrand(ctx, sp[-2], sp[-1]) < 0)
+                goto exception;
             BREAK;
         CASE(OP_add_brand):
             if (JS_AddBrand(ctx, sp[-2], sp[-1]) < 0)
@@ -17117,19 +16890,6 @@
                 if (unlikely(JS_IsUninitialized(var_buf[idx]))) {
                     JS_ThrowReferenceErrorUninitialized2(ctx, b, idx, FALSE);
                     goto exception;
-                }
-                sp[0] = JS_DupValue(ctx, var_buf[idx]);
-                sp++;
-            }
-            BREAK;
-        CASE(OP_get_loc_checkthis):
-            {
-                int idx;
-                idx = get_u16(pc);
-                pc += 2;
-                if (unlikely(JS_IsUninitialized(var_buf[idx]))) {
-                    JS_ThrowReferenceErrorUninitialized2(caller_ctx, b, idx, FALSE);
-                    goto exception;
                 }
                 sp[0] = JS_DupValue(ctx, var_buf[idx]);
                 sp++;
@@ -17258,7 +17018,6 @@
 
                 op1 = sp[-1];
                 pc += 4;
-                /* quick and dirty test for JS_TAG_INT, JS_TAG_BOOL, JS_TAG_NULL and JS_TAG_UNDEFINED */
                 if ((uint32_t)JS_VALUE_GET_TAG(op1) <= JS_TAG_UNDEFINED) {
                     res = JS_VALUE_GET_INT(op1);
                 } else {
@@ -17405,21 +17164,26 @@
             }
             sp--;
             BREAK;
-        CASE(OP_nip_catch):
+        CASE(OP_iterator_close_return):
             {
                 JSValue ret_val;
-                /* catch_offset ... ret_val -> ret_eval */
+                /* iter_obj next catch_offset ... ret_val ->
+                   ret_eval iter_obj next catch_offset */
                 ret_val = *--sp;
                 while (sp > stack_buf &&
                        JS_VALUE_GET_TAG(sp[-1]) != JS_TAG_CATCH_OFFSET) {
                     JS_FreeValue(ctx, *--sp);
                 }
-                if (unlikely(sp == stack_buf)) {
-                    JS_ThrowInternalError(ctx, "nip_catch");
+                if (unlikely(sp < stack_buf + 3)) {
+                    JS_ThrowInternalError(ctx, "iterator_close_return");
                     JS_FreeValue(ctx, ret_val);
                     goto exception;
                 }
-                sp[-1] = ret_val;
+                sp[0] = sp[-1];
+                sp[-1] = sp[-2];
+                sp[-2] = sp[-3];
+                sp[-3] = ret_val;
+                sp++;
             }
             BREAK;
 
@@ -17520,7 +17284,7 @@
                 atom = get_u32(pc);
                 pc += 4;
 
-                ret = JS_SetPropertyInternal(ctx, sp[-2], atom, sp[-1], sp[-2],
+                ret = JS_SetPropertyInternal(ctx, sp[-2], atom, sp[-1],
                                              JS_PROP_THROW_STRICT);
                 JS_FreeValue(ctx, sp[-2]);
                 sp -= 2;
@@ -17819,8 +17583,8 @@
                 atom = JS_ValueToAtom(ctx, sp[-2]);
                 if (unlikely(atom == JS_ATOM_NULL))
                     goto exception;
-                ret = JS_SetPropertyInternal(ctx, sp[-3], atom, sp[-1], sp[-4],
-                                             JS_PROP_THROW_STRICT);
+                ret = JS_SetPropertyGeneric(ctx, sp[-3], atom, sp[-1], sp[-4],
+                                            JS_PROP_THROW_STRICT);
                 JS_FreeAtom(ctx, atom);
                 JS_FreeValue(ctx, sp[-4]);
                 JS_FreeValue(ctx, sp[-3]);
@@ -17882,11 +17646,6 @@
                     sp[-2] = __JS_NewFloat64(ctx, JS_VALUE_GET_FLOAT64(op1) +
                                              JS_VALUE_GET_FLOAT64(op2));
                     sp--;
-                } else if (JS_IsString(op1) && JS_IsString(op2)) {
-                    sp[-2] = JS_ConcatString(ctx, op1, op2);
-                    sp--;
-                    if (JS_IsException(sp[-1]))
-                        goto exception;
                 } else {
                 add_slow:
                     if (js_add_slow(ctx, sp))
@@ -17897,45 +17656,38 @@
             BREAK;
         CASE(OP_add_loc):
             {
-                JSValue op2;
                 JSValue *pv;
                 int idx;
                 idx = *pc;
                 pc += 1;
 
-                op2 = sp[-1];
                 pv = &var_buf[idx];
-                if (likely(JS_VALUE_IS_BOTH_INT(*pv, op2))) {
+                if (likely(JS_VALUE_IS_BOTH_INT(*pv, sp[-1]))) {
                     int64_t r;
-                    r = (int64_t)JS_VALUE_GET_INT(*pv) + JS_VALUE_GET_INT(op2);
+                    r = (int64_t)JS_VALUE_GET_INT(*pv) +
+                        JS_VALUE_GET_INT(sp[-1]);
                     if (unlikely((int)r != r))
                         goto add_loc_slow;
                     *pv = JS_NewInt32(ctx, r);
-                    sp--;
-                } else if (JS_VALUE_IS_BOTH_FLOAT(*pv, op2)) {
-                    *pv = __JS_NewFloat64(ctx, JS_VALUE_GET_FLOAT64(*pv) +
-                                               JS_VALUE_GET_FLOAT64(op2));
                     sp--;
                 } else if (JS_VALUE_GET_TAG(*pv) == JS_TAG_STRING) {
+                    JSValue op1;
+                    op1 = sp[-1];
                     sp--;
-                    op2 = JS_ToPrimitiveFree(ctx, op2, HINT_NONE);
-                    if (JS_IsException(op2))
+                    op1 = JS_ToPrimitiveFree(ctx, op1, HINT_NONE);
+                    if (JS_IsException(op1))
                         goto exception;
-                    if (JS_ConcatStringInPlace(ctx, JS_VALUE_GET_STRING(*pv), op2)) {
-                        JS_FreeValue(ctx, op2);
-                    } else {
-                        op2 = JS_ConcatString(ctx, JS_DupValue(ctx, *pv), op2);
-                        if (JS_IsException(op2))
-                            goto exception;
-                        set_value(ctx, pv, op2);
-                    }
+                    op1 = JS_ConcatString(ctx, JS_DupValue(ctx, *pv), op1);
+                    if (JS_IsException(op1))
+                        goto exception;
+                    set_value(ctx, pv, op1);
                 } else {
                     JSValue ops[2];
                 add_loc_slow:
                     /* In case of exception, js_add_slow frees ops[0]
                        and ops[1], so we must duplicate *pv */
                     ops[0] = JS_DupValue(ctx, *pv);
-                    ops[1] = op2;
+                    ops[1] = sp[-1];
                     sp--;
                     if (js_add_slow(ctx, ops + 2))
                         goto exception;
@@ -18381,11 +18133,6 @@
                 goto exception;
             sp--;
             BREAK;
-        CASE(OP_private_in):
-            if (js_operator_private_in(ctx, sp))
-                goto exception;
-            sp--;
-            BREAK;
         CASE(OP_instanceof):
             if (js_operator_instanceof(ctx, sp))
                 goto exception;
@@ -18516,7 +18263,7 @@
                         break;
                     case OP_with_put_var:
                         /* XXX: check if strict mode */
-                        ret = JS_SetPropertyInternal(ctx, obj, atom, sp[-2], obj,
+                        ret = JS_SetPropertyInternal(ctx, obj, atom, sp[-2],
                                                      JS_PROP_THROW_STRICT);
                         JS_FreeValue(ctx, sp[-1]);
                         sp -= 2;
@@ -18572,11 +18319,9 @@
             ret_val = JS_NewInt32(ctx, FUNC_RET_YIELD_STAR);
             goto done_generator;
         CASE(OP_return_async):
+        CASE(OP_initial_yield):
             ret_val = JS_UNDEFINED;
             goto done_generator;
-        CASE(OP_initial_yield):
-            ret_val = JS_NewInt32(ctx, FUNC_RET_INITIAL_YIELD);
-            goto done_generator;
 
         CASE(OP_nop):
             BREAK;
@@ -18858,35 +18603,26 @@
 }
 
 /* JSAsyncFunctionState (used by generator and async functions) */
-static JSAsyncFunctionState *async_func_init(JSContext *ctx,
-                                             JSValueConst func_obj, JSValueConst this_obj,
-                                             int argc, JSValueConst *argv)
+static __exception int async_func_init(JSContext *ctx, JSAsyncFunctionState *s,
+                                       JSValueConst func_obj, JSValueConst this_obj,
+                                       int argc, JSValueConst *argv)
 {
-    JSAsyncFunctionState *s;
     JSObject *p;
     JSFunctionBytecode *b;
     JSStackFrame *sf;
     int local_count, i, arg_buf_len, n;
 
-    s = js_mallocz(ctx, sizeof(*s));
-    if (!s)
-        return NULL;
-    s->header.ref_count = 1;
-    add_gc_object(ctx->rt, &s->header, JS_GC_OBJ_TYPE_ASYNC_FUNCTION);
-
     sf = &s->frame;
     init_list_head(&sf->var_ref_list);
     p = JS_VALUE_GET_OBJ(func_obj);
     b = p->u.func.function_bytecode;
-    sf->js_mode = b->js_mode | JS_MODE_ASYNC;
+    sf->js_mode = b->js_mode;
     sf->cur_pc = b->byte_code_buf;
     arg_buf_len = max_int(b->arg_count, argc);
     local_count = arg_buf_len + b->var_count + b->stack_size;
     sf->arg_buf = js_malloc(ctx, sizeof(JSValue) * max_int(local_count, 1));
-    if (!sf->arg_buf) {
-        js_free(ctx, s);
-        return NULL;
-    }
+    if (!sf->arg_buf)
+        return -1;
     sf->cur_func = JS_DupValue(ctx, func_obj);
     s->this_val = JS_DupValue(ctx, this_obj);
     s->argc = argc;
@@ -18898,17 +18634,38 @@
     n = arg_buf_len + b->var_count;
     for(i = argc; i < n; i++)
         sf->arg_buf[i] = JS_UNDEFINED;
-    s->resolving_funcs[0] = JS_UNDEFINED;
-    s->resolving_funcs[1] = JS_UNDEFINED;
-    s->is_completed = FALSE;
-    return s;
+    return 0;
 }
 
-static void async_func_free_frame(JSRuntime *rt, JSAsyncFunctionState *s)
+static void async_func_mark(JSRuntime *rt, JSAsyncFunctionState *s,
+                            JS_MarkFunc *mark_func)
 {
-    JSStackFrame *sf = &s->frame;
+    JSStackFrame *sf;
+    JSValue *sp;
+
+    sf = &s->frame;
+    JS_MarkValue(rt, sf->cur_func, mark_func);
+    JS_MarkValue(rt, s->this_val, mark_func);
+    if (sf->cur_sp) {
+        /* if the function is running, cur_sp is not known so we
+           cannot mark the stack. Marking the variables is not needed
+           because a running function cannot be part of a removable
+           cycle */
+        for(sp = sf->arg_buf; sp < sf->cur_sp; sp++)
+            JS_MarkValue(rt, *sp, mark_func);
+    }
+}
+
+static void async_func_free(JSRuntime *rt, JSAsyncFunctionState *s)
+{
+    JSStackFrame *sf;
     JSValue *sp;
 
+    sf = &s->frame;
+
+    /* close the closure variables. */
+    close_var_refs(rt, sf);
+
     if (sf->arg_buf) {
         /* cannot free the function if it is running */
         assert(sf->cur_sp != NULL);
@@ -18916,7 +18673,6 @@
             JS_FreeValueRT(rt, *sp);
         }
         js_free_rt(rt, sf->arg_buf);
-        sf->arg_buf = NULL;
     }
     JS_FreeValueRT(rt, sf->cur_func);
     JS_FreeValueRT(rt, s->this_val);
@@ -18924,66 +18680,17 @@
 
 static JSValue async_func_resume(JSContext *ctx, JSAsyncFunctionState *s)
 {
-    JSRuntime *rt = ctx->rt;
-    JSStackFrame *sf = &s->frame;
-    JSValue func_obj, ret;
+    JSValue func_obj;
 
-    assert(!s->is_completed);
-    if (js_check_stack_overflow(ctx->rt, 0)) {
-        ret = JS_ThrowStackOverflow(ctx);
-    } else {
-        /* the tag does not matter provided it is not an object */
-        func_obj = JS_MKPTR(JS_TAG_INT, s);
-        ret = JS_CallInternal(ctx, func_obj, s->this_val, JS_UNDEFINED,
-                              s->argc, sf->arg_buf, JS_CALL_FLAG_GENERATOR);
-    }
-    if (JS_IsException(ret) || JS_IsUndefined(ret)) {
-        if (JS_IsUndefined(ret)) {
-            ret = sf->cur_sp[-1];
-            sf->cur_sp[-1] = JS_UNDEFINED;
-        }
-        /* end of execution */
-        s->is_completed = TRUE;
-
-        /* close the closure variables. */
-        close_var_refs(rt, sf);
-
-        async_func_free_frame(rt, s);
-    }
-    return ret;
+    if (js_check_stack_overflow(ctx->rt, 0))
+        return JS_ThrowStackOverflow(ctx);
+
+    /* the tag does not matter provided it is not an object */
+    func_obj = JS_MKPTR(JS_TAG_INT, s);
+    return JS_CallInternal(ctx, func_obj, s->this_val, JS_UNDEFINED,
+                           s->argc, s->frame.arg_buf, JS_CALL_FLAG_GENERATOR);
 }
-
-static void __async_func_free(JSRuntime *rt, JSAsyncFunctionState *s)
-{
-    /* cannot close the closure variables here because it would
-       potentially modify the object graph */
-    if (!s->is_completed) {
-        async_func_free_frame(rt, s);
-    }
 
-    JS_FreeValueRT(rt, s->resolving_funcs[0]);
-    JS_FreeValueRT(rt, s->resolving_funcs[1]);
-
-    remove_gc_object(&s->header);
-    if (rt->gc_phase == JS_GC_PHASE_REMOVE_CYCLES && s->header.ref_count != 0) {
-        list_add_tail(&s->header.link, &rt->gc_zero_ref_count_list);
-    } else {
-        js_free_rt(rt, s);
-    }
-}
-
-static void async_func_free(JSRuntime *rt, JSAsyncFunctionState *s)
-{
-    if (--s->header.ref_count == 0) {
-        if (rt->gc_phase != JS_GC_PHASE_REMOVE_CYCLES) {
-            list_del(&s->header.link);
-            list_add(&s->header.link, &rt->gc_zero_ref_count_list);
-            if (rt->gc_phase == JS_GC_PHASE_NONE) {
-                free_zero_refcount(rt);
-            }
-        }
-    }
-}
 
 /* Generators */
 
@@ -18997,17 +18704,14 @@
 
 typedef struct JSGeneratorData {
     JSGeneratorStateEnum state;
-    JSAsyncFunctionState *func_state;
+    JSAsyncFunctionState func_state;
 } JSGeneratorData;
 
 static void free_generator_stack_rt(JSRuntime *rt, JSGeneratorData *s)
 {
     if (s->state == JS_GENERATOR_STATE_COMPLETED)
         return;
-    if (s->func_state) {
-        async_func_free(rt, s->func_state);
-        s->func_state = NULL;
-    }
+    async_func_free(rt, &s->func_state);
     s->state = JS_GENERATOR_STATE_COMPLETED;
 }
 
@@ -19032,9 +18736,9 @@
     JSObject *p = JS_VALUE_GET_OBJ(val);
     JSGeneratorData *s = p->u.generator_data;
 
-    if (!s || !s->func_state)
+    if (!s || s->state == JS_GENERATOR_STATE_COMPLETED)
         return;
-    mark_func(rt, &s->func_state->header);
+    async_func_mark(rt, &s->func_state, mark_func);
 }
 
 /* XXX: use enum */
@@ -19053,10 +18757,10 @@
     *pdone = TRUE;
     if (!s)
         return JS_ThrowTypeError(ctx, "not a generator");
+    sf = &s->func_state.frame;
     switch(s->state) {
     default:
     case JS_GENERATOR_STATE_SUSPENDED_START:
-        sf = &s->func_state->frame;
         if (magic == GEN_MAGIC_NEXT) {
             goto exec_no_arg;
         } else {
@@ -19066,29 +18770,28 @@
         break;
     case JS_GENERATOR_STATE_SUSPENDED_YIELD_STAR:
     case JS_GENERATOR_STATE_SUSPENDED_YIELD:
-        sf = &s->func_state->frame;
         /* cur_sp[-1] was set to JS_UNDEFINED in the previous call */
         ret = JS_DupValue(ctx, argv[0]);
         if (magic == GEN_MAGIC_THROW &&
             s->state == JS_GENERATOR_STATE_SUSPENDED_YIELD) {
             JS_Throw(ctx, ret);
-            s->func_state->throw_flag = TRUE;
+            s->func_state.throw_flag = TRUE;
         } else {
             sf->cur_sp[-1] = ret;
             sf->cur_sp[0] = JS_NewInt32(ctx, magic);
             sf->cur_sp++;
         exec_no_arg:
-            s->func_state->throw_flag = FALSE;
+            s->func_state.throw_flag = FALSE;
         }
         s->state = JS_GENERATOR_STATE_EXECUTING;
-        func_ret = async_func_resume(ctx, s->func_state);
+        func_ret = async_func_resume(ctx, &s->func_state);
         s->state = JS_GENERATOR_STATE_SUSPENDED_YIELD;
-        if (s->func_state->is_completed) {
-            /* finalize the execution in case of exception or normal return */
+        if (JS_IsException(func_ret)) {
+            /* finalize the execution in case of exception */
             free_generator_stack(ctx, s);
             return func_ret;
-        } else {
-            assert(JS_VALUE_GET_TAG(func_ret) == JS_TAG_INT);
+        }
+        if (JS_VALUE_GET_TAG(func_ret) == JS_TAG_INT) {
             /* get the returned yield value at the top of the stack */
             ret = sf->cur_sp[-1];
             sf->cur_sp[-1] = JS_UNDEFINED;
@@ -19099,6 +18802,12 @@
             } else {
                 *pdone = FALSE;
             }
+        } else {
+            /* end of iterator */
+            ret = sf->cur_sp[-1];
+            sf->cur_sp[-1] = JS_UNDEFINED;
+            JS_FreeValue(ctx, func_ret);
+            free_generator_stack(ctx, s);
         }
         break;
     case JS_GENERATOR_STATE_COMPLETED:
@@ -19136,14 +18845,13 @@
     if (!s)
         return JS_EXCEPTION;
     s->state = JS_GENERATOR_STATE_SUSPENDED_START;
-    s->func_state = async_func_init(ctx, func_obj, this_obj, argc, argv);
-    if (!s->func_state) {
+    if (async_func_init(ctx, &s->func_state, func_obj, this_obj, argc, argv)) {
         s->state = JS_GENERATOR_STATE_COMPLETED;
         goto fail;
     }
 
     /* execute the function up to 'OP_initial_yield' */
-    func_ret = async_func_resume(ctx, s->func_state);
+    func_ret = async_func_resume(ctx, &s->func_state);
     if (JS_IsException(func_ret))
         goto fail;
     JS_FreeValue(ctx, func_ret);
@@ -19161,12 +18869,36 @@
 
 /* AsyncFunction */
 
+static void js_async_function_terminate(JSRuntime *rt, JSAsyncFunctionData *s)
+{
+    if (s->is_active) {
+        async_func_free(rt, &s->func_state);
+        s->is_active = FALSE;
+    }
+}
+
+static void js_async_function_free0(JSRuntime *rt, JSAsyncFunctionData *s)
+{
+    js_async_function_terminate(rt, s);
+    JS_FreeValueRT(rt, s->resolving_funcs[0]);
+    JS_FreeValueRT(rt, s->resolving_funcs[1]);
+    remove_gc_object(&s->header);
+    js_free_rt(rt, s);
+}
+
+static void js_async_function_free(JSRuntime *rt, JSAsyncFunctionData *s)
+{
+    if (--s->header.ref_count == 0) {
+        js_async_function_free0(rt, s);
+    }
+}
+
 static void js_async_function_resolve_finalizer(JSRuntime *rt, JSValue val)
 {
     JSObject *p = JS_VALUE_GET_OBJ(val);
-    JSAsyncFunctionState *s = p->u.async_function_data;
+    JSAsyncFunctionData *s = p->u.async_function_data;
     if (s) {
-        async_func_free(rt, s);
+        js_async_function_free(rt, s);
     }
 }
 
@@ -19174,14 +18906,14 @@
                                            JS_MarkFunc *mark_func)
 {
     JSObject *p = JS_VALUE_GET_OBJ(val);
-    JSAsyncFunctionState *s = p->u.async_function_data;
+    JSAsyncFunctionData *s = p->u.async_function_data;
     if (s) {
         mark_func(rt, &s->header);
     }
 }
 
 static int js_async_function_resolve_create(JSContext *ctx,
-                                            JSAsyncFunctionState *s,
+                                            JSAsyncFunctionData *s,
                                             JSValue *resolving_funcs)
 {
     int i;
@@ -19203,58 +18935,60 @@
     return 0;
 }
 
-static void js_async_function_resume(JSContext *ctx, JSAsyncFunctionState *s)
+static void js_async_function_resume(JSContext *ctx, JSAsyncFunctionData *s)
 {
     JSValue func_ret, ret2;
 
-    func_ret = async_func_resume(ctx, s);
-    if (s->is_completed) {
-        if (JS_IsException(func_ret)) {
-            JSValue error;
-        fail:
-            error = JS_GetException(ctx);
-            ret2 = JS_Call(ctx, s->resolving_funcs[1], JS_UNDEFINED,
-                           1, (JSValueConst *)&error);
-            JS_FreeValue(ctx, error);
-            JS_FreeValue(ctx, ret2); /* XXX: what to do if exception ? */
-        } else {
-            /* normal return */
+    func_ret = async_func_resume(ctx, &s->func_state);
+    if (JS_IsException(func_ret)) {
+        JSValue error;
+    fail:
+        error = JS_GetException(ctx);
+        ret2 = JS_Call(ctx, s->resolving_funcs[1], JS_UNDEFINED,
+                       1, (JSValueConst *)&error);
+        JS_FreeValue(ctx, error);
+        js_async_function_terminate(ctx->rt, s);
+        JS_FreeValue(ctx, ret2); /* XXX: what to do if exception ? */
+    } else {
+        JSValue value;
+        value = s->func_state.frame.cur_sp[-1];
+        s->func_state.frame.cur_sp[-1] = JS_UNDEFINED;
+        if (JS_IsUndefined(func_ret)) {
+            /* function returned */
             ret2 = JS_Call(ctx, s->resolving_funcs[0], JS_UNDEFINED,
-                           1, (JSValueConst *)&func_ret);
-            JS_FreeValue(ctx, func_ret);
+                           1, (JSValueConst *)&value);
             JS_FreeValue(ctx, ret2); /* XXX: what to do if exception ? */
-        }
-    } else {
-        JSValue value, promise, resolving_funcs[2], resolving_funcs1[2];
-        int i, res;
+            JS_FreeValue(ctx, value);
+            js_async_function_terminate(ctx->rt, s);
+        } else {
+            JSValue promise, resolving_funcs[2], resolving_funcs1[2];
+            int i, res;
 
-        value = s->frame.cur_sp[-1];
-        s->frame.cur_sp[-1] = JS_UNDEFINED;
-
-        /* await */
-        JS_FreeValue(ctx, func_ret); /* not used */
-        promise = js_promise_resolve(ctx, ctx->promise_ctor,
-                                     1, (JSValueConst *)&value, 0);
-        JS_FreeValue(ctx, value);
-        if (JS_IsException(promise))
-            goto fail;
-        if (js_async_function_resolve_create(ctx, s, resolving_funcs)) {
-            JS_FreeValue(ctx, promise);
-            goto fail;
-        }
+            /* await */
+            JS_FreeValue(ctx, func_ret); /* not used */
+            promise = js_promise_resolve(ctx, ctx->promise_ctor,
+                                         1, (JSValueConst *)&value, 0);
+            JS_FreeValue(ctx, value);
+            if (JS_IsException(promise))
+                goto fail;
+            if (js_async_function_resolve_create(ctx, s, resolving_funcs)) {
+                JS_FreeValue(ctx, promise);
+                goto fail;
+            }
 
-        /* Note: no need to create 'thrownawayCapability' as in
-           the spec */
-        for(i = 0; i < 2; i++)
-            resolving_funcs1[i] = JS_UNDEFINED;
-        res = perform_promise_then(ctx, promise,
-                                   (JSValueConst *)resolving_funcs,
-                                   (JSValueConst *)resolving_funcs1);
-        JS_FreeValue(ctx, promise);
-        for(i = 0; i < 2; i++)
-            JS_FreeValue(ctx, resolving_funcs[i]);
-        if (res)
-            goto fail;
+            /* Note: no need to create 'thrownawayCapability' as in
+               the spec */
+            for(i = 0; i < 2; i++)
+                resolving_funcs1[i] = JS_UNDEFINED;
+            res = perform_promise_then(ctx, promise,
+                                       (JSValueConst *)resolving_funcs,
+                                       (JSValueConst *)resolving_funcs1);
+            JS_FreeValue(ctx, promise);
+            for(i = 0; i < 2; i++)
+                JS_FreeValue(ctx, resolving_funcs[i]);
+            if (res)
+                goto fail;
+        }
     }
 }
 
@@ -19265,7 +18999,7 @@
                                               int flags)
 {
     JSObject *p = JS_VALUE_GET_OBJ(func_obj);
-    JSAsyncFunctionState *s = p->u.async_function_data;
+    JSAsyncFunctionData *s = p->u.async_function_data;
     BOOL is_reject = p->class_id - JS_CLASS_ASYNC_FUNCTION_RESOLVE;
     JSValueConst arg;
 
@@ -19273,12 +19007,12 @@
         arg = argv[0];
     else
         arg = JS_UNDEFINED;
-    s->throw_flag = is_reject;
+    s->func_state.throw_flag = is_reject;
     if (is_reject) {
         JS_Throw(ctx, JS_DupValue(ctx, arg));
     } else {
         /* return value of await */
-        s->frame.cur_sp[-1] = JS_DupValue(ctx, arg);
+        s->func_state.frame.cur_sp[-1] = JS_DupValue(ctx, arg);
     }
     js_async_function_resume(ctx, s);
     return JS_UNDEFINED;
@@ -19289,21 +19023,32 @@
                                       int argc, JSValueConst *argv, int flags)
 {
     JSValue promise;
-    JSAsyncFunctionState *s;
+    JSAsyncFunctionData *s;
 
-    s = async_func_init(ctx, func_obj, this_obj, argc, argv);
+    s = js_mallocz(ctx, sizeof(*s));
     if (!s)
         return JS_EXCEPTION;
+    s->header.ref_count = 1;
+    add_gc_object(ctx->rt, &s->header, JS_GC_OBJ_TYPE_ASYNC_FUNCTION);
+    s->is_active = FALSE;
+    s->resolving_funcs[0] = JS_UNDEFINED;
+    s->resolving_funcs[1] = JS_UNDEFINED;
 
     promise = JS_NewPromiseCapability(ctx, s->resolving_funcs);
-    if (JS_IsException(promise)) {
-        async_func_free(ctx->rt, s);
+    if (JS_IsException(promise))
+        goto fail;
+
+    if (async_func_init(ctx, &s->func_state, func_obj, this_obj, argc, argv)) {
+    fail:
+        JS_FreeValue(ctx, promise);
+        js_async_function_free(ctx->rt, s);
         return JS_EXCEPTION;
     }
+    s->is_active = TRUE;
 
     js_async_function_resume(ctx, s);
 
-    async_func_free(ctx->rt, s);
+    js_async_function_free(ctx->rt, s);
 
     return promise;
 }
@@ -19332,8 +19077,7 @@
 typedef struct JSAsyncGeneratorData {
     JSObject *generator; /* back pointer to the object (const) */
     JSAsyncGeneratorStateEnum state;
-    /* func_state is NULL is state AWAITING_RETURN and COMPLETED */
-    JSAsyncFunctionState *func_state;
+    JSAsyncFunctionState func_state;
     struct list_head queue; /* list of JSAsyncGeneratorRequest.link */
 } JSAsyncGeneratorData;
 
@@ -19351,8 +19095,10 @@
         JS_FreeValueRT(rt, req->resolving_funcs[1]);
         js_free_rt(rt, req);
     }
-    if (s->func_state)
-        async_func_free(rt, s->func_state);
+    if (s->state != JS_ASYNC_GENERATOR_STATE_COMPLETED &&
+        s->state != JS_ASYNC_GENERATOR_STATE_AWAITING_RETURN) {
+        async_func_free(rt, &s->func_state);
+    }
     js_free_rt(rt, s);
 }
 
@@ -19379,8 +19125,9 @@
             JS_MarkValue(rt, req->resolving_funcs[0], mark_func);
             JS_MarkValue(rt, req->resolving_funcs[1], mark_func);
         }
-        if (s->func_state) {
-            mark_func(rt, &s->func_state->header);
+        if (s->state != JS_ASYNC_GENERATOR_STATE_COMPLETED &&
+            s->state != JS_ASYNC_GENERATOR_STATE_AWAITING_RETURN) {
+            async_func_mark(rt, &s->func_state, mark_func);
         }
     }
 }
@@ -19490,8 +19237,7 @@
 {
     if (s->state != JS_ASYNC_GENERATOR_STATE_COMPLETED) {
         s->state = JS_ASYNC_GENERATOR_STATE_COMPLETED;
-        async_func_free(ctx->rt, s->func_state);
-        s->func_state = NULL;
+        async_func_free(ctx->rt, &s->func_state);
     }
 }
 
@@ -19502,19 +19248,10 @@
     JSValue promise, resolving_funcs[2], resolving_funcs1[2];
     int res;
 
-    // Can fail looking up JS_ATOM_constructor when is_reject==0.
-    promise = js_promise_resolve(ctx, ctx->promise_ctor, 1, &value,
-                                 /*is_reject*/0);
-    // A poisoned .constructor property is observable and the resulting
-    // exception should be delivered to the catch handler.
-    if (JS_IsException(promise)) {
-        JSValue err = JS_GetException(ctx);
-        promise = js_promise_resolve(ctx, ctx->promise_ctor, 1, (JSValueConst *)&err,
-                                     /*is_reject*/1);
-        JS_FreeValue(ctx, err);
-        if (JS_IsException(promise))
-            return -1;
-    }
+    promise = js_promise_resolve(ctx, ctx->promise_ctor,
+                                 1, (JSValueConst *)&value, 0);
+    if (JS_IsException(promise))
+        return -1;
     if (js_async_generator_resolve_function_create(ctx,
                                                    JS_MKPTR(JS_TAG_OBJECT, s->generator),
                                                    resolving_funcs1,
@@ -19562,6 +19299,7 @@
             } else if (next->completion_type == GEN_MAGIC_RETURN) {
                 s->state = JS_ASYNC_GENERATOR_STATE_AWAITING_RETURN;
                 js_async_generator_completed_return(ctx, s, next->result);
+                goto done;
             } else {
                 js_async_generator_reject(ctx, s, next->result);
             }
@@ -19572,38 +19310,30 @@
             if (next->completion_type == GEN_MAGIC_THROW &&
                 s->state == JS_ASYNC_GENERATOR_STATE_SUSPENDED_YIELD) {
                 JS_Throw(ctx, value);
-                s->func_state->throw_flag = TRUE;
+                s->func_state.throw_flag = TRUE;
             } else {
                 /* 'yield' returns a value. 'yield *' also returns a value
                    in case the 'throw' method is called */
-                s->func_state->frame.cur_sp[-1] = value;
-                s->func_state->frame.cur_sp[0] =
+                s->func_state.frame.cur_sp[-1] = value;
+                s->func_state.frame.cur_sp[0] =
                     JS_NewInt32(ctx, next->completion_type);
-                s->func_state->frame.cur_sp++;
+                s->func_state.frame.cur_sp++;
             exec_no_arg:
-                s->func_state->throw_flag = FALSE;
+                s->func_state.throw_flag = FALSE;
             }
             s->state = JS_ASYNC_GENERATOR_STATE_EXECUTING;
         resume_exec:
-            func_ret = async_func_resume(ctx, s->func_state);
-            if (s->func_state->is_completed) {
-                if (JS_IsException(func_ret)) {
-                    value = JS_GetException(ctx);
-                    js_async_generator_complete(ctx, s);
-                    js_async_generator_reject(ctx, s, value);
-                    JS_FreeValue(ctx, value);
-                } else {
-                    /* end of function */
-                    js_async_generator_complete(ctx, s);
-                    js_async_generator_resolve(ctx, s, func_ret, TRUE);
-                    JS_FreeValue(ctx, func_ret);
-                }
-            } else {
-                int func_ret_code, ret;
-                assert(JS_VALUE_GET_TAG(func_ret) == JS_TAG_INT);
+            func_ret = async_func_resume(ctx, &s->func_state);
+            if (JS_IsException(func_ret)) {
+                value = JS_GetException(ctx);
+                js_async_generator_complete(ctx, s);
+                js_async_generator_reject(ctx, s, value);
+                JS_FreeValue(ctx, value);
+            } else if (JS_VALUE_GET_TAG(func_ret) == JS_TAG_INT) {
+                int func_ret_code;
+                value = s->func_state.frame.cur_sp[-1];
+                s->func_state.frame.cur_sp[-1] = JS_UNDEFINED;
                 func_ret_code = JS_VALUE_GET_INT(func_ret);
-                value = s->func_state->frame.cur_sp[-1];
-                s->func_state->frame.cur_sp[-1] = JS_UNDEFINED;
                 switch(func_ret_code) {
                 case FUNC_RET_YIELD:
                 case FUNC_RET_YIELD_STAR:
@@ -19615,17 +19345,20 @@
                     JS_FreeValue(ctx, value);
                     break;
                 case FUNC_RET_AWAIT:
-                    ret = js_async_generator_await(ctx, s, value);
+                    js_async_generator_await(ctx, s, value);
                     JS_FreeValue(ctx, value);
-                    if (ret < 0) {
-                        /* exception: throw it */
-                        s->func_state->throw_flag = TRUE;
-                        goto resume_exec;
-                    }
                     goto done;
                 default:
                     abort();
                 }
+            } else {
+                assert(JS_IsUndefined(func_ret));
+                /* end of function */
+                value = s->func_state.frame.cur_sp[-1];
+                s->func_state.frame.cur_sp[-1] = JS_UNDEFINED;
+                js_async_generator_complete(ctx, s);
+                js_async_generator_resolve(ctx, s, value, TRUE);
+                JS_FreeValue(ctx, value);
             }
             break;
         default:
@@ -19659,12 +19392,12 @@
     } else {
         /* restart function execution after await() */
         assert(s->state == JS_ASYNC_GENERATOR_STATE_EXECUTING);
-        s->func_state->throw_flag = is_reject;
+        s->func_state.throw_flag = is_reject;
         if (is_reject) {
             JS_Throw(ctx, JS_DupValue(ctx, arg));
         } else {
             /* return value of await */
-            s->func_state->frame.cur_sp[-1] = JS_DupValue(ctx, arg);
+            s->func_state.frame.cur_sp[-1] = JS_DupValue(ctx, arg);
         }
         js_async_generator_resume_next(ctx, s);
     }
@@ -19728,12 +19461,14 @@
         return JS_EXCEPTION;
     s->state = JS_ASYNC_GENERATOR_STATE_SUSPENDED_START;
     init_list_head(&s->queue);
-    s->func_state = async_func_init(ctx, func_obj, this_obj, argc, argv);
-    if (!s->func_state)
+    if (async_func_init(ctx, &s->func_state, func_obj, this_obj, argc, argv)) {
+        s->state = JS_ASYNC_GENERATOR_STATE_COMPLETED;
         goto fail;
+    }
+
     /* execute the function up to 'OP_initial_yield' (no yield nor
        await are possible) */
-    func_ret = async_func_resume(ctx, s->func_state);
+    func_ret = async_func_resume(ctx, &s->func_state);
     if (JS_IsException(func_ret))
         goto fail;
     JS_FreeValue(ctx, func_ret);
@@ -19919,7 +19654,6 @@
     JS_PARSE_FUNC_GETTER,
     JS_PARSE_FUNC_SETTER,
     JS_PARSE_FUNC_METHOD,
-    JS_PARSE_FUNC_CLASS_STATIC_INIT,
     JS_PARSE_FUNC_CLASS_CONSTRUCTOR,
     JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR,
 } JSParseFunctionEnum;
@@ -20039,7 +19773,6 @@
     int source_len;
 
     JSModuleDef *module; /* != NULL when parsing a module */
-    BOOL has_await; /* TRUE if await is used (used in module eval) */
 } JSFunctionDef;
 
 typedef struct JSToken {
@@ -20152,7 +19885,7 @@
     }
 }
 
-static void __attribute((unused)) dump_token(JSParseState *s,
+static void PLATFORM_MAYBE_UNUSED dump_token(JSParseState *s,
                                              const JSToken *token)
 {
     switch(token->val) {
@@ -20213,7 +19946,7 @@
     }
 }
 
-int __attribute__((format(printf, 2, 3))) js_parse_error(JSParseState *s, const char *fmt, ...)
+int PLATFORM_PRINTF_LIKE(2, 3) js_parse_error(JSParseState *s, const char *fmt, ...)
 {
     JSContext *ctx = s->ctx;
     va_list ap;
@@ -20590,48 +20323,6 @@
     return 0;
 }
 
-/* convert a TOK_IDENT to a keyword when needed */
-static void update_token_ident(JSParseState *s)
-{
-    if (s->token.u.ident.atom <= JS_ATOM_LAST_KEYWORD ||
-        (s->token.u.ident.atom <= JS_ATOM_LAST_STRICT_KEYWORD &&
-         (s->cur_func->js_mode & JS_MODE_STRICT)) ||
-        (s->token.u.ident.atom == JS_ATOM_yield &&
-         ((s->cur_func->func_kind & JS_FUNC_GENERATOR) ||
-          (s->cur_func->func_type == JS_PARSE_FUNC_ARROW &&
-           !s->cur_func->in_function_body && s->cur_func->parent &&
-           (s->cur_func->parent->func_kind & JS_FUNC_GENERATOR)))) ||
-        (s->token.u.ident.atom == JS_ATOM_await &&
-         (s->is_module ||
-          (s->cur_func->func_kind & JS_FUNC_ASYNC) ||
-          s->cur_func->func_type == JS_PARSE_FUNC_CLASS_STATIC_INIT ||
-          (s->cur_func->func_type == JS_PARSE_FUNC_ARROW &&
-           !s->cur_func->in_function_body && s->cur_func->parent &&
-           ((s->cur_func->parent->func_kind & JS_FUNC_ASYNC) ||
-            s->cur_func->parent->func_type == JS_PARSE_FUNC_CLASS_STATIC_INIT))))) {
-        if (s->token.u.ident.has_escape) {
-            s->token.u.ident.is_reserved = TRUE;
-            s->token.val = TOK_IDENT;
-        } else {
-            /* The keywords atoms are pre allocated */
-            s->token.val = s->token.u.ident.atom - 1 + TOK_FIRST_KEYWORD;
-        }
-    }
-}
-
-/* if the current token is an identifier or keyword, reparse it
-   according to the current function type */
-static void reparse_ident_token(JSParseState *s)
-{
-    if (s->token.val == TOK_IDENT ||
-        (s->token.val >= TOK_FIRST_KEYWORD &&
-         s->token.val <= TOK_LAST_KEYWORD)) {
-        s->token.val = TOK_IDENT;
-        s->token.u.ident.is_reserved = FALSE;
-        update_token_ident(s);
-    }
-}
-
 /* 'c' is the first character. Return JS_ATOM_NULL in case of error */
 static JSAtom parse_ident(JSParseState *s, const uint8_t **pp,
                           BOOL *pident_has_escape, int c, BOOL is_private)
@@ -20838,8 +20529,30 @@
         s->token.u.ident.atom = atom;
         s->token.u.ident.has_escape = ident_has_escape;
         s->token.u.ident.is_reserved = FALSE;
-        s->token.val = TOK_IDENT;
-        update_token_ident(s);
+        if (s->token.u.ident.atom <= JS_ATOM_LAST_KEYWORD ||
+            (s->token.u.ident.atom <= JS_ATOM_LAST_STRICT_KEYWORD &&
+             (s->cur_func->js_mode & JS_MODE_STRICT)) ||
+            (s->token.u.ident.atom == JS_ATOM_yield &&
+             ((s->cur_func->func_kind & JS_FUNC_GENERATOR) ||
+              (s->cur_func->func_type == JS_PARSE_FUNC_ARROW &&
+               !s->cur_func->in_function_body && s->cur_func->parent &&
+               (s->cur_func->parent->func_kind & JS_FUNC_GENERATOR)))) ||
+            (s->token.u.ident.atom == JS_ATOM_await &&
+             (s->is_module ||
+              (((s->cur_func->func_kind & JS_FUNC_ASYNC) ||
+                (s->cur_func->func_type == JS_PARSE_FUNC_ARROW &&
+                 !s->cur_func->in_function_body && s->cur_func->parent &&
+                 (s->cur_func->parent->func_kind & JS_FUNC_ASYNC))))))) {
+                  if (ident_has_escape) {
+                      s->token.u.ident.is_reserved = TRUE;
+                      s->token.val = TOK_IDENT;
+                  } else {
+                      /* The keywords atoms are pre allocated */
+                      s->token.val = s->token.u.ident.atom - 1 + TOK_FIRST_KEYWORD;
+                  }
+        } else {
+            s->token.val = TOK_IDENT;
+        }
         break;
     case '#':
         /* private name */
@@ -21486,31 +21199,6 @@
     return simple_next_token(&p, no_line_terminator);
 }
 
-static void skip_shebang(const uint8_t **pp, const uint8_t *buf_end)
-{
-    const uint8_t *p = *pp;
-    int c;
-
-    if (p[0] == '#' && p[1] == '!') {
-        p += 2;
-        while (p < buf_end) {
-            if (*p == '\n' || *p == '\r') {
-                break;
-            } else if (*p >= 0x80) {
-                c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
-                if (c == CP_LS || c == CP_PS) {
-                    break;
-                } else if (c == -1) {
-                    p++; /* skip invalid UTF-8 */
-                }
-            } else {
-                p++;
-            }
-        }
-        *pp = p;
-    }
-}
-
 /* return true if 'input' contains the source of a module
    (heuristic). 'input' must be a zero terminated.
 
@@ -21521,8 +21209,6 @@
 {
     const uint8_t *p = (const uint8_t *)input;
     int tok;
-
-    skip_shebang(&p, p + input_len);
     switch(simple_next_token(&p, FALSE)) {
     case TOK_IMPORT:
         tok = simple_next_token(&p, FALSE);
@@ -21635,14 +21321,6 @@
     return new_label_fd(s->cur_func, -1);
 }
 
-/* don't update the last opcode and don't emit line number info */
-static void emit_label_raw(JSParseState *s, int label)
-{
-    emit_u8(s, OP_label);
-    emit_u32(s, label);
-    s->cur_func->label_slots[label].pos = s->cur_func->byte_code.size;
-}
-
 /* return the label ID offset */
 static int emit_label(JSParseState *s, int label)
 {
@@ -22141,7 +21819,7 @@
 
 /* add a private field variable in the current scope */
 static int add_private_class_field(JSParseState *s, JSFunctionDef *fd,
-                                   JSAtom name, JSVarKindEnum var_kind, BOOL is_static)
+                                   JSAtom name, JSVarKindEnum var_kind)
 {
     JSContext *ctx = s->ctx;
     JSVarDef *vd;
@@ -22153,7 +21831,6 @@
     vd = &fd->vars[idx];
     vd->is_lexical = 1;
     vd->is_const = 1;
-    vd->is_static_private = is_static;
     return idx;
 }
 
@@ -22797,10 +22474,12 @@
 #define PF_IN_ACCEPTED  (1 << 0)
 /* allow function calls parsing in js_parse_postfix_expr() */
 #define PF_POSTFIX_CALL (1 << 1)
+/* allow arrow functions parsing in js_parse_postfix_expr() */
+#define PF_ARROW_FUNC   (1 << 2)
 /* allow the exponentiation operator in js_parse_unary() */
-#define PF_POW_ALLOWED  (1 << 2)
+#define PF_POW_ALLOWED  (1 << 3)
 /* forbid the exponentiation operator in js_parse_unary() */
-#define PF_POW_FORBIDDEN (1 << 3)
+#define PF_POW_FORBIDDEN (1 << 4)
 
 static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags);
 
@@ -22897,9 +22576,8 @@
 typedef struct {
     JSFunctionDef *fields_init_fd;
     int computed_fields_count;
-    BOOL need_brand;
+    BOOL has_brand;
     int brand_push_pos;
-    BOOL is_static;
 } ClassFieldsDef;
 
 static __exception int emit_class_init_start(JSParseState *s,
@@ -22913,29 +22591,43 @@
 
     s->cur_func = cf->fields_init_fd;
 
-    if (!cf->is_static) {
-        /* add the brand to the newly created instance */
-        /* XXX: would be better to add the code only if needed, maybe in a
-           later pass */
-        emit_op(s, OP_push_false); /* will be patched later */
-        cf->brand_push_pos = cf->fields_init_fd->last_opcode_pos;
-        label_add_brand = emit_goto(s, OP_if_false, -1);
+    /* XXX: would be better to add the code only if needed, maybe in a
+       later pass */
+    emit_op(s, OP_push_false); /* will be patched later */
+    cf->brand_push_pos = cf->fields_init_fd->last_opcode_pos;
+    label_add_brand = emit_goto(s, OP_if_false, -1);
 
-        emit_op(s, OP_scope_get_var);
-        emit_atom(s, JS_ATOM_this);
-        emit_u16(s, 0);
+    emit_op(s, OP_scope_get_var);
+    emit_atom(s, JS_ATOM_this);
+    emit_u16(s, 0);
 
-        emit_op(s, OP_scope_get_var);
-        emit_atom(s, JS_ATOM_home_object);
-        emit_u16(s, 0);
+    emit_op(s, OP_scope_get_var);
+    emit_atom(s, JS_ATOM_home_object);
+    emit_u16(s, 0);
 
-        emit_op(s, OP_add_brand);
+    emit_op(s, OP_add_brand);
 
-        emit_label(s, label_add_brand);
-    }
+    emit_label(s, label_add_brand);
+
     s->cur_func = s->cur_func->parent;
     return 0;
 }
+
+static __exception int add_brand(JSParseState *s, ClassFieldsDef *cf)
+{
+    if (!cf->has_brand) {
+        /* define the brand field in 'this' of the initializer */
+        if (!cf->fields_init_fd) {
+            if (emit_class_init_start(s, cf))
+                return -1;
+        }
+        /* patch the start of the function to enable the OP_add_brand code */
+        cf->fields_init_fd->byte_code.buf[cf->brand_push_pos] = OP_push_true;
+
+        cf->has_brand = TRUE;
+    }
+    return 0;
+}
 
 static void emit_class_init_end(JSParseState *s, ClassFieldsDef *cf)
 {
@@ -23040,8 +22732,7 @@
         ClassFieldsDef *cf = &class_fields[i];
         cf->fields_init_fd = NULL;
         cf->computed_fields_count = 0;
-        cf->need_brand = FALSE;
-        cf->is_static = i;
+        cf->has_brand = FALSE;
     }
 
     ctor_fd = NULL;
@@ -23056,41 +22747,6 @@
         if (is_static) {
             if (next_token(s))
                 goto fail;
-            if (s->token.val == '{') {
-                ClassFieldsDef *cf = &class_fields[is_static];
-                JSFunctionDef *init;
-                if (!cf->fields_init_fd) {
-                    if (emit_class_init_start(s, cf))
-                        goto fail;
-                }
-                s->cur_func = cf->fields_init_fd;
-                /* XXX: could try to avoid creating a new function and
-                   reuse 'fields_init_fd' with a specific 'var'
-                   scope */
-                // stack is now: <empty>
-                if (js_parse_function_decl2(s, JS_PARSE_FUNC_CLASS_STATIC_INIT,
-                                            JS_FUNC_NORMAL, JS_ATOM_NULL,
-                                            s->token.ptr, s->token.line_num,
-                                            JS_PARSE_EXPORT_NONE, &init) < 0) {
-                    goto fail;
-                }
-                // stack is now: fclosure
-                push_scope(s);
-                emit_op(s, OP_scope_get_var);
-                emit_atom(s, JS_ATOM_this);
-                emit_u16(s, 0);
-                // stack is now: fclosure this
-                emit_op(s, OP_swap);
-                // stack is now: this fclosure
-                emit_op(s, OP_call_method);
-                emit_u16(s, 0);
-                // stack is now: returnvalue
-                emit_op(s, OP_drop);
-                // stack is now: <empty>
-                pop_scope(s);
-                s->cur_func = s->cur_func->parent;
-                continue;
-            }
             /* allow "static" field name */
             if (s->token.val == ';' || s->token.val == '=') {
                 is_static = FALSE;
@@ -23121,26 +22777,24 @@
             JSFunctionDef *method_fd;
 
             if (is_private) {
-                int idx, var_kind, is_static1;
+                int idx, var_kind;
                 idx = find_private_class_field(ctx, fd, name, fd->scope_level);
                 if (idx >= 0) {
                     var_kind = fd->vars[idx].var_kind;
-                    is_static1 = fd->vars[idx].is_static_private;
                     if (var_kind == JS_VAR_PRIVATE_FIELD ||
                         var_kind == JS_VAR_PRIVATE_METHOD ||
                         var_kind == JS_VAR_PRIVATE_GETTER_SETTER ||
-                        var_kind == (JS_VAR_PRIVATE_GETTER + is_set) ||
-                        (var_kind == (JS_VAR_PRIVATE_GETTER + 1 - is_set) &&
-                         is_static != is_static1)) {
+                        var_kind == (JS_VAR_PRIVATE_GETTER + is_set)) {
                         goto private_field_already_defined;
                     }
                     fd->vars[idx].var_kind = JS_VAR_PRIVATE_GETTER_SETTER;
                 } else {
                     if (add_private_class_field(s, fd, name,
-                                                JS_VAR_PRIVATE_GETTER + is_set, is_static) < 0)
+                                                JS_VAR_PRIVATE_GETTER + is_set) < 0)
                         goto fail;
                 }
-                class_fields[is_static].need_brand = TRUE;
+                if (add_brand(s, &class_fields[is_static]) < 0)
+                    goto fail;
             }
 
             if (js_parse_function_decl2(s, JS_PARSE_FUNC_GETTER + is_set,
@@ -23162,7 +22816,7 @@
                         goto fail;
                     emit_atom(s, setter_name);
                     ret = add_private_class_field(s, fd, setter_name,
-                                                  JS_VAR_PRIVATE_SETTER, is_static);
+                                                  JS_VAR_PRIVATE_SETTER);
                     JS_FreeAtom(ctx, setter_name);
                     if (ret < 0)
                         goto fail;
@@ -23197,7 +22851,7 @@
                     goto private_field_already_defined;
                 }
                 if (add_private_class_field(s, fd, name,
-                                            JS_VAR_PRIVATE_FIELD, is_static) < 0)
+                                            JS_VAR_PRIVATE_FIELD) < 0)
                     goto fail;
                 emit_op(s, OP_private_symbol);
                 emit_atom(s, name);
@@ -23287,7 +22941,8 @@
                     func_type = JS_PARSE_FUNC_CLASS_CONSTRUCTOR;
             }
             if (is_private) {
-                class_fields[is_static].need_brand = TRUE;
+                if (add_brand(s, &class_fields[is_static]) < 0)
+                    goto fail;
             }
             if (js_parse_function_decl2(s, func_type, func_kind, JS_ATOM_NULL, start_ptr, s->token.line_num, JS_PARSE_EXPORT_NONE, &method_fd))
                 goto fail;
@@ -23303,7 +22958,7 @@
                     goto fail;
                 }
                 if (add_private_class_field(s, fd, name,
-                                            JS_VAR_PRIVATE_METHOD, is_static) < 0)
+                                            JS_VAR_PRIVATE_METHOD) < 0)
                     goto fail;
                 emit_op(s, OP_set_home_object);
                 emit_op(s, OP_set_name);
@@ -23352,30 +23007,13 @@
     /* consume the '}' */
     if (next_token(s))
         goto fail;
-
-    {
-        ClassFieldsDef *cf = &class_fields[0];
-        int var_idx;
-
-        if (cf->need_brand) {
-            /* add a private brand to the prototype */
-            emit_op(s, OP_dup);
-            emit_op(s, OP_null);
-            emit_op(s, OP_swap);
-            emit_op(s, OP_add_brand);
-
-            /* define the brand field in 'this' of the initializer */
-            if (!cf->fields_init_fd) {
-                if (emit_class_init_start(s, cf))
-                    goto fail;
-            }
-            /* patch the start of the function to enable the
-               OP_add_brand_instance code */
-            cf->fields_init_fd->byte_code.buf[cf->brand_push_pos] = OP_push_true;
-        }
 
-        /* store the function to initialize the fields to that it can be
-           referenced by the constructor */
+    /* store the function to initialize the fields to that it can be
+       referenced by the constructor */
+    {
+        ClassFieldsDef *cf = &class_fields[0];
+        int var_idx;
+
         var_idx = define_var(s, fd, JS_ATOM_class_fields_init,
                              JS_VAR_DEF_CONST);
         if (var_idx < 0)
@@ -23393,11 +23031,14 @@
     /* drop the prototype */
     emit_op(s, OP_drop);
 
-    if (class_fields[1].need_brand) {
-        /* add a private brand to the class */
+    /* initialize the static fields */
+    if (class_fields[1].fields_init_fd != NULL) {
+        ClassFieldsDef *cf = &class_fields[1];
         emit_op(s, OP_dup);
-        emit_op(s, OP_dup);
-        emit_op(s, OP_add_brand);
+        emit_class_init_end(s, cf);
+        emit_op(s, OP_call_method);
+        emit_u16(s, 0);
+        emit_op(s, OP_drop);
     }
 
     if (class_name != JS_ATOM_NULL) {
@@ -23409,17 +23050,6 @@
         emit_atom(s, class_name);
         emit_u16(s, fd->scope_level);
     }
-
-    /* initialize the static fields */
-    if (class_fields[1].fields_init_fd != NULL) {
-        ClassFieldsDef *cf = &class_fields[1];
-        emit_op(s, OP_dup);
-        emit_class_init_end(s, cf);
-        emit_op(s, OP_call_method);
-        emit_u16(s, 0);
-        emit_op(s, OP_drop);
-    }
-
     pop_scope(s);
     pop_scope(s);
 
@@ -24412,7 +24042,7 @@
     emit_label(s, label_next);
 }
 
-/* allowed parse_flags: PF_POSTFIX_CALL */
+/* allowed parse_flags: PF_POSTFIX_CALL, PF_ARROW_FUNC */
 static __exception int js_parse_postfix_expr(JSParseState *s, int parse_flags)
 {
     FuncCallType call_type;
@@ -24515,8 +24145,16 @@
         }
         break;
     case '(':
-        if (js_parse_expr_paren(s))
-            return -1;
+        if ((parse_flags & PF_ARROW_FUNC) &&
+            js_parse_skip_parens_token(s, NULL, TRUE) == TOK_ARROW) {
+            if (js_parse_function_decl(s, JS_PARSE_FUNC_ARROW,
+                                       JS_FUNC_NORMAL, JS_ATOM_NULL,
+                                       s->token.ptr, s->token.line_num))
+                return -1;
+        } else {
+            if (js_parse_expr_paren(s))
+                return -1;
+        }
         break;
     case TOK_FUNCTION:
         if (js_parse_function_decl(s, JS_PARSE_FUNC_EXPR,
@@ -24556,8 +24194,14 @@
             if (s->token.u.ident.is_reserved) {
                 return js_parse_error_reserved_identifier(s);
             }
-            if (token_is_pseudo_keyword(s, JS_ATOM_async) &&
-                peek_token(s, TRUE) != '\n') {
+            if ((parse_flags & PF_ARROW_FUNC) &&
+                peek_token(s, TRUE) == TOK_ARROW) {
+                if (js_parse_function_decl(s, JS_PARSE_FUNC_ARROW,
+                                           JS_FUNC_NORMAL, JS_ATOM_NULL,
+                                           s->token.ptr, s->token.line_num))
+                    return -1;
+            } else if (token_is_pseudo_keyword(s, JS_ATOM_async) &&
+                       peek_token(s, TRUE) != '\n') {
                 const uint8_t *source_ptr;
                 int source_line_num;
 
@@ -24570,6 +24214,15 @@
                                                JS_FUNC_ASYNC, JS_ATOM_NULL,
                                                source_ptr, source_line_num))
                         return -1;
+                } else if ((parse_flags & PF_ARROW_FUNC) &&
+                           ((s->token.val == '(' &&
+                             js_parse_skip_parens_token(s, NULL, TRUE) == TOK_ARROW) ||
+                            (s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved &&
+                             peek_token(s, TRUE) == TOK_ARROW))) {
+                    if (js_parse_function_decl(s, JS_PARSE_FUNC_ARROW,
+                                               JS_FUNC_ASYNC, JS_ATOM_NULL,
+                                               source_ptr, source_line_num))
+                        return -1;
                 } else {
                     name = JS_DupAtom(s->ctx, JS_ATOM_async);
                     goto do_get_var;
@@ -24581,10 +24234,8 @@
                     return -1;
                 }
                 name = JS_DupAtom(s->ctx, s->token.u.ident.atom);
-                if (next_token(s)) {  /* update line number before emitting code */
-                    JS_FreeAtom(s->ctx, name);
+                if (next_token(s))  /* update line number before emitting code */
                     return -1;
-                }
             do_get_var:
                 emit_op(s, OP_scope_get_var);
                 emit_u32(s, name);
@@ -24730,25 +24381,6 @@
                     /* keep the object on the stack */
                     fd->byte_code.buf[fd->last_opcode_pos] = OP_get_field2;
                     drop_count = 2;
-                    break;
-                case OP_get_field_opt_chain:
-                    {
-                        int opt_chain_label, next_label;
-                        opt_chain_label = get_u32(fd->byte_code.buf +
-                                                  fd->last_opcode_pos + 1 + 4 + 1);
-                        /* keep the object on the stack */
-                        fd->byte_code.buf[fd->last_opcode_pos] = OP_get_field2;
-                        fd->byte_code.size = fd->last_opcode_pos + 1 + 4;
-                        next_label = emit_goto(s, OP_goto, -1);
-                        emit_label(s, opt_chain_label);
-                        /* need an additional undefined value for the
-                           case where the optional field does not
-                           exists */
-                        emit_op(s, OP_undefined);
-                        emit_label(s, next_label);
-                        drop_count = 2;
-                        opcode = OP_get_field;
-                    }
                     break;
                 case OP_scope_get_private_field:
                     /* keep the object on the stack */
@@ -24759,25 +24391,6 @@
                     /* keep the object on the stack */
                     fd->byte_code.buf[fd->last_opcode_pos] = OP_get_array_el2;
                     drop_count = 2;
-                    break;
-                case OP_get_array_el_opt_chain:
-                    {
-                        int opt_chain_label, next_label;
-                        opt_chain_label = get_u32(fd->byte_code.buf +
-                                                  fd->last_opcode_pos + 1 + 1);
-                        /* keep the object on the stack */
-                        fd->byte_code.buf[fd->last_opcode_pos] = OP_get_array_el2;
-                        fd->byte_code.size = fd->last_opcode_pos + 1;
-                        next_label = emit_goto(s, OP_goto, -1);
-                        emit_label(s, opt_chain_label);
-                        /* need an additional undefined value for the
-                           case where the optional field does not
-                           exists */
-                        emit_op(s, OP_undefined);
-                        emit_label(s, next_label);
-                        drop_count = 2;
-                        opcode = OP_get_array_el;
-                    }
                     break;
                 case OP_scope_get_var:
                     {
@@ -25061,23 +24674,8 @@
             break;
         }
     }
-    if (optional_chaining_label >= 0) {
-        JSFunctionDef *fd = s->cur_func;
-        int opcode;
-        emit_label_raw(s, optional_chaining_label);
-        /* modify the last opcode so that it is an indicator of an
-           optional chain */
-        opcode = get_prev_opcode(fd);
-        if (opcode == OP_get_field || opcode == OP_get_array_el) {
-            if (opcode == OP_get_field)
-                opcode = OP_get_field_opt_chain;
-            else
-                opcode = OP_get_array_el_opt_chain;
-            fd->byte_code.buf[fd->last_opcode_pos] = opcode;
-        } else {
-            fd->last_opcode_pos = -1;
-        }
-    }
+    if (optional_chaining_label >= 0)
+        emit_label(s, optional_chaining_label);
     return 0;
 }
 
@@ -25093,56 +24691,26 @@
         return -1;
     switch(opcode = get_prev_opcode(fd)) {
     case OP_get_field:
-    case OP_get_field_opt_chain:
         {
             JSValue val;
-            int ret, opt_chain_label, next_label;
-            if (opcode == OP_get_field_opt_chain) {
-                opt_chain_label = get_u32(fd->byte_code.buf +
-                                          fd->last_opcode_pos + 1 + 4 + 1);
-            } else {
-                opt_chain_label = -1;
-            }
+            int ret;
+
             name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
             fd->byte_code.size = fd->last_opcode_pos;
+            fd->last_opcode_pos = -1;
             val = JS_AtomToValue(s->ctx, name);
             ret = emit_push_const(s, val, 1);
             JS_FreeValue(s->ctx, val);
             JS_FreeAtom(s->ctx, name);
             if (ret)
                 return ret;
-            emit_op(s, OP_delete);
-            if (opt_chain_label >= 0) {
-                next_label = emit_goto(s, OP_goto, -1);
-                emit_label(s, opt_chain_label);
-                /* if the optional chain is not taken, return 'true' */
-                emit_op(s, OP_drop);
-                emit_op(s, OP_push_true);
-                emit_label(s, next_label);
-            }
-            fd->last_opcode_pos = -1;
         }
-        break;
+        goto do_delete;
     case OP_get_array_el:
         fd->byte_code.size = fd->last_opcode_pos;
         fd->last_opcode_pos = -1;
+    do_delete:
         emit_op(s, OP_delete);
-        break;
-    case OP_get_array_el_opt_chain:
-        {
-            int opt_chain_label, next_label;
-            opt_chain_label = get_u32(fd->byte_code.buf +
-                                      fd->last_opcode_pos + 1 + 1);
-            fd->byte_code.size = fd->last_opcode_pos;
-            emit_op(s, OP_delete);
-            next_label = emit_goto(s, OP_goto, -1);
-            emit_label(s, opt_chain_label);
-            /* if the optional chain is not taken, return 'true' */
-            emit_op(s, OP_drop);
-            emit_op(s, OP_push_true);
-            emit_label(s, next_label);
-            fd->last_opcode_pos = -1;
-        }
         break;
     case OP_scope_get_var:
         /* 'delete this': this is not a reference */
@@ -25158,8 +24726,6 @@
     case OP_scope_get_private_field:
         return js_parse_error(s, "cannot delete a private class field");
     case OP_get_super_value:
-        fd->byte_code.size = fd->last_opcode_pos;
-        fd->last_opcode_pos = -1;
         emit_op(s, OP_throw_error);
         emit_atom(s, JS_ATOM_NULL);
         emit_u8(s, JS_THROW_ERROR_DELETE_SUPER);
@@ -25173,7 +24739,7 @@
     return 0;
 }
 
-/* allowed parse_flags: PF_POW_ALLOWED, PF_POW_FORBIDDEN */
+/* allowed parse_flags: PF_ARROW_FUNC, PF_POW_ALLOWED, PF_POW_FORBIDDEN */
 static __exception int js_parse_unary(JSParseState *s, int parse_flags)
 {
     int op;
@@ -25259,12 +24825,12 @@
             return -1;
         if (js_parse_unary(s, PF_POW_FORBIDDEN))
             return -1;
-        s->cur_func->has_await = TRUE;
         emit_op(s, OP_await);
         parse_flags = 0;
         break;
     default:
-        if (js_parse_postfix_expr(s, PF_POSTFIX_CALL))
+        if (js_parse_postfix_expr(s, (parse_flags & PF_ARROW_FUNC) |
+                                  PF_POSTFIX_CALL))
             return -1;
         if (!s->got_lf &&
             (s->token.val == TOK_DEC || s->token.val == TOK_INC)) {
@@ -25321,40 +24887,18 @@
     return 0;
 }
 
-/* allowed parse_flags: PF_IN_ACCEPTED */
+/* allowed parse_flags: PF_ARROW_FUNC, PF_IN_ACCEPTED */
 static __exception int js_parse_expr_binary(JSParseState *s, int level,
                                             int parse_flags)
 {
     int op, opcode;
 
     if (level == 0) {
-        return js_parse_unary(s, PF_POW_ALLOWED);
-    } else if (s->token.val == TOK_PRIVATE_NAME &&
-               (parse_flags & PF_IN_ACCEPTED) && level == 4 &&
-               peek_token(s, FALSE) == TOK_IN) {
-        JSAtom atom;
-
-        atom = JS_DupAtom(s->ctx, s->token.u.ident.atom);
-        if (next_token(s))
-            goto fail_private_in;
-        if (s->token.val != TOK_IN)
-            goto fail_private_in;
-        if (next_token(s))
-            goto fail_private_in;
-        if (js_parse_expr_binary(s, level - 1, parse_flags)) {
-        fail_private_in:
-            JS_FreeAtom(s->ctx, atom);
-            return -1;
-        }
-        emit_op(s, OP_scope_in_private_field);
-        emit_atom(s, atom);
-        emit_u16(s, s->cur_func->scope_level);
-        JS_FreeAtom(s->ctx, atom);
-        return 0;
-    } else {
-        if (js_parse_expr_binary(s, level - 1, parse_flags))
-            return -1;
-    }
+        return js_parse_unary(s, (parse_flags & PF_ARROW_FUNC) |
+                              PF_POW_ALLOWED);
+    }
+    if (js_parse_expr_binary(s, level - 1, parse_flags))
+        return -1;
     for(;;) {
         op = s->token.val;
         switch(level) {
@@ -25483,14 +25027,14 @@
         }
         if (next_token(s))
             return -1;
-        if (js_parse_expr_binary(s, level - 1, parse_flags))
+        if (js_parse_expr_binary(s, level - 1, parse_flags & ~PF_ARROW_FUNC))
             return -1;
         emit_op(s, opcode);
     }
     return 0;
 }
 
-/* allowed parse_flags: PF_IN_ACCEPTED */
+/* allowed parse_flags: PF_ARROW_FUNC, PF_IN_ACCEPTED */
 static __exception int js_parse_logical_and_or(JSParseState *s, int op,
                                                int parse_flags)
 {
@@ -25514,11 +25058,11 @@
             emit_op(s, OP_drop);
 
             if (op == TOK_LAND) {
-                if (js_parse_expr_binary(s, 8, parse_flags))
+                if (js_parse_expr_binary(s, 8, parse_flags & ~PF_ARROW_FUNC))
                     return -1;
             } else {
                 if (js_parse_logical_and_or(s, TOK_LAND,
-                                            parse_flags))
+                                            parse_flags & ~PF_ARROW_FUNC))
                     return -1;
             }
             if (s->token.val != op) {
@@ -25550,7 +25094,7 @@
             emit_goto(s, OP_if_false, label1);
             emit_op(s, OP_drop);
 
-            if (js_parse_expr_binary(s, 8, parse_flags))
+            if (js_parse_expr_binary(s, 8, parse_flags & ~PF_ARROW_FUNC))
                 return -1;
             if (s->token.val != TOK_DOUBLE_QUESTION_MARK)
                 break;
@@ -25560,7 +25104,7 @@
     return 0;
 }
 
-/* allowed parse_flags: PF_IN_ACCEPTED */
+/* allowed parse_flags: PF_ARROW_FUNC, PF_IN_ACCEPTED */
 static __exception int js_parse_cond_expr(JSParseState *s, int parse_flags)
 {
     int label1, label2;
@@ -25654,6 +25198,7 @@
                 /* OP_async_yield_star takes the value as parameter */
                 emit_op(s, OP_get_field);
                 emit_atom(s, JS_ATOM_value);
+                emit_op(s, OP_await);
                 emit_op(s, OP_async_yield_star);
             } else {
                 /* OP_yield_star takes (value, done) as parameter */
@@ -25735,50 +25280,12 @@
             emit_label(s, label_next);
         }
         return 0;
-    } else if (s->token.val == '(' &&
-               js_parse_skip_parens_token(s, NULL, TRUE) == TOK_ARROW) {
-        return js_parse_function_decl(s, JS_PARSE_FUNC_ARROW,
-                                      JS_FUNC_NORMAL, JS_ATOM_NULL,
-                                      s->token.ptr, s->token.line_num);
-    } else if (token_is_pseudo_keyword(s, JS_ATOM_async)) {
-        const uint8_t *source_ptr;
-        int source_line_num, tok;
-        JSParsePos pos;
-
-        /* fast test */
-        tok = peek_token(s, TRUE);
-        if (tok == TOK_FUNCTION || tok == '\n')
-            goto next;
-
-        source_ptr = s->token.ptr;
-        source_line_num = s->token.line_num;
-        js_parse_get_pos(s, &pos);
-        if (next_token(s))
-            return -1;
-        if ((s->token.val == '(' &&
-             js_parse_skip_parens_token(s, NULL, TRUE) == TOK_ARROW) ||
-            (s->token.val == TOK_IDENT && !s->token.u.ident.is_reserved &&
-             peek_token(s, TRUE) == TOK_ARROW)) {
-            return js_parse_function_decl(s, JS_PARSE_FUNC_ARROW,
-                                          JS_FUNC_ASYNC, JS_ATOM_NULL,
-                                          source_ptr, source_line_num);
-        } else {
-            /* undo the token parsing */
-            if (js_parse_seek_token(s, &pos))
-                return -1;
-        }
-    } else if (s->token.val == TOK_IDENT &&
-               peek_token(s, TRUE) == TOK_ARROW) {
-        return js_parse_function_decl(s, JS_PARSE_FUNC_ARROW,
-                                      JS_FUNC_NORMAL, JS_ATOM_NULL,
-                                      s->token.ptr, s->token.line_num);
     }
- next:
     if (s->token.val == TOK_IDENT) {
         /* name0 is used to check for OP_set_name pattern, not duplicated */
         name0 = s->token.u.ident.atom;
     }
-    if (js_parse_cond_expr(s, parse_flags))
+    if (js_parse_cond_expr(s, parse_flags | PF_ARROW_FUNC))
         return -1;
 
     op = s->token.val;
@@ -25985,61 +25492,61 @@
 static void emit_return(JSParseState *s, BOOL hasval)
 {
     BlockEnv *top;
+    int drop_count;
 
-    if (s->cur_func->func_kind != JS_FUNC_NORMAL) {
-        if (!hasval) {
-            /* no value: direct return in case of async generator */
-            emit_op(s, OP_undefined);
-            hasval = TRUE;
-        } else if (s->cur_func->func_kind == JS_FUNC_ASYNC_GENERATOR) {
-            /* the await must be done before handling the "finally" in
-               case it raises an exception */
-            emit_op(s, OP_await);
-        }
-    }
-
+    drop_count = 0;
     top = s->cur_func->top_break;
     while (top != NULL) {
-        if (top->has_iterator || top->label_finally != -1) {
+        /* XXX: emit the appropriate OP_leave_scope opcodes? Probably not
+           required as all local variables will be closed upon returning
+           from JS_CallInternal, but not in the same order. */
+        if (top->has_iterator) {
+            /* with 'yield', the exact number of OP_drop to emit is
+               unknown, so we use a specific operation to look for
+               the catch offset */
             if (!hasval) {
                 emit_op(s, OP_undefined);
                 hasval = TRUE;
             }
-            /* Remove the stack elements up to and including the catch
-               offset. When 'yield' is used in an expression we have
-               no easy way to count them, so we use this specific
-               instruction instead. */
-            emit_op(s, OP_nip_catch);
-            /* stack: iter_obj next ret_val */
-            if (top->has_iterator) {
-                if (s->cur_func->func_kind == JS_FUNC_ASYNC_GENERATOR) {
-                    int label_next, label_next2;
-                    emit_op(s, OP_nip); /* next */
-                    emit_op(s, OP_swap);
-                    emit_op(s, OP_get_field2);
-                    emit_atom(s, JS_ATOM_return);
-                    /* stack: iter_obj return_func */
-                    emit_op(s, OP_dup);
-                    emit_op(s, OP_is_undefined_or_null);
-                    label_next = emit_goto(s, OP_if_true, -1);
-                    emit_op(s, OP_call_method);
-                    emit_u16(s, 0);
-                    emit_op(s, OP_iterator_check_object);
-                    emit_op(s, OP_await);
-                    label_next2 = emit_goto(s, OP_goto, -1);
-                    emit_label(s, label_next);
-                    emit_op(s, OP_drop);
-                    emit_label(s, label_next2);
-                    emit_op(s, OP_drop);
-                } else {
-                    emit_op(s, OP_rot3r);
-                    emit_op(s, OP_undefined); /* dummy catch offset */
-                    emit_op(s, OP_iterator_close);
-                }
-            } else {
-                /* execute the "finally" block */
-                emit_goto(s, OP_gosub, top->label_finally);
-            }
+            emit_op(s, OP_iterator_close_return);
+            if (s->cur_func->func_kind == JS_FUNC_ASYNC_GENERATOR) {
+                int label_next, label_next2;
+
+                emit_op(s, OP_drop); /* catch offset */
+                emit_op(s, OP_drop); /* next */
+                emit_op(s, OP_get_field2);
+                emit_atom(s, JS_ATOM_return);
+                /* stack: iter_obj return_func */
+                emit_op(s, OP_dup);
+                emit_op(s, OP_is_undefined_or_null);
+                label_next = emit_goto(s, OP_if_true, -1);
+                emit_op(s, OP_call_method);
+                emit_u16(s, 0);
+                emit_op(s, OP_iterator_check_object);
+                emit_op(s, OP_await);
+                label_next2 = emit_goto(s, OP_goto, -1);
+                emit_label(s, label_next);
+                emit_op(s, OP_drop);
+                emit_label(s, label_next2);
+                emit_op(s, OP_drop);
+            } else {
+                emit_op(s, OP_iterator_close);
+            }
+            drop_count = -3;
+        }
+        drop_count += top->drop_count;
+        if (top->label_finally != -1) {
+            while(drop_count) {
+                /* must keep the stack top if hasval */
+                emit_op(s, hasval ? OP_nip : OP_drop);
+                drop_count--;
+            }
+            if (!hasval) {
+                /* must push return value to keep same stack size */
+                emit_op(s, OP_undefined);
+                hasval = TRUE;
+            }
+            emit_goto(s, OP_gosub, top->label_finally);
         }
         top = top->prev;
     }
@@ -26056,15 +25563,20 @@
             label_return = -1;
         }
 
-        /* The error should be raised in the caller context, so we use
-           a specific opcode */
-        emit_op(s, OP_scope_get_var_checkthis);
+        /* XXX: if this is not initialized, should throw the
+           ReferenceError in the caller realm */
+        emit_op(s, OP_scope_get_var);
         emit_atom(s, JS_ATOM_this);
         emit_u16(s, 0);
 
         emit_label(s, label_return);
         emit_op(s, OP_return);
     } else if (s->cur_func->func_kind != JS_FUNC_NORMAL) {
+        if (!hasval) {
+            emit_op(s, OP_undefined);
+        } else if (s->cur_func->func_kind == JS_FUNC_ASYNC_GENERATOR) {
+            emit_op(s, OP_await);
+        }
         emit_op(s, OP_return_async);
     } else {
         emit_op(s, hasval ? OP_return : OP_return_undef);
@@ -26331,9 +25843,6 @@
             emit_atom(s, var_name);
             emit_u16(s, fd->scope_level);
         }
-    } else if (!is_async && token_is_pseudo_keyword(s, JS_ATOM_async) &&
-               peek_token(s, FALSE) == TOK_OF) {
-        return js_parse_error(s, "'for of' expression cannot start with 'async'");
     } else {
         int skip_bits;
         if ((s->token.val == '[' || s->token.val == '{')
@@ -26550,10 +26059,6 @@
             js_parse_error(s, "return not in a function");
             goto fail;
         }
-        if (s->cur_func->func_type == JS_PARSE_FUNC_CLASS_STATIC_INIT) {
-            js_parse_error(s, "return in a static initializer block");
-            goto fail;
-        }
         if (next_token(s))
             goto fail;
         if (s->token.val != ';' && s->token.val != '}' && !s->got_lf) {
@@ -26722,7 +26227,6 @@
                 is_async = TRUE;
                 if (next_token(s))
                     goto fail;
-                s->cur_func->has_await = TRUE;
             }
             if (js_parse_expect(s, '('))
                 goto fail;
@@ -27253,9 +26757,6 @@
     m->func_obj = JS_UNDEFINED;
     m->eval_exception = JS_UNDEFINED;
     m->meta_obj = JS_UNDEFINED;
-    m->promise = JS_UNDEFINED;
-    m->resolving_funcs[0] = JS_UNDEFINED;
-    m->resolving_funcs[1] = JS_UNDEFINED;
     list_add_tail(&m->link, &ctx->loaded_modules);
     return m;
 }
@@ -27277,9 +26778,6 @@
     JS_MarkValue(rt, m->func_obj, mark_func);
     JS_MarkValue(rt, m->eval_exception, mark_func);
     JS_MarkValue(rt, m->meta_obj, mark_func);
-    JS_MarkValue(rt, m->promise, mark_func);
-    JS_MarkValue(rt, m->resolving_funcs[0], mark_func);
-    JS_MarkValue(rt, m->resolving_funcs[1], mark_func);
 }
 
 static void js_free_module_def(JSContext *ctx, JSModuleDef *m)
@@ -27310,15 +26808,11 @@
         JS_FreeAtom(ctx, mi->import_name);
     }
     js_free(ctx, m->import_entries);
-    js_free(ctx, m->async_parent_modules);
 
     JS_FreeValue(ctx, m->module_ns);
     JS_FreeValue(ctx, m->func_obj);
     JS_FreeValue(ctx, m->eval_exception);
     JS_FreeValue(ctx, m->meta_obj);
-    JS_FreeValue(ctx, m->promise);
-    JS_FreeValue(ctx, m->resolving_funcs[0]);
-    JS_FreeValue(ctx, m->resolving_funcs[1]);
     list_del(&m->link);
     js_free(ctx, m);
 }
@@ -27479,7 +26973,6 @@
 {
     char *filename, *p;
     const char *r;
-    int cap;
     int len;
 
     if (name[0] != '.') {
@@ -27493,8 +26986,7 @@
     else
         len = 0;
 
-    cap = len + strlen(name) + 1 + 1;
-    filename = js_malloc(ctx, cap);
+    filename = js_malloc(ctx, len + strlen(name) + 1 + 1);
     if (!filename)
         return NULL;
     memcpy(filename, base_name, len);
@@ -27526,8 +27018,8 @@
         }
     }
     if (filename[0] != '\0')
-        pstrcat(filename, cap, "/");
-    pstrcat(filename, cap, r);
+        strcat(filename, "/");
+    strcat(filename, r);
     //    printf("normalize: %s %s -> %s\n", base_name, name, filename);
     return filename;
 }
@@ -27909,11 +27401,13 @@
     return ret;
 }
 
+static JSValue js_get_module_ns(JSContext *ctx, JSModuleDef *m);
+
 static JSValue js_module_ns_autoinit(JSContext *ctx, JSObject *p, JSAtom atom,
                                      void *opaque)
 {
     JSModuleDef *m = opaque;
-    return JS_GetModuleNamespace(ctx, m);
+    return js_get_module_ns(ctx, m);
 }
 
 static JSValue js_build_module_ns(JSContext *ctx, JSModuleDef *m)
@@ -28019,7 +27513,7 @@
     return JS_EXCEPTION;
 }
 
-JSValue JS_GetModuleNamespace(JSContext *ctx, JSModuleDef *m)
+static JSValue js_get_module_ns(JSContext *ctx, JSModuleDef *m)
 {
     if (JS_IsUndefined(m->module_ns)) {
         JSValue val;
@@ -28174,8 +27668,7 @@
 
 /* Prepare a module to be executed by resolving all the imported
    variables. */
-static int js_inner_module_linking(JSContext *ctx, JSModuleDef *m,
-                                   JSModuleDef **pstack_top, int index)
+static int js_link_module(JSContext *ctx, JSModuleDef *m)
 {
     int i;
     JSImportEntry *mi;
@@ -28185,47 +27678,21 @@
     BOOL is_c_module;
     JSValue ret_val;
 
-    if (js_check_stack_overflow(ctx->rt, 0)) {
-        JS_ThrowStackOverflow(ctx);
-        return -1;
-    }
+    if (m->instantiated)
+        return 0;
+    m->instantiated = TRUE;
 
 #ifdef DUMP_MODULE_RESOLVE
     {
         char buf1[ATOM_GET_STR_BUF_SIZE];
-        printf("js_inner_module_linking '%s':\n", JS_AtomGetStr(ctx, buf1, sizeof(buf1), m->module_name));
+        printf("start instantiating module '%s':\n", JS_AtomGetStr(ctx, buf1, sizeof(buf1), m->module_name));
     }
 #endif
 
-    if (m->status == JS_MODULE_STATUS_LINKING ||
-        m->status == JS_MODULE_STATUS_LINKED ||
-        m->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
-        m->status == JS_MODULE_STATUS_EVALUATED)
-        return index;
-
-    assert(m->status == JS_MODULE_STATUS_UNLINKED);
-    m->status = JS_MODULE_STATUS_LINKING;
-    m->dfs_index = index;
-    m->dfs_ancestor_index = index;
-    index++;
-    /* push 'm' on stack */
-    m->stack_prev = *pstack_top;
-    *pstack_top = m;
-
     for(i = 0; i < m->req_module_entries_count; i++) {
         JSReqModuleEntry *rme = &m->req_module_entries[i];
-        m1 = rme->module;
-        index = js_inner_module_linking(ctx, m1, pstack_top, index);
-        if (index < 0)
+        if (js_link_module(ctx, rme->module) < 0)
             goto fail;
-        assert(m1->status == JS_MODULE_STATUS_LINKING ||
-               m1->status == JS_MODULE_STATUS_LINKED ||
-               m1->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
-               m1->status == JS_MODULE_STATUS_EVALUATED);
-        if (m1->status == JS_MODULE_STATUS_LINKING) {
-            m->dfs_ancestor_index = min_int(m->dfs_ancestor_index,
-                                            m1->dfs_ancestor_index);
-        }
     }
 
 #ifdef DUMP_MODULE_RESOLVE
@@ -28280,7 +27747,7 @@
             if (mi->import_name == JS_ATOM__star_) {
                 JSValue val;
                 /* name space import */
-                val = JS_GetModuleNamespace(ctx, m1);
+                val = js_get_module_ns(ctx, m1);
                 if (JS_IsException(val))
                     goto fail;
                 set_value(ctx, &var_refs[mi->var_idx]->value, val);
@@ -28304,7 +27771,7 @@
                     JSModuleDef *m2;
                     /* name space import from */
                     m2 = res_m->req_module_entries[res_me->u.req_module_idx].module;
-                    val = JS_GetModuleNamespace(ctx, m2);
+                    val = js_get_module_ns(ctx, m2);
                     if (JS_IsException(val))
                         goto fail;
                     var_ref = js_create_module_var(ctx, TRUE);
@@ -28351,59 +27818,14 @@
         JS_FreeValue(ctx, ret_val);
     }
 
-    assert(m->dfs_ancestor_index <= m->dfs_index);
-    if (m->dfs_index == m->dfs_ancestor_index) {
-        for(;;) {
-            /* pop m1 from stack */
-            m1 = *pstack_top;
-            *pstack_top = m1->stack_prev;
-            m1->status = JS_MODULE_STATUS_LINKED;
-            if (m1 == m)
-                break;
-        }
-    }
-
 #ifdef DUMP_MODULE_RESOLVE
-    printf("js_inner_module_linking done\n");
+    printf("done instantiate\n");
 #endif
-    return index;
+    return 0;
  fail:
     return -1;
 }
 
-/* Prepare a module to be executed by resolving all the imported
-   variables. */
-static int js_link_module(JSContext *ctx, JSModuleDef *m)
-{
-    JSModuleDef *stack_top, *m1;
-
-#ifdef DUMP_MODULE_RESOLVE
-    {
-        char buf1[ATOM_GET_STR_BUF_SIZE];
-        printf("js_link_module '%s':\n", JS_AtomGetStr(ctx, buf1, sizeof(buf1), m->module_name));
-    }
-#endif
-    assert(m->status == JS_MODULE_STATUS_UNLINKED ||
-           m->status == JS_MODULE_STATUS_LINKED ||
-           m->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
-           m->status == JS_MODULE_STATUS_EVALUATED);
-    stack_top = NULL;
-    if (js_inner_module_linking(ctx, m, &stack_top, 0) < 0) {
-        while (stack_top != NULL) {
-            m1 = stack_top;
-            assert(m1->status == JS_MODULE_STATUS_LINKING);
-            m1->status = JS_MODULE_STATUS_UNLINKED;
-            stack_top = m1->stack_prev;
-        }
-        return -1;
-    }
-    assert(stack_top == NULL);
-    assert(m->status == JS_MODULE_STATUS_LINKED ||
-           m->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
-           m->status == JS_MODULE_STATUS_EVALUATED);
-    return 0;
-}
-
 /* return JS_ATOM_NULL if the name cannot be found. Only works with
    not striped bytecode functions. */
 JSAtom JS_GetScriptOrModuleName(JSContext *ctx, int n_stack_levels)
@@ -28412,8 +27834,8 @@
     JSFunctionBytecode *b;
     JSObject *p;
     /* XXX: currently we just use the filename of the englobing
-       function from the debug info. May need to add a ScriptOrModule
-       info in JSFunctionBytecode. */
+       function. It does not work for eval(). Need to add a
+       ScriptOrModule info in JSFunctionBytecode */
     sf = ctx->rt->current_stack_frame;
     if (!sf)
         return JS_ATOM_NULL;
@@ -28422,23 +27844,15 @@
         if (!sf)
             return JS_ATOM_NULL;
     }
-    for(;;) {
-        if (JS_VALUE_GET_TAG(sf->cur_func) != JS_TAG_OBJECT)
-            return JS_ATOM_NULL;
-        p = JS_VALUE_GET_OBJ(sf->cur_func);
-        if (!js_class_has_bytecode(p->class_id))
-            return JS_ATOM_NULL;
-        b = p->u.func.function_bytecode;
-        if (!b->is_direct_or_indirect_eval) {
-            if (!b->has_debug)
-                return JS_ATOM_NULL;
-            return JS_DupAtom(ctx, b->debug.filename);
-        } else {
-            sf = sf->prev_frame;
-            if (!sf)
-                return JS_ATOM_NULL;
-        }
-    }
+    if (JS_VALUE_GET_TAG(sf->cur_func) != JS_TAG_OBJECT)
+        return JS_ATOM_NULL;
+    p = JS_VALUE_GET_OBJ(sf->cur_func);
+    if (!js_class_has_bytecode(p->class_id))
+        return JS_ATOM_NULL;
+    b = p->u.func.function_bytecode;
+    if (!b->has_debug)
+        return JS_ATOM_NULL;
+    return JS_DupAtom(ctx, b->debug.filename);
 }
 
 JSAtom JS_GetModuleName(JSContext *ctx, JSModuleDef *m)
@@ -28481,110 +27895,29 @@
     return JS_GetImportMeta(ctx, m);
 }
 
-static JSValue JS_NewModuleValue(JSContext *ctx, JSModuleDef *m)
-{
-    return JS_DupValue(ctx, JS_MKPTR(JS_TAG_MODULE, m));
-}
-
-static JSValue js_load_module_rejected(JSContext *ctx, JSValueConst this_val,
-                                       int argc, JSValueConst *argv, int magic, JSValue *func_data)
+/* used by os.Worker() and import() */
+JSModuleDef *JS_RunModule(JSContext *ctx, const char *basename,
+                          const char *filename)
 {
-    JSValueConst *resolving_funcs = (JSValueConst *)func_data;
-    JSValueConst error;
-    JSValue ret;
-
-    /* XXX: check if the test is necessary */
-    if (argc >= 1)
-        error = argv[0];
-    else
-        error = JS_UNDEFINED;
-    ret = JS_Call(ctx, resolving_funcs[1], JS_UNDEFINED,
-                  1, &error);
-    JS_FreeValue(ctx, ret);
-    return JS_UNDEFINED;
-}
-
-static JSValue js_load_module_fulfilled(JSContext *ctx, JSValueConst this_val,
-                                        int argc, JSValueConst *argv, int magic, JSValue *func_data)
-{
-    JSValueConst *resolving_funcs = (JSValueConst *)func_data;
-    JSModuleDef *m = JS_VALUE_GET_PTR(func_data[2]);
-    JSValue ret, ns;
-
-    /* return the module namespace */
-    ns = JS_GetModuleNamespace(ctx, m);
-    if (JS_IsException(ns)) {
-        JSValue err = JS_GetException(ctx);
-        js_load_module_rejected(ctx, JS_UNDEFINED, 1, (JSValueConst *)&err, 0, func_data);
-        return JS_UNDEFINED;
-    }
-    ret = JS_Call(ctx, resolving_funcs[0], JS_UNDEFINED,
-                   1, (JSValueConst *)&ns);
-    JS_FreeValue(ctx, ret);
-    JS_FreeValue(ctx, ns);
-    return JS_UNDEFINED;
-}
-
-static void JS_LoadModuleInternal(JSContext *ctx, const char *basename,
-                                  const char *filename,
-                                  JSValueConst *resolving_funcs)
-{
-    JSValue evaluate_promise;
     JSModuleDef *m;
-    JSValue ret, err, func_obj, evaluate_resolving_funcs[2];
-    JSValueConst func_data[3];
+    JSValue ret, func_obj;
 
     m = js_host_resolve_imported_module(ctx, basename, filename);
     if (!m)
-        goto fail;
+        return NULL;
 
     if (js_resolve_module(ctx, m) < 0) {
         js_free_modules(ctx, JS_FREE_MODULE_NOT_RESOLVED);
-        goto fail;
+        return NULL;
     }
 
     /* Evaluate the module code */
-    func_obj = JS_NewModuleValue(ctx, m);
-    evaluate_promise = JS_EvalFunction(ctx, func_obj);
-    if (JS_IsException(evaluate_promise)) {
-    fail:
-        err = JS_GetException(ctx);
-        ret = JS_Call(ctx, resolving_funcs[1], JS_UNDEFINED,
-                      1, (JSValueConst *)&err);
-        JS_FreeValue(ctx, ret); /* XXX: what to do if exception ? */
-        JS_FreeValue(ctx, err);
-        return;
-    }
-
-    func_obj = JS_NewModuleValue(ctx, m);
-    func_data[0] = resolving_funcs[0];
-    func_data[1] = resolving_funcs[1];
-    func_data[2] = func_obj;
-    evaluate_resolving_funcs[0] = JS_NewCFunctionData(ctx, js_load_module_fulfilled, 0, 0, 3, func_data);
-    evaluate_resolving_funcs[1] = JS_NewCFunctionData(ctx, js_load_module_rejected, 0, 0, 3, func_data);
-    JS_FreeValue(ctx, func_obj);
-    ret = js_promise_then(ctx, evaluate_promise, 2, (JSValueConst *)evaluate_resolving_funcs);
+    func_obj = JS_DupValue(ctx, JS_MKPTR(JS_TAG_MODULE, m));
+    ret = JS_EvalFunction(ctx, func_obj);
+    if (JS_IsException(ret))
+        return NULL;
     JS_FreeValue(ctx, ret);
-    JS_FreeValue(ctx, evaluate_resolving_funcs[0]);
-    JS_FreeValue(ctx, evaluate_resolving_funcs[1]);
-    JS_FreeValue(ctx, evaluate_promise);
-}
-
-/* Return a promise or an exception in case of memory error. Used by
-   os.Worker() */
-JSValue JS_LoadModule(JSContext *ctx, const char *basename,
-                      const char *filename)
-{
-    JSValue promise, resolving_funcs[2];
-
-    promise = JS_NewPromiseCapability(ctx, resolving_funcs);
-    if (JS_IsException(promise))
-        return JS_EXCEPTION;
-    JS_LoadModuleInternal(ctx, basename, filename,
-                          (JSValueConst *)resolving_funcs);
-    JS_FreeValue(ctx, resolving_funcs[0]);
-    JS_FreeValue(ctx, resolving_funcs[1]);
-    return promise;
+    return m;
 }
 
 static JSValue js_dynamic_import_job(JSContext *ctx,
@@ -28593,8 +27926,9 @@
     JSValueConst *resolving_funcs = argv;
     JSValueConst basename_val = argv[2];
     JSValueConst specifier = argv[3];
+    JSModuleDef *m;
     const char *basename = NULL, *filename;
-    JSValue ret, err;
+    JSValue ret, err, ns;
 
     if (!JS_IsString(basename_val)) {
         JS_ThrowTypeError(ctx, "no function filename for import()");
@@ -28608,12 +27942,24 @@
     if (!filename)
         goto exception;
 
-    JS_LoadModuleInternal(ctx, basename, filename,
-                          resolving_funcs);
+    m = JS_RunModule(ctx, basename, filename);
     JS_FreeCString(ctx, filename);
+    if (!m)
+        goto exception;
+
+    /* return the module namespace */
+    ns = js_get_module_ns(ctx, m);
+    if (JS_IsException(ns))
+        goto exception;
+
+    ret = JS_Call(ctx, resolving_funcs[0], JS_UNDEFINED,
+                   1, (JSValueConst *)&ns);
+    JS_FreeValue(ctx, ret); /* XXX: what to do if exception ? */
+    JS_FreeValue(ctx, ns);
     JS_FreeCString(ctx, basename);
     return JS_UNDEFINED;
  exception:
+
     err = JS_GetException(ctx);
     ret = JS_Call(ctx, resolving_funcs[1], JS_UNDEFINED,
                    1, (JSValueConst *)&err);
@@ -28649,8 +27995,6 @@
     args[2] = basename_val;
     args[3] = specifier;
 
-    /* cannot run JS_LoadModuleInternal synchronously because it would
-       cause an unexpected recursion in js_evaluate_module() */
     JS_EnqueueJob(ctx, js_dynamic_import_job, 4, args);
 
     JS_FreeValue(ctx, basename_val);
@@ -28659,397 +28003,60 @@
     return promise;
 }
 
-static void js_set_module_evaluated(JSContext *ctx, JSModuleDef *m)
-{
-    m->status = JS_MODULE_STATUS_EVALUATED;
-    if (!JS_IsUndefined(m->promise)) {
-        JSValue value, ret_val;
-        assert(m->cycle_root == m);
-        value = JS_UNDEFINED;
-        ret_val = JS_Call(ctx, m->resolving_funcs[0], JS_UNDEFINED,
-                          1, (JSValueConst *)&value);
-        JS_FreeValue(ctx, ret_val);
-    }
-}
-
-typedef struct {
-    JSModuleDef **tab;
-    int count;
-    int size;
-} ExecModuleList;
-
-/* XXX: slow. Could use a linked list instead of ExecModuleList */
-static BOOL find_in_exec_module_list(ExecModuleList *exec_list, JSModuleDef *m)
-{
-    int i;
-    for(i = 0; i < exec_list->count; i++) {
-        if (exec_list->tab[i] == m)
-            return TRUE;
-    }
-    return FALSE;
-}
-
-static int gather_available_ancestors(JSContext *ctx, JSModuleDef *module,
-                                      ExecModuleList *exec_list)
-{
-    int i;
-
-    if (js_check_stack_overflow(ctx->rt, 0)) {
-        JS_ThrowStackOverflow(ctx);
-        return -1;
-    }
-    for(i = 0; i < module->async_parent_modules_count; i++) {
-        JSModuleDef *m = module->async_parent_modules[i];
-        if (!find_in_exec_module_list(exec_list, m) &&
-            !m->cycle_root->eval_has_exception) {
-            assert(m->status == JS_MODULE_STATUS_EVALUATING_ASYNC);
-            assert(!m->eval_has_exception);
-            assert(m->async_evaluation);
-            assert(m->pending_async_dependencies > 0);
-            m->pending_async_dependencies--;
-            if (m->pending_async_dependencies == 0) {
-                if (js_resize_array(ctx, (void **)&exec_list->tab, sizeof(exec_list->tab[0]), &exec_list->size, exec_list->count + 1)) {
-                    return -1;
-                }
-                exec_list->tab[exec_list->count++] = m;
-                if (!m->has_tla) {
-                    if (gather_available_ancestors(ctx, m, exec_list))
-                        return -1;
-                }
-            }
-        }
-    }
-    return 0;
-}
-
-static int exec_module_list_cmp(const void *p1, const void *p2, void *opaque)
-{
-    JSModuleDef *m1 = *(JSModuleDef **)p1;
-    JSModuleDef *m2 = *(JSModuleDef **)p2;
-    return (m1->async_evaluation_timestamp > m2->async_evaluation_timestamp) -
-        (m1->async_evaluation_timestamp < m2->async_evaluation_timestamp);
-}
-
-static int js_execute_async_module(JSContext *ctx, JSModuleDef *m);
-static int js_execute_sync_module(JSContext *ctx, JSModuleDef *m,
-                                  JSValue *pvalue);
-
-static JSValue js_async_module_execution_rejected(JSContext *ctx, JSValueConst this_val,
-                                                  int argc, JSValueConst *argv, int magic, JSValue *func_data)
-{
-    JSModuleDef *module = JS_VALUE_GET_PTR(func_data[0]);
-    JSValueConst error = argv[0];
-    int i;
-
-    if (js_check_stack_overflow(ctx->rt, 0))
-        return JS_ThrowStackOverflow(ctx);
-
-    if (module->status == JS_MODULE_STATUS_EVALUATED) {
-        assert(module->eval_has_exception);
-        return JS_UNDEFINED;
-    }
-
-    assert(module->status == JS_MODULE_STATUS_EVALUATING_ASYNC);
-    assert(!module->eval_has_exception);
-    assert(module->async_evaluation);
-
-    module->eval_has_exception = TRUE;
-    module->eval_exception = JS_DupValue(ctx, error);
-    module->status = JS_MODULE_STATUS_EVALUATED;
-
-    for(i = 0; i < module->async_parent_modules_count; i++) {
-        JSModuleDef *m = module->async_parent_modules[i];
-        JSValue m_obj = JS_NewModuleValue(ctx, m);
-        js_async_module_execution_rejected(ctx, JS_UNDEFINED, 1, &error, 0,
-                                           &m_obj);
-        JS_FreeValue(ctx, m_obj);
-    }
-
-    if (!JS_IsUndefined(module->promise)) {
-        JSValue ret_val;
-        assert(module->cycle_root == module);
-        ret_val = JS_Call(ctx, module->resolving_funcs[1], JS_UNDEFINED,
-                          1, &error);
-        JS_FreeValue(ctx, ret_val);
-    }
-    return JS_UNDEFINED;
-}
-
-static JSValue js_async_module_execution_fulfilled(JSContext *ctx, JSValueConst this_val,
-                                                   int argc, JSValueConst *argv, int magic, JSValue *func_data)
-{
-    JSModuleDef *module = JS_VALUE_GET_PTR(func_data[0]);
-    ExecModuleList exec_list_s, *exec_list = &exec_list_s;
-    int i;
-
-    if (module->status == JS_MODULE_STATUS_EVALUATED) {
-        assert(module->eval_has_exception);
-        return JS_UNDEFINED;
-    }
-    assert(module->status == JS_MODULE_STATUS_EVALUATING_ASYNC);
-    assert(!module->eval_has_exception);
-    assert(module->async_evaluation);
-    module->async_evaluation = FALSE;
-    js_set_module_evaluated(ctx, module);
-
-    exec_list->tab = NULL;
-    exec_list->count = 0;
-    exec_list->size = 0;
-
-    if (gather_available_ancestors(ctx, module, exec_list) < 0) {
-        js_free(ctx, exec_list->tab);
-        return JS_EXCEPTION;
-    }
-
-    /* sort by increasing async_evaluation timestamp */
-    rqsort(exec_list->tab, exec_list->count, sizeof(exec_list->tab[0]),
-           exec_module_list_cmp, NULL);
-
-    for(i = 0; i < exec_list->count; i++) {
-        JSModuleDef *m = exec_list->tab[i];
-        if (m->status == JS_MODULE_STATUS_EVALUATED) {
-            assert(m->eval_has_exception);
-        } else if (m->has_tla) {
-            js_execute_async_module(ctx, m);
-        } else {
-            JSValue error;
-            if (js_execute_sync_module(ctx, m, &error) < 0) {
-                JSValue m_obj = JS_NewModuleValue(ctx, m);
-                js_async_module_execution_rejected(ctx, JS_UNDEFINED,
-                                                   1, (JSValueConst *)&error, 0,
-                                                   &m_obj);
-                JS_FreeValue(ctx, m_obj);
-                JS_FreeValue(ctx, error);
-            } else {
-                js_set_module_evaluated(ctx, m);
-            }
-        }
-    }
-    js_free(ctx, exec_list->tab);
-    return JS_UNDEFINED;
-}
-
-static int js_execute_async_module(JSContext *ctx, JSModuleDef *m)
-{
-    JSValue promise, m_obj;
-    JSValue resolve_funcs[2], ret_val;
-    promise = js_async_function_call(ctx, m->func_obj, JS_UNDEFINED, 0, NULL, 0);
-    if (JS_IsException(promise))
-        return -1;
-    m_obj = JS_NewModuleValue(ctx, m);
-    resolve_funcs[0] = JS_NewCFunctionData(ctx, js_async_module_execution_fulfilled, 0, 0, 1, (JSValueConst *)&m_obj);
-    resolve_funcs[1] = JS_NewCFunctionData(ctx, js_async_module_execution_rejected, 0, 0, 1, (JSValueConst *)&m_obj);
-    ret_val = js_promise_then(ctx, promise, 2, (JSValueConst *)resolve_funcs);
-    JS_FreeValue(ctx, ret_val);
-    JS_FreeValue(ctx, m_obj);
-    JS_FreeValue(ctx, resolve_funcs[0]);
-    JS_FreeValue(ctx, resolve_funcs[1]);
-    JS_FreeValue(ctx, promise);
-    return 0;
-}
-
-/* return < 0 in case of exception. *pvalue contains the exception. */
-static int js_execute_sync_module(JSContext *ctx, JSModuleDef *m,
-                                  JSValue *pvalue)
-{
-    if (m->init_func) {
-        /* C module init : no asynchronous execution */
-        if (m->init_func(ctx, m) < 0)
-            goto fail;
-    } else {
-        JSValue promise;
-        JSPromiseStateEnum state;
-
-        promise = js_async_function_call(ctx, m->func_obj, JS_UNDEFINED, 0, NULL, 0);
-        if (JS_IsException(promise))
-            goto fail;
-        state = JS_PromiseState(ctx, promise);
-        if (state == JS_PROMISE_FULFILLED) {
-            JS_FreeValue(ctx, promise);
-        } else if (state == JS_PROMISE_REJECTED) {
-            *pvalue = JS_PromiseResult(ctx, promise);
-            JS_FreeValue(ctx, promise);
-            return -1;
-        } else {
-            JS_FreeValue(ctx, promise);
-            JS_ThrowTypeError(ctx, "promise is pending");
-        fail:
-            *pvalue = JS_GetException(ctx);
-            return -1;
-        }
-    }
-    *pvalue = JS_UNDEFINED;
-    return 0;
-}
-
-/* spec: InnerModuleEvaluation. Return (index, JS_UNDEFINED) or (-1,
-   exception) */
-static int js_inner_module_evaluation(JSContext *ctx, JSModuleDef *m,
-                                      int index, JSModuleDef **pstack_top,
-                                      JSValue *pvalue)
+/* Run the <eval> function of the module and of all its requested
+   modules. */
+static JSValue js_evaluate_module(JSContext *ctx, JSModuleDef *m)
 {
     JSModuleDef *m1;
     int i;
+    JSValue ret_val;
 
-    if (js_check_stack_overflow(ctx->rt, 0)) {
-        JS_ThrowStackOverflow(ctx);
-        *pvalue = JS_GetException(ctx);
-        return -1;
-    }
+    if (m->eval_mark)
+        return JS_UNDEFINED; /* avoid cycles */
 
-#ifdef DUMP_MODULE_RESOLVE
-    {
-        char buf1[ATOM_GET_STR_BUF_SIZE];
-        printf("js_inner_module_evaluation '%s':\n", JS_AtomGetStr(ctx, buf1, sizeof(buf1), m->module_name));
-    }
-#endif
-
-    if (m->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
-        m->status == JS_MODULE_STATUS_EVALUATED) {
+    if (m->evaluated) {
+        /* if the module was already evaluated, rethrow the exception
+           it raised */
         if (m->eval_has_exception) {
-            *pvalue = JS_DupValue(ctx, m->eval_exception);
-            return -1;
+            return JS_Throw(ctx, JS_DupValue(ctx, m->eval_exception));
         } else {
-            *pvalue = JS_UNDEFINED;
-            return index;
+            return JS_UNDEFINED;
         }
     }
-    if (m->status == JS_MODULE_STATUS_EVALUATING) {
-        *pvalue = JS_UNDEFINED;
-        return index;
-    }
-    assert(m->status == JS_MODULE_STATUS_LINKED);
 
-    m->status = JS_MODULE_STATUS_EVALUATING;
-    m->dfs_index = index;
-    m->dfs_ancestor_index = index;
-    m->pending_async_dependencies = 0;
-    index++;
-    /* push 'm' on stack */
-    m->stack_prev = *pstack_top;
-    *pstack_top = m;
+    m->eval_mark = TRUE;
 
     for(i = 0; i < m->req_module_entries_count; i++) {
         JSReqModuleEntry *rme = &m->req_module_entries[i];
         m1 = rme->module;
-        index = js_inner_module_evaluation(ctx, m1, index, pstack_top, pvalue);
-        if (index < 0)
-            return -1;
-        assert(m1->status == JS_MODULE_STATUS_EVALUATING ||
-               m1->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
-               m1->status == JS_MODULE_STATUS_EVALUATED);
-        if (m1->status == JS_MODULE_STATUS_EVALUATING) {
-            m->dfs_ancestor_index = min_int(m->dfs_ancestor_index,
-                                            m1->dfs_ancestor_index);
-        } else {
-            m1 = m1->cycle_root;
-            assert(m1->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
-                   m1->status == JS_MODULE_STATUS_EVALUATED);
-            if (m1->eval_has_exception) {
-                *pvalue = JS_DupValue(ctx, m1->eval_exception);
-                return -1;
+        if (!m1->eval_mark) {
+            ret_val = js_evaluate_module(ctx, m1);
+            if (JS_IsException(ret_val)) {
+                m->eval_mark = FALSE;
+                return ret_val;
             }
-        }
-        if (m1->async_evaluation) {
-            m->pending_async_dependencies++;
-            if (js_resize_array(ctx, (void **)&m1->async_parent_modules, sizeof(m1->async_parent_modules[0]), &m1->async_parent_modules_size, m1->async_parent_modules_count + 1)) {
-                *pvalue = JS_GetException(ctx);
-                return -1;
-            }
-            m1->async_parent_modules[m1->async_parent_modules_count++] = m;
-        }
-    }
-
-    if (m->pending_async_dependencies > 0) {
-        assert(!m->async_evaluation);
-        m->async_evaluation = TRUE;
-        m->async_evaluation_timestamp =
-            ctx->rt->module_async_evaluation_next_timestamp++;
-    } else if (m->has_tla) {
-        assert(!m->async_evaluation);
-        m->async_evaluation = TRUE;
-        m->async_evaluation_timestamp =
-            ctx->rt->module_async_evaluation_next_timestamp++;
-        js_execute_async_module(ctx, m);
-    } else {
-        if (js_execute_sync_module(ctx, m, pvalue) < 0)
-            return -1;
-    }
-
-    assert(m->dfs_ancestor_index <= m->dfs_index);
-    if (m->dfs_index == m->dfs_ancestor_index) {
-        for(;;) {
-            /* pop m1 from stack */
-            m1 = *pstack_top;
-            *pstack_top = m1->stack_prev;
-            if (!m1->async_evaluation) {
-                m1->status = JS_MODULE_STATUS_EVALUATED;
-            } else {
-                m1->status = JS_MODULE_STATUS_EVALUATING_ASYNC;
-            }
-            /* spec bug: cycle_root must be assigned before the test */
-            m1->cycle_root = m;
-            if (m1 == m)
-                break;
-        }
-    }
-    *pvalue = JS_UNDEFINED;
-    return index;
-}
-
-/* Run the <eval> function of the module and of all its requested
-   modules. Return a promise or an exception. */
-static JSValue js_evaluate_module(JSContext *ctx, JSModuleDef *m)
-{
-    JSModuleDef *m1, *stack_top;
-    JSValue ret_val, result;
-
-    assert(m->status == JS_MODULE_STATUS_LINKED ||
-           m->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
-           m->status == JS_MODULE_STATUS_EVALUATED);
-    if (m->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
-        m->status == JS_MODULE_STATUS_EVALUATED) {
-        m = m->cycle_root;
-    }
-    /* a promise may be created only on the cycle_root of a cycle */
-    if (!JS_IsUndefined(m->promise))
-        return JS_DupValue(ctx, m->promise);
-    m->promise = JS_NewPromiseCapability(ctx, m->resolving_funcs);
-    if (JS_IsException(m->promise))
-        return JS_EXCEPTION;
-
-    stack_top = NULL;
-    if (js_inner_module_evaluation(ctx, m, 0, &stack_top, &result) < 0) {
-        while (stack_top != NULL) {
-            m1 = stack_top;
-            assert(m1->status == JS_MODULE_STATUS_EVALUATING);
-            m1->status = JS_MODULE_STATUS_EVALUATED;
-            m1->eval_has_exception = TRUE;
-            m1->eval_exception = JS_DupValue(ctx, result);
-            m1->cycle_root = m; /* spec bug: should be present */
-            stack_top = m1->stack_prev;
-        }
-        JS_FreeValue(ctx, result);
-        assert(m->status == JS_MODULE_STATUS_EVALUATED);
-        assert(m->eval_has_exception);
-        ret_val = JS_Call(ctx, m->resolving_funcs[1], JS_UNDEFINED,
-                          1, (JSValueConst *)&m->eval_exception);
-        JS_FreeValue(ctx, ret_val);
+            JS_FreeValue(ctx, ret_val);
+        }
+    }
+
+    if (m->init_func) {
+        /* C module init */
+        if (m->init_func(ctx, m) < 0)
+            ret_val = JS_EXCEPTION;
+        else
+            ret_val = JS_UNDEFINED;
     } else {
-        assert(m->status == JS_MODULE_STATUS_EVALUATING_ASYNC ||
-               m->status == JS_MODULE_STATUS_EVALUATED);
-        assert(!m->eval_has_exception);
-        if (!m->async_evaluation) {
-            JSValue value;
-            assert(m->status == JS_MODULE_STATUS_EVALUATED);
-            value = JS_UNDEFINED;
-            ret_val = JS_Call(ctx, m->resolving_funcs[0], JS_UNDEFINED,
-                              1, (JSValueConst *)&value);
-            JS_FreeValue(ctx, ret_val);
-        }
-        assert(stack_top == NULL);
+        ret_val = JS_CallFree(ctx, m->func_obj, JS_UNDEFINED, 0, NULL);
+        m->func_obj = JS_UNDEFINED;
+    }
+    if (JS_IsException(ret_val)) {
+        /* save the thrown exception value */
+        m->eval_has_exception = TRUE;
+        m->eval_exception = JS_DupValue(ctx, ctx->rt->current_exception);
     }
-    return JS_DupValue(ctx, m->promise);
+    m->eval_mark = FALSE;
+    m->evaluated = TRUE;
+    return ret_val;
 }
 
 static __exception JSAtom js_parse_from_clause(JSParseState *s)
@@ -30403,7 +29410,6 @@
         case OP_scope_get_ref:
             dbuf_putc(bc, OP_undefined);
             /* fall thru */
-        case OP_scope_get_var_checkthis:
         case OP_scope_get_var_undef:
         case OP_scope_get_var:
         case OP_scope_put_var:
@@ -30429,12 +29435,7 @@
                     }
                 } else {
                     if (s->vars[var_idx].is_lexical) {
-                        if (op == OP_scope_get_var_checkthis) {
-                            /* only used for 'this' return in derived class constructors */
-                            dbuf_putc(bc, OP_get_loc_checkthis);
-                        } else {
-                            dbuf_putc(bc, OP_get_loc_check);
-                        }
+                        dbuf_putc(bc, OP_get_loc_check);
                     } else {
                         dbuf_putc(bc, OP_get_loc);
                     }
@@ -30891,16 +29892,11 @@
                 /* obj func value */
                 dbuf_putc(bc, OP_call_method);
                 dbuf_put_u16(bc, 1);
-                dbuf_putc(bc, OP_drop);
             }
             break;
         default:
             abort();
         }
-        break;
-    case OP_scope_in_private_field:
-        get_loc_or_ref(bc, is_ref, idx);
-        dbuf_putc(bc, OP_private_in);
         break;
     default:
         abort();
@@ -31020,13 +30016,12 @@
         is_arg_scope = (scope_idx == ARG_SCOPE_END);
         if (!is_arg_scope) {
             /* add unscoped variables */
-            /* XXX: propagate is_const and var_kind too ? */
             for(i = 0; i < fd->arg_count; i++) {
                 vd = &fd->args[i];
                 if (vd->var_name != JS_ATOM_NULL) {
                     get_closure_var(ctx, s, fd,
-                                    TRUE, i, vd->var_name, FALSE,
-                                    vd->is_lexical, JS_VAR_NORMAL);
+                                    TRUE, i, vd->var_name, FALSE, FALSE,
+                                    JS_VAR_NORMAL);
                 }
             }
             for(i = 0; i < fd->var_count; i++) {
@@ -31036,8 +30031,8 @@
                     vd->var_name != JS_ATOM__ret_ &&
                     vd->var_name != JS_ATOM_NULL) {
                     get_closure_var(ctx, s, fd,
-                                    FALSE, i, vd->var_name, FALSE,
-                                    vd->is_lexical, JS_VAR_NORMAL);
+                                    FALSE, i, vd->var_name, FALSE, FALSE,
+                                    JS_VAR_NORMAL);
                 }
             }
         } else {
@@ -31046,8 +30041,8 @@
                 /* do not close top level last result */
                 if (vd->scope_level == 0 && is_var_in_arg_scope(vd)) {
                     get_closure_var(ctx, s, fd,
-                                    FALSE, i, vd->var_name, FALSE,
-                                    vd->is_lexical, JS_VAR_NORMAL);
+                                    FALSE, i, vd->var_name, FALSE, FALSE,
+                                    JS_VAR_NORMAL);
                 }
             }
         }
@@ -31579,7 +30574,6 @@
             dbuf_putc(&bc_out, op);
             dbuf_put_u16(&bc_out, s->scopes[scope].first + 1);
             break;
-        case OP_scope_get_var_checkthis:
         case OP_scope_get_var_undef:
         case OP_scope_get_var:
         case OP_scope_put_var:
@@ -31609,7 +30603,6 @@
         case OP_scope_get_private_field:
         case OP_scope_get_private_field2:
         case OP_scope_put_private_field:
-        case OP_scope_in_private_field:
             {
                 int ret;
                 var_name = get_u32(bc_buf + pos + 1);
@@ -31821,17 +30814,6 @@
         case OP_set_class_name:
             /* only used during parsing */
             break;
-
-        case OP_get_field_opt_chain: /* equivalent to OP_get_field */
-            {
-                JSAtom name = get_u32(bc_buf + pos + 1);
-                dbuf_putc(&bc_out, OP_get_field);
-                dbuf_put_u32(&bc_out, name);
-            }
-            break;
-        case OP_get_array_el_opt_chain: /* equivalent to OP_get_array_el */
-            dbuf_putc(&bc_out, OP_get_array_el);
-            break;
 
         default:
         no_change:
@@ -32964,7 +31946,6 @@
     int bc_len;
     int stack_len_max;
     uint16_t *stack_level_tab;
-    int32_t *catch_pos_tab;
     int *pc_stack;
     int pc_stack_len;
     int pc_stack_size;
@@ -32972,7 +31953,7 @@
 
 /* 'op' is only used for error indication */
 static __exception int ss_check(JSContext *ctx, StackSizeState *s,
-                                int pos, int op, int stack_len, int catch_pos)
+                                int pos, int op, int stack_len)
 {
     if ((unsigned)pos >= s->bc_len) {
         JS_ThrowInternalError(ctx, "bytecode buffer overflow (op=%d, pc=%d)", op, pos);
@@ -32988,12 +31969,8 @@
     if (s->stack_level_tab[pos] != 0xffff) {
         /* already explored: check that the stack size is consistent */
         if (s->stack_level_tab[pos] != stack_len) {
-            JS_ThrowInternalError(ctx, "inconsistent stack size: %d %d (pc=%d)",
+            JS_ThrowInternalError(ctx, "unconsistent stack size: %d %d (pc=%d)",
                                   s->stack_level_tab[pos], stack_len, pos);
-            return -1;
-        } else if (s->catch_pos_tab[pos] != catch_pos) {
-            JS_ThrowInternalError(ctx, "inconsistent catch position: %d %d (pc=%d)",
-                                  s->catch_pos_tab[pos], catch_pos, pos);
             return -1;
         } else {
             return 0;
@@ -33002,7 +31979,6 @@
 
     /* mark as explored and store the stack size */
     s->stack_level_tab[pos] = stack_len;
-    s->catch_pos_tab[pos] = catch_pos;
 
     /* queue the new PC to explore */
     if (js_resize_array(ctx, (void **)&s->pc_stack, sizeof(s->pc_stack[0]),
@@ -33017,7 +31993,7 @@
                                           int *pstack_size)
 {
     StackSizeState s_s, *s = &s_s;
-    int i, diff, n_pop, pos_next, stack_len, pos, op, catch_pos, catch_level;
+    int i, diff, n_pop, pos_next, stack_len, pos, op;
     const JSOpCode *oi;
     const uint8_t *bc_buf;
 
@@ -33030,33 +32006,24 @@
         return -1;
     for(i = 0; i < s->bc_len; i++)
         s->stack_level_tab[i] = 0xffff;
-    s->pc_stack = NULL;
-    s->catch_pos_tab = js_malloc(ctx, sizeof(s->catch_pos_tab[0]) *
-                                   s->bc_len);
-    if (!s->catch_pos_tab)
-        goto fail;
-
     s->stack_len_max = 0;
+    s->pc_stack = NULL;
     s->pc_stack_len = 0;
     s->pc_stack_size = 0;
 
     /* breadth-first graph exploration */
-    if (ss_check(ctx, s, 0, OP_invalid, 0, -1))
+    if (ss_check(ctx, s, 0, OP_invalid, 0))
         goto fail;
 
     while (s->pc_stack_len > 0) {
         pos = s->pc_stack[--s->pc_stack_len];
         stack_len = s->stack_level_tab[pos];
-        catch_pos = s->catch_pos_tab[pos];
         op = bc_buf[pos];
         if (op == 0 || op >= OP_COUNT) {
             JS_ThrowInternalError(ctx, "invalid opcode (op=%d, pc=%d)", op, pos);
             goto fail;
         }
         oi = &short_opcode_info(op);
-#if defined(DUMP_BYTECODE) && (DUMP_BYTECODE & 64)
-        printf("%5d: %10s %5d %5d\n", pos, oi->name, stack_len, catch_pos);
-#endif
         pos_next = pos + oi->size;
         if (pos_next > s->bc_len) {
             JS_ThrowInternalError(ctx, "bytecode buffer overflow (op=%d, pc=%d)", op, pos);
@@ -33112,104 +32079,55 @@
         case OP_if_true8:
         case OP_if_false8:
             diff = (int8_t)bc_buf[pos + 1];
-            if (ss_check(ctx, s, pos + 1 + diff, op, stack_len, catch_pos))
+            if (ss_check(ctx, s, pos + 1 + diff, op, stack_len))
                 goto fail;
             break;
 #endif
         case OP_if_true:
         case OP_if_false:
+        case OP_catch:
             diff = get_u32(bc_buf + pos + 1);
-            if (ss_check(ctx, s, pos + 1 + diff, op, stack_len, catch_pos))
+            if (ss_check(ctx, s, pos + 1 + diff, op, stack_len))
                 goto fail;
             break;
         case OP_gosub:
             diff = get_u32(bc_buf + pos + 1);
-            if (ss_check(ctx, s, pos + 1 + diff, op, stack_len + 1, catch_pos))
+            if (ss_check(ctx, s, pos + 1 + diff, op, stack_len + 1))
                 goto fail;
             break;
         case OP_with_get_var:
         case OP_with_delete_var:
             diff = get_u32(bc_buf + pos + 5);
-            if (ss_check(ctx, s, pos + 5 + diff, op, stack_len + 1, catch_pos))
+            if (ss_check(ctx, s, pos + 5 + diff, op, stack_len + 1))
                 goto fail;
             break;
         case OP_with_make_ref:
         case OP_with_get_ref:
         case OP_with_get_ref_undef:
             diff = get_u32(bc_buf + pos + 5);
-            if (ss_check(ctx, s, pos + 5 + diff, op, stack_len + 2, catch_pos))
+            if (ss_check(ctx, s, pos + 5 + diff, op, stack_len + 2))
                 goto fail;
             break;
         case OP_with_put_var:
             diff = get_u32(bc_buf + pos + 5);
-            if (ss_check(ctx, s, pos + 5 + diff, op, stack_len - 1, catch_pos))
+            if (ss_check(ctx, s, pos + 5 + diff, op, stack_len - 1))
                 goto fail;
             break;
-        case OP_catch:
-            diff = get_u32(bc_buf + pos + 1);
-            if (ss_check(ctx, s, pos + 1 + diff, op, stack_len, catch_pos))
-                goto fail;
-            catch_pos = pos;
-            break;
-        case OP_for_of_start:
-        case OP_for_await_of_start:
-            catch_pos = pos;
-            break;
-            /* we assume the catch offset entry is only removed with
-               some op codes */
-        case OP_drop:
-            catch_level = stack_len;
-            goto check_catch;
-        case OP_nip:
-            catch_level = stack_len - 1;
-            goto check_catch;
-        case OP_nip1:
-            catch_level = stack_len - 1;
-            goto check_catch;
-        case OP_iterator_close:
-            catch_level = stack_len + 2;
-        check_catch:
-            /* Note: for for_of_start/for_await_of_start we consider
-               the catch offset is on the first stack entry instead of
-               the thirst */
-            if (catch_pos >= 0) {
-                int level;
-                level = s->stack_level_tab[catch_pos];
-                if (bc_buf[catch_pos] != OP_catch)
-                    level++; /* for_of_start, for_wait_of_start */
-                /* catch_level = stack_level before op_catch is executed ? */
-                if (catch_level == level) {
-                    catch_pos = s->catch_pos_tab[catch_pos];
-                }
-            }
-            break;
-        case OP_nip_catch:
-            if (catch_pos < 0) {
-                JS_ThrowInternalError(ctx, "nip_catch: no catch op (pc=%d)", pos);
-                goto fail;
-            }
-            stack_len = s->stack_level_tab[catch_pos];
-            if (bc_buf[catch_pos] != OP_catch)
-                stack_len++; /* for_of_start, for_wait_of_start */
-            stack_len++; /* no stack overflow is possible by construction */
-            catch_pos = s->catch_pos_tab[catch_pos];
-            break;
+
         default:
             break;
         }
-        if (ss_check(ctx, s, pos_next, op, stack_len, catch_pos))
+        if (ss_check(ctx, s, pos_next, op, stack_len))
             goto fail;
     done_insn: ;
     }
-    js_free(ctx, s->pc_stack);
-    js_free(ctx, s->catch_pos_tab);
     js_free(ctx, s->stack_level_tab);
+    js_free(ctx, s->pc_stack);
     *pstack_size = s->stack_len_max;
     return 0;
  fail:
-    js_free(ctx, s->pc_stack);
-    js_free(ctx, s->catch_pos_tab);
     js_free(ctx, s->stack_level_tab);
+    js_free(ctx, s->pc_stack);
     *pstack_size = 0;
     return -1;
 }
@@ -33391,8 +32309,8 @@
             }
         } else {
             b->vardefs = (void *)((uint8_t*)b + vardefs_offset);
-            memcpy_no_ub(b->vardefs, fd->args, fd->arg_count * sizeof(fd->args[0]));
-            memcpy_no_ub(b->vardefs + fd->arg_count, fd->vars, fd->var_count * sizeof(fd->vars[0]));
+            memcpy(b->vardefs, fd->args, fd->arg_count * sizeof(fd->args[0]));
+            memcpy(b->vardefs + fd->arg_count, fd->vars, fd->var_count * sizeof(fd->vars[0]));
         }
         b->var_count = fd->var_count;
         b->arg_count = fd->arg_count;
@@ -33454,8 +32372,6 @@
     b->super_allowed = fd->super_allowed;
     b->arguments_allowed = fd->arguments_allowed;
     b->backtrace_barrier = fd->backtrace_barrier;
-    b->is_direct_or_indirect_eval = (fd->eval_type == JS_EVAL_TYPE_DIRECT ||
-                                     fd->eval_type == JS_EVAL_TYPE_INDIRECT);
     b->realm = JS_DupContext(ctx);
 
     add_gc_object(ctx->rt, &b->header, JS_GC_OBJ_TYPE_FUNCTION_BYTECODE);
@@ -33738,9 +32654,8 @@
                  func_type == JS_PARSE_FUNC_EXPR &&
                  (func_kind & JS_FUNC_GENERATOR)) ||
                 (s->token.u.ident.atom == JS_ATOM_await &&
-                 ((func_type == JS_PARSE_FUNC_EXPR &&
-                   (func_kind & JS_FUNC_ASYNC)) ||
-                  func_type == JS_PARSE_FUNC_CLASS_STATIC_INIT))) {
+                 func_type == JS_PARSE_FUNC_EXPR &&
+                 (func_kind & JS_FUNC_ASYNC))) {
                 return js_parse_error_reserved_identifier(s);
             }
         }
@@ -33834,8 +32749,7 @@
                            func_type == JS_PARSE_FUNC_SETTER ||
                            func_type == JS_PARSE_FUNC_CLASS_CONSTRUCTOR ||
                            func_type == JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR);
-    fd->has_arguments_binding = (func_type != JS_PARSE_FUNC_ARROW &&
-                                 func_type != JS_PARSE_FUNC_CLASS_STATIC_INIT);
+    fd->has_arguments_binding = (func_type != JS_PARSE_FUNC_ARROW);
     fd->has_this_binding = fd->has_arguments_binding;
     fd->is_derived_class_constructor = (func_type == JS_PARSE_FUNC_DERIVED_CLASS_CONSTRUCTOR);
     if (func_type == JS_PARSE_FUNC_ARROW) {
@@ -33843,11 +32757,6 @@
         fd->super_call_allowed = fd->parent->super_call_allowed;
         fd->super_allowed = fd->parent->super_allowed;
         fd->arguments_allowed = fd->parent->arguments_allowed;
-    } else if (func_type == JS_PARSE_FUNC_CLASS_STATIC_INIT) {
-        fd->new_target_allowed = TRUE; // although new.target === undefined
-        fd->super_call_allowed = FALSE;
-        fd->super_allowed = TRUE;
-        fd->arguments_allowed = FALSE;
     } else {
         fd->new_target_allowed = TRUE;
         fd->super_call_allowed = fd->is_derived_class_constructor;
@@ -33885,7 +32794,7 @@
         if (add_arg(ctx, fd, name) < 0)
             goto fail;
         fd->defined_arg_count = 1;
-    } else if (func_type != JS_PARSE_FUNC_CLASS_STATIC_INIT) {
+    } else {
         if (s->token.val == '(') {
             int skip_bits;
             /* if there is an '=' inside the parameter list, we
@@ -33946,8 +32855,6 @@
                     goto fail;
                 }
                 if (fd->has_parameter_expressions) {
-                    if (js_parse_check_duplicate_parameter(s, name))
-                        goto fail;
                     if (define_var(s, fd, name, JS_VAR_DEF_LET) < 0)
                         goto fail;
                 }
@@ -34108,10 +33015,8 @@
         }
     }
 
-    if (func_type != JS_PARSE_FUNC_CLASS_STATIC_INIT) {
-        if (js_parse_expect(s, '{'))
-            goto fail;
-    }
+    if (js_parse_expect(s, '{'))
+        goto fail;
 
     if (js_parse_directives(s))
         goto fail;
@@ -34141,15 +33046,9 @@
     if (js_is_live_code(s)) {
         emit_return(s, FALSE);
     }
- done:
+done:
     s->cur_func = fd->parent;
 
-    /* Reparse identifiers after the function is terminated so that
-       the token is parsed in the englobing function. It could be done
-       by just using next_token() here for normal functions, but it is
-       necessary for arrow functions with an expression body. */
-    reparse_ident_token(s);
-
     /* create the function object */
     {
         int idx;
@@ -34301,24 +33200,12 @@
 
     if (!s->is_module) {
         /* return the value of the hidden variable eval_ret_idx  */
-        if (fd->func_kind == JS_FUNC_ASYNC) {
-            /* wrap the return value in an object so that promises can
-               be safely returned */
-            emit_op(s, OP_object);
-            emit_op(s, OP_dup);
-
-            emit_op(s, OP_get_loc);
-            emit_u16(s, fd->eval_ret_idx);
+        emit_op(s, OP_get_loc);
+        emit_u16(s, fd->eval_ret_idx);
 
-            emit_op(s, OP_put_field);
-            emit_atom(s, JS_ATOM_value);
-        } else {
-            emit_op(s, OP_get_loc);
-            emit_u16(s, fd->eval_ret_idx);
-        }
-        emit_return(s, TRUE);
+        emit_op(s, OP_return);
     } else {
-        emit_return(s, FALSE);
+        emit_op(s, OP_return_undef);
     }
 
     return 0;
@@ -34361,6 +33248,7 @@
         ret_val = js_evaluate_module(ctx, m);
         if (JS_IsException(ret_val)) {
         fail:
+            js_free_modules(ctx, JS_FREE_MODULE_NOT_EVALUATED);
             return JS_EXCEPTION;
         }
     } else {
@@ -34375,6 +33263,31 @@
     return JS_EvalFunctionInternal(ctx, fun_obj, ctx->global_obj, NULL, NULL);
 }
 
+static void skip_shebang(JSParseState *s)
+{
+    const uint8_t *p = s->buf_ptr;
+    int c;
+
+    if (p[0] == '#' && p[1] == '!') {
+        p += 2;
+        while (p < s->buf_end) {
+            if (*p == '\n' || *p == '\r') {
+                break;
+            } else if (*p >= 0x80) {
+                c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
+                if (c == CP_LS || c == CP_PS) {
+                    break;
+                } else if (c == -1) {
+                    p++; /* skip invalid UTF-8 */
+                }
+            } else {
+                p++;
+            }
+        }
+        s->buf_ptr = p;
+    }
+}
+
 /* 'input' must be zero terminated i.e. input[input_len] = '\0'. */
 static JSValue __JS_EvalInternal(JSContext *ctx, JSValueConst this_obj,
                                  const char *input, size_t input_len,
@@ -34390,7 +33303,7 @@
     JSModuleDef *m;
 
     js_parse_init(ctx, s, input, input_len, filename);
-    skip_shebang(&s->buf_ptr, s->buf_end);
+    skip_shebang(s);
 
     eval_type = flags & JS_EVAL_TYPE_MASK;
     m = NULL;
@@ -34448,10 +33361,6 @@
             goto fail;
     }
     fd->module = m;
-    if (m != NULL || (flags & JS_EVAL_FLAG_ASYNC)) {
-        fd->in_function_body = TRUE;
-        fd->func_kind = JS_FUNC_ASYNC;
-    }
     s->is_module = (m != NULL);
     s->allow_html_comments = !s->is_module;
 
@@ -34466,9 +33375,6 @@
         goto fail1;
     }
 
-    if (m != NULL)
-        m->has_tla = fd->has_await;
-
     /* create the function object and all the enclosed functions */
     fun_obj = js_create_function(ctx, fd);
     if (JS_IsException(fun_obj))
@@ -34478,7 +33384,7 @@
         m->func_obj = fun_obj;
         if (js_resolve_module(ctx, m) < 0)
             goto fail1;
-        fun_obj = JS_NewModuleValue(ctx, m);
+        fun_obj = JS_DupValue(ctx, JS_MKPTR(JS_TAG_MODULE, m));
     }
     if (flags & JS_EVAL_FLAG_COMPILE_ONLY) {
         ret_val = fun_obj;
@@ -34674,6 +33580,8 @@
     BC_TAG_OBJECT,
     BC_TAG_ARRAY,
     BC_TAG_BIG_INT,
+    BC_TAG_BIG_FLOAT,
+    BC_TAG_BIG_DECIMAL,
     BC_TAG_TEMPLATE_OBJECT,
     BC_TAG_FUNCTION_BYTECODE,
     BC_TAG_MODULE,
@@ -34683,21 +33591,24 @@
     BC_TAG_DATE,
     BC_TAG_OBJECT_VALUE,
     BC_TAG_OBJECT_REFERENCE,
-#ifdef CONFIG_BIGNUM
-    BC_TAG_BIG_FLOAT,
-    BC_TAG_BIG_DECIMAL,
-#endif
 } BCTagEnum;
 
 #ifdef CONFIG_BIGNUM
-#define BC_VERSION 0x43
+#define BC_BASE_VERSION 2
+#else
+#define BC_BASE_VERSION 1
+#endif
+#define BC_BE_VERSION 0x40
+#ifdef WORDS_BIGENDIAN
+#define BC_VERSION (BC_BASE_VERSION | BC_BE_VERSION)
 #else
-#define BC_VERSION 3
+#define BC_VERSION BC_BASE_VERSION
 #endif
 
 typedef struct BCWriterState {
     JSContext *ctx;
     DynBuf dbuf;
+    BOOL byte_swap : 8;
     BOOL allow_bytecode : 8;
     BOOL allow_sab : 8;
     BOOL allow_reference : 8;
@@ -34727,6 +33638,8 @@
     "object",
     "array",
     "bigint",
+    "bigfloat",
+    "bigdecimal",
     "template",
     "function",
     "module",
@@ -34736,22 +33649,9 @@
     "Date",
     "ObjectValue",
     "ObjectReference",
-#ifdef CONFIG_BIGNUM
-    "bigfloat",
-    "bigdecimal",
-#endif
 };
 #endif
 
-static inline BOOL is_be(void)
-{
-    union {
-        uint16_t a;
-        uint8_t  b;
-    } u = {0x100};
-    return u.b;
-}
-
 static void bc_put_u8(BCWriterState *s, uint8_t v)
 {
     dbuf_putc(&s->dbuf, v);
@@ -34759,21 +33659,21 @@
 
 static void bc_put_u16(BCWriterState *s, uint16_t v)
 {
-    if (is_be())
+    if (s->byte_swap)
         v = bswap16(v);
     dbuf_put_u16(&s->dbuf, v);
 }
 
 static __maybe_unused void bc_put_u32(BCWriterState *s, uint32_t v)
 {
-    if (is_be())
+    if (s->byte_swap)
         v = bswap32(v);
     dbuf_put_u32(&s->dbuf, v);
 }
 
 static void bc_put_u64(BCWriterState *s, uint64_t v)
 {
-    if (is_be())
+    if (s->byte_swap)
         v = bswap64(v);
     dbuf_put(&s->dbuf, (uint8_t *)&v, sizeof(v));
 }
@@ -34943,7 +33843,7 @@
         pos += len;
     }
 
-    if (is_be())
+    if (s->byte_swap)
         bc_byte_swap(bc_buf, bc_len);
 
     dbuf_put(&s->dbuf, bc_buf, bc_len);
@@ -35005,7 +33905,7 @@
         e = a->expn + 3;
     else
         e = a->expn;
-    e = (e * 2) | a->sign;
+    e = (e << 1) | a->sign;
     if (e < INT32_MIN || e > INT32_MAX) {
         JS_ThrowInternalError(s->ctx, "bignum exponent is too large");
         return -1;
@@ -35034,14 +33934,20 @@
             bc_put_leb128(s, len);
             /* always saved in byte based little endian representation */
             for(j = 0; j < n1; j++) {
-                bc_put_u8(s, v >> (j * 8));
+                dbuf_putc(&s->dbuf, v >> (j * 8));
             }
             for(; i < a->len; i++) {
                 limb_t v = a->tab[i];
 #if LIMB_BITS == 32
-                bc_put_u32(s, v);
+#ifdef WORDS_BIGENDIAN
+                v = bswap32(v);
+#endif
+                dbuf_put_u32(&s->dbuf, v);
 #else
-                bc_put_u64(s, v);
+#ifdef WORDS_BIGENDIAN
+                v = bswap64(v);
+#endif
+                dbuf_put_u64(&s->dbuf, v);
 #endif
             }
         } else {
@@ -35084,14 +33990,14 @@
                         v8 = d;
                         bpos = 1;
                     } else {
-                        bc_put_u8(s, v8 | (d << 4));
+                        dbuf_putc(&s->dbuf, v8 | (d << 4));
                         bpos = 0;
                     }
                 }
             }
             /* flush the last digit */
             if (bpos) {
-                bc_put_u8(s, v8);
+                dbuf_putc(&s->dbuf, v8);
             }
         }
     }
@@ -35119,7 +34025,6 @@
     bc_set_flags(&flags, &idx, b->arguments_allowed, 1);
     bc_set_flags(&flags, &idx, b->has_debug, 1);
     bc_set_flags(&flags, &idx, b->backtrace_barrier, 1);
-    bc_set_flags(&flags, &idx, b->is_direct_or_indirect_eval, 1);
     assert(idx <= 16);
     bc_put_u16(s, flags);
     bc_put_u8(s, b->js_mode);
@@ -35226,8 +34131,6 @@
         bc_put_leb128(s, mi->req_module_idx);
     }
 
-    bc_put_u8(s, m->has_tla);
-
     if (JS_WriteObjectRec(s, m->func_obj))
         goto fail;
     return 0;
@@ -35504,10 +34407,15 @@
     JSRuntime *rt = s->ctx->rt;
     DynBuf dbuf1;
     int i, atoms_size;
+    uint8_t version;
 
     dbuf1 = s->dbuf;
     js_dbuf_init(s->ctx, &s->dbuf);
-    bc_put_u8(s, BC_VERSION);
+
+    version = BC_VERSION;
+    if (s->byte_swap)
+        version ^= BC_BE_VERSION;
+    bc_put_u8(s, version);
 
     bc_put_leb128(s, s->idx_to_atom_count);
     for(i = 0; i < s->idx_to_atom_count; i++) {
@@ -35540,6 +34448,8 @@
 
     memset(s, 0, sizeof(*s));
     s->ctx = ctx;
+    /* XXX: byte swapped output is untested */
+    s->byte_swap = ((flags & JS_WRITE_OBJ_BSWAP) != 0);
     s->allow_bytecode = ((flags & JS_WRITE_OBJ_BYTECODE) != 0);
     s->allow_sab = ((flags & JS_WRITE_OBJ_SAB) != 0);
     s->allow_reference = ((flags & JS_WRITE_OBJ_REFERENCE) != 0);
@@ -35606,7 +34516,7 @@
 } BCReaderState;
 
 #ifdef DUMP_READ_OBJECT
-static void __attribute__((format(printf, 2, 3))) bc_read_trace(BCReaderState *s, const char *fmt, ...) {
+static void PLATFORM_PRINTF_LIKE(2, 3) bc_read_trace(BCReaderState *s, const char *fmt, ...) {
     va_list ap;
     int i, n, n0;
 
@@ -35660,45 +34570,33 @@
 
 static int bc_get_u16(BCReaderState *s, uint16_t *pval)
 {
-    uint16_t v;
     if (unlikely(s->buf_end - s->ptr < 2)) {
         *pval = 0; /* avoid warning */
         return bc_read_error_end(s);
     }
-    v = get_u16(s->ptr);
-    if (is_be())
-        v = bswap16(v);
-    *pval = v;
+    *pval = get_u16(s->ptr);
     s->ptr += 2;
     return 0;
 }
 
 static __maybe_unused int bc_get_u32(BCReaderState *s, uint32_t *pval)
 {
-    uint32_t v;
     if (unlikely(s->buf_end - s->ptr < 4)) {
         *pval = 0; /* avoid warning */
         return bc_read_error_end(s);
     }
-    v = get_u32(s->ptr);
-    if (is_be())
-        v = bswap32(v);
-    *pval = v;
+    *pval = get_u32(s->ptr);
     s->ptr += 4;
     return 0;
 }
 
 static int bc_get_u64(BCReaderState *s, uint64_t *pval)
 {
-    uint64_t v;
     if (unlikely(s->buf_end - s->ptr < 8)) {
         *pval = 0; /* avoid warning */
         return bc_read_error_end(s);
     }
-    v = get_u64(s->ptr);
-    if (is_be())
-        v = bswap64(v);
-    *pval = v;
+    *pval = get_u64(s->ptr);
     s->ptr += 8;
     return 0;
 }
@@ -35810,13 +34708,7 @@
     }
     memcpy(p->u.str8, s->ptr, size);
     s->ptr += size;
-    if (is_wide_char) {
-        if (is_be()) {
-            uint32_t i;
-            for (i = 0; i < len; i++)
-                p->u.str16[i] = bswap16(p->u.str16[i]);
-        }
-    } else {
+    if (!is_wide_char) {
         p->u.str8[size] = '\0'; /* add the trailing zero for 8 bit strings */
     }
 #ifdef DUMP_READ_OBJECT
@@ -35855,9 +34747,6 @@
     }
     b->byte_code_buf = bc_buf;
 
-    if (is_be())
-        bc_byte_swap(bc_buf, bc_len);
-
     pos = 0;
     while (pos < bc_len) {
         op = bc_buf[pos];
@@ -35898,10 +34787,11 @@
     uint8_t v8;
     int32_t e;
     uint32_t len;
-    limb_t l, i, n;
+    limb_t l, i, n, j;
     JSBigFloat *p;
     limb_t v;
     bf_t *a;
+    int bpos, d;
 
     p = js_new_bf(s->ctx);
     if (!p)
@@ -35951,23 +34841,45 @@
             JS_ThrowInternalError(s->ctx, "invalid bignum length");
             goto fail;
         }
-#ifdef CONFIG_BIGNUM
-        if (tag == BC_TAG_BIG_DECIMAL) {
-            l = (len + LIMB_DIGITS - 1) / LIMB_DIGITS;
-        } else
-#endif
-        {
+        if (tag != BC_TAG_BIG_DECIMAL)
             l = (len + sizeof(limb_t) - 1) / sizeof(limb_t);
-        }
+        else
+            l = (len + LIMB_DIGITS - 1) / LIMB_DIGITS;
         if (bf_resize(a, l)) {
             JS_ThrowOutOfMemory(s->ctx);
             goto fail;
         }
-#ifdef CONFIG_BIGNUM
-        if (tag == BC_TAG_BIG_DECIMAL) {
-            limb_t j;
-            int bpos, d;
-
+        if (tag != BC_TAG_BIG_DECIMAL) {
+            n = len & (sizeof(limb_t) - 1);
+            if (n != 0) {
+                v = 0;
+                for(i = 0; i < n; i++) {
+                    if (bc_get_u8(s, &v8))
+                        goto fail;
+                    v |= (limb_t)v8 << ((sizeof(limb_t) - n + i) * 8);
+                }
+                a->tab[0] = v;
+                i = 1;
+            } else {
+                i = 0;
+            }
+            for(; i < l; i++) {
+#if LIMB_BITS == 32
+                if (bc_get_u32(s, &v))
+                    goto fail;
+#ifdef WORDS_BIGENDIAN
+                v = bswap32(v);
+#endif
+#else
+                if (bc_get_u64(s, &v))
+                    goto fail;
+#ifdef WORDS_BIGENDIAN
+                v = bswap64(v);
+#endif
+#endif
+                a->tab[i] = v;
+            }
+        } else {
             bpos = 0;
             for(i = 0; i < l; i++) {
                 if (i == 0 && (n = len % LIMB_DIGITS) != 0) {
@@ -35994,32 +34906,6 @@
                 }
                 a->tab[i] = v;
             }
-        } else
-#endif  /* CONFIG_BIGNUM */
-        {
-            n = len & (sizeof(limb_t) - 1);
-            if (n != 0) {
-                v = 0;
-                for(i = 0; i < n; i++) {
-                    if (bc_get_u8(s, &v8))
-                        goto fail;
-                    v |= (limb_t)v8 << ((sizeof(limb_t) - n + i) * 8);
-                }
-                a->tab[0] = v;
-                i = 1;
-            } else {
-                i = 0;
-            }
-            for(; i < l; i++) {
-#if LIMB_BITS == 32
-                if (bc_get_u32(s, &v))
-                    goto fail;
-#else
-                if (bc_get_u64(s, &v))
-                    goto fail;
-#endif
-                a->tab[i] = v;
-            }
         }
     }
     bc_read_trace(s, "}\n");
@@ -36077,7 +34963,6 @@
     bc.arguments_allowed = bc_get_flags(v16, &idx, 1);
     bc.has_debug = bc_get_flags(v16, &idx, 1);
     bc.backtrace_barrier = bc_get_flags(v16, &idx, 1);
-    bc.is_direct_or_indirect_eval = bc_get_flags(v16, &idx, 1);
     bc.read_only_bytecode = s->is_rom_data;
     if (bc_get_u8(s, &v8))
         goto fail;
@@ -36256,7 +35141,7 @@
     m = js_new_module_def(ctx, module_name);
     if (!m)
         goto fail;
-    obj = JS_NewModuleValue(ctx, m);
+    obj = JS_DupValue(ctx, JS_MKPTR(JS_TAG_MODULE, m));
     if (bc_get_leb128_int(s, &m->req_module_entries_count))
         goto fail;
     if (m->req_module_entries_count != 0) {
@@ -36329,10 +35214,6 @@
         }
     }
 
-    if (bc_get_u8(s, &v8))
-        goto fail;
-    m->has_tla = (v8 != 0);
-
     m->func_obj = JS_ReadObjectRec(s);
     if (JS_IsException(m->func_obj))
         goto fail;
@@ -36697,6 +35578,7 @@
 
     if (bc_get_u8(s, &v8))
         return -1;
+    /* XXX: could support byte swapped input */
     if (v8 != BC_VERSION) {
         JS_ThrowSyntaxError(s->ctx, "invalid version (%d expected=%d)",
                             v8, BC_VERSION);
@@ -37071,10 +35953,12 @@
 static JSValue js_global_isFinite(JSContext *ctx, JSValueConst this_val,
                                   int argc, JSValueConst *argv)
 {
+    BOOL res;
     double d;
     if (unlikely(JS_ToFloat64(ctx, &d, argv[0])))
         return JS_EXCEPTION;
-    return JS_NewBool(ctx, isfinite(d));
+    res = isfinite(d);
+    return JS_NewBool(ctx, res);
 }
 
 /* Object class */
@@ -37468,13 +36352,13 @@
             } else {
                 if (JS_DefinePropertyValue(ctx, ret, JS_ATOM_value, JS_DupValue(ctx, desc.value), flags) < 0
                 ||  JS_DefinePropertyValue(ctx, ret, JS_ATOM_writable,
-                                           JS_NewBool(ctx, desc.flags & JS_PROP_WRITABLE), flags) < 0)
+                                           JS_NewBool(ctx, (desc.flags & JS_PROP_WRITABLE) != 0), flags) < 0)
                     goto exception1;
             }
             if (JS_DefinePropertyValue(ctx, ret, JS_ATOM_enumerable,
-                                       JS_NewBool(ctx, desc.flags & JS_PROP_ENUMERABLE), flags) < 0
+                                       JS_NewBool(ctx, (desc.flags & JS_PROP_ENUMERABLE) != 0), flags) < 0
             ||  JS_DefinePropertyValue(ctx, ret, JS_ATOM_configurable,
-                                       JS_NewBool(ctx, desc.flags & JS_PROP_CONFIGURABLE), flags) < 0)
+                                       JS_NewBool(ctx, (desc.flags & JS_PROP_CONFIGURABLE) != 0), flags) < 0)
                 goto exception1;
             js_free_desc(ctx, &desc);
         }
@@ -38222,7 +37106,7 @@
     if (has_prop < 0)
         goto exception;
     if (has_prop) {
-        res = JS_NewBool(ctx, desc.flags & JS_PROP_ENUMERABLE);
+        res = JS_NewBool(ctx, (desc.flags & JS_PROP_ENUMERABLE) != 0);
         js_free_desc(ctx, &desc);
     } else {
         res = JS_FALSE;
@@ -38287,7 +37171,6 @@
     JS_CFUNC_DEF("defineProperties", 2, js_object_defineProperties ),
     JS_CFUNC_DEF("getOwnPropertyNames", 1, js_object_getOwnPropertyNames ),
     JS_CFUNC_DEF("getOwnPropertySymbols", 1, js_object_getOwnPropertySymbols ),
-    JS_CFUNC_MAGIC_DEF("groupBy", 2, js_object_groupBy, 0 ),
     JS_CFUNC_MAGIC_DEF("keys", 1, js_object_keys, JS_ITERATOR_KIND_KEY ),
     JS_CFUNC_MAGIC_DEF("values", 1, js_object_keys, JS_ITERATOR_KIND_VALUE ),
     JS_CFUNC_MAGIC_DEF("entries", 1, js_object_keys, JS_ITERATOR_KIND_KEY_AND_VALUE ),
@@ -38457,9 +37340,7 @@
     if (js_get_length32(ctx, &len, array_arg))
         return NULL;
     if (len > JS_MAX_LOCAL_VARS) {
-        // XXX: check for stack overflow?
-        JS_ThrowRangeError(ctx, "too many arguments in function call (only %d allowed)",
-                           JS_MAX_LOCAL_VARS);
+        JS_ThrowInternalError(ctx, "too many arguments");
         return NULL;
     }
     /* avoid allocating 0 bytes */
@@ -38720,8 +37601,7 @@
                                     int argc, JSValueConst *argv, int magic)
 {
     JSValue obj, msg, proto;
-    JSValueConst message, options;
-    int arg_index;
+    JSValueConst message;
 
     if (JS_IsUndefined(new_target))
         new_target = JS_GetActiveFunction(ctx);
@@ -38747,9 +37627,12 @@
     JS_FreeValue(ctx, proto);
     if (JS_IsException(obj))
         return obj;
-    arg_index = (magic == JS_AGGREGATE_ERROR);
+    if (magic == JS_AGGREGATE_ERROR) {
+        message = argv[1];
+    } else {
+        message = argv[0];
+    }
 
-    message = argv[arg_index++];
     if (!JS_IsUndefined(message)) {
         msg = JS_ToString(ctx, message);
         if (unlikely(JS_IsException(msg)))
@@ -38758,22 +37641,6 @@
                                JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
     }
 
-    if (arg_index < argc) {
-        options = argv[arg_index];
-        if (JS_IsObject(options)) {
-            int present = JS_HasProperty(ctx, options, JS_ATOM_cause);
-            if (present < 0)
-                goto exception;
-            if (present) {
-                JSValue cause = JS_GetProperty(ctx, options, JS_ATOM_cause);
-                if (JS_IsException(cause))
-                    goto exception;
-                JS_DefinePropertyValue(ctx, obj, JS_ATOM_cause, cause,
-                                       JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE);
-            }
-        }
-    }
-
     if (magic == JS_AGGREGATE_ERROR) {
         JSValue error_list = iterator_to_array(ctx, argv[0]);
         if (JS_IsException(error_list))
@@ -39202,71 +38069,6 @@
     return JS_EXCEPTION;
 }
 
-static JSValue js_array_with(JSContext *ctx, JSValueConst this_val,
-                             int argc, JSValueConst *argv)
-{
-    JSValue arr, obj, ret, *arrp, *pval;
-    JSObject *p;
-    int64_t i, len, idx;
-    uint32_t count32;
-
-    ret = JS_EXCEPTION;
-    arr = JS_UNDEFINED;
-    obj = JS_ToObject(ctx, this_val);
-    if (js_get_length64(ctx, &len, obj))
-        goto exception;
-
-    if (JS_ToInt64Sat(ctx, &idx, argv[0]))
-        goto exception;
-
-    if (idx < 0)
-        idx = len + idx;
-
-    if (idx < 0 || idx >= len) {
-        JS_ThrowRangeError(ctx, "invalid array index: %" PRId64, idx);
-        goto exception;
-    }
-
-    arr = js_allocate_fast_array(ctx, len);
-    if (JS_IsException(arr))
-        goto exception;
-
-    p = JS_VALUE_GET_OBJ(arr);
-    i = 0;
-    pval = p->u.array.u.values;
-    if (js_get_fast_array(ctx, obj, &arrp, &count32) && count32 == len) {
-        for (; i < idx; i++, pval++)
-            *pval = JS_DupValue(ctx, arrp[i]);
-        *pval = JS_DupValue(ctx, argv[1]);
-        for (i++, pval++; i < len; i++, pval++)
-            *pval = JS_DupValue(ctx, arrp[i]);
-    } else {
-        for (; i < idx; i++, pval++)
-            if (-1 == JS_TryGetPropertyInt64(ctx, obj, i, pval))
-                goto fill_and_fail;
-        *pval = JS_DupValue(ctx, argv[1]);
-        for (i++, pval++; i < len; i++, pval++) {
-            if (-1 == JS_TryGetPropertyInt64(ctx, obj, i, pval)) {
-            fill_and_fail:
-                for (; i < len; i++, pval++)
-                    *pval = JS_UNDEFINED;
-                goto exception;
-            }
-        }
-    }
-
-    if (JS_SetProperty(ctx, arr, JS_ATOM_length, JS_NewInt64(ctx, len)) < 0)
-        goto exception;
-
-    ret = arr;
-    arr = JS_UNDEFINED;
-
-exception:
-    JS_FreeValue(ctx, arr);
-    JS_FreeValue(ctx, obj);
-    return ret;
-}
-
 static JSValue js_array_concat(JSContext *ctx, JSValueConst this_val,
                                int argc, JSValueConst *argv)
 {
@@ -39632,10 +38434,9 @@
                                  int argc, JSValueConst *argv)
 {
     JSValue obj, val;
-    int64_t len, n;
+    int64_t len, n, res;
     JSValue *arrp;
     uint32_t count;
-    int res;
 
     obj = JS_ToObject(ctx, this_val);
     if (js_get_length64(ctx, &len, obj))
@@ -39766,21 +38567,13 @@
     return JS_EXCEPTION;
 }
 
-enum {
-    ArrayFind,
-    ArrayFindIndex,
-    ArrayFindLast,
-    ArrayFindLastIndex,
-};
-
 static JSValue js_array_find(JSContext *ctx, JSValueConst this_val,
-                             int argc, JSValueConst *argv, int mode)
+                             int argc, JSValueConst *argv, int findIndex)
 {
     JSValueConst func, this_arg;
     JSValueConst args[3];
     JSValue obj, val, index_val, res;
-    int64_t len, k, end;
-    int dir;
+    int64_t len, k;
 
     index_val = JS_UNDEFINED;
     val = JS_UNDEFINED;
@@ -39796,17 +38589,7 @@
     if (argc > 1)
         this_arg = argv[1];
 
-    k = 0;
-    dir = 1;
-    end = len;
-    if (mode == ArrayFindLast || mode == ArrayFindLastIndex) {
-        k = len - 1;
-        dir = -1;
-        end = -1;
-    }
-
-    // TODO(bnoordhuis) add fast path for fast arrays
-    for(; k != end; k += dir) {
+    for(k = 0; k < len; k++) {
         index_val = JS_NewInt64(ctx, k);
         if (JS_IsException(index_val))
             goto exception;
@@ -39820,7 +38603,7 @@
         if (JS_IsException(res))
             goto exception;
         if (JS_ToBoolFree(ctx, res)) {
-            if (mode == ArrayFindIndex || mode == ArrayFindLastIndex) {
+            if (findIndex) {
                 JS_FreeValue(ctx, val);
                 JS_FreeValue(ctx, obj);
                 return index_val;
@@ -39834,7 +38617,7 @@
         JS_FreeValue(ctx, index_val);
     }
     JS_FreeValue(ctx, obj);
-    if (mode == ArrayFindIndex || mode == ArrayFindLastIndex)
+    if (findIndex)
         return JS_NewInt32(ctx, -1);
     else
         return JS_UNDEFINED;
@@ -40085,61 +38868,6 @@
     return JS_EXCEPTION;
 }
 
-// Note: a.toReversed() is a.slice().reverse() with the twist that a.slice()
-// leaves holes in sparse arrays intact whereas a.toReversed() replaces them
-// with undefined, thus in effect creating a dense array.
-// Does not use Array[@@species], always returns a base Array.
-static JSValue js_array_toReversed(JSContext *ctx, JSValueConst this_val,
-                                   int argc, JSValueConst *argv)
-{
-    JSValue arr, obj, ret, *arrp, *pval;
-    JSObject *p;
-    int64_t i, len;
-    uint32_t count32;
-
-    ret = JS_EXCEPTION;
-    arr = JS_UNDEFINED;
-    obj = JS_ToObject(ctx, this_val);
-    if (js_get_length64(ctx, &len, obj))
-        goto exception;
-
-    arr = js_allocate_fast_array(ctx, len);
-    if (JS_IsException(arr))
-        goto exception;
-
-    if (len > 0) {
-        p = JS_VALUE_GET_OBJ(arr);
-
-        i = len - 1;
-        pval = p->u.array.u.values;
-        if (js_get_fast_array(ctx, obj, &arrp, &count32) && count32 == len) {
-            for (; i >= 0; i--, pval++)
-                *pval = JS_DupValue(ctx, arrp[i]);
-        } else {
-            // Query order is observable; test262 expects descending order.
-            for (; i >= 0; i--, pval++) {
-                if (-1 == JS_TryGetPropertyInt64(ctx, obj, i, pval)) {
-                    // Exception; initialize remaining elements.
-                    for (; i >= 0; i--, pval++)
-                        *pval = JS_UNDEFINED;
-                    goto exception;
-                }
-            }
-        }
-
-        if (JS_SetProperty(ctx, arr, JS_ATOM_length, JS_NewInt64(ctx, len)) < 0)
-            goto exception;
-    }
-
-    ret = arr;
-    arr = JS_UNDEFINED;
-
-exception:
-    JS_FreeValue(ctx, arr);
-    JS_FreeValue(ctx, obj);
-    return ret;
-}
-
 static JSValue js_array_slice(JSContext *ctx, JSValueConst this_val,
                               int argc, JSValueConst *argv, int splice)
 {
@@ -40247,92 +38975,6 @@
     return JS_EXCEPTION;
 }
 
-static JSValue js_array_toSpliced(JSContext *ctx, JSValueConst this_val,
-                                  int argc, JSValueConst *argv)
-{
-    JSValue arr, obj, ret, *arrp, *pval, *last;
-    JSObject *p;
-    int64_t i, j, len, newlen, start, add, del;
-    uint32_t count32;
-
-    pval = NULL;
-    last = NULL;
-    ret = JS_EXCEPTION;
-    arr = JS_UNDEFINED;
-
-    obj = JS_ToObject(ctx, this_val);
-    if (js_get_length64(ctx, &len, obj))
-        goto exception;
-
-    start = 0;
-    if (argc > 0)
-        if (JS_ToInt64Clamp(ctx, &start, argv[0], 0, len, len))
-            goto exception;
-
-    del = 0;
-    if (argc > 0)
-        del = len - start;
-    if (argc > 1)
-        if (JS_ToInt64Clamp(ctx, &del, argv[1], 0, del, 0))
-            goto exception;
-
-    add = 0;
-    if (argc > 2)
-        add = argc - 2;
-
-    newlen = len + add - del;
-    if (newlen > MAX_SAFE_INTEGER) {
-        JS_ThrowTypeError(ctx, "invalid array length");
-        goto exception;
-    }
-
-    arr = js_allocate_fast_array(ctx, newlen);
-    if (JS_IsException(arr))
-        goto exception;
-
-    if (newlen <= 0)
-        goto done;
-
-    p = JS_VALUE_GET_OBJ(arr);
-    pval = &p->u.array.u.values[0];
-    last = &p->u.array.u.values[newlen];
-
-    if (js_get_fast_array(ctx, obj, &arrp, &count32) && count32 == len) {
-        for (i = 0; i < start; i++, pval++)
-            *pval = JS_DupValue(ctx, arrp[i]);
-        for (j = 0; j < add; j++, pval++)
-            *pval = JS_DupValue(ctx, argv[2 + j]);
-        for (i += del; i < len; i++, pval++)
-            *pval = JS_DupValue(ctx, arrp[i]);
-    } else {
-        for (i = 0; i < start; i++, pval++)
-            if (-1 == JS_TryGetPropertyInt64(ctx, obj, i, pval))
-                goto exception;
-        for (j = 0; j < add; j++, pval++)
-            *pval = JS_DupValue(ctx, argv[2 + j]);
-        for (i += del; i < len; i++, pval++)
-            if (-1 == JS_TryGetPropertyInt64(ctx, obj, i, pval))
-                goto exception;
-    }
-
-    assert(pval == last);
-
-    if (JS_SetProperty(ctx, arr, JS_ATOM_length, JS_NewInt64(ctx, newlen)) < 0)
-        goto exception;
-
-done:
-    ret = arr;
-    arr = JS_UNDEFINED;
-
-exception:
-    while (pval != last)
-        *pval++ = JS_UNDEFINED;
-
-    JS_FreeValue(ctx, arr);
-    JS_FreeValue(ctx, obj);
-    return ret;
-}
-
 static JSValue js_array_copyWithin(JSContext *ctx, JSValueConst this_val,
                                    int argc, JSValueConst *argv)
 {
@@ -40392,8 +39034,8 @@
         if (!JS_IsUndefined(mapperFunction)) {
             JSValueConst args[3] = { element, JS_NewInt64(ctx, sourceIndex), source };
             element = JS_Call(ctx, mapperFunction, thisArg, 3, args);
-            JS_FreeValue(ctx, (JSValue)args[0]);
-            JS_FreeValue(ctx, (JSValue)args[1]);
+            JS_FreeValue(ctx, args[0]);
+            JS_FreeValue(ctx, args[1]);
             if (JS_IsException(element))
                 return -1;
         }
@@ -40636,68 +39278,6 @@
     return JS_EXCEPTION;
 }
 
-// Note: a.toSorted() is a.slice().sort() with the twist that a.slice()
-// leaves holes in sparse arrays intact whereas a.toSorted() replaces them
-// with undefined, thus in effect creating a dense array.
-// Does not use Array[@@species], always returns a base Array.
-static JSValue js_array_toSorted(JSContext *ctx, JSValueConst this_val,
-                                 int argc, JSValueConst *argv)
-{
-    JSValue arr, obj, ret, *arrp, *pval;
-    JSObject *p;
-    int64_t i, len;
-    uint32_t count32;
-    int ok;
-
-    ok = JS_IsUndefined(argv[0]) || JS_IsFunction(ctx, argv[0]);
-    if (!ok)
-        return JS_ThrowTypeError(ctx, "not a function");
-
-    ret = JS_EXCEPTION;
-    arr = JS_UNDEFINED;
-    obj = JS_ToObject(ctx, this_val);
-    if (js_get_length64(ctx, &len, obj))
-        goto exception;
-
-    arr = js_allocate_fast_array(ctx, len);
-    if (JS_IsException(arr))
-        goto exception;
-
-    if (len > 0) {
-        p = JS_VALUE_GET_OBJ(arr);
-        i = 0;
-        pval = p->u.array.u.values;
-        if (js_get_fast_array(ctx, obj, &arrp, &count32) && count32 == len) {
-            for (; i < len; i++, pval++)
-                *pval = JS_DupValue(ctx, arrp[i]);
-        } else {
-            for (; i < len; i++, pval++) {
-                if (-1 == JS_TryGetPropertyInt64(ctx, obj, i, pval)) {
-                    for (; i < len; i++, pval++)
-                        *pval = JS_UNDEFINED;
-                    goto exception;
-                }
-            }
-        }
-
-        if (JS_SetProperty(ctx, arr, JS_ATOM_length, JS_NewInt64(ctx, len)) < 0)
-            goto exception;
-    }
-
-    ret = js_array_sort(ctx, arr, argc, argv);
-    if (JS_IsException(ret))
-        goto exception;
-    JS_FreeValue(ctx, ret);
-
-    ret = arr;
-    arr = JS_UNDEFINED;
-
-exception:
-    JS_FreeValue(ctx, arr);
-    JS_FreeValue(ctx, obj);
-    return ret;
-}
-
 typedef struct JSArrayIteratorData {
     JSValue obj;
     JSIteratorKindEnum kind;
@@ -40851,7 +39431,6 @@
 
 static const JSCFunctionListEntry js_array_proto_funcs[] = {
     JS_CFUNC_DEF("at", 1, js_array_at ),
-    JS_CFUNC_DEF("with", 2, js_array_with ),
     JS_CFUNC_DEF("concat", 1, js_array_concat ),
     JS_CFUNC_MAGIC_DEF("every", 1, js_array_every, special_every ),
     JS_CFUNC_MAGIC_DEF("some", 1, js_array_every, special_some ),
@@ -40861,10 +39440,8 @@
     JS_CFUNC_MAGIC_DEF("reduce", 1, js_array_reduce, special_reduce ),
     JS_CFUNC_MAGIC_DEF("reduceRight", 1, js_array_reduce, special_reduceRight ),
     JS_CFUNC_DEF("fill", 1, js_array_fill ),
-    JS_CFUNC_MAGIC_DEF("find", 1, js_array_find, ArrayFind ),
-    JS_CFUNC_MAGIC_DEF("findIndex", 1, js_array_find, ArrayFindIndex ),
-    JS_CFUNC_MAGIC_DEF("findLast", 1, js_array_find, ArrayFindLast ),
-    JS_CFUNC_MAGIC_DEF("findLastIndex", 1, js_array_find, ArrayFindLastIndex ),
+    JS_CFUNC_MAGIC_DEF("find", 1, js_array_find, 0 ),
+    JS_CFUNC_MAGIC_DEF("findIndex", 1, js_array_find, 1 ),
     JS_CFUNC_DEF("indexOf", 1, js_array_indexOf ),
     JS_CFUNC_DEF("lastIndexOf", 1, js_array_lastIndexOf ),
     JS_CFUNC_DEF("includes", 1, js_array_includes ),
@@ -40876,12 +39453,9 @@
     JS_CFUNC_MAGIC_DEF("shift", 0, js_array_pop, 1 ),
     JS_CFUNC_MAGIC_DEF("unshift", 1, js_array_push, 1 ),
     JS_CFUNC_DEF("reverse", 0, js_array_reverse ),
-    JS_CFUNC_DEF("toReversed", 0, js_array_toReversed ),
     JS_CFUNC_DEF("sort", 1, js_array_sort ),
-    JS_CFUNC_DEF("toSorted", 1, js_array_toSorted ),
     JS_CFUNC_MAGIC_DEF("slice", 2, js_array_slice, 0 ),
     JS_CFUNC_MAGIC_DEF("splice", 2, js_array_slice, 1 ),
-    JS_CFUNC_DEF("toSpliced", 2, js_array_toSpliced ),
     JS_CFUNC_DEF("copyWithin", 2, js_array_copyWithin ),
     JS_CFUNC_MAGIC_DEF("flatMap", 1, js_array_flatten, 1 ),
     JS_CFUNC_MAGIC_DEF("flat", 0, js_array_flatten, 0 ),
@@ -41070,16 +39644,8 @@
         if (base < 0)
             goto fail;
     }
-    if (JS_VALUE_GET_TAG(val) == JS_TAG_INT) {
-        char buf1[70], *ptr;
-        ptr = i64toa(buf1 + sizeof(buf1), JS_VALUE_GET_INT(val), base);
-        return JS_NewString(ctx, ptr);
-    }
     if (JS_ToFloat64Free(ctx, &d, val))
         return JS_EXCEPTION;
-    if (base != 10 && isfinite(d)) {
-        return js_dtoa_radix(ctx, d, base);
-    }
     return js_dtoa(ctx, d, base, 0, JS_DTOA_VAR_FORMAT);
  fail:
     JS_FreeValue(ctx, val);
@@ -41284,7 +39850,10 @@
             idx = __JS_AtomToUInt32(prop);
             if (idx < p1->len) {
                 if (desc) {
-                    ch = string_get(p1, idx);
+                    if (p1->is_wide_char)
+                        ch = p1->u.str16[idx];
+                    else
+                        ch = p1->u.str8[idx];
                     desc->flags = JS_PROP_ENUMERABLE;
                     desc->value = js_new_string_char(ctx, ch);
                     desc->getter = JS_UNDEFINED;
@@ -41439,7 +40008,7 @@
         } else {
             if (JS_ToFloat64(ctx, &d, argv[i]))
                 goto fail;
-            if (isnan(d) || d < 0 || d > 0x10ffff || (c = (int)d) != d)
+            if (d < 0 || d > 0x10ffff || (c = (int)d) != d)
                 goto range_error;
         }
         if (string_buffer_putc(b, c))
@@ -41550,7 +40119,10 @@
     if (idx < 0 || idx >= p->len) {
         ret = JS_NAN;
     } else {
-        c = string_get(p, idx);
+        if (p->is_wide_char)
+            c = p->u.str16[idx];
+        else
+            c = p->u.str8[idx];
         ret = JS_NewInt32(ctx, c);
     }
     JS_FreeValue(ctx, val);
@@ -41578,9 +40150,12 @@
         if (is_at)
             ret = JS_UNDEFINED;
         else
-            ret = js_new_string8(ctx, NULL, 0);
+        ret = js_new_string8(ctx, NULL, 0);
     } else {
-        c = string_get(p, idx);
+        if (p->is_wide_char)
+            c = p->u.str16[idx];
+        else
+            c = p->u.str8[idx];
         ret = js_new_string_char(ctx, c);
     }
     JS_FreeValue(ctx, val);
@@ -41688,80 +40263,6 @@
     return index;
 }
 
-/* return the position of the first invalid character in the string or
-   -1 if none */
-static int js_string_find_invalid_codepoint(JSString *p)
-{
-    int i;
-    if (!p->is_wide_char)
-        return -1;
-    for(i = 0; i < p->len; i++) {
-        uint32_t c = p->u.str16[i];
-        if (is_surrogate(c)) {
-            if (is_hi_surrogate(c) && (i + 1) < p->len
-            &&  is_lo_surrogate(p->u.str16[i + 1])) {
-                i++;
-            } else {
-                return i;
-            }
-        }
-    }
-    return -1;
-}
-
-static JSValue js_string_isWellFormed(JSContext *ctx, JSValueConst this_val,
-                                      int argc, JSValueConst *argv)
-{
-    JSValue str;
-    JSString *p;
-    BOOL ret;
-
-    str = JS_ToStringCheckObject(ctx, this_val);
-    if (JS_IsException(str))
-        return JS_EXCEPTION;
-    p = JS_VALUE_GET_STRING(str);
-    ret = (js_string_find_invalid_codepoint(p) < 0);
-    JS_FreeValue(ctx, str);
-    return JS_NewBool(ctx, ret);
-}
-
-static JSValue js_string_toWellFormed(JSContext *ctx, JSValueConst this_val,
-                                      int argc, JSValueConst *argv)
-{
-    JSValue str, ret;
-    JSString *p;
-    int i;
-
-    str = JS_ToStringCheckObject(ctx, this_val);
-    if (JS_IsException(str))
-        return JS_EXCEPTION;
-
-    p = JS_VALUE_GET_STRING(str);
-    /* avoid reallocating the string if it is well-formed */
-    i = js_string_find_invalid_codepoint(p);
-    if (i < 0)
-        return str;
-
-    ret = js_new_string16(ctx, p->u.str16, p->len);
-    JS_FreeValue(ctx, str);
-    if (JS_IsException(ret))
-        return JS_EXCEPTION;
-
-    p = JS_VALUE_GET_STRING(ret);
-    for (; i < p->len; i++) {
-        uint32_t c = p->u.str16[i];
-        if (is_surrogate(c)) {
-            if (is_hi_surrogate(c) && (i + 1) < p->len
-            &&  is_lo_surrogate(p->u.str16[i + 1])) {
-                i++;
-            } else {
-                p->u.str16[i] = 0xFFFD;
-            }
-        }
-    }
-    return ret;
-}
-
 static JSValue js_string_indexOf(JSContext *ctx, JSValueConst this_val,
                                  int argc, JSValueConst *argv, int lastIndexOf)
 {
@@ -41844,7 +40345,7 @@
     ret = js_is_regexp(ctx, argv[0]);
     if (ret) {
         if (ret > 0)
-            JS_ThrowTypeError(ctx, "regexp not supported");
+            JS_ThrowTypeError(ctx, "regex not supported");
         goto fail;
     }
     v = JS_ToString(ctx, argv[0]);
@@ -41959,7 +40460,7 @@
         str = JS_NewString(ctx, "g");
         if (JS_IsException(str))
             goto fail;
-        args[args_len++] = (JSValueConst)str;
+        args[args_len++] = str;
     }
     rx = JS_CallConstructor(ctx, ctx->regexp_ctor, args_len, args);
     JS_FreeValue(ctx, str);
@@ -42406,7 +40907,7 @@
         }
     }
     if (n > JS_STRING_LEN_MAX) {
-        JS_ThrowRangeError(ctx, "invalid string length");
+        JS_ThrowInternalError(ctx, "string too long");
         goto fail2;
     }
     if (string_buffer_init(ctx, b, n))
@@ -42468,9 +40969,8 @@
     len = p->len;
     if (len == 0 || n == 1)
         return str;
-    // XXX: potential arithmetic overflow
     if (val * len > JS_STRING_LEN_MAX) {
-        JS_ThrowRangeError(ctx, "invalid string length");
+        JS_ThrowInternalError(ctx, "string too long");
         goto fail;
     }
     if (string_buffer_init2(ctx, b, n * len, p->is_wide_char))
@@ -42533,10 +41033,10 @@
     idx--;
     if (p->is_wide_char) {
         c = p->u.str16[idx];
-        if (is_lo_surrogate(c) && idx > 0) {
+        if (c >= 0xdc00 && c < 0xe000 && idx > 0) {
             c1 = p->u.str16[idx - 1];
-            if (is_hi_surrogate(c1)) {
-                c = from_surrogate(c1, c);
+            if (c1 >= 0xd800 && c1 <= 0xdc00) {
+                c = (((c1 & 0x3ff) << 10) | (c & 0x3ff)) + 0x10000;
                 idx--;
             }
         }
@@ -42575,6 +41075,26 @@
     return !lre_is_cased(c1);
 }
 
+static JSValue js_string_localeCompare(JSContext *ctx, JSValueConst this_val,
+                                       int argc, JSValueConst *argv)
+{
+    JSValue a, b;
+    int cmp;
+
+    a = JS_ToStringCheckObject(ctx, this_val);
+    if (JS_IsException(a))
+        return JS_EXCEPTION;
+    b = JS_ToString(ctx, argv[0]);
+    if (JS_IsException(b)) {
+        JS_FreeValue(ctx, a);
+        return JS_EXCEPTION;
+    }
+    cmp = js_string_compare(ctx, JS_VALUE_GET_STRING(a), JS_VALUE_GET_STRING(b));
+    JS_FreeValue(ctx, a);
+    JS_FreeValue(ctx, b);
+    return JS_NewInt32(ctx, cmp);
+}
+
 static JSValue js_string_toLowerCase(JSContext *ctx, JSValueConst this_val,
                                      int argc, JSValueConst *argv, int to_lower)
 {
@@ -42660,38 +41180,23 @@
     return JS_EXCEPTION;
 }
 
-static int js_string_normalize1(JSContext *ctx, uint32_t **pout_buf,
-                                JSValueConst val,
-                                UnicodeNormalizationEnum n_type)
-{
-    int buf_len, out_len;
-    uint32_t *buf, *out_buf;
-
-    buf_len = JS_ToUTF32String(ctx, &buf, val);
-    if (buf_len < 0)
-        return -1;
-    out_len = unicode_normalize(&out_buf, buf, buf_len, n_type,
-                                ctx->rt, (DynBufReallocFunc *)js_realloc_rt);
-    js_free(ctx, buf);
-    if (out_len < 0)
-        return -1;
-    *pout_buf = out_buf;
-    return out_len;
-}
-
 static JSValue js_string_normalize(JSContext *ctx, JSValueConst this_val,
                                    int argc, JSValueConst *argv)
 {
     const char *form, *p;
     size_t form_len;
-    int is_compat, out_len;
+    int is_compat, buf_len, out_len;
     UnicodeNormalizationEnum n_type;
     JSValue val;
-    uint32_t *out_buf;
+    uint32_t *buf, *out_buf;
 
     val = JS_ToStringCheckObject(ctx, this_val);
     if (JS_IsException(val))
         return val;
+    buf_len = JS_ToUTF32String(ctx, &buf, val);
+    JS_FreeValue(ctx, val);
+    if (buf_len < 0)
+        return JS_EXCEPTION;
 
     if (argc == 0 || JS_IsUndefined(argv[0])) {
         n_type = UNICODE_NFC;
@@ -42717,96 +41222,22 @@
             JS_FreeCString(ctx, form);
             JS_ThrowRangeError(ctx, "bad normalization form");
         fail1:
-            JS_FreeValue(ctx, val);
+            js_free(ctx, buf);
             return JS_EXCEPTION;
         }
         JS_FreeCString(ctx, form);
     }
 
-    out_len = js_string_normalize1(ctx, &out_buf, val, n_type);
-    JS_FreeValue(ctx, val);
+    out_len = unicode_normalize(&out_buf, buf, buf_len, n_type,
+                                ctx->rt, (DynBufReallocFunc *)js_realloc_rt);
+    js_free(ctx, buf);
     if (out_len < 0)
         return JS_EXCEPTION;
     val = JS_NewUTF32String(ctx, out_buf, out_len);
     js_free(ctx, out_buf);
     return val;
 }
-
-/* return < 0, 0 or > 0 */
-static int js_UTF32_compare(const uint32_t *buf1, int buf1_len,
-                            const uint32_t *buf2, int buf2_len)
-{
-    int i, len, c, res;
-    len = min_int(buf1_len, buf2_len);
-    for(i = 0; i < len; i++) {
-        /* Note: range is limited so a subtraction is valid */
-        c = buf1[i] - buf2[i];
-        if (c != 0)
-            return c;
-    }
-    if (buf1_len == buf2_len)
-        res = 0;
-    else if (buf1_len < buf2_len)
-        res = -1;
-    else
-        res = 1;
-    return res;
-}
-
-static JSValue js_string_localeCompare(JSContext *ctx, JSValueConst this_val,
-                                       int argc, JSValueConst *argv)
-{
-    JSValue a, b;
-    int cmp, a_len, b_len;
-    uint32_t *a_buf, *b_buf;
-
-    a = JS_ToStringCheckObject(ctx, this_val);
-    if (JS_IsException(a))
-        return JS_EXCEPTION;
-    b = JS_ToString(ctx, argv[0]);
-    if (JS_IsException(b)) {
-        JS_FreeValue(ctx, a);
-        return JS_EXCEPTION;
-    }
-    a_len = js_string_normalize1(ctx, &a_buf, a, UNICODE_NFC);
-    JS_FreeValue(ctx, a);
-    if (a_len < 0) {
-        JS_FreeValue(ctx, b);
-        return JS_EXCEPTION;
-    }
-
-    b_len = js_string_normalize1(ctx, &b_buf, b, UNICODE_NFC);
-    JS_FreeValue(ctx, b);
-    if (b_len < 0) {
-        js_free(ctx, a_buf);
-        return JS_EXCEPTION;
-    }
-    cmp = js_UTF32_compare(a_buf, a_len, b_buf, b_len);
-    js_free(ctx, a_buf);
-    js_free(ctx, b_buf);
-    return JS_NewInt32(ctx, cmp);
-}
-#else /* CONFIG_ALL_UNICODE */
-static JSValue js_string_localeCompare(JSContext *ctx, JSValueConst this_val,
-                                       int argc, JSValueConst *argv)
-{
-    JSValue a, b;
-    int cmp;
-
-    a = JS_ToStringCheckObject(ctx, this_val);
-    if (JS_IsException(a))
-        return JS_EXCEPTION;
-    b = JS_ToString(ctx, argv[0]);
-    if (JS_IsException(b)) {
-        JS_FreeValue(ctx, a);
-        return JS_EXCEPTION;
-    }
-    cmp = js_string_compare(ctx, JS_VALUE_GET_STRING(a), JS_VALUE_GET_STRING(b));
-    JS_FreeValue(ctx, a);
-    JS_FreeValue(ctx, b);
-    return JS_NewInt32(ctx, cmp);
-}
-#endif /* !CONFIG_ALL_UNICODE */
+#endif /* CONFIG_ALL_UNICODE */
 
 /* also used for String.prototype.valueOf */
 static JSValue js_string_toString(JSContext *ctx, JSValueConst this_val,
@@ -42983,8 +41414,6 @@
     JS_CFUNC_MAGIC_DEF("charAt", 1, js_string_charAt, 0 ),
     JS_CFUNC_DEF("concat", 1, js_string_concat ),
     JS_CFUNC_DEF("codePointAt", 1, js_string_codePointAt ),
-    JS_CFUNC_DEF("isWellFormed", 0, js_string_isWellFormed ),
-    JS_CFUNC_DEF("toWellFormed", 0, js_string_toWellFormed ),
     JS_CFUNC_MAGIC_DEF("indexOf", 1, js_string_indexOf, 0 ),
     JS_CFUNC_MAGIC_DEF("lastIndexOf", 1, js_string_indexOf, 1 ),
     JS_CFUNC_MAGIC_DEF("includes", 1, js_string_includes, 0 ),
@@ -43090,7 +41519,7 @@
     uint32_t tag;
 
     if (unlikely(argc == 0)) {
-        return __JS_NewFloat64(ctx, is_max ? -1.0 / 0.0 : 1.0 / 0.0);
+        return __JS_NewFloat64(ctx, is_max ? -INFINITY : INFINITY);
     }
 
     tag = JS_VALUE_GET_TAG(argv[0]);
@@ -43204,16 +41633,14 @@
 static JSValue js_math_imul(JSContext *ctx, JSValueConst this_val,
                             int argc, JSValueConst *argv)
 {
-    uint32_t a, b, c;
-    int32_t d;
+    int a, b;
 
-    if (JS_ToUint32(ctx, &a, argv[0]))
+    if (JS_ToInt32(ctx, &a, argv[0]))
         return JS_EXCEPTION;
-    if (JS_ToUint32(ctx, &b, argv[1]))
+    if (JS_ToInt32(ctx, &b, argv[1]))
         return JS_EXCEPTION;
-    c = a * b;
-    memcpy(&d, &c, sizeof(d));
-    return JS_NewInt32(ctx, d);
+    /* purposely ignoring overflow */
+    return JS_NewInt32(ctx, a * b);
 }
 
 static JSValue js_math_clz32(JSContext *ctx, JSValueConst this_val,
@@ -43242,6 +41669,28 @@
     return x * 0x2545F4914F6CDD1D;
 }
 
+#if defined(PLATFORM_IS_WINDOWS)
+// From: https://stackoverflow.com/a/26085827
+int gettimeofday(struct timeval *tp, void *tzp)
+{
+    static const uint64_t EPOCH = ((uint64_t)116444736000000000ULL);
+
+    SYSTEMTIME system_time;
+    FILETIME file_time;
+    uint64_t time;
+
+    GetSystemTime(&system_time);
+    SystemTimeToFileTime(&system_time, &file_time);
+    time = ((uint64_t)file_time.dwLowDateTime);
+    time += ((uint64_t)file_time.dwHighDateTime) << 32;
+
+    tp->tv_sec = (long)((time - EPOCH) / 10000000L);
+    tp->tv_usec = (long)(system_time.wMilliseconds * 1000);
+
+    return 0;
+}
+#endif
+
 static void js_random_init(JSContext *ctx)
 {
     struct timeval tv;
@@ -43263,13 +41712,16 @@
     u.u64 = ((uint64_t)0x3ff << 52) | (v >> 12);
     return __JS_NewFloat64(ctx, u.d - 1.0);
 }
+static double js_math_floor(double value) { return floor(value); }
+static double js_math_ceil(double value) { return ceil(value); }
+static double js_math_log2(double value) { return log2(value); }
 
 static const JSCFunctionListEntry js_math_funcs[] = {
     JS_CFUNC_MAGIC_DEF("min", 2, js_math_min_max, 0 ),
     JS_CFUNC_MAGIC_DEF("max", 2, js_math_min_max, 1 ),
     JS_CFUNC_SPECIAL_DEF("abs", 1, f_f, fabs ),
-    JS_CFUNC_SPECIAL_DEF("floor", 1, f_f, floor ),
-    JS_CFUNC_SPECIAL_DEF("ceil", 1, f_f, ceil ),
+    JS_CFUNC_SPECIAL_DEF("floor", 1, f_f, js_math_floor ),
+    JS_CFUNC_SPECIAL_DEF("ceil", 1, f_f, js_math_ceil ),
     JS_CFUNC_SPECIAL_DEF("round", 1, f_f, js_math_round ),
     JS_CFUNC_SPECIAL_DEF("sqrt", 1, f_f, sqrt ),
 
@@ -43294,7 +41746,7 @@
     JS_CFUNC_SPECIAL_DEF("atanh", 1, f_f, atanh ),
     JS_CFUNC_SPECIAL_DEF("expm1", 1, f_f, expm1 ),
     JS_CFUNC_SPECIAL_DEF("log1p", 1, f_f, log1p ),
-    JS_CFUNC_SPECIAL_DEF("log2", 1, f_f, log2 ),
+    JS_CFUNC_SPECIAL_DEF("log2", 1, f_f, js_math_log2 ),
     JS_CFUNC_SPECIAL_DEF("log10", 1, f_f, log10 ),
     JS_CFUNC_SPECIAL_DEF("cbrt", 1, f_f, cbrt ),
     JS_CFUNC_DEF("hypot", 2, js_math_hypot ),
@@ -43319,12 +41771,41 @@
 
 /* Date */
 
+#if 0
+/* OS dependent: return the UTC time in ms since 1970. */
+static JSValue js___date_now(JSContext *ctx, JSValueConst this_val,
+                             int argc, JSValueConst *argv)
+{
+    int64_t d;
+    struct timeval tv;
+    gettimeofday(&tv, NULL);
+    d = (int64_t)tv.tv_sec * 1000 + (tv.tv_usec / 1000);
+    return JS_NewInt64(ctx, d);
+}
+#endif
+
+/* OS dependent: return the UTC time in microseconds since 1970. */
+static JSValue js___date_clock(JSContext *ctx, JSValueConst this_val,
+                               int argc, JSValueConst *argv)
+{
+    int64_t d;
+    struct timeval tv;
+    gettimeofday(&tv, NULL);
+    d = (int64_t)tv.tv_sec * 1000000 + tv.tv_usec;
+    return JS_NewInt64(ctx, d);
+}
+
 /* OS dependent. d = argv[0] is in ms from 1970. Return the difference
    between UTC time and local time 'd' in minutes */
-static int getTimezoneOffset(int64_t time)
-{
+static int getTimezoneOffset(int64_t time) {
+#if defined(_WIN32)
+    TIME_ZONE_INFORMATION tzi;
+    if (!GetTimeZoneInformation(&tzi))
+        return tzi.Bias;
+    return 0;
+#else
     time_t ti;
-    int res;
+    struct tm tm;
 
     time /= 1000; /* convert to seconds */
     if (sizeof(time_t) == 4) {
@@ -43348,27 +41829,9 @@
         }
     }
     ti = time;
-#if defined(_WIN32)
-    {
-        struct tm *tm;
-        time_t gm_ti, loc_ti;
-
-        tm = gmtime(&ti);
-        gm_ti = mktime(tm);
-
-        tm = localtime(&ti);
-        loc_ti = mktime(tm);
-
-        res = (gm_ti - loc_ti) / 60;
-    }
-#else
-    {
-        struct tm tm;
-        localtime_r(&ti, &tm);
-        res = -tm.tm_gmtoff / 60;
-    }
+    localtime_r(&ti, &tm);
+    return -tm.tm_gmtoff / 60;
 #endif
-    return res;
 }
 
 #if 0
@@ -43445,9 +41908,6 @@
         /* XXX: re_flags = LRE_FLAG_OCTAL unless strict mode? */
         for (i = 0; i < len; i++) {
             switch(str[i]) {
-            case 'd':
-                mask = LRE_FLAG_INDICES;
-                break;
             case 'g':
                 mask = LRE_FLAG_GLOBAL;
                 break;
@@ -43461,7 +41921,7 @@
                 mask = LRE_FLAG_DOTALL;
                 break;
             case 'u':
-                mask = LRE_FLAG_UNICODE;
+                mask = LRE_FLAG_UTF16;
                 break;
             case 'y':
                 mask = LRE_FLAG_STICKY;
@@ -43479,7 +41939,7 @@
         JS_FreeCString(ctx, str);
     }
 
-    str = JS_ToCStringLen2(ctx, &len, pattern, !(re_flags & LRE_FLAG_UNICODE));
+    str = JS_ToCStringLen2(ctx, &len, pattern, !(re_flags & LRE_FLAG_UTF16));
     if (!str)
         return JS_EXCEPTION;
     re_bytecode_buf = lre_compile(&re_bytecode_len, error_msg,
@@ -43780,7 +42240,7 @@
     }
 
     flags = lre_get_flags(re->bytecode->u.str8);
-    return JS_NewBool(ctx, flags & mask);
+    return JS_NewBool(ctx, (flags & mask) != 0);
 }
 
 static JSValue js_regexp_get_flags(JSContext *ctx, JSValueConst this_val)
@@ -43791,11 +42251,6 @@
     if (JS_VALUE_GET_TAG(this_val) != JS_TAG_OBJECT)
         return JS_ThrowTypeErrorNotAnObject(ctx);
 
-    res = JS_ToBoolFree(ctx, JS_GetPropertyStr(ctx, this_val, "hasIndices"));
-    if (res < 0)
-        goto exception;
-    if (res)
-        *p++ = 'd';
     res = JS_ToBoolFree(ctx, JS_GetProperty(ctx, this_val, JS_ATOM_global));
     if (res < 0)
         goto exception;
@@ -43875,32 +42330,25 @@
 {
     JSRegExp *re = js_get_regexp(ctx, this_val, TRUE);
     JSString *str;
-    JSValue t, ret, str_val, obj, val, groups;
-    JSValue indices, indices_groups;
+    JSValue str_val, obj, val, groups = JS_UNDEFINED;
     uint8_t *re_bytecode;
+    int ret;
     uint8_t **capture, *str_buf;
-    int rc, capture_count, shift, i, re_flags;
+    int capture_count, shift, i, re_flags;
     int64_t last_index;
     const char *group_name_ptr;
 
     if (!re)
         return JS_EXCEPTION;
-
     str_val = JS_ToString(ctx, argv[0]);
     if (JS_IsException(str_val))
+        return str_val;
+    val = JS_GetProperty(ctx, this_val, JS_ATOM_lastIndex);
+    if (JS_IsException(val) ||
+        JS_ToLengthFree(ctx, &last_index, val)) {
+        JS_FreeValue(ctx, str_val);
         return JS_EXCEPTION;
-
-    ret = JS_EXCEPTION;
-    obj = JS_NULL;
-    groups = JS_UNDEFINED;
-    indices = JS_UNDEFINED;
-    indices_groups = JS_UNDEFINED;
-    capture = NULL;
-
-    val = JS_GetProperty(ctx, this_val, JS_ATOM_lastIndex);
-    if (JS_IsException(val) || JS_ToLengthFree(ctx, &last_index, val))
-        goto fail;
-
+    }
     re_bytecode = re->bytecode->u.str8;
     re_flags = lre_get_flags(re_bytecode);
     if ((re_flags & (LRE_FLAG_GLOBAL | LRE_FLAG_STICKY)) == 0) {
@@ -43908,23 +42356,27 @@
     }
     str = JS_VALUE_GET_STRING(str_val);
     capture_count = lre_get_capture_count(re_bytecode);
+    capture = NULL;
     if (capture_count > 0) {
         capture = js_malloc(ctx, sizeof(capture[0]) * capture_count * 2);
-        if (!capture)
-            goto fail;
+        if (!capture) {
+            JS_FreeValue(ctx, str_val);
+            return JS_EXCEPTION;
+        }
     }
     shift = str->is_wide_char;
     str_buf = str->u.str8;
     if (last_index > str->len) {
-        rc = 2;
+        ret = 2;
     } else {
-        rc = lre_exec(capture, re_bytecode,
-                      str_buf, last_index, str->len,
-                      shift, ctx);
+        ret = lre_exec(capture, re_bytecode,
+                       str_buf, last_index, str->len,
+                       shift, ctx);
     }
-    if (rc != 1) {
-        if (rc >= 0) {
-            if (rc == 2 || (re_flags & (LRE_FLAG_GLOBAL | LRE_FLAG_STICKY))) {
+    obj = JS_NULL;
+    if (ret != 1) {
+        if (ret >= 0) {
+            if (ret == 2 || (re_flags & (LRE_FLAG_GLOBAL | LRE_FLAG_STICKY))) {
                 if (JS_SetProperty(ctx, this_val, JS_ATOM_lastIndex,
                                    JS_NewInt32(ctx, 0)) < 0)
                     goto fail;
@@ -43933,6 +42385,7 @@
             JS_ThrowInternalError(ctx, "out of memory in regexp execution");
             goto fail;
         }
+        JS_FreeValue(ctx, str_val);
     } else {
         int prop_flags;
         if (re_flags & (LRE_FLAG_GLOBAL | LRE_FLAG_STICKY)) {
@@ -43950,124 +42403,52 @@
             if (JS_IsException(groups))
                 goto fail;
         }
-        if (re_flags & LRE_FLAG_INDICES) {
-            indices = JS_NewArray(ctx);
-            if (JS_IsException(indices))
-                goto fail;
-            if (group_name_ptr) {
-                indices_groups = JS_NewObjectProto(ctx, JS_NULL);
-                if (JS_IsException(indices_groups))
-                    goto fail;
-            }
-        }
 
         for(i = 0; i < capture_count; i++) {
-            const char *name = NULL;
-            uint8_t **match = &capture[2 * i];
-            int start = -1;
-            int end = -1;
+            int start, end;
             JSValue val;
-
-            if (group_name_ptr && i > 0) {
-                if (*group_name_ptr) name = group_name_ptr;
-                group_name_ptr += strlen(group_name_ptr) + 1;
-            }
-
-            if (match[0] && match[1]) {
-                start = (match[0] - str_buf) >> shift;
-                end = (match[1] - str_buf) >> shift;
-            }
-
-            if (!JS_IsUndefined(indices)) {
+            if (capture[2 * i] == NULL ||
+                capture[2 * i + 1] == NULL) {
                 val = JS_UNDEFINED;
-                if (start != -1) {
-                    val = JS_NewArray(ctx);
-                    if (JS_IsException(val))
-                        goto fail;
-                    if (JS_DefinePropertyValueUint32(ctx, val, 0,
-                                                     JS_NewInt32(ctx, start),
-                                                     prop_flags) < 0) {
-                        JS_FreeValue(ctx, val);
-                        goto fail;
-                    }
-                    if (JS_DefinePropertyValueUint32(ctx, val, 1,
-                                                     JS_NewInt32(ctx, end),
-                                                     prop_flags) < 0) {
-                        JS_FreeValue(ctx, val);
-                        goto fail;
-                    }
-                }
-                if (name && !JS_IsUndefined(indices_groups)) {
-                    val = JS_DupValue(ctx, val);
-                    if (JS_DefinePropertyValueStr(ctx, indices_groups,
-                                                  name, val, prop_flags) < 0) {
-                        JS_FreeValue(ctx, val);
-                        goto fail;
-                    }
-                }
-                if (JS_DefinePropertyValueUint32(ctx, indices, i, val,
-                                                 prop_flags) < 0) {
-                    goto fail;
-                }
-            }
-
-            val = JS_UNDEFINED;
-            if (start != -1) {
+            } else {
+                start = (capture[2 * i] - str_buf) >> shift;
+                end = (capture[2 * i + 1] - str_buf) >> shift;
                 val = js_sub_string(ctx, str, start, end);
                 if (JS_IsException(val))
                     goto fail;
             }
-
-            if (name) {
-                if (JS_DefinePropertyValueStr(ctx, groups, name,
-                                              JS_DupValue(ctx, val),
-                                              prop_flags) < 0) {
-                    JS_FreeValue(ctx, val);
-                    goto fail;
+            if (group_name_ptr && i > 0) {
+                if (*group_name_ptr) {
+                    if (JS_DefinePropertyValueStr(ctx, groups, group_name_ptr,
+                                                  JS_DupValue(ctx, val),
+                                                  prop_flags) < 0) {
+                        JS_FreeValue(ctx, val);
+                        goto fail;
+                    }
                 }
+                group_name_ptr += strlen(group_name_ptr) + 1;
             }
-
             if (JS_DefinePropertyValueUint32(ctx, obj, i, val, prop_flags) < 0)
                 goto fail;
         }
-
-        t = groups, groups = JS_UNDEFINED;
         if (JS_DefinePropertyValue(ctx, obj, JS_ATOM_groups,
-                                   t, prop_flags) < 0) {
+                                   groups, prop_flags) < 0)
             goto fail;
-        }
-
-        t = JS_NewInt32(ctx, (capture[0] - str_buf) >> shift);
-        if (JS_DefinePropertyValue(ctx, obj, JS_ATOM_index, t, prop_flags) < 0)
+        if (JS_DefinePropertyValue(ctx, obj, JS_ATOM_index,
+                                   JS_NewInt32(ctx, (capture[0] - str_buf) >> shift), prop_flags) < 0)
             goto fail;
-
-        t = str_val, str_val = JS_UNDEFINED;
-        if (JS_DefinePropertyValue(ctx, obj, JS_ATOM_input, t, prop_flags) < 0)
-            goto fail;
-
-        if (!JS_IsUndefined(indices)) {
-            t = indices_groups, indices_groups = JS_UNDEFINED;
-            if (JS_DefinePropertyValue(ctx, indices, JS_ATOM_groups,
-                                       t, prop_flags) < 0) {
-                goto fail;
-            }
-            t = indices, indices = JS_UNDEFINED;
-            if (JS_DefinePropertyValue(ctx, obj, JS_ATOM_indices,
-                                       t, prop_flags) < 0) {
-                goto fail;
-            }
-        }
+        if (JS_DefinePropertyValue(ctx, obj, JS_ATOM_input, str_val, prop_flags) < 0)
+            goto fail1;
     }
-    ret = obj;
-    obj = JS_UNDEFINED;
+    js_free(ctx, capture);
+    return obj;
 fail:
-    JS_FreeValue(ctx, indices_groups);
-    JS_FreeValue(ctx, indices);
+    JS_FreeValue(ctx, groups);
     JS_FreeValue(ctx, str_val);
-    JS_FreeValue(ctx, groups);
+fail1:
     JS_FreeValue(ctx, obj);
     js_free(ctx, capture);
-    return ret;
+    return JS_EXCEPTION;
 }
 
 /* delete portions of a string that match a given regex */
@@ -44146,7 +42527,7 @@
             break;
         }
         if (end == start) {
-            if (!(re_flags & LRE_FLAG_UNICODE) || (unsigned)end >= str->len || !str->is_wide_char) {
+            if (!(re_flags & LRE_FLAG_UTF16) || (unsigned)end >= str->len || !str->is_wide_char) {
                 end++;
             } else {
                 string_getc(str, &end);
@@ -44219,7 +42600,7 @@
 {
     // [Symbol.match](str)
     JSValueConst rx = this_val;
-    JSValue A, S, flags, result, matchStr;
+    JSValue A, S, result, matchStr;
     int global, n, fullUnicode, isEmpty;
     JSString *p;
 
@@ -44227,23 +42608,16 @@
         return JS_ThrowTypeErrorNotAnObject(ctx);
 
     A = JS_UNDEFINED;
-    flags = JS_UNDEFINED;
     result = JS_UNDEFINED;
     matchStr = JS_UNDEFINED;
     S = JS_ToString(ctx, argv[0]);
     if (JS_IsException(S))
         goto exception;
 
-    flags = JS_GetProperty(ctx, rx, JS_ATOM_flags);
-    if (JS_IsException(flags))
-        goto exception;
-    flags = JS_ToStringFree(ctx, flags);
-    if (JS_IsException(flags))
+    global = JS_ToBoolFree(ctx, JS_GetProperty(ctx, rx, JS_ATOM_global));
+    if (global < 0)
         goto exception;
-    p = JS_VALUE_GET_STRING(flags);
 
-    // TODO(bnoordhuis) query 'u' flag the same way?
-    global = (-1 != string_indexof_char(p, 'g', 0));
     if (!global) {
         A = JS_RegExpExec(ctx, rx, S);
     } else {
@@ -44287,14 +42661,12 @@
         }
     }
     JS_FreeValue(ctx, result);
-    JS_FreeValue(ctx, flags);
     JS_FreeValue(ctx, S);
     return A;
 
 exception:
     JS_FreeValue(ctx, A);
     JS_FreeValue(ctx, result);
-    JS_FreeValue(ctx, flags);
     JS_FreeValue(ctx, S);
     return JS_EXCEPTION;
 }
@@ -44537,8 +42909,8 @@
     // [Symbol.replace](str, rep)
     JSValueConst rx = this_val, rep = argv[1];
     JSValueConst args[6];
-    JSValue flags, str, rep_val, matched, tab, rep_str, namedCaptures, res;
-    JSString *p, *sp, *rp;
+    JSValue str, rep_val, matched, tab, rep_str, namedCaptures, res;
+    JSString *sp, *rp;
     StringBuffer b_s, *b = &b_s;
     ValueBuffer v_b, *results = &v_b;
     int nextSourcePosition, n, j, functionalReplace, is_global, fullUnicode;
@@ -44554,7 +42926,6 @@
     rep_val = JS_UNDEFINED;
     matched = JS_UNDEFINED;
     tab = JS_UNDEFINED;
-    flags = JS_UNDEFINED;
     rep_str = JS_UNDEFINED;
     namedCaptures = JS_UNDEFINED;
 
@@ -44571,18 +42942,10 @@
             goto exception;
         rp = JS_VALUE_GET_STRING(rep_val);
     }
-
-    flags = JS_GetProperty(ctx, rx, JS_ATOM_flags);
-    if (JS_IsException(flags))
+    fullUnicode = 0;
+    is_global = JS_ToBoolFree(ctx, JS_GetProperty(ctx, rx, JS_ATOM_global));
+    if (is_global < 0)
         goto exception;
-    flags = JS_ToStringFree(ctx, flags);
-    if (JS_IsException(flags))
-        goto exception;
-    p = JS_VALUE_GET_STRING(flags);
-
-    // TODO(bnoordhuis) query 'u' flag the same way?
-    fullUnicode = 0;
-    is_global = (-1 != string_indexof_char(p, 'g', 0));
     if (is_global) {
         fullUnicode = JS_ToBoolFree(ctx, JS_GetProperty(ctx, rx, JS_ATOM_unicode));
         if (fullUnicode < 0)
@@ -44716,7 +43079,6 @@
     value_buffer_free(results);
     JS_FreeValue(ctx, rep_val);
     JS_FreeValue(ctx, matched);
-    JS_FreeValue(ctx, flags);
     JS_FreeValue(ctx, tab);
     JS_FreeValue(ctx, rep_str);
     JS_FreeValue(ctx, namedCaptures);
@@ -44917,13 +43279,12 @@
 static const JSCFunctionListEntry js_regexp_proto_funcs[] = {
     JS_CGETSET_DEF("flags", js_regexp_get_flags, NULL ),
     JS_CGETSET_DEF("source", js_regexp_get_source, NULL ),
-    JS_CGETSET_MAGIC_DEF("global", js_regexp_get_flag, NULL, LRE_FLAG_GLOBAL ),
-    JS_CGETSET_MAGIC_DEF("ignoreCase", js_regexp_get_flag, NULL, LRE_FLAG_IGNORECASE ),
-    JS_CGETSET_MAGIC_DEF("multiline", js_regexp_get_flag, NULL, LRE_FLAG_MULTILINE ),
-    JS_CGETSET_MAGIC_DEF("dotAll", js_regexp_get_flag, NULL, LRE_FLAG_DOTALL ),
-    JS_CGETSET_MAGIC_DEF("unicode", js_regexp_get_flag, NULL, LRE_FLAG_UNICODE ),
-    JS_CGETSET_MAGIC_DEF("sticky", js_regexp_get_flag, NULL, LRE_FLAG_STICKY ),
-    JS_CGETSET_MAGIC_DEF("hasIndices", js_regexp_get_flag, NULL, LRE_FLAG_INDICES ),
+    JS_CGETSET_MAGIC_DEF("global", js_regexp_get_flag, NULL, 1 ),
+    JS_CGETSET_MAGIC_DEF("ignoreCase", js_regexp_get_flag, NULL, 2 ),
+    JS_CGETSET_MAGIC_DEF("multiline", js_regexp_get_flag, NULL, 4 ),
+    JS_CGETSET_MAGIC_DEF("dotAll", js_regexp_get_flag, NULL, 8 ),
+    JS_CGETSET_MAGIC_DEF("unicode", js_regexp_get_flag, NULL, 16 ),
+    JS_CGETSET_MAGIC_DEF("sticky", js_regexp_get_flag, NULL, 32 ),
     JS_CFUNC_DEF("exec", 1, js_regexp_exec ),
     JS_CFUNC_DEF("compile", 2, js_regexp_compile ),
     JS_CFUNC_DEF("test", 1, js_regexp_test ),
@@ -45081,7 +43442,7 @@
     case TOK_IDENT:
         if (s->token.u.ident.atom == JS_ATOM_false ||
             s->token.u.ident.atom == JS_ATOM_true) {
-            val = JS_NewBool(ctx, s->token.u.ident.atom == JS_ATOM_true);
+            val = JS_NewBool(ctx, (s->token.u.ident.atom == JS_ATOM_true));
         } else if (s->token.u.ident.atom == JS_ATOM_null) {
             val = JS_NULL;
         } else {
@@ -45093,7 +43454,7 @@
     default:
     def_token:
         if (s->token.val == TOK_EOF) {
-            js_parse_error(s, "Unexpected end of JSON input");
+            js_parse_error(s, "unexpected end of input");
         } else {
             js_parse_error(s, "unexpected token: '%.*s'",
                            (int)(s->buf_ptr - s->token.ptr), s->token.ptr);
@@ -45260,27 +43621,22 @@
     JSValue v;
     JSValueConst args[2];
 
-    /* check for object.toJSON method */
-    /* ECMA specifies this is done only for Object and BigInt */
-    /* we do it for BigFloat and BigDecimal as an extension */
-    if (JS_IsObject(val) || JS_IsBigInt(ctx, val)
-#ifdef CONFIG_BIGNUM
-    ||  JS_IsBigFloat(val) || JS_IsBigDecimal(val)
-#endif
+    if (JS_IsObject(val) ||
+        JS_IsBigInt(ctx, val)   /* XXX: probably useless */
         ) {
-        JSValue f = JS_GetProperty(ctx, val, JS_ATOM_toJSON);
-        if (JS_IsException(f))
-            goto exception;
-        if (JS_IsFunction(ctx, f)) {
-            v = JS_CallFree(ctx, f, val, 1, &key);
-            JS_FreeValue(ctx, val);
-            val = v;
-            if (JS_IsException(val))
-                goto exception;
-        } else {
-            JS_FreeValue(ctx, f);
-        }
-    }
+            JSValue f = JS_GetProperty(ctx, val, JS_ATOM_toJSON);
+            if (JS_IsException(f))
+                goto exception;
+            if (JS_IsFunction(ctx, f)) {
+                v = JS_CallFree(ctx, f, val, 1, &key);
+                JS_FreeValue(ctx, val);
+                val = v;
+                if (JS_IsException(val))
+                    goto exception;
+            } else {
+                JS_FreeValue(ctx, f);
+            }
+        }
 
     if (!JS_IsUndefined(jsc->replacer_func)) {
         args[0] = key;
@@ -45299,13 +43655,12 @@
     case JS_TAG_STRING:
     case JS_TAG_INT:
     case JS_TAG_FLOAT64:
+#ifdef CONFIG_BIGNUM
+    case JS_TAG_BIG_FLOAT:
+#endif
     case JS_TAG_BOOL:
     case JS_TAG_NULL:
     case JS_TAG_BIG_INT:
-#ifdef CONFIG_BIGNUM
-    case JS_TAG_BIG_FLOAT:
-    case JS_TAG_BIG_DECIMAL:
-#endif
     case JS_TAG_EXCEPTION:
         return val;
     default:
@@ -45335,29 +43690,36 @@
     tab = JS_UNDEFINED;
     prop = JS_UNDEFINED;
 
-    if (JS_IsObject(val)) {
+    switch (JS_VALUE_GET_NORM_TAG(val)) {
+    case JS_TAG_OBJECT:
         p = JS_VALUE_GET_OBJ(val);
         cl = p->class_id;
         if (cl == JS_CLASS_STRING) {
             val = JS_ToStringFree(ctx, val);
             if (JS_IsException(val))
                 goto exception;
-            goto concat_primitive;
+            val = JS_ToQuotedStringFree(ctx, val);
+            if (JS_IsException(val))
+                goto exception;
+            return string_buffer_concat_value_free(jsc->b, val);
         } else if (cl == JS_CLASS_NUMBER) {
             val = JS_ToNumberFree(ctx, val);
             if (JS_IsException(val))
                 goto exception;
-            goto concat_primitive;
-        } else if (cl == JS_CLASS_BOOLEAN || cl == JS_CLASS_BIG_INT
+            return string_buffer_concat_value_free(jsc->b, val);
+        } else if (cl == JS_CLASS_BOOLEAN) {
+            ret = string_buffer_concat_value(jsc->b, p->u.object_data);
+            JS_FreeValue(ctx, val);
+            return ret;
+        } else
 #ifdef CONFIG_BIGNUM
-               || cl == JS_CLASS_BIG_FLOAT
-               || cl == JS_CLASS_BIG_DECIMAL
+        if (cl == JS_CLASS_BIG_FLOAT) {
+            return string_buffer_concat_value_free(jsc->b, val);
+        } else
 #endif
-                   )
-        {
-            /* This will thow the same error as for the primitive object */
-            set_value(ctx, &val, JS_DupValue(ctx, p->u.object_data));
-            goto concat_primitive;
+        if (cl == JS_CLASS_BIG_INT) {
+            JS_ThrowTypeError(ctx, "bigint are forbidden in JSON.stringify");
+            goto exception;
         }
         v = js_array_includes(ctx, jsc->stack, 1, (JSValueConst *)&val);
         if (JS_IsException(v))
@@ -45455,7 +43817,7 @@
                     has_content = TRUE;
                 }
             }
-            if (has_content && !JS_IsEmptyString(jsc->gap)) {
+            if (has_content && JS_VALUE_GET_STRING(jsc->gap)->len != 0) {
                 string_buffer_putc8(jsc->b, '\n');
                 string_buffer_concat_value(jsc->b, indent);
             }
@@ -45470,9 +43832,6 @@
         JS_FreeValue(ctx, indent1);
         JS_FreeValue(ctx, prop);
         return 0;
-    }
- concat_primitive:
-    switch (JS_VALUE_GET_NORM_TAG(val)) {
     case JS_TAG_STRING:
         val = JS_ToQuotedStringFree(ctx, val);
         if (JS_IsException(val))
@@ -45484,17 +43843,15 @@
         }
         goto concat_value;
     case JS_TAG_INT:
+#ifdef CONFIG_BIGNUM
+    case JS_TAG_BIG_FLOAT:
+#endif
     case JS_TAG_BOOL:
     case JS_TAG_NULL:
     concat_value:
         return string_buffer_concat_value_free(jsc->b, val);
     case JS_TAG_BIG_INT:
-#ifdef CONFIG_BIGNUM
-    case JS_TAG_BIG_FLOAT:
-    case JS_TAG_BIG_DECIMAL:
-#endif
-        /* reject big numbers: use toJSON method to override */
-        JS_ThrowTypeError(ctx, "Do not know how to serialize a BigInt");
+        JS_ThrowTypeError(ctx, "bigint are forbidden in JSON.stringify");
         goto exception;
     default:
         JS_FreeValue(ctx, val);
@@ -45785,8 +44142,8 @@
     atom = JS_ValueToAtom(ctx, prop);
     if (unlikely(atom == JS_ATOM_NULL))
         return JS_EXCEPTION;
-    ret = JS_SetPropertyInternal(ctx, obj, atom,
-                                 JS_DupValue(ctx, val), receiver, 0);
+    ret = JS_SetPropertyGeneric(ctx, obj, atom,
+                                JS_DupValue(ctx, val), receiver, 0);
     JS_FreeAtom(ctx, atom);
     if (ret < 0)
         return JS_EXCEPTION;
@@ -46133,9 +44490,9 @@
     if (!s)
         return -1;
     if (JS_IsUndefined(method)) {
-        return JS_SetPropertyInternal(ctx, s->target, atom,
-                                      JS_DupValue(ctx, value), receiver,
-                                      flags);
+        return JS_SetPropertyGeneric(ctx, s->target, atom,
+                                     JS_DupValue(ctx, value), receiver,
+                                     flags);
     }
     atom_val = JS_AtomToValue(ctx, atom);
     if (JS_IsException(atom_val)) {
@@ -46201,17 +44558,17 @@
     }
     if (flags & JS_PROP_HAS_WRITABLE) {
         JS_DefinePropertyValue(ctx, ret, JS_ATOM_writable,
-                               JS_NewBool(ctx, flags & JS_PROP_WRITABLE),
+                               JS_NewBool(ctx, (flags & JS_PROP_WRITABLE) != 0),
                                JS_PROP_C_W_E);
     }
     if (flags & JS_PROP_HAS_ENUMERABLE) {
         JS_DefinePropertyValue(ctx, ret, JS_ATOM_enumerable,
-                               JS_NewBool(ctx, flags & JS_PROP_ENUMERABLE),
+                               JS_NewBool(ctx, (flags & JS_PROP_ENUMERABLE) != 0),
                                JS_PROP_C_W_E);
     }
     if (flags & JS_PROP_HAS_CONFIGURABLE) {
         JS_DefinePropertyValue(ctx, ret, JS_ATOM_configurable,
-                               JS_NewBool(ctx, flags & JS_PROP_CONFIGURABLE),
+                               JS_NewBool(ctx, (flags & JS_PROP_CONFIGURABLE) != 0),
                                JS_PROP_C_W_E);
     }
     return ret;
@@ -47071,7 +45428,7 @@
         h = (uintptr_t)JS_VALUE_GET_PTR(key) * 3163;
         break;
     case JS_TAG_INT:
-        d = JS_VALUE_GET_INT(key);
+        d = JS_VALUE_GET_INT(key) * 3163;
         goto hash_float64;
     case JS_TAG_FLOAT64:
         d = JS_VALUE_GET_FLOAT64(key);
@@ -47081,7 +45438,7 @@
     hash_float64:
         u.d = d;
         h = (u.u32[0] ^ u.u32[1]) * 3163;
-        return h ^= JS_TAG_FLOAT64;
+        break;
     default:
         h = 0; /* XXX: bignum support */
         break;
@@ -47158,7 +45515,7 @@
     } else {
         JS_DupValue(ctx, key);
     }
-    mr->key = (JSValue)key;
+    mr->key = key;
     h = map_hash_key(ctx, key) & (s->hash_size - 1);
     list_add_tail(&mr->hash_link, &s->hash_table[h]);
     list_add_tail(&mr->link, &s->records);
@@ -47305,7 +45662,7 @@
         return JS_EXCEPTION;
     key = map_normalize_key(ctx, argv[0]);
     mr = map_find_record(ctx, s, key);
-    return JS_NewBool(ctx, mr != NULL);
+    return JS_NewBool(ctx, (mr != NULL));
 }
 
 static JSValue js_map_delete(JSContext *ctx, JSValueConst this_val,
@@ -47380,7 +45737,7 @@
                 args[0] = args[1];
             else
                 args[0] = JS_DupValue(ctx, mr->value);
-            args[2] = (JSValue)this_val;
+            args[2] = this_val;
             ret = JS_Call(ctx, func, this_arg, 3, (JSValueConst *)args);
             JS_FreeValue(ctx, args[0]);
             if (!magic)
@@ -47397,123 +45754,6 @@
     return JS_UNDEFINED;
 }
 
-static JSValue js_object_groupBy(JSContext *ctx, JSValueConst this_val,
-                                 int argc, JSValueConst *argv, int is_map)
-{
-    JSValueConst cb, args[2];
-    JSValue res, iter, next, groups, key, v, prop;
-    JSAtom key_atom = JS_ATOM_NULL;
-    int64_t idx;
-    BOOL done;
-
-    // "is function?" check must be observed before argv[0] is accessed
-    cb = argv[1];
-    if (check_function(ctx, cb))
-        return JS_EXCEPTION;
-
-    iter = JS_GetIterator(ctx, argv[0], /*is_async*/FALSE);
-    if (JS_IsException(iter))
-        return JS_EXCEPTION;
-
-    key = JS_UNDEFINED;
-    key_atom = JS_ATOM_NULL;
-    v = JS_UNDEFINED;
-    prop = JS_UNDEFINED;
-    groups = JS_UNDEFINED;
-
-    next = JS_GetProperty(ctx, iter, JS_ATOM_next);
-    if (JS_IsException(next))
-        goto exception;
-
-    if (is_map) {
-        groups = js_map_constructor(ctx, JS_UNDEFINED, 0, NULL, 0);
-    } else {
-        groups = JS_NewObjectProto(ctx, JS_NULL);
-    }
-    if (JS_IsException(groups))
-        goto exception;
-
-    for (idx = 0; ; idx++) {
-        if (idx >= MAX_SAFE_INTEGER) {
-            JS_ThrowTypeError(ctx, "too many elements");
-            goto iterator_close_exception;
-        }
-        v = JS_IteratorNext(ctx, iter, next, 0, NULL, &done);
-        if (JS_IsException(v))
-            goto exception;
-        if (done)
-            break; // v is JS_UNDEFINED
-
-        args[0] = v;
-        args[1] = JS_NewInt64(ctx, idx);
-        key = JS_Call(ctx, cb, ctx->global_obj, 2, args);
-        if (JS_IsException(key))
-            goto iterator_close_exception;
-
-        if (is_map) {
-            prop = js_map_get(ctx, groups, 1, (JSValueConst *)&key, 0);
-        } else {
-            key_atom = JS_ValueToAtom(ctx, key);
-            JS_FreeValue(ctx, key);
-            key = JS_UNDEFINED;
-            if (key_atom == JS_ATOM_NULL)
-                goto iterator_close_exception;
-            prop = JS_GetProperty(ctx, groups, key_atom);
-        }
-        if (JS_IsException(prop))
-            goto exception;
-
-        if (JS_IsUndefined(prop)) {
-            prop = JS_NewArray(ctx);
-            if (JS_IsException(prop))
-                goto exception;
-            if (is_map) {
-                args[0] = key;
-                args[1] = prop;
-                res = js_map_set(ctx, groups, 2, args, 0);
-                if (JS_IsException(res))
-                    goto exception;
-                JS_FreeValue(ctx, res);
-            } else {
-                prop = JS_DupValue(ctx, prop);
-                if (JS_DefinePropertyValue(ctx, groups, key_atom, prop,
-                                           JS_PROP_C_W_E) < 0) {
-                    goto exception;
-                }
-            }
-        }
-        res = js_array_push(ctx, prop, 1, (JSValueConst *)&v, /*unshift*/0);
-        if (JS_IsException(res))
-            goto exception;
-        // res is an int64
-
-        JS_FreeValue(ctx, prop);
-        JS_FreeValue(ctx, key);
-        JS_FreeAtom(ctx, key_atom);
-        JS_FreeValue(ctx, v);
-        prop = JS_UNDEFINED;
-        key = JS_UNDEFINED;
-        key_atom = JS_ATOM_NULL;
-        v = JS_UNDEFINED;
-    }
-
-    JS_FreeValue(ctx, iter);
-    JS_FreeValue(ctx, next);
-    return groups;
-
- iterator_close_exception:
-    JS_IteratorClose(ctx, iter, TRUE);
- exception:
-    JS_FreeAtom(ctx, key_atom);
-    JS_FreeValue(ctx, prop);
-    JS_FreeValue(ctx, key);
-    JS_FreeValue(ctx, v);
-    JS_FreeValue(ctx, groups);
-    JS_FreeValue(ctx, iter);
-    JS_FreeValue(ctx, next);
-    return JS_EXCEPTION;
-}
-
 static void js_map_finalizer(JSRuntime *rt, JSValue val)
 {
     JSObject *p;
@@ -47694,7 +45934,6 @@
 }
 
 static const JSCFunctionListEntry js_map_funcs[] = {
-    JS_CFUNC_MAGIC_DEF("groupBy", 2, js_object_groupBy, 1 ),
     JS_CGETSET_DEF("[Symbol.species]", js_get_this, NULL ),
 };
 
@@ -47815,12 +46054,19 @@
 
 /* Promise */
 
+typedef enum JSPromiseStateEnum {
+    JS_PROMISE_PENDING,
+    JS_PROMISE_FULFILLED,
+    JS_PROMISE_REJECTED,
+} JSPromiseStateEnum;
+
 typedef struct JSPromiseData {
     JSPromiseStateEnum promise_state;
     /* 0=fulfill, 1=reject, list of JSPromiseReactionData.link */
     struct list_head promise_reactions[2];
     BOOL is_handled; /* Note: only useful to debug */
     JSValue promise_result;
+    JSContext * ctx;
 } JSPromiseData;
 
 typedef struct JSPromiseFunctionDataResolved {
@@ -47839,22 +46085,6 @@
     JSValue handler;
 } JSPromiseReactionData;
 
-JSPromiseStateEnum JS_PromiseState(JSContext *ctx, JSValue promise)
-{
-    JSPromiseData *s = JS_GetOpaque(promise, JS_CLASS_PROMISE);
-    if (!s)
-        return -1;
-    return s->promise_state;
-}
-
-JSValue JS_PromiseResult(JSContext *ctx, JSValue promise)
-{
-    JSPromiseData *s = JS_GetOpaque(promise, JS_CLASS_PROMISE);
-    if (!s)
-        return JS_UNDEFINED;
-    return JS_DupValue(ctx, s->promise_result);
-}
-
 static int js_create_resolving_functions(JSContext *ctx, JSValue *args,
                                          JSValueConst promise);
 
@@ -47917,6 +46147,15 @@
     rt->host_promise_rejection_tracker_opaque = opaque;
 }
 
+void JS_SetHostUnhandledPromiseRejectionTracker(JSRuntime *rt,
+                                       JSHostPromiseRejectionTracker *cb,
+                                       void *opaque)
+{
+    rt->host_unhandled_promise_rejection_tracker = cb;
+    rt->host_unhandled_promise_rejection_tracker_opaque = opaque;
+}
+
+
 static void fulfill_or_reject_promise(JSContext *ctx, JSValueConst promise,
                                       JSValueConst value, BOOL is_reject)
 {
@@ -48121,6 +46360,14 @@
 
     if (!s)
         return;
+    if (s->promise_state == JS_PROMISE_REJECTED && !s->is_handled) {
+        if (rt->host_unhandled_promise_rejection_tracker) {
+            rt->host_unhandled_promise_rejection_tracker(s->ctx, val, s->promise_result, FALSE,
+                                                         rt->host_unhandled_promise_rejection_tracker_opaque);
+        }
+    }
+
+
     for(i = 0; i < 2; i++) {
         list_for_each_safe(el, el1, &s->promise_reactions[i]) {
             JSPromiseReactionData *rd =
@@ -48171,6 +46418,7 @@
     s = js_mallocz(ctx, sizeof(*s));
     if (!s)
         goto fail;
+    s->ctx = ctx;
     s->promise_state = JS_PROMISE_PENDING;
     s->is_handled = FALSE;
     for(i = 0; i < 2; i++)
@@ -48300,14 +46548,17 @@
     return result_promise;
 }
 
-static JSValue js_promise_withResolvers(JSContext *ctx,
-                                        JSValueConst this_val,
-                                        int argc, JSValueConst *argv)
+#if 0
+static JSValue js_promise___newPromiseCapability(JSContext *ctx,
+                                                 JSValueConst this_val,
+                                                 int argc, JSValueConst *argv)
 {
     JSValue result_promise, resolving_funcs[2], obj;
-    if (!JS_IsObject(this_val))
+    JSValueConst ctor;
+    ctor = argv[0];
+    if (!JS_IsObject(ctor))
         return JS_ThrowTypeErrorNotAnObject(ctx);
-    result_promise = js_new_promise_capability(ctx, resolving_funcs, this_val);
+    result_promise = js_new_promise_capability(ctx, resolving_funcs, ctor);
     if (JS_IsException(result_promise))
         return result_promise;
     obj = JS_NewObject(ctx);
@@ -48322,6 +46573,7 @@
     JS_DefinePropertyValue(ctx, obj, JS_ATOM_reject, resolving_funcs[1], JS_PROP_C_W_E);
     return obj;
 }
+#endif
 
 static __exception int remainingElementsCount_add(JSContext *ctx,
                                                   JSValueConst resolve_element_env,
@@ -48482,7 +46734,7 @@
                 goto fail_reject;
             }
             resolve_element_data[0] = JS_NewBool(ctx, FALSE);
-            resolve_element_data[1] = (JSValueConst)JS_NewInt32(ctx, index);
+            resolve_element_data[1] = JS_NewInt32(ctx, index);
             resolve_element_data[2] = values;
             resolve_element_data[3] = resolving_funcs[is_promise_any];
             resolve_element_data[4] = resolve_element_env;
@@ -48811,7 +47063,7 @@
     JS_CFUNC_MAGIC_DEF("allSettled", 1, js_promise_all, PROMISE_MAGIC_allSettled ),
     JS_CFUNC_MAGIC_DEF("any", 1, js_promise_all, PROMISE_MAGIC_any ),
     JS_CFUNC_DEF("race", 1, js_promise_race ),
-    JS_CFUNC_DEF("withResolvers", 0, js_promise_withResolvers ),
+    //JS_CFUNC_DEF("__newPromiseCapability", 1, js_promise___newPromiseCapability ),
     JS_CGETSET_DEF("[Symbol.species]", js_get_this, NULL),
 };
 
@@ -48841,7 +47093,7 @@
 {
     JSValueConst func_data[1];
 
-    func_data[0] = (JSValueConst)JS_NewBool(ctx, done);
+    func_data[0] = JS_NewBool(ctx, done);
     return JS_NewCFunctionData(ctx, js_async_from_sync_iterator_unwrap,
                                1, 0, 1, func_data);
 }
@@ -49146,7 +47398,7 @@
     return c < 0x100 && memchr(";/?:@&=+$,#", c, sizeof(";/?:@&=+$,#") - 1) != NULL;
 }
 
-static int __attribute__((format(printf, 2, 3))) js_throw_URIError(JSContext *ctx, const char *fmt, ...)
+static int PLATFORM_PRINTF_LIKE(2, 3) js_throw_URIError(JSContext *ctx, const char *fmt, ...)
 {
     va_list ap;
 
@@ -49224,7 +47476,8 @@
                     }
                     c = (c << 6) | (c1 & 0x3f);
                 }
-                if (c < c_min || c > 0x10FFFF || is_surrogate(c)) {
+                if (c < c_min || c > 0x10FFFF ||
+                    (c >= 0xd800 && c < 0xe000)) {
                     js_throw_URIError(ctx, "malformed UTF-8");
                     goto fail;
                 }
@@ -49299,21 +47552,21 @@
         if (isURIUnescaped(c, isComponent)) {
             string_buffer_putc16(b, c);
         } else {
-            if (is_lo_surrogate(c)) {
+            if (c >= 0xdc00 && c <= 0xdfff) {
                 js_throw_URIError(ctx, "invalid character");
                 goto fail;
-            } else if (is_hi_surrogate(c)) {
+            } else if (c >= 0xd800 && c <= 0xdbff) {
                 if (k >= p->len) {
                     js_throw_URIError(ctx, "expecting surrogate pair");
                     goto fail;
                 }
                 c1 = string_get(p, k);
                 k++;
-                if (!is_lo_surrogate(c1)) {
+                if (c1 < 0xdc00 || c1 > 0xdfff) {
                     js_throw_URIError(ctx, "expecting surrogate pair");
                     goto fail;
                 }
-                c = from_surrogate(c, c1);
+                c = (((c & 0x3ff) << 10) | (c1 & 0x3ff)) + 0x10000;
             }
             if (c < 0x80) {
                 encodeURI_hex(b, c);
@@ -49418,10 +47671,15 @@
     JS_CFUNC_MAGIC_DEF("encodeURIComponent", 1, js_global_encodeURI, 1 ),
     JS_CFUNC_DEF("escape", 1, js_global_escape ),
     JS_CFUNC_DEF("unescape", 1, js_global_unescape ),
-    JS_PROP_DOUBLE_DEF("Infinity", 1.0 / 0.0, 0 ),
+    JS_PROP_DOUBLE_DEF("Infinity", INFINITY, 0 ),
     JS_PROP_DOUBLE_DEF("NaN", NAN, 0 ),
     JS_PROP_UNDEFINED_DEF("undefined", 0 ),
-    JS_PROP_STRING_DEF("[Symbol.toStringTag]", "global", JS_PROP_CONFIGURABLE ),
+
+    /* for the 'Date' implementation */
+    JS_CFUNC_DEF("__date_clock", 0, js___date_clock ),
+    //JS_CFUNC_DEF("__date_now", 0, js___date_now ),
+    //JS_CFUNC_DEF("__date_getTimezoneOffset", 1, js___date_getTimezoneOffset ),
+    //JS_CFUNC_DEF("__date_create", 3, js___date_create ),
 };
 
 /* Date */
@@ -49502,7 +47760,7 @@
 static char const day_names[] = "SunMonTueWedThuFriSat";
 
 static __exception int get_date_fields(JSContext *ctx, JSValueConst obj,
-                                       double fields[minimum_length(9)], int is_local, int force)
+                                       double fields[9], int is_local, int force)
 {
     double dval;
     int64_t d, days, wd, y, i, md, h, m, s, ms, tz = 0;
@@ -49515,7 +47773,7 @@
             return FALSE; /* NaN */
         d = 0;        /* initialize all fields to 0 */
     } else {
-        d = dval;     /* assuming -8.64e15 <= dval <= -8.64e15 */
+        d = dval;
         if (is_local) {
             tz = -getTimezoneOffset(d);
             d += tz * 60000;
@@ -49561,63 +47819,33 @@
         return NAN;
 }
 
-/* The spec mandates the use of 'double' and it specifies the order
+/* The spec mandates the use of 'double' and it fixes the order
    of the operations */
-static double set_date_fields(double fields[minimum_length(7)], int is_local) {
-    double y, m, dt, ym, mn, day, h, s, milli, time, tv;
-    int yi, mi, i;
-    int64_t days;
-    volatile double temp;  /* enforce evaluation order */
+static double set_date_fields(double fields[], int is_local) {
+    int64_t y;
+    double days, d, h, m1;
+    int i, m, md;
 
-    /* emulate 21.4.1.15 MakeDay ( year, month, date ) */
-    y = fields[0];
-    m = fields[1];
-    dt = fields[2];
-    ym = y + floor(m / 12);
-    mn = fmod(m, 12);
-    if (mn < 0)
-        mn += 12;
-    if (ym < -271821 || ym > 275760)
-        return NAN;
+    m1 = fields[1];
+    m = fmod(m1, 12);
+    if (m < 0)
+        m += 12;
+    y = (int64_t)(fields[0] + floor(m1 / 12));
+    days = days_from_year(y);
 
-    yi = ym;
-    mi = mn;
-    days = days_from_year(yi);
-    for(i = 0; i < mi; i++) {
-        days += month_days[i];
+    for(i = 0; i < m; i++) {
+        md = month_days[i];
         if (i == 1)
-            days += days_in_year(yi) - 365;
+            md += days_in_year(y) - 365;
+        days += md;
     }
-    day = days + dt - 1;
-
-    /* emulate 21.4.1.14 MakeTime ( hour, min, sec, ms ) */
-    h = fields[3];
-    m = fields[4];
-    s = fields[5];
-    milli = fields[6];
-    /* Use a volatile intermediary variable to ensure order of evaluation
-     * as specified in ECMA. This fixes a test262 error on
-     * test262/test/built-ins/Date/UTC/fp-evaluation-order.js.
-     * Without the volatile qualifier, the compile can generate code
-     * that performs the computation in a different order or with instructions
-     * that produce a different result such as FMA (float multiply and add).
-     */
-    time = h * 3600000;
-    time += (temp = m * 60000);
-    time += (temp = s * 1000);
-    time += milli;
-
-    /* emulate 21.4.1.16 MakeDate ( day, time ) */
-    tv = (temp = day * 86400000) + time;   /* prevent generation of FMA */
-    if (!isfinite(tv))
-        return NAN;
-
-    /* adjust for local time and clip */
-    if (is_local) {
-        int64_t ti = tv < INT64_MIN ? INT64_MIN : tv >= 0x1p63 ? INT64_MAX : (int64_t)tv;
-        tv += getTimezoneOffset(ti) * 60000;
-    }
-    return time_clip(tv);
+    days += fields[2] - 1;
+    h = fields[3] * 3600000 + fields[4] * 60000 +
+        fields[5] * 1000 + fields[6];
+    d = days * 86400000 + h;
+    if (is_local)
+        d += getTimezoneOffset(d) * 60000;
+    return time_clip(d);
 }
 
 static JSValue get_date_field(JSContext *ctx, JSValueConst this_val,
@@ -49657,19 +47885,20 @@
     res = get_date_fields(ctx, this_val, fields, is_local, first_field == 0);
     if (res < 0)
         return JS_EXCEPTION;
-
-    // Argument coercion is observable and must be done unconditionally.
-    n = min_int(argc, end_field - first_field);
-    for(i = 0; i < n; i++) {
-        if (JS_ToFloat64(ctx, &a, argv[i]))
-            return JS_EXCEPTION;
-        if (!isfinite(a))
-            res = FALSE;
-        fields[first_field + i] = trunc(a);
-    }
-    if (res && argc > 0)
+    if (res && argc > 0) {
+        n = end_field - first_field;
+        if (argc < n)
+            n = argc;
+        for(i = 0; i < n; i++) {
+            if (JS_ToFloat64(ctx, &a, argv[i]))
+                return JS_EXCEPTION;
+            if (!isfinite(a))
+                goto done;
+            fields[first_field + i] = trunc(a);
+        }
         d = set_date_fields(fields, is_local);
-
+    }
+done:
     return JS_SetThisTimeValue(ctx, this_val, d);
 }
 
@@ -49779,7 +48008,7 @@
             break;
         case 3:
             pos += snprintf(buf + pos, sizeof(buf) - pos,
-                            "%02d:%02d:%02d %cM", (h + 11) % 12 + 1, m, s,
+                            "%02d:%02d:%02d %cM", (h + 1) % 12 - 1, m, s,
                             (h < 12) ? 'A' : 'P');
             break;
         }
@@ -49895,418 +48124,142 @@
     return JS_NewFloat64(ctx, set_date_fields(fields, 0));
 }
 
-/* Date string parsing */
-
-static BOOL string_skip_char(const uint8_t *sp, int *pp, int c) {
-    if (sp[*pp] == c) {
+static void string_skip_spaces(JSString *sp, int *pp) {
+    while (*pp < sp->len && string_get(sp, *pp) == ' ')
         *pp += 1;
-        return TRUE;
-    } else {
-        return FALSE;
-    }
 }
 
-/* skip spaces, update offset, return next char */
-static int string_skip_spaces(const uint8_t *sp, int *pp) {
-    int c;
-    while ((c = sp[*pp]) == ' ')
-        *pp += 1;
-    return c;
-}
-
-/* skip dashes dots and commas */
-static int string_skip_separators(const uint8_t *sp, int *pp) {
-    int c;
-    while ((c = sp[*pp]) == '-' || c == '/' || c == '.' || c == ',')
-        *pp += 1;
-    return c;
-}
-
-/* skip a word, stop on spaces, digits and separators, update offset */
-static int string_skip_until(const uint8_t *sp, int *pp, const char *stoplist) {
-    int c;
-    while (!strchr(stoplist, c = sp[*pp]))
+static void string_skip_non_spaces(JSString *sp, int *pp) {
+    while (*pp < sp->len && string_get(sp, *pp) != ' ')
         *pp += 1;
-    return c;
 }
 
-/* parse a numeric field (max_digits = 0 -> no maximum) */
-static BOOL string_get_digits(const uint8_t *sp, int *pp, int *pval,
-                              int min_digits, int max_digits)
-{
-    int v = 0;
+/* parse a numeric field with an optional sign if accept_sign is TRUE */
+static int string_get_digits(JSString *sp, int *pp, int64_t *pval) {
+    int64_t v = 0;
     int c, p = *pp, p_start;
 
+    if (p >= sp->len)
+        return -1;
     p_start = p;
-    while ((c = sp[p]) >= '0' && c <= '9') {
+    while (p < sp->len) {
+        c = string_get(sp, p);
+        if (!(c >= '0' && c <= '9')) {
+            if (p == p_start)
+                return -1;
+            else
+                break;
+        }
         v = v * 10 + c - '0';
         p++;
-        if (p - p_start == max_digits)
-            break;
     }
-    if (p - p_start < min_digits)
-        return FALSE;
     *pval = v;
     *pp = p;
-    return TRUE;
+    return 0;
 }
 
-static BOOL string_get_milliseconds(const uint8_t *sp, int *pp, int *pval) {
-    /* parse optional fractional part as milliseconds and truncate. */
-    /* spec does not indicate which rounding should be used */
-    int mul = 100, ms = 0, c, p_start, p = *pp;
+static int string_get_signed_digits(JSString *sp, int *pp, int64_t *pval) {
+    int res, sgn, p = *pp;
 
-    c = sp[p];
-    if (c == '.' || c == ',') {
+    if (p >= sp->len)
+        return -1;
+
+    sgn = string_get(sp, p);
+    if (sgn == '-' || sgn == '+')
         p++;
-        p_start = p;
-        while ((c = sp[p]) >= '0' && c <= '9') {
-            ms += (c - '0') * mul;
-            mul /= 10;
-            p++;
-            if (p - p_start == 9)
-                break;
-        }
-        if (p > p_start) {
-            /* only consume the separator if digits are present */
-            *pval = ms;
-            *pp = p;
-        }
-    }
-    return TRUE;
-}
-
-static uint8_t upper_ascii(uint8_t c) {
-    return c >= 'a' && c <= 'z' ? c - 'a' + 'A' : c;
+
+    res = string_get_digits(sp, &p, pval);
+    if (res == 0 && sgn == '-')
+        *pval = -*pval;
+    *pp = p;
+    return res;
 }
 
-static BOOL string_get_tzoffset(const uint8_t *sp, int *pp, int *tzp, BOOL strict) {
-    int tz = 0, sgn, hh, mm, p = *pp;
+/* parse a fixed width numeric field */
+static int string_get_fixed_width_digits(JSString *sp, int *pp, int n, int64_t *pval) {
+    int64_t v = 0;
+    int i, c, p = *pp;
 
-    sgn = sp[p++];
-    if (sgn == '+' || sgn == '-') {
-        int n = p;
-        if (!string_get_digits(sp, &p, &hh, 1, 9))
-            return FALSE;
-        n = p - n;
-        if (strict && n != 2 && n != 4)
-            return FALSE;
-        while (n > 4) {
-            n -= 2;
-            hh /= 100;
-        }
-        if (n > 2) {
-            mm = hh % 100;
-            hh = hh / 100;
-        } else {
-            mm = 0;
-            if (string_skip_char(sp, &p, ':')  /* optional separator */
-            &&  !string_get_digits(sp, &p, &mm, 2, 2))
-                return FALSE;
-        }
-        if (hh > 23 || mm > 59)
-            return FALSE;
-        tz = hh * 60 + mm;
-        if (sgn != '+')
-            tz = -tz;
-    } else
-    if (sgn != 'Z') {
-        return FALSE;
+    for(i = 0; i < n; i++) {
+        if (p >= sp->len)
+            return -1;
+        c = string_get(sp, p);
+        if (!(c >= '0' && c <= '9'))
+            return -1;
+        v = v * 10 + c - '0';
+        p++;
     }
+    *pval = v;
     *pp = p;
-    *tzp = tz;
-    return TRUE;
+    return 0;
 }
 
-static BOOL string_match(const uint8_t *sp, int *pp, const char *s) {
-    int p = *pp;
-    while (*s != '\0') {
-        if (upper_ascii(sp[p]) != upper_ascii(*s++))
-            return FALSE;
+static int string_get_milliseconds(JSString *sp, int *pp, int64_t *pval) {
+    /* parse milliseconds as a fractional part, round to nearest */
+    /* XXX: the spec does not indicate which rounding should be used */
+    int mul = 1000, ms = 0, p = *pp, c, p_start;
+    if (p >= sp->len)
+        return -1;
+    p_start = p;
+    while (p < sp->len) {
+        c = string_get(sp, p);
+        if (!(c >= '0' && c <= '9')) {
+            if (p == p_start)
+                return -1;
+            else
+                break;
+        }
+        if (mul == 1 && c >= '5')
+            ms += 1;
+        ms += (c - '0') * (mul /= 10);
         p++;
     }
+    *pval = ms;
     *pp = p;
-    return TRUE;
+    return 0;
 }
 
-static int find_abbrev(const uint8_t *sp, int p, const char *list, int count) {
+
+static int find_abbrev(JSString *sp, int p, const char *list, int count) {
     int n, i;
 
-    for (n = 0; n < count; n++) {
-        for (i = 0;; i++) {
-            if (upper_ascii(sp[p + i]) != upper_ascii(list[n * 3 + i]))
-                break;
-            if (i == 2)
-                return n;
+    if (p + 3 <= sp->len) {
+        for (n = 0; n < count; n++) {
+            for (i = 0; i < 3; i++) {
+                if (string_get(sp, p + i) != month_names[n * 3 + i])
+                    goto next;
+            }
+            return n;
+        next:;
         }
     }
     return -1;
 }
 
-static BOOL string_get_month(const uint8_t *sp, int *pp, int *pval) {
+static int string_get_month(JSString *sp, int *pp, int64_t *pval) {
     int n;
 
+    string_skip_spaces(sp, pp);
     n = find_abbrev(sp, *pp, month_names, 12);
     if (n < 0)
-        return FALSE;
+        return -1;
 
-    *pval = n + 1;
+    *pval = n;
     *pp += 3;
-    return TRUE;
-}
-
-/* parse toISOString format */
-static BOOL js_date_parse_isostring(const uint8_t *sp, int fields[9], BOOL *is_local) {
-    int sgn, i, p = 0;
-
-    /* initialize fields to the beginning of the Epoch */
-    for (i = 0; i < 9; i++) {
-        fields[i] = (i == 2);
-    }
-    *is_local = FALSE;
-
-    /* year is either yyyy digits or [+-]yyyyyy */
-    sgn = sp[p];
-    if (sgn == '-' || sgn == '+') {
-        p++;
-        if (!string_get_digits(sp, &p, &fields[0], 6, 6))
-            return FALSE;
-        if (sgn == '-') {
-            if (fields[0] == 0)
-                return FALSE; // reject -000000
-            fields[0] = -fields[0];
-        }
-    } else {
-        if (!string_get_digits(sp, &p, &fields[0], 4, 4))
-            return FALSE;
-    }
-    if (string_skip_char(sp, &p, '-')) {
-        if (!string_get_digits(sp, &p, &fields[1], 2, 2))  /* month */
-            return FALSE;
-        if (fields[1] < 1)
-            return FALSE;
-        fields[1] -= 1;
-        if (string_skip_char(sp, &p, '-')) {
-            if (!string_get_digits(sp, &p, &fields[2], 2, 2))  /* day */
-                return FALSE;
-            if (fields[2] < 1)
-                return FALSE;
-        }
-    }
-    if (string_skip_char(sp, &p, 'T')) {
-        *is_local = TRUE;
-        if (!string_get_digits(sp, &p, &fields[3], 2, 2)  /* hour */
-        ||  !string_skip_char(sp, &p, ':')
-        ||  !string_get_digits(sp, &p, &fields[4], 2, 2)) {  /* minute */
-            fields[3] = 100;  // reject unconditionally
-            return TRUE;
-        }
-        if (string_skip_char(sp, &p, ':')) {
-            if (!string_get_digits(sp, &p, &fields[5], 2, 2))  /* second */
-                return FALSE;
-            string_get_milliseconds(sp, &p, &fields[6]);
-        }
-    }
-    /* parse the time zone offset if present: [+-]HH:mm or [+-]HHmm */
-    if (sp[p]) {
-        *is_local = FALSE;
-        if (!string_get_tzoffset(sp, &p, &fields[8], TRUE))
-            return FALSE;
-    }
-    /* error if extraneous characters */
-    return sp[p] == '\0';
-}
-
-static struct {
-    char name[6];
-    int16_t offset;
-} const js_tzabbr[] = {
-    { "GMT",   0 },         // Greenwich Mean Time
-    { "UTC",   0 },         // Coordinated Universal Time
-    { "UT",    0 },         // Universal Time
-    { "Z",     0 },         // Zulu Time
-    { "EDT",  -4 * 60 },    // Eastern Daylight Time
-    { "EST",  -5 * 60 },    // Eastern Standard Time
-    { "CDT",  -5 * 60 },    // Central Daylight Time
-    { "CST",  -6 * 60 },    // Central Standard Time
-    { "MDT",  -6 * 60 },    // Mountain Daylight Time
-    { "MST",  -7 * 60 },    // Mountain Standard Time
-    { "PDT",  -7 * 60 },    // Pacific Daylight Time
-    { "PST",  -8 * 60 },    // Pacific Standard Time
-    { "WET",  +0 * 60 },    // Western European Time
-    { "WEST", +1 * 60 },    // Western European Summer Time
-    { "CET",  +1 * 60 },    // Central European Time
-    { "CEST", +2 * 60 },    // Central European Summer Time
-    { "EET",  +2 * 60 },    // Eastern European Time
-    { "EEST", +3 * 60 },    // Eastern European Summer Time
-};
-
-static BOOL string_get_tzabbr(const uint8_t *sp, int *pp, int *offset) {
-    for (size_t i = 0; i < countof(js_tzabbr); i++) {
-        if (string_match(sp, pp, js_tzabbr[i].name)) {
-            *offset = js_tzabbr[i].offset;
-            return TRUE;
-        }
-    }
-    return FALSE;
-}
-
-/* parse toString, toUTCString and other formats */
-static BOOL js_date_parse_otherstring(const uint8_t *sp,
-                                      int fields[minimum_length(9)],
-                                      BOOL *is_local) {
-    int c, i, val, p = 0, p_start;
-    int num[3];
-    BOOL has_year = FALSE;
-    BOOL has_mon = FALSE;
-    BOOL has_time = FALSE;
-    int num_index = 0;
-
-    /* initialize fields to the beginning of 2001-01-01 */
-    fields[0] = 2001;
-    fields[1] = 1;
-    fields[2] = 1;
-    for (i = 3; i < 9; i++) {
-        fields[i] = 0;
-    }
-    *is_local = TRUE;
-
-    while (string_skip_spaces(sp, &p)) {
-        p_start = p;
-        if ((c = sp[p]) == '+' || c == '-') {
-            if (has_time && string_get_tzoffset(sp, &p, &fields[8], FALSE)) {
-                *is_local = FALSE;
-            } else {
-                p++;
-                if (string_get_digits(sp, &p, &val, 1, 9)) {
-                    if (c == '-') {
-                        if (val == 0)
-                            return FALSE;
-                        val = -val;
-                    }
-                    fields[0] = val;
-                    has_year = TRUE;
-                }
-            }
-        } else
-        if (string_get_digits(sp, &p, &val, 1, 9)) {
-            if (string_skip_char(sp, &p, ':')) {
-                /* time part */
-                fields[3] = val;
-                if (!string_get_digits(sp, &p, &fields[4], 1, 2))
-                    return FALSE;
-                if (string_skip_char(sp, &p, ':')) {
-                    if (!string_get_digits(sp, &p, &fields[5], 1, 2))
-                        return FALSE;
-                    string_get_milliseconds(sp, &p, &fields[6]);
-                }
-                has_time = TRUE;
-            } else {
-                if (p - p_start > 2) {
-                    fields[0] = val;
-                    has_year = TRUE;
-                } else
-                if (val < 1 || val > 31) {
-                    fields[0] = val + (val < 100) * 1900 + (val < 50) * 100;
-                    has_year = TRUE;
-                } else {
-                    if (num_index == 3)
-                        return FALSE;
-                    num[num_index++] = val;
-                }
-            }
-        } else
-        if (string_get_month(sp, &p, &fields[1])) {
-            has_mon = TRUE;
-            string_skip_until(sp, &p, "0123456789 -/(");
-        } else
-        if (has_time && string_match(sp, &p, "PM")) {
-            if (fields[3] < 12)
-                fields[3] += 12;
-            continue;
-        } else
-        if (has_time && string_match(sp, &p, "AM")) {
-            if (fields[3] == 12)
-                fields[3] -= 12;
-            continue;
-        } else
-        if (string_get_tzabbr(sp, &p, &fields[8])) {
-            *is_local = FALSE;
-            continue;
-        } else
-        if (c == '(') {  /* skip parenthesized phrase */
-            int level = 0;
-            while ((c = sp[p]) != '\0') {
-                p++;
-                level += (c == '(');
-                level -= (c == ')');
-                if (!level)
-                    break;
-            }
-            if (level > 0)
-                return FALSE;
-        } else
-        if (c == ')') {
-            return FALSE;
-        } else {
-            if (has_year + has_mon + has_time + num_index)
-                return FALSE;
-            /* skip a word */
-            string_skip_until(sp, &p, " -/(");
-        }
-        string_skip_separators(sp, &p);
-    }
-    if (num_index + has_year + has_mon > 3)
-        return FALSE;
-
-    switch (num_index) {
-    case 0:
-        if (!has_year)
-            return FALSE;
-        break;
-    case 1:
-        if (has_mon)
-            fields[2] = num[0];
-        else
-            fields[1] = num[0];
-        break;
-    case 2:
-        if (has_year) {
-            fields[1] = num[0];
-            fields[2] = num[1];
-        } else
-        if (has_mon) {
-            fields[0] = num[1] + (num[1] < 100) * 1900 + (num[1] < 50) * 100;
-            fields[2] = num[0];
-        } else {
-            fields[1] = num[0];
-            fields[2] = num[1];
-        }
-        break;
-    case 3:
-        fields[0] = num[2] + (num[2] < 100) * 1900 + (num[2] < 50) * 100;
-        fields[1] = num[0];
-        fields[2] = num[1];
-        break;
-    default:
-        return FALSE;
-    }
-    if (fields[1] < 1 || fields[2] < 1)
-        return FALSE;
-    fields[1] -= 1;
-    return TRUE;
+    return 0;
 }
 
 static JSValue js_Date_parse(JSContext *ctx, JSValueConst this_val,
                              int argc, JSValueConst *argv)
 {
+    // parse(s)
     JSValue s, rv;
-    int fields[9];
-    double fields1[9];
+    int64_t fields[] = { 0, 1, 1, 0, 0, 0, 0 };
+    double fields1[7];
+    int64_t tz, hh, mm;
     double d;
-    int i, c;
+    int p, i, c, sgn, l;
     JSString *sp;
-    uint8_t buf[128];
     BOOL is_local;
 
     rv = JS_NAN;
@@ -50316,33 +48269,145 @@
         return JS_EXCEPTION;
 
     sp = JS_VALUE_GET_STRING(s);
-    /* convert the string as a byte array */
-    for (i = 0; i < sp->len && i < (int)countof(buf) - 1; i++) {
-        c = string_get(sp, i);
-        if (c > 255)
-            c = (c == 0x2212) ? '-' : 'x';
-        buf[i] = c;
-    }
-    buf[i] = '\0';
-    if (js_date_parse_isostring(buf, fields, &is_local)
-    ||  js_date_parse_otherstring(buf, fields, &is_local)) {
-        static int const field_max[6] = { 0, 11, 31, 24, 59, 59 };
-        BOOL valid = TRUE;
-        /* check field maximum values */
-        for (i = 1; i < 6; i++) {
-            if (fields[i] > field_max[i])
-                valid = FALSE;
-        }
-        /* special case 24:00:00.000 */
-        if (fields[3] == 24 && (fields[4] | fields[5] | fields[6]))
-            valid = FALSE;
-        if (valid) {
-            for(i = 0; i < 7; i++)
-                fields1[i] = fields[i];
-            d = set_date_fields(fields1, is_local) - fields[8] * 60000;
-            rv = JS_NewFloat64(ctx, d);
-        }
-    }
+    p = 0;
+    if (p < sp->len && (((c = string_get(sp, p)) >= '0' && c <= '9') || c == '+' || c == '-')) {
+        /* ISO format */
+        /* year field can be negative */
+        if (string_get_signed_digits(sp, &p, &fields[0]))
+            goto done;
+
+        for (i = 1; i < 7; i++) {
+            if (p >= sp->len)
+                break;
+            switch(i) {
+            case 1:
+            case 2:
+                c = '-';
+                break;
+            case 3:
+                c = 'T';
+                break;
+            case 4:
+            case 5:
+                c = ':';
+                break;
+            case 6:
+                c = '.';
+                break;
+            }
+            if (string_get(sp, p) != c)
+                break;
+            p++;
+            if (i == 6) {
+                if (string_get_milliseconds(sp, &p, &fields[i]))
+                    goto done;
+            } else {
+                if (string_get_digits(sp, &p, &fields[i]))
+                    goto done;
+            }
+        }
+        /* no time: UTC by default */
+        is_local = (i > 3);
+        fields[1] -= 1;
+
+        /* parse the time zone offset if present: [+-]HH:mm or [+-]HHmm */
+        tz = 0;
+        if (p < sp->len) {
+            sgn = string_get(sp, p);
+            if (sgn == '+' || sgn == '-') {
+                p++;
+                l = sp->len - p;
+                if (l != 4 && l != 5)
+                    goto done;
+                if (string_get_fixed_width_digits(sp, &p, 2, &hh))
+                    goto done;
+                if (l == 5) {
+                    if (string_get(sp, p) != ':')
+                        goto done;
+                    p++;
+                }
+                if (string_get_fixed_width_digits(sp, &p, 2, &mm))
+                    goto done;
+                tz = hh * 60 + mm;
+                if (sgn == '-')
+                    tz = -tz;
+                is_local = FALSE;
+            } else if (sgn == 'Z') {
+                p++;
+                is_local = FALSE;
+            } else {
+                goto done;
+            }
+            /* error if extraneous characters */
+            if (p != sp->len)
+                goto done;
+        }
+    } else {
+        /* toString or toUTCString format */
+        /* skip the day of the week */
+        string_skip_non_spaces(sp, &p);
+        string_skip_spaces(sp, &p);
+        if (p >= sp->len)
+            goto done;
+        c = string_get(sp, p);
+        if (c >= '0' && c <= '9') {
+            /* day of month first */
+            if (string_get_digits(sp, &p, &fields[2]))
+                goto done;
+            if (string_get_month(sp, &p, &fields[1]))
+                goto done;
+        } else {
+            /* month first */
+            if (string_get_month(sp, &p, &fields[1]))
+                goto done;
+            string_skip_spaces(sp, &p);
+            if (string_get_digits(sp, &p, &fields[2]))
+                goto done;
+        }
+        /* year */
+        string_skip_spaces(sp, &p);
+        if (string_get_signed_digits(sp, &p, &fields[0]))
+            goto done;
+
+        /* hour, min, seconds */
+        string_skip_spaces(sp, &p);
+        for(i = 0; i < 3; i++) {
+            if (i == 1 || i == 2) {
+                if (p >= sp->len)
+                    goto done;
+                if (string_get(sp, p) != ':')
+                    goto done;
+                p++;
+            }
+            if (string_get_digits(sp, &p, &fields[3 + i]))
+                goto done;
+        }
+        // XXX: parse optional milliseconds?
+
+        /* parse the time zone offset if present: [+-]HHmm */
+        is_local = FALSE;
+        tz = 0;
+        for (tz = 0; p < sp->len; p++) {
+            sgn = string_get(sp, p);
+            if (sgn == '+' || sgn == '-') {
+                p++;
+                if (string_get_fixed_width_digits(sp, &p, 2, &hh))
+                    goto done;
+                if (string_get_fixed_width_digits(sp, &p, 2, &mm))
+                    goto done;
+                tz = hh * 60 + mm;
+                if (sgn == '-')
+                    tz = -tz;
+                break;
+            }
+        }
+    }
+    for(i = 0; i < 7; i++)
+        fields1[i] = fields[i];
+    d = set_date_fields(fields1, is_local) - tz * 60000;
+    rv = JS_NewFloat64(ctx, d);
+
+done:
     JS_FreeValue(ctx, s);
     return rv;
 }
@@ -50373,7 +48438,9 @@
     }
     switch (hint) {
     case JS_ATOM_number:
+#ifdef CONFIG_BIGNUM
     case JS_ATOM_integer:
+#endif
         hint_num = HINT_NUMBER;
         break;
     case JS_ATOM_string:
@@ -50397,7 +48464,6 @@
     if (isnan(v))
         return JS_NAN;
     else
-        /* assuming -8.64e15 <= v <= -8.64e15 */
         return JS_NewInt64(ctx, getTimezoneOffset((int64_t)trunc(v)));
 }
 
@@ -50536,15 +48602,6 @@
     JS_CFUNC_DEF("toJSON", 1, js_date_toJSON ),
 };
 
-JSValue JS_NewDate(JSContext *ctx, double epoch_ms)
-{
-    JSValue obj = js_create_from_ctor(ctx, JS_UNDEFINED, JS_CLASS_DATE);
-    if (JS_IsException(obj))
-        return JS_EXCEPTION;
-    JS_SetObjectData(ctx, obj, __JS_NewFloat64(ctx, time_clip(epoch_ms)));
-    return obj;
-}
-
 void JS_AddIntrinsicDate(JSContext *ctx)
 {
     JSValueConst obj;
@@ -50895,7 +48952,7 @@
             }
             if (!bf_is_finite(a)) {
                 JS_FreeValue(ctx, val);
-                val = JS_ThrowRangeError(ctx, "cannot convert NaN or Infinity to BigInt");
+                val = JS_ThrowRangeError(ctx, "cannot convert NaN or Infinity to bigint");
             } else {
                 JSValue val1 = JS_NewBigInt(ctx);
                 bf_t *r;
@@ -50913,7 +48970,7 @@
                     val = JS_ThrowOutOfMemory(ctx);
                 } else if (ret & BF_ST_INEXACT) {
                     JS_FreeValue(ctx, val1);
-                    val = JS_ThrowRangeError(ctx, "cannot convert to BigInt: not an integer");
+                    val = JS_ThrowRangeError(ctx, "cannot convert to bigint: not an integer");
                 } else {
                     val = JS_CompactBigInt(ctx, val1);
                 }
@@ -50925,7 +48982,7 @@
 #ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_DECIMAL:
         val = JS_ToStringFree(ctx, val);
-        if (JS_IsException(val))
+         if (JS_IsException(val))
             break;
         goto redo;
 #endif
@@ -50941,7 +48998,7 @@
     case JS_TAG_UNDEFINED:
     default:
         JS_FreeValue(ctx, val);
-        return JS_ThrowTypeError(ctx, "cannot convert to BigInt");
+        return JS_ThrowTypeError(ctx, "cannot convert to bigint");
     }
     return val;
 }
@@ -50967,7 +49024,7 @@
                 return JS_DupValue(ctx, p->u.object_data);
         }
     }
-    return JS_ThrowTypeError(ctx, "not a BigInt");
+    return JS_ThrowTypeError(ctx, "not a bigint");
 }
 
 static JSValue js_bigint_toString(JSContext *ctx, JSValueConst this_val,
@@ -52008,9 +50065,9 @@
     case FE_RNDMODE:
         return JS_NewInt32(ctx, fe->flags & BF_RND_MASK);
     case FE_SUBNORMAL:
-        return JS_NewBool(ctx, fe->flags & BF_FLAG_SUBNORMAL);
+        return JS_NewBool(ctx, (fe->flags & BF_FLAG_SUBNORMAL) != 0);
     default:
-        return JS_NewBool(ctx, fe->status & magic);
+        return JS_NewBool(ctx, (fe->status & magic) != 0);
     }
 }
 
@@ -52733,13 +50790,11 @@
     JS_NewGlobalCConstructor2(ctx, obj1,
                               "Error", ctx->class_proto[JS_CLASS_ERROR]);
 
-    /* Used to squelch a -Wcast-function-type warning. */
-    JSCFunctionType ft = { .generic_magic = js_error_constructor };
     for(i = 0; i < JS_NATIVE_ERROR_COUNT; i++) {
         JSValue func_obj;
         int n_args;
         n_args = 1 + (i == JS_AGGREGATE_ERROR);
-        func_obj = JS_NewCFunction3(ctx, ft.generic,
+        func_obj = JS_NewCFunction3(ctx, (JSCFunction *)js_error_constructor,
                                     native_error_name[i], n_args,
                                     JS_CFUNC_constructor_or_func_magic, i, obj1);
         JS_NewGlobalCConstructor2(ctx, func_obj, native_error_name[i],
@@ -52766,22 +50821,8 @@
     /* XXX: create auto_initializer */
     {
         /* initialize Array.prototype[Symbol.unscopables] */
-        static const char unscopables[] =
-            "copyWithin" "\0"
-            "entries" "\0"
-            "fill" "\0"
-            "find" "\0"
-            "findIndex" "\0"
-            "findLast" "\0"
-            "findLastIndex" "\0"
-            "flat" "\0"
-            "flatMap" "\0"
-            "includes" "\0"
-            "keys" "\0"
-            "toReversed" "\0"
-            "toSorted" "\0"
-            "toSpliced" "\0"
-            "values" "\0";
+        char const unscopables[] = "copyWithin" "\0" "entries" "\0" "fill" "\0" "find" "\0"
+            "findIndex" "\0" "flat" "\0" "flatMap" "\0" "includes" "\0" "keys" "\0" "values" "\0";
         const char *p = unscopables;
         obj1 = JS_NewObjectProto(ctx, JS_NULL);
         for(p = unscopables; *p; p += strlen(p) + 1) {
@@ -53035,26 +51076,11 @@
 {
     JSObject *p = JS_VALUE_GET_OBJ(val);
     JSArrayBuffer *abuf = p->u.array_buffer;
-    struct list_head *el, *el1;
-
     if (abuf) {
         /* The ArrayBuffer finalizer may be called before the typed
            array finalizers using it, so abuf->array_list is not
            necessarily empty. */
-        list_for_each_safe(el, el1, &abuf->array_list) {
-            JSTypedArray *ta;
-            JSObject *p1;
-
-            ta = list_entry(el, JSTypedArray, link);
-            ta->link.prev = NULL;
-            ta->link.next = NULL;
-            p1 = ta->obj;
-            /* Note: the typed array length and offset fields are not modified */
-            if (p1->class_id != JS_CLASS_DATAVIEW) {
-                p1->u.array.count = 0;
-                p1->u.array.u.ptr = NULL;
-            }
-        }
+        // assert(list_empty(&abuf->array_list));
         if (abuf->shared && rt->sab_funcs.sab_free) {
             rt->sab_funcs.sab_free(rt->sab_funcs.sab_opaque, abuf->data);
         } else {
@@ -53504,44 +51530,7 @@
         idx = len + idx;
     if (idx < 0 || idx >= len)
         return JS_UNDEFINED;
-    return JS_GetPropertyInt64(ctx, this_val, idx);
-}
-
-static JSValue js_typed_array_with(JSContext *ctx, JSValueConst this_val,
-                                   int argc, JSValueConst *argv)
-{
-    JSValue arr, val;
-    JSObject *p;
-    int64_t idx, len;
-
-    p = get_typed_array(ctx, this_val, /*is_dataview*/0);
-    if (!p)
-        return JS_EXCEPTION;
-
-    if (JS_ToInt64Sat(ctx, &idx, argv[0]))
-        return JS_EXCEPTION;
-
-    len = p->u.array.count;
-    if (idx < 0)
-        idx = len + idx;
-    if (idx < 0 || idx >= len)
-        return JS_ThrowRangeError(ctx, "invalid array index");
-
-    val = JS_ToPrimitive(ctx, argv[1], HINT_NUMBER);
-    if (JS_IsException(val))
-        return JS_EXCEPTION;
-
-    arr = js_typed_array_constructor_ta(ctx, JS_UNDEFINED, this_val,
-                                        p->class_id);
-    if (JS_IsException(arr)) {
-        JS_FreeValue(ctx, val);
-        return JS_EXCEPTION;
-    }
-    if (JS_SetPropertyInt64(ctx, arr, idx, val) < 0) {
-        JS_FreeValue(ctx, arr);
-        return JS_EXCEPTION;
-    }
-    return arr;
+    return JS_GetPropertyUint32(ctx, this_val, idx);
 }
 
 static JSValue js_typed_array_set(JSContext *ctx,
@@ -53898,13 +51887,12 @@
 }
 
 static JSValue js_typed_array_find(JSContext *ctx, JSValueConst this_val,
-                                   int argc, JSValueConst *argv, int mode)
+                                   int argc, JSValueConst *argv, int findIndex)
 {
     JSValueConst func, this_arg;
     JSValueConst args[3];
     JSValue val, index_val, res;
-    int len, k, end;
-    int dir;
+    int len, k;
 
     val = JS_UNDEFINED;
     len = js_typed_array_get_length_internal(ctx, this_val);
@@ -53919,16 +51907,7 @@
     if (argc > 1)
         this_arg = argv[1];
 
-    k = 0;
-    dir = 1;
-    end = len;
-    if (mode == ArrayFindLast || mode == ArrayFindLastIndex) {
-        k = len - 1;
-        dir = -1;
-        end = -1;
-    }
-
-    for(; k != end; k += dir) {
+    for(k = 0; k < len; k++) {
         index_val = JS_NewInt32(ctx, k);
         val = JS_GetPropertyValue(ctx, this_val, index_val);
         if (JS_IsException(val))
@@ -53940,7 +51919,7 @@
         if (JS_IsException(res))
             goto exception;
         if (JS_ToBoolFree(ctx, res)) {
-            if (mode == ArrayFindIndex || mode == ArrayFindLastIndex) {
+            if (findIndex) {
                 JS_FreeValue(ctx, val);
                 return index_val;
             } else {
@@ -53949,7 +51928,7 @@
         }
         JS_FreeValue(ctx, val);
     }
-    if (mode == ArrayFindIndex || mode == ArrayFindLastIndex)
+    if (findIndex)
         return JS_NewInt32(ctx, -1);
     else
         return JS_UNDEFINED;
@@ -54031,10 +52010,8 @@
     } else
     if (tag == JS_TAG_FLOAT64) {
         d = JS_VALUE_GET_FLOAT64(argv[0]);
-        if (d >= INT64_MIN && d < 0x1p63) {
-            v64 = d;
-            is_int = (v64 == d);
-        }
+        v64 = d;
+        is_int = (v64 == d);
     } else if (tag == JS_TAG_BIG_INT) {
         JSBigFloat *p1 = JS_VALUE_GET_PTR(argv[0]);
 
@@ -54323,24 +52300,6 @@
     return JS_DupValue(ctx, this_val);
 }
 
-static JSValue js_typed_array_toReversed(JSContext *ctx, JSValueConst this_val,
-                                         int argc, JSValueConst *argv)
-{
-    JSValue arr, ret;
-    JSObject *p;
-
-    p = get_typed_array(ctx, this_val, /*is_dataview*/0);
-    if (!p)
-        return JS_EXCEPTION;
-    arr = js_typed_array_constructor_ta(ctx, JS_UNDEFINED, this_val,
-                                        p->class_id);
-    if (JS_IsException(arr))
-        return JS_EXCEPTION;
-    ret = js_typed_array_reverse(ctx, arr, argc, argv);
-    JS_FreeValue(ctx, arr);
-    return ret;
-}
-
 static JSValue js_typed_array_slice(JSContext *ctx, JSValueConst this_val,
                                     int argc, JSValueConst *argv)
 {
@@ -54549,7 +52508,7 @@
 
 struct TA_sort_context {
     JSContext *ctx;
-    int exception; /* 1 = exception, 2 = detached typed array */
+    int exception;
     JSValueConst arr;
     JSValueConst cmp;
     JSValue (*getfun)(JSContext *ctx, const void *a);
@@ -54567,8 +52526,6 @@
 
     cmp = 0;
     if (!psc->exception) {
-        /* Note: the typed array can be detached without causing an
-           error */
         a_idx = *(uint32_t *)a;
         b_idx = *(uint32_t *)b;
         argv[0] = psc->getfun(ctx, psc->array_ptr +
@@ -54596,13 +52553,12 @@
             /* make sort stable: compare array offsets */
             cmp = (a_idx > b_idx) - (a_idx < b_idx);
         }
-        if (unlikely(typed_array_is_detached(ctx,
-                                             JS_VALUE_GET_PTR(psc->arr)))) {
-            psc->exception = 2;
+        if (validate_typed_array(ctx, psc->arr) < 0) {
+            psc->exception = 1;
         }
     done:
-        JS_FreeValue(ctx, (JSValue)argv[0]);
-        JS_FreeValue(ctx, (JSValue)argv[1]);
+        JS_FreeValue(ctx, argv[0]);
+        JS_FreeValue(ctx, argv[1]);
     }
     return cmp;
 }
@@ -54622,11 +52578,11 @@
     tsc.arr = this_val;
     tsc.cmp = argv[0];
 
-    if (!JS_IsUndefined(tsc.cmp) && check_function(ctx, tsc.cmp))
-        return JS_EXCEPTION;
     len = js_typed_array_get_length_internal(ctx, this_val);
     if (len < 0)
         return JS_EXCEPTION;
+    if (!JS_IsUndefined(tsc.cmp) && check_function(ctx, tsc.cmp))
+        return JS_EXCEPTION;
 
     if (len > 1) {
         p = JS_VALUE_GET_OBJ(this_val);
@@ -54692,48 +52648,44 @@
             tsc.elt_size = elt_size;
             rqsort(array_idx, len, sizeof(array_idx[0]),
                    js_TA_cmp_generic, &tsc);
-            if (tsc.exception) {
-                if (tsc.exception == 1)
-                    goto fail;
-                /* detached typed array during the sort: no error */
-            } else {
-                array_tmp = js_malloc(ctx, len * elt_size);
-                if (!array_tmp) {
-                fail:
-                    js_free(ctx, array_idx);
-                    return JS_EXCEPTION;
-                }
-                memcpy(array_tmp, array_ptr, len * elt_size);
-                switch(elt_size) {
-                case 1:
-                    for(i = 0; i < len; i++) {
-                        j = array_idx[i];
-                        ((uint8_t *)array_ptr)[i] = ((uint8_t *)array_tmp)[j];
-                    }
-                    break;
-                case 2:
-                    for(i = 0; i < len; i++) {
-                        j = array_idx[i];
-                        ((uint16_t *)array_ptr)[i] = ((uint16_t *)array_tmp)[j];
-                    }
-                    break;
-                case 4:
-                    for(i = 0; i < len; i++) {
-                        j = array_idx[i];
-                        ((uint32_t *)array_ptr)[i] = ((uint32_t *)array_tmp)[j];
-                    }
-                    break;
-                case 8:
-                    for(i = 0; i < len; i++) {
-                        j = array_idx[i];
-                        ((uint64_t *)array_ptr)[i] = ((uint64_t *)array_tmp)[j];
-                    }
-                    break;
-                default:
-                    abort();
-                }
-                js_free(ctx, array_tmp);
-            }
+            if (tsc.exception)
+                goto fail;
+            array_tmp = js_malloc(ctx, len * elt_size);
+            if (!array_tmp) {
+            fail:
+                js_free(ctx, array_idx);
+                return JS_EXCEPTION;
+            }
+            memcpy(array_tmp, array_ptr, len * elt_size);
+            switch(elt_size) {
+            case 1:
+                for(i = 0; i < len; i++) {
+                    j = array_idx[i];
+                    ((uint8_t *)array_ptr)[i] = ((uint8_t *)array_tmp)[j];
+                }
+                break;
+            case 2:
+                for(i = 0; i < len; i++) {
+                    j = array_idx[i];
+                    ((uint16_t *)array_ptr)[i] = ((uint16_t *)array_tmp)[j];
+                }
+                break;
+            case 4:
+                for(i = 0; i < len; i++) {
+                    j = array_idx[i];
+                    ((uint32_t *)array_ptr)[i] = ((uint32_t *)array_tmp)[j];
+                }
+                break;
+            case 8:
+                for(i = 0; i < len; i++) {
+                    j = array_idx[i];
+                    ((uint64_t *)array_ptr)[i] = ((uint64_t *)array_tmp)[j];
+                }
+                break;
+            default:
+                abort();
+            }
+            js_free(ctx, array_tmp);
             js_free(ctx, array_idx);
         } else {
             rqsort(array_ptr, len, elt_size, cmpfun, &tsc);
@@ -54744,24 +52696,6 @@
     return JS_DupValue(ctx, this_val);
 }
 
-static JSValue js_typed_array_toSorted(JSContext *ctx, JSValueConst this_val,
-                                       int argc, JSValueConst *argv)
-{
-    JSValue arr, ret;
-    JSObject *p;
-
-    p = get_typed_array(ctx, this_val, /*is_dataview*/0);
-    if (!p)
-        return JS_EXCEPTION;
-    arr = js_typed_array_constructor_ta(ctx, JS_UNDEFINED, this_val,
-                                        p->class_id);
-    if (JS_IsException(arr))
-        return JS_EXCEPTION;
-    ret = js_typed_array_sort(ctx, arr, argc, argv);
-    JS_FreeValue(ctx, arr);
-    return ret;
-}
-
 static const JSCFunctionListEntry js_typed_array_base_funcs[] = {
     JS_CFUNC_DEF("from", 1, js_typed_array_from ),
     JS_CFUNC_DEF("of", 0, js_typed_array_of ),
@@ -54774,7 +52708,6 @@
 static const JSCFunctionListEntry js_typed_array_base_proto_funcs[] = {
     JS_CGETSET_DEF("length", js_typed_array_get_length, NULL ),
     JS_CFUNC_DEF("at", 1, js_typed_array_at ),
-    JS_CFUNC_DEF("with", 2, js_typed_array_with ),
     JS_CGETSET_MAGIC_DEF("buffer", js_typed_array_get_buffer, NULL, 0 ),
     JS_CGETSET_MAGIC_DEF("byteLength", js_typed_array_get_byteLength, NULL, 0 ),
     JS_CGETSET_MAGIC_DEF("byteOffset", js_typed_array_get_byteOffset, NULL, 0 ),
@@ -54793,16 +52726,12 @@
     JS_CFUNC_MAGIC_DEF("reduce", 1, js_array_reduce, special_reduce | special_TA ),
     JS_CFUNC_MAGIC_DEF("reduceRight", 1, js_array_reduce, special_reduceRight | special_TA ),
     JS_CFUNC_DEF("fill", 1, js_typed_array_fill ),
-    JS_CFUNC_MAGIC_DEF("find", 1, js_typed_array_find, ArrayFind ),
-    JS_CFUNC_MAGIC_DEF("findIndex", 1, js_typed_array_find, ArrayFindIndex ),
-    JS_CFUNC_MAGIC_DEF("findLast", 1, js_typed_array_find, ArrayFindLast ),
-    JS_CFUNC_MAGIC_DEF("findLastIndex", 1, js_typed_array_find, ArrayFindLastIndex ),
+    JS_CFUNC_MAGIC_DEF("find", 1, js_typed_array_find, 0 ),
+    JS_CFUNC_MAGIC_DEF("findIndex", 1, js_typed_array_find, 1 ),
     JS_CFUNC_DEF("reverse", 0, js_typed_array_reverse ),
-    JS_CFUNC_DEF("toReversed", 0, js_typed_array_toReversed ),
     JS_CFUNC_DEF("slice", 2, js_typed_array_slice ),
     JS_CFUNC_DEF("subarray", 2, js_typed_array_subarray ),
     JS_CFUNC_DEF("sort", 1, js_typed_array_sort ),
-    JS_CFUNC_DEF("toSorted", 1, js_typed_array_toSorted ),
     JS_CFUNC_MAGIC_DEF("join", 1, js_typed_array_join, 0 ),
     JS_CFUNC_MAGIC_DEF("toLocaleString", 0, js_typed_array_join, 1 ),
     JS_CFUNC_MAGIC_DEF("indexOf", 1, js_typed_array_indexOf, special_indexOf ),
@@ -54949,7 +52878,7 @@
 {
     JSObject *p, *src_buffer;
     JSTypedArray *ta;
-    JSValue obj, buffer;
+    JSValue ctor, obj, buffer;
     uint32_t len, i;
     int size_log2;
     JSArrayBuffer *src_abuf, *abuf;
@@ -54966,9 +52895,19 @@
     len = p->u.array.count;
     src_buffer = ta->buffer;
     src_abuf = src_buffer->u.array_buffer;
+    if (!src_abuf->shared) {
+        ctor = JS_SpeciesConstructor(ctx, JS_MKPTR(JS_TAG_OBJECT, src_buffer),
+                                     JS_UNDEFINED);
+        if (JS_IsException(ctor))
+            goto fail;
+    } else {
+        /* force ArrayBuffer default constructor */
+        ctor = JS_UNDEFINED;
+    }
     size_log2 = typed_array_size_log2(classid);
-    buffer = js_array_buffer_constructor1(ctx, JS_UNDEFINED,
+    buffer = js_array_buffer_constructor1(ctx, ctor,
                                           (uint64_t)len << size_log2);
+    JS_FreeValue(ctx, ctor);
     if (JS_IsException(buffer))
         goto fail;
     /* necessary because it could have been detached */
@@ -55074,7 +53013,7 @@
     if (ta) {
         /* during the GC the finalizers are called in an arbitrary
            order so the ArrayBuffer finalizer may have been called */
-        if (ta->link.next) {
+        if (JS_IsLiveObject(rt, JS_MKPTR(JS_TAG_OBJECT, ta->buffer))) {
             list_del(&ta->link);
         }
         JS_FreeValueRT(rt, JS_MKPTR(JS_TAG_OBJECT, ta->buffer));
@@ -55157,8 +53096,7 @@
 {
     JSTypedArray *ta;
     JSArrayBuffer *abuf;
-    BOOL littleEndian, is_swap;
-    int size;
+    int is_swap, size;
     uint8_t *ptr;
     uint32_t v;
     uint64_t pos;
@@ -55169,8 +53107,12 @@
     size = 1 << typed_array_size_log2(class_id);
     if (JS_ToIndex(ctx, &pos, argv[0]))
         return JS_EXCEPTION;
-    littleEndian = argc > 1 && JS_ToBool(ctx, argv[1]);
-    is_swap = littleEndian ^ !is_be();
+    is_swap = FALSE;
+    if (argc > 1)
+        is_swap = JS_ToBool(ctx, argv[1]);
+#ifndef WORDS_BIGENDIAN
+    is_swap ^= 1;
+#endif
     abuf = ta->buffer->u.array_buffer;
     if (abuf->detached)
         return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
@@ -55255,8 +53197,7 @@
 {
     JSTypedArray *ta;
     JSArrayBuffer *abuf;
-    BOOL littleEndian, is_swap;
-    int size;
+    int is_swap, size;
     uint8_t *ptr;
     uint64_t v64;
     uint32_t v;
@@ -55295,8 +53236,12 @@
             v64 = u.u64;
         }
     }
-    littleEndian = argc > 2 && JS_ToBool(ctx, argv[2]);
-    is_swap = littleEndian ^ !is_be();
+    is_swap = FALSE;
+    if (argc > 2)
+        is_swap = JS_ToBool(ctx, argv[2]);
+#ifndef WORDS_BIGENDIAN
+    is_swap ^= 1;
+#endif
     abuf = ta->buffer->u.array_buffer;
     if (abuf->detached)
         return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
@@ -55683,8 +53628,7 @@
     }
     if (JS_ToFloat64(ctx, &d, argv[3]))
         return JS_EXCEPTION;
-    /* must use INT64_MAX + 1 because INT64_MAX cannot be exactly represented as a double */
-    if (isnan(d) || d >= 0x1p63)
+    if (isnan(d) || d > INT64_MAX)
         timeout = INT64_MAX;
     else if (d < 0)
         timeout = 0;
@@ -55862,8 +53806,6 @@
                                countof(js_typed_array_base_funcs));
     JS_SetConstructor(ctx, typed_array_base_func, typed_array_base_proto);
 
-    /* Used to squelch a -Wcast-function-type warning. */
-    JSCFunctionType ft = { .generic_magic = js_typed_array_constructor };
     for(i = JS_CLASS_UINT8C_ARRAY; i < JS_CLASS_UINT8C_ARRAY + JS_TYPED_ARRAY_COUNT; i++) {
         JSValue func_obj;
         char buf[ATOM_GET_STR_BUF_SIZE];
@@ -55876,7 +53818,7 @@
                                   0);
         name = JS_AtomGetStr(ctx, buf, sizeof(buf),
                              JS_ATOM_Uint8ClampedArray + i - JS_CLASS_UINT8C_ARRAY);
-        func_obj = JS_NewCFunction3(ctx, ft.generic,
+        func_obj = JS_NewCFunction3(ctx, (JSCFunction *)js_typed_array_constructor,
                                     name, 3, JS_CFUNC_constructor_magic, i,
                                     typed_array_base_func);
         JS_NewGlobalCConstructor2(ctx, func_obj, name, ctx->class_proto[i]);
Index: libxml2-src/libxml2/include/libxml/xmlerror.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libxml2-src/libxml2/include/libxml/xmlerror.h b/libxml2-src/libxml2/include/libxml/xmlerror.h
--- a/libxml2-src/libxml2/include/libxml/xmlerror.h	(revision 505e2e872e767405be565aa9d47ae9d6d5677f79)
+++ b/libxml2-src/libxml2/include/libxml/xmlerror.h	(date 1714440647086)
@@ -928,7 +928,7 @@
 /*
  * Extended error information routines
  */
-XMLPUBFUN const xmlError *
+XMLPUBFUN xmlError *
     xmlGetLastError		(void);
 XMLPUBFUN void
     xmlResetLastError		(void);
Index: inchi-src/inchi/INCHI_API/libinchi/src/ichilnct.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ichilnct.c b/inchi-src/inchi/INCHI_API/libinchi/src/ichilnct.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ichilnct.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ichilnct.c	(date 1714440647086)
@@ -42,16 +42,16 @@
 
 /* for use in the InChI library */
 
-#include "../../../INCHI_BASE/src/mode.h"
+#include "mode.h"
 
-#include "../../../INCHI_BASE/src/incomdef.h"
-#include "../../../INCHI_BASE/src/ichidrp.h"
-#include "../../../INCHI_BASE/src/inpdef.h"
-#include "../../../INCHI_BASE/src/util.h"
-#include "../../../INCHI_BASE/src/ichierr.h"
-#include "../../../INCHI_BASE/src/ichicomp.h"
-#include "../../../INCHI_BASE/src/ichi_io.h"
-#include "../../../INCHI_BASE/src/inchi_api.h"
+#include "incomdef.h"
+#include "ichidrp.h"
+#include "inpdef.h"
+#include "util.h"
+#include "ichierr.h"
+#include "ichicomp.h"
+#include "ichi_io.h"
+#include "inchi_api.h"
 
 #include "inchi_dll_b.h"
 
@@ -63,7 +63,7 @@
                        int *err, char *pStrErr );
 
 /* This contains executable code. Included in lReadAux.c, e_ReadINCH.c, ReadINCH.c,  */
-#include "../../../INCHI_BASE/src/readinch.h"
+#include "readinch.h"
 
 
 
Index: quickjs-src/quickjs/libunicode-table.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/libunicode-table.h b/quickjs-src/quickjs/src/libunicode-table.h
rename from quickjs-src/quickjs/libunicode-table.h
rename to quickjs-src/quickjs/src/libunicode-table.h
--- a/quickjs-src/quickjs/libunicode-table.h	(revision 3b45d155c77bbdfe9177b1e03db830d2aff0b2a8)
+++ b/quickjs-src/quickjs/src/libunicode-table.h	(date 1714440647086)
@@ -3779,70 +3779,72 @@
     0x8b, 0x80, 0x8e, 0x80, 0xae, 0x80,
 };
 
-static const uint8_t unicode_prop_Changes_When_Casefolded1_table[29] = {
-    0x41, 0xef, 0x80, 0x41, 0x9e, 0x80, 0x9e, 0x80,
-    0x5a, 0xe4, 0x83, 0x40, 0xb5, 0x00, 0x00, 0x00,
-    0x80, 0xde, 0x06, 0x06, 0x80, 0x8a, 0x09, 0x81,
-    0x89, 0x10, 0x81, 0x8d, 0x80,
+static const uint8_t unicode_prop_Changes_When_Casefolded1_table[33] = {
+    0x40, 0xde, 0x80, 0xcf, 0x80, 0x97, 0x80, 0x44,
+    0x3c, 0x80, 0x59, 0x11, 0x80, 0x40, 0xe4, 0x3f,
+    0x3f, 0x87, 0x89, 0x11, 0x05, 0x02, 0x11, 0x80,
+    0xa9, 0x11, 0x80, 0x60, 0xdb, 0x07, 0x86, 0x8b,
+    0x84,
 };
 
-static const uint8_t unicode_prop_Changes_When_NFKC_Casefolded1_table[447] = {
+static const uint8_t unicode_prop_Changes_When_NFKC_Casefolded1_table[451] = {
     0x40, 0x9f, 0x06, 0x00, 0x01, 0x00, 0x01, 0x12,
-    0x10, 0x82, 0xf3, 0x80, 0x8b, 0x80, 0x40, 0x84,
-    0x01, 0x01, 0x80, 0xa2, 0x01, 0x80, 0x40, 0xbb,
-    0x88, 0x9e, 0x29, 0x84, 0xda, 0x08, 0x81, 0x89,
-    0x80, 0xa3, 0x04, 0x02, 0x04, 0x08, 0x07, 0x80,
-    0x9e, 0x80, 0xa0, 0x82, 0x9c, 0x80, 0x42, 0x28,
-    0x80, 0xd7, 0x83, 0x42, 0xde, 0x87, 0xfb, 0x08,
-    0x80, 0xd2, 0x01, 0x80, 0xa1, 0x11, 0x80, 0x40,
-    0xfc, 0x81, 0x42, 0xd4, 0x80, 0xfe, 0x80, 0xa7,
-    0x81, 0xad, 0x80, 0xb5, 0x80, 0x88, 0x03, 0x03,
-    0x03, 0x80, 0x8b, 0x80, 0x88, 0x00, 0x26, 0x80,
-    0x90, 0x80, 0x88, 0x03, 0x03, 0x03, 0x80, 0x8b,
-    0x80, 0x41, 0x41, 0x80, 0xe1, 0x81, 0x46, 0x52,
-    0x81, 0xd4, 0x84, 0x45, 0x1b, 0x10, 0x8a, 0x80,
-    0x91, 0x80, 0x9b, 0x8c, 0x80, 0xa1, 0xa4, 0x40,
-    0xd5, 0x83, 0x40, 0xb5, 0x00, 0x00, 0x00, 0x80,
-    0x99, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
-    0xb7, 0x05, 0x00, 0x13, 0x05, 0x11, 0x02, 0x0c,
-    0x11, 0x00, 0x00, 0x0c, 0x15, 0x05, 0x08, 0x8f,
-    0x00, 0x20, 0x8b, 0x12, 0x2a, 0x08, 0x0b, 0x00,
-    0x07, 0x82, 0x8c, 0x06, 0x92, 0x81, 0x9a, 0x80,
-    0x8c, 0x8a, 0x80, 0xd6, 0x18, 0x10, 0x8a, 0x01,
-    0x0c, 0x0a, 0x00, 0x10, 0x11, 0x02, 0x06, 0x05,
-    0x1c, 0x85, 0x8f, 0x8f, 0x8f, 0x88, 0x80, 0x40,
-    0xa1, 0x08, 0x81, 0x40, 0xf7, 0x81, 0x41, 0x34,
-    0xd5, 0x99, 0x9a, 0x45, 0x20, 0x80, 0xe6, 0x82,
-    0xe4, 0x80, 0x41, 0x9e, 0x81, 0x40, 0xf0, 0x80,
-    0x41, 0x2e, 0x80, 0xd2, 0x80, 0x8b, 0x40, 0xd5,
-    0xa9, 0x80, 0xb4, 0x00, 0x82, 0xdf, 0x09, 0x80,
-    0xde, 0x80, 0xb0, 0xdd, 0x82, 0x8d, 0xdf, 0x9e,
-    0x80, 0xa7, 0x87, 0xae, 0x80, 0x41, 0x7f, 0x60,
-    0x72, 0x9b, 0x81, 0x40, 0xd1, 0x80, 0x40, 0x80,
-    0x12, 0x81, 0x43, 0x61, 0x83, 0x88, 0x80, 0x60,
-    0x4d, 0x95, 0x41, 0x0d, 0x08, 0x00, 0x81, 0x89,
-    0x00, 0x00, 0x09, 0x82, 0xc3, 0x81, 0xe9, 0xc2,
-    0x00, 0x97, 0x04, 0x00, 0x01, 0x01, 0x80, 0xeb,
-    0xa0, 0x41, 0x6a, 0x91, 0xbf, 0x81, 0xb5, 0xa7,
-    0x8c, 0x82, 0x99, 0x95, 0x94, 0x81, 0x8b, 0x80,
-    0x92, 0x03, 0x1a, 0x00, 0x80, 0x40, 0x86, 0x08,
-    0x80, 0x9f, 0x99, 0x40, 0x83, 0x15, 0x0d, 0x0d,
-    0x0a, 0x16, 0x06, 0x80, 0x88, 0x47, 0x87, 0x20,
-    0xa9, 0x80, 0x88, 0x60, 0xb4, 0xe4, 0x83, 0x54,
-    0xb9, 0x86, 0x8d, 0x87, 0xbf, 0x85, 0x42, 0x3e,
-    0xd4, 0x80, 0xc6, 0x01, 0x08, 0x09, 0x0b, 0x80,
-    0x8b, 0x00, 0x06, 0x80, 0xc0, 0x03, 0x0f, 0x06,
-    0x80, 0x9b, 0x03, 0x04, 0x00, 0x16, 0x80, 0x41,
-    0x53, 0x81, 0x41, 0x23, 0x81, 0xb1, 0x48, 0x2f,
-    0xbd, 0x4d, 0x91, 0x18, 0x9a, 0x01, 0x00, 0x08,
-    0x80, 0x89, 0x03, 0x00, 0x00, 0x28, 0x18, 0x00,
-    0x00, 0x02, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00,
-    0x00, 0x01, 0x00, 0x0b, 0x06, 0x03, 0x03, 0x00,
-    0x80, 0x89, 0x80, 0x90, 0x22, 0x04, 0x80, 0x90,
-    0x42, 0x43, 0x8a, 0x84, 0x9e, 0x80, 0x9f, 0x99,
-    0x82, 0xa2, 0x80, 0xee, 0x82, 0x8c, 0xab, 0x83,
-    0x88, 0x31, 0x49, 0x9d, 0x89, 0x60, 0xfc, 0x05,
-    0x42, 0x1d, 0x6b, 0x05, 0xe1, 0x4f, 0xff,
+    0x10, 0x82, 0x9f, 0x80, 0xcf, 0x01, 0x80, 0x8b,
+    0x07, 0x80, 0xfb, 0x01, 0x01, 0x80, 0xa5, 0x80,
+    0x40, 0xbb, 0x88, 0x9e, 0x29, 0x84, 0xda, 0x08,
+    0x81, 0x89, 0x80, 0xa3, 0x04, 0x02, 0x04, 0x08,
+    0x80, 0xc9, 0x82, 0x9c, 0x80, 0x41, 0x93, 0x80,
+    0x40, 0x93, 0x80, 0xd7, 0x83, 0x42, 0xde, 0x87,
+    0xfb, 0x08, 0x80, 0xd2, 0x01, 0x80, 0xa1, 0x11,
+    0x80, 0x40, 0xfc, 0x81, 0x42, 0xd4, 0x80, 0xfe,
+    0x80, 0xa7, 0x81, 0xad, 0x80, 0xb5, 0x80, 0x88,
+    0x03, 0x03, 0x03, 0x80, 0x8b, 0x80, 0x88, 0x00,
+    0x26, 0x80, 0x90, 0x80, 0x88, 0x03, 0x03, 0x03,
+    0x80, 0x8b, 0x80, 0x41, 0x41, 0x80, 0xe1, 0x81,
+    0x46, 0x52, 0x81, 0xd4, 0x84, 0x45, 0x1b, 0x10,
+    0x8a, 0x80, 0x91, 0x80, 0x9b, 0x8c, 0x80, 0xa1,
+    0xa4, 0x40, 0xd9, 0x80, 0x40, 0xd5, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x3f, 0x87,
+    0x89, 0x11, 0x04, 0x00, 0x29, 0x04, 0x12, 0x80,
+    0x88, 0x12, 0x80, 0x88, 0x11, 0x11, 0x04, 0x08,
+    0x8f, 0x00, 0x20, 0x8b, 0x12, 0x2a, 0x08, 0x0b,
+    0x00, 0x07, 0x82, 0x8c, 0x06, 0x92, 0x81, 0x9a,
+    0x80, 0x8c, 0x8a, 0x80, 0xd6, 0x18, 0x10, 0x8a,
+    0x01, 0x0c, 0x0a, 0x00, 0x10, 0x11, 0x02, 0x06,
+    0x05, 0x1c, 0x85, 0x8f, 0x8f, 0x8f, 0x88, 0x80,
+    0x40, 0xa1, 0x08, 0x81, 0x40, 0xf7, 0x81, 0x41,
+    0x34, 0xd5, 0x99, 0x9a, 0x45, 0x20, 0x80, 0xe6,
+    0x82, 0xe4, 0x80, 0x41, 0x9e, 0x81, 0x40, 0xf0,
+    0x80, 0x41, 0x2e, 0x80, 0xd2, 0x80, 0x8b, 0x40,
+    0xd5, 0xa9, 0x80, 0xb4, 0x00, 0x82, 0xdf, 0x09,
+    0x80, 0xde, 0x80, 0xb0, 0xdd, 0x82, 0x8d, 0xdf,
+    0x9e, 0x80, 0xa7, 0x87, 0xae, 0x80, 0x41, 0x7f,
+    0x60, 0x72, 0x9b, 0x81, 0x40, 0xd1, 0x80, 0x40,
+    0x80, 0x12, 0x81, 0x43, 0x61, 0x83, 0x88, 0x80,
+    0x60, 0x4d, 0x95, 0x41, 0x0d, 0x08, 0x00, 0x81,
+    0x89, 0x00, 0x00, 0x09, 0x82, 0xc3, 0x81, 0xe9,
+    0xa5, 0x86, 0x8b, 0x24, 0x00, 0x97, 0x04, 0x00,
+    0x01, 0x01, 0x80, 0xeb, 0xa0, 0x41, 0x6a, 0x91,
+    0xbf, 0x81, 0xb5, 0xa7, 0x8c, 0x82, 0x99, 0x95,
+    0x94, 0x81, 0x8b, 0x80, 0x92, 0x03, 0x1a, 0x00,
+    0x80, 0x40, 0x86, 0x08, 0x80, 0x9f, 0x99, 0x40,
+    0x83, 0x15, 0x0d, 0x0d, 0x0a, 0x16, 0x06, 0x80,
+    0x88, 0x47, 0x87, 0x20, 0xa9, 0x80, 0x88, 0x60,
+    0xb4, 0xe4, 0x83, 0x54, 0xb9, 0x86, 0x8d, 0x87,
+    0xbf, 0x85, 0x42, 0x3e, 0xd4, 0x80, 0xc6, 0x01,
+    0x08, 0x09, 0x0b, 0x80, 0x8b, 0x00, 0x06, 0x80,
+    0xc0, 0x03, 0x0f, 0x06, 0x80, 0x9b, 0x03, 0x04,
+    0x00, 0x16, 0x80, 0x41, 0x53, 0x81, 0x41, 0x23,
+    0x81, 0xb1, 0x48, 0x2f, 0xbd, 0x4d, 0x91, 0x18,
+    0x9a, 0x01, 0x00, 0x08, 0x80, 0x89, 0x03, 0x00,
+    0x00, 0x28, 0x18, 0x00, 0x00, 0x02, 0x01, 0x00,
+    0x08, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0b,
+    0x06, 0x03, 0x03, 0x00, 0x80, 0x89, 0x80, 0x90,
+    0x22, 0x04, 0x80, 0x90, 0x42, 0x43, 0x8a, 0x84,
+    0x9e, 0x80, 0x9f, 0x99, 0x82, 0xa2, 0x80, 0xee,
+    0x82, 0x8c, 0xab, 0x83, 0x88, 0x31, 0x49, 0x9d,
+    0x89, 0x60, 0xfc, 0x05, 0x42, 0x1d, 0x6b, 0x05,
+    0xe1, 0x4f, 0xff,
 };
 
 static const uint8_t unicode_prop_ASCII_Hex_Digit_table[5] = {
Index: indigo-src/indigo/api/c/indigo-inchi/indigo-inchi.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo-inchi/indigo-inchi.h b/indigo-src/indigo/api/c/indigo-inchi/indigo-inchi.h
--- a/indigo-src/indigo/api/c/indigo-inchi/indigo-inchi.h	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo-inchi/indigo-inchi.h	(date 1714440647086)
@@ -20,24 +20,25 @@
 #define __indigo_inchi__
 
 #include "indigo.h"
+#include "indigo_inchi_export.h"
 
-CEXPORT const char* indigoInchiVersion();
+INDIGO_INCHI_EXPORT const char *indigoInchiVersion();
 
-CEXPORT int indigoInchiInit(qword id);
-CEXPORT int indigoInchiDispose(qword id);
+INDIGO_INCHI_EXPORT int indigoInchiInit(qword id);
+INDIGO_INCHI_EXPORT int indigoInchiDispose(qword id);
 
-CEXPORT int indigoInchiResetOptions();
+INDIGO_INCHI_EXPORT int indigoInchiResetOptions();
 
-CEXPORT int indigoInchiLoadMolecule(const char* inchi_string);
+INDIGO_INCHI_EXPORT int indigoInchiLoadMolecule(const char *inchi_string);
 
-CEXPORT const char* indigoInchiGetInchi(int molecule);
+INDIGO_INCHI_EXPORT const char *indigoInchiGetInchi(int molecule);
 
-CEXPORT const char* indigoInchiGetInchiKey(const char* inchi_string);
+INDIGO_INCHI_EXPORT const char *indigoInchiGetInchiKey(const char *inchi_string);
 
-CEXPORT const char* indigoInchiGetWarning();
+INDIGO_INCHI_EXPORT const char *indigoInchiGetWarning();
 
-CEXPORT const char* indigoInchiGetLog();
+INDIGO_INCHI_EXPORT const char *indigoInchiGetLog();
 
-CEXPORT const char* indigoInchiGetAuxInfo();
+INDIGO_INCHI_EXPORT const char *indigoInchiGetAuxInfo();
 
 #endif // __indigo_inchi__
Index: quickjs-src/quickjs/list.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/list.h b/quickjs-src/quickjs/src/list.h
rename from quickjs-src/quickjs/list.h
rename to quickjs-src/quickjs/src/list.h
--- a/quickjs-src/quickjs/list.h	(revision 3b45d155c77bbdfe9177b1e03db830d2aff0b2a8)
+++ b/quickjs-src/quickjs/src/list.h	(date 1714440647090)
@@ -36,7 +36,8 @@
 #define LIST_HEAD_INIT(el) { &(el), &(el) }
 
 /* return the pointer of type 'type *' containing 'el' as field 'member' */
-#define list_entry(el, type, member) container_of(el, type, member)
+#define list_entry(el, type, member) \
+    ((type *)((uint8_t *)(el) - offsetof(type, member)))
 
 static inline void init_list_head(struct list_head *head)
 {
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.h b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.h
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.h	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.h	(date 1714440647086)
@@ -35,7 +35,7 @@
 #ifndef __IXA_MOL_H__
 #define __IXA_MOL_H__
 
-#include "../../../../INCHI_BASE/src/ixa.h"
+#include "ixa.h"
 
 typedef struct
 {
Index: rdkit-src/rdkit/Code/RDGeneral/Invariant.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/RDGeneral/Invariant.h b/rdkit-src/rdkit/Code/RDGeneral/Invariant.h
--- a/rdkit-src/rdkit/Code/RDGeneral/Invariant.h	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Code/RDGeneral/Invariant.h	(date 1714440647086)
@@ -26,9 +26,9 @@
 // Enable RDDEBUG for testing whether rdcast
 //  conversions are within numerical limits
 #include <RDGeneral/BoostStartInclude.h>
-#include <boost/numeric/conversion/cast.hpp>
 #include <RDGeneral/BoostEndInclude.h>
 #endif
+#include <boost/numeric/conversion/cast.hpp>
 //
 // What if no invariant method is defined?
 //
Index: rdkit-src/rdkit/Code/GraphMol/FileParsers/MolSGroupParsing.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/FileParsers/MolSGroupParsing.h b/rdkit-src/rdkit/Code/GraphMol/FileParsers/MolSGroupParsing.h
--- a/rdkit-src/rdkit/Code/GraphMol/FileParsers/MolSGroupParsing.h	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Code/GraphMol/FileParsers/MolSGroupParsing.h	(date 1714440647086)
@@ -131,7 +131,7 @@
 template <class T>
 RDKIT_FILEPARSERS_EXPORT std::vector<T> ParseV3000Array(
     std::stringstream &stream, int maxV = -1, bool strictParsing = false);
-#if defined(_MSC_VER) && defined(RDKIT_DYN_LINK)
+#if defined(_MSC_VER)
 template RDKIT_FILEPARSERS_EXPORT std::vector<int> ParseV3000Array(
     std::stringstream &, int, bool);
 template RDKIT_FILEPARSERS_EXPORT std::vector<unsigned int> ParseV3000Array(
Index: yaehmop-src/yaehmop/tightbind/abfns.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/yaehmop-src/yaehmop/tightbind/abfns.c b/yaehmop-src/yaehmop/tightbind/abfns.c
--- a/yaehmop-src/yaehmop/tightbind/abfns.c	(revision 7a4919752a60a7d096c83c3d2112a38c41e0f0ac)
+++ b/yaehmop-src/yaehmop/tightbind/abfns.c	(date 1714440647086)
@@ -2,7 +2,15 @@
 Produced by gmFortran V30.59(10/26/17) on 9/17/18 at 9:45:37
 */
 #define LPROTOTYPE
-#include "fortran.h"
+#include <math.h>
+#include <stdlib.h>
+#ifndef min
+#define min(x, y) ({				\
+	typeof(x) _min1 = (x);			\
+	typeof(y) _min2 = (y);			\
+	(void) (&_min1 == &_min2);		\
+	_min1 < _min2 ? _min1 : _min2; })
+#endif
 /*
 */
 void abfns(double *a,double *b,double *sk1,double *sk2,double *rr,int *l1,
@@ -55,7 +63,7 @@
     }
     ix = j;
     ir = fabs(2.e0*rho2);
-    is = fifmin0(ir+1,19);
+    is = min(ir+1,19);
     if(rho2 == 0) goto S35;
     d = exp(rho2);
     h = 1.e0/d;
Index: quickjs-src/quickjs/cutils.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/cutils.h b/quickjs-src/quickjs/src/cutils.h
rename from quickjs-src/quickjs/cutils.h
rename to quickjs-src/quickjs/src/cutils.h
--- a/quickjs-src/quickjs/cutils.h	(revision 3b45d155c77bbdfe9177b1e03db830d2aff0b2a8)
+++ b/quickjs-src/quickjs/src/cutils.h	(date 1714440647086)
@@ -25,15 +25,18 @@
 #ifndef CUTILS_H
 #define CUTILS_H
 
+#include "quickjs-defs.h"
 #include <stdlib.h>
-#include <string.h>
 #include <inttypes.h>
 
-#define likely(x)       __builtin_expect(!!(x), 1)
-#define unlikely(x)     __builtin_expect(!!(x), 0)
-#define force_inline inline __attribute__((always_inline))
-#define no_inline __attribute__((noinline))
-#define __maybe_unused __attribute__((unused))
+/* set if CPU is big endian */
+#undef WORDS_BIGENDIAN
+
+#define likely(x)       PLATFORM_LIKELY(x)
+#define unlikely(x)     PLATFORM_UNLIKELY(x)
+#define force_inline    PLATFORM_FORCE_INLINE
+#define no_inline       PLATFORM_NO_INLINE
+#define __maybe_unused  PLATFORM_MAYBE_UNUSED
 
 #define xglue(x, y) x ## y
 #define glue(x, y) xglue(x, y)
@@ -46,16 +49,6 @@
 #ifndef countof
 #define countof(x) (sizeof(x) / sizeof((x)[0]))
 #endif
-#ifndef container_of
-/* return the pointer of type 'type *' containing 'ptr' as field 'member' */
-#define container_of(ptr, type, member) ((type *)((uint8_t *)(ptr) - offsetof(type, member)))
-#endif
-
-#if !defined(_MSC_VER) && defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-#define minimum_length(n)  static n
-#else
-#define minimum_length(n)  n
-#endif
 
 typedef int BOOL;
 
@@ -71,12 +64,6 @@
 int strstart(const char *str, const char *val, const char **ptr);
 int has_suffix(const char *str, const char *suffix);
 
-/* Prevent UB when n == 0 and (src == NULL or dest == NULL) */
-static inline void memcpy_no_ub(void *dest, const void *src, size_t n) {
-    if (n)
-        memcpy(dest, src, n);
-}
-
 static inline int max_int(int a, int b)
 {
     if (a > b)
@@ -128,27 +115,65 @@
 /* WARNING: undefined if a = 0 */
 static inline int clz32(unsigned int a)
 {
+#if defined(PLATFORM_GNUC_LIKE)
     return __builtin_clz(a);
+#else
+    unsigned long idx;
+    _BitScanReverse(&idx, a);
+    return 31 ^ idx;
+#endif
 }
 
 /* WARNING: undefined if a = 0 */
 static inline int clz64(uint64_t a)
 {
+#if defined(PLATFORM_GNUC_LIKE)
     return __builtin_clzll(a);
+#else
+    unsigned long idx;
+#  if defined(_WIN64)
+    _BitScanReverse64(&idx, a);
+#  else
+    if (_BitScanReverse(&idx, (uint32_t)(a >> 32)))
+        return 63 ^ (idx + 32);
+    _BitScanReverse(&idx, (uint32_t)(a));
+#  endif
+    return 63 ^ idx;
+#endif
 }
 
 /* WARNING: undefined if a = 0 */
 static inline int ctz32(unsigned int a)
 {
+#if defined(PLATFORM_GNUC_LIKE)
     return __builtin_ctz(a);
+#else
+    unsigned long idx;
+    _BitScanForward(&idx, a);
+    return idx;
+#endif
 }
 
 /* WARNING: undefined if a = 0 */
 static inline int ctz64(uint64_t a)
 {
+#if defined(PLATFORM_GNUC_LIKE)
     return __builtin_ctzll(a);
+#else
+    unsigned long idx;
+#  if defined(_WIN64)
+    _BitScanForward64(&idx, a);
+    return idx;
+#  else
+    if (_BitScanForward(&idx, (uint32_t)(a)))
+        return idx;
+    _BitScanForward(&idx, (uint32_t)(a >> 32));
+    return idx + 32;
+#  endif
+#endif
 }
 
+#if defined(PLATFORM_GNUC_LIKE)
 struct __attribute__((packed)) packed_u64 {
     uint64_t v;
 };
@@ -160,6 +185,21 @@
 struct __attribute__((packed)) packed_u16 {
     uint16_t v;
 };
+#else
+#pragma pack(push, 1)
+struct packed_u64 {
+    uint64_t v;
+};
+
+struct packed_u32 {
+    uint32_t v;
+};
+
+struct packed_u16 {
+    uint16_t v;
+};
+#pragma pack(pop)
+#endif
 
 static inline uint64_t get_u64(const uint8_t *tab)
 {
@@ -221,22 +261,17 @@
     *tab = val;
 }
 
-#ifndef bswap16
 static inline uint16_t bswap16(uint16_t x)
 {
     return (x >> 8) | (x << 8);
 }
-#endif
 
-#ifndef bswap32
 static inline uint32_t bswap32(uint32_t v)
 {
     return ((v & 0xff000000) >> 24) | ((v & 0x00ff0000) >>  8) |
         ((v & 0x0000ff00) <<  8) | ((v & 0x000000ff) << 24);
 }
-#endif
 
-#ifndef bswap64
 static inline uint64_t bswap64(uint64_t v)
 {
     return ((v & ((uint64_t)0xff << (7 * 8))) >> (7 * 8)) |
@@ -248,7 +283,6 @@
         ((v & ((uint64_t)0xff << (1 * 8))) << (5 * 8)) |
         ((v & ((uint64_t)0xff << (0 * 8))) << (7 * 8));
 }
-#endif
 
 /* XXX: should take an extra argument to pass slack information to the caller */
 typedef void *DynBufReallocFunc(void *opaque, void *ptr, size_t size);
@@ -282,8 +316,7 @@
 {
     return dbuf_put(s, (uint8_t *)&val, 8);
 }
-int __attribute__((format(printf, 2, 3))) dbuf_printf(DynBuf *s,
-                                                      const char *fmt, ...);
+int PLATFORM_PRINTF_LIKE(2, 3) dbuf_printf(DynBuf *s, const char *fmt, ...);
 void dbuf_free(DynBuf *s);
 static inline BOOL dbuf_error(DynBuf *s) {
     return s->error;
@@ -298,36 +331,6 @@
 int unicode_to_utf8(uint8_t *buf, unsigned int c);
 int unicode_from_utf8(const uint8_t *p, int max_len, const uint8_t **pp);
 
-static inline BOOL is_surrogate(uint32_t c)
-{
-    return (c >> 11) == (0xD800 >> 11); // 0xD800-0xDFFF
-}
-
-static inline BOOL is_hi_surrogate(uint32_t c)
-{
-    return (c >> 10) == (0xD800 >> 10); // 0xD800-0xDBFF
-}
-
-static inline BOOL is_lo_surrogate(uint32_t c)
-{
-    return (c >> 10) == (0xDC00 >> 10); // 0xDC00-0xDFFF
-}
-
-static inline uint32_t get_hi_surrogate(uint32_t c)
-{
-    return (c >> 10) - (0x10000 >> 10) + 0xD800;
-}
-
-static inline uint32_t get_lo_surrogate(uint32_t c)
-{
-    return (c & 0x3FF) | 0xDC00;
-}
-
-static inline uint32_t from_surrogate(uint32_t hi, uint32_t lo)
-{
-    return 0x10000 + 0x400 * (hi - 0xD800) + (lo - 0xDC00);
-}
-
 static inline int from_hex(int c)
 {
     if (c >= '0' && c <= '9')
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.h b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.h
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.h	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.h	(date 1714440647086)
@@ -35,7 +35,7 @@
 #ifndef __IXA_STATUS_H__
 #define __IXA_STATUS_H__
 
-#include "../../../../INCHI_BASE/src/ixa.h"
+#include "ixa.h"
 
 void STATUS_PushMessage( IXA_STATUS_HANDLE hStatus,
                         IXA_STATUS        vSeverity,
Index: quickjs-src/quickjs/libbf.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/libbf.h b/quickjs-src/quickjs/src/libbf.h
rename from quickjs-src/quickjs/libbf.h
rename to quickjs-src/quickjs/src/libbf.h
--- a/quickjs-src/quickjs/libbf.h	(revision 3b45d155c77bbdfe9177b1e03db830d2aff0b2a8)
+++ b/quickjs-src/quickjs/src/libbf.h	(date 1714440647090)
@@ -24,10 +24,15 @@
 #ifndef LIBBF_H
 #define LIBBF_H
 
+#include "quickjs-defs.h"
 #include <stddef.h>
 #include <stdint.h>
 
-#if defined(__SIZEOF_INT128__) && (INTPTR_MAX >= INT64_MAX)
+#if _MSC_VER
+#undef __AVX2__
+#endif
+
+#if INTPTR_MAX >= INT64_MAX && __AVX2__
 #define LIMB_LOG2_BITS 6
 #else
 #define LIMB_LOG2_BITS 5
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_inchi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_inchi.c b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_inchi.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_inchi.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_inchi.c	(date 1714440647086)
@@ -34,9 +34,9 @@
 
 #include "string.h"
 
-#include "../../../../INCHI_BASE/src/mode.h"
-#include "../../../../INCHI_BASE/src/inchi_api.h"
-#include "../../../../INCHI_BASE/src/util.h"
+#include "mode.h"
+#include "inchi_api.h"
+#include "util.h"
 #include "ixa_mol.h"
 #include "ixa_status.h"
 
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_inchikey_builder.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_inchikey_builder.c b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_inchikey_builder.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_inchikey_builder.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_inchikey_builder.c	(date 1714440647086)
@@ -32,8 +32,8 @@
  */
 
 
-#include "../../../../INCHI_BASE/src/mode.h"
-#include "../../../../INCHI_BASE/src/inchi_api.h"
+#include "mode.h"
+#include "inchi_api.h"
 #include "ixa_status.h"
 #include <stdlib.h>
 #include <string.h>
Index: yaehmop-src/yaehmop/tightbind/lovlap.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/yaehmop-src/yaehmop/tightbind/lovlap.c b/yaehmop-src/yaehmop/tightbind/lovlap.c
--- a/yaehmop-src/yaehmop/tightbind/lovlap.c	(revision 7a4919752a60a7d096c83c3d2112a38c41e0f0ac)
+++ b/yaehmop-src/yaehmop/tightbind/lovlap.c	(date 1714440647086)
@@ -2,7 +2,7 @@
 Produced by gmFortran V30.59(10/26/17) on 9/17/18 at 9:45:37
 */
 #define LPROTOTYPE
-#include "fortran.h"
+#include <math.h>
 /*
 */
 void lovlap(double *strad,double *a,double *b,double *sk1,double *sk2,double *r,
Index: opencv-src/opencv/modules/imgproc/src/spatialgradient.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/imgproc/src/spatialgradient.cpp b/opencv-src/opencv/modules/imgproc/src/spatialgradient.cpp
--- a/opencv-src/opencv/modules/imgproc/src/spatialgradient.cpp	(revision dad8af6b17f8e60d7b95a1203a1b4d22f56574cf)
+++ b/opencv-src/opencv/modules/imgproc/src/spatialgradient.cpp	(date 1714440647086)
@@ -77,7 +77,13 @@
 #endif
 
 template <typename T>
-static inline void spatialGradientKernel( T& vx, T& vy,
+static
+#if _MSC_VER >= 1930 && _MSC_VER < 1940 // FIXME: MSVC 2022, static build, got fatal error C1001
+__declspec(noinline)
+#else
+inline
+#endif
+void spatialGradientKernel( T& vx, T& vy,
                                           const T& v00, const T& v01, const T& v02,
                                           const T& v10,               const T& v12,
                                           const T& v20, const T& v21, const T& v22 )
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.c b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.c	(date 1714440647086)
@@ -36,12 +36,12 @@
 #include <string.h>
 #include <limits.h>
 
-#include "../../../../INCHI_BASE/src/mode.h"
-#include "../../../../INCHI_BASE/src/ichierr.h"
-#include "../../../../INCHI_BASE/src/mol_fmt.h"
-#include "../../../../INCHI_BASE/src/inchi_api.h"
+#include "mode.h"
+#include "ichierr.h"
+#include "mol_fmt.h"
+#include "inchi_api.h"
 
-#include "../../../../INCHI_BASE/src/ichi_io.h"
+#include "ichi_io.h"
 
 #include "ixa_mol.h"
 #include "ixa_status.h"
Index: thrift-src/thrift/lib/cpp/src/thrift/windows/Sync.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/thrift-src/thrift/lib/cpp/src/thrift/windows/Sync.h b/thrift-src/thrift/lib/cpp/src/thrift/windows/Sync.h
--- a/thrift-src/thrift/lib/cpp/src/thrift/windows/Sync.h	(revision 0d0ac75347267f7c12fc9b5b349bf9ef7f632347)
+++ b/thrift-src/thrift/lib/cpp/src/thrift/windows/Sync.h	(date 1714440647086)
@@ -37,7 +37,7 @@
 #define WIN32_LEAN_AND_MEAN
 #define _THRIFT_UNDEF_WIN32_LEAN_AND_MEAN
 #endif
-#include <Windows.h>
+#include <windows.h>
 #ifdef _THRIFT_UNDEF_NOMINMAX
 #undef NOMINMAX
 #undef _THRIFT_UNDEF_NOMINMAX
Index: indigo-src/indigo/core/indigo-core/molecule/src/haworth_projection_finder.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/molecule/src/haworth_projection_finder.cpp b/indigo-src/indigo/core/indigo-core/molecule/src/haworth_projection_finder.cpp
--- a/indigo-src/indigo/core/indigo-core/molecule/src/haworth_projection_finder.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/core/indigo-core/molecule/src/haworth_projection_finder.cpp	(date 1714440647086)
@@ -12,6 +12,11 @@
 
 CP_DEF(HaworthProjectionFinder);
 
+template<typename T>
+inline auto indigo_get_sign(T a){
+    return (a > 0 ? 1 : (a < 0 ? -1 : 0));
+}
+
 const float COS10_THRESHOLD = 0.015f;
 
 HaworthProjectionFinder::HaworthProjectionFinder(BaseMolecule& mol)
@@ -147,8 +152,8 @@
 
         float s = _getAngleSin(vi, e1i, e2i);
         if (sign == 0)
-            sign = __sign(s);
-        else if (sign != __sign(s))
+            sign = indigo_get_sign(s);
+        else if (sign != indigo_get_sign(s))
             return false; // Rotation direction is different => non-convex
 
         bool is_corner = _isCornerVertex(vi, e1i, e2i);
@@ -219,8 +224,8 @@
             {
                 // Count only non-horizontal bonds
                 if (sub_sign == 0)
-                    sub_sign = __sign(c2);
-                else if (sub_sign == __sign(c2))
+                    sub_sign = indigo_get_sign(c2);
+                else if (sub_sign == indigo_get_sign(c2))
                     return false; // Substituents are in the same direction
             }
         }
@@ -329,7 +334,7 @@
     float yn = _mol.getAtomXyz(vertices[left_next]).y;
     float yp = _mol.getAtomXyz(vertices[left_prev]).y;
 
-    int parity = __sign(yn - yp);
+    int parity = indigo_get_sign(yn - yp);
 
     for (int j = 0; j < vertices.size(); j++)
     {
@@ -411,7 +416,7 @@
     Vec2f d1(pv1.x - pv.x, pv1.y - pv.y);
     Vec2f d2(pv2.x - pv.x, pv2.y - pv.y);
 
-    return __sign(d1.x * d2.x) == 1;
+    return indigo_get_sign(d1.x * d2.x) == 1;
 }
 
 bool HaworthProjectionFinder::_isHorizontalEdge(int e, float cos_threshold)
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_mol.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_mol.c b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_mol.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_mol.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_mol.c	(date 1714440647086)
@@ -38,12 +38,12 @@
 #include <stdlib.h>
 #include <string.h>
 
-#include "../../../../INCHI_BASE/src/mode.h"
-#include "../../../../INCHI_BASE/src/inchi_api.h"
-#include "../../../../INCHI_BASE/src/ichicomp.h"
-#include "../../../../INCHI_BASE/src/util.h"
-#include "../../../../INCHI_BASE/src/mol_fmt.h"
-#include "../../../../INCHI_BASE/src/ichi_io.h"
+#include "mode.h"
+#include "inchi_api.h"
+#include "ichicomp.h"
+#include "util.h"
+#include "mol_fmt.h"
+#include "ichi_io.h"
 
 #include "ixa_status.h"
 #include "ixa_mol.h"
Index: indigo-src/indigo/api/c/indigo-renderer/src/indigo_render2d.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo-renderer/src/indigo_render2d.cpp b/indigo-src/indigo/api/c/indigo-renderer/src/indigo_render2d.cpp
--- a/indigo-src/indigo/api/c/indigo-renderer/src/indigo_render2d.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/api/c/indigo-renderer/src/indigo_render2d.cpp	(date 1714440647086)
@@ -413,7 +413,7 @@
         value.readString("right", true);
 }
 
-CEXPORT int indigoRendererInit(qword id)
+int indigoRendererInit(qword id)
 {
 #ifdef INDIGO_DEBUG
     std::stringstream ss;
@@ -429,7 +429,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRendererDispose(const qword id)
+int indigoRendererDispose(const qword id)
 {
 #ifdef INDIGO_DEBUG
     std::stringstream ss;
@@ -444,7 +444,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRender(int object, int output)
+int indigoRender(int object, int output)
 {
     INDIGO_BEGIN
     {
@@ -500,7 +500,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRenderGrid(int objects, int* refAtoms, int nColumns, int output)
+int indigoRenderGrid(int objects, int* refAtoms, int nColumns, int output)
 {
     INDIGO_BEGIN
     {
@@ -624,7 +624,7 @@
     return indigoRenderMapOutputFormat(ext + 1);
 }
 
-CEXPORT int indigoRenderToFile(int object, const char* filename)
+int indigoRenderToFile(int object, const char* filename)
 {
     int f = indigoWriteFile(filename);
 
@@ -641,7 +641,7 @@
     return res;
 }
 
-CEXPORT int indigoRenderGridToFile(int objects, int* refAtoms, int nColumns, const char* filename)
+int indigoRenderGridToFile(int objects, int* refAtoms, int nColumns, const char* filename)
 {
     int f = indigoWriteFile(filename);
 
@@ -658,7 +658,7 @@
     return res;
 }
 
-CEXPORT int indigoRenderReset()
+int indigoRenderReset()
 {
     INDIGO_BEGIN
     {
@@ -669,13 +669,13 @@
     INDIGO_END(-1);
 }
 
-CEXPORT void indigoRenderResetOptions()
+void indigoRenderResetOptions()
 {
     indigoRendererGetInstance().init();
     getCdxmlContext().clear();
 }
 
-CEXPORT int indigoRenderWriteHDC(void* hdc, int printingHdc)
+int indigoRenderWriteHDC(void* hdc, int printingHdc)
 {
     INDIGO_BEGIN
     {
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.c b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.c	(date 1714440647086)
@@ -32,8 +32,8 @@
  */
 
 
-#include "../../../../INCHI_BASE/src/mode.h"
-#include "../../../../INCHI_BASE/src/inchi_api.h"
+#include "mode.h"
+#include "inchi_api.h"
 #include "ixa_status.h"
 #include <string.h>
 #include <stdarg.h>
Index: svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns_print.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns_print.hpp b/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns_print.hpp
new file mode 100644
--- /dev/null	(date 1714440647086)
+++ b/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns_print.hpp	(date 1714440647086)
@@ -0,0 +1,432 @@
+#ifndef RAPIDXML_NS_PRINT_HPP_INCLUDED
+#define RAPIDXML_NS_PRINT_HPP_INCLUDED
+
+// Copyright (C) 2006, 2009 Marcin Kalicinski
+// Version 1.13
+// Revision $DateTime: 2009/05/13 01:46:17 $
+//! \file rapidxml_ns_print.hpp This file contains rapidxml printer implementation
+
+#include "rapidxml_ns.hpp"
+
+// Only include streams if not disabled
+#ifndef RAPIDXML_NO_STREAMS
+    #include <ostream>
+    #include <iterator>
+#endif
+
+namespace rapidxml_ns
+{
+
+    ///////////////////////////////////////////////////////////////////////
+    // Printing flags
+
+    const int print_no_indenting = 0x1;   //!< Printer flag instructing the printer to suppress indenting of XML. See print() function.
+
+    ///////////////////////////////////////////////////////////////////////
+    // Internal
+
+    //! \cond internal
+    namespace internal
+    {
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Internal character operations
+
+        // Copy characters from given range to given output iterator
+        template<class OutIt, class Ch>
+        inline OutIt copy_chars(const Ch *begin, const Ch *end, OutIt out)
+        {
+            while (begin != end)
+                *out++ = *begin++;
+            return out;
+        }
+
+        // Copy characters from given range to given output iterator and expand
+        // characters into references (&lt; &gt; &apos; &quot; &amp;)
+        template<class OutIt, class Ch>
+        inline OutIt copy_and_expand_chars(const Ch *begin, const Ch *end, Ch noexpand, OutIt out)
+        {
+            while (begin != end)
+            {
+                if (*begin == noexpand)
+                {
+                    *out++ = *begin;    // No expansion, copy character
+                }
+                else
+                {
+                    switch (*begin)
+                    {
+                    case Ch('<'):
+                        *out++ = Ch('&'); *out++ = Ch('l'); *out++ = Ch('t'); *out++ = Ch(';');
+                        break;
+                    case Ch('>'):
+                        *out++ = Ch('&'); *out++ = Ch('g'); *out++ = Ch('t'); *out++ = Ch(';');
+                        break;
+                    case Ch('\''):
+                        *out++ = Ch('&'); *out++ = Ch('a'); *out++ = Ch('p'); *out++ = Ch('o'); *out++ = Ch('s'); *out++ = Ch(';');
+                        break;
+                    case Ch('"'):
+                        *out++ = Ch('&'); *out++ = Ch('q'); *out++ = Ch('u'); *out++ = Ch('o'); *out++ = Ch('t'); *out++ = Ch(';');
+                        break;
+                    case Ch('&'):
+                        *out++ = Ch('&'); *out++ = Ch('a'); *out++ = Ch('m'); *out++ = Ch('p'); *out++ = Ch(';');
+                        break;
+                    default:
+                        *out++ = *begin;    // No expansion, copy character
+                    }
+                }
+                ++begin;    // Step to next character
+            }
+            return out;
+        }
+
+        // Fill given output iterator with repetitions of the same character
+        template<class OutIt, class Ch>
+        inline OutIt fill_chars(OutIt out, int n, Ch ch)
+        {
+            for (int i = 0; i < n; ++i)
+                *out++ = ch;
+            return out;
+        }
+
+        // Find character
+        template<class Ch, Ch ch>
+        inline bool find_char(const Ch *begin, const Ch *end)
+        {
+            while (begin != end)
+                if (*begin++ == ch)
+                    return true;
+            return false;
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Internal printing operations
+
+        // Printing function declarations (fix for clang bug in gcc and others: http://sourceforge.net/p/rapidxml/bugs/16/)
+
+        template<class OutIt, class Ch> inline OutIt print_children(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_element_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_data_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_cdata_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_declaration_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_comment_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_doctype_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_pi_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+
+        // Print node
+        template<class OutIt, class Ch>
+        inline OutIt print_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            // Print proper node type
+            switch (node->type())
+            {
+
+            // Document
+            case node_document:
+                out = print_children(out, node, flags, indent);
+                break;
+
+            // Element
+            case node_element:
+                out = print_element_node(out, node, flags, indent);
+                break;
+
+            // Data
+            case node_data:
+                out = print_data_node(out, node, flags, indent);
+                break;
+
+            // CDATA
+            case node_cdata:
+                out = print_cdata_node(out, node, flags, indent);
+                break;
+
+            // Declaration
+            case node_declaration:
+                out = print_declaration_node(out, node, flags, indent);
+                break;
+
+            // Comment
+            case node_comment:
+                out = print_comment_node(out, node, flags, indent);
+                break;
+
+            // Doctype
+            case node_doctype:
+                out = print_doctype_node(out, node, flags, indent);
+                break;
+
+            // Pi
+            case node_pi:
+                out = print_pi_node(out, node, flags, indent);
+                break;
+
+                // Unknown
+            default:
+                assert(0);
+                break;
+            }
+
+            // If indenting not disabled, add line break after node
+            if (!(flags & print_no_indenting))
+                *out = Ch('\n'), ++out;
+
+            // Return modified iterator
+            return out;
+        }
+
+        // Print children of the node
+        template<class OutIt, class Ch>
+        inline OutIt print_children(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            for (xml_node<Ch> *child = node->first_node(); child; child = child->next_sibling())
+                out = print_node(out, child, flags, indent);
+            return out;
+        }
+
+        // Print attributes of the node
+        template<class OutIt, class Ch>
+        inline OutIt print_attributes(OutIt out, const xml_node<Ch> *node, int flags)
+        {
+            for (xml_attribute<Ch> *attribute = node->first_attribute(); attribute; attribute = attribute->next_attribute())
+            {
+                if (attribute->name() && attribute->value())
+                {
+                    // Print attribute name
+                    *out = Ch(' '), ++out;
+                    out = copy_chars(attribute->name(), attribute->name() + attribute->name_size(), out);
+                    *out = Ch('='), ++out;
+                    // Print attribute value using appropriate quote type
+                    if (find_char<Ch, Ch('"')>(attribute->value(), attribute->value() + attribute->value_size()))
+                    {
+                        *out = Ch('\''), ++out;
+                        out = copy_and_expand_chars(attribute->value(), attribute->value() + attribute->value_size(), Ch('"'), out);
+                        *out = Ch('\''), ++out;
+                    }
+                    else
+                    {
+                        *out = Ch('"'), ++out;
+                        out = copy_and_expand_chars(attribute->value(), attribute->value() + attribute->value_size(), Ch('\''), out);
+                        *out = Ch('"'), ++out;
+                    }
+                }
+            }
+            return out;
+        }
+
+        // Print data node
+        template<class OutIt, class Ch>
+        inline OutIt print_data_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            assert(node->type() == node_data);
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            out = copy_and_expand_chars(node->value(), node->value() + node->value_size(), Ch(0), out);
+            return out;
+        }
+
+        // Print data node
+        template<class OutIt, class Ch>
+        inline OutIt print_cdata_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            assert(node->type() == node_cdata);
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            *out = Ch('<'); ++out;
+            *out = Ch('!'); ++out;
+            *out = Ch('['); ++out;
+            *out = Ch('C'); ++out;
+            *out = Ch('D'); ++out;
+            *out = Ch('A'); ++out;
+            *out = Ch('T'); ++out;
+            *out = Ch('A'); ++out;
+            *out = Ch('['); ++out;
+            out = copy_chars(node->value(), node->value() + node->value_size(), out);
+            *out = Ch(']'); ++out;
+            *out = Ch(']'); ++out;
+            *out = Ch('>'); ++out;
+            return out;
+        }
+
+        // Print element node
+        template<class OutIt, class Ch>
+        inline OutIt print_element_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            assert(node->type() == node_element);
+
+            // Print element name and attributes, if any
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            *out = Ch('<'), ++out;
+            out = copy_chars(node->name(), node->name() + node->name_size(), out);
+            out = print_attributes(out, node, flags);
+
+            // If node is childless
+            if (node->value_size() == 0 && !node->first_node())
+            {
+                // Print childless node tag ending
+                *out = Ch('/'), ++out;
+                *out = Ch('>'), ++out;
+            }
+            else
+            {
+                // Print normal node tag ending
+                *out = Ch('>'), ++out;
+
+                // Test if node contains a single data node only (and no other nodes)
+                xml_node<Ch> *child = node->first_node();
+                if (!child)
+                {
+                    // If node has no children, only print its value without indenting
+                    out = copy_and_expand_chars(node->value(), node->value() + node->value_size(), Ch(0), out);
+                }
+                else if (child->next_sibling() == 0 && child->type() == node_data)
+                {
+                    // If node has a sole data child, only print its value without indenting
+                    out = copy_and_expand_chars(child->value(), child->value() + child->value_size(), Ch(0), out);
+                }
+                else
+                {
+                    // Print all children with full indenting
+                    if (!(flags & print_no_indenting))
+                        *out = Ch('\n'), ++out;
+                    out = print_children(out, node, flags, indent + 1);
+                    if (!(flags & print_no_indenting))
+                        out = fill_chars(out, indent, Ch('\t'));
+                }
+
+                // Print node end
+                *out = Ch('<'), ++out;
+                *out = Ch('/'), ++out;
+                out = copy_chars(node->name(), node->name() + node->name_size(), out);
+                *out = Ch('>'), ++out;
+            }
+            return out;
+        }
+
+        // Print declaration node
+        template<class OutIt, class Ch>
+        inline OutIt print_declaration_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            // Print declaration start
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            *out = Ch('<'), ++out;
+            *out = Ch('?'), ++out;
+            *out = Ch('x'), ++out;
+            *out = Ch('m'), ++out;
+            *out = Ch('l'), ++out;
+
+            // Print attributes
+            out = print_attributes(out, node, flags);
+
+            // Print declaration end
+            *out = Ch('?'), ++out;
+            *out = Ch('>'), ++out;
+
+            return out;
+        }
+
+        // Print comment node
+        template<class OutIt, class Ch>
+        inline OutIt print_comment_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            assert(node->type() == node_comment);
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            *out = Ch('<'), ++out;
+            *out = Ch('!'), ++out;
+            *out = Ch('-'), ++out;
+            *out = Ch('-'), ++out;
+            out = copy_chars(node->value(), node->value() + node->value_size(), out);
+            *out = Ch('-'), ++out;
+            *out = Ch('-'), ++out;
+            *out = Ch('>'), ++out;
+            return out;
+        }
+
+        // Print doctype node
+        template<class OutIt, class Ch>
+        inline OutIt print_doctype_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            assert(node->type() == node_doctype);
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            *out = Ch('<'), ++out;
+            *out = Ch('!'), ++out;
+            *out = Ch('D'), ++out;
+            *out = Ch('O'), ++out;
+            *out = Ch('C'), ++out;
+            *out = Ch('T'), ++out;
+            *out = Ch('Y'), ++out;
+            *out = Ch('P'), ++out;
+            *out = Ch('E'), ++out;
+            *out = Ch(' '), ++out;
+            out = copy_chars(node->value(), node->value() + node->value_size(), out);
+            *out = Ch('>'), ++out;
+            return out;
+        }
+
+        // Print pi node
+        template<class OutIt, class Ch>
+        inline OutIt print_pi_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            assert(node->type() == node_pi);
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            *out = Ch('<'), ++out;
+            *out = Ch('?'), ++out;
+            out = copy_chars(node->name(), node->name() + node->name_size(), out);
+            *out = Ch(' '), ++out;
+            out = copy_chars(node->value(), node->value() + node->value_size(), out);
+            *out = Ch('?'), ++out;
+            *out = Ch('>'), ++out;
+            return out;
+        }
+
+    }
+    //! \endcond
+
+    ///////////////////////////////////////////////////////////////////////////
+    // Printing
+
+    //! Prints XML to given output iterator.
+    //! \param out Output iterator to print to.
+    //! \param node Node to be printed. Pass xml_document to print entire document.
+    //! \param flags Flags controlling how XML is printed.
+    //! \return Output iterator pointing to position immediately after last character of printed text.
+    template<class OutIt, class Ch>
+    inline OutIt print(OutIt out, const xml_node<Ch> &node, int flags = 0)
+    {
+        return internal::print_node(out, &node, flags, 0);
+    }
+
+#ifndef RAPIDXML_NO_STREAMS
+
+    //! Prints XML to given output stream.
+    //! \param out Output stream to print to.
+    //! \param node Node to be printed. Pass xml_document to print entire document.
+    //! \param flags Flags controlling how XML is printed.
+    //! \return Output stream.
+    template<class Ch>
+    inline std::basic_ostream<Ch> &print(std::basic_ostream<Ch> &out, const xml_node<Ch> &node, int flags = 0)
+    {
+        print(std::ostream_iterator<Ch>(out), node, flags);
+        return out;
+    }
+
+    //! Prints formatted XML to given output stream. Uses default printing flags. Use print() function to customize printing process.
+    //! \param out Output stream to print to.
+    //! \param node Node to be printed.
+    //! \return Output stream.
+    template<class Ch>
+    inline std::basic_ostream<Ch> &operator <<(std::basic_ostream<Ch> &out, const xml_node<Ch> &node)
+    {
+        return print(out, node);
+    }
+
+#endif
+
+}
+
+#endif
Index: fluentui-src/fluentui/src/Qt6/CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/Qt6/CMakeLists.txt b/fluentui-src/fluentui/src/Qt6/CMakeLists.txt
new file mode 100644
--- /dev/null	(date 1714441205102)
+++ b/fluentui-src/fluentui/src/Qt6/CMakeLists.txt	(date 1714441205102)
@@ -0,0 +1,60 @@
+project(fluentui)
+
+# fluentui
+set(ROOT_DIR ${CMAKE_CURRENT_SOURCE_DIR})
+set(INC_DIR ${ROOT_DIR}/../)
+set(SRC_DIR ${ROOT_DIR}/../)
+
+file(GLOB_RECURSE QML_PATHS ${ROOT_DIR}/*.qml)
+foreach (filepath ${QML_PATHS})
+    string(REPLACE "${ROOT_DIR}/" "" filename ${filepath})
+    list(APPEND qml_files ${filename})
+endforeach (filepath)
+
+file(GLOB_RECURSE RES_PATHS
+        ${ROOT_DIR}/*.png ${ROOT_DIR}/*.jpg
+        ${ROOT_DIR}/*.svg ${ROOT_DIR}/*.ico
+        ${ROOT_DIR}/*.ttf ${ROOT_DIR}/*.webp
+        ${ROOT_DIR}/*.js)
+foreach (filepath ${RES_PATHS})
+    string(REPLACE "${ROOT_DIR}/" "" filename ${filepath})
+    list(APPEND resource_files ${filename})
+endforeach (filepath)
+
+foreach (filepath IN LISTS qml_files resource_files)
+    string(REPLACE "imports/FluentUI/" "" filename ${filepath})
+    set_source_files_properties(${filepath} PROPERTIES QT_RESOURCE_ALIAS ${filename})
+endforeach ()
+
+if (CMAKE_RUNTIME_OUTPUT_DIRECTORY)
+    set(OUTPUT_DIRECTORY "${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/FluentUI")
+else ()
+    set(OUTPUT_DIRECTORY FluentUI)
+endif ()
+
+#set(CMAKE_AUTOMOC ON)
+#set(CMAKE_AUTORCC ON)
+
+xgd_add_library(${PROJECT_NAME} PRIVATE_INCLUDE_DIRS ${INC_DIR})
+xgd_link_qt(${PROJECT_NAME} PRIVATE Quick)
+
+aux_source_directory(${SRC_DIR} source_files)
+aux_source_directory(${SRC_DIR}/qrcode source_files)
+list(REMOVE_ITEM source_files "${SRC_DIR}/fluentuiplugin.cpp")
+
+# create target ${PROJECT_NAME}plugin
+qt_add_qml_module(${PROJECT_NAME}
+        PLUGIN_TARGET ""
+        OUTPUT_DIRECTORY "${OUTPUT_DIRECTORY}"
+        VERSION 1.0
+        URI FluentUI
+        TYPEINFO "plugins.qmltypes"
+        SOURCES ${source_files}
+        QML_FILES ${qml_files}
+        RESOURCES ${resource_files}
+        RESOURCE_PREFIX "/")
+
+target_compile_definitions(fluentui PRIVATE HAVE_CONFIG_H)
+if (NOT BUILD_SHARED_LIBS)
+    target_compile_definitions(fluentui PRIVATE FLUENTUI_BUILD_STATIC_LIB)
+endif ()
Index: svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns.hpp b/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns.hpp
new file mode 100644
--- /dev/null	(date 1714440647086)
+++ b/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns.hpp	(date 1714440647086)
@@ -0,0 +1,3113 @@
+#ifndef RAPIDXML_NS_HPP_INCLUDED
+#define RAPIDXML_NS_HPP_INCLUDED
+
+// Copyright (C) 2006, 2009 Marcin Kalicinski
+// Version 1.13
+// Revision $DateTime: 2009/05/13 01:46:17 $
+//! \file rapidxml_ns.hpp This file contains rapidxml_ns parser and DOM implementation
+
+// If standard library is disabled, user must provide implementations of required functions and typedefs
+#if !defined(RAPIDXML_NO_STDLIB)
+    #include <cstdlib>      // For std::size_t
+    #include <cassert>      // For assert
+    #include <new>          // For placement new
+    #include <vector>
+#endif
+
+// On MSVC, disable "conditional expression is constant" warning (level 4).
+// This warning is almost impossible to avoid with certain types of templated code
+#ifdef _MSC_VER
+    #pragma warning(push)
+    #pragma warning(disable:4127)   // Conditional expression is constant
+#endif
+
+///////////////////////////////////////////////////////////////////////////
+// RAPIDXML_PARSE_ERROR
+
+#if defined(RAPIDXML_NO_EXCEPTIONS)
+
+#define RAPIDXML_PARSE_ERROR(what, where) { parse_error_handler(what, where); assert(0); }
+
+namespace rapidxml_ns
+{
+    //! When exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS,
+    //! this function is called to notify user about the error.
+    //! It must be defined by the user.
+    //! <br><br>
+    //! This function cannot return. If it does, the results are undefined.
+    //! <br><br>
+    //! A very simple definition might look like that:
+    //! <pre>
+    //! void %rapidxml_ns::%parse_error_handler(const char *what, void *where)
+    //! {
+    //!     std::cout << "Parse error: " << what << "\n";
+    //!     std::abort();
+    //! }
+    //! </pre>
+    //! \param what Human readable description of the error.
+    //! \param where Pointer to character data where error was detected.
+    void parse_error_handler(const char *what, void *where);
+}
+
+#else
+
+#include <exception>    // For std::exception
+
+#define RAPIDXML_PARSE_ERROR(what, where) throw parse_error(what, where)
+
+namespace rapidxml_ns
+{
+
+    //! Parse error exception.
+    //! This exception is thrown by the parser when an error occurs.
+    //! Use what() function to get human-readable error message.
+    //! Use where() function to get a pointer to position within source text where error was detected.
+    //! <br><br>
+    //! If throwing exceptions by the parser is undesirable,
+    //! it can be disabled by defining RAPIDXML_NO_EXCEPTIONS macro before rapidxml_ns.hpp is included.
+    //! This will cause the parser to call rapidxml_ns::parse_error_handler() function instead of throwing an exception.
+    //! This function must be defined by the user.
+    //! <br><br>
+    //! This class derives from <code>std::exception</code> class.
+    class parse_error: public std::exception
+    {
+
+    public:
+
+        //! Constructs parse error
+        parse_error(const char *what, void *where)
+            : m_what(what)
+            , m_where(where)
+        {
+        }
+
+        //! Gets human readable description of error.
+        //! \return Pointer to null terminated description of the error.
+        virtual const char *what() const throw()
+        {
+            return m_what;
+        }
+
+        //! Gets pointer to character data where error happened.
+        //! Ch should be the same as char type of xml_document that produced the error.
+        //! \return Pointer to location within the parsed string where error occured.
+        template<class Ch>
+        Ch *where() const
+        {
+            return reinterpret_cast<Ch *>(m_where);
+        }
+
+    private:
+
+        const char *m_what;
+        void *m_where;
+
+    };
+}
+
+#endif
+
+///////////////////////////////////////////////////////////////////////////
+// Pool sizes
+
+#ifndef RAPIDXML_STATIC_POOL_SIZE
+    // Size of static memory block of memory_pool.
+    // Define RAPIDXML_STATIC_POOL_SIZE before including rapidxml_ns.hpp if you want to override the default value.
+    // No dynamic memory allocations are performed by memory_pool until static memory is exhausted.
+    #define RAPIDXML_STATIC_POOL_SIZE (64 * 1024)
+#endif
+
+#ifndef RAPIDXML_DYNAMIC_POOL_SIZE
+    // Size of dynamic memory block of memory_pool.
+    // Define RAPIDXML_DYNAMIC_POOL_SIZE before including rapidxml_ns.hpp if you want to override the default value.
+    // After the static block is exhausted, dynamic blocks with approximately this size are allocated by memory_pool.
+    #define RAPIDXML_DYNAMIC_POOL_SIZE (64 * 1024)
+#endif
+
+#ifndef RAPIDXML_ALIGNMENT
+    // Memory allocation alignment.
+    // Define RAPIDXML_ALIGNMENT before including rapidxml_ns.hpp if you want to override the default value, which is the size of pointer.
+    // All memory allocations for nodes, attributes and strings will be aligned to this value.
+    // This must be a power of 2 and at least 1, otherwise memory_pool will not work.
+    #define RAPIDXML_ALIGNMENT sizeof(void *)
+#endif
+
+namespace rapidxml_ns
+{
+    // Forward declarations
+    template<class Ch> class xml_base;
+    template<class Ch> class xml_node;
+    template<class Ch> class xml_attribute;
+    template<class Ch> class xml_document;
+
+    //! Enumeration listing all node types produced by the parser.
+    //! Use xml_node::type() function to query node type.
+    enum node_type
+    {
+        node_document,      //!< A document node. Name and value are empty.
+        node_element,       //!< An element node. Name contains element name. Value contains text of first data node.
+        node_data,          //!< A data node. Name is empty. Value contains data text.
+        node_cdata,         //!< A CDATA node. Name is empty. Value contains data text.
+        node_comment,       //!< A comment node. Name is empty. Value contains comment text.
+        node_declaration,   //!< A declaration node. Name and value are empty. Declaration parameters (version, encoding and standalone) are in node attributes.
+        node_doctype,       //!< A DOCTYPE node. Name is empty. Value contains DOCTYPE text.
+        node_pi             //!< A PI node. Name contains target. Value contains instructions.
+    };
+
+    ///////////////////////////////////////////////////////////////////////
+    // Parsing flags
+
+    //! Parse flag instructing the parser to not create data nodes.
+    //! Text of first data node will still be placed in value of parent element, unless rapidxml_ns::parse_no_element_values flag is also specified.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_no_data_nodes = 0x1;
+
+    //! Parse flag instructing the parser to not use text of first data node as a value of parent element.
+    //! Can be combined with other flags by use of | operator.
+    //! Note that child data nodes of element node take precendence over its value when printing.
+    //! That is, if element has one or more child data nodes <em>and</em> a value, the value will be ignored.
+    //! Use rapidxml_ns::parse_no_data_nodes flag to prevent creation of data nodes if you want to manipulate data using values of elements.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_no_element_values = 0x2;
+
+    //! Parse flag instructing the parser to not place zero terminators after strings in the source text.
+    //! By default zero terminators are placed, modifying source text.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_no_string_terminators = 0x4;
+
+    //! Parse flag instructing the parser to not translate entities in the source text.
+    //! By default entities are translated, modifying source text.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_no_entity_translation = 0x8;
+
+    //! Parse flag instructing the parser to disable UTF-8 handling and assume plain 8 bit characters.
+    //! By default, UTF-8 handling is enabled.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_no_utf8 = 0x10;
+
+    //! Parse flag instructing the parser to create XML declaration node.
+    //! By default, declaration node is not created.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_declaration_node = 0x20;
+
+    //! Parse flag instructing the parser to create comments nodes.
+    //! By default, comment nodes are not created.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_comment_nodes = 0x40;
+
+    //! Parse flag instructing the parser to create DOCTYPE node.
+    //! By default, doctype node is not created.
+    //! Although W3C specification allows at most one DOCTYPE node, RapidXml will silently accept documents with more than one.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_doctype_node = 0x80;
+
+    //! Parse flag instructing the parser to create PI nodes.
+    //! By default, PI nodes are not created.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_pi_nodes = 0x100;
+
+    //! Parse flag instructing the parser to validate closing tag names.
+    //! If not set, name inside closing tag is irrelevant to the parser.
+    //! By default, closing tags are not validated.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_validate_closing_tags = 0x200;
+
+    //! Parse flag instructing the parser to trim all leading and trailing whitespace of data nodes.
+    //! By default, whitespace is not trimmed.
+    //! This flag does not cause the parser to modify source text.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_trim_whitespace = 0x400;
+
+    //! Parse flag instructing the parser to condense all whitespace runs of data nodes to a single space character.
+    //! Trimming of leading and trailing whitespace of data is controlled by rapidxml_ns::parse_trim_whitespace flag.
+    //! By default, whitespace is not normalized.
+    //! If this flag is specified, source text will be modified.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_normalize_whitespace = 0x800;
+
+    //! Parse flag instructing the parser to skip assigning XML namespace URI to elements and attributes.
+    //! I.e. to behave like original RapidXML parser.
+    //! By default, namespaces are set.
+    //! This flag does not cause the parser to modify source text.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_no_namespace = 0x1000;
+
+    // Compound flags
+
+    //! Parse flags which represent default behaviour of the parser.
+    //! This is always equal to 0, so that all other flags can be simply ored together.
+    //! Normally there is no need to inconveniently disable flags by anding with their negated (~) values.
+    //! This also means that meaning of each flag is a <i>negation</i> of the default setting.
+    //! For example, if flag name is rapidxml_ns::parse_no_utf8, it means that utf-8 is <i>enabled</i> by default,
+    //! and using the flag will disable it.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_default = 0;
+
+    //! A combination of parse flags that forbids any modifications of the source text.
+    //! This also results in faster parsing. However, note that the following will occur:
+    //! <ul>
+    //! <li>names and values of nodes will not be zero terminated, you have to use xml_base::name_size() and xml_base::value_size() functions to determine where name and value ends</li>
+    //! <li>entities will not be translated</li>
+    //! <li>whitespace will not be normalized</li>
+    //! </ul>
+    //! See xml_document::parse() function.
+    const int parse_non_destructive = parse_no_string_terminators | parse_no_entity_translation;
+
+    //! A combination of parse flags resulting in fastest possible parsing, without sacrificing important data.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_fastest = parse_non_destructive | parse_no_data_nodes;
+
+    //! A combination of parse flags resulting in largest amount of data being extracted.
+    //! This usually results in slowest parsing.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_full = parse_declaration_node | parse_comment_nodes | parse_doctype_node | parse_pi_nodes | parse_validate_closing_tags;
+
+    template<class Ch>
+    struct xml_namespace
+    {
+        static const size_t prefix_size = 3;
+
+        static Ch const * prefix()
+        {
+            static const Ch value[prefix_size] = {'x', 'm', 'l'};
+            return value;
+        }
+
+        static const size_t uri_size = 36;
+
+        // There should be only one instance of "http://www.w3.org/XML/1998/namespace" string, so
+        // that it can be compared as pointer
+        static Ch const * uri()
+        {
+            static const Ch value[uri_size] =
+                {'h', 't', 't', 'p', ':', '/', '/', 'w', 'w', 'w', '.', 'w', '3', '.', 'o', 'r', 'g',
+                 '/', 'X', 'M', 'L', '/', '1', '9', '9', '8', '/', 'n', 'a', 'm', 'e', 's', 'p', 'a', 'c', 'e'};
+            return value;
+        }
+    };
+
+    template<class Ch>
+    struct xmlns_namespace
+    {
+        static const size_t prefix_size = 5;
+
+        static Ch const * prefix()
+        {
+            static const Ch value[prefix_size] = {'x', 'm', 'l', 'n', 's'};
+            return value;
+        }
+
+        static const size_t uri_size = 29;
+
+        // There should be only one instance of "http://www.w3.org/2000/xmlns/" string, so
+        // that it can be compared as pointer
+        static Ch const * uri()
+        {
+            static const Ch value[uri_size] =
+                {'h', 't', 't', 'p', ':', '/', '/', 'w', 'w', 'w', '.', 'w', '3', '.', 'o', 'r', 'g',
+                 '/', '2', '0', '0', '0', '/', 'x', 'm', 'l', 'n', 's', '/'};
+            return value;
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////
+    // Internals
+
+    //! \cond internal
+    namespace internal
+    {
+
+        // Struct that contains lookup tables for the parser
+        // It must be a template to allow correct linking (because it has static data members, which are defined in a header file).
+        template<int Dummy>
+        struct lookup_tables
+        {
+            static const unsigned char lookup_whitespace[256];              // Whitespace table
+            static const unsigned char lookup_node_name[256];               // Node name table
+            static const unsigned char lookup_node_ncname[256];             // Node NCName table
+            static const unsigned char lookup_text[256];                    // Text table
+            static const unsigned char lookup_text_pure_no_ws[256];         // Text table
+            static const unsigned char lookup_text_pure_with_ws[256];       // Text table
+            static const unsigned char lookup_attribute_name[256];          // Attribute name table
+            static const unsigned char lookup_attribute_ncname[256];        // Attribute NCName table
+            static const unsigned char lookup_attribute_data_1[256];        // Attribute data table with single quote
+            static const unsigned char lookup_attribute_data_1_pure[256];   // Attribute data table with single quote
+            static const unsigned char lookup_attribute_data_2[256];        // Attribute data table with double quotes
+            static const unsigned char lookup_attribute_data_2_pure[256];   // Attribute data table with double quotes
+            static const unsigned char lookup_digits[256];                  // Digits
+            static const unsigned char lookup_upcase[256];                  // To uppercase conversion table for ASCII characters
+        };
+
+        // Find length of the string
+        template<class Ch>
+        inline std::size_t measure(const Ch *p)
+        {
+            const Ch *tmp = p;
+            while (*tmp)
+                ++tmp;
+            return tmp - p;
+        }
+
+        // Compare strings for equality
+        template<class Ch>
+        inline bool compare(const Ch *p1, std::size_t size1, const Ch *p2, std::size_t size2)
+        {
+            if (size1 != size2)
+                return false;
+            for (const Ch *end = p1 + size1; p1 < end; ++p1, ++p2)
+                if (*p1 != *p2)
+                    return false;
+            return true;
+        }
+
+        // Compare strings for equality with option to ignore case
+        template<class Ch>
+        inline bool compare(const Ch *p1, std::size_t size1, const Ch *p2, std::size_t size2, bool case_sensitive)
+        {
+            if (size1 != size2)
+                return false;
+            if (case_sensitive)
+            {
+                for (const Ch *end = p1 + size1; p1 < end; ++p1, ++p2)
+                    if (*p1 != *p2)
+                        return false;
+            }
+            else
+            {
+                for (const Ch *end = p1 + size1; p1 < end; ++p1, ++p2)
+                    if (lookup_tables<0>::lookup_upcase[static_cast<unsigned char>(*p1)] != lookup_tables<0>::lookup_upcase[static_cast<unsigned char>(*p2)])
+                        return false;
+            }
+            return true;
+        }
+
+        template<class Ch, class NamespaceStorage>
+        void assign_element_namespace_uris(xml_node<Ch> * element, NamespaceStorage & ns_storage)
+        {
+            xml_attribute<Ch> * first_prefixed_attribute = 0;
+            for (xml_attribute<Ch> *attr = element->first_attribute(); attr; attr = attr->next_attribute())
+            {
+                switch (attr->prefix_size())
+                {
+                case 0:
+                    if (compare(attr->name(), attr->name_size(),
+                        xmlns_namespace<Ch>::prefix(), xmlns_namespace<Ch>::prefix_size))
+                    {
+                        attr->namespace_uri(xmlns_namespace<Ch>::uri(), xmlns_namespace<Ch>::uri_size);
+                        ns_storage.set_default_namespace(attr);
+                    }
+                    continue;
+                case xml_namespace<Ch>::prefix_size:
+                    if (compare(attr->prefix(), attr->prefix_size(),
+                        xml_namespace<Ch>::prefix(), xml_namespace<Ch>::prefix_size))
+                    {
+                        attr->namespace_uri(xml_namespace<Ch>::uri(), xml_namespace<Ch>::uri_size);
+                        continue;
+                    }
+                    break;
+                case xmlns_namespace<Ch>::prefix_size:
+                    if (compare(attr->prefix(), attr->prefix_size(),
+                        xmlns_namespace<Ch>::prefix(), xmlns_namespace<Ch>::prefix_size))
+                    {
+                        attr->namespace_uri(xmlns_namespace<Ch>::uri(), xmlns_namespace<Ch>::uri_size);
+                        ns_storage.add_namespace_prefix(attr);
+                        continue;
+                    }
+                    break;
+                } // switch
+                if (!first_prefixed_attribute)
+                    first_prefixed_attribute = attr;
+            } // for
+            if (element->prefix_size() == 0)
+                ns_storage.set_element_default_namespace_uri(element);
+            else
+                ns_storage.set_node_namespace_uri_by_prefix(element);
+
+            for (; first_prefixed_attribute; first_prefixed_attribute = first_prefixed_attribute->next_attribute())
+                if (first_prefixed_attribute->prefix_size() > 0 && first_prefixed_attribute->namespace_uri_size() == 0)
+                    ns_storage.set_node_namespace_uri_by_prefix(first_prefixed_attribute);
+        }
+
+        template<class Ch>
+        class xml_namespace_processor
+        {
+        public:
+            class scope
+            {
+            public:
+                scope(xml_namespace_processor & processor)
+                    : m_processor(processor)
+                    , m_stack_position(processor.m_namespace_prefixes.size())
+                    , m_default_namespace(0)
+                {
+                }
+
+                scope(scope const & parent_scope)
+                    : m_processor(parent_scope.m_processor)
+                    , m_stack_position(m_processor.m_namespace_prefixes.size())
+                    , m_default_namespace(parent_scope.m_default_namespace)
+                {
+                }
+
+                ~scope()
+                {
+                    m_processor.m_namespace_prefixes.resize(m_stack_position);
+                }
+
+                void process_element(xml_node<Ch> * element)
+                {
+                    assign_element_namespace_uris(element, *this);
+                }
+
+                void set_default_namespace(xml_attribute<Ch> * ns_attr)
+                {
+                    m_default_namespace = ns_attr;
+                }
+
+                void add_namespace_prefix(xml_attribute<Ch> * ns_attr)
+                {
+                    m_processor.m_namespace_prefixes.push_back(ns_attr);
+                }
+
+                void set_element_default_namespace_uri(xml_node<Ch> * element) const
+                {
+                    if (m_default_namespace)
+                        element->namespace_uri(m_default_namespace->value(), m_default_namespace->value_size());
+                }
+
+                void set_node_namespace_uri_by_prefix(xml_base<Ch> * node) const
+                {
+                    Ch const * prefix = node->prefix();
+                    std::size_t prefix_size = node->prefix_size();
+                    for (typename xml_namespace_processor::xmlns_attributes_t::const_reverse_iterator
+                            it = m_processor.m_namespace_prefixes.rbegin();
+                            it != m_processor.m_namespace_prefixes.rend(); ++it)
+                        if (compare((*it)->local_name(), (*it)->local_name_size(), prefix, prefix_size))
+                        {
+                            node->namespace_uri((*it)->value(), (*it)->value_size());
+                            return;
+                        }
+                    RAPIDXML_PARSE_ERROR("No namespace definition found", 0);
+                }
+
+            private:
+                xml_namespace_processor & m_processor;
+                size_t const m_stack_position;
+                xml_attribute<Ch> * m_default_namespace;
+            };
+
+        private:
+            typedef std::vector<xml_attribute<Ch> *> xmlns_attributes_t;
+            xmlns_attributes_t m_namespace_prefixes;
+        };
+
+        template<class Ch>
+        class xml_namespace_processor_stub
+        {
+        public:
+          class scope
+          {
+          public:
+            scope(xml_namespace_processor_stub &)
+            {}
+
+            scope(scope const &)
+            {}
+
+            void process_element(xml_node<Ch> *) const
+            {}
+          };
+        };
+    }
+    //! \endcond
+
+    ///////////////////////////////////////////////////////////////////////
+    // Memory pool
+
+    //! This class is used by the parser to create new nodes and attributes, without overheads of dynamic memory allocation.
+    //! In most cases, you will not need to use this class directly.
+    //! However, if you need to create nodes manually or modify names/values of nodes,
+    //! you are encouraged to use memory_pool of relevant xml_document to allocate the memory.
+    //! Not only is this faster than allocating them by using <code>new</code> operator,
+    //! but also their lifetime will be tied to the lifetime of document,
+    //! possibly simplyfing memory management.
+    //! <br><br>
+    //! Call allocate_node() or allocate_attribute() functions to obtain new nodes or attributes from the pool.
+    //! You can also call allocate_string() function to allocate strings.
+    //! Such strings can then be used as names or values of nodes without worrying about their lifetime.
+    //! Note that there is no <code>free()</code> function -- all allocations are freed at once when clear() function is called,
+    //! or when the pool is destroyed.
+    //! <br><br>
+    //! It is also possible to create a standalone memory_pool, and use it
+    //! to allocate nodes, whose lifetime will not be tied to any document.
+    //! <br><br>
+    //! Pool maintains <code>RAPIDXML_STATIC_POOL_SIZE</code> bytes of statically allocated memory.
+    //! Until static memory is exhausted, no dynamic memory allocations are done.
+    //! When static memory is exhausted, pool allocates additional blocks of memory of size <code>RAPIDXML_DYNAMIC_POOL_SIZE</code> each,
+    //! by using global <code>new[]</code> and <code>delete[]</code> operators.
+    //! This behaviour can be changed by setting custom allocation routines.
+    //! Use set_allocator() function to set them.
+    //! <br><br>
+    //! Allocations for nodes, attributes and strings are aligned at <code>RAPIDXML_ALIGNMENT</code> bytes.
+    //! This value defaults to the size of pointer on target architecture.
+    //! <br><br>
+    //! To obtain absolutely top performance from the parser,
+    //! it is important that all nodes are allocated from a single, contiguous block of memory.
+    //! Otherwise, cache misses when jumping between two (or more) disjoint blocks of memory can slow down parsing quite considerably.
+    //! If required, you can tweak <code>RAPIDXML_STATIC_POOL_SIZE</code>, <code>RAPIDXML_DYNAMIC_POOL_SIZE</code> and <code>RAPIDXML_ALIGNMENT</code>
+    //! to obtain best wasted memory to performance compromise.
+    //! To do it, define their values before rapidxml_ns.hpp file is included.
+    //! \param Ch Character type of created nodes.
+    template<class Ch = char>
+    class memory_pool
+    {
+
+    public:
+
+        //! \cond internal
+        typedef void *(alloc_func)(std::size_t);       // Type of user-defined function used to allocate memory
+        typedef void (free_func)(void *);              // Type of user-defined function used to free memory
+        //! \endcond
+
+        //! Constructs empty pool with default allocator functions.
+        memory_pool()
+            : m_alloc_func(0)
+            , m_free_func(0)
+        {
+            init();
+        }
+
+        //! Destroys pool and frees all the memory.
+        //! This causes memory occupied by nodes allocated by the pool to be freed.
+        //! Nodes allocated from the pool are no longer valid.
+        ~memory_pool()
+        {
+            clear();
+        }
+
+        //! Allocates a new node from the pool, and optionally assigns name and value to it.
+        //! If the allocation request cannot be accomodated, this function will throw <code>std::bad_alloc</code>.
+        //! If exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, this function
+        //! will call rapidxml_ns::parse_error_handler() function.
+        //! \param type Type of node to create.
+        //! \param name Name to assign to the node, or 0 to assign no name.
+        //! \param value Value to assign to the node, or 0 to assign no value.
+        //! \param name_size Size of name to assign, or 0 to automatically calculate size from name string.
+        //! \param value_size Size of value to assign, or 0 to automatically calculate size from value string.
+        //! \return Pointer to allocated node. This pointer will never be NULL.
+        xml_node<Ch> *allocate_node(node_type type,
+                                    const Ch *name = 0, const Ch *value = 0,
+                                    std::size_t name_size = 0, std::size_t value_size = 0)
+        {
+            void *memory = allocate_aligned(sizeof(xml_node<Ch>));
+            xml_node<Ch> *node = new(memory) xml_node<Ch>(type);
+            if (name)
+            {
+                if (name_size > 0)
+                    node->name(name, name_size);
+                else
+                    node->name(name);
+            }
+            if (value)
+            {
+                if (value_size > 0)
+                    node->value(value, value_size);
+                else
+                    node->value(value);
+            }
+            return node;
+        }
+
+        //! Allocates a new attribute from the pool, and optionally assigns name and value to it.
+        //! If the allocation request cannot be accomodated, this function will throw <code>std::bad_alloc</code>.
+        //! If exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, this function
+        //! will call rapidxml_ns::parse_error_handler() function.
+        //! \param name Name to assign to the attribute, or 0 to assign no name.
+        //! \param value Value to assign to the attribute, or 0 to assign no value.
+        //! \param name_size Size of name to assign, or 0 to automatically calculate size from name string.
+        //! \param value_size Size of value to assign, or 0 to automatically calculate size from value string.
+        //! \return Pointer to allocated attribute. This pointer will never be NULL.
+        xml_attribute<Ch> *allocate_attribute(const Ch *name = 0, const Ch *value = 0,
+                                              std::size_t name_size = 0, std::size_t value_size = 0)
+        {
+            void *memory = allocate_aligned(sizeof(xml_attribute<Ch>));
+            xml_attribute<Ch> *attribute = new(memory) xml_attribute<Ch>;
+            if (name)
+            {
+                if (name_size > 0)
+                    attribute->name(name, name_size);
+                else
+                    attribute->name(name);
+            }
+            if (value)
+            {
+                if (value_size > 0)
+                    attribute->value(value, value_size);
+                else
+                    attribute->value(value);
+            }
+            return attribute;
+        }
+
+        //! Allocates a char array of given size from the pool, and optionally copies a given string to it.
+        //! If the allocation request cannot be accomodated, this function will throw <code>std::bad_alloc</code>.
+        //! If exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, this function
+        //! will call rapidxml_ns::parse_error_handler() function.
+        //! \param source String to initialize the allocated memory with, or 0 to not initialize it.
+        //! \param size Number of characters to allocate, or zero to calculate it automatically from source string length; if size is 0, source string must be specified and null terminated.
+        //! \return Pointer to allocated char array. This pointer will never be NULL.
+        Ch *allocate_string(const Ch *source = 0, std::size_t size = 0)
+        {
+            assert(source || size);     // Either source or size (or both) must be specified
+            if (size == 0)
+                size = internal::measure(source) + 1;
+            Ch *result = static_cast<Ch *>(allocate_aligned(size * sizeof(Ch)));
+            if (source)
+                for (std::size_t i = 0; i < size; ++i)
+                    result[i] = source[i];
+            return result;
+        }
+
+        //! Clones an xml_node and its hierarchy of child nodes and attributes.
+        //! Nodes and attributes are allocated from this memory pool.
+        //! Names and values are not cloned, they are shared between the clone and the source.
+        //! Result node can be optionally specified as a second parameter,
+        //! in which case its contents will be replaced with cloned source node.
+        //! This is useful when you want to clone entire document.
+        //! \param source Node to clone.
+        //! \param result Node to put results in, or 0 to automatically allocate result node
+        //! \return Pointer to cloned node. This pointer will never be NULL.
+        xml_node<Ch> *clone_node(const xml_node<Ch> *source, xml_node<Ch> *result = 0)
+        {
+            // Prepare result node
+            if (result)
+            {
+                result->remove_all_attributes();
+                result->remove_all_nodes();
+                result->type(source->type());
+            }
+            else
+                result = allocate_node(source->type());
+
+            // Clone name and value
+            result->qname(source->name(), source->name_size(), source->local_name());
+            result->value(source->value(), source->value_size());
+
+            // Clone child nodes and attributes
+            for (xml_node<Ch> *child = source->first_node(); child; child = child->next_sibling())
+                result->append_node(clone_node(child));
+            for (xml_attribute<Ch> *attr = source->first_attribute(); attr; attr = attr->next_attribute())
+                result->append_attribute(allocate_attribute(attr->name(), attr->value(), attr->name_size(), attr->value_size()));
+
+            return result;
+        }
+
+        //! Clears the pool.
+        //! This causes memory occupied by nodes allocated by the pool to be freed.
+        //! Any nodes or strings allocated from the pool will no longer be valid.
+        void clear()
+        {
+            while (m_begin != m_static_memory)
+            {
+                char *previous_begin = reinterpret_cast<header *>(align(m_begin))->previous_begin;
+                if (m_free_func)
+                    m_free_func(m_begin);
+                else
+                    delete[] m_begin;
+                m_begin = previous_begin;
+            }
+            init();
+        }
+
+        //! Sets or resets the user-defined memory allocation functions for the pool.
+        //! This can only be called when no memory is allocated from the pool yet, otherwise results are undefined.
+        //! Allocation function must not return invalid pointer on failure. It should either throw,
+        //! stop the program, or use <code>longjmp()</code> function to pass control to other place of program.
+        //! If it returns invalid pointer, results are undefined.
+        //! <br><br>
+        //! User defined allocation functions must have the following forms:
+        //! <br><code>
+        //! <br>void *allocate(std::size_t size);
+        //! <br>void free(void *pointer);
+        //! </code><br>
+        //! \param af Allocation function, or 0 to restore default function
+        //! \param ff Free function, or 0 to restore default function
+        void set_allocator(alloc_func *af, free_func *ff)
+        {
+            assert(m_begin == m_static_memory && m_ptr == align(m_begin));    // Verify that no memory is allocated yet
+            m_alloc_func = af;
+            m_free_func = ff;
+        }
+
+    private:
+
+        struct header
+        {
+            char *previous_begin;
+        };
+
+        void init()
+        {
+            m_begin = m_static_memory;
+            m_ptr = align(m_begin);
+            m_end = m_static_memory + sizeof(m_static_memory);
+        }
+
+        char *align(char *ptr)
+        {
+            std::size_t alignment = ((RAPIDXML_ALIGNMENT - (std::size_t(ptr) & (RAPIDXML_ALIGNMENT - 1))) & (RAPIDXML_ALIGNMENT - 1));
+            return ptr + alignment;
+        }
+
+        char *allocate_raw(std::size_t size)
+        {
+            // Allocate
+            void *memory;
+            if (m_alloc_func)   // Allocate memory using either user-specified allocation function or global operator new[]
+            {
+                memory = m_alloc_func(size);
+                assert(memory); // Allocator is not allowed to return 0, on failure it must either throw, stop the program or use longjmp
+            }
+            else
+            {
+                memory = new char[size];
+#ifdef RAPIDXML_NO_EXCEPTIONS
+                if (!memory)            // If exceptions are disabled, verify memory allocation, because new will not be able to throw bad_alloc
+                    RAPIDXML_PARSE_ERROR("out of memory", 0);
+#endif
+            }
+            return static_cast<char *>(memory);
+        }
+
+        void *allocate_aligned(std::size_t size)
+        {
+            // Calculate aligned pointer
+            char *result = align(m_ptr);
+
+            // If not enough memory left in current pool, allocate a new pool
+            if (result + size > m_end)
+            {
+                // Calculate required pool size (may be bigger than RAPIDXML_DYNAMIC_POOL_SIZE)
+                std::size_t pool_size = RAPIDXML_DYNAMIC_POOL_SIZE;
+                if (pool_size < size)
+                    pool_size = size;
+
+                // Allocate
+                std::size_t alloc_size = sizeof(header) + (2 * RAPIDXML_ALIGNMENT - 2) + pool_size;     // 2 alignments required in worst case: one for header, one for actual allocation
+                char *raw_memory = allocate_raw(alloc_size);
+
+                // Setup new pool in allocated memory
+                char *pool = align(raw_memory);
+                header *new_header = reinterpret_cast<header *>(pool);
+                new_header->previous_begin = m_begin;
+                m_begin = raw_memory;
+                m_ptr = pool + sizeof(header);
+                m_end = raw_memory + alloc_size;
+
+                // Calculate aligned pointer again using new pool
+                result = align(m_ptr);
+            }
+
+            // Update pool and return aligned pointer
+            m_ptr = result + size;
+            return result;
+        }
+
+        char *m_begin;                                      // Start of raw memory making up current pool
+        char *m_ptr;                                        // First free byte in current pool
+        char *m_end;                                        // One past last available byte in current pool
+        char m_static_memory[RAPIDXML_STATIC_POOL_SIZE];    // Static raw memory
+        alloc_func *m_alloc_func;                           // Allocator function, or 0 if default is to be used
+        free_func *m_free_func;                             // Free function, or 0 if default is to be used
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    // XML base
+
+    //! Base class for xml_node and xml_attribute implementing common functions:
+    //! name(), name_size(), value(), value_size() and parent().
+    //! \param Ch Character type to use
+    template<class Ch = char>
+    class xml_base
+    {
+
+    public:
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Construction & destruction
+
+        // Construct a base with empty name, value and parent
+        xml_base()
+            : m_local_name(0)
+            , m_name(0)
+            , m_namespace_uri(0)
+            , m_value(0)
+            , m_parent(0)
+        {
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Node data access
+
+        Ch *local_name() const
+        {
+            return m_local_name ? m_local_name : nullstr();
+        }
+
+        std::size_t local_name_size() const
+        {
+            return m_local_name ? (m_name_size - (m_local_name - m_name)) : 0;
+        }
+
+        //! Gets namespace prefix.
+        //! Returned string is never zero-terminated, regardless of parse_no_string_terminators. Use prefix_size()
+        //! "Note that the prefix functions only as a placeholder for a namespace name. Applications
+        //! SHOULD use the namespace name, not the prefix, in constructing names whose scope extends beyond the containing
+        //! document" Namespaces in XML 1.0 (Third Edition)
+        Ch *prefix() const
+        {
+            return m_name ? m_name : nullstr();
+        }
+
+        //! Gets size of namespace prefix, not including terminator character.
+        //! \return Size of namespace prefix, in characters.
+        std::size_t prefix_size() const
+        {
+            return (m_name && m_local_name > m_name) ? (m_local_name - m_name - 1) : 0;
+        }
+
+        //! Gets QName of the node.
+        //! Interpretation of name depends on type of node.
+        //! Note that name will not be zero-terminated if rapidxml_ns::parse_no_string_terminators option was selected during parse.
+        //! <br><br>
+        //! Use name_size() function to determine length of the name.
+        //! \return Name of node, or empty string if node has no name.
+        Ch *name() const
+        {
+            return m_name ? m_name : nullstr();
+        }
+
+        //! Gets size of node QName, not including terminator character.
+        //! This function works correctly irrespective of whether name is or is not zero terminated.
+        //! \return Size of node name, in characters.
+        std::size_t name_size() const
+        {
+            return m_name ? m_name_size : 0;
+        }
+
+        //! Gets value of node.
+        //! Interpretation of value depends on type of node.
+        //! Note that value will not be zero-terminated if rapidxml_ns::parse_no_string_terminators option was selected during parse.
+        //! <br><br>
+        //! Use value_size() function to determine length of the value.
+        //! \return Value of node, or empty string if node has no value.
+        Ch *value() const
+        {
+            return m_value ? m_value : nullstr();
+        }
+
+        //! Gets size of node value, not including terminator character.
+        //! This function works correctly irrespective of whether value is or is not zero terminated.
+        //! \return Size of node value, in characters.
+        std::size_t value_size() const
+        {
+            return m_value ? m_value_size : 0;
+        }
+
+        //! Gets namespace URI of the node.
+        //! Note that URI will not be zero-terminated if rapidxml_ns::parse_no_string_terminators option was selected during parse.
+        //! Namespace URI is not assigned if rapidxml_ns::parse_no_namespace option was selected during parse.
+        //! <br><br>
+        //! Use namespace_uri_size() function to determine length of the name.
+        //! \return Namespace URI of node, or empty string if node has no namespace assigned.
+        Ch const *namespace_uri() const
+        {
+            return m_namespace_uri ? m_namespace_uri : nullstr();
+        }
+
+        //! Gets size of namespace URI value, not including terminator character.
+        //! This function works correctly irrespective of whether namespace URI is or is not zero terminated.
+        //! \return Size of namespace URI, in characters.
+        std::size_t namespace_uri_size() const
+        {
+            return m_namespace_uri ? m_namespace_uri_size : 0;
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Node modification
+
+        //! Sets QName of node to a non zero-terminated string.
+        //! See \ref ownership_of_strings.
+        //! <br><br>
+        //! Note that node does not own its name or value, it only stores a pointer to it.
+        //! It will not delete or otherwise free the pointer on destruction.
+        //! It is reponsibility of the user to properly manage lifetime of the string.
+        //! The easiest way to achieve it is to use memory_pool of the document to allocate the string -
+        //! on destruction of the document the string will be automatically freed.
+        //! <br><br>
+        //! Note that passed string will not be automatically divided to prefix and local_name,
+        //! it seems useless for manual node creation. qname() may be used instead
+        //! local_name() will be set to be equal to name()
+        //! <br><br>
+        //! Size of name must be specified separately, because name does not have to be zero terminated.
+        //! Use name(const Ch *) function to have the length automatically calculated (string must be zero terminated).
+        //! \param name QName of node to set. Does not have to be zero terminated.
+        //! \param size Size of name, in characters. This does not include zero terminator, if one is present.
+        void name(const Ch *name, std::size_t size)
+        {
+            qname(name, size);
+        }
+
+        //! Sets QName of node to a zero-terminated string.
+        //! See also \ref ownership_of_strings and xml_node::name(const Ch *, std::size_t).
+        //! \param name Name of node to set. Must be zero terminated.
+        void name(const Ch *name)
+        {
+            this->name(name, internal::measure(name));
+        }
+
+        //! Sets QName as PrefixedName or UnprefixedName where local_part points in QName string
+        void qname(const Ch *qname, std::size_t qname_size, const Ch * local_part)
+        {
+            m_name = const_cast<Ch *>(qname);
+            m_name_size = qname_size;
+            m_local_name = const_cast<Ch *>(local_part);
+        }
+
+        //! Sets QName as UnprefixedName
+        void qname(const Ch *qname, std::size_t qname_size)
+        {
+            m_name = const_cast<Ch *>(qname);
+            m_name_size = qname_size;
+            m_local_name = m_name;
+        }
+
+        void namespace_uri(const Ch *uri, std::size_t size)
+        {
+            m_namespace_uri = uri;
+            m_namespace_uri_size = size;
+        }
+
+        //! Sets value of node to a non zero-terminated string.
+        //! See \ref ownership_of_strings.
+        //! <br><br>
+        //! Note that node does not own its name or value, it only stores a pointer to it.
+        //! It will not delete or otherwise free the pointer on destruction.
+        //! It is responsibility of the user to properly manage lifetime of the string.
+        //! The easiest way to achieve it is to use memory_pool of the document to allocate the string -
+        //! on destruction of the document the string will be automatically freed.
+        //! <br><br>
+        //! Size of value must be specified separately, because it does not have to be zero terminated.
+        //! Use value(const Ch *) function to have the length automatically calculated (string must be zero terminated).
+        //! <br><br>
+        //! If an element has a child node of type node_data, it will take precedence over element value when printing.
+        //! If you want to manipulate data of elements using values, use parser flag rapidxml_ns::parse_no_data_nodes to prevent creation of data nodes by the parser.
+        //! \param value value of node to set. Does not have to be zero terminated.
+        //! \param size Size of value, in characters. This does not include zero terminator, if one is present.
+        void value(const Ch *value, std::size_t size)
+        {
+            m_value = const_cast<Ch *>(value);
+            m_value_size = size;
+        }
+
+        //! Sets value of node to a zero-terminated string.
+        //! See also \ref ownership_of_strings and xml_node::value(const Ch *, std::size_t).
+        //! \param value Vame of node to set. Must be zero terminated.
+        void value(const Ch *value)
+        {
+            this->value(value, internal::measure(value));
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Related nodes access
+
+        //! Gets node parent.
+        //! \return Pointer to parent node, or 0 if there is no parent.
+        xml_node<Ch> *parent() const
+        {
+            return m_parent;
+        }
+
+    protected:
+
+        // Return empty string
+        static Ch *nullstr()
+        {
+            static Ch zero = Ch('\0');
+            return &zero;
+        }
+
+        Ch *m_local_name;                   // Pointer into m_name where local part begins
+        Ch *m_name;                         // Name of node, or 0 if no name
+        Ch *m_value;                        // Value of node, or 0 if no value
+        Ch const *m_namespace_uri;
+        std::size_t m_name_size;            // Length of node name, or undefined of no name
+        std::size_t m_value_size;           // Length of node value, or undefined if no value
+        std::size_t m_namespace_uri_size;
+        xml_node<Ch> *m_parent;             // Pointer to parent node, or 0 if none
+
+    };
+
+    //! Class representing attribute node of XML document.
+    //! Each attribute has name and value strings, which are available through name() and value() functions (inherited from xml_base).
+    //! Note that after parse, both name and value of attribute will point to interior of source text used for parsing.
+    //! Thus, this text must persist in memory for the lifetime of attribute.
+    //! \param Ch Character type to use.
+    template<class Ch = char>
+    class xml_attribute: public xml_base<Ch>
+    {
+
+        friend class xml_node<Ch>;
+
+    public:
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Construction & destruction
+
+        //! Constructs an empty attribute with the specified type.
+        //! Consider using memory_pool of appropriate xml_document if allocating attributes manually.
+        xml_attribute()
+        {
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Related nodes access
+
+        //! Gets document of which attribute is a child.
+        //! \return Pointer to document that contains this attribute, or 0 if there is no parent document.
+        xml_document<Ch> *document() const
+        {
+            if (xml_node<Ch> *node = this->parent())
+            {
+                while (node->parent())
+                    node = node->parent();
+                return node->type() == node_document ? static_cast<xml_document<Ch> *>(node) : 0;
+            }
+            else
+                return 0;
+        }
+
+        //! Gets previous attribute, optionally matching attribute name.
+        //! \param name Name of attribute to find, or 0 to return previous attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found attribute, or 0 if not found.
+        xml_attribute<Ch> *previous_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_attribute<Ch> *attribute = m_prev_attribute; attribute; attribute = attribute->m_prev_attribute)
+                    if (internal::compare(attribute->name(), attribute->name_size(), name, name_size, case_sensitive))
+                        return attribute;
+                return 0;
+            }
+            else
+                return this->m_parent ? m_prev_attribute : 0;
+        }
+
+        //! Gets next attribute, optionally matching attribute name.
+        //! \param name Name of attribute to find, or 0 to return next attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found attribute, or 0 if not found.
+        xml_attribute<Ch> *next_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_attribute<Ch> *attribute = m_next_attribute; attribute; attribute = attribute->m_next_attribute)
+                    if (internal::compare(attribute->name(), attribute->name_size(), name, name_size, case_sensitive))
+                        return attribute;
+                return 0;
+            }
+            else
+                return this->m_parent ? m_next_attribute : 0;
+        }
+
+        //! Gets next attribute, matching attribute local name and attribute namespace URI .
+        //! \param namespace_uri Namespace URI of attribute to find; this string have to be zero-terminated
+        //! \param local_name Local name of attribute to find; this string have to be zero-terminated
+        //! \param local_name_case_sensitive Should local name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found attribute, or 0 if not found.
+        xml_attribute<Ch> *next_attribute_ns(const Ch * namespace_uri, const Ch *local_name,
+                                             bool local_name_case_sensitive = true) const
+        {
+            return next_attribute_ns(namespace_uri, internal::measure(namespace_uri),
+                local_name, internal::measure(local_name), local_name_case_sensitive);
+        }
+
+        xml_attribute<Ch> *next_attribute_ns(const Ch * namespace_uri, std::size_t namespace_uri_size,
+                                             const Ch *local_name,     std::size_t local_name_size,
+                                             bool local_name_case_sensitive = true) const
+        {
+            for (xml_attribute<Ch> *attribute = m_next_attribute; attribute; attribute = attribute->m_next_attribute)
+                if (internal::compare(attribute->local_name(), attribute->local_name_size(),
+                        local_name, local_name_size, local_name_case_sensitive)
+                    && internal::compare(attribute->namespace_uri(), attribute->namespace_uri_size(),
+                        namespace_uri, namespace_uri_size))
+                    return attribute;
+            return 0;
+        }
+
+    private:
+
+        xml_attribute<Ch> *m_prev_attribute;        // Pointer to previous sibling of attribute, or 0 if none; only valid if parent is non-zero
+        xml_attribute<Ch> *m_next_attribute;        // Pointer to next sibling of attribute, or 0 if none; only valid if parent is non-zero
+
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    // XML node
+
+    //! Class representing a node of XML document.
+    //! Each node may have associated name and value strings, which are available through name() and value() functions.
+    //! Interpretation of name and value depends on type of the node.
+    //! Type of node can be determined by using type() function.
+    //! <br><br>
+    //! Note that after parse, both name and value of node, if any, will point interior of source text used for parsing.
+    //! Thus, this text must persist in the memory for the lifetime of node.
+    //! \param Ch Character type to use.
+    template<class Ch = char>
+    class xml_node: public xml_base<Ch>
+    {
+
+    public:
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Construction & destruction
+
+        //! Constructs an empty node with the specified type.
+        //! Consider using memory_pool of appropriate document to allocate nodes manually.
+        //! \param type Type of node to construct.
+        xml_node(node_type type)
+            : m_type(type)
+            , m_first_node(0)
+            , m_first_attribute(0)
+        {
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Node data access
+
+        //! Gets type of node.
+        //! \return Type of node.
+        node_type type() const
+        {
+            return m_type;
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Related nodes access
+
+        //! Gets document of which node is a child.
+        //! \return Pointer to document that contains this node, or 0 if there is no parent document.
+        xml_document<Ch> *document() const
+        {
+            xml_node<Ch> *node = const_cast<xml_node<Ch> *>(this);
+            while (node->parent())
+                node = node->parent();
+            return node->type() == node_document ? static_cast<xml_document<Ch> *>(node) : 0;
+        }
+
+        //! Gets first child node, optionally matching node name.
+        //! \param name Name of child to find, or 0 to return first child regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found child, or 0 if not found.
+        xml_node<Ch> *first_node(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_node<Ch> *child = m_first_node; child; child = child->next_sibling())
+                    if (internal::compare(child->name(), child->name_size(), name, name_size, case_sensitive))
+                        return child;
+                return 0;
+            }
+            else
+                return m_first_node;
+        }
+
+        //! Gets first child node, matching node local name and namespace URI.
+        //! \param namespace_uri Namespace URI of child to find; this string have to be zero-terminated
+        //! \param local_name Local name of child to find; this string have to be zero-terminated
+        //! \param local_name_case_sensitive Should local name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found child, or 0 if not found.
+        xml_node<Ch> *first_node_ns(const Ch * namespace_uri, const Ch *local_name,
+                                    bool local_name_case_sensitive = true) const
+        {
+            return first_node_ns(namespace_uri, internal::measure(namespace_uri),
+                local_name, internal::measure(local_name), local_name_case_sensitive);
+        }
+
+        xml_node<Ch> *first_node_ns(const Ch *namespace_uri,  std::size_t namespace_uri_size,
+                                    const Ch *local_name,     std::size_t local_name_size,
+                                    bool local_name_case_sensitive = true) const
+        {
+            for (xml_node<Ch> *child = m_first_node; child; child = child->next_sibling())
+                if (internal::compare(child->local_name(), child->local_name_size(),
+                        local_name, local_name_size, local_name_case_sensitive)
+                    && internal::compare(child->namespace_uri(), child->namespace_uri_size(),
+                        namespace_uri, namespace_uri_size))
+                    return child;
+            return 0;
+        }
+
+        xml_node<Ch> *first_node_ns(const Ch *namespace_uri, std::size_t namespace_uri_size = 0) const
+        {
+            if (namespace_uri_size == 0)
+                namespace_uri_size = internal::measure(namespace_uri);
+            for (xml_node<Ch> *child = m_first_node; child; child = child->next_sibling())
+                if (internal::compare(child->namespace_uri(), child->namespace_uri_size(), namespace_uri, namespace_uri_size))
+                    return child;
+            return 0;
+        }
+
+        //! Gets last child node, optionally matching node name.
+        //! Behaviour is undefined if node has no children.
+        //! Use first_node() to test if node has children.
+        //! \param name Name of child to find, or 0 to return last child regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found child, or 0 if not found.
+        xml_node<Ch> *last_node(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            assert(m_first_node);  // Cannot query for last child if node has no children
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_node<Ch> *child = m_last_node; child; child = child->previous_sibling())
+                    if (internal::compare(child->name(), child->name_size(), name, name_size, case_sensitive))
+                        return child;
+                return 0;
+            }
+            else
+                return m_last_node;
+        }
+
+        //! Gets previous sibling node, optionally matching node name.
+        //! Behaviour is undefined if node has no parent.
+        //! Use parent() to test if node has a parent.
+        //! \param name Name of sibling to find, or 0 to return previous sibling regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found sibling, or 0 if not found.
+        xml_node<Ch> *previous_sibling(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            assert(this->m_parent);     // Cannot query for siblings if node has no parent
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_node<Ch> *sibling = m_prev_sibling; sibling; sibling = sibling->m_prev_sibling)
+                    if (internal::compare(sibling->name(), sibling->name_size(), name, name_size, case_sensitive))
+                        return sibling;
+                return 0;
+            }
+            else
+                return m_prev_sibling;
+        }
+
+        //! Gets next sibling node, optionally matching node name.
+        //! Behaviour is undefined if node has no parent.
+        //! Use parent() to test if node has a parent.
+        //! \param name Name of sibling to find, or 0 to return next sibling regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found sibling, or 0 if not found.
+        xml_node<Ch> *next_sibling(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            assert(this->m_parent);     // Cannot query for siblings if node has no parent
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_node<Ch> *sibling = m_next_sibling; sibling; sibling = sibling->m_next_sibling)
+                    if (internal::compare(sibling->name(), sibling->name_size(), name, name_size, case_sensitive))
+                        return sibling;
+                return 0;
+            }
+            else
+                return m_next_sibling;
+        }
+
+        xml_node<Ch> *next_sibling_ns(const Ch * namespace_uri, const Ch *local_name,
+                                      bool local_name_case_sensitive = true) const
+        {
+            return next_sibling_ns(namespace_uri, internal::measure(namespace_uri),
+                local_name, internal::measure(local_name), local_name_case_sensitive);
+        }
+
+        xml_node<Ch> *next_sibling_ns(const Ch * namespace_uri, std::size_t namespace_uri_size,
+                                      const Ch *local_name,     std::size_t local_name_size,
+                                      bool local_name_case_sensitive = true) const
+        {
+            for (xml_node<Ch> *sibling = m_next_sibling; sibling; sibling = sibling->m_next_sibling)
+                if (internal::compare(sibling->local_name(), sibling->local_name_size(),
+                        local_name, local_name_size, local_name_case_sensitive)
+                    && internal::compare(sibling->namespace_uri(), sibling->namespace_uri_size(),
+                        namespace_uri, namespace_uri_size))
+                    return sibling;
+            return 0;
+        }
+
+        xml_node<Ch> *next_sibling_ns(const Ch *namespace_uri, std::size_t namespace_uri_size = 0) const
+        {
+            if (namespace_uri_size == 0)
+                namespace_uri_size = internal::measure(namespace_uri);
+            for (xml_node<Ch> *sibling = m_next_sibling; sibling; sibling = sibling->m_next_sibling)
+                if (internal::compare(sibling->namespace_uri(), sibling->namespace_uri_size(), namespace_uri, namespace_uri_size))
+                    return sibling;
+            return 0;
+        }
+
+        //! Gets first attribute of node, optionally matching attribute name.
+        //! \param name Name of attribute to find, or 0 to return first attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found attribute, or 0 if not found.
+        xml_attribute<Ch> *first_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_attribute<Ch> *attribute = m_first_attribute; attribute; attribute = attribute->m_next_attribute)
+                    if (internal::compare(attribute->name(), attribute->name_size(), name, name_size, case_sensitive))
+                        return attribute;
+                return 0;
+            }
+            else
+                return m_first_attribute;
+        }
+
+        //! Gets first attribute of node, matching attribute namespace URI and local name.
+        //! \param namespace_uri Namespace URI of attribute to find; this string have to be zero-terminated
+        //! \param local_name Local name of attribute to find; this string have to be zero-terminated
+        //! \param local_name_case_sensitive Should local name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found attribute, or 0 if not found.
+        xml_attribute<Ch> *first_attribute_ns(const Ch * namespace_uri, const Ch *local_name,
+                                             bool local_name_case_sensitive = true) const
+        {
+            return first_attribute_ns(namespace_uri, internal::measure(namespace_uri),
+                local_name, internal::measure(local_name), local_name_case_sensitive);
+        }
+
+        xml_attribute<Ch> *first_attribute_ns(const Ch * namespace_uri, std::size_t namespace_uri_size,
+                                             const Ch *local_name,     std::size_t local_name_size,
+                                             bool local_name_case_sensitive = true) const
+        {
+            for (xml_attribute<Ch> *attribute = m_first_attribute; attribute; attribute = attribute->m_next_attribute)
+                if (internal::compare(attribute->local_name(), attribute->local_name_size(),
+                        local_name, local_name_size, local_name_case_sensitive)
+                    && internal::compare(attribute->namespace_uri(), attribute->namespace_uri_size(),
+                        namespace_uri, namespace_uri_size))
+                    return attribute;
+            return 0;
+        }
+
+        //! Gets last attribute of node, optionally matching attribute name.
+        //! \param name Name of attribute to find, or 0 to return last attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found attribute, or 0 if not found.
+        xml_attribute<Ch> *last_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_attribute<Ch> *attribute = m_last_attribute; attribute; attribute = attribute->m_prev_attribute)
+                    if (internal::compare(attribute->name(), attribute->name_size(), name, name_size, case_sensitive))
+                        return attribute;
+                return 0;
+            }
+            else
+                return m_first_attribute ? m_last_attribute : 0;
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Node modification
+
+        //! Sets type of node.
+        //! \param type Type of node to set.
+        void type(node_type type)
+        {
+            m_type = type;
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Node manipulation
+
+        //! Prepends a new child node.
+        //! The prepended child becomes the first child, and all existing children are moved one position back.
+        //! \param child Node to prepend.
+        void prepend_node(xml_node<Ch> *child)
+        {
+            assert(child && !child->parent() && child->type() != node_document);
+            if (first_node())
+            {
+                child->m_next_sibling = m_first_node;
+                m_first_node->m_prev_sibling = child;
+            }
+            else
+            {
+                child->m_next_sibling = 0;
+                m_last_node = child;
+            }
+            m_first_node = child;
+            child->m_parent = this;
+            child->m_prev_sibling = 0;
+        }
+
+        //! Appends a new child node.
+        //! The appended child becomes the last child.
+        //! \param child Node to append.
+        void append_node(xml_node<Ch> *child)
+        {
+            assert(child && !child->parent() && child->type() != node_document);
+            if (first_node())
+            {
+                child->m_prev_sibling = m_last_node;
+                m_last_node->m_next_sibling = child;
+            }
+            else
+            {
+                child->m_prev_sibling = 0;
+                m_first_node = child;
+            }
+            m_last_node = child;
+            child->m_parent = this;
+            child->m_next_sibling = 0;
+        }
+
+        //! Inserts a new child node at specified place inside the node.
+        //! All children after and including the specified node are moved one position back.
+        //! \param where Place where to insert the child, or 0 to insert at the back.
+        //! \param child Node to insert.
+        void insert_node(xml_node<Ch> *where, xml_node<Ch> *child)
+        {
+            assert(!where || where->parent() == this);
+            assert(child && !child->parent() && child->type() != node_document);
+            if (where == m_first_node)
+                prepend_node(child);
+            else if (where == 0)
+                append_node(child);
+            else
+            {
+                child->m_prev_sibling = where->m_prev_sibling;
+                child->m_next_sibling = where;
+                where->m_prev_sibling->m_next_sibling = child;
+                where->m_prev_sibling = child;
+                child->m_parent = this;
+            }
+        }
+
+        //! Removes first child node.
+        //! If node has no children, behaviour is undefined.
+        //! Use first_node() to test if node has children.
+        void remove_first_node()
+        {
+            assert(first_node());
+            xml_node<Ch> *child = m_first_node;
+            m_first_node = child->m_next_sibling;
+            if (child->m_next_sibling)
+                child->m_next_sibling->m_prev_sibling = 0;
+            else
+                m_last_node = 0;
+            child->m_parent = 0;
+        }
+
+        //! Removes last child of the node.
+        //! If node has no children, behaviour is undefined.
+        //! Use first_node() to test if node has children.
+        void remove_last_node()
+        {
+            assert(first_node());
+            xml_node<Ch> *child = m_last_node;
+            if (child->m_prev_sibling)
+            {
+                m_last_node = child->m_prev_sibling;
+                child->m_prev_sibling->m_next_sibling = 0;
+            }
+            else
+                m_first_node = 0;
+            child->m_parent = 0;
+        }
+
+        //! Removes specified child from the node
+        // \param where Pointer to child to be removed.
+        void remove_node(xml_node<Ch> *where)
+        {
+            assert(where && where->parent() == this);
+            assert(first_node());
+            if (where == m_first_node)
+                remove_first_node();
+            else if (where == m_last_node)
+                remove_last_node();
+            else
+            {
+                where->m_prev_sibling->m_next_sibling = where->m_next_sibling;
+                where->m_next_sibling->m_prev_sibling = where->m_prev_sibling;
+                where->m_parent = 0;
+            }
+        }
+
+        //! Removes all child nodes (but not attributes).
+        void remove_all_nodes()
+        {
+            for (xml_node<Ch> *node = first_node(); node; node = node->m_next_sibling)
+                node->m_parent = 0;
+            m_first_node = 0;
+        }
+
+        //! Prepends a new attribute to the node.
+        //! \param attribute Attribute to prepend.
+        void prepend_attribute(xml_attribute<Ch> *attribute)
+        {
+            assert(attribute && !attribute->parent());
+            if (first_attribute())
+            {
+                attribute->m_next_attribute = m_first_attribute;
+                m_first_attribute->m_prev_attribute = attribute;
+            }
+            else
+            {
+                attribute->m_next_attribute = 0;
+                m_last_attribute = attribute;
+            }
+            m_first_attribute = attribute;
+            attribute->m_parent = this;
+            attribute->m_prev_attribute = 0;
+        }
+
+        //! Appends a new attribute to the node.
+        //! \param attribute Attribute to append.
+        void append_attribute(xml_attribute<Ch> *attribute)
+        {
+            assert(attribute && !attribute->parent());
+            if (first_attribute())
+            {
+                attribute->m_prev_attribute = m_last_attribute;
+                m_last_attribute->m_next_attribute = attribute;
+            }
+            else
+            {
+                attribute->m_prev_attribute = 0;
+                m_first_attribute = attribute;
+            }
+            m_last_attribute = attribute;
+            attribute->m_parent = this;
+            attribute->m_next_attribute = 0;
+        }
+
+        //! Inserts a new attribute at specified place inside the node.
+        //! All attributes after and including the specified attribute are moved one position back.
+        //! \param where Place where to insert the attribute, or 0 to insert at the back.
+        //! \param attribute Attribute to insert.
+        void insert_attribute(xml_attribute<Ch> *where, xml_attribute<Ch> *attribute)
+        {
+            assert(!where || where->parent() == this);
+            assert(attribute && !attribute->parent());
+            if (where == m_first_attribute)
+                prepend_attribute(attribute);
+            else if (where == 0)
+                append_attribute(attribute);
+            else
+            {
+                attribute->m_prev_attribute = where->m_prev_attribute;
+                attribute->m_next_attribute = where;
+                where->m_prev_attribute->m_next_attribute = attribute;
+                where->m_prev_attribute = attribute;
+                attribute->m_parent = this;
+            }
+        }
+
+        //! Removes first attribute of the node.
+        //! If node has no attributes, behaviour is undefined.
+        //! Use first_attribute() to test if node has attributes.
+        void remove_first_attribute()
+        {
+            assert(first_attribute());
+            xml_attribute<Ch> *attribute = m_first_attribute;
+            if (attribute->m_next_attribute)
+            {
+                attribute->m_next_attribute->m_prev_attribute = 0;
+            }
+            else
+                m_last_attribute = 0;
+            attribute->m_parent = 0;
+            m_first_attribute = attribute->m_next_attribute;
+        }
+
+        //! Removes last attribute of the node.
+        //! If node has no attributes, behaviour is undefined.
+        //! Use first_attribute() to test if node has attributes.
+        void remove_last_attribute()
+        {
+            assert(first_attribute());
+            xml_attribute<Ch> *attribute = m_last_attribute;
+            if (attribute->m_prev_attribute)
+            {
+                attribute->m_prev_attribute->m_next_attribute = 0;
+                m_last_attribute = attribute->m_prev_attribute;
+            }
+            else
+                m_first_attribute = 0;
+            attribute->m_parent = 0;
+        }
+
+        //! Removes specified attribute from node.
+        //! \param where Pointer to attribute to be removed.
+        void remove_attribute(xml_attribute<Ch> *where)
+        {
+            assert(first_attribute() && where->parent() == this);
+            if (where == m_first_attribute)
+                remove_first_attribute();
+            else if (where == m_last_attribute)
+                remove_last_attribute();
+            else
+            {
+                where->m_prev_attribute->m_next_attribute = where->m_next_attribute;
+                where->m_next_attribute->m_prev_attribute = where->m_prev_attribute;
+                where->m_parent = 0;
+            }
+        }
+
+        //! Removes all attributes of node.
+        void remove_all_attributes()
+        {
+            for (xml_attribute<Ch> *attribute = first_attribute(); attribute; attribute = attribute->m_next_attribute)
+                attribute->m_parent = 0;
+            m_first_attribute = 0;
+        }
+
+    private:
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Restrictions
+
+        // No copying
+        xml_node(const xml_node &);
+        void operator =(const xml_node &);
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Data members
+
+        // Note that some of the pointers below have UNDEFINED values if certain other pointers are 0.
+        // This is required for maximum performance, as it allows the parser to omit initialization of
+        // unneded/redundant values.
+        //
+        // The rules are as follows:
+        // 1. first_node and first_attribute contain valid pointers, or 0 if node has no children/attributes respectively
+        // 2. last_node and last_attribute are valid only if node has at least one child/attribute respectively, otherwise they contain garbage
+        // 3. prev_sibling and next_sibling are valid only if node has a parent, otherwise they contain garbage
+
+        node_type m_type;                       // Type of node; always valid
+        xml_node<Ch> *m_first_node;             // Pointer to first child node, or 0 if none; always valid
+        xml_node<Ch> *m_last_node;              // Pointer to last child node, or 0 if none; this value is only valid if m_first_node is non-zero
+        xml_attribute<Ch> *m_first_attribute;   // Pointer to first attribute of node, or 0 if none; always valid
+        xml_attribute<Ch> *m_last_attribute;    // Pointer to last attribute of node, or 0 if none; this value is only valid if m_first_attribute is non-zero
+        xml_node<Ch> *m_prev_sibling;           // Pointer to previous sibling of node, or 0 if none; this value is only valid if m_parent is non-zero
+        xml_node<Ch> *m_next_sibling;           // Pointer to next sibling of node, or 0 if none; this value is only valid if m_parent is non-zero
+
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    // XML document
+
+    //! This class represents root of the DOM hierarchy.
+    //! It is also an xml_node and a memory_pool through public inheritance.
+    //! Use parse() function to build a DOM tree from a zero-terminated XML text string.
+    //! parse() function allocates memory for nodes and attributes by using functions of xml_document,
+    //! which are inherited from memory_pool.
+    //! To access root node of the document, use the document itself, as if it was an xml_node.
+    //! \param Ch Character type to use.
+    template<class Ch = char>
+    class xml_document: public xml_node<Ch>, public memory_pool<Ch>
+    {
+
+    public:
+
+        //! Constructs empty XML document
+        xml_document()
+            : xml_node<Ch>(node_document)
+        {
+        }
+
+        //! Parses zero-terminated XML string according to given flags.
+        //! Passed string will be modified by the parser, unless rapidxml_ns::parse_non_destructive flag is used.
+        //! The string must persist for the lifetime of the document.
+        //! In case of error, rapidxml_ns::parse_error exception will be thrown.
+        //! <br><br>
+        //! If you want to parse contents of a file, you must first load the file into the memory, and pass pointer to its beginning.
+        //! Make sure that data is zero-terminated.
+        //! <br><br>
+        //! Document can be parsed into multiple times.
+        //! Each new call to parse removes previous nodes and attributes (if any), but does not clear memory pool.
+        //! \param text XML data to parse; pointer is non-const to denote fact that this data may be modified by the parser.
+        template<int Flags>
+        void parse(Ch *text)
+        {
+            if (Flags & parse_no_namespace)
+                parse_ns<Flags, internal::xml_namespace_processor_stub<Ch> >(text);
+            else
+                parse_ns<Flags, internal::xml_namespace_processor<Ch> >(text);
+        }
+
+        //! Use parse() instead.
+        //! Parses zero-terminated XML string according to given flags and NamespaceProcessor passed.
+        //! Should be called only when default xml_namespace_processor is substituted with custom one.
+        template<int Flags, class NamespaceProcessor>
+        void parse_ns(Ch *text)
+        {
+            assert(text);
+
+            // Remove current contents
+            this->remove_all_nodes();
+            this->remove_all_attributes();
+
+            NamespaceProcessor namespace_processor;
+            // Creating topmost namespace scope that actually won't be used
+            typename NamespaceProcessor::scope const namespace_scope(namespace_processor);
+
+            // Parse BOM, if any
+            parse_bom<Flags>(text);
+
+            // Parse children
+            while (1)
+            {
+                // Skip whitespace before node
+                skip<whitespace_pred, Flags>(text);
+                if (*text == 0)
+                    break;
+
+                // Parse and append new child
+                if (*text == Ch('<'))
+                {
+                    ++text;     // Skip '<'
+                    if (xml_node<Ch> *node = parse_node<Flags, typename NamespaceProcessor::scope>(text, namespace_scope))
+                        this->append_node(node);
+                }
+                else
+                    RAPIDXML_PARSE_ERROR("expected <", text);
+            }
+
+        }
+
+        //! Clears the document by deleting all nodes and clearing the memory pool.
+        //! All nodes owned by document pool are destroyed.
+        void clear()
+        {
+            this->remove_all_nodes();
+            this->remove_all_attributes();
+            memory_pool<Ch>::clear();
+        }
+
+    private:
+
+        ///////////////////////////////////////////////////////////////////////
+        // Internal character utility functions
+
+        // Detect whitespace character
+        struct whitespace_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_whitespace[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect node name character
+        struct node_name_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_node_name[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect node name character without ':' (NCName) - namespace prefix or local name
+        struct node_ncname_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_node_ncname[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect attribute name character
+        struct attribute_name_pred
+        {
+          static unsigned char test(Ch ch)
+          {
+            return internal::lookup_tables<0>::lookup_attribute_name[static_cast<unsigned char>(ch)];
+          }
+        };
+
+        // Detect attribute name character without ':' (NCName) - namespace prefix or local name
+        struct attribute_ncname_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_attribute_ncname[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect text character (PCDATA)
+        struct text_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_text[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect text character (PCDATA) that does not require processing
+        struct text_pure_no_ws_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_text_pure_no_ws[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect text character (PCDATA) that does not require processing
+        struct text_pure_with_ws_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_text_pure_with_ws[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect attribute value character
+        template<Ch Quote>
+        struct attribute_value_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                if (Quote == Ch('\''))
+                    return internal::lookup_tables<0>::lookup_attribute_data_1[static_cast<unsigned char>(ch)];
+                if (Quote == Ch('\"'))
+                    return internal::lookup_tables<0>::lookup_attribute_data_2[static_cast<unsigned char>(ch)];
+                return 0;       // Should never be executed, to avoid warnings on Comeau
+            }
+        };
+
+        // Detect attribute value character
+        template<Ch Quote>
+        struct attribute_value_pure_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                if (Quote == Ch('\''))
+                    return internal::lookup_tables<0>::lookup_attribute_data_1_pure[static_cast<unsigned char>(ch)];
+                if (Quote == Ch('\"'))
+                    return internal::lookup_tables<0>::lookup_attribute_data_2_pure[static_cast<unsigned char>(ch)];
+                return 0;       // Should never be executed, to avoid warnings on Comeau
+            }
+        };
+
+        // Insert coded character, using UTF8 or 8-bit ASCII
+        template<int Flags>
+        static void insert_coded_character(Ch *&text, unsigned long code)
+        {
+            if (Flags & parse_no_utf8)
+            {
+                // Insert 8-bit ASCII character
+                // Todo: possibly verify that code is less than 256 and use replacement char otherwise?
+                text[0] = static_cast<unsigned char>(code);
+                text += 1;
+            }
+            else
+            {
+                // Insert UTF8 sequence
+                if (code < 0x80)    // 1 byte sequence
+                {
+	                text[0] = static_cast<unsigned char>(code);
+                    text += 1;
+                }
+                else if (code < 0x800)  // 2 byte sequence
+                {
+	                text[1] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;
+	                text[0] = static_cast<unsigned char>(code | 0xC0);
+                    text += 2;
+                }
+	            else if (code < 0x10000)    // 3 byte sequence
+                {
+	                text[2] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;
+	                text[1] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;
+	                text[0] = static_cast<unsigned char>(code | 0xE0);
+                    text += 3;
+                }
+	            else if (code < 0x110000)   // 4 byte sequence
+                {
+	                text[3] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;
+	                text[2] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;
+	                text[1] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;
+	                text[0] = static_cast<unsigned char>(code | 0xF0);
+                    text += 4;
+                }
+                else    // Invalid, only codes up to 0x10FFFF are allowed in Unicode
+                {
+                    RAPIDXML_PARSE_ERROR("invalid numeric character entity", text);
+                }
+            }
+        }
+
+        // Skip characters until predicate evaluates to true
+        template<class StopPred, int Flags>
+        static void skip(Ch *&text)
+        {
+            Ch *tmp = text;
+            while (StopPred::test(*tmp))
+                ++tmp;
+            text = tmp;
+        }
+
+        // Skip characters until predicate evaluates to true while doing the following:
+        // - replacing XML character entity references with proper characters (&apos; &amp; &quot; &lt; &gt; &#...;)
+        // - condensing whitespace sequences to single space character
+        template<class StopPred, class StopPredPure, int Flags>
+        static Ch *skip_and_expand_character_refs(Ch *&text)
+        {
+            // If entity translation, whitespace condense and whitespace trimming is disabled, use plain skip
+            if (Flags & parse_no_entity_translation &&
+                !(Flags & parse_normalize_whitespace) &&
+                !(Flags & parse_trim_whitespace))
+            {
+                skip<StopPred, Flags>(text);
+                return text;
+            }
+
+            // Use simple skip until first modification is detected
+            skip<StopPredPure, Flags>(text);
+
+            // Use translation skip
+            Ch *src = text;
+            Ch *dest = src;
+            while (StopPred::test(*src))
+            {
+                // If entity translation is enabled
+                if (!(Flags & parse_no_entity_translation))
+                {
+                    // Test if replacement is needed
+                    if (src[0] == Ch('&'))
+                    {
+                        switch (src[1])
+                        {
+
+                        // &amp; &apos;
+                        case Ch('a'):
+                            if (src[2] == Ch('m') && src[3] == Ch('p') && src[4] == Ch(';'))
+                            {
+                                *dest = Ch('&');
+                                ++dest;
+                                src += 5;
+                                continue;
+                            }
+                            if (src[2] == Ch('p') && src[3] == Ch('o') && src[4] == Ch('s') && src[5] == Ch(';'))
+                            {
+                                *dest = Ch('\'');
+                                ++dest;
+                                src += 6;
+                                continue;
+                            }
+                            break;
+
+                        // &quot;
+                        case Ch('q'):
+                            if (src[2] == Ch('u') && src[3] == Ch('o') && src[4] == Ch('t') && src[5] == Ch(';'))
+                            {
+                                *dest = Ch('"');
+                                ++dest;
+                                src += 6;
+                                continue;
+                            }
+                            break;
+
+                        // &gt;
+                        case Ch('g'):
+                            if (src[2] == Ch('t') && src[3] == Ch(';'))
+                            {
+                                *dest = Ch('>');
+                                ++dest;
+                                src += 4;
+                                continue;
+                            }
+                            break;
+
+                        // &lt;
+                        case Ch('l'):
+                            if (src[2] == Ch('t') && src[3] == Ch(';'))
+                            {
+                                *dest = Ch('<');
+                                ++dest;
+                                src += 4;
+                                continue;
+                            }
+                            break;
+
+                        // &#...; - assumes ASCII
+                        case Ch('#'):
+                            if (src[2] == Ch('x'))
+                            {
+                                unsigned long code = 0;
+                                src += 3;   // Skip &#x
+                                while (1)
+                                {
+                                    unsigned char digit = internal::lookup_tables<0>::lookup_digits[static_cast<unsigned char>(*src)];
+                                    if (digit == 0xFF)
+                                        break;
+                                    code = code * 16 + digit;
+                                    ++src;
+                                }
+                                insert_coded_character<Flags>(dest, code);    // Put character in output
+                            }
+                            else
+                            {
+                                unsigned long code = 0;
+                                src += 2;   // Skip &#
+                                while (1)
+                                {
+                                    unsigned char digit = internal::lookup_tables<0>::lookup_digits[static_cast<unsigned char>(*src)];
+                                    if (digit == 0xFF)
+                                        break;
+                                    code = code * 10 + digit;
+                                    ++src;
+                                }
+                                insert_coded_character<Flags>(dest, code);    // Put character in output
+                            }
+                            if (*src == Ch(';'))
+                                ++src;
+                            else
+                                RAPIDXML_PARSE_ERROR("expected ;", src);
+                            continue;
+
+                        // Something else
+                        default:
+                            // Ignore, just copy '&' verbatim
+                            break;
+
+                        }
+                    }
+                }
+
+                // If whitespace condensing is enabled
+                if (Flags & parse_normalize_whitespace)
+                {
+                    // Test if condensing is needed
+                    if (whitespace_pred::test(*src))
+                    {
+                        *dest = Ch(' '); ++dest;    // Put single space in dest
+                        ++src;                      // Skip first whitespace char
+                        // Skip remaining whitespace chars
+                        while (whitespace_pred::test(*src))
+                            ++src;
+                        continue;
+                    }
+                }
+
+                // No replacement, only copy character
+                *dest++ = *src++;
+
+            }
+
+            // Return new end
+            text = src;
+            return dest;
+
+        }
+
+        ///////////////////////////////////////////////////////////////////////
+        // Internal parsing functions
+
+        // Parse BOM, if any
+        template<int Flags>
+        void parse_bom(Ch *&text)
+        {
+            // UTF-8?
+            if (static_cast<unsigned char>(text[0]) == 0xEF &&
+                static_cast<unsigned char>(text[1]) == 0xBB &&
+                static_cast<unsigned char>(text[2]) == 0xBF)
+            {
+                text += 3;      // Skup utf-8 bom
+            }
+        }
+
+        // Parse XML declaration (<?xml...)
+        template<int Flags>
+        xml_node<Ch> *parse_xml_declaration(Ch *&text)
+        {
+            // If parsing of declaration is disabled
+            if (!(Flags & parse_declaration_node))
+            {
+                // Skip until end of declaration
+                while (text[0] != Ch('?') || text[1] != Ch('>'))
+                {
+                    if (!text[0])
+                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                    ++text;
+                }
+                text += 2;    // Skip '?>'
+                return 0;
+            }
+
+            // Create declaration
+            xml_node<Ch> *declaration = this->allocate_node(node_declaration);
+
+            // Skip whitespace before attributes or ?>
+            skip<whitespace_pred, Flags>(text);
+
+            // Parse declaration attributes
+            parse_node_attributes<Flags>(text, declaration);
+
+            // Skip ?>
+            if (text[0] != Ch('?') || text[1] != Ch('>'))
+                RAPIDXML_PARSE_ERROR("expected ?>", text);
+            text += 2;
+
+            return declaration;
+        }
+
+        // Parse XML comment (<!--...)
+        template<int Flags>
+        xml_node<Ch> *parse_comment(Ch *&text)
+        {
+            // If parsing of comments is disabled
+            if (!(Flags & parse_comment_nodes))
+            {
+                // Skip until end of comment
+                while (text[0] != Ch('-') || text[1] != Ch('-') || text[2] != Ch('>'))
+                {
+                    if (!text[0])
+                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                    ++text;
+                }
+                text += 3;     // Skip '-->'
+                return 0;      // Do not produce comment node
+            }
+
+            // Remember value start
+            Ch *value = text;
+
+            // Skip until end of comment
+            while (text[0] != Ch('-') || text[1] != Ch('-') || text[2] != Ch('>'))
+            {
+                if (!text[0])
+                    RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                ++text;
+            }
+
+            // Create comment node
+            xml_node<Ch> *comment = this->allocate_node(node_comment);
+            comment->value(value, text - value);
+
+            // Place zero terminator after comment value
+            if (!(Flags & parse_no_string_terminators))
+                *text = Ch('\0');
+
+            text += 3;     // Skip '-->'
+            return comment;
+        }
+
+        // Parse DOCTYPE
+        template<int Flags>
+        xml_node<Ch> *parse_doctype(Ch *&text)
+        {
+            // Remember value start
+            Ch *value = text;
+
+            // Skip to >
+            while (*text != Ch('>'))
+            {
+                // Determine character type
+                switch (*text)
+                {
+
+                // If '[' encountered, scan for matching ending ']' using naive algorithm with depth
+                // This works for all W3C test files except for 2 most wicked
+                case Ch('['):
+                {
+                    ++text;     // Skip '['
+                    int depth = 1;
+                    while (depth > 0)
+                    {
+                        switch (*text)
+                        {
+                            case Ch('['): ++depth; break;
+                            case Ch(']'): --depth; break;
+                            case 0: RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                        }
+                        ++text;
+                    }
+                    break;
+                }
+
+                // Error on end of text
+                case Ch('\0'):
+                    RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+
+                // Other character, skip it
+                default:
+                    ++text;
+
+                }
+            }
+
+            // If DOCTYPE nodes enabled
+            if (Flags & parse_doctype_node)
+            {
+                // Create a new doctype node
+                xml_node<Ch> *doctype = this->allocate_node(node_doctype);
+                doctype->value(value, text - value);
+
+                // Place zero terminator after value
+                if (!(Flags & parse_no_string_terminators))
+                    *text = Ch('\0');
+
+                text += 1;      // skip '>'
+                return doctype;
+            }
+            else
+            {
+                text += 1;      // skip '>'
+                return 0;
+            }
+
+        }
+
+        // Parse PI
+        template<int Flags>
+        xml_node<Ch> *parse_pi(Ch *&text)
+        {
+            // If creation of PI nodes is enabled
+            if (Flags & parse_pi_nodes)
+            {
+                // Create pi node
+                xml_node<Ch> *pi = this->allocate_node(node_pi);
+
+                // Extract PI target name
+                Ch *name = text;
+                skip<node_name_pred, Flags>(text);
+                if (text == name)
+                    RAPIDXML_PARSE_ERROR("expected PI target", text);
+                pi->name(name, text - name);
+
+                // Skip whitespace between pi target and pi
+                skip<whitespace_pred, Flags>(text);
+
+                // Remember start of pi
+                Ch *value = text;
+
+                // Skip to '?>'
+                while (text[0] != Ch('?') || text[1] != Ch('>'))
+                {
+                    if (*text == Ch('\0'))
+                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                    ++text;
+                }
+
+                // Set pi value (verbatim, no entity expansion or whitespace normalization)
+                pi->value(value, text - value);
+
+                // Place zero terminator after name and value
+                if (!(Flags & parse_no_string_terminators))
+                {
+                    pi->name()[pi->name_size()] = Ch('\0');
+                    pi->value()[pi->value_size()] = Ch('\0');
+                }
+
+                text += 2;                          // Skip '?>'
+                return pi;
+            }
+            else
+            {
+                // Skip to '?>'
+                while (text[0] != Ch('?') || text[1] != Ch('>'))
+                {
+                    if (*text == Ch('\0'))
+                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                    ++text;
+                }
+                text += 2;    // Skip '?>'
+                return 0;
+            }
+        }
+
+        // Parse and append data
+        // Return character that ends data.
+        // This is necessary because this character might have been overwritten by a terminating 0
+        template<int Flags>
+        Ch parse_and_append_data(xml_node<Ch> *node, Ch *&text, Ch *contents_start)
+        {
+            // Backup to contents start if whitespace trimming is disabled
+            if (!(Flags & parse_trim_whitespace))
+                text = contents_start;
+
+            // Skip until end of data
+            Ch *value = text, *end;
+            if (Flags & parse_normalize_whitespace)
+                end = skip_and_expand_character_refs<text_pred, text_pure_with_ws_pred, Flags>(text);
+            else
+                end = skip_and_expand_character_refs<text_pred, text_pure_no_ws_pred, Flags>(text);
+
+            // Trim trailing whitespace if flag is set; leading was already trimmed by whitespace skip after >
+            if (Flags & parse_trim_whitespace)
+            {
+                if (Flags & parse_normalize_whitespace)
+                {
+                    // Whitespace is already condensed to single space characters by skipping function, so just trim 1 char off the end
+                    if (*(end - 1) == Ch(' '))
+                        --end;
+                }
+                else
+                {
+                    // Backup until non-whitespace character is found
+                    while (whitespace_pred::test(*(end - 1)))
+                        --end;
+                }
+            }
+
+            // If characters are still left between end and value (this test is only necessary if normalization is enabled)
+            // Create new data node
+            if (!(Flags & parse_no_data_nodes))
+            {
+                xml_node<Ch> *data = this->allocate_node(node_data);
+                data->value(value, end - value);
+                node->append_node(data);
+            }
+
+            // Add data to parent node if no data exists yet
+            if (!(Flags & parse_no_element_values))
+                if (*node->value() == Ch('\0'))
+                    node->value(value, end - value);
+
+            // Place zero terminator after value
+            if (!(Flags & parse_no_string_terminators))
+            {
+                Ch ch = *text;
+                *end = Ch('\0');
+                return ch;      // Return character that ends data; this is required because zero terminator overwritten it
+            }
+
+            // Return character that ends data
+            return *text;
+        }
+
+        // Parse CDATA
+        template<int Flags>
+        xml_node<Ch> *parse_cdata(Ch *&text)
+        {
+            // If CDATA is disabled
+            if (Flags & parse_no_data_nodes)
+            {
+                // Skip until end of cdata
+                while (text[0] != Ch(']') || text[1] != Ch(']') || text[2] != Ch('>'))
+                {
+                    if (!text[0])
+                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                    ++text;
+                }
+                text += 3;      // Skip ]]>
+                return 0;       // Do not produce CDATA node
+            }
+
+            // Skip until end of cdata
+            Ch *value = text;
+            while (text[0] != Ch(']') || text[1] != Ch(']') || text[2] != Ch('>'))
+            {
+                if (!text[0])
+                    RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                ++text;
+            }
+
+            // Create new cdata node
+            xml_node<Ch> *cdata = this->allocate_node(node_cdata);
+            cdata->value(value, text - value);
+
+            // Place zero terminator after value
+            if (!(Flags & parse_no_string_terminators))
+                *text = Ch('\0');
+
+            text += 3;      // Skip ]]>
+            return cdata;
+        }
+
+        // Parse element node
+        template<int Flags, class NamespaceScope>
+        xml_node<Ch> *parse_element(Ch *&text, NamespaceScope namespace_scope)
+        {
+            // Create element node
+            xml_node<Ch> *element = this->allocate_node(node_element);
+
+            // Extract element name
+            Ch *name = text;
+            if (Flags & parse_no_namespace)
+                skip<node_name_pred, Flags>(text);
+            else
+                skip<node_ncname_pred, Flags>(text);
+            if (text == name)
+                RAPIDXML_PARSE_ERROR("expected element name", text);
+            if ((Flags & parse_no_namespace) == 0 && *text == Ch(':'))
+            {
+                // Namespace prefix found
+                ++text;
+                Ch *local_name = text;
+                skip<node_ncname_pred, Flags>(text);
+                if (*text == Ch(':'))
+                    RAPIDXML_PARSE_ERROR("second colon in element name", text);
+                if (text == local_name)
+                    RAPIDXML_PARSE_ERROR("expected local part of element name", text);
+                element->qname(name, text - name, local_name);
+            }
+            else
+                element->qname(name, text - name);
+
+            // Skip whitespace between element name and attributes or >
+            skip<whitespace_pred, Flags>(text);
+
+            // Parse attributes, if any
+            parse_node_attributes<Flags>(text, element);
+
+            // Setting attributes and element own namespace_uri, adding declared
+            // namespace prefixes and probably setting default namespace
+            namespace_scope.process_element(element);
+
+            // Determine ending type
+            if (*text == Ch('>'))
+            {
+                ++text;
+                parse_node_contents<Flags, NamespaceScope>(text, element, namespace_scope);
+            }
+            else if (*text == Ch('/'))
+            {
+                ++text;
+                if (*text != Ch('>'))
+                    RAPIDXML_PARSE_ERROR("expected >", text);
+                ++text;
+            }
+            else
+                RAPIDXML_PARSE_ERROR("expected >", text);
+
+            // Place zero terminator after name
+            if (!(Flags & parse_no_string_terminators))
+                element->name()[element->name_size()] = Ch('\0');
+
+            // Return parsed element
+            return element;
+        }
+
+        // Determine node type, and parse it
+        template<int Flags, class NamespaceScope>
+        xml_node<Ch> *parse_node(Ch *&text, NamespaceScope const & namespace_scope)
+        {
+            // Parse proper node type
+            switch (text[0])
+            {
+
+            // <...
+            default:
+                // Parse and append element node
+                return parse_element<Flags, NamespaceScope>(text, namespace_scope);
+
+            // <?...
+            case Ch('?'):
+                ++text;     // Skip ?
+                if ((text[0] == Ch('x') || text[0] == Ch('X')) &&
+                    (text[1] == Ch('m') || text[1] == Ch('M')) &&
+                    (text[2] == Ch('l') || text[2] == Ch('L')) &&
+                    whitespace_pred::test(text[3]))
+                {
+                    // '<?xml ' - xml declaration
+                    text += 4;      // Skip 'xml '
+                    return parse_xml_declaration<Flags>(text);
+                }
+                else
+                {
+                    // Parse PI
+                    return parse_pi<Flags>(text);
+                }
+
+            // <!...
+            case Ch('!'):
+
+                // Parse proper subset of <! node
+                switch (text[1])
+                {
+
+                // <!-
+                case Ch('-'):
+                    if (text[2] == Ch('-'))
+                    {
+                        // '<!--' - xml comment
+                        text += 3;     // Skip '!--'
+                        return parse_comment<Flags>(text);
+                    }
+                    break;
+
+                // <![
+                case Ch('['):
+                    if (text[2] == Ch('C') && text[3] == Ch('D') && text[4] == Ch('A') &&
+                        text[5] == Ch('T') && text[6] == Ch('A') && text[7] == Ch('['))
+                    {
+                        // '<![CDATA[' - cdata
+                        text += 8;     // Skip '![CDATA['
+                        return parse_cdata<Flags>(text);
+                    }
+                    break;
+
+                // <!D
+                case Ch('D'):
+                    if (text[2] == Ch('O') && text[3] == Ch('C') && text[4] == Ch('T') &&
+                        text[5] == Ch('Y') && text[6] == Ch('P') && text[7] == Ch('E') &&
+                        whitespace_pred::test(text[8]))
+                    {
+                        // '<!DOCTYPE ' - doctype
+                        text += 9;      // skip '!DOCTYPE '
+                        return parse_doctype<Flags>(text);
+                    }
+
+                }   // switch
+
+                // Attempt to skip other, unrecognized node types starting with <!
+                ++text;     // Skip !
+                while (*text != Ch('>'))
+                {
+                    if (*text == 0)
+                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                    ++text;
+                }
+                ++text;     // Skip '>'
+                return 0;   // No node recognized
+
+            }
+        }
+
+        // Parse contents of the node - children, data etc.
+        template<int Flags, class NamespaceScope>
+        void parse_node_contents(Ch *&text, xml_node<Ch> *node, NamespaceScope const & namespace_scope)
+        {
+            // For all children and text
+            while (1)
+            {
+                // Skip whitespace between > and node contents
+                Ch *contents_start = text;      // Store start of node contents before whitespace is skipped
+                skip<whitespace_pred, Flags>(text);
+                Ch next_char = *text;
+
+            // After data nodes, instead of continuing the loop, control jumps here.
+            // This is because zero termination inside parse_and_append_data() function
+            // would wreak havoc with the above code.
+            // Also, skipping whitespace after data nodes is unnecessary.
+            after_data_node:
+
+                // Determine what comes next: node closing, child node, data node, or 0?
+                switch (next_char)
+                {
+
+                // Node closing or child node
+                case Ch('<'):
+                    if (text[1] == Ch('/'))
+                    {
+                        // Node closing
+                        text += 2;      // Skip '</'
+                        if (Flags & parse_validate_closing_tags)
+                        {
+                            // Skip and validate closing tag name
+                            Ch *closing_name = text;
+                            skip<node_name_pred, Flags>(text);
+                            if (!internal::compare(node->name(), node->name_size(), closing_name, text - closing_name, true))
+                                RAPIDXML_PARSE_ERROR("invalid closing tag name", text);
+                        }
+                        else
+                        {
+                            // No validation, just skip name
+                            skip<node_name_pred, Flags>(text);
+                        }
+                        // Skip remaining whitespace after node name
+                        skip<whitespace_pred, Flags>(text);
+                        if (*text != Ch('>'))
+                            RAPIDXML_PARSE_ERROR("expected >", text);
+                        ++text;     // Skip '>'
+                        return;     // Node closed, finished parsing contents
+                    }
+                    else
+                    {
+                        // Child node
+                        ++text;     // Skip '<'
+                        if (xml_node<Ch> *child = parse_node<Flags, NamespaceScope>(text, namespace_scope))
+                            node->append_node(child);
+                    }
+                    break;
+
+                // End of data - error
+                case Ch('\0'):
+                    RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+
+                // Data node
+                default:
+                    next_char = parse_and_append_data<Flags>(node, text, contents_start);
+                    goto after_data_node;   // Bypass regular processing after data nodes
+
+                }
+            }
+        }
+
+        // Parse XML attributes of the node
+        template<int Flags>
+        void parse_node_attributes(Ch *&text, xml_node<Ch> *node)
+        {
+            // For all attributes
+            while ((Flags & parse_no_namespace)
+                ? attribute_name_pred::test(*text)
+                : attribute_ncname_pred::test(*text))
+            {
+                // Extract attribute name
+                Ch *name = text;
+                ++text;     // Skip first character of attribute name
+                if (Flags & parse_no_namespace)
+                    skip<attribute_name_pred, Flags>(text);
+                else
+                    skip<attribute_ncname_pred, Flags>(text);
+                if (text == name)
+                    RAPIDXML_PARSE_ERROR("expected attribute name", name);
+                // Create new attribute
+                xml_attribute<Ch> *attribute = this->allocate_attribute();
+                if ((Flags & parse_no_namespace) == 0 && *text == Ch(':'))
+                {
+                    // Namespace prefix found
+                    ++text;
+                    Ch *local_name = text;
+                    skip<attribute_ncname_pred, Flags>(text);
+                    if (text == local_name)
+                        RAPIDXML_PARSE_ERROR("expected local part of attribute name", local_name);
+                    attribute->qname(name, text - name, local_name);
+                }
+                else
+                    attribute->qname(name, text - name);
+
+                node->append_attribute(attribute);
+
+                // Skip whitespace after attribute name
+                skip<whitespace_pred, Flags>(text);
+
+                // Skip =
+                if (*text != Ch('='))
+                    RAPIDXML_PARSE_ERROR("expected =", text);
+                ++text;
+
+                // Add terminating zero after name
+                if (!(Flags & parse_no_string_terminators))
+                    attribute->name()[attribute->name_size()] = 0;
+
+                // Skip whitespace after =
+                skip<whitespace_pred, Flags>(text);
+
+                // Skip quote and remember if it was ' or "
+                Ch quote = *text;
+                if (quote != Ch('\'') && quote != Ch('"'))
+                    RAPIDXML_PARSE_ERROR("expected ' or \"", text);
+                ++text;
+
+                // Extract attribute value and expand char refs in it
+                Ch *value = text, *end;
+                const int AttFlags = Flags & ~parse_normalize_whitespace;   // No whitespace normalization in attributes
+                if (quote == Ch('\''))
+                    end = skip_and_expand_character_refs<attribute_value_pred<Ch('\'')>, attribute_value_pure_pred<Ch('\'')>, AttFlags>(text);
+                else
+                    end = skip_and_expand_character_refs<attribute_value_pred<Ch('"')>, attribute_value_pure_pred<Ch('"')>, AttFlags>(text);
+
+                // Set attribute value
+                attribute->value(value, end - value);
+
+                // Make sure that end quote is present
+                if (*text != quote)
+                    RAPIDXML_PARSE_ERROR("expected ' or \"", text);
+                ++text;     // Skip quote
+
+                // Add terminating zero after value
+                if (!(Flags & parse_no_string_terminators))
+                    attribute->value()[attribute->value_size()] = 0;
+
+                // Skip whitespace after attribute value
+                skip<whitespace_pred, Flags>(text);
+            }
+        }
+
+    };
+
+    //! \cond internal
+    namespace internal
+    {
+
+        // Whitespace (space \n \r \t)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_whitespace[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  0,  // 0
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 1
+             1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 2
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 3
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 4
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 5
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 6
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 7
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 8
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 9
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // A
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // B
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // C
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // D
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // E
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0   // F
+        };
+
+        // Node name (anything but space \n \r \t / > ? \0)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_node_name[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Node NCName (anything but space \n \r \t / > ? \0 :)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_node_ncname[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  0,  0,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Text (i.e. PCDATA) (anything but < \0)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_text[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Text (i.e. PCDATA) that does not require processing when ws normalization is disabled
+        // (anything but < \0 &)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_text_pure_no_ws[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Text (i.e. PCDATA) that does not require processing when ws normalizationis is enabled
+        // (anything but < \0 & space \n \r \t)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_text_pure_with_ws[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             0,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Attribute name (anything but space \n \r \t / < > = ? ! \0)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_attribute_name[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+        // Attribute name (anything but space \n \r \t / < > = ? ! \0 :)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_attribute_ncname[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  0,  0,  0,  0,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Attribute data with single quote (anything but ' \0)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_1[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Attribute data with single quote that does not require processing (anything but ' \0 &)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_1_pure[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Attribute data with double quote (anything but " \0)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_2[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Attribute data with double quote that does not require processing (anything but " \0 &)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_2_pure[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             1,  1,  0,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Digits (dec and hex, 255 denotes end of numeric character reference)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_digits[256] =
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 0
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 1
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 2
+             0,  1,  2,  3,  4,  5,  6,  7,  8,  9,255,255,255,255,255,255,  // 3
+           255, 10, 11, 12, 13, 14, 15,255,255,255,255,255,255,255,255,255,  // 4
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 5
+           255, 10, 11, 12, 13, 14, 15,255,255,255,255,255,255,255,255,255,  // 6
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 7
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 8
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 9
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // A
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // B
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // C
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // D
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // E
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255   // F
+        };
+
+        // Upper case conversion
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_upcase[256] =
+        {
+          // 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  A   B   C   D   E   F
+           0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15,   // 0
+           16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,   // 1
+           32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,   // 2
+           48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,   // 3
+           64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,   // 4
+           80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,   // 5
+           96, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,   // 6
+           80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 123,124,125,126,127,  // 7
+           128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,  // 8
+           144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,  // 9
+           160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,  // A
+           176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,  // B
+           192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,  // C
+           208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,  // D
+           224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,  // E
+           240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255   // F
+        };
+    }
+    //! \endcond
+
+}
+
+// Undefine internal macros
+#undef RAPIDXML_PARSE_ERROR
+
+// On MSVC, restore warnings state
+#ifdef _MSC_VER
+    #pragma warning(pop)
+#endif
+
+#endif
Index: svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns_utils.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns_utils.hpp b/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns_utils.hpp
new file mode 100644
--- /dev/null	(date 1714440647086)
+++ b/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns_utils.hpp	(date 1714440647086)
@@ -0,0 +1,122 @@
+#ifndef RAPIDXML_NS_UTILS_HPP_INCLUDED
+#define RAPIDXML_NS_UTILS_HPP_INCLUDED
+
+// Copyright (C) 2006, 2009 Marcin Kalicinski
+// Version 1.13
+// Revision $DateTime: 2009/05/15 23:02:39 $
+//! \file rapidxml_utils.hpp This file contains high-level rapidxml utilities that can be useful
+//! in certain simple scenarios. They should probably not be used if maximizing performance is the main objective.
+
+#include "rapidxml_ns.hpp"
+#include <vector>
+#include <string>
+#include <fstream>
+#include <stdexcept>
+
+namespace rapidxml_ns
+{
+
+    //! Represents data loaded from a file
+    template<class Ch = char>
+    class file
+    {
+
+    public:
+
+        //! Loads file into the memory. Data will be automatically destroyed by the destructor.
+        //! \param filename Filename to load.
+        file(const char *filename)
+        {
+            using namespace std;
+
+            // Open stream
+            basic_ifstream<Ch> stream(filename, ios::binary);
+            if (!stream)
+                throw runtime_error(string("cannot open file ") + filename);
+            stream.unsetf(ios::skipws);
+
+            // Determine stream size
+            stream.seekg(0, ios::end);
+            size_t size = stream.tellg();
+            stream.seekg(0);
+
+            // Load data and add terminating 0
+            m_data.resize(size + 1);
+            stream.read(&m_data.front(), static_cast<streamsize>(size));
+            m_data[size] = 0;
+        }
+
+        //! Loads file into the memory. Data will be automatically destroyed by the destructor
+        //! \param stream Stream to load from
+        file(std::basic_istream<Ch> &stream)
+        {
+            using namespace std;
+
+            // Load data and add terminating 0
+            stream.unsetf(ios::skipws);
+            m_data.assign(istreambuf_iterator<Ch>(stream), istreambuf_iterator<Ch>());
+            if (stream.fail() || stream.bad())
+                throw runtime_error("error reading stream");
+            m_data.push_back(0);
+        }
+
+        //! Gets file data.
+        //! \return Pointer to data of file.
+        Ch *data()
+        {
+            return &m_data.front();
+        }
+
+        //! Gets file data.
+        //! \return Pointer to data of file.
+        const Ch *data() const
+        {
+            return &m_data.front();
+        }
+
+        //! Gets file data size.
+        //! \return Size of file data, in characters.
+        std::size_t size() const
+        {
+            return m_data.size();
+        }
+
+    private:
+
+        std::vector<Ch> m_data;   // File data
+
+    };
+
+    //! Counts children of node. Time complexity is O(n).
+    //! \return Number of children of node
+    template<class Ch>
+    inline std::size_t count_children(xml_node<Ch> *node)
+    {
+        xml_node<Ch> *child = node->first_node();
+        std::size_t count = 0;
+        while (child)
+        {
+            ++count;
+            child = child->next_sibling();
+        }
+        return count;
+    }
+
+    //! Counts attributes of node. Time complexity is O(n).
+    //! \return Number of attributes of node
+    template<class Ch>
+    inline std::size_t count_attributes(xml_node<Ch> *node)
+    {
+        xml_attribute<Ch> *attr = node->first_attribute();
+        std::size_t count = 0;
+        while (attr)
+        {
+            ++count;
+            attr = attr->next_attribute();
+        }
+        return count;
+    }
+
+}
+
+#endif
Index: openssl-src/openssl/opensslconf.h.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openssl-src/openssl/opensslconf.h.cmake b/openssl-src/openssl/opensslconf.h.cmake
new file mode 100644
--- /dev/null	(date 1714440647086)
+++ b/openssl-src/openssl/opensslconf.h.cmake	(date 1714440647086)
@@ -0,0 +1,203 @@
+/*
+ * Copyright 2016-2020 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://www.openssl.org/source/license.html
+ */
+
+#include <openssl/opensslv.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#ifdef OPENSSL_ALGORITHM_DEFINES
+# error OPENSSL_ALGORITHM_DEFINES no longer supported
+#endif
+
+/*
+ * OpenSSL was configured with the following options:
+ */
+
+#ifndef OPENSSL_NO_MD2
+# define OPENSSL_NO_MD2
+#endif
+#ifndef OPENSSL_NO_RC5
+# define OPENSSL_NO_RC5
+#endif
+#ifndef OPENSSL_THREADS
+# define OPENSSL_THREADS
+#endif
+#ifndef OPENSSL_RAND_SEED_OS
+# define OPENSSL_RAND_SEED_OS
+#endif
+#ifndef OPENSSL_NO_ASAN
+# define OPENSSL_NO_ASAN
+#endif
+#ifndef OPENSSL_NO_ASM
+# define OPENSSL_NO_ASM
+#endif
+#ifndef OPENSSL_NO_CRYPTO_MDEBUG
+# define OPENSSL_NO_CRYPTO_MDEBUG
+#endif
+#ifndef OPENSSL_NO_CRYPTO_MDEBUG_BACKTRACE
+# define OPENSSL_NO_CRYPTO_MDEBUG_BACKTRACE
+#endif
+#ifndef OPENSSL_NO_DEVCRYPTOENG
+# define OPENSSL_NO_DEVCRYPTOENG
+#endif
+#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128
+# define OPENSSL_NO_EC_NISTP_64_GCC_128
+#endif
+#ifndef OPENSSL_NO_EGD
+# define OPENSSL_NO_EGD
+#endif
+#ifndef OPENSSL_NO_EXTERNAL_TESTS
+# define OPENSSL_NO_EXTERNAL_TESTS
+#endif
+#ifndef OPENSSL_NO_FUZZ_AFL
+# define OPENSSL_NO_FUZZ_AFL
+#endif
+#ifndef OPENSSL_NO_FUZZ_LIBFUZZER
+# define OPENSSL_NO_FUZZ_LIBFUZZER
+#endif
+#ifndef OPENSSL_NO_HEARTBEATS
+# define OPENSSL_NO_HEARTBEATS
+#endif
+#ifndef OPENSSL_NO_MSAN
+# define OPENSSL_NO_MSAN
+#endif
+#ifndef OPENSSL_NO_SCTP
+# define OPENSSL_NO_SCTP
+#endif
+#ifndef OPENSSL_NO_SSL_TRACE
+# define OPENSSL_NO_SSL_TRACE
+#endif
+#ifndef OPENSSL_NO_SSL3
+# define OPENSSL_NO_SSL3
+#endif
+#ifndef OPENSSL_NO_SSL3_METHOD
+# define OPENSSL_NO_SSL3_METHOD
+#endif
+#ifndef OPENSSL_NO_UBSAN
+# define OPENSSL_NO_UBSAN
+#endif
+#ifndef OPENSSL_NO_UNIT_TEST
+# define OPENSSL_NO_UNIT_TEST
+#endif
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
+# define OPENSSL_NO_WEAK_SSL_CIPHERS
+#endif
+#ifndef OPENSSL_NO_STATIC_ENGINE
+# define OPENSSL_NO_STATIC_ENGINE
+#endif
+#ifndef OPENSSL_NO_AFALGENG
+# define OPENSSL_NO_AFALGENG
+#endif
+
+/*
+ * Sometimes OPENSSSL_NO_xxx ends up with an empty file and some compilers
+ * don't like that.  This will hopefully silence them.
+ */
+#define NON_EMPTY_TRANSLATION_UNIT static void *dummy = &dummy;
+
+/*
+ * Applications should use -DOPENSSL_API_COMPAT=<version> to suppress the
+ * declarations of functions deprecated in or before <version>. Otherwise, they
+ * still won't see them if the library has been built to disable deprecated
+ * functions.
+ */
+#ifndef DECLARE_DEPRECATED
+# define DECLARE_DEPRECATED(f)   f;
+# ifdef __GNUC__
+#  if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 0)
+#   undef DECLARE_DEPRECATED
+#   define DECLARE_DEPRECATED(f)    f __attribute__ ((deprecated));
+#  endif
+# elif defined(__SUNPRO_C)
+#  if (__SUNPRO_C >= 0x5130)
+#   undef DECLARE_DEPRECATED
+#   define DECLARE_DEPRECATED(f)    f __attribute__ ((deprecated));
+#  endif
+# endif
+#endif
+
+#ifndef OPENSSL_FILE
+# ifdef OPENSSL_NO_FILENAMES
+#  define OPENSSL_FILE ""
+#  define OPENSSL_LINE 0
+# else
+#  define OPENSSL_FILE __FILE__
+#  define OPENSSL_LINE __LINE__
+# endif
+#endif
+
+#ifndef OPENSSL_MIN_API
+# define OPENSSL_MIN_API 0
+#endif
+
+#if !defined(OPENSSL_API_COMPAT) || OPENSSL_API_COMPAT < OPENSSL_MIN_API
+# undef OPENSSL_API_COMPAT
+# define OPENSSL_API_COMPAT OPENSSL_MIN_API
+#endif
+
+/*
+ * Do not deprecate things to be deprecated in version 1.2.0 before the
+ * OpenSSL version number matches.
+ */
+#if OPENSSL_VERSION_NUMBER < 0x10200000L
+# define DEPRECATEDIN_1_2_0(f)   f;
+#elif OPENSSL_API_COMPAT < 0x10200000L
+# define DEPRECATEDIN_1_2_0(f)   DECLARE_DEPRECATED(f)
+#else
+# define DEPRECATEDIN_1_2_0(f)
+#endif
+
+#if OPENSSL_API_COMPAT < 0x10100000L
+# define DEPRECATEDIN_1_1_0(f)   DECLARE_DEPRECATED(f)
+#else
+# define DEPRECATEDIN_1_1_0(f)
+#endif
+
+#if OPENSSL_API_COMPAT < 0x10000000L
+# define DEPRECATEDIN_1_0_0(f)   DECLARE_DEPRECATED(f)
+#else
+# define DEPRECATEDIN_1_0_0(f)
+#endif
+
+#if OPENSSL_API_COMPAT < 0x00908000L
+# define DEPRECATEDIN_0_9_8(f)   DECLARE_DEPRECATED(f)
+#else
+# define DEPRECATEDIN_0_9_8(f)
+#endif
+
+/* Generate 80386 code? */
+#undef I386_ONLY
+
+#undef OPENSSL_UNISTD
+#define OPENSSL_UNISTD <unistd.h>
+
+#undef OPENSSL_EXPORT_VAR_AS_FUNCTION
+#cmakedefine OPENSSL_EXPORT_VAR_AS_FUNCTION
+
+/*
+ * The following are cipher-specific, but are part of the public API.
+ */
+#if !defined(OPENSSL_SYS_UEFI)
+#undef BN_LLONG
+/* Only one for the following should be defined */
+#undef SIXTY_FOUR_BIT_LONG
+#cmakedefine SIXTY_FOUR_BIT_LONG
+#undef SIXTY_FOUR_BIT
+#cmakedefine SIXTY_FOUR_BIT
+#undef THIRTY_TWO_BIT
+#cmakedefine THIRTY_TWO_BIT
+#endif
+
+#define RC4_INT unsigned int
+
+#ifdef  __cplusplus
+}
+#endif
Index: indigo-src/indigo/core/indigo-core/molecule/src/inchi_wrapper.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/molecule/src/inchi_wrapper.cpp b/indigo-src/indigo/core/indigo-core/molecule/src/inchi_wrapper.cpp
--- a/indigo-src/indigo/core/indigo-core/molecule/src/inchi_wrapper.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/core/indigo-core/molecule/src/inchi_wrapper.cpp	(date 1714440647086)
@@ -17,6 +17,7 @@
  ***************************************************************************/
 
 #include <algorithm>
+#define TARGET_LIB_FOR_WINCHI
 #include <mode.h>
 
 #include "molecule/inchi_wrapper.h"
Index: yaehmop-src/yaehmop/tightbind/diag.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/yaehmop-src/yaehmop/tightbind/diag.c b/yaehmop-src/yaehmop/tightbind/diag.c
--- a/yaehmop-src/yaehmop/tightbind/diag.c	(revision 7a4919752a60a7d096c83c3d2112a38c41e0f0ac)
+++ b/yaehmop-src/yaehmop/tightbind/diag.c	(date 1714440647086)
@@ -2,7 +2,9 @@
 Produced by gmFortran V30.59(10/26/17) on 9/18/18 at 9:02:32
 */
 #define LPROTOTYPE
-#include "fortran.h"
+#include "bind.h"
+#include <math.h>
+
 void cchol(int *n,int *nd,double *a,int *fail)
 {
 static int i,ia,j,k,ka;
@@ -431,7 +433,7 @@
 */
         p = (d[l]-d[l-1])/(2.0e0*e[l-1]);
         r = sqrt(1.0e0+p*p);
-        h = d[l-1]-e[l-1]/(p+fdsign(r,p));
+        h = d[l-1]-e[l-1]/(p+d_sign(r,p));
 /*
 */
         for(i=l; i<=*n; i++) {
Index: quickjs-src/quickjs/quickjs-libc.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/quickjs-libc.h b/quickjs-src/quickjs/include/quickjs/quickjs-libc.h
rename from quickjs-src/quickjs/quickjs-libc.h
rename to quickjs-src/quickjs/include/quickjs/quickjs-libc.h
--- a/quickjs-src/quickjs/quickjs-libc.h	(revision 3b45d155c77bbdfe9177b1e03db830d2aff0b2a8)
+++ b/quickjs-src/quickjs/include/quickjs/quickjs-libc.h	(date 1714440647082)
@@ -37,7 +37,6 @@
 JSModuleDef *js_init_module_os(JSContext *ctx, const char *module_name);
 void js_std_add_helpers(JSContext *ctx, int argc, char **argv);
 void js_std_loop(JSContext *ctx);
-JSValue js_std_await(JSContext *ctx, JSValue obj);
 void js_std_init_handlers(JSRuntime *rt);
 void js_std_free_handlers(JSRuntime *rt);
 void js_std_dump_error(JSContext *ctx);
Index: quickjs-src/quickjs/quickjs.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/quickjs.h b/quickjs-src/quickjs/include/quickjs/quickjs.h
rename from quickjs-src/quickjs/quickjs.h
rename to quickjs-src/quickjs/include/quickjs/quickjs.h
--- a/quickjs-src/quickjs/quickjs.h	(revision 3b45d155c77bbdfe9177b1e03db830d2aff0b2a8)
+++ b/quickjs-src/quickjs/include/quickjs/quickjs.h	(date 1714440647082)
@@ -25,6 +25,7 @@
 #ifndef QUICKJS_H
 #define QUICKJS_H
 
+#include "quickjs-defs.h"
 #include <stdio.h>
 #include <stdint.h>
 
@@ -32,17 +33,10 @@
 extern "C" {
 #endif
 
-#if defined(__GNUC__) || defined(__clang__)
-#define js_likely(x)          __builtin_expect(!!(x), 1)
-#define js_unlikely(x)        __builtin_expect(!!(x), 0)
-#define js_force_inline       inline __attribute__((always_inline))
-#define __js_printf_like(f, a)   __attribute__((format(printf, f, a)))
-#else
-#define js_likely(x)     (x)
-#define js_unlikely(x)   (x)
-#define js_force_inline  inline
-#define __js_printf_like(a, b)
-#endif
+#define js_likely(x)           PLATFORM_LIKELY(x)
+#define js_unlikely(x)         PLATFORM_UNLIKELY(x)
+#define js_force_inline        PLATFORM_FORCE_INLINE
+#define __js_printf_like(f, a) PLATFORM_PRINTF_LIKE(f, a)
 
 #define JS_BOOL int
 
@@ -215,8 +209,14 @@
 #define JS_VALUE_GET_FLOAT64(v) ((v).u.float64)
 #define JS_VALUE_GET_PTR(v) ((v).u.ptr)
 
+// error C4576: a parenthesized type followed by an initializer list is a non-standard explicit type conversion syntax
+#if _MSC_VER && __cplusplus
+#define JS_MKVAL(tag, val) JSValue{ JSValueUnion{ .int32 = val }, tag }
+#define JS_MKPTR(tag, p) JSValue{ JSValueUnion{ .ptr = p }, tag }
+#else
 #define JS_MKVAL(tag, val) (JSValue){ (JSValueUnion){ .int32 = val }, tag }
 #define JS_MKPTR(tag, p) (JSValue){ (JSValueUnion){ .ptr = p }, tag }
+#endif
 
 #define JS_TAG_IS_FLOAT64(tag) ((unsigned)(tag) == JS_TAG_FLOAT64)
 
@@ -307,9 +307,6 @@
 #define JS_EVAL_FLAG_COMPILE_ONLY (1 << 5)
 /* don't include the stack frames before this eval in the Error() backtraces */
 #define JS_EVAL_FLAG_BACKTRACE_BARRIER (1 << 6)
-/* allow top-level await in normal script. JS_Eval() returns a
-   promise. Only allowed with JS_EVAL_TYPE_GLOBAL */
-#define JS_EVAL_FLAG_ASYNC (1 << 7)
 
 typedef JSValue JSCFunction(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);
 typedef JSValue JSCFunctionMagic(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv, int magic);
@@ -499,10 +496,8 @@
     JSClassExoticMethods *exotic;
 } JSClassDef;
 
-#define JS_INVALID_CLASS_ID 0
 JSClassID JS_NewClassID(JSClassID *pclass_id);
-/* Returns the class ID if `v` is an object, otherwise returns JS_INVALID_CLASS_ID. */
-JSClassID JS_GetClassID(JSValue v);
+JSClassID JS_GetClassID(JSValueConst v);
 int JS_NewClass(JSRuntime *rt, JSClassID class_id, const JSClassDef *class_def);
 int JS_IsRegisteredClass(JSRuntime *rt, JSClassID class_id);
 
@@ -550,21 +545,23 @@
 
 static js_force_inline JSValue JS_NewFloat64(JSContext *ctx, double d)
 {
+    JSValue v;
     int32_t val;
     union {
         double d;
         uint64_t u;
     } u, t;
-    if (d >= INT32_MIN && d <= INT32_MAX) {
-        u.d = d;
-        val = (int32_t)d;
-        t.d = val;
-        /* -0 cannot be represented as integer, so we compare the bit
-           representation */
-        if (u.u == t.u)
-            return JS_MKVAL(JS_TAG_INT, val);
+    u.d = d;
+    val = (int32_t)d;
+    t.d = val;
+    /* -0 cannot be represented as integer, so we compare the bit
+        representation */
+    if (u.u == t.u) {
+        v = JS_MKVAL(JS_TAG_INT, val);
+    } else {
+        v = __JS_NewFloat64(ctx, d);
     }
-    return __JS_NewFloat64(ctx, d);
+    return v;
 }
 
 static inline JS_BOOL JS_IsNumber(JSValueConst v)
@@ -670,7 +667,7 @@
         JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);
         p->ref_count++;
     }
-    return (JSValue)v;
+    return v;
 }
 
 static inline JSValue JS_DupValueRT(JSRuntime *rt, JSValueConst v)
@@ -679,7 +676,7 @@
         JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);
         p->ref_count++;
     }
-    return (JSValue)v;
+    return v;
 }
 
 int JS_ToBool(JSContext *ctx, JSValueConst val); /* return -1 for JS_EXCEPTION */
@@ -724,8 +721,6 @@
 JSValue JS_NewArray(JSContext *ctx);
 int JS_IsArray(JSContext *ctx, JSValueConst val);
 
-JSValue JS_NewDate(JSContext *ctx, double epoch_ms);
-
 JSValue JS_GetPropertyInternal(JSContext *ctx, JSValueConst obj,
                                JSAtom prop, JSValueConst receiver,
                                JS_BOOL throw_ref_error);
@@ -739,13 +734,13 @@
 JSValue JS_GetPropertyUint32(JSContext *ctx, JSValueConst this_obj,
                              uint32_t idx);
 
-int JS_SetPropertyInternal(JSContext *ctx, JSValueConst obj,
-                           JSAtom prop, JSValue val, JSValueConst this_obj,
+int JS_SetPropertyInternal(JSContext *ctx, JSValueConst this_obj,
+                           JSAtom prop, JSValue val,
                            int flags);
 static inline int JS_SetProperty(JSContext *ctx, JSValueConst this_obj,
                                  JSAtom prop, JSValue val)
 {
-    return JS_SetPropertyInternal(ctx, this_obj, prop, val, this_obj, JS_PROP_THROW);
+    return JS_SetPropertyInternal(ctx, this_obj, prop, val, JS_PROP_THROW);
 }
 int JS_SetPropertyUint32(JSContext *ctx, JSValueConst this_obj,
                          uint32_t idx, JSValue val);
@@ -837,21 +832,14 @@
 void JS_SetSharedArrayBufferFunctions(JSRuntime *rt,
                                       const JSSharedArrayBufferFunctions *sf);
 
-typedef enum JSPromiseStateEnum {
-    JS_PROMISE_PENDING,
-    JS_PROMISE_FULFILLED,
-    JS_PROMISE_REJECTED,
-} JSPromiseStateEnum;
-
 JSValue JS_NewPromiseCapability(JSContext *ctx, JSValue *resolving_funcs);
-JSPromiseStateEnum JS_PromiseState(JSContext *ctx, JSValue promise);
-JSValue JS_PromiseResult(JSContext *ctx, JSValue promise);
 
 /* is_handled = TRUE means that the rejection is handled */
 typedef void JSHostPromiseRejectionTracker(JSContext *ctx, JSValueConst promise,
                                            JSValueConst reason,
                                            JS_BOOL is_handled, void *opaque);
 void JS_SetHostPromiseRejectionTracker(JSRuntime *rt, JSHostPromiseRejectionTracker *cb, void *opaque);
+void JS_SetHostUnhandledPromiseRejectionTracker(JSRuntime *rt, JSHostPromiseRejectionTracker *cb, void *opaque);
 
 /* return != 0 if the JS code needs to be interrupted */
 typedef int JSInterruptHandler(JSRuntime *rt, void *opaque);
@@ -879,7 +867,6 @@
 /* return the import.meta object of a module */
 JSValue JS_GetImportMeta(JSContext *ctx, JSModuleDef *m);
 JSAtom JS_GetModuleName(JSContext *ctx, JSModuleDef *m);
-JSValue JS_GetModuleNamespace(JSContext *ctx, JSModuleDef *m);
 
 /* JS Job support */
 
@@ -917,8 +904,8 @@
 /* only exported for os.Worker() */
 JSAtom JS_GetScriptOrModuleName(JSContext *ctx, int n_stack_levels);
 /* only exported for os.Worker() */
-JSValue JS_LoadModule(JSContext *ctx, const char *basename,
-                      const char *filename);
+JSModuleDef *JS_RunModule(JSContext *ctx, const char *basename,
+                          const char *filename);
 
 /* C function definition */
 typedef enum JSCFunctionEnum {  /* XXX: should rename for namespace isolation */
Index: quickjs-src/quickjs/include/quickjspp.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/include/quickjspp.hpp b/quickjs-src/quickjs/include/quickjspp.hpp
new file mode 100644
--- /dev/null	(date 1714440647086)
+++ b/quickjs-src/quickjs/include/quickjspp.hpp	(date 1714440647086)
@@ -0,0 +1,2232 @@
+#pragma once
+
+#include "quickjs/quickjs.h"
+
+#include <vector>
+#include <string_view>
+#include <string>
+#include <cassert>
+#include <memory>
+#include <cstddef>
+#include <algorithm>
+#include <tuple>
+#include <functional>
+#include <stdexcept>
+#include <variant>
+#include <optional>
+#include <type_traits>
+#include <unordered_map>
+#include <fstream>
+#include <ios>
+#include <sstream>
+#include <filesystem>
+
+
+#if defined(__cpp_rtti)
+#define QJSPP_TYPENAME(...) (typeid(__VA_ARGS__).name())
+#else
+#define QJSPP_TYPENAME(...) #__VA_ARGS__
+#endif
+
+
+namespace qjs {
+
+class Context;
+class Value;
+
+/** Exception type.
+ * Indicates that exception has occured in JS context.
+ */
+class exception {
+    JSContext * ctx;
+public:
+    exception(JSContext * ctx) : ctx(ctx) {}
+    Context & context() const;
+
+    /// Clears and returns the occurred exception.
+    Value get();
+};
+
+/** std::shared_ptr, for compatibility with quickjspp v2. */
+template <class T> using shared_ptr = std::shared_ptr<T>;
+/** std::make_shared, for compatibility with quickjspp v2. */
+template <class T, typename... Args>
+shared_ptr<T> make_shared(JSContext *, Args&&... args)
+{
+    return std::make_shared<T>(std::forward<Args>(args)...);
+}
+
+/** Javascript conversion traits.
+ * Describes how to convert type R to/from JSValue. Second template argument can be used for SFINAE/enable_if type filters.
+ */
+template <typename R, typename /*_SFINAE*/ = void>
+struct js_traits
+{
+    /** Create an object of C++ type R given JSValue v and JSContext.
+     * This function is intentionally not implemented. User should implement this function for their own type.
+     * @param v This value is passed as JSValueConst so it should be freed by the caller.
+     * @throws exception in case of conversion error
+     */
+    static R unwrap(JSContext * ctx, JSValueConst v) = delete;
+
+    /** Create JSValue from an object of type R and JSContext.
+     * This function is intentionally not implemented. User should implement this function for their own type.
+     * @return Returns JSValue which should be freed by the caller or JS_EXCEPTION in case of error.
+     */
+    static JSValue wrap(JSContext * ctx, R value) = delete;
+};
+
+/** Conversion traits for JSValue (identity).
+ */
+template <>
+struct js_traits<JSValue>
+{
+    static JSValue unwrap(JSContext * ctx, JSValueConst v) noexcept
+    {
+        return JS_DupValue(ctx, v);
+    }
+
+    static JSValue wrap(JSContext * ctx, JSValue&& v) noexcept
+    {
+        return v;
+    }
+};
+
+/** Conversion traits for integers.
+ * Intentionally doesn't define traits for uint64_t since it can be typedefed to JSValue. (@see JS_NAN_BOXING)
+ */
+template <typename Int>
+struct js_traits<Int, std::enable_if_t<std::is_integral_v<Int> && sizeof(Int) <= sizeof(int64_t) && !std::is_same_v<Int, uint64_t>>>
+{
+    /// @throws exception
+    static Int unwrap(JSContext * ctx, JSValueConst v)
+    {
+        if constexpr (sizeof(Int) > sizeof(int32_t))
+        {
+            int64_t r;
+            if(JS_ToInt64(ctx, &r, v))
+                throw exception{ctx};
+            return static_cast<Int>(r);
+        }
+        else
+        {
+            int32_t r;
+            if(JS_ToInt32(ctx, &r, v))
+                throw exception{ctx};
+            return static_cast<Int>(r);
+        }
+    }
+
+    static JSValue wrap(JSContext * ctx, Int i) noexcept
+    {
+        if constexpr (std::is_same_v<Int, uint32_t> || sizeof(Int) > sizeof(int32_t))
+            return JS_NewInt64(ctx, static_cast<Int>(i));
+        else
+            return JS_NewInt32(ctx, static_cast<Int>(i));
+    }
+};
+
+/** Conversion traits for boolean.
+ */
+template <>
+struct js_traits<bool>
+{
+    static bool unwrap(JSContext * ctx, JSValueConst v) noexcept
+    {
+        // TODO: is this behaviour correct?
+        return JS_ToBool(ctx, v) > 0;
+    }
+
+    static JSValue wrap(JSContext * ctx, bool i) noexcept
+    {
+        return JS_NewBool(ctx, i);
+    }
+};
+
+/** Conversion trait for void.
+ */
+template <>
+struct js_traits<void>
+{
+    /// @throws exception if jsvalue is neither undefined nor null
+    static void unwrap(JSContext * ctx, JSValueConst value)
+    {
+        if(JS_IsException(value))
+            throw exception{ctx};
+    }
+};
+
+/** Conversion traits for float64/double.
+ */
+template <>
+struct js_traits<double>
+{
+    /// @throws exception
+    static double unwrap(JSContext * ctx, JSValueConst v)
+    {
+        double r;
+        if(JS_ToFloat64(ctx, &r, v))
+            throw exception{ctx};
+        return r;
+    }
+
+    static JSValue wrap(JSContext * ctx, double i) noexcept
+    {
+        return JS_NewFloat64(ctx, i);
+    }
+};
+
+namespace detail {
+/** Fake std::string_view which frees the string on destruction.
+*/
+class js_string : public std::string_view
+{
+    using Base = std::string_view;
+    JSContext * ctx = nullptr;
+
+    friend struct js_traits<std::string_view>;
+
+    js_string(JSContext * ctx, const char * ptr, std::size_t len) : Base(ptr, len), ctx(ctx) {}
+
+public:
+
+    template <typename... Args>
+    js_string(Args&& ... args) : Base(std::forward<Args>(args)...), ctx(nullptr) {}
+
+    js_string(const js_string& other) = delete;
+
+    operator const char *() const
+    {
+        return this->data();
+    }
+
+    ~js_string()
+    {
+        if(ctx)
+            JS_FreeCString(ctx, this->data());
+    }
+};
+} // namespace detail
+
+/** Conversion traits from std::string_view and to detail::js_string. */
+template <>
+struct js_traits<std::string_view>
+{
+    static detail::js_string unwrap(JSContext * ctx, JSValueConst v)
+    {
+        size_t plen;
+        const char * ptr = JS_ToCStringLen(ctx, &plen, v);
+        if(!ptr)
+            throw exception{ctx};
+        return detail::js_string{ctx, ptr, plen};
+    }
+
+    static JSValue wrap(JSContext * ctx, std::string_view str) noexcept
+    {
+        return JS_NewStringLen(ctx, str.data(), str.size());
+    }
+};
+
+/** Conversion traits for std::string */
+template <> // slower
+struct js_traits<std::string>
+{
+    static std::string unwrap(JSContext * ctx, JSValueConst v)
+    {
+        auto str_view = js_traits<std::string_view>::unwrap(ctx, v);
+        return std::string{str_view.data(), str_view.size()};
+    }
+
+    static JSValue wrap(JSContext * ctx, const std::string& str) noexcept
+    {
+        return JS_NewStringLen(ctx, str.data(), str.size());
+    }
+};
+
+/** Conversion from const char * */
+template <>
+struct js_traits<const char *>
+{
+    static JSValue wrap(JSContext * ctx, const char * str) noexcept
+    {
+        return JS_NewString(ctx, str);
+    }
+
+    static detail::js_string unwrap(JSContext * ctx, JSValueConst v)
+    {
+        return js_traits<std::string_view>::unwrap(ctx, v);
+    }
+};
+
+
+/** Conversion from const std::variant */
+template <typename ... Ts>
+struct js_traits<std::variant<Ts...>>
+{
+    static JSValue wrap(JSContext * ctx, std::variant<Ts...> value) noexcept
+    {
+        return std::visit([ctx](auto&& value) {
+            using T = std::decay_t<decltype(value)>;
+            return js_traits<T>::wrap(ctx, value);
+        }, std::move(value));
+    }
+
+
+    /* Useful type traits */
+    template <typename T> struct is_shared_ptr : std::false_type {};
+    template <typename T> struct is_shared_ptr<std::shared_ptr<T>> : std::true_type {};
+    template <typename T> struct is_string
+    {
+        static constexpr bool value = std::is_same_v<T, const char *> || std::is_same_v<std::decay_t<T>, std::string> ||
+                                      std::is_same_v<std::decay_t<T>, std::string_view>;
+    };
+    template <typename T> struct is_boolean { static constexpr bool value = std::is_same_v<std::decay_t<T>, bool>; };
+    template <typename T> struct is_double { static constexpr bool value = std::is_same_v<std::decay_t<T>, double>; };
+    template <typename T> struct is_vector : std::false_type {};
+    template <typename T> struct is_vector<std::vector<T>> : std::true_type {};
+    template <typename T> struct is_pair : std::false_type {};
+    template <typename U, typename V> struct is_pair<std::pair<U, V>> : std::true_type {};
+    template <typename T> struct is_variant : std::false_type {};
+    template <typename ... Us> struct is_variant<std::variant<Us...>> : std::true_type {};
+
+    /** Attempt to match common types (integral, floating-point, string, etc.) */
+    template <template <typename R> typename Trait, typename U, typename ... Us>
+    static std::optional<std::variant<Ts...>> unwrapImpl(JSContext * ctx, JSValueConst v)
+    {
+        if constexpr (Trait<U>::value)
+        {
+            return js_traits<U>::unwrap(ctx, v);
+        }
+        if constexpr ((sizeof ... (Us)) > 0)
+        {
+            return unwrapImpl<Trait, Us...>(ctx, v);
+        }
+        return std::nullopt;
+    }
+
+    /** Attempt to match class ID with type */
+    template <typename U, typename ... Us>
+    static std::optional<std::variant<Ts...>> unwrapObj(JSContext * ctx, JSValueConst v, JSClassID class_id)
+    {
+        if constexpr (is_shared_ptr<U>::value)
+        {
+            if(class_id == js_traits<U>::QJSClassId)
+            {
+                return js_traits<U>::unwrap(ctx, v);
+            }
+        }
+
+        // try to unwrap embedded variant (variant<variant<...>>), might be slow
+        if constexpr (is_variant<U>::value)
+        {
+            if(auto opt = js_traits<std::optional<U>>::unwrap(ctx, v))
+                return *opt;
+        }
+
+        if constexpr (is_vector<U>::value)
+        {
+            if(JS_IsArray(ctx, v) == 1)
+            {
+                auto firstElement = JS_GetPropertyUint32(ctx, v, 0);
+                bool ok = isCompatible<std::decay_t<typename U::value_type>>(ctx, firstElement);
+                JS_FreeValue(ctx, firstElement);
+                if(ok)
+                {
+                    return U{js_traits<U>::unwrap(ctx, v)};
+                }
+            }
+        }
+
+        if constexpr (is_pair<U>::value)
+        {
+            if(JS_IsArray(ctx, v) == 1)
+            {
+                // todo: check length?
+                auto firstElement = JS_GetPropertyUint32(ctx, v, 0);
+                auto secondElement = JS_GetPropertyUint32(ctx, v, 1);
+                bool ok = isCompatible<std::decay_t<typename U::first_type>>(ctx, firstElement)
+                          && isCompatible<std::decay_t<typename U::second_type>>(ctx, secondElement);
+                JS_FreeValue(ctx, firstElement);
+                JS_FreeValue(ctx, secondElement);
+                if(ok)
+                {
+                    return U{js_traits<U>::unwrap(ctx, v)};
+                }
+            }
+        }
+
+        if constexpr ((sizeof ... (Us)) > 0)
+        {
+            return unwrapObj<Us...>(ctx, v, class_id);
+        }
+        return std::nullopt;
+    }
+
+    /** Attempt to cast to types satisfying traits, ordered in terms of priority */
+    template <template <typename T> typename Trait, template <typename T> typename ... Traits>
+    static std::variant<Ts...> unwrapPriority(JSContext * ctx, JSValueConst v)
+    {
+        if(auto result = unwrapImpl<Trait, Ts...>(ctx, v))
+        {
+            return *result;
+        }
+        if constexpr ((sizeof ... (Traits)) > 0)
+        {
+            return unwrapPriority<Traits...>(ctx, v);
+        }
+        JS_ThrowTypeError(ctx, "Expected type %s", QJSPP_TYPENAME(std::variant<Ts...>));
+        throw exception{ctx};
+    }
+
+    template <typename T>
+    static bool isCompatible(JSContext * ctx, JSValueConst v) noexcept
+    {
+        //const char * type_name = typeid(T).name();
+        switch(JS_VALUE_GET_TAG(v))
+        {
+            case JS_TAG_STRING:
+                return is_string<T>::value;
+
+            case JS_TAG_FUNCTION_BYTECODE:
+                return std::is_function<T>::value;
+            case JS_TAG_OBJECT:
+                if(JS_IsArray(ctx, v) == 1)
+                    return is_vector<T>::value || is_pair<T>::value;
+                if constexpr (is_shared_ptr<T>::value)
+                {
+                    if(JS_GetClassID(v) == js_traits<T>::QJSClassId)
+                        return true;
+                }
+                return false;
+
+            case JS_TAG_INT:
+                [[fallthrough]];
+            case JS_TAG_BIG_INT:
+                return std::is_integral_v<T> || std::is_floating_point_v<T>;
+            case JS_TAG_BOOL:
+                return is_boolean<T>::value || std::is_integral_v<T> || std::is_floating_point_v<T>;
+
+            case JS_TAG_BIG_DECIMAL:
+                [[fallthrough]];
+            case JS_TAG_BIG_FLOAT:
+                [[fallthrough]];
+            case JS_TAG_FLOAT64:
+            default: // >JS_TAG_FLOAT64 (JS_NAN_BOXING)
+                return is_double<T>::value || std::is_floating_point_v<T>;
+
+            case JS_TAG_SYMBOL:
+                [[fallthrough]];
+            case JS_TAG_MODULE:
+                [[fallthrough]];
+            case JS_TAG_NULL:
+                [[fallthrough]];
+            case JS_TAG_UNDEFINED:
+                [[fallthrough]];
+            case JS_TAG_UNINITIALIZED:
+                [[fallthrough]];
+            case JS_TAG_CATCH_OFFSET:
+                [[fallthrough]];
+            case JS_TAG_EXCEPTION:
+                break;
+        }
+        return false;
+    }
+
+    static std::variant<Ts...> unwrap(JSContext * ctx, JSValueConst v)
+    {
+        const auto tag = JS_VALUE_GET_TAG(v);
+        switch(tag)
+        {
+            case JS_TAG_STRING:
+                return unwrapPriority<is_string>(ctx, v);
+
+            case JS_TAG_FUNCTION_BYTECODE:
+                return unwrapPriority<std::is_function>(ctx, v);
+            case JS_TAG_OBJECT:
+                if(auto result = unwrapObj<Ts...>(ctx, v, JS_GetClassID(v)))
+                {
+                    return *result;
+                }
+                JS_ThrowTypeError(ctx, "Expected type %s, got object with classid %d",
+                                  QJSPP_TYPENAME(std::variant<Ts...>), JS_GetClassID(v));
+                break;
+
+            case JS_TAG_INT:
+                [[fallthrough]];
+            case JS_TAG_BIG_INT:
+                return unwrapPriority<std::is_integral, std::is_floating_point>(ctx, v);
+            case JS_TAG_BOOL:
+                return unwrapPriority<is_boolean, std::is_integral, std::is_floating_point>(ctx, v);
+
+            case JS_TAG_SYMBOL:
+                [[fallthrough]];
+            case JS_TAG_MODULE:
+                [[fallthrough]];
+            case JS_TAG_NULL:
+                [[fallthrough]];
+            case JS_TAG_UNDEFINED:
+                [[fallthrough]];
+            case JS_TAG_UNINITIALIZED:
+                [[fallthrough]];
+            case JS_TAG_CATCH_OFFSET:
+                JS_ThrowTypeError(ctx, "Expected type %s, got tag %d", QJSPP_TYPENAME(std::variant<Ts...>), tag);
+                [[fallthrough]];
+            case JS_TAG_EXCEPTION:
+                break;
+
+            case JS_TAG_BIG_DECIMAL:
+                [[fallthrough]];
+            case JS_TAG_BIG_FLOAT:
+                [[fallthrough]];
+
+            case JS_TAG_FLOAT64:
+                [[fallthrough]];
+            default: // more than JS_TAG_FLOAT64 (nan boxing)
+                return unwrapPriority<is_double, std::is_floating_point>(ctx, v);
+        }
+
+        throw exception{ctx};
+    }
+};
+
+template <typename T>
+struct rest : std::vector<T>
+{
+    using std::vector<T>::vector;
+    using std::vector<T>::operator=;
+};
+
+namespace detail {
+
+/** Helper function to convert and then free JSValue. */
+template <typename T>
+T unwrap_free(JSContext * ctx, JSValue val)
+{
+    if constexpr(std::is_same_v<T, void>)
+    {
+        JS_FreeValue(ctx, val);
+        return js_traits<T>::unwrap(ctx, val);
+    }
+    else
+    {
+        try
+        {
+            T result = js_traits<std::decay_t<T>>::unwrap(ctx, val);
+            JS_FreeValue(ctx, val);
+            return result;
+        }
+        catch(...)
+        {
+            JS_FreeValue(ctx, val);
+            throw;
+        }
+    }
+}
+
+template <typename T, size_t I, size_t NArgs>
+struct unwrap_arg_impl {
+    static auto unwrap(JSContext * ctx, int argc, JSValueConst * argv)
+    {
+        if (size_t(argc) <= I) {
+            JS_ThrowTypeError(ctx, "Expected at least %lu arguments but received %d",
+                              (unsigned long)NArgs, argc);
+            throw exception{ctx};
+        }
+        return js_traits<std::decay_t<T>>::unwrap(ctx, argv[I]);
+    }
+};
+
+template <typename T, size_t I, size_t NArgs>
+struct unwrap_arg_impl<rest<T>, I, NArgs> {
+    static rest<T> unwrap(JSContext * ctx, int argc, JSValueConst * argv) {
+        static_assert(I == NArgs - 1, "The `rest` argument must be the last function argument.");
+        rest<T> result;
+        result.reserve(argc - I);
+        for (size_t i = I; i < size_t(argc); ++i)
+            result.push_back(js_traits<T>::unwrap(ctx, argv[i]));
+        return result;
+    }
+};
+
+template <class Tuple, std::size_t... I>
+Tuple unwrap_args_impl(JSContext * ctx, int argc, JSValueConst * argv, std::index_sequence<I...>)
+{
+    return Tuple{unwrap_arg_impl<std::tuple_element_t<I, Tuple>, I, sizeof...(I)>::unwrap(ctx, argc, argv)...};
+}
+
+/** Helper function to convert an array of JSValues to a tuple.
+ * @tparam Args C++ types of the argv array
+ */
+template <typename... Args>
+std::tuple<std::decay_t<Args>...> unwrap_args(JSContext * ctx, int argc, JSValueConst * argv)
+{
+    return unwrap_args_impl<std::tuple<std::decay_t<Args>...>>(ctx, argc, argv, std::make_index_sequence<sizeof...(Args)>());
+}
+
+/** Helper function to call f with an array of JSValues.
+ * @tparam R return type of f
+ * @tparam Args argument types of f
+ * @tparam Callable type of f (inferred)
+ * @param ctx JSContext
+ * @param f callable object
+ * @param argv array of JSValue's
+ * @return converted return value of f or JS_NULL if f returns void
+ */
+template <typename R, typename... Args, typename Callable>
+JSValue wrap_call(JSContext * ctx, Callable&& f, int argc, JSValueConst * argv) noexcept
+{
+    try
+    {
+        if constexpr(std::is_same_v<R, void>)
+        {
+            std::apply(std::forward<Callable>(f), unwrap_args<Args...>(ctx, argc, argv));
+            return JS_NULL;
+        }
+        else
+        {
+            return js_traits<std::decay_t<R>>::wrap(ctx,
+                                                    std::apply(std::forward<Callable>(f),
+                                                               unwrap_args<Args...>(ctx, argc, argv)));
+        }
+    }
+    catch(exception)
+    {
+        return JS_EXCEPTION;
+    }
+    catch (std::exception const & err)
+    {
+        JS_ThrowInternalError(ctx, "%s", err.what());
+        return JS_EXCEPTION;
+    }
+    catch (...)
+    {
+        JS_ThrowInternalError(ctx, "Unknown error");
+        return JS_EXCEPTION;
+    }
+}
+
+/** Same as wrap_call, but pass this_value as first argument.
+ * @tparam FirstArg type of this_value
+ */
+template <typename R, typename FirstArg, typename... Args, typename Callable>
+JSValue wrap_this_call(JSContext * ctx, Callable&& f, JSValueConst this_value, int argc, JSValueConst * argv) noexcept
+{
+    try
+    {
+        if constexpr(std::is_same_v<R, void>)
+        {
+            std::apply(std::forward<Callable>(f), std::tuple_cat(unwrap_args<FirstArg>(ctx, 1, &this_value),
+                                                                 unwrap_args<Args...>(ctx, argc, argv)));
+            return JS_NULL;
+        }
+        else
+        {
+            return js_traits<std::decay_t<R>>::wrap(ctx,
+                                                    std::apply(std::forward<Callable>(f),
+                                                               std::tuple_cat(
+                                                                       unwrap_args<FirstArg>(ctx, 1, &this_value),
+                                                                       unwrap_args<Args...>(ctx, argc, argv))));
+        }
+    }
+    catch(exception)
+    {
+        return JS_EXCEPTION;
+    }
+    catch (std::exception const & err)
+    {
+        JS_ThrowInternalError(ctx, "%s", err.what());
+        return JS_EXCEPTION;
+    }
+    catch (...)
+    {
+        JS_ThrowInternalError(ctx, "Unknown error");
+        return JS_EXCEPTION;
+    }
+}
+
+template <class Tuple, std::size_t... I>
+void wrap_args_impl(JSContext * ctx, JSValue * argv, Tuple tuple, std::index_sequence<I...>)
+{
+    ((argv[I] = js_traits<std::decay_t<std::tuple_element_t<I, Tuple>>>::wrap(ctx, std::get<I>(tuple))), ...);
+}
+
+/** Converts C++ args to JSValue array.
+ * @tparam Args argument types
+ * @param argv array of size at least sizeof...(Args)
+ */
+template <typename... Args>
+void wrap_args(JSContext * ctx, JSValue * argv, Args&& ... args)
+{
+    wrap_args_impl(ctx, argv, std::make_tuple(std::forward<Args>(args)...),
+                   std::make_index_sequence<sizeof...(Args)>());
+}
+
+// Helper trait to obtain `T` in `T::*` expressions
+template<typename T> struct class_from_member_pointer { using type = void; };
+template<typename T, typename U> struct class_from_member_pointer<T U::*> { using type = U; };
+template<typename T> using class_from_member_pointer_t = typename class_from_member_pointer<T>::type;
+
+} // namespace detail
+
+/** A wrapper type for free and class member functions.
+ * Pointer to function F is a template argument.
+ * @tparam F either a pointer to free function or a pointer to class member function
+ * @tparam PassThis if true and F is a pointer to free function, passes Javascript "this" value as first argument:
+ */
+template <auto F, bool PassThis = false /* pass this as the first argument */>
+struct fwrapper
+{
+    /// "name" property of the JS function object (not defined if nullptr)
+    const char * name = nullptr;
+};
+
+/** Conversion to JSValue for free function in fwrapper. */
+template <typename R, typename... Args, R (* F)(Args...), bool PassThis>
+struct js_traits<fwrapper<F, PassThis>>
+{
+    static JSValue wrap(JSContext * ctx, fwrapper<F, PassThis> fw) noexcept
+    {
+        return JS_NewCFunction(ctx, [](JSContext * ctx, JSValueConst this_value, int argc,
+                                       JSValueConst * argv) noexcept -> JSValue {
+            if constexpr(PassThis)
+                return detail::wrap_this_call<R, Args...>(ctx, F, this_value, argc, argv);
+            else
+                return detail::wrap_call<R, Args...>(ctx, F, argc, argv);
+        }, fw.name, sizeof...(Args));
+
+    }
+};
+
+/** Conversion to JSValue for class member function in fwrapper. PassThis is ignored and treated as true */
+template <typename R, class T, typename... Args, R (T::*F)(Args...), bool PassThis/*=ignored*/>
+struct js_traits<fwrapper<F, PassThis>>
+{
+    static JSValue wrap(JSContext * ctx, fwrapper<F, PassThis> fw) noexcept
+    {
+        return JS_NewCFunction(ctx, [](JSContext * ctx, JSValueConst this_value, int argc,
+                                       JSValueConst * argv) noexcept -> JSValue {
+            return detail::wrap_this_call<R, std::shared_ptr<T>, Args...>(ctx, F, this_value, argc, argv);
+        }, fw.name, sizeof...(Args));
+
+    }
+};
+
+/** Conversion to JSValue for const class member function in fwrapper. PassThis is ignored and treated as true */
+template <typename R, class T, typename... Args, R (T::*F)(Args...) const, bool PassThis/*=ignored*/>
+struct js_traits<fwrapper<F, PassThis>>
+{
+    static JSValue wrap(JSContext * ctx, fwrapper<F, PassThis> fw) noexcept
+    {
+        return JS_NewCFunction(ctx, [](JSContext * ctx, JSValueConst this_value, int argc,
+                                       JSValueConst * argv) noexcept -> JSValue {
+            return detail::wrap_this_call<R, std::shared_ptr<T>, Args...>(ctx, F, this_value, argc, argv);
+        }, fw.name, sizeof...(Args));
+
+    }
+};
+
+/** A wrapper type for constructor of type T with arguments Args.
+ * Compilation fails if no such constructor is defined.
+ * @tparam Args constructor arguments
+ */
+template <class T, typename... Args>
+struct ctor_wrapper
+{
+    static_assert(std::is_constructible<T, Args...>::value, "no such constructor!");
+    /// "name" property of JS constructor object
+    const char * name = nullptr;
+};
+
+namespace detail {
+/// equivalent to JS_GetPropertyStr(ctx, this_value, "prototype");
+inline JSValue GetPropertyPrototype(JSContext * ctx, JSValueConst this_value)
+{
+    // constant atom: doesn't need to be freed and doesn't change with context
+    static const JSAtom JS_ATOM_prototype = JS_NewAtom(ctx, "prototype");
+    return JS_GetProperty(ctx, this_value, JS_ATOM_prototype);
+}
+} // namespace detail
+
+/** Conversion to JSValue for ctor_wrapper. */
+template <class T, typename... Args>
+struct js_traits<ctor_wrapper<T, Args...>>
+{
+    static JSValue wrap(JSContext * ctx, ctor_wrapper<T, Args...> cw) noexcept
+    {
+        return JS_NewCFunction2(ctx, [](JSContext * ctx, JSValueConst this_value, int argc,
+                                        JSValueConst * argv) noexcept -> JSValue {
+
+            if(js_traits<std::shared_ptr<T>>::QJSClassId == 0) // not registered
+            {
+#if defined(__cpp_rtti)
+                // automatically register class on first use (no prototype)
+                js_traits<std::shared_ptr<T>>::register_class(ctx, typeid(T).name());
+#else
+                JS_ThrowTypeError(ctx, "quickjspp ctor_wrapper<T>::wrap: Class is not registered");
+                return JS_EXCEPTION;
+#endif
+            }
+
+            auto proto = detail::GetPropertyPrototype(ctx, this_value);
+            if(JS_IsException(proto))
+                return proto;
+            auto jsobj = JS_NewObjectProtoClass(ctx, proto, js_traits<std::shared_ptr<T>>::QJSClassId);
+            JS_FreeValue(ctx, proto);
+            if(JS_IsException(jsobj))
+                return jsobj;
+
+            try
+            {
+                std::shared_ptr<T> ptr = std::apply(std::make_shared<T, Args...>, detail::unwrap_args<Args...>(ctx, argc, argv));
+                JS_SetOpaque(jsobj, new std::shared_ptr<T>(std::move(ptr)));
+                return jsobj;
+            }
+            catch (exception)
+            {
+                JS_FreeValue(ctx, jsobj);
+                return JS_EXCEPTION;
+            }
+            catch (std::exception const & err)
+            {
+                JS_FreeValue(ctx, jsobj);
+                JS_ThrowInternalError(ctx, "%s", err.what());
+                return JS_EXCEPTION;
+            }
+            catch (...)
+            {
+                JS_FreeValue(ctx, jsobj);
+                JS_ThrowInternalError(ctx, "Unknown error");
+                return JS_EXCEPTION;
+            }
+
+            // return detail::wrap_call<std::shared_ptr<T>, Args...>(ctx, std::make_shared<T, Args...>, argv);
+        }, cw.name, sizeof...(Args), JS_CFUNC_constructor, 0);
+    }
+};
+
+
+/** Conversions for std::shared_ptr<T>. Empty shared_ptr corresponds to JS_NULL.
+ * T should be registered to a context before conversions.
+ * @tparam T class type
+ */
+template <class T>
+struct js_traits<std::shared_ptr<T>>
+{
+    /// Registered class id in QuickJS.
+    inline static JSClassID QJSClassId = 0;
+
+    /// Signature of the function to obtain the std::shared_ptr from the JSValue.
+    using ptr_cast_fcn_t = std::function<std::shared_ptr<T>(JSContext*, JSValueConst)>;
+
+    /// Used by registerDerivedClass to register new derived classes with this class' base type.
+    inline static std::function<void(JSClassID, ptr_cast_fcn_t)> registerWithBase;
+
+    /// Mapping between derived class' JSClassID and function to obtain the std::shared_ptr from the JSValue.
+    inline static std::unordered_map<JSClassID, ptr_cast_fcn_t> ptrCastFcnMap;
+
+    /** Register a class as a derived class.
+     *
+     * @tparam D type of the derived class
+     * @param derived_class_id class id of the derived class
+     * @param ptr_cast_fcn function to obtain a std::shared_ptr from the JSValue
+     */
+    template<typename D>
+    static void registerDerivedClass(JSClassID derived_class_id, ptr_cast_fcn_t ptr_cast_fcn) {
+        static_assert(std::is_base_of<T,D>::value && !std::is_same<T,D>::value, "Type is not a derived class");
+        using derived_ptr_cast_fcn_t = typename js_traits<std::shared_ptr<D>>::ptr_cast_fcn_t;
+
+        // Register how to obtain the std::shared_ptr from the derived class.
+        ptrCastFcnMap[derived_class_id] = ptr_cast_fcn;
+
+        // Propagate the registration to our base class (if any).
+        if (registerWithBase) registerWithBase(derived_class_id, ptr_cast_fcn);
+
+        // Instrument the derived class so that it can propagate new derived classes to us.
+        auto old_registerWithBase = js_traits<std::shared_ptr<D>>::registerWithBase;
+        js_traits<std::shared_ptr<D>>::registerWithBase =
+            [old_registerWithBase = std::move(old_registerWithBase)]
+            (JSClassID derived_class_id, derived_ptr_cast_fcn_t derived_ptr_cast_fcn){
+                if (old_registerWithBase) old_registerWithBase(derived_class_id, derived_ptr_cast_fcn);
+                registerDerivedClass<D>(derived_class_id, [derived_cast_fcn = std::move(derived_ptr_cast_fcn)](JSContext * ctx, JSValueConst v) {
+                    return std::shared_ptr<T>(derived_cast_fcn(ctx, v));
+                });
+            };
+    }
+
+    template <typename B>
+    static
+    std::enable_if_t<std::is_same_v<B, T> || std::is_same_v<B, void>>
+    ensureCanCastToBase() { }
+
+    template <typename B>
+    static
+    std::enable_if_t<!std::is_same_v<B, T> && !std::is_same_v<B, void>>
+    ensureCanCastToBase() {
+        static_assert(std::is_base_of_v<B, T>, "Type is not a derived class");
+
+        if(js_traits<std::shared_ptr<T>>::QJSClassId == 0)
+            JS_NewClassID(&js_traits<std::shared_ptr<T>>::QJSClassId);
+
+        js_traits<std::shared_ptr<B>>::template registerDerivedClass<T>(QJSClassId, unwrap);
+    }
+
+    template <auto M>
+    static void ensureCanCastToBase() {
+        ensureCanCastToBase<detail::class_from_member_pointer_t<decltype(M)>>();
+    }
+
+    /** Stores offsets to qjs::Value members of T.
+     * These values should be marked by class_registrar::mark for QuickJS garbage collector
+     * so that the cycle removal algorithm can find the other objects referenced by this object.
+     */
+    static inline std::vector<Value T::*> markOffsets;
+
+    /** Register class in QuickJS context.
+     *
+     * @param ctx context
+     * @param name class name
+     * @param proto class prototype or JS_NULL
+     * @param call QJS call function. see quickjs doc
+     * @param exotic pointer to QJS exotic methods(static lifetime) which allow custom property handling. see quickjs doc
+     * @throws exception
+     */
+    static void register_class(JSContext * ctx, const char * name, JSValue proto = JS_NULL,
+                               JSClassCall * call = nullptr, JSClassExoticMethods * exotic = nullptr)
+    {
+        if(QJSClassId == 0)
+        {
+            JS_NewClassID(&QJSClassId);
+        }
+        auto rt = JS_GetRuntime(ctx);
+        if(!JS_IsRegisteredClass(rt, QJSClassId))
+        {
+            JSClassGCMark * marker = nullptr;
+            if(!markOffsets.empty())
+            {
+                marker = [](JSRuntime *rt, JSValueConst val, JS_MarkFunc *mark_func) {
+                    auto pptr = static_cast<std::shared_ptr<T> *>(JS_GetOpaque(val, QJSClassId));
+                    assert(pptr);
+                    const T * ptr = pptr->get();
+                    assert(ptr);
+                    for(Value T::* member : markOffsets)
+                    {
+                        JS_MarkValue(rt, (*ptr.*member).v, mark_func);
+                    }
+                };
+            }
+            JSClassDef def{
+                    name,
+                    // destructor (finalizer)
+                    [](JSRuntime * rt, JSValue obj) noexcept {
+                        auto pptr = static_cast<std::shared_ptr<T> *>(JS_GetOpaque(obj, QJSClassId));
+                        delete pptr;
+                    },
+                    // mark
+                    marker,
+                    // call
+                    call,
+                    // exotic
+                    exotic
+            };
+            int e = JS_NewClass(rt, QJSClassId, &def);
+            if(e < 0)
+            {
+                JS_ThrowInternalError(ctx, "Can't register class %s", name);
+                throw exception{ctx};
+            }
+        }
+        JS_SetClassProto(ctx, QJSClassId, proto);
+    }
+
+    /** Create a JSValue from std::shared_ptr<T>.
+     * Creates an object with class if #QJSClassId and sets its opaque pointer to a new copy of #ptr.
+     */
+    static JSValue wrap(JSContext * ctx, std::shared_ptr<T> ptr)
+    {
+        if(!ptr)
+            return JS_NULL;
+        if(QJSClassId == 0) // not registered
+        {
+#if defined(__cpp_rtti)
+            // automatically register class on first use (no prototype)
+            register_class(ctx, typeid(T).name());
+#else
+            JS_ThrowTypeError(ctx, "quickjspp std::shared_ptr<T>::wrap: Class is not registered");
+            return JS_EXCEPTION;
+#endif
+        }
+        auto jsobj = JS_NewObjectClass(ctx, QJSClassId);
+        if(JS_IsException(jsobj))
+            return jsobj;
+
+        auto pptr = new std::shared_ptr<T>(std::move(ptr));
+        JS_SetOpaque(jsobj, pptr);
+        return jsobj;
+    }
+
+    /// @throws exception if #v doesn't have the correct class id
+    static std::shared_ptr<T> unwrap(JSContext * ctx, JSValueConst v)
+    {
+        std::shared_ptr<T> ptr = nullptr;
+        if (JS_IsNull(v)) {
+            return ptr;
+        }
+        auto obj_class_id = JS_GetClassID(v);
+
+        if (obj_class_id == QJSClassId) {
+            // The JS object is of class T
+            void * opaque = JS_GetOpaque2(ctx, v, obj_class_id);
+            assert(opaque && "No opaque pointer in object");
+            ptr = *static_cast<std::shared_ptr<T> *>(opaque);
+        } else if (ptrCastFcnMap.count(obj_class_id)) {
+            // The JS object is of a class derived from T
+            ptr = ptrCastFcnMap[obj_class_id](ctx, v);
+        } else {
+            // The JS object does not derives from T
+            JS_ThrowTypeError(ctx, "Expected type %s, got object with classid %d",
+                              QJSPP_TYPENAME(T), obj_class_id);
+            throw exception{ctx};
+        }
+        if(!ptr) {
+            JS_ThrowInternalError(ctx, "Object's opaque pointer is NULL");
+            throw exception{ctx};
+        }
+        return ptr;
+    }
+};
+
+/** Conversions for non-owning pointers to class T. nullptr corresponds to JS_NULL.
+ * @tparam T class type
+ */
+template <class T>
+struct js_traits<T *, std::enable_if_t<std::is_class_v<T>>>
+{
+    static JSValue wrap(JSContext * ctx, T * ptr)
+    {
+        if (ptr == nullptr) {
+            return JS_NULL;
+        }
+        if(js_traits<std::shared_ptr<T>>::QJSClassId == 0) // not registered
+        {
+#if defined(__cpp_rtti)
+            // If you have an error here with T=JSValueConst
+            // it probably means you are passing JSValueConst to where JSValue is expected
+            js_traits<std::shared_ptr<T>>::register_class(ctx, typeid(T).name());
+#else
+            JS_ThrowTypeError(ctx, "quickjspp js_traits<T *>::wrap: Class is not registered");
+            return JS_EXCEPTION;
+#endif
+        }
+        auto jsobj = JS_NewObjectClass(ctx, js_traits<std::shared_ptr<T>>::QJSClassId);
+        if(JS_IsException(jsobj))
+            return jsobj;
+
+        // shared_ptr with empty deleter since we don't own T*
+        auto pptr = new std::shared_ptr<T>(ptr, [](T *) {});
+        JS_SetOpaque(jsobj, pptr);
+        return jsobj;
+    }
+
+    static T * unwrap(JSContext * ctx, JSValueConst v)
+    {
+        if (JS_IsNull(v)) {
+            return nullptr;
+        }
+        auto ptr = js_traits<std::shared_ptr<T>>::unwrap(ctx, v);
+        return ptr.get();
+    }
+};
+
+/** Conversions for enums. */
+template <typename E>
+struct js_traits<E, std::enable_if_t<std::is_enum_v<E>>> {
+    using T = std::underlying_type_t<E>;
+    static E unwrap(JSContext* ctx, JSValue v) noexcept {
+        return static_cast<E>(js_traits<T>::unwrap(ctx, v));
+    }
+
+    static JSValue wrap(JSContext* ctx, E t) noexcept {
+        return js_traits<T>::wrap(ctx, static_cast<T>(t));;
+    }
+};
+
+namespace detail {
+/** A faster std::function-like object with type erasure.
+ * Used to convert any callable objects (including lambdas) to JSValue.
+ */
+struct function
+{
+    JSValue
+    (* invoker)(function * self, JSContext * ctx, JSValueConst this_value, int argc, JSValueConst * argv) = nullptr;
+
+    void (* destroyer)(function * self) = nullptr;
+
+    alignas(std::max_align_t) char functor[];
+
+    template <typename Functor>
+    static function * create(JSRuntime * rt, Functor&& f)
+    {
+        using Functor_t = std::decay_t<Functor>;
+        auto fptr = static_cast<function *>(js_malloc_rt(rt, sizeof(function) + sizeof(Functor_t)));
+        if(!fptr)
+            throw std::bad_alloc{};
+        new(fptr) function;
+        auto functorptr = reinterpret_cast<Functor_t *>(fptr->functor);
+        new(functorptr) Functor_t(std::forward<Functor>(f));
+        fptr->destroyer = nullptr;
+        if constexpr(!std::is_trivially_destructible_v<Functor_t>)
+        {
+            fptr->destroyer = [](function * fptr) {
+                auto functorptr = reinterpret_cast<Functor_t *>(fptr->functor);
+                functorptr->~Functor_t();
+            };
+        }
+        return fptr;
+    }
+};
+
+static_assert(std::is_trivially_destructible_v<function>);
+}
+
+template <>
+struct js_traits<detail::function>
+{
+    inline static JSClassID QJSClassId = 0;
+
+    // TODO: replace ctx with rt
+    static void register_class(JSContext * ctx, const char * name)
+    {
+        if(QJSClassId == 0)
+        {
+            JS_NewClassID(&QJSClassId);
+        }
+        auto rt = JS_GetRuntime(ctx);
+        if(JS_IsRegisteredClass(rt, QJSClassId))
+            return;
+        JSClassDef def{
+                name,
+                // destructor
+                [](JSRuntime * rt, JSValue obj) noexcept {
+                    auto fptr = static_cast<detail::function *>(JS_GetOpaque(obj, QJSClassId));
+                    assert(fptr);
+                    if(fptr->destroyer)
+                        fptr->destroyer(fptr);
+                    js_free_rt(rt, fptr);
+                },
+                nullptr, // mark
+                // call
+                [](JSContext * ctx, JSValueConst func_obj, JSValueConst this_val, int argc,
+                   JSValueConst * argv, int flags) -> JSValue {
+                    auto ptr = static_cast<detail::function *>(JS_GetOpaque2(ctx, func_obj, QJSClassId));
+                    if(!ptr)
+                        return JS_EXCEPTION;
+                    return ptr->invoker(ptr, ctx, this_val, argc, argv);
+                },
+                nullptr
+        };
+        int e = JS_NewClass(rt, QJSClassId, &def);
+        if(e < 0)
+            throw std::runtime_error{"Cannot register C++ function class"};
+    }
+};
+
+
+/** Traits for accessing object properties.
+ * @tparam Key property key type (uint32 and strings are supported)
+ */
+template <typename Key>
+struct js_property_traits
+{
+    static void set_property(JSContext * ctx, JSValue this_obj, Key key, JSValue value);
+
+    static JSValue get_property(JSContext * ctx, JSValue this_obj, Key key);
+};
+
+template <>
+struct js_property_traits<const char *>
+{
+    static void set_property(JSContext * ctx, JSValue this_obj, const char * name, JSValue value)
+    {
+        int err = JS_SetPropertyStr(ctx, this_obj, name, value);
+        if(err < 0)
+            throw exception{ctx};
+    }
+
+    static JSValue get_property(JSContext * ctx, JSValue this_obj, const char * name) noexcept
+    {
+        return JS_GetPropertyStr(ctx, this_obj, name);
+    }
+};
+
+template <>
+struct js_property_traits<uint32_t>
+{
+    static void set_property(JSContext * ctx, JSValue this_obj, uint32_t idx, JSValue value)
+    {
+        int err = JS_SetPropertyUint32(ctx, this_obj, idx, value);
+        if(err < 0)
+            throw exception{ctx};
+    }
+
+    static JSValue get_property(JSContext * ctx, JSValue this_obj, uint32_t idx) noexcept
+    {
+        return JS_GetPropertyUint32(ctx, this_obj, idx);
+    }
+};
+
+template <>
+struct js_property_traits<int> : js_property_traits<uint32_t> {};
+
+
+namespace detail {
+template <typename Key>
+struct property_proxy
+{
+    JSContext * ctx;
+    JSValue this_obj;
+    Key key;
+
+    /** Conversion helper function */
+    template <typename T>
+    T as() const
+    {
+        return unwrap_free<T>(ctx, js_property_traits<Key>::get_property(ctx, this_obj, key));
+    }
+
+    /** Explicit conversion operator (to any type) */
+    template <typename T>
+    explicit operator T() const { return as<T>(); }
+
+    /** Implicit converion to qjs::Value */
+    operator Value() const; // defined later due to Value being incomplete type
+
+    /// noncopyable
+    property_proxy& operator =(property_proxy) = delete;
+
+    template <typename T>
+    property_proxy& operator =(T&& value)
+    {
+        js_property_traits<Key>::set_property(ctx, this_obj, key,
+                                              js_traits<std::decay_t<T>>::wrap(ctx, std::forward<T>(value)));
+        return *this;
+    }
+
+    template <typename Key2>
+    property_proxy<Key2> operator[](Key2 key2) const
+    {
+        return {ctx, as<JSValue>(), std::move(key2)};
+    }
+
+    ~property_proxy() noexcept { JS_FreeValue(ctx, this_obj); }
+};
+
+
+// class member variable getter/setter
+template <auto M>
+struct get_set {};
+
+// M -  member object
+template <class T, typename R, R T::*M>
+struct get_set<M>
+{
+    using is_const = std::is_const<R>;
+
+    static const R& get(std::shared_ptr<T> ptr)
+    {
+        return *ptr.*M;
+    }
+
+    static R& set(std::shared_ptr<T> ptr, R value)
+    {
+        return *ptr.*M = std::move(value);
+    }
+
+};
+
+// M - static member object
+template <typename R, R *M>
+struct get_set<M>
+{
+    using is_const = std::is_const<R>;
+
+    static const R& get(bool)
+    {
+        return *M;
+    }
+
+    static R& set(bool, R value)
+    {
+        return *M = std::move(value);
+    }
+
+};
+
+} // namespace detail
+
+/** JSValue with RAAI semantics.
+ * A wrapper over (JSValue v, JSContext * ctx).
+ * Calls JS_FreeValue(ctx, v) on destruction. Can be copied and moved.
+ * A JSValue can be released by either JSValue x = std::move(value); or JSValue x = value.release(), then the Value becomes invalid and FreeValue won't be called
+ * Can be converted to C++ type, for example: auto string = value.as<std::string>(); qjs::exception would be thrown on error
+ * Properties can be accessed (read/write): value["property1"] = 1; value[2] = "2";
+ */
+class Value
+{
+public:
+    JSValue v;
+    JSContext * ctx = nullptr;
+
+public:
+    /** Use context.newValue(val) instead */
+    template <typename T>
+    Value(JSContext * ctx, T&& val) : ctx(ctx)
+    {
+        v = js_traits<std::decay_t<T>>::wrap(ctx, std::forward<T>(val));
+        if(JS_IsException(v))
+            throw exception{ctx};
+    }
+
+    Value(JSValue&& v) noexcept : v(std::move(v)), ctx(nullptr) {}
+
+    Value(const Value& rhs) noexcept
+    {
+        ctx = rhs.ctx;
+        v = JS_DupValue(ctx, rhs.v);
+    }
+
+    Value(Value&& rhs) noexcept
+    {
+        std::swap(ctx, rhs.ctx);
+        v = rhs.v;
+    }
+
+    Value& operator =(Value rhs) noexcept
+    {
+        std::swap(ctx, rhs.ctx);
+        std::swap(v, rhs.v);
+        return *this;
+    }
+
+    bool operator ==(JSValueConst other) const
+    {
+        return JS_VALUE_GET_TAG(v) == JS_VALUE_GET_TAG(other) && JS_VALUE_GET_PTR(v) == JS_VALUE_GET_PTR(other);
+    }
+
+    bool operator !=(JSValueConst other) const { return !((*this) == other); }
+
+    /** Returns true if 2 values are the same (equality for arithmetic types or point to the same object) */
+    bool operator ==(const Value& rhs) const
+    {
+        return (*this == rhs.v);
+    }
+
+    bool operator !=(const Value& rhs) const { return !((*this) == rhs); }
+
+
+    ~Value()
+    {
+        if(ctx) JS_FreeValue(ctx, v);
+    }
+
+    bool isError() const { return JS_IsError(ctx, v); }
+
+    /** Conversion helper function: value.as<T>()
+     * @tparam T type to convert to
+     * @return type returned by js_traits<std::decay_t<T>>::unwrap that should be implicitly convertible to T
+     * */
+    template <typename T>
+    auto as() const { return js_traits<std::decay_t<T>>::unwrap(ctx, v); }
+
+    /** Explicit conversion: static_cast<T>(value) or (T)value */
+    template <typename T>
+    explicit operator T() const { return as<T>(); }
+
+    JSValue release() noexcept// dont call freevalue
+    {
+        ctx = nullptr;
+        return v;
+    }
+
+    /** Implicit conversion to JSValue (rvalue only). Example: JSValue v = std::move(value); */
+    operator JSValue()&& noexcept { return release(); }
+
+
+    /** Access JS properties. Returns proxy type which is implicitly convertible to qjs::Value */
+    template <typename Key>
+    detail::property_proxy<Key> operator [](Key key)
+    {
+        assert(ctx && "Trying to access properties of Value with no JSContext");
+        return {ctx, JS_DupValue(ctx, v), std::move(key)};
+    }
+
+
+    // add("f", []() {...});
+    template <typename Function>
+    Value& add(const char * name, Function&& f)
+    {
+        (*this)[name] = js_traits<decltype(std::function{std::forward<Function>(f)})>::wrap(ctx,
+                                                                                            std::forward<Function>(f));
+        return *this;
+    }
+
+    // add<&f>("f");
+    // add<&T::f>("f");
+    template <auto F>
+    std::enable_if_t<std::is_member_function_pointer_v<decltype(F)> || std::is_function_v<std::remove_pointer_t<decltype(F)>>, Value&>
+    add(const char * name)
+    {
+        (*this)[name] = fwrapper<F>{name};
+        return *this;
+    }
+
+    // add_getter_setter<&T::get_member, &T::set_member>("member");
+    template <auto FGet, auto FSet>
+    Value& add_getter_setter(const char * name)
+    {
+        auto prop = JS_NewAtom(ctx, name);
+        using fgetter = fwrapper<FGet, true>;
+        using fsetter = fwrapper<FSet, true>;
+        int ret = JS_DefinePropertyGetSet(ctx, v, prop,
+                                          js_traits<fgetter>::wrap(ctx, fgetter{name}),
+                                          js_traits<fsetter>::wrap(ctx, fsetter{name}),
+                                          JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE | JS_PROP_ENUMERABLE
+        );
+        JS_FreeAtom(ctx, prop);
+        if(ret < 0)
+            throw exception{ctx};
+        return *this;
+    }
+
+    // add_getter<&T::get_member>("member");
+    template <auto FGet>
+    Value& add_getter(const char * name)
+    {
+        auto prop = JS_NewAtom(ctx, name);
+        using fgetter = fwrapper<FGet, true>;
+        int ret = JS_DefinePropertyGetSet(ctx, v, prop,
+                                          js_traits<fgetter>::wrap(ctx, fgetter{name}),
+                                          JS_UNDEFINED,
+                                          JS_PROP_CONFIGURABLE | JS_PROP_ENUMERABLE
+        );
+        JS_FreeAtom(ctx, prop);
+        if(ret < 0)
+            throw exception{ctx};
+        return *this;
+    }
+
+    // add<&T::member>("member");
+    template <auto M>
+    std::enable_if_t<std::is_member_object_pointer_v<decltype(M)>, Value&>
+    add(const char * name)
+    {
+        if constexpr (detail::get_set<M>::is_const::value)
+            return add_getter<detail::get_set<M>::get>(name);
+        else
+            return add_getter_setter<detail::get_set<M>::get, detail::get_set<M>::set>(name);
+    }
+
+    // add<&T::static_member>("static_member");
+    template <auto M>
+    std::enable_if_t<std::is_pointer_v<decltype(M)> && !std::is_function_v<std::remove_pointer_t<decltype(M)>> , Value&>
+    add(const char * name)
+    {
+        if constexpr (detail::get_set<M>::is_const::value)
+            return add_getter<detail::get_set<M>::get>(name);
+        else
+            return add_getter_setter<detail::get_set<M>::get, detail::get_set<M>::set>(name);
+    }
+
+    std::string
+    toJSON(const Value& replacer = JS_UNDEFINED, const Value& space = JS_UNDEFINED)
+    {
+        assert(ctx);
+        assert(!replacer.ctx || ctx == replacer.ctx);
+        assert(!space.ctx || ctx == space.ctx);
+        return (std::string) Value{ctx, JS_JSONStringify(ctx, v, replacer.v, space.v)};
+    }
+
+    /** same as Context::eval() but with this Value as 'this' */
+    Value evalThis(std::string_view buffer, const char * filename = "<evalThis>", int flags = 0)
+    {
+        assert(buffer.data()[buffer.size()] == '\0' && "eval buffer is not null-terminated"); // JS_Eval requirement
+        assert(ctx);
+        return Value{ctx, JS_EvalThis(ctx, v, buffer.data(), buffer.size(), filename, flags)};
+    }
+
+};
+
+/** Thin wrapper over JSRuntime * rt
+ * Calls JS_FreeRuntime on destruction. noncopyable.
+ */
+class Runtime
+{
+public:
+    JSRuntime * rt;
+
+    Runtime()
+    {
+        rt = JS_NewRuntime();
+        if(!rt)
+            throw std::runtime_error{"qjs: Cannot create runtime"};
+
+        JS_SetHostUnhandledPromiseRejectionTracker(rt, promise_unhandled_rejection_tracker, NULL);
+        JS_SetModuleLoaderFunc(rt, nullptr, module_loader, nullptr);
+    }
+
+    // noncopyable
+    Runtime(const Runtime&) = delete;
+
+    ~Runtime()
+    {
+        JS_FreeRuntime(rt);
+    }
+
+    /// @return pointer to qjs::Context of the executed job or nullptr if no job is pending
+    Context * executePendingJob();
+
+    bool isJobPending() const {
+        return JS_IsJobPending(rt);
+    }
+
+private:
+    static void promise_unhandled_rejection_tracker(JSContext *ctx, JSValueConst promise,
+                                                    JSValueConst reason, JS_BOOL is_handled, void *opaque);
+
+    static JSModuleDef *module_loader(JSContext *ctx,
+                                      const char *module_name, void *opaque);
+};
+
+namespace detail {
+
+inline std::optional<std::string> readFile(std::filesystem::path const & filepath)
+{
+    if (!std::filesystem::exists(filepath)) return std::nullopt;
+    std::ifstream f(filepath, std::ios::in | std::ios::binary);
+    if (!f.is_open()) return std::nullopt;
+    std::stringstream sstream;
+    sstream << f.rdbuf();
+    return sstream.str();
+}
+
+inline std::string toUri(std::string_view filename) {
+    auto fname = std::string{filename};
+    if (fname.find("://") < fname.find("/")) return fname;
+
+    auto fpath = std::filesystem::path(fname);
+    if (!fpath.is_absolute()) {
+        fpath = "." / fpath;
+    }
+    fpath = std::filesystem::weakly_canonical(fpath);
+    fname = "file://" + fpath.generic_string();
+    return fname;
+}
+
+}
+
+/** Wrapper over JSContext * ctx
+ * Calls JS_SetContextOpaque(ctx, this); on construction and JS_FreeContext on destruction
+ */
+class Context
+{
+public:
+    JSContext * ctx;
+
+    /** Module wrapper
+     * Workaround for lack of opaque pointer for module load function by keeping a list of modules in qjs::Context.
+     */
+    class Module
+    {
+        friend class Context;
+
+        JSModuleDef * m;
+        JSContext * ctx;
+        const char * name;
+
+        using nvp = std::pair<const char *, Value>;
+        std::vector<nvp> exports;
+    public:
+        Module(JSContext * ctx, const char * name) : ctx(ctx), name(name)
+        {
+            m = JS_NewCModule(ctx, name, [](JSContext * ctx, JSModuleDef * m) noexcept {
+                auto& context = Context::get(ctx);
+                auto it = std::find_if(context.modules.begin(), context.modules.end(),
+                                       [m](const Module& module) { return module.m == m; });
+                if(it == context.modules.end())
+                    return -1;
+                for(const auto& e : it->exports)
+                {
+                    if(JS_SetModuleExport(ctx, m, e.first, JS_DupValue(ctx, e.second.v)) != 0)
+                        return -1;
+                }
+                return 0;
+            });
+            if(!m)
+                throw exception{ctx};
+        }
+
+        Module& add(const char * name, JSValue&& value)
+        {
+            exports.push_back({name, {ctx, std::move(value)}});
+            JS_AddModuleExport(ctx, m, name);
+            return *this;
+        }
+
+
+        template <typename T>
+        Module& add(const char * name, T&& value)
+        {
+            return add(name, js_traits<T>::wrap(ctx, std::forward<T>(value)));
+        }
+
+        Module(const Module&) = delete;
+
+        Module(Module&&) = default;
+        //Module& operator=(Module&&) = default;
+
+
+        // function wrappers
+
+        /** Add free function F.
+         * Example:
+         * module.function<static_cast<double (*)(double)>(&::sin)>("sin");
+         */
+        template <auto F>
+        Module& function(const char * name)
+        {
+            return add(name, qjs::fwrapper<F>{name});
+        }
+
+        /** Add function object f.
+         * Slower than template version.
+         * Example: module.function("sin", [](double x) { return ::sin(x); });
+         */
+        template <typename F>
+        Module& function(const char * name, F&& f)
+        {
+            return add(name, js_traits<decltype(std::function{std::forward<F>(f)})>::wrap(ctx, std::forward<F>(f)));
+        }
+
+        // class register wrapper
+    private:
+        /** Helper class to register class members and constructors.
+         * See fun, constructor.
+         * Actual registration occurs at object destruction.
+         */
+        template <class T>
+        class class_registrar
+        {
+            const char * name;
+            qjs::Value prototype;
+            qjs::Context::Module& module;
+            qjs::Context& context;
+            qjs::Value ctor; // last added constructor
+        public:
+            explicit class_registrar(const char * name, qjs::Context::Module& module, qjs::Context& context) :
+                    name(name),
+                    prototype(context.newObject()),
+                    module(module),
+                    context(context),
+                    ctor(JS_NULL)
+            {
+            }
+
+            class_registrar(const class_registrar&) = delete;
+
+            /** Add functional object f
+             */
+            template <typename F>
+            class_registrar& fun(const char * name, F&& f)
+            {
+                prototype[name] = std::forward<F>(f);
+                return *this;
+            }
+
+            /** Add class member function or class member variable F
+             * Example:
+             * struct T { int var; int func(); }
+             * auto& module = context.addModule("module");
+             * module.class_<T>("T").fun<&T::var>("var").fun<&T::func>("func");
+             */
+            template <auto F>
+            class_registrar& fun(const char * name)
+            {
+                js_traits<std::shared_ptr<T>>::template ensureCanCastToBase<F>();
+                prototype.add<F>(name);
+                return *this;
+            }
+
+            /** Add a static member or function to the last added constructor.
+             * Example:
+             *  struct T { static int var; static int func(); }
+             *  module.class_<T>("T").contructor<>("T").static_fun<&T::var>("var").static_fun<&T::func>("func");
+             */
+            template <auto F>
+            class_registrar& static_fun(const char * name)
+            {
+                assert(!JS_IsNull(ctor.v) && "You should call .constructor before .static_fun");
+                js_traits<qjs::shared_ptr<T>>::template ensureCanCastToBase<F>();
+                ctor.add<F>(name);
+                return *this;
+            }
+
+            /** Add a property with custom getter and setter.
+             * Example:
+             * module.class_<T>("T").property<&T::getX, &T::setX>("x");
+             */
+            template <auto FGet, auto FSet = nullptr>
+            class_registrar& property(const char * name)
+            {
+                js_traits<std::shared_ptr<T>>::template ensureCanCastToBase<FGet>();
+                js_traits<std::shared_ptr<T>>::template ensureCanCastToBase<FSet>();
+                if constexpr (std::is_same_v<decltype(FSet), std::nullptr_t>)
+                    prototype.add_getter<FGet>(name);
+                else
+                    prototype.add_getter_setter<FGet, FSet>(name);
+                return *this;
+            }
+
+            /** Add class constructor
+             * @tparam Args contructor arguments
+             * @param name constructor name (if not specified class name will be used)
+             */
+            template <typename... Args>
+            class_registrar& constructor(const char * name = nullptr)
+            {
+                if(!name)
+                    name = this->name;
+                ctor = context.newValue(qjs::ctor_wrapper<T, Args...>{name});
+                JS_SetConstructor(context.ctx, ctor.v, prototype.v);
+                module.add(name, qjs::Value{ctor});
+                return *this;
+            }
+
+            /** Sets the base class
+             * @tparam B base class
+             */
+            template <class B>
+            class_registrar& base()
+            {
+                static_assert(!std::is_same_v<B, T>, "Type cannot be a base of itself");
+                assert(js_traits<std::shared_ptr<B>>::QJSClassId && "base class is not registered");
+                js_traits<std::shared_ptr<T>>::template ensureCanCastToBase<B>();
+                auto base_proto = JS_GetClassProto(context.ctx, js_traits<std::shared_ptr<B>>::QJSClassId);
+                int err = JS_SetPrototype(context.ctx, prototype.v, base_proto);
+                JS_FreeValue(context.ctx, base_proto);
+                if(err < 0)
+                    throw exception{context.ctx};
+                return *this;
+            }
+
+            /** All qjs::Value members of T should be marked by mark<> for QuickJS garbage collector
+             * so that the cycle removal algorithm can find the other objects referenced by this object.
+             */
+            template <Value T::* V>
+            class_registrar& mark()
+            {
+                js_traits<std::shared_ptr<T>>::markOffsets.push_back(V);
+                return *this;
+            }
+
+
+            ~class_registrar()
+            {
+                context.registerClass<T>(name, std::move(prototype));
+            }
+        };
+
+    public:
+        /** Add class to module.
+         * See \ref class_registrar.
+         */
+        template <class T>
+        class_registrar<T> class_(const char * name)
+        {
+            return class_registrar<T>{name, *this, qjs::Context::get(ctx)};
+        }
+
+    };
+
+    std::vector<Module> modules;
+private:
+    void init()
+    {
+        JS_SetContextOpaque(ctx, this);
+        js_traits<detail::function>::register_class(ctx, "C++ function");
+    }
+
+public:
+    Context(Runtime& rt) : Context(rt.rt) {}
+
+    Context(JSRuntime * rt)
+    {
+        ctx = JS_NewContext(rt);
+        if(!ctx)
+            throw std::runtime_error{"qjs: Cannot create context"};
+        init();
+    }
+
+    Context(JSContext * ctx) : ctx{ctx}
+    {
+        init();
+    }
+
+    // noncopyable
+    Context(const Context&) = delete;
+
+    ~Context()
+    {
+        modules.clear();
+        JS_FreeContext(ctx);
+    }
+
+    /** Callback triggered when a Promise rejection won't ever be handled */
+    std::function<void(Value)> onUnhandledPromiseRejection;
+
+    /** Data type returned by the moduleLoader function */
+    struct ModuleData {
+        std::optional<std::string> source, url;
+        ModuleData() : source(std::nullopt), url(std::nullopt) {}
+        ModuleData(std::optional<std::string> source) : source(std::move(source)), url(std::nullopt) {}
+        ModuleData(std::optional<std::string> url, std::optional<std::string> source) : source(std::move(source)), url(std::move(url)) {}
+    };
+
+    /** Function called to obtain the source of a module */
+    std::function<ModuleData(std::string_view)> moduleLoader =
+        [](std::string_view filename) -> ModuleData {
+            return ModuleData{ detail::toUri(filename), detail::readFile(filename) };
+        };
+
+    template <typename Function>
+    void enqueueJob(Function && job);
+
+    /** Create module and return a reference to it */
+    Module& addModule(const char * name)
+    {
+        modules.emplace_back(ctx, name);
+        return modules.back();
+    }
+
+    /** returns globalThis */
+    Value global() { return Value{ctx, JS_GetGlobalObject(ctx)}; }
+
+    /** returns new Object() */
+    Value newObject() { return Value{ctx, JS_NewObject(ctx)}; }
+
+    /** returns JS value converted from c++ object val */
+    template <typename T>
+    Value newValue(T&& val) { return Value{ctx, std::forward<T>(val)}; }
+
+    /** returns current exception associated with context and clears it. Should be called when qjs::exception is caught */
+    Value getException() { return Value{ctx, JS_GetException(ctx)}; }
+
+    /** Register class T for conversions to/from std::shared_ptr<T> to work.
+     * Wherever possible module.class_<T>("T")... should be used instead.
+     * @tparam T class type
+     * @param name class name in JS engine
+     * @param proto JS class prototype or JS_UNDEFINED
+     */
+    template <class T>
+    void registerClass(const char * name, JSValue proto = JS_NULL)
+    {
+        js_traits<std::shared_ptr<T>>::register_class(ctx, name, proto);
+    }
+
+    /// @see JS_Eval
+    Value eval(std::string_view buffer, const char * filename = "<eval>", int flags = 0)
+    {
+        assert(buffer.data()[buffer.size()] == '\0' && "eval buffer is not null-terminated"); // JS_Eval requirement
+        JSValue v = JS_Eval(ctx, buffer.data(), buffer.size(), filename, flags);
+        return Value{ctx, std::move(v)};
+    }
+
+    Value evalFile(const char * filename, int flags = 0)
+    {
+        auto buf = detail::readFile(filename);
+        if (!buf)
+            throw std::runtime_error{std::string{"evalFile: can't read file: "} + filename};
+        return eval(*buf, filename, flags);
+    }
+
+    /// @see JS_ParseJSON2
+    Value fromJSON(std::string_view buffer, const char * filename = "<fromJSON>", int flags = 0)
+    {
+        assert(buffer.data()[buffer.size()] == '\0' &&
+               "fromJSON buffer is not null-terminated"); // JS_ParseJSON requirement
+        return Value{ctx, JS_ParseJSON2(ctx, buffer.data(), buffer.size(), filename, flags)};
+    }
+
+    /** Get qjs::Context from JSContext opaque pointer */
+    static Context& get(JSContext * ctx)
+    {
+        void * ptr = JS_GetContextOpaque(ctx);
+        assert(ptr);
+        return *static_cast<Context *>(ptr);
+    }
+};
+
+/** Conversion traits for Value.
+ */
+template <>
+struct js_traits<Value>
+{
+    static Value unwrap(JSContext * ctx, JSValueConst v)
+    {
+        return Value{ctx, JS_DupValue(ctx, v)};
+    }
+
+    static JSValue wrap(JSContext * ctx, Value v) noexcept
+    {
+        assert(JS_GetRuntime(ctx) == JS_GetRuntime(v.ctx));
+        return v.release();
+    }
+};
+
+/** Convert to/from std::function. Actually accepts/returns callable object that is compatible with function<R (Args...)>.
+ * @tparam R return type
+ * @tparam Args argument types
+ */
+template <typename R, typename... Args>
+struct js_traits<std::function<R(Args...)>, int>
+{
+    static auto unwrap(JSContext * ctx, JSValueConst fun_obj)
+    {
+        const int argc = sizeof...(Args);
+        if constexpr(argc == 0)
+        {
+            return [jsfun_obj = Value{ctx, JS_DupValue(ctx, fun_obj)}]() -> R {
+                JSValue result = JS_Call(jsfun_obj.ctx, jsfun_obj.v, JS_UNDEFINED, 0, nullptr);
+                if(JS_IsException(result))
+                    throw exception{jsfun_obj.ctx};
+                return detail::unwrap_free<R>(jsfun_obj.ctx, result);
+            };
+        }
+        else
+        {
+            return [jsfun_obj = Value{ctx, JS_DupValue(ctx, fun_obj)}](Args ... args) -> R {
+                const int argc = sizeof...(Args);
+                JSValue argv[argc];
+                detail::wrap_args(jsfun_obj.ctx, argv, std::forward<Args>(args)...);
+                JSValue result = JS_Call(jsfun_obj.ctx, jsfun_obj.v, JS_UNDEFINED, argc,
+                                         const_cast<JSValueConst *>(argv));
+                for(int i = 0; i < argc; i++) JS_FreeValue(jsfun_obj.ctx, argv[i]);
+                if(JS_IsException(result))
+                    throw exception{jsfun_obj.ctx};
+                return detail::unwrap_free<R>(jsfun_obj.ctx, result);
+            };
+        }
+    }
+
+    /** Convert from function object functor to JSValue.
+     * Uses detail::function for type-erasure.
+     */
+    template <typename Functor>
+    static JSValue wrap(JSContext * ctx, Functor&& functor) noexcept
+    {
+        using detail::function;
+        assert(js_traits<function>::QJSClassId);
+        auto obj = JS_NewObjectClass(ctx, js_traits<function>::QJSClassId);
+        if(JS_IsException(obj))
+            return obj;
+        try
+        {
+            auto fptr = function::create(JS_GetRuntime(ctx), std::forward<Functor>(functor));
+            fptr->invoker = [](function * self, JSContext * ctx, JSValueConst this_value, int argc,
+                               JSValueConst * argv) {
+                assert(self);
+                auto f = reinterpret_cast<std::decay_t<Functor> *>(&self->functor);
+                return detail::wrap_call<R, Args...>(ctx, *f, argc, argv);
+            };
+            JS_SetOpaque(obj, fptr);
+            return obj;
+        }
+        catch(const std::exception& e)
+        {
+            JS_ThrowInternalError(ctx, "%s", e.what());
+            return JS_EXCEPTION;
+        }
+        catch(...)
+        {
+            JS_ThrowInternalError(ctx, "Unknown errror");
+            return JS_EXCEPTION;
+        }
+    }
+};
+
+namespace detail {
+
+template<typename T, typename = void>
+struct is_callable : std::is_function<T> { };
+
+template<typename T>
+struct is_callable<T, std::enable_if_t<std::is_same_v<decltype(void(&T::operator())), void>>> : std::true_type { };
+
+template<typename T>
+inline constexpr bool is_callable_v = is_callable<T>::value;
+
+}
+
+template <typename Function>
+struct js_traits<Function, std::enable_if_t<detail::is_callable_v<Function>>> {
+    static auto unwrap(JSContext * ctx, JSValueConst fun_obj)
+    {
+        return js_traits<
+            decltype(std::function{std::declval<Function>()}),
+            int
+        >::unwrap(ctx, fun_obj);
+    }
+
+    template <typename Functor>
+    static JSValue wrap(JSContext * ctx, Functor&& functor)
+    {
+        return js_traits<
+            decltype(std::function{std::declval<Function>()}),
+            int
+        >::wrap(ctx, std::forward<Functor>(functor));
+    }
+};
+
+/** Convert from std::vector<T> to Array and vice-versa. If Array holds objects that are non-convertible to T throws qjs::exception */
+template <class T>
+struct js_traits<std::vector<T>>
+{
+    static JSValue wrap(JSContext * ctx, const std::vector<T>& arr) noexcept
+    {
+        try
+        {
+            auto jsarray = Value{ctx, JS_NewArray(ctx)};
+            for(uint32_t i = 0; i < (uint32_t) arr.size(); i++)
+                jsarray[i] = arr[i];
+            return jsarray.release();
+        }
+        catch(exception)
+        {
+            return JS_EXCEPTION;
+        }
+        catch (std::exception const & err)
+        {
+            JS_ThrowInternalError(ctx, "%s", err.what());
+            return JS_EXCEPTION;
+        }
+        catch (...)
+        {
+            JS_ThrowInternalError(ctx, "Unknown error");
+            return JS_EXCEPTION;
+        }
+    }
+
+    static std::vector<T> unwrap(JSContext * ctx, JSValueConst jsarr)
+    {
+        int e = JS_IsArray(ctx, jsarr);
+        if(e == 0)
+            JS_ThrowTypeError(ctx, "js_traits<std::vector<T>>::unwrap expects array");
+        if(e <= 0)
+            throw exception{ctx};
+        Value jsarray{ctx, JS_DupValue(ctx, jsarr)};
+        std::vector<T> arr;
+        auto len = static_cast<int32_t>(jsarray["length"]);
+        arr.reserve((uint32_t) len);
+        for(uint32_t i = 0; i < (uint32_t) len; i++)
+            arr.push_back(static_cast<T>(jsarray[i]));
+        return arr;
+    }
+};
+
+
+template <typename U, typename V>
+struct js_traits<std::pair<U, V>>
+{
+    static JSValue wrap(JSContext * ctx, std::pair<U, V> obj) noexcept
+    {
+        try
+        {
+            auto jsarray = Value{ctx, JS_NewArray(ctx)};
+            jsarray[uint32_t(0)] = std::move(obj.first);
+            jsarray[uint32_t(1)] = std::move(obj.second);
+            return jsarray.release();
+        }
+        catch(exception)
+        {
+            return JS_EXCEPTION;
+        }
+        catch (std::exception const & err)
+        {
+            JS_ThrowInternalError(ctx, "%s", err.what());
+            return JS_EXCEPTION;
+        }
+        catch (...)
+        {
+            JS_ThrowInternalError(ctx, "Unknown error");
+            return JS_EXCEPTION;
+        }
+    }
+
+    static std::pair<U, V> unwrap(JSContext * ctx, JSValueConst jsarr)
+    {
+        int e = JS_IsArray(ctx, jsarr);
+        if(e == 0)
+            JS_ThrowTypeError(ctx, "js_traits<%s>::unwrap expects array", QJSPP_TYPENAME(std::pair<U, V>));
+        if(e <= 0)
+            throw exception{ctx};
+        Value jsarray{ctx, JS_DupValue(ctx, jsarr)};
+        const auto len = static_cast<uint32_t>(jsarray["length"]);
+        if(len != 2)
+        {
+            JS_ThrowTypeError(ctx, "js_traits<%s>::unwrap expected array of length 2, got length %d",
+                              QJSPP_TYPENAME(std::pair<U, V>), len);
+            throw exception{ctx};
+        }
+        return std::pair<U, V>{
+                static_cast<U>(jsarray[uint32_t(0)]),
+                static_cast<V>(jsarray[uint32_t(1)])
+        };
+    }
+};
+
+/** Conversions for std::optional.
+ * Unlike other types does not throw on unwrap but returns nullopt.
+ * Converts std::nullopt to null.
+ */
+template <typename T>
+struct js_traits<std::optional<T>>
+{
+    /** Wraps T or null. */
+    static JSValue wrap(JSContext * ctx, std::optional<T> obj) noexcept
+    {
+        if(obj)
+            return js_traits<std::decay_t<T>>::wrap(ctx, *obj);
+        return JS_NULL;
+    }
+
+    /** If conversion to T fails returns std::nullopt. */
+    static auto unwrap(JSContext * ctx, JSValueConst v) noexcept -> std::optional<decltype(js_traits<std::decay_t<T>>::unwrap(ctx, v))>
+    {
+        try
+        {
+            if(JS_IsNull(v))
+                return std::nullopt;
+            return js_traits<std::decay_t<T>>::unwrap(ctx, v);
+        }
+        catch(exception)
+        {
+            // ignore and clear exception
+            JS_FreeValue(ctx, JS_GetException(ctx));
+        }
+        return std::nullopt;
+    }
+};
+
+
+namespace detail {
+template <typename Key>
+property_proxy<Key>::operator Value() const
+{
+    return as<Value>();
+}
+}
+
+template <typename Function>
+void Context::enqueueJob(Function && job) {
+    JSValue job_val = js_traits<std::function<void()>>::wrap(ctx, std::forward<Function>(job));
+    JSValueConst arg = job_val;
+    int err = JS_EnqueueJob(ctx, [](JSContext *ctx, int argc, JSValueConst *argv){
+        try
+        {
+            assert(argc >= 1);
+            js_traits<std::function<void()>>::unwrap(ctx, argv[0])();
+        }
+        catch (exception)
+        {
+            return JS_EXCEPTION;
+        }
+        catch (std::exception const & err)
+        {
+            JS_ThrowInternalError(ctx, "%s", err.what());
+            return JS_EXCEPTION;
+        }
+        catch (...)
+        {
+            JS_ThrowInternalError(ctx, "Unknown error");
+            return JS_EXCEPTION;
+        }
+        return JS_UNDEFINED;
+    }, 1, &arg);
+    JS_FreeValue(ctx, job_val);
+    if(err < 0)
+        throw exception{ctx};
+}
+
+inline Context & exception::context() const {
+    return Context::get(ctx);
+}
+
+inline Value exception::get() {
+    return context().getException();
+}
+
+inline void Runtime::promise_unhandled_rejection_tracker(JSContext *ctx, JSValueConst promise,
+                                                         JSValueConst reason, JS_BOOL is_handled, void *opaque)
+{
+    auto & context = Context::get(ctx);
+    if (context.onUnhandledPromiseRejection) {
+        context.onUnhandledPromiseRejection(context.newValue(JS_DupValue(ctx, reason)));
+    }
+}
+
+inline JSModuleDef * Runtime::module_loader(JSContext *ctx,
+                                            const char *module_name, void *opaque)
+{
+    Context::ModuleData data;
+    auto & context = Context::get(ctx);
+
+    try {
+        if (context.moduleLoader) data = context.moduleLoader(module_name);
+
+        if (!data.source) {
+            JS_ThrowReferenceError(ctx, "could not load module filename '%s'", module_name);
+            return NULL;
+        }
+
+        if (!data.url) data.url = module_name;
+
+        // compile the module
+        auto func_val = context.eval(*data.source, module_name, JS_EVAL_TYPE_MODULE | JS_EVAL_FLAG_COMPILE_ONLY);
+        assert(JS_VALUE_GET_TAG(func_val.v) == JS_TAG_MODULE);
+        JSModuleDef * m = reinterpret_cast<JSModuleDef *>(JS_VALUE_GET_PTR(func_val.v));
+
+        // set import.meta
+        auto meta = context.newValue(JS_GetImportMeta(ctx, m));
+        meta["url"] = *data.url;
+        meta["main"] = false;
+
+        return m;
+    }
+    catch(exception)
+    {
+        return NULL;
+    }
+    catch (std::exception const & err)
+    {
+        JS_ThrowInternalError(ctx, "%s", err.what());
+        return NULL;
+    }
+    catch (...)
+    {
+        JS_ThrowInternalError(ctx, "Unknown error");
+        return NULL;
+    }
+}
+
+
+inline Context * Runtime::executePendingJob() {
+    JSContext * ctx;
+    auto err = JS_ExecutePendingJob(rt, &ctx);
+    if (err == 0) {
+        // There was no job to run
+        return nullptr;
+    } else if (err < 0) {
+        throw exception{ctx};
+    }
+    return &Context::get(ctx);
+}
+
+} // namespace qjs
Index: quickjs-src/quickjs/include/quickjs/quickjs-defs.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/include/quickjs/quickjs-defs.h b/quickjs-src/quickjs/include/quickjs/quickjs-defs.h
new file mode 100644
--- /dev/null	(date 1714440647078)
+++ b/quickjs-src/quickjs/include/quickjs/quickjs-defs.h	(date 1714440647078)
@@ -0,0 +1,116 @@
+#pragma once
+
+#include <stdint.h>
+
+//////////////////////////////////////////////////////////////////////////
+#if defined(_DEBUG) || defined(FORCE_DEBUG)
+#  define PLATFORM_IS_DEBUG 1
+#else
+#  define PLATFORM_IS_NDEBUG 1
+#endif
+
+#if defined(_WIN32)
+#  include <intrin.h>
+#  define PLATFORM_IS_WINDOWS 1
+#  if defined(_WIN64)
+#    define PLATFORM_IS_WIN64 1
+#  endif
+#endif
+
+#if defined(__ANDROID__)
+#  define PLATFORM_IS_ANDROID 1
+#endif
+
+#if defined(__APPLE__)
+#  define PLATFORM_IS_APPLE 1
+#  include <TargetConditionals.h>
+#  if TARGET_IPHONE_SIMULATOR
+#    define PLATFORM_IS_IPHONE 1
+#    define PLATFORM_IS_IPHONE_SIMULATOR 1
+#  elif TARGET_OS_IPHONE
+#    define PLATFORM_IS_IPHONE 1
+#  elif TARGET_OS_MAC
+#    define PLATFORM_IS_MAC 1
+#  endif
+#endif
+
+#if defined(__linux__)
+#  define PLATFORM_IS_LINUX 1
+#endif
+
+#if defined(__FreeBSD__)
+#  define PLATFORM_IS_FREEBSD 1
+#endif
+
+#if defined(__unix__)
+#  define PLATFORM_IS_UNIX 1
+#endif
+
+#if defined(__x86_64__) || defined(_M_X64)
+#  define PLATFORM_ARCH_X86 1
+#  define PLATFORM_IS_X64 1
+#elif defined(__i386__) || defined(_M_IX86)
+#  define PLATFORM_ARCH_X86 1
+#  define PLATFORM_IS_X86 1
+#endif
+
+#if defined(__aarch64__)
+#  define PLATFORM_ARCH_ARM 1
+#  define PLATFORM_IS_ARM64 1
+#elif defined(__arm__) || defined(_M_ARM)
+#  define PLATFORM_ARCH_ARM 1
+#  define PLATFORM_IS_ARM32 1
+#endif
+
+//////////////////////////////////////////////////////////////////////////
+#if UINTPTR_MAX == UINT32_MAX
+#  define PLATFORM_IS_32BIT 1
+#else
+#  define PLATFORM_IS_64BIT 1
+#endif
+
+//////////////////////////////////////////////////////////////////////////
+#if defined(__clang__) || defined(__GNUC__)
+#  define PLATFORM_GNUC_LIKE 1
+#  if defined(PLATFORM_ARCH_X86)
+#    include <x86intrin.h>
+#  elif defined(PLATFORM_ARCH_ARM)
+#    include <arm_acle.h>
+#    if defined(__ARM_NEON__)
+#      include <arm_neon.h>
+#    endif
+#  endif
+#elif defined(_MSC_VER)
+#  define PLATFORM_MSVC_LIKE 1
+#else
+#  error Cannot detect compiler environment!
+#endif
+
+//////////////////////////////////////////////////////////////////////////
+#if defined(PLATFORM_GNUC_LIKE)
+#  define PLATFORM_LIKELY(x)			__builtin_expect(!!(x), 1)
+#  define PLATFORM_UNLIKELY(x)			__builtin_expect(!!(x), 0)
+#  define PLATFORM_FORCE_INLINE			inline __attribute__((always_inline))
+#  define PLATFORM_NO_INLINE			__attribute__((noinline))
+#  define PLATFORM_MAYBE_UNUSED			__attribute__((unused))
+#  define PLATFORM_WARN_UNUSED			__attribute__((warn_unused_result))
+#  define PLATFORM_PRINTF_LIKE(f, a)	__attribute__((format(printf, f, a)))
+#else
+#  define PLATFORM_LIKELY(x)			x
+#  define PLATFORM_UNLIKELY(x)			x
+#  define PLATFORM_FORCE_INLINE			__forceinline
+#  define PLATFORM_NO_INLINE			__declspec(noinline)
+#  define PLATFORM_MAYBE_UNUSED
+#  define PLATFORM_WARN_UNUSED
+#  define PLATFORM_PRINTF_LIKE(f, a)
+#endif
+
+//////////////////////////////////////////////////////////////////////////
+#if defined(PLATFORM_IS_WINDOWS)
+
+typedef intptr_t ssize_t;
+
+
+#endif
+
+//////////////////////////////////////////////////////////////////////////
Index: quickjs-src/quickjs/libunicode.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/libunicode.h b/quickjs-src/quickjs/src/libunicode.h
rename from quickjs-src/quickjs/libunicode.h
rename to quickjs-src/quickjs/src/libunicode.h
--- a/quickjs-src/quickjs/libunicode.h	(revision 3b45d155c77bbdfe9177b1e03db830d2aff0b2a8)
+++ b/quickjs-src/quickjs/src/libunicode.h	(date 1714440647082)
@@ -41,7 +41,6 @@
 } UnicodeNormalizationEnum;
 
 int lre_case_conv(uint32_t *res, uint32_t c, int conv_type);
-int lre_canonicalize(uint32_t c, LRE_BOOL is_unicode);
 LRE_BOOL lre_is_cased(uint32_t c);
 LRE_BOOL lre_is_case_ignorable(uint32_t c);
 
@@ -102,8 +101,6 @@
 
 int cr_invert(CharRange *cr);
 
-int cr_regexp_canonicalize(CharRange *cr, LRE_BOOL is_unicode);
-
 #ifdef CONFIG_ALL_UNICODE
 
 LRE_BOOL lre_is_id_start(uint32_t c);
Index: quickjs-src/quickjs/quickjs-libc.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/quickjs-libc.c b/quickjs-src/quickjs/src/quickjs-libc.c
rename from quickjs-src/quickjs/quickjs-libc.c
rename to quickjs-src/quickjs/src/quickjs-libc.c
--- a/quickjs-src/quickjs/quickjs-libc.c	(revision 3b45d155c77bbdfe9177b1e03db830d2aff0b2a8)
+++ b/quickjs-src/quickjs/src/quickjs-libc.c	(date 1714440647082)
@@ -28,50 +28,29 @@
 #include <inttypes.h>
 #include <string.h>
 #include <assert.h>
-#include <unistd.h>
 #include <errno.h>
 #include <fcntl.h>
-#include <sys/time.h>
 #include <time.h>
 #include <signal.h>
 #include <limits.h>
 #include <sys/stat.h>
-#include <dirent.h>
 #if defined(_WIN32)
 #include <windows.h>
 #include <conio.h>
-#include <utime.h>
+#ifndef PATH_MAX
+#define PATH_MAX MAX_PATH
+#endif
 #else
+#include <unistd.h>
+#include <dirent.h>
 #include <dlfcn.h>
 #include <termios.h>
 #include <sys/ioctl.h>
+#include <sys/time.h>
 #include <sys/wait.h>
-
-#if defined(__FreeBSD__)
-extern char **environ;
-#endif
-
-#if defined(__APPLE__) || defined(__FreeBSD__)
+#if defined(__APPLE__)
 typedef sig_t sighandler_t;
 #endif
-
-#if defined(__APPLE__)
-#if !defined(environ)
-#include <crt_externs.h>
-#define environ (*_NSGetEnviron())
-#endif
-#endif /* __APPLE__ */
-
-#endif
-
-#if !defined(_WIN32)
-/* enable the os.Worker API. IT relies on POSIX threads */
-#define USE_WORKER
-#endif
-
-#ifdef USE_WORKER
-#include <pthread.h>
-#include <stdatomic.h>
 #endif
 
 #include "cutils.h"
@@ -96,7 +75,7 @@
 
 typedef struct {
     struct list_head link;
-    int timer_id;
+    BOOL has_object;
     int64_t timeout;
     JSValue func;
 } JSOSTimer;
@@ -132,7 +111,6 @@
     struct list_head os_timers; /* list of JSOSTimer.link */
     struct list_head port_list; /* list of JSWorkerMessageHandler.link */
     int eval_script_recurse; /* only used in the main thread */
-    int next_timer_id; /* for setTimeout() */
     /* not used in the main thread */
     JSWorkerMessagePipe *recv_pipe, *send_pipe;
 } JSThreadState;
@@ -157,7 +135,7 @@
     uint8_t cbuf[UTF8_CHAR_LEN_MAX+1];
     JSValue res;
     DynBuf dbuf;
-    const char *fmt_str = NULL;
+    const char *fmt_str;
     const uint8_t *fmt, *fmt_end;
     const uint8_t *p;
     char *q;
@@ -258,7 +236,7 @@
                     string_arg = JS_ToCString(ctx, argv[i++]);
                     if (!string_arg)
                         goto fail;
-                    int32_arg = unicode_from_utf8((const uint8_t *)string_arg, UTF8_CHAR_LEN_MAX, &p);
+                    int32_arg = unicode_from_utf8((uint8_t *)string_arg, UTF8_CHAR_LEN_MAX, &p);
                     JS_FreeCString(ctx, string_arg);
                 } else {
                     if (JS_ToInt32(ctx, &int32_arg, argv[i++]))
@@ -362,7 +340,6 @@
     return res;
 
 fail:
-    JS_FreeCString(ctx, fmt_str);
     dbuf_free(&dbuf);
     return JS_EXCEPTION;
 }
@@ -461,65 +438,6 @@
 typedef JSModuleDef *(JSInitModuleFunc)(JSContext *ctx,
                                         const char *module_name);
 
-
-#if defined(_WIN32)
-static JSModuleDef *js_module_loader_so(JSContext *ctx,
-                                        const char *module_name)
-{
-    JS_ThrowReferenceError(ctx, "shared library modules are not supported yet");
-    return NULL;
-}
-#else
-static JSModuleDef *js_module_loader_so(JSContext *ctx,
-                                        const char *module_name)
-{
-    JSModuleDef *m;
-    void *hd;
-    JSInitModuleFunc *init;
-    char *filename;
-
-    if (!strchr(module_name, '/')) {
-        /* must add a '/' so that the DLL is not searched in the
-           system library paths */
-        filename = js_malloc(ctx, strlen(module_name) + 2 + 1);
-        if (!filename)
-            return NULL;
-        strcpy(filename, "./");
-        strcpy(filename + 2, module_name);
-    } else {
-        filename = (char *)module_name;
-    }
-
-    /* C module */
-    hd = dlopen(filename, RTLD_NOW | RTLD_LOCAL);
-    if (filename != module_name)
-        js_free(ctx, filename);
-    if (!hd) {
-        JS_ThrowReferenceError(ctx, "could not load module filename '%s' as shared library",
-                               module_name);
-        goto fail;
-    }
-
-    init = dlsym(hd, "js_init_module");
-    if (!init) {
-        JS_ThrowReferenceError(ctx, "could not load module filename '%s': js_init_module not found",
-                               module_name);
-        goto fail;
-    }
-
-    m = init(ctx, module_name);
-    if (!m) {
-        JS_ThrowReferenceError(ctx, "could not load module filename '%s': initialization error",
-                               module_name);
-    fail:
-        if (hd)
-            dlclose(hd);
-        return NULL;
-    }
-    return m;
-}
-#endif /* !_WIN32 */
-
 int js_module_set_import_meta(JSContext *ctx, JSValueConst func_val,
                               JS_BOOL use_realpath, JS_BOOL is_main)
 {
@@ -573,40 +491,6 @@
     return 0;
 }
 
-JSModuleDef *js_module_loader(JSContext *ctx,
-                              const char *module_name, void *opaque)
-{
-    JSModuleDef *m;
-
-    if (has_suffix(module_name, ".so")) {
-        m = js_module_loader_so(ctx, module_name);
-    } else {
-        size_t buf_len;
-        uint8_t *buf;
-        JSValue func_val;
-
-        buf = js_load_file(ctx, &buf_len, module_name);
-        if (!buf) {
-            JS_ThrowReferenceError(ctx, "could not load module filename '%s'",
-                                   module_name);
-            return NULL;
-        }
-
-        /* compile the module */
-        func_val = JS_Eval(ctx, (char *)buf, buf_len, module_name,
-                           JS_EVAL_TYPE_MODULE | JS_EVAL_FLAG_COMPILE_ONLY);
-        js_free(ctx, buf);
-        if (JS_IsException(func_val))
-            return NULL;
-        /* XXX: could propagate the exception */
-        js_module_set_import_meta(ctx, func_val, TRUE, FALSE);
-        /* the module is already referenced, so we must free it */
-        m = JS_VALUE_GET_PTR(func_val);
-        JS_FreeValue(ctx, func_val);
-    }
-    return m;
-}
-
 static JSValue js_std_exit(JSContext *ctx, JSValueConst this_val,
                            int argc, JSValueConst *argv)
 {
@@ -684,45 +568,6 @@
     return JS_UNDEFINED;
 }
 
-/* return an object containing the list of the available environment
-   variables. */
-static JSValue js_std_getenviron(JSContext *ctx, JSValueConst this_val,
-                                 int argc, JSValueConst *argv)
-{
-    char **envp;
-    const char *name, *p, *value;
-    JSValue obj;
-    uint32_t idx;
-    size_t name_len;
-    JSAtom atom;
-    int ret;
-
-    obj = JS_NewObject(ctx);
-    if (JS_IsException(obj))
-        return JS_EXCEPTION;
-    envp = environ;
-    for(idx = 0; envp[idx] != NULL; idx++) {
-        name = envp[idx];
-        p = strchr(name, '=');
-        name_len = p - name;
-        if (!p)
-            continue;
-        value = p + 1;
-        atom = JS_NewAtomLen(ctx, name, name_len);
-        if (atom == JS_ATOM_NULL)
-            goto fail;
-        ret = JS_DefinePropertyValue(ctx, obj, atom, JS_NewString(ctx, value),
-                                     JS_PROP_C_W_E);
-        JS_FreeAtom(ctx, atom);
-        if (ret < 0)
-            goto fail;
-    }
-    return obj;
- fail:
-    JS_FreeValue(ctx, obj);
-    return JS_EXCEPTION;
-}
-
 static JSValue js_std_gc(JSContext *ctx, JSValueConst this_val,
                          int argc, JSValueConst *argv)
 {
@@ -760,7 +605,6 @@
     JSValue ret;
     JSValueConst options_obj;
     BOOL backtrace_barrier = FALSE;
-    BOOL is_async = FALSE;
     int flags;
 
     if (argc >= 2) {
@@ -768,9 +612,6 @@
         if (get_bool_option(ctx, &backtrace_barrier, options_obj,
                             "backtrace_barrier"))
             return JS_EXCEPTION;
-        if (get_bool_option(ctx, &is_async, options_obj,
-                            "async"))
-            return JS_EXCEPTION;
     }
 
     str = JS_ToCStringLen(ctx, &len, argv[0]);
@@ -783,8 +624,6 @@
     flags = JS_EVAL_TYPE_GLOBAL;
     if (backtrace_barrier)
         flags |= JS_EVAL_FLAG_BACKTRACE_BARRIER;
-    if (is_async)
-        flags |= JS_EVAL_FLAG_ASYNC;
     ret = JS_Eval(ctx, str, len, "<evalScript>", flags);
     JS_FreeCString(ctx, str);
     if (!ts->recv_pipe && --ts->eval_script_recurse == 0) {
@@ -799,28 +638,6 @@
     return ret;
 }
 
-static JSClassID js_std_file_class_id;
-
-typedef struct {
-    FILE *f;
-    BOOL close_in_finalizer;
-    BOOL is_popen;
-} JSSTDFile;
-
-static void js_std_file_finalizer(JSRuntime *rt, JSValue val)
-{
-    JSSTDFile *s = JS_GetOpaque(val, js_std_file_class_id);
-    if (s) {
-        if (s->f && s->close_in_finalizer) {
-            if (s->is_popen)
-                pclose(s->f);
-            else
-                fclose(s->f);
-        }
-        js_free_rt(rt, s);
-    }
-}
-
 static ssize_t js_get_errno(ssize_t ret)
 {
     if (ret == -1)
@@ -851,27 +668,6 @@
     JS_FreeCString(ctx, str);
     return obj;
 }
-
-static JSValue js_new_std_file(JSContext *ctx, FILE *f,
-                               BOOL close_in_finalizer,
-                               BOOL is_popen)
-{
-    JSSTDFile *s;
-    JSValue obj;
-    obj = JS_NewObjectClass(ctx, js_std_file_class_id);
-    if (JS_IsException(obj))
-        return obj;
-    s = js_mallocz(ctx, sizeof(*s));
-    if (!s) {
-        JS_FreeValue(ctx, obj);
-        return JS_EXCEPTION;
-    }
-    s->close_in_finalizer = close_in_finalizer;
-    s->is_popen = is_popen;
-    s->f = f;
-    JS_SetOpaque(obj, s);
-    return obj;
-}
 
 static void js_set_error_object(JSContext *ctx, JSValue obj, int err)
 {
@@ -880,123 +676,6 @@
     }
 }
 
-static JSValue js_std_open(JSContext *ctx, JSValueConst this_val,
-                           int argc, JSValueConst *argv)
-{
-    const char *filename, *mode = NULL;
-    FILE *f;
-    int err;
-
-    filename = JS_ToCString(ctx, argv[0]);
-    if (!filename)
-        goto fail;
-    mode = JS_ToCString(ctx, argv[1]);
-    if (!mode)
-        goto fail;
-    if (mode[strspn(mode, "rwa+b")] != '\0') {
-        JS_ThrowTypeError(ctx, "invalid file mode");
-        goto fail;
-    }
-
-    f = fopen(filename, mode);
-    if (!f)
-        err = errno;
-    else
-        err = 0;
-    if (argc >= 3)
-        js_set_error_object(ctx, argv[2], err);
-    JS_FreeCString(ctx, filename);
-    JS_FreeCString(ctx, mode);
-    if (!f)
-        return JS_NULL;
-    return js_new_std_file(ctx, f, TRUE, FALSE);
- fail:
-    JS_FreeCString(ctx, filename);
-    JS_FreeCString(ctx, mode);
-    return JS_EXCEPTION;
-}
-
-static JSValue js_std_popen(JSContext *ctx, JSValueConst this_val,
-                            int argc, JSValueConst *argv)
-{
-    const char *filename, *mode = NULL;
-    FILE *f;
-    int err;
-
-    filename = JS_ToCString(ctx, argv[0]);
-    if (!filename)
-        goto fail;
-    mode = JS_ToCString(ctx, argv[1]);
-    if (!mode)
-        goto fail;
-    if (mode[strspn(mode, "rw")] != '\0') {
-        JS_ThrowTypeError(ctx, "invalid file mode");
-        goto fail;
-    }
-
-    f = popen(filename, mode);
-    if (!f)
-        err = errno;
-    else
-        err = 0;
-    if (argc >= 3)
-        js_set_error_object(ctx, argv[2], err);
-    JS_FreeCString(ctx, filename);
-    JS_FreeCString(ctx, mode);
-    if (!f)
-        return JS_NULL;
-    return js_new_std_file(ctx, f, TRUE, TRUE);
- fail:
-    JS_FreeCString(ctx, filename);
-    JS_FreeCString(ctx, mode);
-    return JS_EXCEPTION;
-}
-
-static JSValue js_std_fdopen(JSContext *ctx, JSValueConst this_val,
-                             int argc, JSValueConst *argv)
-{
-    const char *mode;
-    FILE *f;
-    int fd, err;
-
-    if (JS_ToInt32(ctx, &fd, argv[0]))
-        return JS_EXCEPTION;
-    mode = JS_ToCString(ctx, argv[1]);
-    if (!mode)
-        goto fail;
-    if (mode[strspn(mode, "rwa+")] != '\0') {
-        JS_ThrowTypeError(ctx, "invalid file mode");
-        goto fail;
-    }
-
-    f = fdopen(fd, mode);
-    if (!f)
-        err = errno;
-    else
-        err = 0;
-    if (argc >= 3)
-        js_set_error_object(ctx, argv[2], err);
-    JS_FreeCString(ctx, mode);
-    if (!f)
-        return JS_NULL;
-    return js_new_std_file(ctx, f, TRUE, FALSE);
- fail:
-    JS_FreeCString(ctx, mode);
-    return JS_EXCEPTION;
-}
-
-static JSValue js_std_tmpfile(JSContext *ctx, JSValueConst this_val,
-                              int argc, JSValueConst *argv)
-{
-    FILE *f;
-    f = tmpfile();
-    if (argc >= 1)
-        js_set_error_object(ctx, argv[0], f ? 0 : errno);
-    if (!f)
-        return JS_NULL;
-    return js_new_std_file(ctx, f, TRUE, FALSE);
-}
-
 static JSValue js_std_sprintf(JSContext *ctx, JSValueConst this_val,
                           int argc, JSValueConst *argv)
 {
@@ -1009,287 +688,9 @@
     return js_printf_internal(ctx, argc, argv, stdout);
 }
 
-static FILE *js_std_file_get(JSContext *ctx, JSValueConst obj)
-{
-    JSSTDFile *s = JS_GetOpaque2(ctx, obj, js_std_file_class_id);
-    if (!s)
-        return NULL;
-    if (!s->f) {
-        JS_ThrowTypeError(ctx, "invalid file handle");
-        return NULL;
-    }
-    return s->f;
-}
-
-static JSValue js_std_file_puts(JSContext *ctx, JSValueConst this_val,
-                                int argc, JSValueConst *argv, int magic)
-{
-    FILE *f;
-    int i;
-    const char *str;
-    size_t len;
-
-    if (magic == 0) {
-        f = stdout;
-    } else {
-        f = js_std_file_get(ctx, this_val);
-        if (!f)
-            return JS_EXCEPTION;
-    }
-
-    for(i = 0; i < argc; i++) {
-        str = JS_ToCStringLen(ctx, &len, argv[i]);
-        if (!str)
-            return JS_EXCEPTION;
-        fwrite(str, 1, len, f);
-        JS_FreeCString(ctx, str);
-    }
-    return JS_UNDEFINED;
-}
-
-static JSValue js_std_file_close(JSContext *ctx, JSValueConst this_val,
-                                 int argc, JSValueConst *argv)
-{
-    JSSTDFile *s = JS_GetOpaque2(ctx, this_val, js_std_file_class_id);
-    int err;
-    if (!s)
-        return JS_EXCEPTION;
-    if (!s->f)
-        return JS_ThrowTypeError(ctx, "invalid file handle");
-    if (s->is_popen)
-        err = js_get_errno(pclose(s->f));
-    else
-        err = js_get_errno(fclose(s->f));
-    s->f = NULL;
-    return JS_NewInt32(ctx, err);
-}
-
-static JSValue js_std_file_printf(JSContext *ctx, JSValueConst this_val,
-                                  int argc, JSValueConst *argv)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    if (!f)
-        return JS_EXCEPTION;
-    return js_printf_internal(ctx, argc, argv, f);
-}
-
-static JSValue js_std_file_flush(JSContext *ctx, JSValueConst this_val,
-                                 int argc, JSValueConst *argv)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    if (!f)
-        return JS_EXCEPTION;
-    fflush(f);
-    return JS_UNDEFINED;
-}
-
-static JSValue js_std_file_tell(JSContext *ctx, JSValueConst this_val,
-                                int argc, JSValueConst *argv, int is_bigint)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    int64_t pos;
-    if (!f)
-        return JS_EXCEPTION;
-#if defined(__linux__)
-    pos = ftello(f);
-#else
-    pos = ftell(f);
-#endif
-    if (is_bigint)
-        return JS_NewBigInt64(ctx, pos);
-    else
-        return JS_NewInt64(ctx, pos);
-}
-
-static JSValue js_std_file_seek(JSContext *ctx, JSValueConst this_val,
-                                int argc, JSValueConst *argv)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    int64_t pos;
-    int whence, ret;
-    if (!f)
-        return JS_EXCEPTION;
-    if (JS_ToInt64Ext(ctx, &pos, argv[0]))
-        return JS_EXCEPTION;
-    if (JS_ToInt32(ctx, &whence, argv[1]))
-        return JS_EXCEPTION;
-#if defined(__linux__)
-    ret = fseeko(f, pos, whence);
-#else
-    ret = fseek(f, pos, whence);
-#endif
-    if (ret < 0)
-        ret = -errno;
-    return JS_NewInt32(ctx, ret);
-}
-
-static JSValue js_std_file_eof(JSContext *ctx, JSValueConst this_val,
-                               int argc, JSValueConst *argv)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    if (!f)
-        return JS_EXCEPTION;
-    return JS_NewBool(ctx, feof(f));
-}
-
-static JSValue js_std_file_error(JSContext *ctx, JSValueConst this_val,
-                               int argc, JSValueConst *argv)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    if (!f)
-        return JS_EXCEPTION;
-    return JS_NewBool(ctx, ferror(f));
-}
-
-static JSValue js_std_file_clearerr(JSContext *ctx, JSValueConst this_val,
-                                    int argc, JSValueConst *argv)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    if (!f)
-        return JS_EXCEPTION;
-    clearerr(f);
-    return JS_UNDEFINED;
-}
-
-static JSValue js_std_file_fileno(JSContext *ctx, JSValueConst this_val,
-                                  int argc, JSValueConst *argv)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    if (!f)
-        return JS_EXCEPTION;
-    return JS_NewInt32(ctx, fileno(f));
-}
-
-static JSValue js_std_file_read_write(JSContext *ctx, JSValueConst this_val,
-                                      int argc, JSValueConst *argv, int magic)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    uint64_t pos, len;
-    size_t size, ret;
-    uint8_t *buf;
-
-    if (!f)
-        return JS_EXCEPTION;
-    if (JS_ToIndex(ctx, &pos, argv[1]))
-        return JS_EXCEPTION;
-    if (JS_ToIndex(ctx, &len, argv[2]))
-        return JS_EXCEPTION;
-    buf = JS_GetArrayBuffer(ctx, &size, argv[0]);
-    if (!buf)
-        return JS_EXCEPTION;
-    if (pos + len > size)
-        return JS_ThrowRangeError(ctx, "read/write array buffer overflow");
-    if (magic)
-        ret = fwrite(buf + pos, 1, len, f);
-    else
-        ret = fread(buf + pos, 1, len, f);
-    return JS_NewInt64(ctx, ret);
-}
-
-/* XXX: could use less memory and go faster */
-static JSValue js_std_file_getline(JSContext *ctx, JSValueConst this_val,
-                                   int argc, JSValueConst *argv)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    int c;
-    DynBuf dbuf;
-    JSValue obj;
-
-    if (!f)
-        return JS_EXCEPTION;
-
-    js_std_dbuf_init(ctx, &dbuf);
-    for(;;) {
-        c = fgetc(f);
-        if (c == EOF) {
-            if (dbuf.size == 0) {
-                /* EOF */
-                dbuf_free(&dbuf);
-                return JS_NULL;
-            } else {
-                break;
-            }
-        }
-        if (c == '\n')
-            break;
-        if (dbuf_putc(&dbuf, c)) {
-            dbuf_free(&dbuf);
-            return JS_ThrowOutOfMemory(ctx);
-        }
-    }
-    obj = JS_NewStringLen(ctx, (const char *)dbuf.buf, dbuf.size);
-    dbuf_free(&dbuf);
-    return obj;
-}
-
-/* XXX: could use less memory and go faster */
-static JSValue js_std_file_readAsString(JSContext *ctx, JSValueConst this_val,
-                                        int argc, JSValueConst *argv)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    int c;
-    DynBuf dbuf;
-    JSValue obj;
-    uint64_t max_size64;
-    size_t max_size;
-    JSValueConst max_size_val;
-
-    if (!f)
-        return JS_EXCEPTION;
-
-    if (argc >= 1)
-        max_size_val = argv[0];
-    else
-        max_size_val = JS_UNDEFINED;
-    max_size = (size_t)-1;
-    if (!JS_IsUndefined(max_size_val)) {
-        if (JS_ToIndex(ctx, &max_size64, max_size_val))
-            return JS_EXCEPTION;
-        if (max_size64 < max_size)
-            max_size = max_size64;
-    }
-
-    js_std_dbuf_init(ctx, &dbuf);
-    while (max_size != 0) {
-        c = fgetc(f);
-        if (c == EOF)
-            break;
-        if (dbuf_putc(&dbuf, c)) {
-            dbuf_free(&dbuf);
-            return JS_EXCEPTION;
-        }
-        max_size--;
-    }
-    obj = JS_NewStringLen(ctx, (const char *)dbuf.buf, dbuf.size);
-    dbuf_free(&dbuf);
-    return obj;
-}
-
-static JSValue js_std_file_getByte(JSContext *ctx, JSValueConst this_val,
-                                   int argc, JSValueConst *argv)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    if (!f)
-        return JS_EXCEPTION;
-    return JS_NewInt32(ctx, fgetc(f));
-}
-
-static JSValue js_std_file_putByte(JSContext *ctx, JSValueConst this_val,
-                                   int argc, JSValueConst *argv)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    int c;
-    if (!f)
-        return JS_EXCEPTION;
-    if (JS_ToInt32(ctx, &c, argv[0]))
-        return JS_EXCEPTION;
-    c = fputc(c, f);
-    return JS_NewInt32(ctx, c);
-}
-
 /* urlGet */
 
-#define URL_GET_PROGRAM "curl -s -i --"
+#define URL_GET_PROGRAM "curl -s -i"
 #define URL_GET_BUF_SIZE 4096
 
 static int http_get_header_line(FILE *f, char *buf, size_t buf_size,
@@ -1326,167 +727,6 @@
     return atoi(p);
 }
 
-static JSValue js_std_urlGet(JSContext *ctx, JSValueConst this_val,
-                             int argc, JSValueConst *argv)
-{
-    const char *url;
-    DynBuf cmd_buf;
-    DynBuf data_buf_s, *data_buf = &data_buf_s;
-    DynBuf header_buf_s, *header_buf = &header_buf_s;
-    char *buf;
-    size_t i, len;
-    int status;
-    JSValue response = JS_UNDEFINED, ret_obj;
-    JSValueConst options_obj;
-    FILE *f;
-    BOOL binary_flag, full_flag;
-
-    url = JS_ToCString(ctx, argv[0]);
-    if (!url)
-        return JS_EXCEPTION;
-
-    binary_flag = FALSE;
-    full_flag = FALSE;
-
-    if (argc >= 2) {
-        options_obj = argv[1];
-
-        if (get_bool_option(ctx, &binary_flag, options_obj, "binary"))
-            goto fail_obj;
-
-        if (get_bool_option(ctx, &full_flag, options_obj, "full")) {
-        fail_obj:
-            JS_FreeCString(ctx, url);
-            return JS_EXCEPTION;
-        }
-    }
-
-    js_std_dbuf_init(ctx, &cmd_buf);
-    dbuf_printf(&cmd_buf, "%s '", URL_GET_PROGRAM);
-    for(i = 0; url[i] != '\0'; i++) {
-        unsigned char c = url[i];
-        switch (c) {
-        case '\'':
-            /* shell single quoted string does not support \' */
-            dbuf_putstr(&cmd_buf, "'\\''");
-            break;
-        case '[': case ']': case '{': case '}': case '\\':
-            /* prevent interpretation by curl as range or set specification */
-            dbuf_putc(&cmd_buf, '\\');
-            /* FALLTHROUGH */
-        default:
-            dbuf_putc(&cmd_buf, c);
-            break;
-        }
-    }
-    JS_FreeCString(ctx, url);
-    dbuf_putstr(&cmd_buf, "'");
-    dbuf_putc(&cmd_buf, '\0');
-    if (dbuf_error(&cmd_buf)) {
-        dbuf_free(&cmd_buf);
-        return JS_EXCEPTION;
-    }
-    //    printf("%s\n", (char *)cmd_buf.buf);
-    f = popen((char *)cmd_buf.buf, "r");
-    dbuf_free(&cmd_buf);
-    if (!f) {
-        return JS_ThrowTypeError(ctx, "could not start curl");
-    }
-
-    js_std_dbuf_init(ctx, data_buf);
-    js_std_dbuf_init(ctx, header_buf);
-
-    buf = js_malloc(ctx, URL_GET_BUF_SIZE);
-    if (!buf)
-        goto fail;
-
-    /* get the HTTP status */
-    if (http_get_header_line(f, buf, URL_GET_BUF_SIZE, NULL) < 0) {
-        status = 0;
-        goto bad_header;
-    }
-    status = http_get_status(buf);
-    if (!full_flag && !(status >= 200 && status <= 299)) {
-        goto bad_header;
-    }
-
-    /* wait until there is an empty line */
-    for(;;) {
-        if (http_get_header_line(f, buf, URL_GET_BUF_SIZE, header_buf) < 0) {
-        bad_header:
-            response = JS_NULL;
-            goto done;
-        }
-        if (!strcmp(buf, "\r\n"))
-            break;
-    }
-    if (dbuf_error(header_buf))
-        goto fail;
-    header_buf->size -= 2; /* remove the trailing CRLF */
-
-    /* download the data */
-    for(;;) {
-        len = fread(buf, 1, URL_GET_BUF_SIZE, f);
-        if (len == 0)
-            break;
-        dbuf_put(data_buf, (uint8_t *)buf, len);
-    }
-    if (dbuf_error(data_buf))
-        goto fail;
-    if (binary_flag) {
-        response = JS_NewArrayBufferCopy(ctx,
-                                         data_buf->buf, data_buf->size);
-    } else {
-        response = JS_NewStringLen(ctx, (char *)data_buf->buf, data_buf->size);
-    }
-    if (JS_IsException(response))
-        goto fail;
- done:
-    js_free(ctx, buf);
-    buf = NULL;
-    pclose(f);
-    f = NULL;
-    dbuf_free(data_buf);
-    data_buf = NULL;
-
-    if (full_flag) {
-        ret_obj = JS_NewObject(ctx);
-        if (JS_IsException(ret_obj))
-            goto fail;
-        JS_DefinePropertyValueStr(ctx, ret_obj, "response",
-                                  response,
-                                  JS_PROP_C_W_E);
-        if (!JS_IsNull(response)) {
-            JS_DefinePropertyValueStr(ctx, ret_obj, "responseHeaders",
-                                      JS_NewStringLen(ctx, (char *)header_buf->buf,
-                                                      header_buf->size),
-                                      JS_PROP_C_W_E);
-            JS_DefinePropertyValueStr(ctx, ret_obj, "status",
-                                      JS_NewInt32(ctx, status),
-                                      JS_PROP_C_W_E);
-        }
-    } else {
-        ret_obj = response;
-    }
-    dbuf_free(header_buf);
-    return ret_obj;
- fail:
-    if (f)
-        pclose(f);
-    js_free(ctx, buf);
-    if (data_buf)
-        dbuf_free(data_buf);
-    if (header_buf)
-        dbuf_free(header_buf);
-    JS_FreeValue(ctx, response);
-    return JS_EXCEPTION;
-}
-
-static JSClassDef js_std_file_class = {
-    "FILE",
-    .finalizer = js_std_file_finalizer,
-};
-
 static const JSCFunctionListEntry js_std_error_props[] = {
     /* various errno values */
 #define DEF(x) JS_PROP_INT32_DEF(#x, x, JS_PROP_CONFIGURABLE )
@@ -1512,18 +752,11 @@
     JS_CFUNC_DEF("getenv", 1, js_std_getenv ),
     JS_CFUNC_DEF("setenv", 1, js_std_setenv ),
     JS_CFUNC_DEF("unsetenv", 1, js_std_unsetenv ),
-    JS_CFUNC_DEF("getenviron", 1, js_std_getenviron ),
-    JS_CFUNC_DEF("urlGet", 1, js_std_urlGet ),
     JS_CFUNC_DEF("loadFile", 1, js_std_loadFile ),
     JS_CFUNC_DEF("strerror", 1, js_std_strerror ),
     JS_CFUNC_DEF("parseExtJSON", 1, js_std_parseExtJSON ),
 
     /* FILE I/O */
-    JS_CFUNC_DEF("open", 2, js_std_open ),
-    JS_CFUNC_DEF("popen", 2, js_std_popen ),
-    JS_CFUNC_DEF("fdopen", 2, js_std_fdopen ),
-    JS_CFUNC_DEF("tmpfile", 0, js_std_tmpfile ),
-    JS_CFUNC_MAGIC_DEF("puts", 1, js_std_file_puts, 0 ),
     JS_CFUNC_DEF("printf", 1, js_std_printf ),
     JS_CFUNC_DEF("sprintf", 1, js_std_sprintf ),
     JS_PROP_INT32_DEF("SEEK_SET", SEEK_SET, JS_PROP_CONFIGURABLE ),
@@ -1532,46 +765,15 @@
     JS_OBJECT_DEF("Error", js_std_error_props, countof(js_std_error_props), JS_PROP_CONFIGURABLE),
 };
 
-static const JSCFunctionListEntry js_std_file_proto_funcs[] = {
-    JS_CFUNC_DEF("close", 0, js_std_file_close ),
-    JS_CFUNC_MAGIC_DEF("puts", 1, js_std_file_puts, 1 ),
-    JS_CFUNC_DEF("printf", 1, js_std_file_printf ),
-    JS_CFUNC_DEF("flush", 0, js_std_file_flush ),
-    JS_CFUNC_MAGIC_DEF("tell", 0, js_std_file_tell, 0 ),
-    JS_CFUNC_MAGIC_DEF("tello", 0, js_std_file_tell, 1 ),
-    JS_CFUNC_DEF("seek", 2, js_std_file_seek ),
-    JS_CFUNC_DEF("eof", 0, js_std_file_eof ),
-    JS_CFUNC_DEF("fileno", 0, js_std_file_fileno ),
-    JS_CFUNC_DEF("error", 0, js_std_file_error ),
-    JS_CFUNC_DEF("clearerr", 0, js_std_file_clearerr ),
-    JS_CFUNC_MAGIC_DEF("read", 3, js_std_file_read_write, 0 ),
-    JS_CFUNC_MAGIC_DEF("write", 3, js_std_file_read_write, 1 ),
-    JS_CFUNC_DEF("getline", 0, js_std_file_getline ),
-    JS_CFUNC_DEF("readAsString", 0, js_std_file_readAsString ),
-    JS_CFUNC_DEF("getByte", 0, js_std_file_getByte ),
-    JS_CFUNC_DEF("putByte", 1, js_std_file_putByte ),
-    /* setvbuf, ...  */
-};
-
 static int js_std_init(JSContext *ctx, JSModuleDef *m)
 {
     JSValue proto;
 
     /* FILE class */
-    /* the class ID is created once */
-    JS_NewClassID(&js_std_file_class_id);
-    /* the class is created once per runtime */
-    JS_NewClass(JS_GetRuntime(ctx), js_std_file_class_id, &js_std_file_class);
     proto = JS_NewObject(ctx);
-    JS_SetPropertyFunctionList(ctx, proto, js_std_file_proto_funcs,
-                               countof(js_std_file_proto_funcs));
-    JS_SetClassProto(ctx, js_std_file_class_id, proto);
 
     JS_SetModuleExportList(ctx, m, js_std_funcs,
                            countof(js_std_funcs));
-    JS_SetModuleExport(ctx, m, "in", js_new_std_file(ctx, stdin, FALSE, FALSE));
-    JS_SetModuleExport(ctx, m, "out", js_new_std_file(ctx, stdout, FALSE, FALSE));
-    JS_SetModuleExport(ctx, m, "err", js_new_std_file(ctx, stderr, FALSE, FALSE));
     return 0;
 }
 
@@ -1591,256 +793,6 @@
 /**********************************************************/
 /* 'os' object */
 
-static JSValue js_os_open(JSContext *ctx, JSValueConst this_val,
-                          int argc, JSValueConst *argv)
-{
-    const char *filename;
-    int flags, mode, ret;
-
-    filename = JS_ToCString(ctx, argv[0]);
-    if (!filename)
-        return JS_EXCEPTION;
-    if (JS_ToInt32(ctx, &flags, argv[1]))
-        goto fail;
-    if (argc >= 3 && !JS_IsUndefined(argv[2])) {
-        if (JS_ToInt32(ctx, &mode, argv[2])) {
-        fail:
-            JS_FreeCString(ctx, filename);
-            return JS_EXCEPTION;
-        }
-    } else {
-        mode = 0666;
-    }
-#if defined(_WIN32)
-    /* force binary mode by default */
-    if (!(flags & O_TEXT))
-        flags |= O_BINARY;
-#endif
-    ret = js_get_errno(open(filename, flags, mode));
-    JS_FreeCString(ctx, filename);
-    return JS_NewInt32(ctx, ret);
-}
-
-static JSValue js_os_close(JSContext *ctx, JSValueConst this_val,
-                           int argc, JSValueConst *argv)
-{
-    int fd, ret;
-    if (JS_ToInt32(ctx, &fd, argv[0]))
-        return JS_EXCEPTION;
-    ret = js_get_errno(close(fd));
-    return JS_NewInt32(ctx, ret);
-}
-
-static JSValue js_os_seek(JSContext *ctx, JSValueConst this_val,
-                          int argc, JSValueConst *argv)
-{
-    int fd, whence;
-    int64_t pos, ret;
-    BOOL is_bigint;
-
-    if (JS_ToInt32(ctx, &fd, argv[0]))
-        return JS_EXCEPTION;
-    is_bigint = JS_IsBigInt(ctx, argv[1]);
-    if (JS_ToInt64Ext(ctx, &pos, argv[1]))
-        return JS_EXCEPTION;
-    if (JS_ToInt32(ctx, &whence, argv[2]))
-        return JS_EXCEPTION;
-    ret = lseek(fd, pos, whence);
-    if (ret == -1)
-        ret = -errno;
-    if (is_bigint)
-        return JS_NewBigInt64(ctx, ret);
-    else
-        return JS_NewInt64(ctx, ret);
-}
-
-static JSValue js_os_read_write(JSContext *ctx, JSValueConst this_val,
-                                int argc, JSValueConst *argv, int magic)
-{
-    int fd;
-    uint64_t pos, len;
-    size_t size;
-    ssize_t ret;
-    uint8_t *buf;
-
-    if (JS_ToInt32(ctx, &fd, argv[0]))
-        return JS_EXCEPTION;
-    if (JS_ToIndex(ctx, &pos, argv[2]))
-        return JS_EXCEPTION;
-    if (JS_ToIndex(ctx, &len, argv[3]))
-        return JS_EXCEPTION;
-    buf = JS_GetArrayBuffer(ctx, &size, argv[1]);
-    if (!buf)
-        return JS_EXCEPTION;
-    if (pos + len > size)
-        return JS_ThrowRangeError(ctx, "read/write array buffer overflow");
-    if (magic)
-        ret = js_get_errno(write(fd, buf + pos, len));
-    else
-        ret = js_get_errno(read(fd, buf + pos, len));
-    return JS_NewInt64(ctx, ret);
-}
-
-static JSValue js_os_isatty(JSContext *ctx, JSValueConst this_val,
-                            int argc, JSValueConst *argv)
-{
-    int fd;
-    if (JS_ToInt32(ctx, &fd, argv[0]))
-        return JS_EXCEPTION;
-    return JS_NewBool(ctx, isatty(fd));
-}
-
-#if defined(_WIN32)
-static JSValue js_os_ttyGetWinSize(JSContext *ctx, JSValueConst this_val,
-                                   int argc, JSValueConst *argv)
-{
-    int fd;
-    HANDLE handle;
-    CONSOLE_SCREEN_BUFFER_INFO info;
-    JSValue obj;
-
-    if (JS_ToInt32(ctx, &fd, argv[0]))
-        return JS_EXCEPTION;
-    handle = (HANDLE)_get_osfhandle(fd);
-
-    if (!GetConsoleScreenBufferInfo(handle, &info))
-        return JS_NULL;
-    obj = JS_NewArray(ctx);
-    if (JS_IsException(obj))
-        return obj;
-    JS_DefinePropertyValueUint32(ctx, obj, 0, JS_NewInt32(ctx, info.dwSize.X), JS_PROP_C_W_E);
-    JS_DefinePropertyValueUint32(ctx, obj, 1, JS_NewInt32(ctx, info.dwSize.Y), JS_PROP_C_W_E);
-    return obj;
-}
-
-/* Windows 10 built-in VT100 emulation */
-#define __ENABLE_VIRTUAL_TERMINAL_PROCESSING 0x0004
-#define __ENABLE_VIRTUAL_TERMINAL_INPUT 0x0200
-
-static JSValue js_os_ttySetRaw(JSContext *ctx, JSValueConst this_val,
-                               int argc, JSValueConst *argv)
-{
-    int fd;
-    HANDLE handle;
-
-    if (JS_ToInt32(ctx, &fd, argv[0]))
-        return JS_EXCEPTION;
-    handle = (HANDLE)_get_osfhandle(fd);
-    SetConsoleMode(handle, ENABLE_WINDOW_INPUT | __ENABLE_VIRTUAL_TERMINAL_INPUT);
-    _setmode(fd, _O_BINARY);
-    if (fd == 0) {
-        handle = (HANDLE)_get_osfhandle(1); /* corresponding output */
-        SetConsoleMode(handle, ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT | __ENABLE_VIRTUAL_TERMINAL_PROCESSING);
-    }
-    return JS_UNDEFINED;
-}
-#else
-static JSValue js_os_ttyGetWinSize(JSContext *ctx, JSValueConst this_val,
-                                   int argc, JSValueConst *argv)
-{
-    int fd;
-    struct winsize ws;
-    JSValue obj;
-
-    if (JS_ToInt32(ctx, &fd, argv[0]))
-        return JS_EXCEPTION;
-    if (ioctl(fd, TIOCGWINSZ, &ws) == 0 &&
-        ws.ws_col >= 4 && ws.ws_row >= 4) {
-        obj = JS_NewArray(ctx);
-        if (JS_IsException(obj))
-            return obj;
-        JS_DefinePropertyValueUint32(ctx, obj, 0, JS_NewInt32(ctx, ws.ws_col), JS_PROP_C_W_E);
-        JS_DefinePropertyValueUint32(ctx, obj, 1, JS_NewInt32(ctx, ws.ws_row), JS_PROP_C_W_E);
-        return obj;
-    } else {
-        return JS_NULL;
-    }
-}
-
-static struct termios oldtty;
-
-static void term_exit(void)
-{
-    tcsetattr(0, TCSANOW, &oldtty);
-}
-
-/* XXX: should add a way to go back to normal mode */
-static JSValue js_os_ttySetRaw(JSContext *ctx, JSValueConst this_val,
-                               int argc, JSValueConst *argv)
-{
-    struct termios tty;
-    int fd;
-
-    if (JS_ToInt32(ctx, &fd, argv[0]))
-        return JS_EXCEPTION;
-
-    memset(&tty, 0, sizeof(tty));
-    tcgetattr(fd, &tty);
-    oldtty = tty;
-
-    tty.c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP
-                          |INLCR|IGNCR|ICRNL|IXON);
-    tty.c_oflag |= OPOST;
-    tty.c_lflag &= ~(ECHO|ECHONL|ICANON|IEXTEN);
-    tty.c_cflag &= ~(CSIZE|PARENB);
-    tty.c_cflag |= CS8;
-    tty.c_cc[VMIN] = 1;
-    tty.c_cc[VTIME] = 0;
-
-    tcsetattr(fd, TCSANOW, &tty);
-
-    atexit(term_exit);
-    return JS_UNDEFINED;
-}
-
-#endif /* !_WIN32 */
-
-static JSValue js_os_remove(JSContext *ctx, JSValueConst this_val,
-                            int argc, JSValueConst *argv)
-{
-    const char *filename;
-    int ret;
-
-    filename = JS_ToCString(ctx, argv[0]);
-    if (!filename)
-        return JS_EXCEPTION;
-#if defined(_WIN32)
-    {
-        struct stat st;
-        if (stat(filename, &st) == 0 && S_ISDIR(st.st_mode)) {
-            ret = rmdir(filename);
-        } else {
-            ret = unlink(filename);
-        }
-    }
-#else
-    ret = remove(filename);
-#endif
-    ret = js_get_errno(ret);
-    JS_FreeCString(ctx, filename);
-    return JS_NewInt32(ctx, ret);
-}
-
-static JSValue js_os_rename(JSContext *ctx, JSValueConst this_val,
-                            int argc, JSValueConst *argv)
-{
-    const char *oldpath, *newpath;
-    int ret;
-
-    oldpath = JS_ToCString(ctx, argv[0]);
-    if (!oldpath)
-        return JS_EXCEPTION;
-    newpath = JS_ToCString(ctx, argv[1]);
-    if (!newpath) {
-        JS_FreeCString(ctx, oldpath);
-        return JS_EXCEPTION;
-    }
-    ret = js_get_errno(rename(oldpath, newpath));
-    JS_FreeCString(ctx, oldpath);
-    JS_FreeCString(ctx, newpath);
-    return JS_NewInt32(ctx, ret);
-}
-
 static BOOL is_main_thread(JSRuntime *rt)
 {
     JSThreadState *ts = JS_GetRuntimeOpaque(rt);
@@ -1940,53 +892,6 @@
 typedef void (*sighandler_t)(int sig_num);
 #endif
 
-static JSValue js_os_signal(JSContext *ctx, JSValueConst this_val,
-                            int argc, JSValueConst *argv)
-{
-    JSRuntime *rt = JS_GetRuntime(ctx);
-    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
-    JSOSSignalHandler *sh;
-    uint32_t sig_num;
-    JSValueConst func;
-    sighandler_t handler;
-
-    if (!is_main_thread(rt))
-        return JS_ThrowTypeError(ctx, "signal handler can only be set in the main thread");
-
-    if (JS_ToUint32(ctx, &sig_num, argv[0]))
-        return JS_EXCEPTION;
-    if (sig_num >= 64)
-        return JS_ThrowRangeError(ctx, "invalid signal number");
-    func = argv[1];
-    /* func = null: SIG_DFL, func = undefined, SIG_IGN */
-    if (JS_IsNull(func) || JS_IsUndefined(func)) {
-        sh = find_sh(ts, sig_num);
-        if (sh) {
-            free_sh(JS_GetRuntime(ctx), sh);
-        }
-        if (JS_IsNull(func))
-            handler = SIG_DFL;
-        else
-            handler = SIG_IGN;
-        signal(sig_num, handler);
-    } else {
-        if (!JS_IsFunction(ctx, func))
-            return JS_ThrowTypeError(ctx, "not a function");
-        sh = find_sh(ts, sig_num);
-        if (!sh) {
-            sh = js_mallocz(ctx, sizeof(*sh));
-            if (!sh)
-                return JS_EXCEPTION;
-            sh->sig_num = sig_num;
-            list_add_tail(&sh->link, &ts->os_signal_handlers);
-        }
-        JS_FreeValue(ctx, sh->func);
-        sh->func = JS_DupValue(ctx, func);
-        signal(sig_num, os_signal_handler);
-    }
-    return JS_UNDEFINED;
-}
-
 #if defined(__linux__) || defined(__APPLE__)
 static int64_t get_time_ms(void)
 {
@@ -1994,43 +899,57 @@
     clock_gettime(CLOCK_MONOTONIC, &ts);
     return (uint64_t)ts.tv_sec * 1000 + (ts.tv_nsec / 1000000);
 }
-
-static int64_t get_time_ns(void)
+#elif defined(_MSC_VER)
+static int64_t get_time_ms(void)
 {
-    struct timespec ts;
-    clock_gettime(CLOCK_MONOTONIC, &ts);
-    return (uint64_t)ts.tv_sec * 1000000000 + ts.tv_nsec;
+	return GetTickCount();
 }
 #else
 /* more portable, but does not work if the date is updated */
+int gettimeofday(struct timeval *tp, void *tzp);
 static int64_t get_time_ms(void)
 {
     struct timeval tv;
     gettimeofday(&tv, NULL);
     return (int64_t)tv.tv_sec * 1000 + (tv.tv_usec / 1000);
 }
-
-static int64_t get_time_ns(void)
-{
-    struct timeval tv;
-    gettimeofday(&tv, NULL);
-    return (int64_t)tv.tv_sec * 1000000000 + (tv.tv_usec * 1000);
-}
 #endif
 
-static JSValue js_os_now(JSContext *ctx, JSValue this_val,
-                         int argc, JSValue *argv)
+static void unlink_timer(JSRuntime *rt, JSOSTimer *th)
 {
-    return JS_NewFloat64(ctx, (double)get_time_ns() / 1e6);
+    if (th->link.prev) {
+        list_del(&th->link);
+        th->link.prev = th->link.next = NULL;
+    }
 }
 
 static void free_timer(JSRuntime *rt, JSOSTimer *th)
 {
-    list_del(&th->link);
     JS_FreeValueRT(rt, th->func);
     js_free_rt(rt, th);
 }
 
+static JSClassID js_os_timer_class_id;
+
+static void js_os_timer_finalizer(JSRuntime *rt, JSValue val)
+{
+    JSOSTimer *th = JS_GetOpaque(val, js_os_timer_class_id);
+    if (th) {
+        th->has_object = FALSE;
+        if (!th->link.prev)
+            free_timer(rt, th);
+    }
+}
+
+static void js_os_timer_mark(JSRuntime *rt, JSValueConst val,
+                             JS_MarkFunc *mark_func)
+{
+    JSOSTimer *th = JS_GetOpaque(val, js_os_timer_class_id);
+    if (th) {
+        JS_MarkValue(rt, th->func, mark_func);
+    }
+}
+
 static JSValue js_os_setTimeout(JSContext *ctx, JSValueConst this_val,
                                 int argc, JSValueConst *argv)
 {
@@ -2039,87 +958,44 @@
     int64_t delay;
     JSValueConst func;
     JSOSTimer *th;
+    JSValue obj;
 
     func = argv[0];
     if (!JS_IsFunction(ctx, func))
         return JS_ThrowTypeError(ctx, "not a function");
     if (JS_ToInt64(ctx, &delay, argv[1]))
         return JS_EXCEPTION;
+    obj = JS_NewObjectClass(ctx, js_os_timer_class_id);
+    if (JS_IsException(obj))
+        return obj;
     th = js_mallocz(ctx, sizeof(*th));
-    if (!th)
+    if (!th) {
+        JS_FreeValue(ctx, obj);
         return JS_EXCEPTION;
-    th->timer_id = ts->next_timer_id;
-    if (ts->next_timer_id == INT32_MAX)
-        ts->next_timer_id = 1;
-    else
-        ts->next_timer_id++;
+    }
+    th->has_object = TRUE;
     th->timeout = get_time_ms() + delay;
     th->func = JS_DupValue(ctx, func);
     list_add_tail(&th->link, &ts->os_timers);
-    return JS_NewInt32(ctx, th->timer_id);
-}
-
-static JSOSTimer *find_timer_by_id(JSThreadState *ts, int timer_id)
-{
-    struct list_head *el;
-    if (timer_id <= 0)
-        return NULL;
-    list_for_each(el, &ts->os_timers) {
-        JSOSTimer *th = list_entry(el, JSOSTimer, link);
-        if (th->timer_id == timer_id)
-            return th;
-    }
-    return NULL;
+    JS_SetOpaque(obj, th);
+    return obj;
 }
 
 static JSValue js_os_clearTimeout(JSContext *ctx, JSValueConst this_val,
                                   int argc, JSValueConst *argv)
 {
-    JSRuntime *rt = JS_GetRuntime(ctx);
-    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
-    JSOSTimer *th;
-    int timer_id;
-
-    if (JS_ToInt32(ctx, &timer_id, argv[0]))
-        return JS_EXCEPTION;
-    th = find_timer_by_id(ts, timer_id);
+    JSOSTimer *th = JS_GetOpaque2(ctx, argv[0], js_os_timer_class_id);
     if (!th)
-        return JS_UNDEFINED;
-    free_timer(rt, th);
-    return JS_UNDEFINED;
-}
-
-/* return a promise */
-static JSValue js_os_sleepAsync(JSContext *ctx, JSValueConst this_val,
-                                int argc, JSValueConst *argv)
-{
-    JSRuntime *rt = JS_GetRuntime(ctx);
-    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
-    int64_t delay;
-    JSOSTimer *th;
-    JSValue promise, resolving_funcs[2];
-
-    if (JS_ToInt64(ctx, &delay, argv[0]))
         return JS_EXCEPTION;
-    promise = JS_NewPromiseCapability(ctx, resolving_funcs);
-    if (JS_IsException(promise))
-        return JS_EXCEPTION;
-
-    th = js_mallocz(ctx, sizeof(*th));
-    if (!th) {
-        JS_FreeValue(ctx, promise);
-        JS_FreeValue(ctx, resolving_funcs[0]);
-        JS_FreeValue(ctx, resolving_funcs[1]);
-        return JS_EXCEPTION;
-    }
-    th->timer_id = -1;
-    th->timeout = get_time_ms() + delay;
-    th->func = JS_DupValue(ctx, resolving_funcs[0]);
-    list_add_tail(&th->link, &ts->os_timers);
-    JS_FreeValue(ctx, resolving_funcs[0]);
-    JS_FreeValue(ctx, resolving_funcs[1]);
-    return promise;
+    unlink_timer(JS_GetRuntime(ctx), th);
+    return JS_UNDEFINED;
 }
+
+static JSClassDef js_os_timer_class = {
+    "OSTimer",
+    .finalizer = js_os_timer_finalizer,
+    .gc_mark = js_os_timer_mark,
+};
 
 static void call_handler(JSContext *ctx, JSValueConst func)
 {
@@ -2162,7 +1038,9 @@
                 /* the timer expired */
                 func = th->func;
                 th->func = JS_UNDEFINED;
-                free_timer(rt, th);
+                unlink_timer(rt, th);
+                if (!th->has_object)
+                    free_timer(rt, th);
                 call_handler(ctx, func);
                 JS_FreeValue(ctx, func);
                 return 0;
@@ -2329,7 +1207,9 @@
                 /* the timer expired */
                 func = th->func;
                 th->func = JS_UNDEFINED;
-                free_timer(rt, th);
+                unlink_timer(rt, th);
+                if (!th->has_object)
+                    free_timer(rt, th);
                 call_handler(ctx, func);
                 JS_FreeValue(ctx, func);
                 return 0;
@@ -2423,251 +1303,9 @@
     return make_obj_error(ctx, JS_NewString(ctx, buf), err);
 }
 
-/* return [cwd, errorcode] */
-static JSValue js_os_getcwd(JSContext *ctx, JSValueConst this_val,
-                            int argc, JSValueConst *argv)
-{
-    char buf[PATH_MAX];
-    int err;
-
-    if (!getcwd(buf, sizeof(buf))) {
-        buf[0] = '\0';
-        err = errno;
-    } else {
-        err = 0;
-    }
-    return make_string_error(ctx, buf, err);
-}
-
-static JSValue js_os_chdir(JSContext *ctx, JSValueConst this_val,
-                           int argc, JSValueConst *argv)
-{
-    const char *target;
-    int err;
-
-    target = JS_ToCString(ctx, argv[0]);
-    if (!target)
-        return JS_EXCEPTION;
-    err = js_get_errno(chdir(target));
-    JS_FreeCString(ctx, target);
-    return JS_NewInt32(ctx, err);
-}
-
-static JSValue js_os_mkdir(JSContext *ctx, JSValueConst this_val,
-                           int argc, JSValueConst *argv)
-{
-    int mode, ret;
-    const char *path;
-
-    if (argc >= 2) {
-        if (JS_ToInt32(ctx, &mode, argv[1]))
-            return JS_EXCEPTION;
-    } else {
-        mode = 0777;
-    }
-    path = JS_ToCString(ctx, argv[0]);
-    if (!path)
-        return JS_EXCEPTION;
-#if defined(_WIN32)
-    (void)mode;
-    ret = js_get_errno(mkdir(path));
-#else
-    ret = js_get_errno(mkdir(path, mode));
-#endif
-    JS_FreeCString(ctx, path);
-    return JS_NewInt32(ctx, ret);
-}
-
-/* return [array, errorcode] */
-static JSValue js_os_readdir(JSContext *ctx, JSValueConst this_val,
-                             int argc, JSValueConst *argv)
-{
-    const char *path;
-    DIR *f;
-    struct dirent *d;
-    JSValue obj;
-    int err;
-    uint32_t len;
-
-    path = JS_ToCString(ctx, argv[0]);
-    if (!path)
-        return JS_EXCEPTION;
-    obj = JS_NewArray(ctx);
-    if (JS_IsException(obj)) {
-        JS_FreeCString(ctx, path);
-        return JS_EXCEPTION;
-    }
-    f = opendir(path);
-    if (!f)
-        err = errno;
-    else
-        err = 0;
-    JS_FreeCString(ctx, path);
-    if (!f)
-        goto done;
-    len = 0;
-    for(;;) {
-        errno = 0;
-        d = readdir(f);
-        if (!d) {
-            err = errno;
-            break;
-        }
-        JS_DefinePropertyValueUint32(ctx, obj, len++,
-                                     JS_NewString(ctx, d->d_name),
-                                     JS_PROP_C_W_E);
-    }
-    closedir(f);
- done:
-    return make_obj_error(ctx, obj, err);
-}
-
-#if !defined(_WIN32)
-static int64_t timespec_to_ms(const struct timespec *tv)
-{
-    return (int64_t)tv->tv_sec * 1000 + (tv->tv_nsec / 1000000);
-}
-#endif
-
-/* return [obj, errcode] */
-static JSValue js_os_stat(JSContext *ctx, JSValueConst this_val,
-                          int argc, JSValueConst *argv, int is_lstat)
-{
-    const char *path;
-    int err, res;
-    struct stat st;
-    JSValue obj;
-
-    path = JS_ToCString(ctx, argv[0]);
-    if (!path)
-        return JS_EXCEPTION;
-#if defined(_WIN32)
-    res = stat(path, &st);
-#else
-    if (is_lstat)
-        res = lstat(path, &st);
-    else
-        res = stat(path, &st);
-#endif
-    if (res < 0)
-        err = errno;
-    else
-        err = 0;
-    JS_FreeCString(ctx, path);
-    if (res < 0) {
-        obj = JS_NULL;
-    } else {
-        obj = JS_NewObject(ctx);
-        if (JS_IsException(obj))
-            return JS_EXCEPTION;
-        JS_DefinePropertyValueStr(ctx, obj, "dev",
-                                  JS_NewInt64(ctx, st.st_dev),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "ino",
-                                  JS_NewInt64(ctx, st.st_ino),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "mode",
-                                  JS_NewInt32(ctx, st.st_mode),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "nlink",
-                                  JS_NewInt64(ctx, st.st_nlink),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "uid",
-                                  JS_NewInt64(ctx, st.st_uid),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "gid",
-                                  JS_NewInt64(ctx, st.st_gid),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "rdev",
-                                  JS_NewInt64(ctx, st.st_rdev),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "size",
-                                  JS_NewInt64(ctx, st.st_size),
-                                  JS_PROP_C_W_E);
-#if !defined(_WIN32)
-        JS_DefinePropertyValueStr(ctx, obj, "blocks",
-                                  JS_NewInt64(ctx, st.st_blocks),
-                                  JS_PROP_C_W_E);
-#endif
-#if defined(_WIN32)
-        JS_DefinePropertyValueStr(ctx, obj, "atime",
-                                  JS_NewInt64(ctx, (int64_t)st.st_atime * 1000),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "mtime",
-                                  JS_NewInt64(ctx, (int64_t)st.st_mtime * 1000),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "ctime",
-                                  JS_NewInt64(ctx, (int64_t)st.st_ctime * 1000),
-                                  JS_PROP_C_W_E);
-#elif defined(__APPLE__)
-        JS_DefinePropertyValueStr(ctx, obj, "atime",
-                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_atimespec)),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "mtime",
-                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_mtimespec)),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "ctime",
-                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_ctimespec)),
-                                  JS_PROP_C_W_E);
-#else
-        JS_DefinePropertyValueStr(ctx, obj, "atime",
-                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_atim)),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "mtime",
-                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_mtim)),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "ctime",
-                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_ctim)),
-                                  JS_PROP_C_W_E);
-#endif
-    }
-    return make_obj_error(ctx, obj, err);
-}
-
-#if !defined(_WIN32)
-static void ms_to_timeval(struct timeval *tv, uint64_t v)
-{
-    tv->tv_sec = v / 1000;
-    tv->tv_usec = (v % 1000) * 1000;
-}
-#endif
-
-static JSValue js_os_utimes(JSContext *ctx, JSValueConst this_val,
-                            int argc, JSValueConst *argv)
-{
-    const char *path;
-    int64_t atime, mtime;
-    int ret;
-
-    if (JS_ToInt64(ctx, &atime, argv[1]))
-        return JS_EXCEPTION;
-    if (JS_ToInt64(ctx, &mtime, argv[2]))
-        return JS_EXCEPTION;
-    path = JS_ToCString(ctx, argv[0]);
-    if (!path)
-        return JS_EXCEPTION;
-#if defined(_WIN32)
-    {
-        struct _utimbuf times;
-        times.actime = atime / 1000;
-        times.modtime = mtime / 1000;
-        ret = js_get_errno(_utime(path, &times));
-    }
-#else
-    {
-        struct timeval times[2];
-        ms_to_timeval(&times[0], atime);
-        ms_to_timeval(&times[1], mtime);
-        ret = js_get_errno(utimes(path, times));
-    }
-#endif
-    JS_FreeCString(ctx, path);
-    return JS_NewInt32(ctx, ret);
-}
-
 /* sleep(delay_ms) */
 static JSValue js_os_sleep(JSContext *ctx, JSValueConst this_val,
-                           int argc, JSValueConst *argv)
+                          int argc, JSValueConst *argv)
 {
     int64_t delay;
     int ret;
@@ -2731,7 +1369,7 @@
 
 #if !defined(_WIN32)
 static JSValue js_os_symlink(JSContext *ctx, JSValueConst this_val,
-                             int argc, JSValueConst *argv)
+                              int argc, JSValueConst *argv)
 {
     const char *target, *linkpath;
     int err;
@@ -2889,211 +1527,6 @@
     return -1;
 }
 
-/* exec(args[, options]) -> exitcode */
-static JSValue js_os_exec(JSContext *ctx, JSValueConst this_val,
-                          int argc, JSValueConst *argv)
-{
-    JSValueConst options, args = argv[0];
-    JSValue val, ret_val;
-    const char **exec_argv, *file = NULL, *str, *cwd = NULL;
-    char **envp = environ;
-    uint32_t exec_argc, i;
-    int ret, pid, status;
-    BOOL block_flag = TRUE, use_path = TRUE;
-    static const char *std_name[3] = { "stdin", "stdout", "stderr" };
-    int std_fds[3];
-    uint32_t uid = -1, gid = -1;
-
-    val = JS_GetPropertyStr(ctx, args, "length");
-    if (JS_IsException(val))
-        return JS_EXCEPTION;
-    ret = JS_ToUint32(ctx, &exec_argc, val);
-    JS_FreeValue(ctx, val);
-    if (ret)
-        return JS_EXCEPTION;
-    /* arbitrary limit to avoid overflow */
-    if (exec_argc < 1 || exec_argc > 65535) {
-        return JS_ThrowTypeError(ctx, "invalid number of arguments");
-    }
-    exec_argv = js_mallocz(ctx, sizeof(exec_argv[0]) * (exec_argc + 1));
-    if (!exec_argv)
-        return JS_EXCEPTION;
-    for(i = 0; i < exec_argc; i++) {
-        val = JS_GetPropertyUint32(ctx, args, i);
-        if (JS_IsException(val))
-            goto exception;
-        str = JS_ToCString(ctx, val);
-        JS_FreeValue(ctx, val);
-        if (!str)
-            goto exception;
-        exec_argv[i] = str;
-    }
-    exec_argv[exec_argc] = NULL;
-
-    for(i = 0; i < 3; i++)
-        std_fds[i] = i;
-
-    /* get the options, if any */
-    if (argc >= 2) {
-        options = argv[1];
-
-        if (get_bool_option(ctx, &block_flag, options, "block"))
-            goto exception;
-        if (get_bool_option(ctx, &use_path, options, "usePath"))
-            goto exception;
-
-        val = JS_GetPropertyStr(ctx, options, "file");
-        if (JS_IsException(val))
-            goto exception;
-        if (!JS_IsUndefined(val)) {
-            file = JS_ToCString(ctx, val);
-            JS_FreeValue(ctx, val);
-            if (!file)
-                goto exception;
-        }
-
-        val = JS_GetPropertyStr(ctx, options, "cwd");
-        if (JS_IsException(val))
-            goto exception;
-        if (!JS_IsUndefined(val)) {
-            cwd = JS_ToCString(ctx, val);
-            JS_FreeValue(ctx, val);
-            if (!cwd)
-                goto exception;
-        }
-
-        /* stdin/stdout/stderr handles */
-        for(i = 0; i < 3; i++) {
-            val = JS_GetPropertyStr(ctx, options, std_name[i]);
-            if (JS_IsException(val))
-                goto exception;
-            if (!JS_IsUndefined(val)) {
-                int fd;
-                ret = JS_ToInt32(ctx, &fd, val);
-                JS_FreeValue(ctx, val);
-                if (ret)
-                    goto exception;
-                std_fds[i] = fd;
-            }
-        }
-
-        val = JS_GetPropertyStr(ctx, options, "env");
-        if (JS_IsException(val))
-            goto exception;
-        if (!JS_IsUndefined(val)) {
-            envp = build_envp(ctx, val);
-            JS_FreeValue(ctx, val);
-            if (!envp)
-                goto exception;
-        }
-
-        val = JS_GetPropertyStr(ctx, options, "uid");
-        if (JS_IsException(val))
-            goto exception;
-        if (!JS_IsUndefined(val)) {
-            ret = JS_ToUint32(ctx, &uid, val);
-            JS_FreeValue(ctx, val);
-            if (ret)
-                goto exception;
-        }
-
-        val = JS_GetPropertyStr(ctx, options, "gid");
-        if (JS_IsException(val))
-            goto exception;
-        if (!JS_IsUndefined(val)) {
-            ret = JS_ToUint32(ctx, &gid, val);
-            JS_FreeValue(ctx, val);
-            if (ret)
-                goto exception;
-        }
-    }
-
-    pid = fork();
-    if (pid < 0) {
-        JS_ThrowTypeError(ctx, "fork error");
-        goto exception;
-    }
-    if (pid == 0) {
-        /* child */
-        int fd_max = sysconf(_SC_OPEN_MAX);
-
-        /* remap the stdin/stdout/stderr handles if necessary */
-        for(i = 0; i < 3; i++) {
-            if (std_fds[i] != i) {
-                if (dup2(std_fds[i], i) < 0)
-                    _exit(127);
-            }
-        }
-
-        for(i = 3; i < fd_max; i++)
-            close(i);
-        if (cwd) {
-            if (chdir(cwd) < 0)
-                _exit(127);
-        }
-        if (uid != -1) {
-            if (setuid(uid) < 0)
-                _exit(127);
-        }
-        if (gid != -1) {
-            if (setgid(gid) < 0)
-                _exit(127);
-        }
-
-        if (!file)
-            file = exec_argv[0];
-        if (use_path)
-            ret = my_execvpe(file, (char **)exec_argv, envp);
-        else
-            ret = execve(file, (char **)exec_argv, envp);
-        _exit(127);
-    }
-    /* parent */
-    if (block_flag) {
-        for(;;) {
-            ret = waitpid(pid, &status, 0);
-            if (ret == pid) {
-                if (WIFEXITED(status)) {
-                    ret = WEXITSTATUS(status);
-                    break;
-                } else if (WIFSIGNALED(status)) {
-                    ret = -WTERMSIG(status);
-                    break;
-                }
-            }
-        }
-    } else {
-        ret = pid;
-    }
-    ret_val = JS_NewInt32(ctx, ret);
- done:
-    JS_FreeCString(ctx, file);
-    JS_FreeCString(ctx, cwd);
-    for(i = 0; i < exec_argc; i++)
-        JS_FreeCString(ctx, exec_argv[i]);
-    js_free(ctx, exec_argv);
-    if (envp != environ) {
-        char **p;
-        p = envp;
-        while (*p != NULL) {
-            js_free(ctx, *p);
-            p++;
-        }
-        js_free(ctx, envp);
-    }
-    return ret_val;
- exception:
-    ret_val = JS_EXCEPTION;
-    goto done;
-}
-
-/* getpid() -> pid */
-static JSValue js_os_getpid(JSContext *ctx, JSValueConst this_val,
-                            int argc, JSValueConst *argv)
-{
-    return JS_NewInt32(ctx, getpid());
-}
-
 /* waitpid(pid, block) -> [pid, status] */
 static JSValue js_os_waitpid(JSContext *ctx, JSValueConst this_val,
                              int argc, JSValueConst *argv)
@@ -3338,7 +1771,6 @@
     JSRuntime *rt;
     JSThreadState *ts;
     JSContext *ctx;
-    JSValue val;
 
     rt = JS_NewRuntime();
     if (rt == NULL) {
@@ -3365,14 +1797,11 @@
 
     js_std_add_helpers(ctx, -1, NULL);
 
-    val = JS_LoadModule(ctx, args->basename, args->filename);
+    if (!JS_RunModule(ctx, args->basename, args->filename))
+        js_std_dump_error(ctx);
     free(args->filename);
     free(args->basename);
     free(args);
-    val = js_std_await(ctx, val);
-    if (JS_IsException(val))
-        js_std_dump_error(ctx);
-    JS_FreeValue(ctx, val);
 
     js_std_loop(ctx);
 
@@ -3527,12 +1956,10 @@
     memcpy(msg->data, data, data_len);
     msg->data_len = data_len;
 
-    if (sab_tab_len > 0) {
-        msg->sab_tab = malloc(sizeof(msg->sab_tab[0]) * sab_tab_len);
-        if (!msg->sab_tab)
-            goto fail;
-        memcpy(msg->sab_tab, sab_tab, sizeof(msg->sab_tab[0]) * sab_tab_len);
-    }
+    msg->sab_tab = malloc(sizeof(msg->sab_tab[0]) * sab_tab_len);
+    if (!msg->sab_tab)
+        goto fail;
+    memcpy(msg->sab_tab, sab_tab, sizeof(msg->sab_tab[0]) * sab_tab_len);
     msg->sab_tab_len = sab_tab_len;
 
     js_free(ctx, data);
@@ -3648,7 +2075,6 @@
 #define OS_FLAG(x) JS_PROP_INT32_DEF(#x, x, JS_PROP_CONFIGURABLE )
 
 static const JSCFunctionListEntry js_os_funcs[] = {
-    JS_CFUNC_DEF("open", 2, js_os_open ),
     OS_FLAG(O_RDONLY),
     OS_FLAG(O_WRONLY),
     OS_FLAG(O_RDWR),
@@ -3660,18 +2086,8 @@
     OS_FLAG(O_BINARY),
     OS_FLAG(O_TEXT),
 #endif
-    JS_CFUNC_DEF("close", 1, js_os_close ),
-    JS_CFUNC_DEF("seek", 3, js_os_seek ),
-    JS_CFUNC_MAGIC_DEF("read", 4, js_os_read_write, 0 ),
-    JS_CFUNC_MAGIC_DEF("write", 4, js_os_read_write, 1 ),
-    JS_CFUNC_DEF("isatty", 1, js_os_isatty ),
-    JS_CFUNC_DEF("ttyGetWinSize", 1, js_os_ttyGetWinSize ),
-    JS_CFUNC_DEF("ttySetRaw", 1, js_os_ttySetRaw ),
-    JS_CFUNC_DEF("remove", 1, js_os_remove ),
-    JS_CFUNC_DEF("rename", 2, js_os_rename ),
     JS_CFUNC_MAGIC_DEF("setReadHandler", 2, js_os_setReadHandler, 0 ),
     JS_CFUNC_MAGIC_DEF("setWriteHandler", 2, js_os_setReadHandler, 1 ),
-    JS_CFUNC_DEF("signal", 2, js_os_signal ),
     OS_FLAG(SIGINT),
     OS_FLAG(SIGABRT),
     OS_FLAG(SIGFPE),
@@ -3691,38 +2107,19 @@
     OS_FLAG(SIGTTIN),
     OS_FLAG(SIGTTOU),
 #endif
-    JS_CFUNC_DEF("now", 0, js_os_now ),
     JS_CFUNC_DEF("setTimeout", 2, js_os_setTimeout ),
     JS_CFUNC_DEF("clearTimeout", 1, js_os_clearTimeout ),
-    JS_CFUNC_DEF("sleepAsync", 1, js_os_sleepAsync ),
     JS_PROP_STRING_DEF("platform", OS_PLATFORM, 0 ),
-    JS_CFUNC_DEF("getcwd", 0, js_os_getcwd ),
-    JS_CFUNC_DEF("chdir", 0, js_os_chdir ),
-    JS_CFUNC_DEF("mkdir", 1, js_os_mkdir ),
-    JS_CFUNC_DEF("readdir", 1, js_os_readdir ),
     /* st_mode constants */
     OS_FLAG(S_IFMT),
-    OS_FLAG(S_IFIFO),
     OS_FLAG(S_IFCHR),
     OS_FLAG(S_IFDIR),
-    OS_FLAG(S_IFBLK),
     OS_FLAG(S_IFREG),
-#if !defined(_WIN32)
-    OS_FLAG(S_IFSOCK),
-    OS_FLAG(S_IFLNK),
-    OS_FLAG(S_ISGID),
-    OS_FLAG(S_ISUID),
-#endif
-    JS_CFUNC_MAGIC_DEF("stat", 1, js_os_stat, 0 ),
-    JS_CFUNC_DEF("utimes", 3, js_os_utimes ),
     JS_CFUNC_DEF("sleep", 1, js_os_sleep ),
     JS_CFUNC_DEF("realpath", 1, js_os_realpath ),
 #if !defined(_WIN32)
-    JS_CFUNC_MAGIC_DEF("lstat", 1, js_os_stat, 1 ),
     JS_CFUNC_DEF("symlink", 2, js_os_symlink ),
     JS_CFUNC_DEF("readlink", 1, js_os_readlink ),
-    JS_CFUNC_DEF("exec", 1, js_os_exec ),
-    JS_CFUNC_DEF("getpid", 0, js_os_getpid ),
     JS_CFUNC_DEF("waitpid", 2, js_os_waitpid ),
     OS_FLAG(WNOHANG),
     JS_CFUNC_DEF("pipe", 0, js_os_pipe ),
@@ -3736,6 +2133,10 @@
 {
     os_poll_func = js_os_poll;
 
+    /* OSTimer class */
+    JS_NewClassID(&js_os_timer_class_id);
+    JS_NewClass(JS_GetRuntime(ctx), js_os_timer_class_id, &js_os_timer_class);
+
 #ifdef USE_WORKER
     {
         JSRuntime *rt = JS_GetRuntime(ctx);
@@ -3784,7 +2185,7 @@
 /**********************************************************/
 
 static JSValue js_print(JSContext *ctx, JSValueConst this_val,
-                        int argc, JSValueConst *argv)
+                              int argc, JSValueConst *argv)
 {
     int i;
     const char *str;
@@ -3847,7 +2248,6 @@
     init_list_head(&ts->os_signal_handlers);
     init_list_head(&ts->os_timers);
     init_list_head(&ts->port_list);
-    ts->next_timer_id = 1;
 
     JS_SetRuntimeOpaque(rt, ts);
 
@@ -3881,7 +2281,9 @@
 
     list_for_each_safe(el, el1, &ts->os_timers) {
         JSOSTimer *th = list_entry(el, JSOSTimer, link);
-        free_timer(rt, th);
+        unlink_timer(rt, th);
+        if (!th->has_object)
+            free_timer(rt, th);
     }
 
 #ifdef USE_WORKER
@@ -3964,42 +2366,6 @@
             break;
     }
 }
-
-/* Wait for a promise and execute pending jobs while waiting for
-   it. Return the promise result or JS_EXCEPTION in case of promise
-   rejection. */
-JSValue js_std_await(JSContext *ctx, JSValue obj)
-{
-    JSValue ret;
-    int state;
-
-    for(;;) {
-        state = JS_PromiseState(ctx, obj);
-        if (state == JS_PROMISE_FULFILLED) {
-            ret = JS_PromiseResult(ctx, obj);
-            JS_FreeValue(ctx, obj);
-            break;
-        } else if (state == JS_PROMISE_REJECTED) {
-            ret = JS_Throw(ctx, JS_PromiseResult(ctx, obj));
-            JS_FreeValue(ctx, obj);
-            break;
-        } else if (state == JS_PROMISE_PENDING) {
-            JSContext *ctx1;
-            int err;
-            err = JS_ExecutePendingJob(JS_GetRuntime(ctx), &ctx1);
-            if (err < 0) {
-                js_std_dump_error(ctx1);
-            }
-            if (os_poll_func)
-                os_poll_func(ctx);
-        } else {
-            /* not a promise */
-            ret = obj;
-            break;
-        }
-    }
-    return ret;
-}
 
 void js_std_eval_binary(JSContext *ctx, const uint8_t *buf, size_t buf_len,
                         int load_only)
@@ -4019,11 +2385,8 @@
                 goto exception;
             }
             js_module_set_import_meta(ctx, obj, FALSE, TRUE);
-            val = JS_EvalFunction(ctx, obj);
-            val = js_std_await(ctx, val);
-        } else {
-            val = JS_EvalFunction(ctx, obj);
-        }
+        }
+        val = JS_EvalFunction(ctx, obj);
         if (JS_IsException(val)) {
         exception:
             js_std_dump_error(ctx);
Index: svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_all_attributes.inc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_all_attributes.inc b/svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_all_attributes.inc
--- a/svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_all_attributes.inc	(revision 5f1870aa7b757718ff5f86bdfb55966fa4f217f9)
+++ b/svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_all_attributes.inc	(date 1714440647086)
@@ -43,6 +43,9 @@
 SVGPP_ON      (cx                                 , cx)
 SVGPP_ON      (cy                                 , cy)
 SVGPP_ON      (d                                  , d)
+SVGPP_ON_STYLE(data_c                             , data-c)
+SVGPP_ON_STYLE(data_mjx_texclass                  , data-mjx-texclass)
+SVGPP_ON_STYLE(data_mml_node                      , data-mml-node)
 SVGPP_ON      (descent                            , descent)
 SVGPP_ON      (diffuseConstant                    , diffuseConstant)
 SVGPP_ON_STYLE(direction                          , direction)
Index: quickjs-src/quickjs/libbf.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/libbf.c b/quickjs-src/quickjs/src/libbf.c
rename from quickjs-src/quickjs/libbf.c
rename to quickjs-src/quickjs/src/libbf.c
--- a/quickjs-src/quickjs/libbf.c	(revision 3b45d155c77bbdfe9177b1e03db830d2aff0b2a8)
+++ b/quickjs-src/quickjs/src/libbf.c	(date 1714440647082)
@@ -136,7 +136,6 @@
         return a / b;
 }
 
-#ifdef USE_BF_DEC
 /* b must be >= 1 */
 static inline slimb_t floor_div(slimb_t a, slimb_t b)
 {
@@ -146,7 +145,6 @@
         return (a - b + 1) / b;
     }
 }
-#endif
 
 /* return r = a modulo b (0 <= r <= b - 1. b must be >= 1 */
 static inline limb_t smod(slimb_t a, slimb_t b)
@@ -311,7 +309,7 @@
     }
     r->sign = a->sign;
     r->expn = a->expn;
-    memcpy_no_ub(r->tab, a->tab, a->len * sizeof(limb_t));
+    memcpy(r->tab, a->tab, a->len * sizeof(limb_t));
     return 0;
 }
 
Index: svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_presentation_attributes.inc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_presentation_attributes.inc b/svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_presentation_attributes.inc
--- a/svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_presentation_attributes.inc	(revision 5f1870aa7b757718ff5f86bdfb55966fa4f217f9)
+++ b/svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_presentation_attributes.inc	(date 1714440647086)
@@ -16,6 +16,9 @@
 SVGPP_ON(color_rendering)
 SVGPP_ON(color)
 SVGPP_ON(cursor)
+SVGPP_ON(data_c)
+SVGPP_ON(data_mjx_texclass)
+SVGPP_ON(data_mml_node)
 SVGPP_ON(direction)
 SVGPP_ON(display)
 SVGPP_ON(dominant_baseline)
Index: quickjs-src/quickjs/quickjs-opcode.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/quickjs-opcode.h b/quickjs-src/quickjs/src/quickjs-opcode.h
rename from quickjs-src/quickjs/quickjs-opcode.h
rename to quickjs-src/quickjs/src/quickjs-opcode.h
--- a/quickjs-src/quickjs/quickjs-opcode.h	(revision 3b45d155c77bbdfe9177b1e03db830d2aff0b2a8)
+++ b/quickjs-src/quickjs/src/quickjs-opcode.h	(date 1714440647082)
@@ -172,7 +172,6 @@
 DEF(  get_loc_check, 3, 0, 1, loc)
 DEF(  put_loc_check, 3, 1, 0, loc) /* must come after get_loc_check */
 DEF(  put_loc_check_init, 3, 1, 0, loc)
-DEF(get_loc_checkthis, 3, 0, 1, loc)
 DEF(get_var_ref_check, 3, 0, 1, var_ref)
 DEF(put_var_ref_check, 3, 1, 0, var_ref) /* must come after get_var_ref_check */
 DEF(put_var_ref_check_init, 3, 1, 0, var_ref)
@@ -183,7 +182,6 @@
 DEF(          catch, 5, 0, 1, label)
 DEF(          gosub, 5, 0, 0, label) /* used to execute the finally block */
 DEF(            ret, 1, 1, 0, none) /* used to return from the finally block */
-DEF(      nip_catch, 1, 2, 1, none) /* catch ... a -> a */
 
 DEF(      to_object, 1, 1, 1, none)
 //DEF(      to_string, 1, 1, 1, none)
@@ -210,6 +208,7 @@
 DEF(iterator_check_object, 1, 1, 1, none)
 DEF(iterator_get_value_done, 1, 1, 2, none)
 DEF( iterator_close, 1, 3, 0, none)
+DEF(iterator_close_return, 1, 4, 4, none)
 DEF(  iterator_next, 1, 4, 4, none)
 DEF(  iterator_call, 2, 4, 5, u8)
 DEF(  initial_yield, 1, 0, 0, none)
@@ -257,7 +256,6 @@
 DEF(            xor, 1, 2, 1, none)
 DEF(             or, 1, 2, 1, none)
 DEF(is_undefined_or_null, 1, 1, 1, none)
-DEF(     private_in, 1, 2, 1, none)
 #ifdef CONFIG_BIGNUM
 DEF(      mul_pow10, 1, 2, 1, none)
 DEF(       math_mod, 1, 2, 1, none)
@@ -272,8 +270,6 @@
 
 def(          label, 5, 0, 0, label) /* emitted in phase 1, removed in phase 3 */
 
-/* the following opcodes must be in the same order as the 'with_x' and
-   get_var_undef, get_var and put_var opcodes */
 def(scope_get_var_undef, 7, 0, 1, atom_u16) /* emitted in phase 1, removed in phase 2 */
 def(  scope_get_var, 7, 0, 1, atom_u16) /* emitted in phase 1, removed in phase 2 */
 def(  scope_put_var, 7, 1, 0, atom_u16) /* emitted in phase 1, removed in phase 2 */
@@ -281,13 +277,10 @@
 def( scope_make_ref, 11, 0, 2, atom_label_u16) /* emitted in phase 1, removed in phase 2 */
 def(  scope_get_ref, 7, 0, 2, atom_u16) /* emitted in phase 1, removed in phase 2 */
 def(scope_put_var_init, 7, 0, 2, atom_u16) /* emitted in phase 1, removed in phase 2 */
-def(scope_get_var_checkthis, 7, 0, 1, atom_u16) /* emitted in phase 1, removed in phase 2, only used to return 'this' in derived class constructors */
 def(scope_get_private_field, 7, 1, 1, atom_u16) /* obj -> value, emitted in phase 1, removed in phase 2 */
 def(scope_get_private_field2, 7, 1, 2, atom_u16) /* obj -> obj value, emitted in phase 1, removed in phase 2 */
-def(scope_put_private_field, 7, 2, 0, atom_u16) /* obj value ->, emitted in phase 1, removed in phase 2 */
-def(scope_in_private_field, 7, 1, 1, atom_u16) /* obj -> res emitted in phase 1, removed in phase 2 */
-def(get_field_opt_chain, 5, 1, 1, atom) /* emitted in phase 1, removed in phase 2 */
-def(get_array_el_opt_chain, 1, 2, 1, none) /* emitted in phase 1, removed in phase 2 */
+def(scope_put_private_field, 7, 1, 1, atom_u16) /* obj value ->, emitted in phase 1, removed in phase 2 */
+
 def( set_class_name, 5, 1, 1, u32) /* emitted in phase 1, removed in phase 2 */
 
 def(       line_num, 5, 0, 0, u32) /* emitted in phase 1, removed in phase 3 */
Index: arrow-src/arrow/cpp/src/arrow/vendored/uriparser/UriBase.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/arrow-src/arrow/cpp/src/arrow/vendored/uriparser/UriBase.h b/arrow-src/arrow/cpp/src/arrow/vendored/uriparser/UriBase.h
--- a/arrow-src/arrow/cpp/src/arrow/vendored/uriparser/UriBase.h	(revision 6a28035c2b49b432dc63f5ee7524d76b4ed2d762)
+++ b/arrow-src/arrow/cpp/src/arrow/vendored/uriparser/UriBase.h	(date 1714440647086)
@@ -96,27 +96,10 @@
 #endif
 
 
+#include <arrow_export.h>
 
 /* Import/export decorator */
-#if defined(URI_STATIC_BUILD)
-# define URI_PUBLIC
-#else
-# if defined(URI_LIBRARY_BUILD)
-#  if defined(_MSC_VER)
-#   define URI_PUBLIC __declspec(dllexport)
-#  elif defined(URI_VISIBILITY)
-#   define URI_PUBLIC __attribute__ ((visibility("default")))
-#  else
-#   define URI_PUBLIC
-#  endif
-# else
-#  if defined(_MSC_VER)
-#   define URI_PUBLIC __declspec(dllimport)
-#  else
-#   define URI_PUBLIC
-#  endif
-# endif
-#endif
+#define URI_PUBLIC ARROW_EXPORT
 
 
 
Index: openbabel-src/openbabel/include/openbabel/obutil.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/obutil.h b/openbabel-src/openbabel/include/openbabel/obutil.h
--- a/openbabel-src/openbabel/include/openbabel/obutil.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/obutil.h	(date 1714440647086)
@@ -24,6 +24,7 @@
 
 #include <string>
 #include <iosfwd>
+#include <fstream>
 
 #if TIME_WITH_SYS_TIME
 #include <sys/time.h>
Index: yaehmop-src/yaehmop/tightbind/cboris.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/yaehmop-src/yaehmop/tightbind/cboris.c b/yaehmop-src/yaehmop/tightbind/cboris.c
--- a/yaehmop-src/yaehmop/tightbind/cboris.c	(revision 7a4919752a60a7d096c83c3d2112a38c41e0f0ac)
+++ b/yaehmop-src/yaehmop/tightbind/cboris.c	(date 1714440647086)
@@ -2,7 +2,7 @@
 Produced by gmFortran V30.59(10/26/17) on 9/18/18 at 9:02:32
 */
 #define LPROTOTYPE
-#include "fortran.h"
+#include <math.h>
 void cboris(int *n,int *nd,double *a,double *b,double *c,double *d,double *e,
     double *f,int *fail)
 {
Index: svgpp-src/svgpp/include/svgpp/parser/number.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/parser/number.hpp b/svgpp-src/svgpp/include/svgpp/parser/number.hpp
--- a/svgpp-src/svgpp/include/svgpp/parser/number.hpp	(revision 5f1870aa7b757718ff5f86bdfb55966fa4f217f9)
+++ b/svgpp-src/svgpp/include/svgpp/parser/number.hpp	(date 1714440647086)
@@ -105,7 +105,7 @@
           number [phx::ref(value1) = _1] 
           >> -(
               comma_wsp 
-              >> number [phx::ref(value2) = _1, phx::ref(two_values) = true]
+              >> number [(phx::ref(value2) = _1, phx::ref(two_values) = true)]
               )
       ) && it == end)
     {
Index: eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h b/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h
--- a/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	(revision 3147391d946bb4b6c68edd901f2add6ac1f31f8c)
+++ b/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	(date 1714440647086)
@@ -207,7 +207,11 @@
     // block_count leaves that do actual computations.
     Barrier barrier(static_cast<unsigned int>(block.count));
     std::function<void(Index, Index)> handleRange;
+#if __cplusplus >= 202002L
+    handleRange = [=, &handleRange, &barrier, &f, this](Index firstIdx,
+#else
     handleRange = [=, &handleRange, &barrier, &f](Index firstIdx,
+#endif
                                                   Index lastIdx) {
       while (lastIdx - firstIdx > block.size) {
         // Split into halves and schedule the second half on a different thread.
Index: rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/MolDraw2DQt.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/MolDraw2DQt.h b/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/MolDraw2DQt.h
--- a/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/MolDraw2DQt.h	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/MolDraw2DQt.h	(date 1714440647086)
@@ -10,10 +10,10 @@
 // This is a concrete class derived from MolDraw2D that uses RDKit to draw a
 // molecule into a QPainter.
 
-#include <RDGeneral/export.h>
 #ifndef MOLDRAW2DQT_H
 #define MOLDRAW2DQT_H
-
+#include <RDGeneral/export.h>
+#include <MolDraw2DQt/rdkit_export.hpp>
 #include <GraphMol/MolDraw2D/MolDraw2D.h>
 
 class QPainter;
Index: rdkit-src/rdkit/Code/ForceField/UFF/Params.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/ForceField/UFF/Params.cpp b/rdkit-src/rdkit/Code/ForceField/UFF/Params.cpp
--- a/rdkit-src/rdkit/Code/ForceField/UFF/Params.cpp	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Code/ForceField/UFF/Params.cpp	(date 1714440647086)
@@ -7,7 +7,7 @@
 //  which is included in the file license.txt, found at the root
 //  of the RDKit source tree.
 //
-#ifdef WIN32
+#if defined(WIN32) && !defined(_USE_MATH_DEFINES)
 #define _USE_MATH_DEFINES
 #endif
 #include <cmath>
Index: openbabel-src/openbabel/include/openbabel/inchiformat.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/inchiformat.h b/openbabel-src/openbabel/include/openbabel/inchiformat.h
--- a/openbabel-src/openbabel/include/openbabel/inchiformat.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/inchiformat.h	(date 1714440647086)
@@ -131,7 +131,6 @@
   // and "CH4" is less than "C2H6"
   // and "CH4" is less than "ClH" (hydrogen chloride)
   struct InchiLess
-    : public std::binary_function<const std::string&, const std::string&, bool>
   {
     bool operator()(const std::string& s1, const std::string& s2) const
     {
@@ -146,12 +145,14 @@
           {
             n1 = atoi(&*p1);
             //skip over number
-            while(p1!=s1.end() && isdigit(*p1++)); --p1;
+            while(p1!=s1.end() && isdigit(*p1++)) {}
+            --p1;
           }
         if(isdigit(*p2))
           {
             n2 = atoi(&*p2);
-            while(p2!=s2.end() && isdigit(*p2++)); --p2;
+            while(p2!=s2.end() && isdigit(*p2++)) {}
+            --p2;
           }
         if(n1<0 && n2 < 0)
           {
Index: inchi-src/inchi/INCHI_BASE/src/ichicomp.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_BASE/src/ichicomp.h b/inchi-src/inchi/INCHI_BASE/src/ichicomp.h
--- a/inchi-src/inchi/INCHI_BASE/src/ichicomp.h	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_BASE/src/ichicomp.h	(date 1714440647090)
@@ -54,9 +54,6 @@
 
 /*  ANSI redefinitions */
 #ifdef COMPILE_ANSI_ONLY  /* { */
-#ifndef __isascii
-#define __isascii(val)  ((unsigned)(val) <= 0x7F)
-#endif
 
 /* #ifndef __GNUC__ */
 /* these non-ANSI functions are implemented in gcc */
Index: inchi-src/inchi/INCHI_BASE/src/ichiparm.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_BASE/src/ichiparm.c b/inchi-src/inchi/INCHI_BASE/src/ichiparm.c
--- a/inchi-src/inchi/INCHI_BASE/src/ichiparm.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_BASE/src/ichiparm.c	(date 1714440647090)
@@ -586,7 +586,7 @@
     int bHashKey            = 0;
     int bHashXtra1          = 0;
     int bHashXtra2          = 0;
-    int bLargeMolecules     = 0;
+    int bLargeMolecules     = 1;
     int bPolymers           = POLYMERS_NO;
 #ifdef TARGET_LIB_FOR_WINCHI
     int bFoldPolymerSRU     = 0;
Index: rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/DrawTextQt.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/DrawTextQt.h b/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/DrawTextQt.h
--- a/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/DrawTextQt.h	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/DrawTextQt.h	(date 1714440647090)
@@ -11,6 +11,7 @@
 #define RDKIT_DRAWTEXTQT_H
 
 #include <RDGeneral/export.h>
+#include <MolDraw2DQt/rdkit_export.hpp>
 #include <GraphMol/MolDraw2D/DrawTextNotFT.h>
 
 class QPainter;
Index: freesasa-src/freesasa/src/xml.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/freesasa-src/freesasa/src/xml.c b/freesasa-src/freesasa/src/xml.c
--- a/freesasa-src/freesasa/src/xml.c	(revision aa3c67d174049c0103d39a2a97b4a3a931d55243)
+++ b/freesasa-src/freesasa/src/xml.c	(date 1714440647090)
@@ -3,6 +3,7 @@
 #endif
 #include <assert.h>
 #include <errno.h>
+#include <libxml/parser.h>
 #include <libxml/tree.h>
 #include <libxml/xmlwriter.h>
 #include <stdlib.h>
Index: rdkit-src/rdkit/Code/ForceField/MMFF/Params.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/ForceField/MMFF/Params.cpp b/rdkit-src/rdkit/Code/ForceField/MMFF/Params.cpp
--- a/rdkit-src/rdkit/Code/ForceField/MMFF/Params.cpp	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Code/ForceField/MMFF/Params.cpp	(date 1714440647090)
@@ -10,7 +10,7 @@
 //  which is included in the file license.txt, found at the root
 //  of the RDKit source tree.
 //
-#ifdef WIN32
+#if defined(WIN32) && !defined(_USE_MATH_DEFINES)
 #define _USE_MATH_DEFINES
 #endif
 #include <cmath>
Index: arrow-src/arrow/cpp/src/arrow/util/io_util.cc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/arrow-src/arrow/cpp/src/arrow/util/io_util.cc b/arrow-src/arrow/cpp/src/arrow/util/io_util.cc
--- a/arrow-src/arrow/cpp/src/arrow/util/io_util.cc	(revision 6a28035c2b49b432dc63f5ee7524d76b4ed2d762)
+++ b/arrow-src/arrow/cpp/src/arrow/util/io_util.cc	(date 1714463789047)
@@ -118,10 +118,12 @@
 #endif
 
 #ifdef _WIN32
-#include <Windows.h>
+#include <windows.h>
 #else
+#if 0
 #include <dlfcn.h>
 #endif
+#endif
 
 namespace arrow::internal {
 
@@ -2229,6 +2231,7 @@
   ARROW_ASSIGN_OR_RAISE(auto platform_path, PlatformFilename::FromString(path));
   return LoadDynamicLibrary(platform_path);
 #else
+#if 0
   constexpr int kFlags =
       // All undefined symbols in the shared object are resolved before dlopen() returns.
       RTLD_NOW
@@ -2240,6 +2243,9 @@
   // There is no null-returning non-error condition.
   auto* error = dlerror();
   return Status::IOError("dlopen(", path, ") failed: ", error ? error : "unknown error");
+#else
+    return Status::IOError("Not Implemented");
+#endif
 #endif
 }
 
@@ -2270,11 +2276,15 @@
   // There is no null-returning non-error condition.
   return IOErrorFromWinError(GetLastError(), "GetProcAddress(", name, ") failed.");
 #else
+#if 0
   if (void* sym = dlsym(handle, name)) return sym;
   // dlsym(3) man page: "On failure, they return NULL"
   // There is no null-returning non-error condition.
   auto* error = dlerror();
   return Status::IOError("dlsym(", name, ") failed: ", error ? error : "unknown error");
+#else
+    return Status::IOError("Not Implemented");
+#endif
 #endif
 }
 
Index: rdkit-src/rdkit/External/GA/ga/GaBase.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/External/GA/ga/GaBase.h b/rdkit-src/rdkit/External/GA/ga/GaBase.h
--- a/rdkit-src/rdkit/External/GA/ga/GaBase.h	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/External/GA/ga/GaBase.h	(date 1714440647090)
@@ -34,8 +34,8 @@
   GaBase& operator=(const GaBase& other) = delete;
 
  public:
-  GaBase(){};
-  virtual ~GaBase(){};
+  GaBase();
+  virtual ~GaBase();
 
   double getSelectionPressure() const { return selectionPressure; }
 
Index: ncnn-src/ncnn/src/modelbin.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/src/modelbin.cpp b/ncnn-src/ncnn/src/modelbin.cpp
--- a/ncnn-src/ncnn/src/modelbin.cpp	(revision 56775de50990ab7f16627efdcf5529b49541206f)
+++ b/ncnn-src/ncnn/src/modelbin.cpp	(date 1714440647090)
@@ -92,7 +92,6 @@
 
 Mat ModelBinFromDataReader::load(int w, int type) const
 {
-    Mat m;
 
     if (type == 0)
     {
@@ -117,10 +116,6 @@
             return Mat();
         }
 
-#if __BIG_ENDIAN__
-        swap_endianness_32(&flag_struct.tag);
-#endif
-
         unsigned int flag = (int)flag_struct.f0 + flag_struct.f1 + flag_struct.f2 + flag_struct.f3;
 
         if (flag_struct.tag == 0x01306B47)
@@ -128,17 +123,6 @@
             // half-precision data
             size_t align_data_size = alignSize(w * sizeof(unsigned short), 4);
 
-#if !__BIG_ENDIAN__
-            // try reference data
-            const void* refbuf = 0;
-            nread = d->dr.reference(align_data_size, &refbuf);
-            if (nread == align_data_size)
-            {
-                m = Mat::from_float16((const unsigned short*)refbuf, w);
-            }
-            else
-#endif
-            {
                 std::vector<unsigned short> float16_weights;
                 float16_weights.resize(align_data_size);
                 nread = d->dr.read(&float16_weights[0], align_data_size);
@@ -148,34 +132,12 @@
                     return Mat();
                 }
 
-#if __BIG_ENDIAN__
-                for (int i = 0; i < w; i++)
-                {
-                    swap_endianness_16(&float16_weights[i]);
-                }
-#endif
-
-                m = Mat::from_float16(&float16_weights[0], w);
-            }
-
-            return m;
+                return Mat::from_float16(float16_weights.data(), w);
         }
         else if (flag_struct.tag == 0x000D4B38)
         {
             // int8 data
             size_t align_data_size = alignSize(w, 4);
-
-#if !__BIG_ENDIAN__
-            // try reference data
-            const void* refbuf = 0;
-            nread = d->dr.reference(align_data_size, &refbuf);
-            if (nread == align_data_size)
-            {
-                m = Mat(w, (void*)refbuf, (size_t)1u);
-            }
-            else
-#endif
-            {
                 std::vector<signed char> int8_weights;
                 int8_weights.resize(align_data_size);
                 nread = d->dr.read(&int8_weights[0], align_data_size);
@@ -185,29 +147,17 @@
                     return Mat();
                 }
 
-                m.create(w, (size_t)1u);
+                Mat m(w, (size_t)1u);
                 if (m.empty())
                     return m;
 
                 memcpy(m.data, &int8_weights[0], w);
-            }
 
             return m;
         }
         else if (flag_struct.tag == 0x0002C056)
         {
-#if !__BIG_ENDIAN__
-            // try reference data
-            const void* refbuf = 0;
-            nread = d->dr.reference(w * sizeof(float), &refbuf);
-            if (nread == w * sizeof(float))
-            {
-                m = Mat(w, (void*)refbuf);
-            }
-            else
-#endif
-            {
-                m.create(w);
+            Mat m(w);
                 if (m.empty())
                     return m;
 
@@ -219,23 +169,13 @@
                     return Mat();
                 }
 
-#if __BIG_ENDIAN__
-                for (int i = 0; i < w; i++)
-                {
-                    swap_endianness_32((float*)m + i);
-                }
-#endif
-            }
-
             return m;
         }
-
-        if (flag != 0)
-        {
-            m.create(w);
+        Mat m(w);
             if (m.empty())
                 return m;
-
+        if (flag != 0)
+        {
             // quantized data
             float quantization_value[256];
             nread = d->dr.read(quantization_value, 256 * sizeof(float));
@@ -245,13 +185,6 @@
                 return Mat();
             }
 
-#if __BIG_ENDIAN__
-            for (int i = 0; i < 256; i++)
-            {
-                swap_endianness_32(&quantization_value[i]);
-            }
-#endif
-
             size_t align_weight_data_size = alignSize(w * sizeof(unsigned char), 4);
             std::vector<unsigned char> index_array;
             index_array.resize(align_weight_data_size);
@@ -270,21 +203,6 @@
         }
         else if (flag_struct.f0 == 0)
         {
-#if !__BIG_ENDIAN__
-            // try reference data
-            const void* refbuf = 0;
-            nread = d->dr.reference(w * sizeof(float), &refbuf);
-            if (nread == w * sizeof(float))
-            {
-                m = Mat(w, (void*)refbuf);
-            }
-            else
-#endif
-            {
-                m.create(w);
-                if (m.empty())
-                    return m;
-
                 // raw data
                 nread = d->dr.read(m, w * sizeof(float));
                 if (nread != w * sizeof(float))
@@ -292,32 +210,12 @@
                     NCNN_LOGE("ModelBin read weight_data failed %zd", nread);
                     return Mat();
                 }
-
-#if __BIG_ENDIAN__
-                for (int i = 0; i < w; i++)
-                {
-                    swap_endianness_32((float*)m + i);
-                }
-#endif
             }
-        }
-
         return m;
     }
     else if (type == 1)
     {
-#if !__BIG_ENDIAN__
-        // try reference data
-        const void* refbuf = 0;
-        size_t nread = d->dr.reference(w * sizeof(float), &refbuf);
-        if (nread == w * sizeof(float))
-        {
-            m = Mat(w, (void*)refbuf);
-        }
-        else
-#endif
-        {
-            m.create(w);
+            Mat m(w);
             if (m.empty())
                 return m;
 
@@ -328,15 +226,6 @@
                 NCNN_LOGE("ModelBin read weight_data failed %zd", nread);
                 return Mat();
             }
-
-#if __BIG_ENDIAN__
-            for (int i = 0; i < w; i++)
-            {
-                swap_endianness_32((float*)m + i);
-            }
-#endif
-        }
-
         return m;
     }
     else
Index: openbabel-src/openbabel/include/openbabel/plugin.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/plugin.h b/openbabel-src/openbabel/include/openbabel/plugin.h
--- a/openbabel-src/openbabel/include/openbabel/plugin.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/plugin.h	(date 1714440647090)
@@ -20,7 +20,6 @@
 #define OB_PLUGIN_H
 
 #include <openbabel/babelconfig.h>
-#include <openbabel/dlhandler.h>
 #include <string>
 #include <iostream>
 #include <vector>
@@ -38,7 +37,7 @@
 ///@{
 
 /// @brief Case insensitive string comparison for PluginMapType key.
-struct OBERROR CharPtrLess : public std::binary_function<const char*,const char*, bool>
+struct OBERROR CharPtrLess
 {
   bool operator()(const char* p1,const char* p2) const
   { return strcasecmp(p1,p2)<0; }
@@ -150,53 +149,13 @@
   const char* _id;
 };
 
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-
 //Macro to be added to definition of the base class
 #define MAKE_PLUGIN(BaseClass)\
-protected:\
-  static PluginMapType& Map();\
-  virtual PluginMapType& GetMap() const {\
-    return Map();\
-  }\
-public:\
-  static BaseClass*& Default() {\
-    static BaseClass* d;\
-    return d;\
-  }\
-  BaseClass(const char* ID, bool IsDefault=false) {\
-    _id=ID;\
-    if (ID&&*ID) {\
-      if (IsDefault || Map().empty()) {\
-        Default() = this;\
-      }\
-      if (Map().count(ID) == 0) {\
-        Map()[ID] = this;\
-        PluginMap()[TypeID()] = this;\
-      }\
-    }\
-  }\
-  static BaseClass* FindType(const char* ID) {\
-    if (!ID || *ID==0 || *ID==' ') {\
-      return Default();\
-    }\
-    return static_cast<BaseClass*>(BaseFindType(Map(),ID));\
-  }
-
-#define PLUGIN_CPP_FILE(BaseClass)\
-OBPlugin::PluginMapType& BaseClass::Map() {\
-  static OBPlugin::PluginMapType map;\
-  return map;\
-}
-
-#else // __CYGWIN__ || __MINGW32__
-
-//Macro to be added to definition of the base class
-#define MAKE_PLUGIN(BaseClass)\
+private:\
+   inline static PluginMapType mPluginMapHolder;\
 protected:\
   static PluginMapType& Map() {\
-    static PluginMapType m;\
-    return m;\
+    return mPluginMapHolder;\
   }\
   virtual PluginMapType& GetMap() const {\
     return Map();\
@@ -223,9 +182,8 @@
       return Default();\
     }\
     return static_cast<BaseClass*>(BaseFindType(Map(),ID));\
-  }
-
-#endif // __CYGWIN__ || __MINGW32__
+  }\
+  private:
 
 /** \file plugin.h
    \brief Simplify 'plugin' classes to be discovered and/or loaded at runtime.
@@ -371,7 +329,7 @@
 
 #define OB_STATIC_PLUGIN(className,instanceName) \
   class className; \
-  OBAPI OB_EXTERN className instanceName;
+  OB_EXTERN className instanceName;
 
   // formats
   OB_STATIC_PLUGIN(ABINITFormat, theABINITFormat)
@@ -430,6 +388,8 @@
   OB_STATIC_PLUGIN(HINFormat, theHINFormat)
   OB_STATIC_PLUGIN(JaguarOutputFormat, theJaguarOutputFormat)
   OB_STATIC_PLUGIN(JaguarInputFormat, theJaguarInputFormat)
+  OB_STATIC_PLUGIN(ChemDoodleJSONFormat, theChemDoodleJSONFormat)
+  OB_STATIC_PLUGIN(PubChemJSONFormat, thePubChemJSONFormat)
   OB_STATIC_PLUGIN(LMPDATFormat, theLMPDATFormat)
   OB_STATIC_PLUGIN(MCDLFormat, theMCDLFormat)
   OB_STATIC_PLUGIN(MOLFormat, theMOLFormat)
@@ -463,6 +423,7 @@
   OB_STATIC_PLUGIN(PDBQTFormat, thePDBQTFormat)
 #ifdef HAVE_LIBZ
   OB_STATIC_PLUGIN(PNGFormat, thePNGFormat)
+  OB_STATIC_PLUGIN(PNG2Format, thePNG2Format)
 #endif
   OB_STATIC_PLUGIN(PointCloudFormat, thePointCloudFormat)
   OB_STATIC_PLUGIN(PovrayFormat, thePovrayFormat)
@@ -502,6 +463,8 @@
 #endif
 #ifdef HAVE_STATIC_INCHI
   OB_STATIC_PLUGIN(InChIFormat, theInChIFormat)
+  OB_STATIC_PLUGIN(InChICompareFormat, theInChICompareFormat)
+  OB_STATIC_PLUGIN(InChIKeyFormat, theInChIKeyFormat)
 #endif
 #ifdef HAVE_REGEX_H
   OB_STATIC_PLUGIN(GAMESSUKInputFormat, theGAMESSUKInputFormat)
@@ -560,6 +523,7 @@
   OB_STATIC_PLUGIN(OpFillUC, theOpFillUC)
   OB_STATIC_PLUGIN(OpEnergy, theOpEnergy)
   OB_STATIC_PLUGIN(OpMinimize, theOpMinimize)
+  OB_STATIC_PLUGIN(Op2D, theOp2D)
   OB_STATIC_PLUGIN(OpGen2D, theOpGen2D)
   OB_STATIC_PLUGIN(OpGen3D, theOpGen3D)
   OB_STATIC_PLUGIN(OpNewS, theOpNewS)
Index: skia-src/skia/src/core/SkDistanceFieldGen.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/src/core/SkDistanceFieldGen.cpp b/skia-src/skia/src/core/SkDistanceFieldGen.cpp
--- a/skia-src/skia/src/core/SkDistanceFieldGen.cpp	(revision 3d4e45907f9b239a54957001d619d2d4a6ca06b4)
+++ b/skia-src/skia/src/core/SkDistanceFieldGen.cpp	(date 1714440647090)
@@ -23,6 +23,7 @@
 using namespace skia_private;
 
 #if !defined(SK_DISABLE_SDF_TEXT)
+namespace {
 
 struct DFData {
     float   fAlpha;      // alpha value of source texel
@@ -30,6 +31,7 @@
     SkPoint fDistVector; // distance vector to nearest (so far) edge texel
 };
 
+}
 enum NeighborFlags {
     kLeft_NeighborFlag        = 0x01,
     kRight_NeighborFlag       = 0x02,
Index: rdkit-src/rdkit/External/GA/util/Util.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/External/GA/util/Util.cpp b/rdkit-src/rdkit/External/GA/util/Util.cpp
--- a/rdkit-src/rdkit/External/GA/util/Util.cpp	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/External/GA/util/Util.cpp	(date 1714440647090)
@@ -40,18 +40,7 @@
 }
 
 string getUserName() {
-#ifdef WIN32
-  return "UNKNOWN";
-#else
-  const int bufsize = 100;
-  char buffer[bufsize];
-
-  if (!getlogin_r(buffer, bufsize)) {
-    return string(buffer);
-  } else {
-    return string("");
-  }
-#endif
+    return "UNKNOWN";
 }
 
 string &removeTrailingLF(string &line) {
Index: svgpp-src/svgpp/include/svgpp/parser/external_function/parse_paint_impl.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/parser/external_function/parse_paint_impl.hpp b/svgpp-src/svgpp/include/svgpp/parser/external_function/parse_paint_impl.hpp
--- a/svgpp-src/svgpp/include/svgpp/parser/external_function/parse_paint_impl.hpp	(revision 5f1870aa7b757718ff5f86bdfb55966fa4f217f9)
+++ b/svgpp-src/svgpp/include/svgpp/parser/external_function/parse_paint_impl.hpp	(date 1714440647090)
@@ -51,13 +51,13 @@
       | qi::lit("currentColor")   [phx::ref(out_main_option) = paint_option_currentColor]
       | qi::lit("inherit")        [phx::ref(out_main_option) = paint_option_inherit]
       | color_optional_icc_color(boost::phoenix::ref(icc_color_factory))  
-          [phx::ref(out_color) = qi::_1, phx::ref(out_main_option) = paint_option_color]
+          [(phx::ref(out_color) = qi::_1, phx::ref(out_main_option) = paint_option_color)]
       | ( funciri_rule [phx::ref(out_iri) = qi::_1]
           >> - ( +space
                   >> ( qi::lit("none")          [phx::ref(out_funciri_suboption) = paint_option_none]
                       | qi::lit("currentColor")  [phx::ref(out_funciri_suboption) = paint_option_currentColor]
                       | color_optional_icc_color(boost::phoenix::ref(icc_color_factory)) 
-                        [phx::ref(out_color) = qi::_1, phx::ref(out_funciri_suboption) = paint_option_color]
+                        [(phx::ref(out_color) = qi::_1, phx::ref(out_funciri_suboption) = paint_option_color)]
                       )
                 )
         ) [phx::ref(out_main_option) = paint_option_funciri]
Index: thrift-src/thrift/lib/cpp/src/thrift/transport/THttpServer.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/thrift-src/thrift/lib/cpp/src/thrift/transport/THttpServer.cpp b/thrift-src/thrift/lib/cpp/src/thrift/transport/THttpServer.cpp
--- a/thrift-src/thrift/lib/cpp/src/thrift/transport/THttpServer.cpp	(revision 0d0ac75347267f7c12fc9b5b349bf9ef7f632347)
+++ b/thrift-src/thrift/lib/cpp/src/thrift/transport/THttpServer.cpp	(date 1714440647090)
@@ -25,7 +25,7 @@
 #include <thrift/transport/THttpServer.h>
 #include <thrift/transport/TSocket.h>
 #if defined(_MSC_VER) || defined(__MINGW32__)
-  #include <Shlwapi.h>
+  #include <shlwapi.h>
 #endif
 
 using std::string;
Index: rdkit-src/rdkit/External/GA/util/export.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/External/GA/util/export.h b/rdkit-src/rdkit/External/GA/util/export.h
--- a/rdkit-src/rdkit/External/GA/util/export.h	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/External/GA/util/export.h	(date 1714440647090)
@@ -10,6 +10,6 @@
 
 #pragma once
 
-#include <RDGeneral/RDExportMacros.h>
+#include <RDGeneral/export.h>
 
-#define GA_EXPORT RDKIT_EXPORT_API
+#define GA_EXPORT RDKIT_GA_EXPORT
Index: openbabel-src/openbabel/include/openbabel/typer.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/typer.h b/openbabel-src/openbabel/include/openbabel/typer.h
--- a/openbabel-src/openbabel/include/openbabel/typer.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/typer.h	(date 1714440647090)
@@ -67,7 +67,7 @@
 #endif
 //! Global OBAtomTyper for marking internal valence, hybridization,
 //!  and atom types (for internal and external use)
-THREAD_LOCAL OB_EXTERN OBAtomTyper      atomtyper;
+THREAD_LOCAL extern OBAtomTyper      atomtyper;
 
 // class introduction in typer.cpp
 class OBAPI OBAromaticTyper
@@ -81,7 +81,7 @@
 };
 
 //! Global OBAromaticTyper for detecting aromatic atoms and bonds
-THREAD_LOCAL OB_EXTERN OBAromaticTyper  aromtyper;
+THREAD_LOCAL extern OBAromaticTyper  aromtyper;
 
 // class introduction in typer.cpp
 class OBAPI OBRingTyper : public OBGlobalDataBase
Index: openbabel-src/openbabel/include/openbabel/obmolecformat.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/obmolecformat.h b/openbabel-src/openbabel/include/openbabel/obmolecformat.h
--- a/openbabel-src/openbabel/include/openbabel/obmolecformat.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/obmolecformat.h	(date 1714440647090)
@@ -142,7 +142,7 @@
 #endif
 
 #ifdef _MSC_VER
-  typedef std::tr1::unordered_map<std::string, unsigned> NameIndexType;
+  typedef std::unordered_map<std::string, unsigned> NameIndexType;
 #elif defined(_LIBCPP_VERSION)
   typedef std::unordered_map<std::string, unsigned> NameIndexType;
 #elif (__GNUC__ == 4 && __GNUC_MINOR__ >= 1 && !defined(__APPLE_CC__)) || defined (USE_BOOST)
Index: ncnn-src/ncnn/src/datareader.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/src/datareader.cpp b/ncnn-src/ncnn/src/datareader.cpp
--- a/ncnn-src/ncnn/src/datareader.cpp	(revision 56775de50990ab7f16627efdcf5529b49541206f)
+++ b/ncnn-src/ncnn/src/datareader.cpp	(date 1714440647090)
@@ -38,11 +38,6 @@
     return 0;
 }
 
-size_t DataReader::reference(size_t /*size*/, const void** /*buf*/) const
-{
-    return 0;
-}
-
 #if NCNN_STDIO
 class DataReaderFromStdioPrivate
 {
@@ -141,13 +136,6 @@
     d->mem += size;
     return size;
 }
-
-size_t DataReaderFromMemory::reference(size_t size, const void** buf) const
-{
-    *buf = d->mem;
-    d->mem += size;
-    return size;
-}
 
 #if NCNN_PLATFORM_API
 #if __ANDROID_API__ >= 9
Index: openbabel-src/openbabel/include/openbabel/tokenst.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/tokenst.h b/openbabel-src/openbabel/include/openbabel/tokenst.h
--- a/openbabel-src/openbabel/include/openbabel/tokenst.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/tokenst.h	(date 1714440647090)
@@ -25,7 +25,6 @@
 #include <vector>
 #include <sstream>
 #include <string>
-#include <fstream>
 
 namespace OpenBabel
 {
@@ -56,7 +55,7 @@
 
   //! Opens a datafile in a directory where OpenBabel expects to find it.
   // full documentation in tokenst.cpp
-  OBERROR std::string OpenDatafile(std::ifstream& fs,
+  OBERROR std::string OpenDatafile(std::istringstream& iss,
                                  const std::string& filename,
                                  const std::string& envvar = "BABEL_DATADIR");
 
Index: inchi-src/inchi/INCHI_BASE/src/runichi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_BASE/src/runichi.c b/inchi-src/inchi/INCHI_BASE/src/runichi.c
--- a/inchi-src/inchi/INCHI_BASE/src/runichi.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_BASE/src/runichi.c	(date 1714440647090)
@@ -3083,7 +3083,9 @@
         (i.e., delete a whole connected component(s) comprising original atoms)
         */
         int natnums = 0;
-        atnums = (int *)inchi_calloc(max_atoms, sizeof(int));
+        if (max_atoms > 0) {
+            atnums = (int *) inchi_calloc(max_atoms, sizeof(int));
+        }
         if (!atnums)
         {
             return _IS_ERROR;
Index: ncnn-src/ncnn/src/datareader.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/src/datareader.h b/ncnn-src/ncnn/src/datareader.h
--- a/ncnn-src/ncnn/src/datareader.h	(revision 56775de50990ab7f16627efdcf5529b49541206f)
+++ b/ncnn-src/ncnn/src/datareader.h	(date 1714440647090)
@@ -44,10 +44,6 @@
     // read binary param and model data
     // return bytes read
     virtual size_t read(void* buf, size_t size) const;
-
-    // get model data reference
-    // return bytes referenced
-    virtual size_t reference(size_t size, const void** buf) const;
 };
 
 #if NCNN_STDIO
@@ -83,7 +79,6 @@
     virtual int scan(const char* format, void* p) const;
 #endif // NCNN_STRING
     virtual size_t read(void* buf, size_t size) const;
-    virtual size_t reference(size_t size, const void** buf) const;
 
 private:
     DataReaderFromMemory(const DataReaderFromMemory&);
Index: inchi-src/inchi/INCHI_BASE/src/util.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_BASE/src/util.c b/inchi-src/inchi/INCHI_BASE/src/util.c
--- a/inchi-src/inchi/INCHI_BASE/src/util.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_BASE/src/util.c	(date 1714440647090)
@@ -38,10 +38,6 @@
 
 #include "mode.h"
 
-#if defined(COMPILE_ANSI_ONLY) && defined(__APPLE__)
-/*    For build under OSX, advice from Burt Leland */
-#include "ichicomp.h"    /* Needed for __isascii define */
-#endif
 
 #include "util.h"
 #include "extr_ct.h"
@@ -1741,13 +1737,13 @@
 
     if (p && ( len = (int) strlen( p ) ))
     {
-        for (i = 0; i < len && __isascii( p[i] ) && isspace( p[i] ); i++)
+        for (i = 0; i < len && isascii( p[i] ) && isspace( p[i] ); i++)
         {
             ;
         }
         if (i)
             (memmove) ( p, p + i, ( len -= i ) + 1 );
-        for (; 0 < len && __isascii( p[len - 1] ) && isspace( p[len - 1] ); len--)
+        for (; 0 < len && isascii( p[len - 1] ) && isspace( p[len - 1] ); len--)
         {
             ;
         }
Index: eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h b/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h
--- a/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	(revision 3147391d946bb4b6c68edd901f2add6ac1f31f8c)
+++ b/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	(date 1714440647090)
@@ -1006,7 +1006,11 @@
       } else {
         eigen_assert(!use_thread_local);
         device_.enqueueNoNotification(
+#if __cplusplus >= 202002L
+            [=, this]() { kernel(m, n, k, use_thread_local); });
+#else
             [=]() { kernel(m, n, k, use_thread_local); });
+#endif
       }
     }
 
@@ -1060,7 +1064,11 @@
         while (end - start > 1) {
           Index mid = (start + end) / 2;
           device_.enqueueNoNotification(
+#if __cplusplus >= 202002L
+              [=, this]() { enqueue_packing_helper(mid, end, k, rhs); });
+#else
               [=]() { enqueue_packing_helper(mid, end, k, rhs); });
+#endif
           end = mid;
         }
 
@@ -1079,7 +1087,11 @@
 
         if (pack_async) {
           device_.enqueueNoNotification(
+#if __cplusplus >= 202002L
+              [=, this]() { enqueue_packing_helper(start, end, k, rhs); });
+#else
               [=]() { enqueue_packing_helper(start, end, k, rhs); });
+#endif
         } else {
           enqueue_packing_helper(start, end, k, rhs);
         }
Index: ncnn-src/ncnn/src/gpu.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/src/gpu.h b/ncnn-src/ncnn/src/gpu.h
--- a/ncnn-src/ncnn/src/gpu.h	(revision 56775de50990ab7f16627efdcf5529b49541206f)
+++ b/ncnn-src/ncnn/src/gpu.h	(date 1714440647090)
@@ -316,7 +316,7 @@
     GpuInfo& operator=(const GpuInfo&);
 
 private:
-    friend int create_gpu_instance(const char* driver_path);
+    friend int NCNN_EXPORT create_gpu_instance(const char* driver_path);
     GpuInfoPrivate* const d;
 };
 
Index: openbabel-src/openbabel/include/openbabel/tree/tree.hh
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/tree/tree.hh b/openbabel-src/openbabel/include/openbabel/tree/tree.hh
--- a/openbabel-src/openbabel/include/openbabel/tree/tree.hh	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/tree/tree.hh	(date 1714440647090)
@@ -542,8 +542,8 @@
 template <class T, class tree_node_allocator>
 void tree<T, tree_node_allocator>::head_initialise_()
    {
-   head = alloc_.allocate(1,nullptr); // MSVC does not have default second argument
-	feet = alloc_.allocate(1,nullptr);
+   head = alloc_.allocate(1);
+   feet = alloc_.allocate(1);
 
    head->parent=nullptr;
    head->first_child=nullptr;
@@ -869,7 +869,7 @@
 	assert(position.node!=head);
 	assert(position.node);
 
-	tree_node *tmp=alloc_.allocate(1,0);
+	tree_node *tmp=alloc_.allocate(1);
 	kp::constructor(&tmp->data);
 	tmp->first_child=0;
 	tmp->last_child=0;
@@ -894,7 +894,7 @@
 	assert(position.node!=head);
 	assert(position.node);
 
-	tree_node *tmp=alloc_.allocate(1,0);
+	tree_node *tmp=alloc_.allocate(1);
 	kp::constructor(&tmp->data);
 	tmp->first_child=0;
 	tmp->last_child=0;
@@ -923,7 +923,7 @@
 	assert(position.node!=head);
 	assert(position.node);
 
-	tree_node* tmp = alloc_.allocate(1,nullptr);
+	tree_node* tmp = alloc_.allocate(1);
 	kp::constructor(&tmp->data, x);
 	tmp->first_child=nullptr;
 	tmp->last_child=nullptr;
@@ -948,7 +948,7 @@
 	assert(position.node!=head);
 	assert(position.node);
 
-	tree_node* tmp = alloc_.allocate(1,0);
+	tree_node* tmp = alloc_.allocate(1);
 	kp::constructor(&tmp->data, x);
 	tmp->first_child=0;
 	tmp->last_child=0;
@@ -1035,7 +1035,7 @@
 		position.node=feet; // Backward compatibility: when calling insert on a null node,
 		                    // insert before the feet.
 		}
-	tree_node* tmp = alloc_.allocate(1,nullptr);
+	tree_node* tmp = alloc_.allocate(1);
 	kp::constructor(&tmp->data, x);
 	tmp->first_child=nullptr;
 	tmp->last_child=nullptr;
@@ -1057,7 +1057,7 @@
 template <class T, class tree_node_allocator>
 typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::insert(sibling_iterator position, const T& x)
 	{
-	tree_node* tmp = alloc_.allocate(1,0);
+	tree_node* tmp = alloc_.allocate(1);
 	kp::constructor(&tmp->data, x);
 	tmp->first_child=0;
 	tmp->last_child=0;
@@ -1087,7 +1087,7 @@
 template <class iter>
 iter tree<T, tree_node_allocator>::insert_after(iter position, const T& x)
 	{
-	tree_node* tmp = alloc_.allocate(1,0);
+	tree_node* tmp = alloc_.allocate(1);
 	kp::constructor(&tmp->data, x);
 	tmp->first_child=0;
 	tmp->last_child=0;
@@ -1159,7 +1159,7 @@
 //	std::cout << "warning!" << position.node << std::endl;
 	erase_children(position);
 //	std::cout << "no warning!" << std::endl;
-	tree_node* tmp = alloc_.allocate(1,0);
+	tree_node* tmp = alloc_.allocate(1);
 	kp::constructor(&tmp->data, (*from));
 	tmp->first_child=0;
 	tmp->last_child=0;
Index: inchi-src/inchi/INCHI_BASE/src/inchi_api.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_BASE/src/inchi_api.h b/inchi-src/inchi/INCHI_BASE/src/inchi_api.h
--- a/inchi-src/inchi/INCHI_BASE/src/inchi_api.h	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_BASE/src/inchi_api.h	(date 1714440647090)
@@ -681,23 +681,17 @@
  *************************************************/
 
 
-#if (defined( _WIN32 ) && defined( _MSC_VER ) && defined(BUILD_LINK_AS_DLL) )
-    /* Win32 & MS VC ++, compile and link as a DLL */
-#ifdef _USRDLL
-    /* InChI library dll */
-#define INCHI_API __declspec(dllexport)
-#define EXPIMP_TEMPLATE
-#define INCHI_DECL
-#else
-   /* calling the InChI dll program */
-#define INCHI_API __declspec(dllimport)
+#include "inchi_export.h"
+
+#ifdef _MSC_VER
 #define EXPIMP_TEMPLATE extern
-#define INCHI_DECL
-#endif
 #else
-    /* create a statically linked InChI library or link to an executable */
-#define INCHI_API
 #define EXPIMP_TEMPLATE
+#endif
+#ifndef INCHI_API
+#define INCHI_API INCHI_EXPORT
+#endif
+#ifndef INCHI_DECL
 #define INCHI_DECL
 #endif
 
Index: inchi-src/inchi/INCHI_BASE/src/ichicano.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_BASE/src/ichicano.c b/inchi-src/inchi/INCHI_BASE/src/ichicano.c
--- a/inchi-src/inchi/INCHI_BASE/src/ichicano.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_BASE/src/ichicano.c	(date 1714440647090)
@@ -37,7 +37,6 @@
 #include <string.h>
 #include <ctype.h>
 #include <time.h>
-#include <sys/timeb.h>
 
 #include "mode.h"
 #include "ichicano.h"
Index: boost-src/boost/libs/numeric/odeint/examples/stepper_details.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/numeric/odeint/examples/stepper_details.cpp b/boost-src/boost/libs/numeric/odeint/examples/stepper_details.cpp
--- a/boost-src/boost/libs/numeric/odeint/examples/stepper_details.cpp	(revision 1f4e47dfb395461a5c00d23b3728062f8290dfe6)
+++ b/boost-src/boost/libs/numeric/odeint/examples/stepper_details.cpp	(date 1714440647090)
@@ -129,6 +129,7 @@
 
         //[ symplectic_stepper_detail_system_class_example
         harm_osc h;
+        using namespace std::placeholders;
         rkn.do_step( make_pair( detail::bind( &harm_osc::f1 , h , _1 , _2 ) , detail::bind( &harm_osc::f2 , h , _1 , _2 ) ) ,
                 x , t , dt );
         //]
Index: openbabel-src/openbabel/include/openbabel/math/matrix3x3.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/math/matrix3x3.h b/openbabel-src/openbabel/include/openbabel/math/matrix3x3.h
--- a/openbabel-src/openbabel/include/openbabel/math/matrix3x3.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/math/matrix3x3.h	(date 1714440647090)
@@ -281,7 +281,7 @@
       friend OBAPI std::ostream& operator<< ( std::ostream&, const matrix3x3 & ) ;
 
       //! Eigenvalue calculation
-      static void jacobi(unsigned int n, double *a, double *d, double *v);
+      static void jacobi(int n, double *a, double *d, double *v);
     };
 
 #ifndef SWIG
Index: skia-src/skia/src/gpu/ganesh/glsl/GrGLSLShaderBuilder.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/src/gpu/ganesh/glsl/GrGLSLShaderBuilder.cpp b/skia-src/skia/src/gpu/ganesh/glsl/GrGLSLShaderBuilder.cpp
--- a/skia-src/skia/src/gpu/ganesh/glsl/GrGLSLShaderBuilder.cpp	(revision 3d4e45907f9b239a54957001d619d2d4a6ca06b4)
+++ b/skia-src/skia/src/gpu/ganesh/glsl/GrGLSLShaderBuilder.cpp	(date 1714440647090)
@@ -150,7 +150,7 @@
     // function, one for the (inverse) destination transfer function, and one for the gamut xform.
     // Any combination of these may be present, although some configurations are much more likely.
 
-    auto emitTFFunc = [=](const char* name, GrGLSLProgramDataManager::UniformHandle uniform,
+    auto emitTFFunc = [=, this](const char* name, GrGLSLProgramDataManager::UniformHandle uniform,
                           skcms_TFType tfType) {
         const GrShaderVar gTFArgs[] = { GrShaderVar("x", SkSLType::kFloat) };
         const char* coeffs = uniformHandler->getUniformCStr(uniform);
Index: arrow-src/arrow/cpp/src/arrow/util/macros.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/arrow-src/arrow/cpp/src/arrow/util/macros.h b/arrow-src/arrow/cpp/src/arrow/util/macros.h
--- a/arrow-src/arrow/cpp/src/arrow/util/macros.h	(revision 6a28035c2b49b432dc63f5ee7524d76b4ed2d762)
+++ b/arrow-src/arrow/cpp/src/arrow/util/macros.h	(date 1714440647090)
@@ -91,6 +91,7 @@
 // clang-format off
 // [[deprecated]] is only available in C++14, use this for the time being
 // This macro takes an optional deprecation message
+#undef ARROW_DEPRECATED
 #ifdef __COVERITY__
 #  define ARROW_DEPRECATED(...)
 #else
Index: thrift-src/thrift/lib/cpp/src/thrift/thrift_export.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/thrift-src/thrift/lib/cpp/src/thrift/thrift_export.h b/thrift-src/thrift/lib/cpp/src/thrift/thrift_export.h
--- a/thrift-src/thrift/lib/cpp/src/thrift/thrift_export.h	(revision 0d0ac75347267f7c12fc9b5b349bf9ef7f632347)
+++ b/thrift-src/thrift/lib/cpp/src/thrift/thrift_export.h	(date 1714440647090)
@@ -1,20 +1,3 @@
-#ifndef THRIFT_EXPORT_H
-#define THRIFT_EXPORT_H
+#pragma once
 
-#ifdef THRIFT_STATIC_DEFINE
-#  define THRIFT_EXPORT
-#elif defined(_MSC_VER )
-#  ifndef THRIFT_EXPORT
-#    ifdef thrift_EXPORTS
-          /* We are building this library */
-#      define THRIFT_EXPORT __declspec(dllexport)
-#    else
-          /* We are using this library */
-#      define THRIFT_EXPORT __declspec(dllimport)
-#    endif
-#  endif
-#else
-#  define THRIFT_EXPORT
-#endif
-
-#endif /* THRIFT_EXPORT_H */
+#include "thrift_export.hpp"
Index: opencv-src/opencv/modules/core/src/parallel.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/core/src/parallel.cpp b/opencv-src/opencv/modules/core/src/parallel.cpp
--- a/opencv-src/opencv/modules/core/src/parallel.cpp	(revision dad8af6b17f8e60d7b95a1203a1b4d22f56574cf)
+++ b/opencv-src/opencv/modules/core/src/parallel.cpp	(date 1714440647090)
@@ -76,7 +76,7 @@
     #include <thread>
 #endif
 
-#ifdef _OPENMP
+#if defined(_OPENMP) && !defined(HAVE_OPENMP)
     #define HAVE_OPENMP
 #endif
 
Index: skia-src/skia/src/gpu/ganesh/GrDistanceFieldGenFromVector.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/src/gpu/ganesh/GrDistanceFieldGenFromVector.cpp b/skia-src/skia/src/gpu/ganesh/GrDistanceFieldGenFromVector.cpp
--- a/skia-src/skia/src/gpu/ganesh/GrDistanceFieldGenFromVector.cpp	(revision 3d4e45907f9b239a54957001d619d2d4a6ca06b4)
+++ b/skia-src/skia/src/gpu/ganesh/GrDistanceFieldGenFromVector.cpp	(date 1714440647090)
@@ -64,12 +64,14 @@
     kRight_SegSide =  1,
     kNA_SegSide    =  2,
 };
+namespace {
 
 struct DFData {
     float fDistSq;            // distance squared to nearest (so far) edge
     int   fDeltaWindingScore; // +1 or -1 whenever a scanline cross over a segment
 };
 
+}
 ///////////////////////////////////////////////////////////////////////////////
 
 /*
Index: skia-src/skia/src/ports/SkScalerContext_win_dw.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/src/ports/SkScalerContext_win_dw.cpp b/skia-src/skia/src/ports/SkScalerContext_win_dw.cpp
--- a/skia-src/skia/src/ports/SkScalerContext_win_dw.cpp	(revision 3d4e45907f9b239a54957001d619d2d4a6ca06b4)
+++ b/skia-src/skia/src/ports/SkScalerContext_win_dw.cpp	(date 1714440647090)
@@ -1715,8 +1715,10 @@
     }
 
     DWRITE_GLYPH_IMAGE_FORMATS imageFormats;
+#if not defined(__MINGW64__)
     HRBM(fontFace4->GetGlyphImageFormats(glyph.getGlyphID(), 0, UINT32_MAX, &imageFormats),
          "Cannot get glyph image formats.");
+#endif
     if (!(imageFormats & DWRITE_GLYPH_IMAGE_FORMATS_PNG)) {
         return false;
     }
@@ -2266,8 +2268,10 @@
     }
 
     DWRITE_GLYPH_IMAGE_FORMATS imageFormats;
+#if not defined(__MINGW64__)
     HRBM(fontFace4->GetGlyphImageFormats(glyph.getGlyphID(), 0, UINT32_MAX, &imageFormats),
          "Cannot get glyph image formats.");
+#endif
     if (!(imageFormats & DWRITE_GLYPH_IMAGE_FORMATS_SVG)) {
         return false;
     }
Index: openbabel-src/openbabel/src/zipstreamimpl.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/zipstreamimpl.h b/openbabel-src/openbabel/src/zipstreamimpl.h
--- a/openbabel-src/openbabel/src/zipstreamimpl.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/zipstreamimpl.h	(date 1714440647090)
@@ -176,8 +176,7 @@
     }
     while(_err == Z_OK);
 
-    if(&_ostream)
-			_ostream.flush();
+    _ostream.flush();
 
     return total_written_byte_size;
 }
Index: openbabel-src/openbabel/src/builder.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/builder.cpp b/openbabel-src/openbabel/src/builder.cpp
--- a/openbabel-src/openbabel/src/builder.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/builder.cpp	(date 1714440647090)
@@ -97,7 +97,7 @@
 
   void OBBuilder::LoadFragments()  {
     // open data/fragments.txt
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "rigid-fragments-index.txt").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open ring-fragments-index.txt", obError);
       return;
@@ -171,7 +171,7 @@
       return coords;
     }
 
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "rigid-fragments.txt").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open rigid-fragments.txt", obError);
       return coords;
Index: svgpp-src/svgpp/include/svgpp/traits/attribute_type.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/traits/attribute_type.hpp b/svgpp-src/svgpp/include/svgpp/traits/attribute_type.hpp
--- a/svgpp-src/svgpp/include/svgpp/traits/attribute_type.hpp	(revision 5f1870aa7b757718ff5f86bdfb55966fa4f217f9)
+++ b/svgpp-src/svgpp/include/svgpp/traits/attribute_type.hpp	(date 1714440647090)
@@ -432,6 +432,9 @@
 template<class Element> struct attribute_type<Element, tag::attribute::class_                > { typedef tag::type::string type; }; // TODO: parse list of strings
 template<class Element> struct attribute_type<Element, tag::attribute::contentScriptType     > { typedef tag::type::string type; };
 template<class Element> struct attribute_type<Element, tag::attribute::contentStyleType      > { typedef tag::type::string type; };
+template<class Element> struct attribute_type<Element, tag::attribute::data_c                > { typedef tag::type::string type; };
+template<class Element> struct attribute_type<Element, tag::attribute::data_mjx_texclass     > { typedef tag::type::string type; };
+template<class Element> struct attribute_type<Element, tag::attribute::data_mml_node         > { typedef tag::type::string type; };
 template<class Element> struct attribute_type<Element, tag::attribute::id                    > { typedef tag::type::string type; };
 template<class Element> struct attribute_type<Element, tag::attribute::attributeName         > { typedef tag::type::string type; };
 template<class Element> struct attribute_type<Element, tag::attribute::font_family           > { typedef tag::type::string type; };
Index: openbabel-src/openbabel/src/oberror.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/oberror.cpp b/openbabel-src/openbabel/src/oberror.cpp
--- a/openbabel-src/openbabel/src/oberror.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/oberror.cpp	(date 1714440647090)
@@ -22,6 +22,7 @@
 #include <iostream>
 #include <string>
 #include <algorithm>
+#include <mutex>
 
 #include <openbabel/oberror.h>
 
@@ -162,6 +163,8 @@
 
   void OBMessageHandler::ThrowError(OBError err, errorQualifier qualifier)
   {
+    static std::mutex mutex_;
+    std::unique_lock lk(mutex_);
     if (!_logging)
       return;
 
@@ -182,6 +185,8 @@
                                     const std::string &errorMsg,
                                     obMessageLevel level, errorQualifier qualifier)
   {
+    static std::mutex mutex_;
+    std::unique_lock lk(mutex_);
     if (errorMsg.length() > 1)
       {
         OBError err(method, errorMsg, "", "", "", level);
@@ -191,6 +196,8 @@
 
   std::vector<std::string> OBMessageHandler::GetMessagesOfLevel(const obMessageLevel level)
   {
+    static std::mutex mutex_;
+    std::unique_lock lk(mutex_);
     vector<string> results;
     deque<OBError>::iterator i;
     OBError error;
@@ -207,6 +214,8 @@
 
   bool OBMessageHandler::StartErrorWrap()
   {
+    static std::mutex mutex_;
+    std::unique_lock lk(mutex_);
     if (_inWrapStreamBuf != nullptr)
       return true; // already wrapped cerr  -- don't go into loops!
 
@@ -223,6 +232,8 @@
 
   bool OBMessageHandler::StopErrorWrap()
   {
+    static std::mutex mutex_;
+    std::unique_lock lk(mutex_);
     if (_inWrapStreamBuf == nullptr)
       return true; // never wrapped cerr
 
@@ -237,6 +248,8 @@
 
   string OBMessageHandler::GetMessageSummary()
   {
+    static std::mutex mutex_;
+    std::unique_lock lk(mutex_);
     stringstream summary;
     if (_messageCount[obError] > 0)
       summary << _messageCount[obError] << " errors ";
Index: coordgen-src/coordgen/CoordgenConfig.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/coordgen-src/coordgen/CoordgenConfig.hpp b/coordgen-src/coordgen/CoordgenConfig.hpp
--- a/coordgen-src/coordgen/CoordgenConfig.hpp	(revision c4dd5b0e1f1971c06c7ab85725c185e47211814e)
+++ b/coordgen-src/coordgen/CoordgenConfig.hpp	(date 1714440647090)
@@ -1,22 +1,7 @@
 #pragma once
 
-#ifndef STATIC_COORDGEN
-
-#ifdef WIN32
-#ifdef IN_COORDGEN
-#define EXPORT_COORDGEN __declspec(dllexport)
-#else
-#define EXPORT_COORDGEN __declspec(dllimport)
-#endif // IN_COORDGEN
-
-#else
-
-#define EXPORT_COORDGEN __attribute__((visibility("default")))
-
-#endif // WIN32
+#include <coordgenlibs_export.hpp>
 
-#else
-
-#define EXPORT_COORDGEN
-
-#endif // STATIC_COORDGEN
+#ifndef EXPORT_COORDGEN
+#define EXPORT_COORDGEN COORDGENLIBS_EXPORT
+#endif
Index: openbabel-src/openbabel/src/RDKitConv.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/RDKitConv.cpp b/openbabel-src/openbabel/src/RDKitConv.cpp
--- a/openbabel-src/openbabel/src/RDKitConv.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/RDKitConv.cpp	(date 1714440647090)
@@ -23,6 +23,9 @@
 ***********************************************************************/
 
 #include <openbabel/babelconfig.h>
+#include <openbabel/oberror.h>
+#include <openbabel/bond.h>
+#include <openbabel/bondtyper.h>
 #include <RDKitConv.h>
 
 using OpenBabel::OBMolAtomIter;
@@ -45,7 +48,7 @@
   {
     //bond order >3 needs doing properly
     //assume RDKit atom indices start at 0
-    RDMol.addBond(b->GetBeginAtomIdx()-1, b->GetEndAtomIdx()-1, (RDKit::Bond::BondType)b->GetBO());
+    RDMol.addBond(b->GetBeginAtomIdx()-1, b->GetEndAtomIdx()-1, (RDKit::Bond::BondType)b->GetBondOrder());
   }
   std::string msg("RWMol made from ");
   if(pOBMol->GetTitle())
Index: arrow-src/arrow/cpp/src/parquet/platform.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/arrow-src/arrow/cpp/src/parquet/platform.h b/arrow-src/arrow/cpp/src/parquet/platform.h
--- a/arrow-src/arrow/cpp/src/parquet/platform.h	(revision 6a28035c2b49b432dc63f5ee7524d76b4ed2d762)
+++ b/arrow-src/arrow/cpp/src/parquet/platform.h	(date 1714440647090)
@@ -25,6 +25,7 @@
 #include "arrow/status.h"         // IWYU pragma: export
 #include "arrow/type_fwd.h"       // IWYU pragma: export
 #include "arrow/util/macros.h"    // IWYU pragma: export
+#include <parquet_export.h>
 
 #if defined(_WIN32) || defined(__CYGWIN__)
 
@@ -42,24 +43,6 @@
 #else
 #pragma GCC diagnostic ignored "-Wattributes"
 #endif
-
-#ifdef PARQUET_STATIC
-#define PARQUET_EXPORT
-#elif defined(PARQUET_EXPORTING)
-#define PARQUET_EXPORT __declspec(dllexport)
-#else
-#define PARQUET_EXPORT __declspec(dllimport)
-#endif
-
-#define PARQUET_NO_EXPORT
-
-#else  // Not Windows
-#ifndef PARQUET_EXPORT
-#define PARQUET_EXPORT __attribute__((visibility("default")))
-#endif
-#ifndef PARQUET_NO_EXPORT
-#define PARQUET_NO_EXPORT __attribute__((visibility("hidden")))
-#endif
 #endif  // Non-Windows
 
 // This is a complicated topic, some reading on it:
@@ -75,7 +58,6 @@
 #define PARQUET_DISALLOW_COPY_AND_ASSIGN ARROW_DISALLOW_COPY_AND_ASSIGN
 
 #define PARQUET_NORETURN ARROW_NORETURN
-#define PARQUET_DEPRECATED ARROW_DEPRECATED
 
 // If ARROW_VALGRIND set when compiling unit tests, also define
 // PARQUET_VALGRIND
Index: openbabel-src/openbabel/src/rotor.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/rotor.cpp b/openbabel-src/openbabel/src/rotor.cpp
--- a/openbabel-src/openbabel/src/rotor.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/rotor.cpp	(date 1714440647090)
@@ -31,8 +31,6 @@
 #include <set>
 #include <assert.h>
 
-// private data headers with default parameters
-#include "torlib.h"
 
 #ifndef M_PI
 #define M_PI 3.14159265358979323846
@@ -806,7 +804,7 @@
     _envvar = "BABEL_DATADIR";
     _filename = "torlib.txt";
     _subdir = "data";
-    _dataptr = TorsionDefaults;
+    _dataptr = nullptr;
   }
 
   void OBRotorRules::ParseLine(const char *buffer)
Index: openbabel-src/openbabel/src/format.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/format.cpp b/openbabel-src/openbabel/src/format.cpp
--- a/openbabel-src/openbabel/src/format.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/format.cpp	(date 1714440647090)
@@ -23,11 +23,6 @@
 using namespace std;
 namespace OpenBabel
 {
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-  // macro to implement static OBPlugin::PluginMapType& Map()
-  PLUGIN_CPP_FILE(OBFormat)
-#endif
-
 int OBFormat::RegisterFormat(const char* ID, const char* MIME)
 {
   GetMap()[ID] = this;
Index: openbabel-src/openbabel/src/forcefield.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/forcefield.cpp b/openbabel-src/openbabel/src/forcefield.cpp
--- a/openbabel-src/openbabel/src/forcefield.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/forcefield.cpp	(date 1714440647090)
@@ -40,11 +40,6 @@
 
 namespace OpenBabel
 {
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-  // macro to implement static OBPlugin::PluginMapType& Map()
-  PLUGIN_CPP_FILE(OBForceField)
-#endif
-
   /** \class OBForceField forcefield.h <openbabel/forcefield.h>
       \brief Base class for molecular mechanics force fields
 
Index: eigen-src/eigen/Eigen/src/Core/util/Macros.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/eigen-src/eigen/Eigen/src/Core/util/Macros.h b/eigen-src/eigen/Eigen/src/Core/util/Macros.h
--- a/eigen-src/eigen/Eigen/src/Core/util/Macros.h	(revision 3147391d946bb4b6c68edd901f2add6ac1f31f8c)
+++ b/eigen-src/eigen/Eigen/src/Core/util/Macros.h	(date 1714440647090)
@@ -59,7 +59,7 @@
 //------------------------------------------------------------------------------------------
 
 /// \internal EIGEN_COMP_GNUC set to 1 for all compilers compatible with GCC
-#ifdef __GNUC__
+#if defined(__GNUC__) && !defined(EMSCRIPTEN)
   #define EIGEN_COMP_GNUC (__GNUC__*10+__GNUC_MINOR__)
 #else
   #define EIGEN_COMP_GNUC 0
Index: openbabel-src/openbabel/src/confsearch.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/confsearch.cpp b/openbabel-src/openbabel/src/confsearch.cpp
--- a/openbabel-src/openbabel/src/confsearch.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/confsearch.cpp	(date 1714440647090)
@@ -131,7 +131,7 @@
 
     const double arr[] = {3.0, 2.0, 1.5, 1.0, 0.5, 0.25};
     std::vector<double> vec (arr, arr + sizeof(arr) / sizeof(arr[0]) );
-    vec.erase(std::remove_if(vec.begin(), vec.end(), std::bind2nd(std::less<double>(), (cutoff + 0.1) )), vec.end());
+    vec.erase(std::remove_if(vec.begin(), vec.end(), std::bind(std::less<double>(), std::placeholders::_1, (cutoff + 0.1) )), vec.end());
     vec.push_back(cutoff);
 
     levels = vec;
@@ -293,7 +293,7 @@
   std::vector <OBDiversePoses::PosePair> confs, newconfs;
 
   // The leaf iterator will (in effect) iterate over the nodes just at the loweset level
-  for (OBDiversePoses::Tree::leaf_iterator node = poses->begin(); node != poses->end(); ++node)
+  for (auto node = poses->begin(); node != poses->end(); ++node)
     if (node->first.size() > 0) // Don't include the dummy head node
       confs.push_back(*node);
 
@@ -441,7 +441,7 @@
     UpdateConformersFromTree(&_mol, _energies, &divposes, verbose);
 
     // Add back the energy offset
-    transform(_energies.begin(), _energies.end(), _energies.begin(), bind2nd(std::plus<double>(), energy_offset));
+    transform(_energies.begin(), _energies.end(), _energies.begin(), std::bind(std::plus<double>(), std::placeholders::_1, energy_offset));
 
     // Clean up
     delete [] store_initial;
Index: arrow-src/arrow/cpp/src/arrow/util/visibility.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/arrow-src/arrow/cpp/src/arrow/util/visibility.h b/arrow-src/arrow/cpp/src/arrow/util/visibility.h
--- a/arrow-src/arrow/cpp/src/arrow/util/visibility.h	(revision 6a28035c2b49b432dc63f5ee7524d76b4ed2d762)
+++ b/arrow-src/arrow/cpp/src/arrow/util/visibility.h	(date 1714440647090)
@@ -17,6 +17,8 @@
 
 #pragma once
 
+#include <arrow_export.h>
+
 #if defined(_WIN32) || defined(__CYGWIN__)
 // Windows
 
@@ -26,56 +28,13 @@
 #pragma GCC diagnostic ignored "-Wattributes"
 #endif
 
-#if defined(__cplusplus) && defined(__GNUC__) && !defined(__clang__)
-// Use C++ attribute syntax where possible to avoid GCC parser bug
-// (https://stackoverflow.com/questions/57993818/gcc-how-to-combine-attribute-dllexport-and-nodiscard-in-a-struct-de)
-#define ARROW_DLLEXPORT [[gnu::dllexport]]
-#define ARROW_DLLIMPORT [[gnu::dllimport]]
-#else
-#define ARROW_DLLEXPORT __declspec(dllexport)
-#define ARROW_DLLIMPORT __declspec(dllimport)
-#endif
-
-// _declspec(dllexport) even when the #included by a non-arrow source
-#define ARROW_FORCE_EXPORT ARROW_DLLEXPORT
-
-#ifdef ARROW_STATIC
-#define ARROW_EXPORT
-#define ARROW_FRIEND_EXPORT
-#define ARROW_TEMPLATE_EXPORT
-#elif defined(ARROW_EXPORTING)
-#define ARROW_EXPORT ARROW_DLLEXPORT
-// For some reason [[gnu::dllexport]] doesn't work well with friend declarations
-#define ARROW_FRIEND_EXPORT __declspec(dllexport)
-#define ARROW_TEMPLATE_EXPORT ARROW_DLLEXPORT
-#else
-#define ARROW_EXPORT ARROW_DLLIMPORT
-#define ARROW_FRIEND_EXPORT __declspec(dllimport)
-#define ARROW_TEMPLATE_EXPORT ARROW_DLLIMPORT
-#endif
-
-#define ARROW_NO_EXPORT
+#define ARROW_FRIEND_EXPORT ARROW_EXPORT
+#define ARROW_TEMPLATE_EXPORT ARROW_EXPORT
 
 #else
 
 // Non-Windows
 
-#if defined(__cplusplus) && (defined(__GNUC__) || defined(__clang__))
-#ifndef ARROW_EXPORT
-#define ARROW_EXPORT [[gnu::visibility("default")]]
-#endif
-#ifndef ARROW_NO_EXPORT
-#define ARROW_NO_EXPORT [[gnu::visibility("hidden")]]
-#endif
-#else
-// Not C++, or not gcc/clang
-#ifndef ARROW_EXPORT
-#define ARROW_EXPORT
-#endif
-#ifndef ARROW_NO_EXPORT
-#define ARROW_NO_EXPORT
-#endif
-#endif
 
 #define ARROW_FRIEND_EXPORT
 #define ARROW_TEMPLATE_EXPORT
Index: thrift-src/thrift/lib/cpp/src/thrift/transport/TPipeServer.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/thrift-src/thrift/lib/cpp/src/thrift/transport/TPipeServer.cpp b/thrift-src/thrift/lib/cpp/src/thrift/transport/TPipeServer.cpp
--- a/thrift-src/thrift/lib/cpp/src/thrift/transport/TPipeServer.cpp	(revision 0d0ac75347267f7c12fc9b5b349bf9ef7f632347)
+++ b/thrift-src/thrift/lib/cpp/src/thrift/transport/TPipeServer.cpp	(date 1714440647090)
@@ -27,8 +27,8 @@
 #ifdef _WIN32
 #include <thrift/windows/OverlappedSubmissionThread.h>
 #include <thrift/windows/Sync.h>
-#include <AccCtrl.h>
-#include <Aclapi.h>
+#include <accctrl.h>
+#include <aclapi.h>
 #include <sddl.h>
 #endif //_WIN32
 
Index: openbabel-src/openbabel/src/phmodel.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/phmodel.cpp b/openbabel-src/openbabel/src/phmodel.cpp
--- a/openbabel-src/openbabel/src/phmodel.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/phmodel.cpp	(date 1714440647090)
@@ -28,8 +28,6 @@
 
 #include <cstdlib>
 
-// private data header with default parameters
-#include "phmodeldata.h"
 
 #ifdef WIN32
 #pragma warning (disable : 4786)
@@ -50,7 +48,7 @@
     _envvar = "BABEL_DATADIR";
     _filename = "phmodel.txt";
     _subdir = "data";
-    _dataptr = PhModelData;
+    _dataptr = nullptr;
   }
 
   OBPhModel::~OBPhModel()
Index: svgpp-src/svgpp/include/svgpp/utility/gil/mask.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/utility/gil/mask.hpp b/svgpp-src/svgpp/include/svgpp/utility/gil/mask.hpp
--- a/svgpp-src/svgpp/include/svgpp/utility/gil/mask.hpp	(revision 5f1870aa7b757718ff5f86bdfb55966fa4f217f9)
+++ b/svgpp-src/svgpp/include/svgpp/utility/gil/mask.hpp	(date 1714440647090)
@@ -28,6 +28,7 @@
   GrayChannelValue operator()(const RedChannel& red, const GreenChannel& green, const BlueChannel& blue) const 
   {
     using namespace boost::gil;
+    using boost::gil::float32_t;
     return channel_convert<GrayChannelValue>(
       channel_convert<float32_t>(red  )*0.2125f +
       channel_convert<float32_t>(green)*0.7154f +
Index: pixman-src/pixman/pixman/pixman-compiler.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pixman-src/pixman/pixman/pixman-compiler.h b/pixman-src/pixman/pixman/pixman-compiler.h
--- a/pixman-src/pixman/pixman/pixman-compiler.h	(revision 54cad71674ec485cbbbf49876feaa8a69b97c828)
+++ b/pixman-src/pixman/pixman/pixman-compiler.h	(date 1714440647090)
@@ -4,8 +4,6 @@
  * The features are:
  *
  *    FUNC	     must be defined to expand to the current function
- *    PIXMAN_EXPORT  should be defined to whatever is required to
- *                   export functions from a shared library
  *    limits	     limits for various types must be defined
  *    inline         must be defined
  *    force_inline   must be defined
@@ -88,18 +86,6 @@
 #      define noinline
 #   endif
 #endif
-
-/* GCC visibility */
-#if defined(__GNUC__) && __GNUC__ >= 4 && !defined(_WIN32)
-#   define PIXMAN_EXPORT __attribute__ ((visibility("default")))
-/* Sun Studio 8 visibility */
-#elif defined(__SUNPRO_C) && (__SUNPRO_C >= 0x550)
-#   define PIXMAN_EXPORT __global
-#elif defined (_MSC_VER) || defined(__MINGW32__)
-#   define PIXMAN_EXPORT PIXMAN_API
-#else
-#   define PIXMAN_EXPORT
-#endif
 
 /* member offsets */
 #define CONTAINER_OF(type, member, data)				\
Index: openbabel-src/openbabel/src/plugin.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/plugin.cpp b/openbabel-src/openbabel/src/plugin.cpp
--- a/openbabel-src/openbabel/src/plugin.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/plugin.cpp	(date 1714440647090)
@@ -285,6 +285,8 @@
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theHINFormat)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theJaguarOutputFormat)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theJaguarInputFormat)->GetID());
+  plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theChemDoodleJSONFormat)->GetID());
+  plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&thePubChemJSONFormat)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theLMPDATFormat)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theMCDLFormat)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theMOLFormat)->GetID());
@@ -315,6 +317,7 @@
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&thePDBQTFormat)->GetID());
 #ifdef HAVE_LIBZ
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&thePNGFormat)->GetID());
+  plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&thePNG2Format)->GetID());
 #endif
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&thePointCloudFormat)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&thePovrayFormat)->GetID());
@@ -354,6 +357,8 @@
 #endif
 #ifdef HAVE_STATIC_INCHI
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theInChIFormat)->GetID());
+  plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theInChICompareFormat)->GetID());
+  plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theInChIKeyFormat)->GetID());
 #endif
 #ifdef HAVE_RPC_XDR_H
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theXTCFormat)->GetID());
@@ -413,6 +418,7 @@
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOpFillUC)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOpEnergy)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOpMinimize)->GetID());
+  plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOp2D)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOpGen2D)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOpGen3D)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOpNewS)->GetID());
Index: eigen-src/eigen/Eigen/src/Core/util/ConfigureVectorization.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/eigen-src/eigen/Eigen/src/Core/util/ConfigureVectorization.h b/eigen-src/eigen/Eigen/src/Core/util/ConfigureVectorization.h
--- a/eigen-src/eigen/Eigen/src/Core/util/ConfigureVectorization.h	(revision 3147391d946bb4b6c68edd901f2add6ac1f31f8c)
+++ b/eigen-src/eigen/Eigen/src/Core/util/ConfigureVectorization.h	(date 1714440647090)
@@ -339,7 +339,7 @@
     extern "C" {
       // In theory we should only include immintrin.h and not the other *mmintrin.h header files directly.
       // Doing so triggers some issues with ICC. However old gcc versions seems to not have this file, thus:
-      #if EIGEN_COMP_ICC >= 1110
+      #if EIGEN_COMP_ICC >= 1110 || EIGEN_COMP_EMSCRIPTEN
         #include <immintrin.h>
       #else
         #include <mmintrin.h>
Index: boost-src/boost/libs/gil/include/boost/gil/extension/rasterization/ellipse.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/gil/include/boost/gil/extension/rasterization/ellipse.hpp b/boost-src/boost/libs/gil/include/boost/gil/extension/rasterization/ellipse.hpp
--- a/boost-src/boost/libs/gil/include/boost/gil/extension/rasterization/ellipse.hpp	(revision 8994c2ff8ed8b88e0ffef9658a4c603c4a001fad)
+++ b/boost-src/boost/libs/gil/include/boost/gil/extension/rasterization/ellipse.hpp	(date 1714440647090)
@@ -37,8 +37,8 @@
     /// center respectively.
     /// \param semi_axes - Point containing positive integer lengths of horizontal semi-axis
     /// and vertical semi-axis respectively.
-    midpoint_ellipse_rasterizer(point<unsigned int> center_point,
-        point<unsigned int> semi_axes_values)
+    midpoint_ellipse_rasterizer(point_t center_point,
+        point_t semi_axes_values)
         : center(center_point)
         , semi_axes(semi_axes_values)
     {}
@@ -130,7 +130,7 @@
         }
 
         // mutable center copy
-        point<unsigned int> center2(center);
+        point_t center2(center);
         --center2[0], --center2[1]; // For converting center co-ordinate values to zero based indexing.
         for (point_t pnt : trajectory_points)
         {
@@ -186,8 +186,8 @@
         draw_curve(view, pixel, obtain_trajectory());
     }
 
-    point<unsigned int> center;
-    point<unsigned int> semi_axes;
+    point_t center;
+    point_t semi_axes;
 };
 
 namespace detail {
Index: rdkit-src/rdkit/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/.gitignore b/rdkit-src/rdkit/.gitignore
--- a/rdkit-src/rdkit/.gitignore	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/.gitignore	(date 1714440647090)
@@ -39,7 +39,6 @@
 
 /Code/RDBoost/test.h
 /Code/RDGeneral/RDConfig.h
-/Code/RDGeneral/export.h
 /Code/RDGeneral/test.h
 /Code/RDGeneral/versions.h
 /Code/RDGeneral/versions.cpp
Index: eigen-src/eigen/Eigen/src/Core/util/DisableStupidWarnings.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/eigen-src/eigen/Eigen/src/Core/util/DisableStupidWarnings.h b/eigen-src/eigen/Eigen/src/Core/util/DisableStupidWarnings.h
--- a/eigen-src/eigen/Eigen/src/Core/util/DisableStupidWarnings.h	(revision 3147391d946bb4b6c68edd901f2add6ac1f31f8c)
+++ b/eigen-src/eigen/Eigen/src/Core/util/DisableStupidWarnings.h	(date 1714440647090)
@@ -74,25 +74,25 @@
 #endif
 
 #if defined __NVCC__
-  #pragma diag_suppress boolean_controlling_expr_is_constant
+  #pragma nv_diag_suppress boolean_controlling_expr_is_constant
   // Disable the "statement is unreachable" message
-  #pragma diag_suppress code_is_unreachable
+  #pragma nv_diag_suppress code_is_unreachable
   // Disable the "dynamic initialization in unreachable code" message
-  #pragma diag_suppress initialization_not_reachable
+  #pragma nv_diag_suppress initialization_not_reachable
   // Disable the "invalid error number" message that we get with older versions of nvcc
-  #pragma diag_suppress 1222
+  #pragma nv_diag_suppress 1222
   // Disable the "calling a __host__ function from a __host__ __device__ function is not allowed" messages (yes, there are many of them and they seem to change with every version of the compiler)
-  #pragma diag_suppress 2527
-  #pragma diag_suppress 2529
-  #pragma diag_suppress 2651
-  #pragma diag_suppress 2653
-  #pragma diag_suppress 2668
-  #pragma diag_suppress 2669
-  #pragma diag_suppress 2670
-  #pragma diag_suppress 2671
-  #pragma diag_suppress 2735
-  #pragma diag_suppress 2737
-  #pragma diag_suppress 2739
+  #pragma nv_diag_suppress 2527
+  #pragma nv_diag_suppress 2529
+  #pragma nv_diag_suppress 2651
+  #pragma nv_diag_suppress 2653
+  #pragma nv_diag_suppress 2668
+  #pragma nv_diag_suppress 2669
+  #pragma nv_diag_suppress 2670
+  #pragma nv_diag_suppress 2671
+  #pragma nv_diag_suppress 2735
+  #pragma nv_diag_suppress 2737
+  #pragma nv_diag_suppress 2739
 #endif
 
 #else
Index: openbabel-src/openbabel/src/op.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/op.cpp b/openbabel-src/openbabel/src/op.cpp
--- a/openbabel-src/openbabel/src/op.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/op.cpp	(date 1714440647090)
@@ -22,10 +22,6 @@
 using namespace std;
 namespace OpenBabel
 {
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-  // macro to implement static OBPlugin::PluginMapType& Map()
-  PLUGIN_CPP_FILE(OBOp)
-#endif
 }
 
 
Index: openbabel-src/openbabel/src/distgeom.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/distgeom.cpp b/openbabel-src/openbabel/src/distgeom.cpp
--- a/openbabel-src/openbabel/src/distgeom.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/distgeom.cpp	(date 1714440647090)
@@ -16,7 +16,7 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 ***********************************************************************/
-
+#include <openbabel/babelconfig.h>
 #ifdef HAVE_EIGEN
 
 #include <openbabel/distgeom.h>
Index: openbabel-src/openbabel/src/alias.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/alias.cpp b/openbabel-src/openbabel/src/alias.cpp
--- a/openbabel-src/openbabel/src/alias.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/alias.cpp	(date 1714440647090)
@@ -222,7 +222,7 @@
 bool AliasData::LoadFile(SuperAtomTable& table)
 {
   //In table: key=alias left-form; value=pair<alias right-form, SMILES>
-  ifstream ifs;
+  istringstream ifs;
   if (OpenDatafile(ifs, "superatom.txt").length() == 0)
   {
     obErrorLog.ThrowError(__FUNCTION__, "Cannot open superatom.txt", obError);
@@ -250,7 +250,7 @@
 bool AliasData::LoadFile(SmartsTable& smtable)
 {
   //Re-parse the datafile. Seems simpler than trying to extract from the map.
-  ifstream ifs;
+  istringstream ifs;
   if (OpenDatafile(ifs, "superatom.txt").length() == 0)
   {
     obErrorLog.ThrowError(__FUNCTION__, "Cannot open superatom.txt", obError);
Index: openbabel-src/openbabel/src/tokenst.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/tokenst.cpp b/openbabel-src/openbabel/src/tokenst.cpp
--- a/openbabel-src/openbabel/src/tokenst.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/tokenst.cpp	(date 1714440647090)
@@ -24,7 +24,7 @@
 #include <limits>
 #include <cstring>
 #include <openbabel/tokenst.h>
-
+#include "text_assets.hpp"
 using namespace std;
 
 namespace OpenBabel
@@ -180,7 +180,7 @@
      or "BABEL_DATADIR" if @p envvar is not specified, or the compiled-in
      macro BABEL_DATADIR if the environment variable is not set
 
-     \param ifs        Stream to load
+     \param iss        Stream to load
      \param filename   Name of the data file to load
      \param envvar     Name of the environment variable
 
@@ -188,51 +188,16 @@
      unless it is in current directory
 
   **/
-  std::string OpenDatafile(std::ifstream& ifs, const std::string& filename,
+  std::string OpenDatafile(std::istringstream& iss, const std::string& filename,
                            const std::string& envvar)
   {
-    ios_base::openmode imode = ios_base::in;
-    #ifdef ALL_READS_BINARY //Makes unix files compatible with VC++6
-      imode = ios_base::in|ios_base::binary;
-    #endif
-
-    // check the current directory
-    ifs.close();
-    ifs.clear();
-    ifs.open(filename.c_str(),imode);
-    if(ifs)
-      return filename;
-
-    string file;
-    const char* datadir = getenv(envvar.c_str());
-    if(!datadir)
-      datadir = BABEL_DATADIR;
-
-    // check the subdirectory for this version number
-    file = datadir;
-    file += FILE_SEP_CHAR;
-    file += BABEL_VERSION;
-    file += FILE_SEP_CHAR + filename;
-
-    ifs.clear();
-    ifs.open(file.c_str(),imode);
-    if(ifs)
-      return file;
-
-    // couldn't find it with the version built in, so try the parent
-    file = datadir;
-    file += FILE_SEP_CHAR;
-    file += filename;
-
-    ifs.clear();
-    ifs.open(file.c_str(),imode);
-
-    if (ifs)
-      return file;
-
-    ifs.clear();
-    ifs.close();
-    return(""); // error
+    auto it = openbabel::OPENBABEL_ASSET_MAP.find(filename);
+    if(it==openbabel::OPENBABEL_ASSET_MAP.end()) {
+        return "";
+    }
+    iss.clear();
+    iss.str(it->second);
+    return filename;
   }
 
 
Index: openbabel-src/openbabel/src/mcdlutil.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/mcdlutil.cpp b/openbabel-src/openbabel/src/mcdlutil.cpp
--- a/openbabel-src/openbabel/src/mcdlutil.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/mcdlutil.cpp	(date 1714440647090)
@@ -5033,7 +5033,7 @@
 
     if (bondLabel != nullptr && nBonds() > 0) {
       bondLabel->resize(molecule1->nBonds());
-      if (test2) for (j=0; j<molecule1->nBonds(); j++) if (bSTested[j]>=0) (*bondLabel)[j]=1; else (*bondLabel)[j]=0;
+      if (test2) for (j=0; j<molecule1->nBonds(); j++) { if (bSTested[j]>=0) (*bondLabel)[j]=1; else (*bondLabel)[j]=0; }
     };
     result=test2;
 
@@ -5102,7 +5102,7 @@
   std::vector<TEditedMolecule *> TemplateRedraw::queryData;
 
   bool TemplateRedraw::loadTemplates() {
-    std::ifstream ifs;
+    std::istringstream ifs;
     string filename("templates.sdf");//("e:\\templates.sdf");
     TEditedMolecule sm;
     TEditedMolecule * em;
Index: openbabel-src/openbabel/src/obmolecformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/obmolecformat.cpp b/openbabel-src/openbabel/src/obmolecformat.cpp
--- a/openbabel-src/openbabel/src/obmolecformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/obmolecformat.cpp	(date 1714440647090)
@@ -500,12 +500,12 @@
 
     NameIndexType::iterator itr;
 
-    ifstream indexstream;
+    istringstream indexstream;
     OpenDatafile(indexstream, datafilename + ".obindx");
     if(!indexstream)
       {
         //Need to prepare the index
-        ifstream datastream;
+        istringstream datastream;
         string datafilepath = OpenDatafile(datastream, datafilename);
         if(!datastream)
           {
Index: openbabel-src/openbabel/src/bondtyper.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/bondtyper.cpp b/openbabel-src/openbabel/src/bondtyper.cpp
--- a/openbabel-src/openbabel/src/bondtyper.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/bondtyper.cpp	(date 1714440647090)
@@ -24,8 +24,6 @@
 #include <openbabel/bondtyper.h>
 #include <openbabel/elements.h>
 
-// data header with default parameters
-#include "bondtyp.h"
 
 using namespace std;
 
@@ -54,7 +52,7 @@
     _envvar = "BABEL_DATADIR";
     _filename = "bondtyp.txt";
     _subdir = "data";
-    _dataptr = BondTypeData;
+    _dataptr = nullptr;
   }
 
   void OBBondTyper::ParseLine(const char *buffer)
Index: openbabel-src/openbabel/src/data.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/data.cpp b/openbabel-src/openbabel/src/data.cpp
--- a/openbabel-src/openbabel/src/data.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/data.cpp	(date 1714440647090)
@@ -31,9 +31,6 @@
 #include <openbabel/oberror.h>
 #include <openbabel/elements.h>
 
-// data headers with default parameters
-#include "types.h"
-#include "resdata.h"
 
 
 #if !HAVE_STRNCASECMP
@@ -250,7 +247,7 @@
     _envvar = "BABEL_DATADIR";
     _filename = "types.txt";
     _subdir = "data";
-    _dataptr = TypesData;
+    _dataptr = nullptr;
     _linecount = 0;
     _from = _to = -1;
   }
@@ -434,7 +431,7 @@
     _envvar = "BABEL_DATADIR";
     _filename = "resdata.txt";
     _subdir = "data";
-    _dataptr = ResidueData;
+    _dataptr = nullptr;
   }
 
   bool OBResidueData::AssignBonds(OBMol &mol)
@@ -669,7 +666,7 @@
       return;
     _init = true;
 
-    ifstream ifs;
+    istringstream ifs;
     char charBuffer[BUFF_SIZE];
 
     // Set the locale for number parsing to avoid locale issues: PR#1785463
@@ -716,8 +713,6 @@
     // return the locale to the original one
     obLocale.RestoreLocale();
 
-    if (ifs)
-      ifs.close();
 
     if (GetSize() == 0)
       {
Index: openbabel-src/openbabel/src/typer.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/typer.cpp b/openbabel-src/openbabel/src/typer.cpp
--- a/openbabel-src/openbabel/src/typer.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/typer.cpp	(date 1714440647090)
@@ -27,8 +27,6 @@
 #include <openbabel/typer.h>
 #include <openbabel/elements.h>
 
-// private data headers with default parameters
-#include "atomtyp.h"
 
 #ifdef WIN32
 #pragma warning (disable : 4786)
@@ -64,7 +62,7 @@
     _envvar = "BABEL_DATADIR";
     _filename = "atomtyp.txt";
     _subdir = "data";
-    _dataptr = AtomTypeData;
+    _dataptr = nullptr;
   }
 
   void OBAtomTyper::ParseLine(const char *buffer)
Index: openbabel-src/openbabel/src/config.h.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/config.h.cmake b/openbabel-src/openbabel/src/config.h.cmake
--- a/openbabel-src/openbabel/src/config.h.cmake	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/config.h.cmake	(date 1714440647090)
@@ -16,23 +16,12 @@
 /* The file extension used for shared modules */
 #define MODULE_EXTENSION "@MODULE_EXTENSION@"
 
+#include <openbabel_export.hpp>
 // If we are using a recent GCC version with visibility support use it
-#ifdef HAVE_GCC_VISIBILITY
-  #define OB_EXPORT __attribute__ ((visibility("default")))
-  #define OB_IMPORT __attribute__ ((visibility("default")))
-  #define OB_HIDDEN __attribute__ ((visibility("hidden")))
-#elif defined(WIN32) && defined(USING_DYNAMIC_LIBS) && !defined(__MINGW32__)
- #define OB_EXPORT __declspec(dllexport)
- #define OB_IMPORT __declspec(dllimport)
- #define OB_HIDDEN
-#else
- #define OB_EXPORT
- #define OB_IMPORT
- #define OB_HIDDEN
+#ifndef OB_EXPORT
+#define OB_EXPORT OPENBABEL_EXPORT
 #endif
 
-/* Used to export symbols for DLL / shared library builds */
-#if defined(MAKE_OBDLL) // e.g. in src/main.cpp
  #ifndef OB_EXTERN
   #define OB_EXTERN   OB_EXPORT extern
  #endif
@@ -60,39 +49,6 @@
  #ifndef OBDEPICT
   #define OBDEPICT OB_EXPORT
  #endif
-
-#else   // defined(MAKE_OBDLL)
-
- #ifndef OB_EXTERN
-  #define OB_EXTERN   OB_IMPORT extern
- #endif
- #ifndef OBAPI
-  #define OBAPI    OB_IMPORT
- #endif
- #ifndef OBCOMMON
-  #define OBCOMMON OB_IMPORT
- #endif
- #ifndef OBCONV
-  #define OBCONV   OB_IMPORT
- #endif
- #ifndef OBERROR
-  #define OBERROR  OB_IMPORT
- #endif
- #ifndef OBFPRT
-  #define OBFPRT   OB_IMPORT
- #endif
- #ifndef OBFPTR
-  #define OBFPTR   OB_IMPORT
- #endif
- #ifndef OBMCDL
- #define OBMCDL    OB_IMPORT
-  #ifndef OBDEPICT
- #define OBDEPICT  OB_IMPORT
- #endif
-
- #endif
-
-#endif
 
 #ifdef _MSC_VER
  // Suppress warning on deprecated functions
@@ -149,6 +105,22 @@
 /* have struct clock_t */
 #cmakedefine HAVE_CLOCK_T 1
 
+#cmakedefine HAVE_REGEX_H 1
+
+#cmakedefine HAVE_SHARED_POINTER 1
+
+#cmakedefine HAVE_EIGEN 1
+
+#cmakedefine HAVE_EIGEN3 1
+
+#cmakedefine HAVE_STATIC_INCHI 1
+
+#cmakedefine HAVE_LIBZ 1
+
+#cmakedefine HAVE_STATIC_LIBXML 1
+
+#cmakedefine HAVE_RPC_XDR_H 1
+
 /* shared pointer implementation to be used */
 #cmakedefine OB_SHARED_PTR_IMPLEMENTATION @OB_SHARED_PTR_IMPLEMENTATION@
 
Index: pixman-src/pixman/pixman/pixman-version.h.in
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pixman-src/pixman/pixman/pixman-version.h.in b/pixman-src/pixman/pixman/pixman-version.h.in
--- a/pixman-src/pixman/pixman/pixman-version.h.in	(revision 54cad71674ec485cbbbf49876feaa8a69b97c828)
+++ b/pixman-src/pixman/pixman/pixman-version.h.in	(date 1714440647090)
@@ -27,6 +27,7 @@
 #ifndef PIXMAN_VERSION_H__
 #define PIXMAN_VERSION_H__
 
+#include "pixman_export.h"
 #ifndef PIXMAN_H__
 #  error pixman-version.h should only be included by pixman.h
 #endif
@@ -48,7 +49,7 @@
 	PIXMAN_VERSION_MICRO)
 
 #ifndef PIXMAN_API
-# define PIXMAN_API
+# define PIXMAN_API PIXMAN_EXPORT
 #endif
 
 #endif /* PIXMAN_VERSION_H__ */
Index: openbabel-src/openbabel/src/patty.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/patty.cpp b/openbabel-src/openbabel/src/patty.cpp
--- a/openbabel-src/openbabel/src/patty.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/patty.cpp	(date 1714440647090)
@@ -25,6 +25,7 @@
 
 #include <cstring>
 #include <cstdlib>
+#include <fstream>
 
 // Simple programmable atom typer
 // WPW - 070199
Index: openbabel-src/openbabel/src/descriptor.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/descriptor.cpp b/openbabel-src/openbabel/src/descriptor.cpp
--- a/openbabel-src/openbabel/src/descriptor.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/descriptor.cpp	(date 1714440647090)
@@ -25,11 +25,6 @@
 using namespace std;
 namespace OpenBabel
 {
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-  // macro to implement static OBPlugin::PluginMapType& Map()
-  PLUGIN_CPP_FILE(OBDescriptor)
-#endif
-
 /**
      Compare() is a virtual function and can be overridden to allow different
      comparison behaviour.
Index: rdkit-src/rdkit/Code/GraphMol/Canon.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/Canon.cpp b/rdkit-src/rdkit/Code/GraphMol/Canon.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/Canon.cpp	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Code/GraphMol/Canon.cpp	(date 1714440647090)
@@ -80,7 +80,7 @@
            !details::isUnsaturated(atom, mol)));
 }
 
-auto _possibleCompare = [](const PossibleType &arg1, const PossibleType &arg2) {
+const auto _possibleCompare = [](const PossibleType &arg1, const PossibleType &arg2) {
   return (std::get<0>(arg1) < std::get<0>(arg2));
 };
 
Index: openbabel-src/openbabel/src/locale.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/locale.cpp b/openbabel-src/openbabel/src/locale.cpp
--- a/openbabel-src/openbabel/src/locale.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/locale.cpp	(date 1714440647094)
@@ -16,33 +16,19 @@
 GNU General Public License for more details.
 ***********************************************************************/
 
-#include <stdlib.h>
-#include <string.h>
 #include <openbabel/locale.h>
-
-#if HAVE_XLOCALE_H
-#include <xlocale.h>
-#endif
-#if HAVE_LOCALE_H
-#include <locale.h>
-#endif
+#include <string>
+#include <clocale>
 
 namespace OpenBabel
 {
   class OBLocalePrivate {
   public:
-    char *old_locale_string;
-#if HAVE_USELOCALE
-    locale_t new_c_num_locale;
-    locale_t old_locale;
-#endif
+    std::string old_locale_string;
     unsigned int counter; // Reference counter -- ensures balance in SetLocale/RestoreLocale calls
 
     OBLocalePrivate(): counter(0)
     {
-#if HAVE_USELOCALE
-      new_c_num_locale = newlocale(LC_NUMERIC_MASK, NULL, NULL);
-#endif
     }
 
     ~OBLocalePrivate()
@@ -92,21 +78,8 @@
   void OBLocale::SetLocale()
   {
     if (d->counter == 0) {
-      // Set the locale for number parsing to avoid locale issues: PR#1785463
-#if HAVE_USELOCALE
-      // Extended per-thread interface
-      d->old_locale = uselocale(d->new_c_num_locale);
-#else
-#ifndef ANDROID
-      // Original global POSIX interface
-      // regular UNIX, no USELOCALE, no ANDROID
-      d->old_locale_string = strdup(setlocale(LC_NUMERIC, nullptr));
-#else
-      // ANDROID should stay as "C" -- Igor Filippov
-      d->old_locale_string = "C";
-#endif
+      d->old_locale_string = std::setlocale(LC_ALL, nullptr);
   	  setlocale(LC_NUMERIC, "C");
-#endif
     }
 
     ++d->counter;
@@ -117,15 +90,7 @@
     --d->counter;
     if(d->counter == 0) {
       // return the locale to the original one
-#ifdef HAVE_USELOCALE
-      uselocale(d->old_locale);
-#else
-      setlocale(LC_NUMERIC, d->old_locale_string);
-#ifndef ANDROID
-      // Don't free on Android because "C" is a static ctring constant
-      free (d->old_locale_string);
-#endif
-#endif
+      std::setlocale(LC_NUMERIC, d->old_locale_string.c_str());
     }
   }
 
Index: openbabel-src/openbabel/src/chargemodel.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/chargemodel.cpp b/openbabel-src/openbabel/src/chargemodel.cpp
--- a/openbabel-src/openbabel/src/chargemodel.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/chargemodel.cpp	(date 1714440647094)
@@ -26,11 +26,6 @@
 using namespace std;
 namespace OpenBabel
 {
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-  // macro to implement static OBPlugin::PluginMapType& Map()
-  PLUGIN_CPP_FILE(OBChargeModel)
-#endif
-
   void OBChargeModel::FillChargeVectors(OBMol &mol)
   {
     OBAtom *atom;
Index: cppcoro-src/cppcoro/include/cppcoro/recursive_generator.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/recursive_generator.hpp b/cppcoro-src/cppcoro/include/cppcoro/recursive_generator.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/recursive_generator.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/recursive_generator.hpp	(date 1714440647094)
@@ -7,7 +7,7 @@
 
 #include <cppcoro/generator.hpp>
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <type_traits>
 #include <utility>
 #include <cassert>
@@ -39,12 +39,12 @@
 				return recursive_generator<T>{ *this };
 			}
 
-			std::experimental::suspend_always initial_suspend() noexcept
+			std::suspend_always initial_suspend() noexcept
 			{
 				return {};
 			}
 
-			std::experimental::suspend_always final_suspend() noexcept
+			std::suspend_always final_suspend() noexcept
 			{
 				return {};
 			}
@@ -56,13 +56,13 @@
 
 			void return_void() noexcept {}
 
-			std::experimental::suspend_always yield_value(T& value) noexcept
+			std::suspend_always yield_value(T& value) noexcept
 			{
 				m_value = std::addressof(value);
 				return {};
 			}
 
-			std::experimental::suspend_always yield_value(T&& value) noexcept
+			std::suspend_always yield_value(T&& value) noexcept
 			{
 				m_value = std::addressof(value);
 				return {};
@@ -87,7 +87,7 @@
 						return this->m_childPromise == nullptr;
 					}
 
-					void await_suspend(std::experimental::coroutine_handle<promise_type>) noexcept
+					void await_suspend(std::coroutine_handle<promise_type>) noexcept
 					{}
 
 					void await_resume()
@@ -122,11 +122,11 @@
 
 			// Don't allow any use of 'co_await' inside the recursive_generator coroutine.
 			template<typename U>
-			std::experimental::suspend_never await_transform(U&& value) = delete;
+			std::suspend_never await_transform(U&& value) = delete;
 
 			void destroy() noexcept
 			{
-				std::experimental::coroutine_handle<promise_type>::from_promise(*this).destroy();
+				std::coroutine_handle<promise_type>::from_promise(*this).destroy();
 			}
 
 			void throw_if_exception()
@@ -139,7 +139,7 @@
 
 			bool is_complete() noexcept
 			{
-				return std::experimental::coroutine_handle<promise_type>::from_promise(*this).done();
+				return std::coroutine_handle<promise_type>::from_promise(*this).done();
 			}
 
 			T& value() noexcept
@@ -167,7 +167,7 @@
 
 			void resume() noexcept
 			{
-				std::experimental::coroutine_handle<promise_type>::from_promise(*this).resume();
+				std::coroutine_handle<promise_type>::from_promise(*this).resume();
 			}
 
 			std::add_pointer_t<T> m_value;
Index: cppcoro-src/cppcoro/include/cppcoro/single_consumer_async_auto_reset_event.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/single_consumer_async_auto_reset_event.hpp b/cppcoro-src/cppcoro/include/cppcoro/single_consumer_async_auto_reset_event.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/single_consumer_async_auto_reset_event.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/single_consumer_async_auto_reset_event.hpp	(date 1714440647094)
@@ -5,7 +5,7 @@
 #ifndef CPPCORO_SINGLE_CONSUMER_ASYNC_AUTO_RESET_EVENT_HPP_INCLUDED
 #define CPPCORO_SINGLE_CONSUMER_ASYNC_AUTO_RESET_EVENT_HPP_INCLUDED
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <atomic>
 #include <cstdint>
 #include <cassert>
@@ -26,7 +26,7 @@
 			if (oldValue != nullptr && oldValue != this)
 			{
 				// There was a waiting coroutine that we now need to resume.
-				auto handle = *static_cast<std::experimental::coroutine_handle<>*>(oldValue);
+				auto handle = *static_cast<std::coroutine_handle<>*>(oldValue);
 
 				// We also need to transition the state back to 'not set' before
 				// resuming the coroutine. This operation needs to be 'acquire'
@@ -54,7 +54,7 @@
 
 				bool await_ready() const noexcept { return false; }
 				
-				bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+				bool await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 				{
 					m_awaitingCoroutine = awaitingCoroutine;
 
@@ -82,7 +82,7 @@
 
 			private:
 				const single_consumer_async_auto_reset_event& m_event;
-				std::experimental::coroutine_handle<> m_awaitingCoroutine;
+				std::coroutine_handle<> m_awaitingCoroutine;
 			};
 
 			return awaiter{ *this };
Index: cppcoro-src/cppcoro/include/cppcoro/read_write_file.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/read_write_file.hpp b/cppcoro-src/cppcoro/include/cppcoro/read_write_file.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/read_write_file.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/read_write_file.hpp	(date 1714440647094)
@@ -11,7 +11,7 @@
 #include <cppcoro/file_buffering_mode.hpp>
 #include <cppcoro/file_open_mode.hpp>
 
-#include <experimental/filesystem>
+#include <filesystem>
 
 namespace cppcoro
 {
@@ -49,7 +49,7 @@
 		[[nodiscard]]
 		static read_write_file open(
 			io_service& ioService,
-			const std::experimental::filesystem::path& path,
+			const std::filesystem::path& path,
 			file_open_mode openMode = file_open_mode::create_or_open,
 			file_share_mode shareMode = file_share_mode::none,
 			file_buffering_mode bufferingMode = file_buffering_mode::default_);
Index: cppcoro-src/cppcoro/include/cppcoro/async_auto_reset_event.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/async_auto_reset_event.hpp b/cppcoro-src/cppcoro/include/cppcoro/async_auto_reset_event.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/async_auto_reset_event.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/async_auto_reset_event.hpp	(date 1714440647094)
@@ -5,7 +5,7 @@
 #ifndef CPPCORO_ASYNC_AUTO_RESET_EVENT_HPP_INCLUDED
 #define CPPCORO_ASYNC_AUTO_RESET_EVENT_HPP_INCLUDED
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <atomic>
 #include <cstdint>
 
@@ -80,7 +80,7 @@
 		async_auto_reset_event_operation(const async_auto_reset_event_operation& other) noexcept;
 
 		bool await_ready() const noexcept { return m_event == nullptr; }
-		bool await_suspend(std::experimental::coroutine_handle<> awaiter) noexcept;
+		bool await_suspend(std::coroutine_handle<> awaiter) noexcept;
 		void await_resume() const noexcept {}
 
 	private:
@@ -89,7 +89,7 @@
 
 		const async_auto_reset_event* m_event;
 		async_auto_reset_event_operation* m_next;
-		std::experimental::coroutine_handle<> m_awaiter;
+		std::coroutine_handle<> m_awaiter;
 		std::atomic<std::uint32_t> m_refCount;
 
 	};
Index: openbabel-src/openbabel/src/fingerprint.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/fingerprint.cpp b/openbabel-src/openbabel/src/fingerprint.cpp
--- a/openbabel-src/openbabel/src/fingerprint.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/fingerprint.cpp	(date 1714440647094)
@@ -30,11 +30,6 @@
 using namespace std;
 namespace OpenBabel
 {
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-  // macro to implement static OBPlugin::PluginMapType& Map()
-  PLUGIN_CPP_FILE(OBFingerprint)
-#endif
-
   const unsigned int OBFingerprint::bitsperint = 8 * sizeof(unsigned int);
 
   void OBFingerprint::SetBit(vector<unsigned int>& vec, const unsigned int n)
Index: cppcoro-src/cppcoro/include/cppcoro/task.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/task.hpp b/cppcoro-src/cppcoro/include/cppcoro/task.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/task.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/task.hpp	(date 1714440647094)
@@ -18,7 +18,7 @@
 #include <cstdint>
 #include <cassert>
 
-#include <experimental/coroutine>
+#include <coroutine>
 
 namespace cppcoro
 {
@@ -36,8 +36,8 @@
 
 #if CPPCORO_COMPILER_SUPPORTS_SYMMETRIC_TRANSFER
 				template<typename PROMISE>
-				std::experimental::coroutine_handle<> await_suspend(
-					std::experimental::coroutine_handle<PROMISE> coro) noexcept
+				std::coroutine_handle<> await_suspend(
+					std::coroutine_handle<PROMISE> coro) noexcept
 				{
 					return coro.promise().m_continuation;
 				}
@@ -49,7 +49,7 @@
 				// were crashing under x86 optimised builds.
 				template<typename PROMISE>
 				CPPCORO_NOINLINE
-				void await_suspend(std::experimental::coroutine_handle<PROMISE> coroutine)
+				void await_suspend(std::coroutine_handle<PROMISE> coroutine)
 				{
 					task_promise_base& promise = coroutine.promise();
 
@@ -79,7 +79,7 @@
 
 			auto initial_suspend() noexcept
 			{
-				return std::experimental::suspend_always{};
+				return std::suspend_always{};
 			}
 
 			auto final_suspend() noexcept
@@ -88,12 +88,12 @@
 			}
 
 #if CPPCORO_COMPILER_SUPPORTS_SYMMETRIC_TRANSFER
-			void set_continuation(std::experimental::coroutine_handle<> continuation) noexcept
+			void set_continuation(std::coroutine_handle<> continuation) noexcept
 			{
 				m_continuation = continuation;
 			}
 #else
-			bool try_set_continuation(std::experimental::coroutine_handle<> continuation)
+			bool try_set_continuation(std::coroutine_handle<> continuation)
 			{
 				m_continuation = continuation;
 				return !m_state.exchange(true, std::memory_order_acq_rel);
@@ -102,7 +102,7 @@
 
 		private:
 
-			std::experimental::coroutine_handle<> m_continuation;
+			std::coroutine_handle<> m_continuation;
 
 #if !CPPCORO_COMPILER_SUPPORTS_SYMMETRIC_TRANSFER
 			// Initially false. Set to true when either a continuation is registered
@@ -292,9 +292,9 @@
 
 		struct awaitable_base
 		{
-			std::experimental::coroutine_handle<promise_type> m_coroutine;
+			std::coroutine_handle<promise_type> m_coroutine;
 
-			awaitable_base(std::experimental::coroutine_handle<promise_type> coroutine) noexcept
+			awaitable_base(std::coroutine_handle<promise_type> coroutine) noexcept
 				: m_coroutine(coroutine)
 			{}
 
@@ -304,14 +304,14 @@
 			}
 
 #if CPPCORO_COMPILER_SUPPORTS_SYMMETRIC_TRANSFER
-			std::experimental::coroutine_handle<> await_suspend(
-				std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+			std::coroutine_handle<> await_suspend(
+				std::coroutine_handle<> awaitingCoroutine) noexcept
 			{
 				m_coroutine.promise().set_continuation(awaitingCoroutine);
 				return m_coroutine;
 			}
 #else
-			bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+			bool await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 			{
 				// NOTE: We are using the bool-returning version of await_suspend() here
 				// to work around a potential stack-overflow issue if a coroutine
@@ -341,7 +341,7 @@
 			: m_coroutine(nullptr)
 		{}
 
-		explicit task(std::experimental::coroutine_handle<promise_type> coroutine)
+		explicit task(std::coroutine_handle<promise_type> coroutine)
 			: m_coroutine(coroutine)
 		{}
 
@@ -446,7 +446,7 @@
 
 	private:
 
-		std::experimental::coroutine_handle<promise_type> m_coroutine;
+		std::coroutine_handle<promise_type> m_coroutine;
 
 	};
 
@@ -455,18 +455,18 @@
 		template<typename T>
 		task<T> task_promise<T>::get_return_object() noexcept
 		{
-			return task<T>{ std::experimental::coroutine_handle<task_promise>::from_promise(*this) };
+			return task<T>{ std::coroutine_handle<task_promise>::from_promise(*this) };
 		}
 
 		inline task<void> task_promise<void>::get_return_object() noexcept
 		{
-			return task<void>{ std::experimental::coroutine_handle<task_promise>::from_promise(*this) };
+			return task<void>{ std::coroutine_handle<task_promise>::from_promise(*this) };
 		}
 
 		template<typename T>
 		task<T&> task_promise<T&>::get_return_object() noexcept
 		{
-			return task<T&>{ std::experimental::coroutine_handle<task_promise>::from_promise(*this) };
+			return task<T&>{ std::coroutine_handle<task_promise>::from_promise(*this) };
 		}
 	}
 
Index: cppcoro-src/cppcoro/include/cppcoro/io_service.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/io_service.hpp b/cppcoro-src/cppcoro/include/cppcoro/io_service.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/io_service.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/io_service.hpp	(date 1714440647094)
@@ -19,7 +19,7 @@
 #include <atomic>
 #include <utility>
 #include <mutex>
-#include <experimental/coroutine>
+#include <coroutine>
 
 namespace cppcoro
 {
@@ -192,7 +192,7 @@
 		{}
 
 		bool await_ready() const noexcept { return false; }
-		void await_suspend(std::experimental::coroutine_handle<> awaiter) noexcept;
+		void await_suspend(std::coroutine_handle<> awaiter) noexcept;
 		void await_resume() const noexcept {}
 
 	private:
@@ -201,7 +201,7 @@
 		friend class io_service::timed_schedule_operation;
 
 		io_service& m_service;
-		std::experimental::coroutine_handle<> m_awaiter;
+		std::coroutine_handle<> m_awaiter;
 		schedule_operation* m_next;
 
 	};
@@ -224,7 +224,7 @@
 		timed_schedule_operation& operator=(const timed_schedule_operation& other) = delete;
 
 		bool await_ready() const noexcept;
-		void await_suspend(std::experimental::coroutine_handle<> awaiter);
+		void await_suspend(std::coroutine_handle<> awaiter);
 		void await_resume();
 
 	private:
Index: cppcoro-src/cppcoro/include/cppcoro/round_robin_scheduler.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/round_robin_scheduler.hpp b/cppcoro-src/cppcoro/include/cppcoro/round_robin_scheduler.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/round_robin_scheduler.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/round_robin_scheduler.hpp	(date 1714440647094)
@@ -7,7 +7,7 @@
 
 #include <cppcoro/config.hpp>
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <array>
 #include <cassert>
 #include <algorithm>
@@ -44,8 +44,8 @@
 				return false;
 			}
 
-			std::experimental::coroutine_handle<> await_suspend(
-				std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+			std::coroutine_handle<> await_suspend(
+				std::coroutine_handle<> awaitingCoroutine) noexcept
 			{
 				return m_scheduler.exchange_next(awaitingCoroutine);
 			}
@@ -61,7 +61,7 @@
 	public:
 		round_robin_scheduler() noexcept
 			: m_index(0)
-			, m_noop(std::experimental::noop_coroutine())
+			, m_noop(std::noop_coroutine())
 		{
 			for (size_t i = 0; i < N - 1; ++i)
 			{
@@ -104,8 +104,8 @@
 
 	private:
 
-		std::experimental::coroutine_handle exchange_next(
-			std::experimental::coroutine_handle<> coroutine) noexcept
+		std::coroutine_handle exchange_next(
+			std::coroutine_handle<> coroutine) noexcept
 		{
 			auto coroutineToResume = std::exchange(
 				m_scheduler.m_coroutines[m_scheduler.m_index],
@@ -115,8 +115,8 @@
 		}
 
 		size_t m_index;
-		const std::experimental::coroutine_handle<> m_noop;
-		std::array<std::experimental::coroutine_handle<>, N - 1> m_coroutines;
+		const std::coroutine_handle<> m_noop;
+		std::array<std::coroutine_handle<>, N - 1> m_coroutines;
 	};
 #endif
 }
Index: cairo-src/cairo/boilerplate/cairo-boilerplate.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cairo-src/cairo/boilerplate/cairo-boilerplate.c b/cairo-src/cairo/boilerplate/cairo-boilerplate.c
--- a/cairo-src/cairo/boilerplate/cairo-boilerplate.c	(revision 3909090108bb2db55330e3eb148aebe664735363)
+++ b/cairo-src/cairo/boilerplate/cairo-boilerplate.c	(date 1714440647094)
@@ -498,6 +498,10 @@
 #endif
 }
 
+void
+_cairo_boilerplate_register_all (void)
+{}
+
 void
 _cairo_boilerplate_register_backend (const cairo_boilerplate_target_t *targets,
 				     unsigned int		       count)
Index: cppcoro-src/cppcoro/include/cppcoro/shared_task.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/shared_task.hpp b/cppcoro-src/cppcoro/include/cppcoro/shared_task.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/shared_task.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/shared_task.hpp	(date 1714440647094)
@@ -17,7 +17,7 @@
 #include <utility>
 #include <type_traits>
 
-#include <experimental/coroutine>
+#include <coroutine>
 
 namespace cppcoro
 {
@@ -28,7 +28,7 @@
 	{
 		struct shared_task_waiter
 		{
-			std::experimental::coroutine_handle<> m_continuation;
+			std::coroutine_handle<> m_continuation;
 			shared_task_waiter* m_next;
 		};
 
@@ -41,7 +41,7 @@
 				bool await_ready() const noexcept { return false; }
 
 				template<typename PROMISE>
-				void await_suspend(std::experimental::coroutine_handle<PROMISE> h) noexcept
+				void await_suspend(std::coroutine_handle<PROMISE> h) noexcept
 				{
 					shared_task_promise_base& promise = h.promise();
 
@@ -79,7 +79,7 @@
 				, m_exception(nullptr)
 			{}
 
-			std::experimental::suspend_always initial_suspend() noexcept { return {}; }
+			std::suspend_always initial_suspend() noexcept { return {}; }
 			final_awaiter final_suspend() noexcept { return {}; }
 
 			void unhandled_exception() noexcept
@@ -124,7 +124,7 @@
 			/// waiter->m_coroutine will be resumed when the task completes.
 			/// false if the coroutine was already completed and the awaiting
 			/// coroutine can continue without suspending.
-			bool try_await(shared_task_waiter* waiter, std::experimental::coroutine_handle<> coroutine)
+			bool try_await(shared_task_waiter* waiter, std::coroutine_handle<> coroutine)
 			{
 				void* const valueReadyValue = this;
 				void* const notStartedValue = &this->m_waiters;
@@ -304,10 +304,10 @@
 
 		struct awaitable_base
 		{
-			std::experimental::coroutine_handle<promise_type> m_coroutine;
+			std::coroutine_handle<promise_type> m_coroutine;
 			detail::shared_task_waiter m_waiter;
 
-			awaitable_base(std::experimental::coroutine_handle<promise_type> coroutine) noexcept
+			awaitable_base(std::coroutine_handle<promise_type> coroutine) noexcept
 				: m_coroutine(coroutine)
 			{}
 
@@ -316,7 +316,7 @@
 				return !m_coroutine || m_coroutine.promise().is_ready();
 			}
 
-			bool await_suspend(std::experimental::coroutine_handle<> awaiter) noexcept
+			bool await_suspend(std::coroutine_handle<> awaiter) noexcept
 			{
 				m_waiter.m_continuation = awaiter;
 				return m_coroutine.promise().try_await(&m_waiter, m_coroutine);
@@ -329,7 +329,7 @@
 			: m_coroutine(nullptr)
 		{}
 
-		explicit shared_task(std::experimental::coroutine_handle<promise_type> coroutine)
+		explicit shared_task(std::coroutine_handle<promise_type> coroutine)
 			: m_coroutine(coroutine)
 		{
 			// Don't increment the ref-count here since it has already been
@@ -452,7 +452,7 @@
 			}
 		}
 
-		std::experimental::coroutine_handle<promise_type> m_coroutine;
+		std::coroutine_handle<promise_type> m_coroutine;
 
 	};
 
@@ -480,7 +480,7 @@
 		shared_task<T> shared_task_promise<T>::get_return_object() noexcept
 		{
 			return shared_task<T>{
-				std::experimental::coroutine_handle<shared_task_promise>::from_promise(*this)
+				std::coroutine_handle<shared_task_promise>::from_promise(*this)
 			};
 		}
 
@@ -488,14 +488,14 @@
 		shared_task<T&> shared_task_promise<T&>::get_return_object() noexcept
 		{
 			return shared_task<T&>{
-				std::experimental::coroutine_handle<shared_task_promise>::from_promise(*this)
+				std::coroutine_handle<shared_task_promise>::from_promise(*this)
 			};
 		}
 
 		inline shared_task<void> shared_task_promise<void>::get_return_object() noexcept
 		{
 			return shared_task<void>{
-				std::experimental::coroutine_handle<shared_task_promise>::from_promise(*this)
+				std::coroutine_handle<shared_task_promise>::from_promise(*this)
 			};
 		}
 	}
Index: cppcoro-src/cppcoro/include/cppcoro/async_manual_reset_event.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/async_manual_reset_event.hpp b/cppcoro-src/cppcoro/include/cppcoro/async_manual_reset_event.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/async_manual_reset_event.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/async_manual_reset_event.hpp	(date 1714440647094)
@@ -5,7 +5,7 @@
 #ifndef CPPCORO_ASYNC_MANUAL_RESET_EVENT_HPP_INCLUDED
 #define CPPCORO_ASYNC_MANUAL_RESET_EVENT_HPP_INCLUDED
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <atomic>
 #include <cstdint>
 
@@ -87,7 +87,7 @@
 		explicit async_manual_reset_event_operation(const async_manual_reset_event& event) noexcept;
 
 		bool await_ready() const noexcept;
-		bool await_suspend(std::experimental::coroutine_handle<> awaiter) noexcept;
+		bool await_suspend(std::coroutine_handle<> awaiter) noexcept;
 		void await_resume() const noexcept {}
 
 	private:
@@ -96,7 +96,7 @@
 
 		const async_manual_reset_event& m_event;
 		async_manual_reset_event_operation* m_next;
-		std::experimental::coroutine_handle<> m_awaiter;
+		std::coroutine_handle<> m_awaiter;
 
 	};
 }
Index: openbabel-src/openbabel/src/ops/op2d.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/ops/op2d.cpp b/openbabel-src/openbabel/src/ops/op2d.cpp
--- a/openbabel-src/openbabel/src/ops/op2d.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/ops/op2d.cpp	(date 1714440647094)
@@ -25,12 +25,13 @@
 #include <openbabel/babelconfig.h>
 #include <iostream>
 #include<openbabel/op.h>
+#include<openbabel/atom.h>
 #include<openbabel/mol.h>
+#include<openbabel/oberror.h>
 #include <RDKitConv.h>
 #include <GraphMol/Depictor/RDDepictor.h>
 #include <Geometry/point.h>
-#include <GraphMol/conformer.h>
-#include <GraphMol/molops.h>
+#include <GraphMol/MolOps.h>
 
 #ifndef OBERROR
  #define OBERROR
@@ -49,13 +50,13 @@
   }
   virtual bool WorksWith(OBBase* pOb)const{ return dynamic_cast<OBMol*>(pOb)!=NULL; }
 
-  virtual bool Do(OBBase* pOb, OpMap*, const char* OptionText);
+  virtual bool Do(OBBase* pOb, const char*, OpMap*, OBConversion*);
 };
 
 Op2D theOp2D("2D"); //Global instance
 
 /////////////////////////////////////////////////////////////////
-bool Op2D::Do(OBBase* pOb, OpMap*, const char* OptionText)
+bool Op2D::Do(OBBase* pOb, const char*, OpMap*, OBConversion*)
 {
   OBMol* pmol = dynamic_cast<OBMol*>(pOb);
   if(!pmol)
Index: cppcoro-src/cppcoro/include/cppcoro/file_write_operation.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/file_write_operation.hpp b/cppcoro-src/cppcoro/include/cppcoro/file_write_operation.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/file_write_operation.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/file_write_operation.hpp	(date 1714440647094)
@@ -11,7 +11,7 @@
 
 #include <atomic>
 #include <optional>
-#include <experimental/coroutine>
+#include <coroutine>
 
 #if CPPCORO_OS_WINNT
 # include <cppcoro/detail/win32.hpp>
Index: rdkit-src/rdkit/Code/ML/Cluster/Murtagh/f2c.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/ML/Cluster/Murtagh/f2c.h b/rdkit-src/rdkit/Code/ML/Cluster/Murtagh/f2c.h
--- a/rdkit-src/rdkit/Code/ML/Cluster/Murtagh/f2c.h	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Code/ML/Cluster/Murtagh/f2c.h	(date 1714440647094)
@@ -4,7 +4,6 @@
 
         - From The Shogakukan DICTIONARY OF NEW ENGLISH (Second edition) */
 
-#include <RDGeneral/export.h>
 #ifndef F2C_INCLUDE
 #define F2C_INCLUDE
 
Index: openbabel-src/openbabel/src/ops/unique.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/ops/unique.cpp b/openbabel-src/openbabel/src/ops/unique.cpp
--- a/openbabel-src/openbabel/src/ops/unique.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/ops/unique.cpp	(date 1714440647094)
@@ -39,7 +39,7 @@
   #ifdef _LIBCPP_VERSION
     using std::unordered_map;
   #else
-    using std::tr1::unordered_map;
+    using std::unordered_map;
   #endif
 #endif
 namespace OpenBabel
Index: cppcoro-src/cppcoro/include/cppcoro/generator.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/generator.hpp b/cppcoro-src/cppcoro/include/cppcoro/generator.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/generator.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/generator.hpp	(date 1714440647094)
@@ -5,7 +5,7 @@
 #ifndef CPPCORO_GENERATOR_HPP_INCLUDED
 #define CPPCORO_GENERATOR_HPP_INCLUDED
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <type_traits>
 #include <utility>
 #include <exception>
@@ -32,19 +32,19 @@
 
 			generator<T> get_return_object() noexcept;
 
-			constexpr std::experimental::suspend_always initial_suspend() const noexcept { return {}; }
-			constexpr std::experimental::suspend_always final_suspend() const noexcept { return {}; }
+			constexpr std::suspend_always initial_suspend() const noexcept { return {}; }
+			constexpr std::suspend_always final_suspend() const noexcept { return {}; }
 
 			template<
 				typename U = T,
 				std::enable_if_t<!std::is_rvalue_reference<U>::value, int> = 0>
-			std::experimental::suspend_always yield_value(std::remove_reference_t<T>& value) noexcept
+			std::suspend_always yield_value(std::remove_reference_t<T>& value) noexcept
 			{
 				m_value = std::addressof(value);
 				return {};
 			}
 
-			std::experimental::suspend_always yield_value(std::remove_reference_t<T>&& value) noexcept
+			std::suspend_always yield_value(std::remove_reference_t<T>&& value) noexcept
 			{
 				m_value = std::addressof(value);
 				return {};
@@ -66,7 +66,7 @@
 
 			// Don't allow any use of 'co_await' inside the generator coroutine.
 			template<typename U>
-			std::experimental::suspend_never await_transform(U&& value) = delete;
+			std::suspend_never await_transform(U&& value) = delete;
 
 			void rethrow_if_exception()
 			{
@@ -88,7 +88,7 @@
 		template<typename T>
 		class generator_iterator
 		{
-			using coroutine_handle = std::experimental::coroutine_handle<generator_promise<T>>;
+			using coroutine_handle = std::coroutine_handle<generator_promise<T>>;
 
 		public:
 
@@ -223,11 +223,11 @@
 
 		friend class detail::generator_promise<T>;
 
-		explicit generator(std::experimental::coroutine_handle<promise_type> coroutine) noexcept
+		explicit generator(std::coroutine_handle<promise_type> coroutine) noexcept
 			: m_coroutine(coroutine)
 		{}
 
-		std::experimental::coroutine_handle<promise_type> m_coroutine;
+		std::coroutine_handle<promise_type> m_coroutine;
 
 	};
 
@@ -242,7 +242,7 @@
 		template<typename T>
 		generator<T> generator_promise<T>::get_return_object() noexcept
 		{
-			using coroutine_handle = std::experimental::coroutine_handle<generator_promise<T>>;
+			using coroutine_handle = std::coroutine_handle<generator_promise<T>>;
 			return generator<T>{ coroutine_handle::from_promise(*this) };
 		}
 	}
Index: cppcoro-src/cppcoro/include/cppcoro/fmap.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/fmap.hpp b/cppcoro-src/cppcoro/include/cppcoro/fmap.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/fmap.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/fmap.hpp	(date 1714440647094)
@@ -40,7 +40,7 @@
 			}
 
 			template<typename PROMISE>
-			decltype(auto) await_suspend(std::experimental::coroutine_handle<PROMISE> coro)
+			decltype(auto) await_suspend(std::coroutine_handle<PROMISE> coro)
 				noexcept(noexcept(static_cast<awaiter_t&&>(m_awaiter).await_suspend(std::move(coro))))
 			{
 				return static_cast<awaiter_t&&>(m_awaiter).await_suspend(std::move(coro));
Index: cppcoro-src/cppcoro/include/cppcoro/single_producer_sequencer.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/single_producer_sequencer.hpp b/cppcoro-src/cppcoro/include/cppcoro/single_producer_sequencer.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/single_producer_sequencer.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/single_producer_sequencer.hpp	(date 1714440647094)
@@ -160,7 +160,7 @@
 			return m_consumerWaitOperation.await_ready();
 		}
 
-		auto await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+		auto await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 		{
 			return m_consumerWaitOperation.await_suspend(awaitingCoroutine);
 		}
@@ -199,7 +199,7 @@
 			return m_consumerWaitOperation.await_ready();
 		}
 
-		auto await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+		auto await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 		{
 			return m_consumerWaitOperation.await_suspend(awaitingCoroutine);
 		}
Index: cppcoro-src/cppcoro/include/cppcoro/inline_scheduler.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/inline_scheduler.hpp b/cppcoro-src/cppcoro/include/cppcoro/inline_scheduler.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/inline_scheduler.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/inline_scheduler.hpp	(date 1714440647094)
@@ -5,7 +5,7 @@
 #ifndef CPPCORO_INLINE_SCHEDULER_HPP_INCLUDED
 #define CPPCORO_INLINE_SCHEDULER_HPP_INCLUDED
 
-#include <experimental/coroutine>
+#include <coroutine>
 
 namespace cppcoro
 {
@@ -15,7 +15,7 @@
 
 		inline_scheduler() noexcept = default;
 
-		std::experimental::suspend_never schedule() const noexcept
+		std::suspend_never schedule() const noexcept
 		{
 			return {};
 		}
Index: boost-src/boost/libs/serialization/src/xml_wiarchive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/xml_wiarchive.cpp b/boost-src/boost/libs/serialization/src/xml_wiarchive.cpp
--- a/boost-src/boost/libs/serialization/src/xml_wiarchive.cpp	(revision a20c4d97c37e5f437c8ba78f296830edb79cff9e)
+++ b/boost-src/boost/libs/serialization/src/xml_wiarchive.cpp	(date 1714440647094)
@@ -17,6 +17,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/xml_wiarchive.hpp>
Index: rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmarts.cpp.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmarts.cpp.cmake b/rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmarts.cpp.cmake
--- a/rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmarts.cpp.cmake	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmarts.cpp.cmake	(date 1714440647094)
@@ -809,7 +809,7 @@
 #endif
 
 #include <cstdio>
-#ifdef WIN32
+#if defined(WIN32) || defined(__MINGW32__)
 #include <io.h>
 #endif
 
Index: openbabel-src/openbabel/src/ops/loader.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/ops/loader.cpp b/openbabel-src/openbabel/src/ops/loader.cpp
--- a/openbabel-src/openbabel/src/ops/loader.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/ops/loader.cpp	(date 1714440647094)
@@ -35,11 +35,6 @@
   const char* TypeID(){return "loaders";};
 };
 
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-// macro to implement static OBPlugin::PluginMapType& Map()
-PLUGIN_CPP_FILE(OBLoader)
-#endif
-
 //*********************************************************
 ///Class which makes instances of plugin classes from information in text file.
 ///This allows the commandline and GUI interfaces to be extended without recompiling.
@@ -55,7 +50,7 @@
   OBDefine(const char* ID, const char* filename)
     : OBLoader(ID, false), _filename(filename)
   {
-    ifstream ifs;
+    istringstream ifs;
     bool filefound = !OpenDatafile(ifs, filename).empty();
     if(!ifs)
     {
Index: rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.h b/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.h
--- a/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.h	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.h	(date 1714440647094)
@@ -36,10 +36,7 @@
 class RDKIT_MOLSTANDARDIZE_EXPORT TautomerCatalogParams
     : public RDCatalog::CatalogParams {
  public:
-  TautomerCatalogParams() {
-    d_typeStr = "Tautomer Catalog Parameters";
-    d_transforms.clear();
-  }
+  TautomerCatalogParams();
 
   TautomerCatalogParams(const std::string &tautomerFile);
   TautomerCatalogParams(const TautomerTransformDefs &data);
Index: rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.cpp b/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.cpp	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.cpp	(date 1714440647094)
@@ -45,6 +45,11 @@
 
 TautomerCatalogParams::~TautomerCatalogParams() {}
 
+TautomerCatalogParams::TautomerCatalogParams() {
+    d_typeStr = "Tautomer Catalog Parameters";
+    d_transforms.clear();
+}
+
 const std::vector<TautomerTransform> &TautomerCatalogParams::getTransforms()
     const {
   return d_transforms;
Index: rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmiles.cpp.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmiles.cpp.cmake b/rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmiles.cpp.cmake
--- a/rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmiles.cpp.cmake	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmiles.cpp.cmake	(date 1714440647094)
@@ -816,7 +816,7 @@
 #endif
 
 #include <cstdio>
-#ifdef WIN32
+#if defined(WIN32) || defined(__MINGW32__)
 #include <io.h>
 #endif
 
Index: cairo-src/cairo/src/cairo.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cairo-src/cairo/src/cairo.h b/cairo-src/cairo/src/cairo.h
--- a/cairo-src/cairo/src/cairo.h	(revision 3909090108bb2db55330e3eb148aebe664735363)
+++ b/cairo-src/cairo/src/cairo.h	(date 1714440647094)
@@ -38,6 +38,7 @@
 #ifndef CAIRO_H
 #define CAIRO_H
 
+#include "cairo_export.h"
 #include "cairo-version.h"
 #include "cairo-features.h"
 #include "cairo-deprecated.h"
@@ -50,22 +51,7 @@
 # define CAIRO_END_DECLS
 #endif
 
-#if (defined(_WIN32) || defined(__CYGWIN__)) && !defined(CAIRO_WIN32_STATIC_BUILD)
-# define _cairo_export __declspec(dllexport)
-# define _cairo_import __declspec(dllimport)
-#elif defined(__GNUC__) && (__GNUC__ >= 4)
-# define _cairo_export __attribute__((__visibility__("default")))
-# define _cairo_import
-#else
-# define _cairo_export
-# define _cairo_import
-#endif
-
-#ifdef CAIRO_COMPILATION
-# define _cairo_api _cairo_export
-#else
-# define _cairo_api _cairo_import
-#endif
+# define _cairo_api CAIRO_EXPORT
 
 #define cairo_public _cairo_api extern
 
Index: cppcoro-src/cppcoro/include/cppcoro/multi_producer_sequencer.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/multi_producer_sequencer.hpp b/cppcoro-src/cppcoro/include/cppcoro/multi_producer_sequencer.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/multi_producer_sequencer.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/multi_producer_sequencer.hpp	(date 1714440647094)
@@ -194,7 +194,7 @@
 			return m_barrierWait.await_ready();
 		}
 
-		auto await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+		auto await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 		{
 			return m_barrierWait.await_suspend(awaitingCoroutine);
 		}
@@ -273,7 +273,7 @@
 			return m_waitOp.await_ready();
 		}
 
-		auto await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+		auto await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 		{
 			return m_waitOp.await_suspend(awaitingCoroutine);
 		}
@@ -347,7 +347,7 @@
 			return !TRAITS::precedes(m_lastKnownPublished, m_targetSequence);
 		}
 
-		bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+		bool await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 		{
 			m_awaitingCoroutine = awaitingCoroutine;
 
@@ -384,7 +384,7 @@
 		SEQUENCE m_targetSequence;
 		SEQUENCE m_lastKnownPublished;
 		multi_producer_sequencer_wait_operation_base* m_next;
-		std::experimental::coroutine_handle<> m_awaitingCoroutine;
+		std::coroutine_handle<> m_awaitingCoroutine;
 		std::atomic<bool> m_readyToResume;
 	};
 
Index: cppcoro-src/cppcoro/include/cppcoro/file.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/file.hpp b/cppcoro-src/cppcoro/include/cppcoro/file.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/file.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/file.hpp	(date 1714440647094)
@@ -15,7 +15,7 @@
 # include <cppcoro/detail/win32.hpp>
 #endif
 
-#include <experimental/filesystem>
+#include <filesystem>
 
 namespace cppcoro
 {
@@ -40,7 +40,7 @@
 		static detail::win32::safe_handle open(
 			detail::win32::dword_t fileAccess,
 			io_service& ioService,
-			const std::experimental::filesystem::path& path,
+			const std::filesystem::path& path,
 			file_open_mode openMode,
 			file_share_mode shareMode,
 			file_buffering_mode bufferingMode);
Index: spdlog-src/spdlog/src/file_sinks.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/spdlog-src/spdlog/src/file_sinks.cpp b/spdlog-src/spdlog/src/file_sinks.cpp
--- a/spdlog-src/spdlog/src/file_sinks.cpp	(revision 7e635fca68d014934b4af8a1cf874f63989352b7)
+++ b/spdlog-src/spdlog/src/file_sinks.cpp	(date 1714440647094)
@@ -8,7 +8,6 @@
 #include <spdlog/details/null_mutex.h>
 #include <spdlog/details/file_helper-inl.h>
 #include <spdlog/sinks/basic_file_sink-inl.h>
-#include <spdlog/sinks/base_sink-inl.h>
 
 #include <mutex>
 
Index: cairo-src/cairo/src/cairo-ps-surface.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cairo-src/cairo/src/cairo-ps-surface.c b/cairo-src/cairo/src/cairo-ps-surface.c
--- a/cairo-src/cairo/src/cairo-ps-surface.c	(revision 3909090108bb2db55330e3eb148aebe664735363)
+++ b/cairo-src/cairo/src/cairo-ps-surface.c	(date 1714440647094)
@@ -102,7 +102,7 @@
 #define DEBUG_FALLBACK(s)
 #endif
 
-#ifndef HAVE_CTIME_R
+#if !defined(HAVE_CTIME_R) && !defined(unix)
 static char *ctime_r(const time_t *timep, char *buf)
 {
     (void)buf;
Index: openbabel-src/openbabel/src/ops/sort.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/ops/sort.cpp b/openbabel-src/openbabel/src/ops/sort.cpp
--- a/openbabel-src/openbabel/src/ops/sort.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/ops/sort.cpp	(date 1714440647094)
@@ -29,7 +29,7 @@
 {
 
 template<class T>
-struct Order : public std::binary_function<std::pair<OBBase*,T>, std::pair<OBBase*,T>, bool>
+struct Order
 {
   Order(OBDescriptor* pDesc, bool rev) : _pDesc(pDesc), _rev(rev){}
   bool operator()(std::pair<OBBase*,T> p1, std::pair<OBBase*,T> p2) const
Index: cppcoro-src/cppcoro/include/cppcoro/single_consumer_event.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/single_consumer_event.hpp b/cppcoro-src/cppcoro/include/cppcoro/single_consumer_event.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/single_consumer_event.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/single_consumer_event.hpp	(date 1714440647094)
@@ -6,7 +6,7 @@
 #define CPPCORO_SINGLE_CONSUMER_EVENT_HPP_INCLUDED
 
 #include <atomic>
-#include <experimental/coroutine>
+#include <coroutine>
 
 namespace cppcoro
 {
@@ -84,7 +84,7 @@
 					return m_event.is_set();
 				}
 
-				bool await_suspend(std::experimental::coroutine_handle<> awaiter)
+				bool await_suspend(std::coroutine_handle<> awaiter)
 				{
 					m_event.m_awaiter = awaiter;
 
@@ -120,7 +120,7 @@
 		// by encoding 'not_set' as 0 (nullptr), 'set' as 1 and
 		// 'not_set_consumer_waiting' as a coroutine handle pointer.
 		std::atomic<state> m_state;
-		std::experimental::coroutine_handle<> m_awaiter;
+		std::coroutine_handle<> m_awaiter;
 
 	};
 }
Index: boost-src/boost/libs/serialization/src/codecvt_null.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/codecvt_null.cpp b/boost-src/boost/libs/serialization/src/codecvt_null.cpp
--- a/boost-src/boost/libs/serialization/src/codecvt_null.cpp	(revision a20c4d97c37e5f437c8ba78f296830edb79cff9e)
+++ b/boost-src/boost/libs/serialization/src/codecvt_null.cpp	(date 1714440647094)
@@ -7,6 +7,7 @@
 // License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
 // http://www.boost.org/LICENSE_1_0.txt)
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/codecvt_null.hpp>
Index: cppcoro-src/cppcoro/include/cppcoro/static_thread_pool.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/static_thread_pool.hpp b/cppcoro-src/cppcoro/include/cppcoro/static_thread_pool.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/static_thread_pool.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/static_thread_pool.hpp	(date 1714440647094)
@@ -11,7 +11,7 @@
 #include <thread>
 #include <vector>
 #include <mutex>
-#include <experimental/coroutine>
+#include <coroutine>
 
 namespace cppcoro
 {
@@ -38,7 +38,7 @@
 			schedule_operation(static_thread_pool* tp) noexcept : m_threadPool(tp) {}
 
 			bool await_ready() noexcept { return false; }
-			void await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept;
+			void await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept;
 			void await_resume() noexcept {}
 
 		private:
@@ -46,7 +46,7 @@
 			friend class static_thread_pool;
 
 			static_thread_pool* m_threadPool;
-			std::experimental::coroutine_handle<> m_awaitingCoroutine;
+			std::coroutine_handle<> m_awaitingCoroutine;
 			schedule_operation* m_next;
 
 		};
Index: boost-src/boost/libs/serialization/src/xml_wgrammar.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/xml_wgrammar.cpp b/boost-src/boost/libs/serialization/src/xml_wgrammar.cpp
--- a/boost-src/boost/libs/serialization/src/xml_wgrammar.cpp	(revision a20c4d97c37e5f437c8ba78f296830edb79cff9e)
+++ b/boost-src/boost/libs/serialization/src/xml_wgrammar.cpp	(date 1714440647094)
@@ -14,6 +14,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/impl/basic_xml_grammar.hpp>
Index: openbabel-src/openbabel/src/ops/optransform.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/ops/optransform.cpp b/openbabel-src/openbabel/src/ops/optransform.cpp
--- a/openbabel-src/openbabel/src/ops/optransform.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/ops/optransform.cpp	(date 1714440647094)
@@ -40,9 +40,7 @@
 {
   _dataLoaded=true;
   _transforms.clear();
-  ifstream ifs;
-  if(ifs.is_open())
-    ifs.close();
+  istringstream ifs;
   char charBuffer[BUFF_SIZE];
 
   // Set the locale for number parsing to avoid locale issues: PR#1785463
Index: cppcoro-src/cppcoro/include/cppcoro/sequence_barrier.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/sequence_barrier.hpp b/cppcoro-src/cppcoro/include/cppcoro/sequence_barrier.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/sequence_barrier.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/sequence_barrier.hpp	(date 1714440647094)
@@ -15,7 +15,7 @@
 #include <cstdint>
 #include <limits>
 #include <optional>
-#include <experimental/coroutine>
+#include <coroutine>
 
 namespace cppcoro
 {
@@ -161,7 +161,7 @@
 			return !TRAITS::precedes(m_lastKnownPublished, m_targetSequence);
 		}
 
-		bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+		bool await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 		{
 			m_awaitingCoroutine = awaitingCoroutine;
 			m_barrier.add_awaiter(this);
@@ -192,7 +192,7 @@
 		const SEQUENCE m_targetSequence;
 		SEQUENCE m_lastKnownPublished;
 		sequence_barrier_wait_operation_base* m_next;
-		std::experimental::coroutine_handle<> m_awaitingCoroutine;
+		std::coroutine_handle<> m_awaitingCoroutine;
 		std::atomic<bool> m_readyToResume;
 
 	};
Index: cppcoro-src/cppcoro/include/cppcoro/async_mutex.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/async_mutex.hpp b/cppcoro-src/cppcoro/include/cppcoro/async_mutex.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/async_mutex.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/async_mutex.hpp	(date 1714440647094)
@@ -5,7 +5,7 @@
 #ifndef CPPCORO_ASYNC_MUTEX_HPP_INCLUDED
 #define CPPCORO_ASYNC_MUTEX_HPP_INCLUDED
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <atomic>
 #include <cstdint>
 #include <mutex> // for std::adopt_lock_t
@@ -166,7 +166,7 @@
 		{}
 
 		bool await_ready() const noexcept { return false; }
-		bool await_suspend(std::experimental::coroutine_handle<> awaiter) noexcept;
+		bool await_suspend(std::coroutine_handle<> awaiter) noexcept;
 		void await_resume() const noexcept {}
 
 	protected:
@@ -178,7 +178,7 @@
 	private:
 
 		async_mutex_lock_operation* m_next;
-		std::experimental::coroutine_handle<> m_awaiter;
+		std::coroutine_handle<> m_awaiter;
 
 	};
 
Index: cppcoro-src/cppcoro/include/cppcoro/read_only_file.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/read_only_file.hpp b/cppcoro-src/cppcoro/include/cppcoro/read_only_file.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/read_only_file.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/read_only_file.hpp	(date 1714440647094)
@@ -9,7 +9,7 @@
 #include <cppcoro/file_share_mode.hpp>
 #include <cppcoro/file_buffering_mode.hpp>
 
-#include <experimental/filesystem>
+#include <filesystem>
 
 namespace cppcoro
 {
@@ -43,7 +43,7 @@
 		[[nodiscard]]
 		static read_only_file open(
 			io_service& ioService,
-			const std::experimental::filesystem::path& path,
+			const std::filesystem::path& path,
 			file_share_mode shareMode = file_share_mode::read,
 			file_buffering_mode bufferingMode = file_buffering_mode::default_);
 
Index: boost-src/boost/libs/serialization/src/xml_woarchive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/xml_woarchive.cpp b/boost-src/boost/libs/serialization/src/xml_woarchive.cpp
--- a/boost-src/boost/libs/serialization/src/xml_woarchive.cpp	(revision a20c4d97c37e5f437c8ba78f296830edb79cff9e)
+++ b/boost-src/boost/libs/serialization/src/xml_woarchive.cpp	(date 1714440647094)
@@ -17,6 +17,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/xml_woarchive.hpp>
Index: cppcoro-src/cppcoro/include/cppcoro/async_scope.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/async_scope.hpp b/cppcoro-src/cppcoro/include/cppcoro/async_scope.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/async_scope.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/async_scope.hpp	(date 1714440647094)
@@ -8,7 +8,7 @@
 #include <cppcoro/on_scope_exit.hpp>
 
 #include <atomic>
-#include <experimental/coroutine>
+#include <coroutine>
 #include <type_traits>
 #include <cassert>
 
@@ -52,7 +52,7 @@
 					return m_scope->m_count.load(std::memory_order_acquire) == 0;
 				}
 
-				bool await_suspend(std::experimental::coroutine_handle<> continuation) noexcept
+				bool await_suspend(std::coroutine_handle<> continuation) noexcept
 				{
 					m_scope->m_continuation = continuation;
 					return m_scope->m_count.fetch_sub(1u, std::memory_order_acq_rel) > 1u;
@@ -85,8 +85,8 @@
 		{
 			struct promise_type
 			{
-				std::experimental::suspend_never initial_suspend() { return {}; }
-				std::experimental::suspend_never final_suspend() { return {}; }
+				std::suspend_never initial_suspend() { return {}; }
+				std::suspend_never final_suspend() { return {}; }
 				void unhandled_exception() { std::terminate(); }
 				oneway_task get_return_object() { return {}; }
 				void return_void() {}
@@ -94,7 +94,7 @@
 		};
 
 		std::atomic<size_t> m_count;
-		std::experimental::coroutine_handle<> m_continuation;
+		std::coroutine_handle<> m_continuation;
 
 	};
 }
Index: cppcoro-src/cppcoro/include/cppcoro/file_read_operation.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/file_read_operation.hpp b/cppcoro-src/cppcoro/include/cppcoro/file_read_operation.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/file_read_operation.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/file_read_operation.hpp	(date 1714440647094)
@@ -11,7 +11,7 @@
 
 #include <atomic>
 #include <optional>
-#include <experimental/coroutine>
+#include <coroutine>
 
 #if CPPCORO_OS_WINNT
 # include <cppcoro/detail/win32.hpp>
Index: fluentui-src/fluentui/src/FluTools.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/FluTools.cpp b/fluentui-src/fluentui/src/FluTools.cpp
--- a/fluentui-src/fluentui/src/FluTools.cpp	(revision 5fd7c7d10ed60349b126393c1e5aef8efbf4325e)
+++ b/fluentui-src/fluentui/src/FluTools.cpp	(date 1714440647094)
@@ -281,6 +281,7 @@
             return path;
         }
     }
+    return {};
 #elif defined(Q_OS_MACOS)
     QProcess process;
     QStringList args;
Index: openbabel-src/openbabel/src/ops/gen3d.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/ops/gen3d.cpp b/openbabel-src/openbabel/src/ops/gen3d.cpp
--- a/openbabel-src/openbabel/src/ops/gen3d.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/ops/gen3d.cpp	(date 1714440647094)
@@ -70,8 +70,10 @@
   bool useDistGeom = false;
 
   // first try converting OptionText to an integer
-  char *endptr;
-  speed = strtol(OptionText, &endptr, 10);
+  char *endptr = nullptr;
+  if (OptionText) {
+    speed = strtol(OptionText, &endptr, 10);
+  }
   if (endptr == OptionText) { // not a number
     speed = 3; // we'll default to balanced
     // but let's also check if it's words like "fast" or "best"
@@ -131,12 +133,12 @@
       return true; // done
 
     // All other speed levels do some FF cleanup
-    // Try MMFF94 first and UFF if that doesn't work
-    OBForceField* pFF = OBForceField::FindForceField("MMFF94");
+    // Try UFF first and MMFF94 if that doesn't work
+    OBForceField* pFF = OBForceField::FindForceField("UFF");
     if (!pFF)
       return true;
     if (!pFF->Setup(molCopy)) {
-      pFF = OBForceField::FindForceField("UFF");
+      pFF = OBForceField::FindForceField("MMFF94");
       if (!pFF || !pFF->Setup(molCopy)) return true; // can't use either MMFF94 or UFF
     }
 
Index: cppcoro-src/cppcoro/include/cppcoro/write_only_file.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/write_only_file.hpp b/cppcoro-src/cppcoro/include/cppcoro/write_only_file.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/write_only_file.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/write_only_file.hpp	(date 1714440647094)
@@ -10,7 +10,7 @@
 #include <cppcoro/file_buffering_mode.hpp>
 #include <cppcoro/file_open_mode.hpp>
 
-#include <experimental/filesystem>
+#include <filesystem>
 
 namespace cppcoro
 {
@@ -48,7 +48,7 @@
 		[[nodiscard]]
 		static write_only_file open(
 			io_service& ioService,
-			const std::experimental::filesystem::path& path,
+			const std::filesystem::path& path,
 			file_open_mode openMode = file_open_mode::create_or_open,
 			file_share_mode shareMode = file_share_mode::none,
 			file_buffering_mode bufferingMode = file_buffering_mode::default_);
Index: fluentui-src/fluentui/src/FluApp.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/FluApp.cpp b/fluentui-src/fluentui/src/FluApp.cpp
--- a/fluentui-src/fluentui/src/FluApp.cpp	(revision 5fd7c7d10ed60349b126393c1e5aef8efbf4325e)
+++ b/fluentui-src/fluentui/src/FluApp.cpp	(date 1714441205114)
@@ -31,19 +31,3 @@
         }
     }
 }
-
-[[maybe_unused]] QJsonArray FluApp::iconDatas(const QString &keyword) {
-    QJsonArray arr;
-    QMetaEnum enumType = Fluent_Icons::staticMetaObject.enumerator(Fluent_Icons::staticMetaObject.indexOfEnumerator("Fluent_IconType"));
-    for (int i = 0; i <= enumType.keyCount() - 1; ++i) {
-        QString name = enumType.key(i);
-        int icon = enumType.value(i);
-        if (keyword.isEmpty() || name.contains(keyword)) {
-            QJsonObject obj;
-            obj.insert("name", name);
-            obj.insert("icon", icon);
-            arr.append(obj);
-        }
-    }
-    return arr;
-}
Index: cppcoro-src/cppcoro/include/cppcoro/async_generator.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/async_generator.hpp b/cppcoro-src/cppcoro/include/cppcoro/async_generator.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/async_generator.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/async_generator.hpp	(date 1714440647094)
@@ -12,7 +12,7 @@
 #include <atomic>
 #include <iterator>
 #include <type_traits>
-#include <experimental/coroutine>
+#include <coroutine>
 #include <functional>
 #include <cassert>
 
@@ -45,7 +45,7 @@
 			async_generator_promise_base(const async_generator_promise_base& other) = delete;
 			async_generator_promise_base& operator=(const async_generator_promise_base& other) = delete;
 
-			std::experimental::suspend_always initial_suspend() const noexcept
+			std::suspend_always initial_suspend() const noexcept
 			{
 				return {};
 			}
@@ -89,7 +89,7 @@
 
 			std::exception_ptr m_exception;
 
-			std::experimental::coroutine_handle<> m_consumerCoroutine;
+			std::coroutine_handle<> m_consumerCoroutine;
 
 		protected:
 
@@ -100,7 +100,7 @@
 		{
 		public:
 
-			async_generator_yield_operation(std::experimental::coroutine_handle<> consumer) noexcept
+			async_generator_yield_operation(std::coroutine_handle<> consumer) noexcept
 				: m_consumer(consumer)
 			{}
 
@@ -109,8 +109,8 @@
 				return false;
 			}
 
-			std::experimental::coroutine_handle<>
-			await_suspend([[maybe_unused]] std::experimental::coroutine_handle<> producer) noexcept
+			std::coroutine_handle<>
+			await_suspend([[maybe_unused]] std::coroutine_handle<> producer) noexcept
 			{
 				return m_consumer;
 			}
@@ -119,7 +119,7 @@
 
 		private:
 
-			std::experimental::coroutine_handle<> m_consumer;
+			std::coroutine_handle<> m_consumer;
 
 		};
 
@@ -145,7 +145,7 @@
 
 			async_generator_advance_operation(
 				async_generator_promise_base& promise,
-				std::experimental::coroutine_handle<> producerCoroutine) noexcept
+				std::coroutine_handle<> producerCoroutine) noexcept
 				: m_promise(std::addressof(promise))
 				, m_producerCoroutine(producerCoroutine)
 			{
@@ -155,8 +155,8 @@
 
 			bool await_ready() const noexcept { return false; }
 
-			std::experimental::coroutine_handle<>
-				await_suspend(std::experimental::coroutine_handle<> consumerCoroutine) noexcept
+			std::coroutine_handle<>
+				await_suspend(std::coroutine_handle<> consumerCoroutine) noexcept
 			{
 				m_promise->m_consumerCoroutine = consumerCoroutine;
 				return m_producerCoroutine;
@@ -165,7 +165,7 @@
 		protected:
 
 			async_generator_promise_base* m_promise;
-			std::experimental::coroutine_handle<> m_producerCoroutine;
+			std::coroutine_handle<> m_producerCoroutine;
 
 		};
 
@@ -242,7 +242,7 @@
 		class async_generator_iterator final
 		{
 			using promise_type = async_generator_promise<T>;
-			using handle_type = std::experimental::coroutine_handle<promise_type>;
+			using handle_type = std::coroutine_handle<promise_type>;
 
 		public:
 
@@ -307,7 +307,7 @@
 		class async_generator_begin_operation final : public async_generator_advance_operation
 		{
 			using promise_type = async_generator_promise<T>;
-			using handle_type = std::experimental::coroutine_handle<promise_type>;
+			using handle_type = std::coroutine_handle<promise_type>;
 
 		public:
 
@@ -358,7 +358,7 @@
 		{}
 
 		explicit async_generator(promise_type& promise) noexcept
-			: m_coroutine(std::experimental::coroutine_handle<promise_type>::from_promise(promise))
+			: m_coroutine(std::coroutine_handle<promise_type>::from_promise(promise))
 		{}
 
 		async_generator(async_generator&& other) noexcept
@@ -408,7 +408,7 @@
 
 	private:
 
-		std::experimental::coroutine_handle<promise_type> m_coroutine;
+		std::coroutine_handle<promise_type> m_coroutine;
 
 	};
 
@@ -451,7 +451,7 @@
 			async_generator_promise_base(const async_generator_promise_base& other) = delete;
 			async_generator_promise_base& operator=(const async_generator_promise_base& other) = delete;
 
-			std::experimental::suspend_always initial_suspend() const noexcept
+			std::suspend_always initial_suspend() const noexcept
 			{
 				return {};
 			}
@@ -556,7 +556,7 @@
 
 			std::exception_ptr m_exception;
 
-			std::experimental::coroutine_handle<> m_consumerCoroutine;
+			std::coroutine_handle<> m_consumerCoroutine;
 
 		protected:
 
@@ -579,7 +579,7 @@
 				return m_initialState == state::value_not_ready_consumer_suspended;
 			}
 
-			bool await_suspend(std::experimental::coroutine_handle<> producer) noexcept;
+			bool await_suspend(std::coroutine_handle<> producer) noexcept;
 
 			void await_resume() noexcept {}
 
@@ -625,7 +625,7 @@
 		}
 
 		inline bool async_generator_yield_operation::await_suspend(
-			std::experimental::coroutine_handle<> producer) noexcept
+			std::coroutine_handle<> producer) noexcept
 		{
 			state currentState = m_initialState;
 			if (currentState == state::value_not_ready_consumer_active)
@@ -711,7 +711,7 @@
 
 			async_generator_advance_operation(
 				async_generator_promise_base& promise,
-				std::experimental::coroutine_handle<> producerCoroutine) noexcept
+				std::coroutine_handle<> producerCoroutine) noexcept
 				: m_promise(std::addressof(promise))
 				, m_producerCoroutine(producerCoroutine)
 			{
@@ -740,7 +740,7 @@
 				return m_initialState == state::value_ready_producer_suspended;
 			}
 
-			bool await_suspend(std::experimental::coroutine_handle<> consumerCoroutine) noexcept
+			bool await_suspend(std::coroutine_handle<> consumerCoroutine) noexcept
 			{
 				m_promise->m_consumerCoroutine = consumerCoroutine;
 
@@ -791,7 +791,7 @@
 		protected:
 
 			async_generator_promise_base* m_promise;
-			std::experimental::coroutine_handle<> m_producerCoroutine;
+			std::coroutine_handle<> m_producerCoroutine;
 
 		private:
 
@@ -872,7 +872,7 @@
 		class async_generator_iterator final
 		{
 			using promise_type = async_generator_promise<T>;
-			using handle_type = std::experimental::coroutine_handle<promise_type>;
+			using handle_type = std::coroutine_handle<promise_type>;
 
 		public:
 
@@ -937,7 +937,7 @@
 		class async_generator_begin_operation final : public async_generator_advance_operation
 		{
 			using promise_type = async_generator_promise<T>;
-			using handle_type = std::experimental::coroutine_handle<promise_type>;
+			using handle_type = std::coroutine_handle<promise_type>;
 
 		public:
 
@@ -988,7 +988,7 @@
 		{}
 
 		explicit async_generator(promise_type& promise) noexcept
-			: m_coroutine(std::experimental::coroutine_handle<promise_type>::from_promise(promise))
+			: m_coroutine(std::coroutine_handle<promise_type>::from_promise(promise))
 		{}
 
 		async_generator(async_generator&& other) noexcept
@@ -1041,7 +1041,7 @@
 
 	private:
 
-		std::experimental::coroutine_handle<promise_type> m_coroutine;
+		std::coroutine_handle<promise_type> m_coroutine;
 
 	};
 
Index: boost-src/boost/libs/serialization/src/text_wiarchive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/text_wiarchive.cpp b/boost-src/boost/libs/serialization/src/text_wiarchive.cpp
--- a/boost-src/boost/libs/serialization/src/text_wiarchive.cpp	(revision a20c4d97c37e5f437c8ba78f296830edb79cff9e)
+++ b/boost-src/boost/libs/serialization/src/text_wiarchive.cpp	(date 1714440647094)
@@ -14,6 +14,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/text_wiarchive.hpp>
Index: taskflow-src/taskflow/taskflow/taskflow.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/taskflow-src/taskflow/taskflow/taskflow.hpp b/taskflow-src/taskflow/taskflow/taskflow.hpp
--- a/taskflow-src/taskflow/taskflow/taskflow.hpp	(revision 12f8bd4e970ab27fd3dee3bffa24b5b48b54ba39)
+++ b/taskflow-src/taskflow/taskflow/taskflow.hpp	(date 1714440647094)
@@ -3,6 +3,7 @@
 #include "core/executor.hpp"
 #include "core/async.hpp"
 #include "algorithm/critical.hpp"
+#include "algorithm/for_each.hpp"
 
 /**
 @dir taskflow
Index: boost-src/boost/libs/serialization/src/binary_woarchive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/binary_woarchive.cpp b/boost-src/boost/libs/serialization/src/binary_woarchive.cpp
--- a/boost-src/boost/libs/serialization/src/binary_woarchive.cpp	(revision a20c4d97c37e5f437c8ba78f296830edb79cff9e)
+++ b/boost-src/boost/libs/serialization/src/binary_woarchive.cpp	(date 1714440647094)
@@ -14,6 +14,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/archive/binary_woarchive.hpp>
 
Index: openbabel-src/openbabel/src/depict/depict.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/depict/depict.cpp b/openbabel-src/openbabel/src/depict/depict.cpp
--- a/openbabel-src/openbabel/src/depict/depict.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/depict/depict.cpp	(date 1714440647094)
@@ -1235,7 +1235,7 @@
                       end.x() - offset.x(), end.y() - offset.y());
 
     static const float dashpattern[] = {5., 5.};
-    static const vector<double> pat = vector<double>(dashpattern,dashpattern + sizeof(dashpattern)/sizeof(double));
+    static const vector<double> pat = vector<double>(dashpattern, dashpattern + sizeof(dashpattern)/sizeof(float));
     painter->DrawLine(begin.x() + offset.x(), begin.y() + offset.y(),
                       end.x() + offset.x(), end.y() + offset.y(), pat);
   }
Index: boost-src/boost/libs/serialization/src/text_woarchive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/text_woarchive.cpp b/boost-src/boost/libs/serialization/src/text_woarchive.cpp
--- a/boost-src/boost/libs/serialization/src/text_woarchive.cpp	(revision a20c4d97c37e5f437c8ba78f296830edb79cff9e)
+++ b/boost-src/boost/libs/serialization/src/text_woarchive.cpp	(date 1714440647094)
@@ -13,6 +13,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/text_woarchive.hpp>
Index: boost-src/boost/libs/serialization/src/basic_text_woprimitive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/basic_text_woprimitive.cpp b/boost-src/boost/libs/serialization/src/basic_text_woprimitive.cpp
--- a/boost-src/boost/libs/serialization/src/basic_text_woprimitive.cpp	(revision a20c4d97c37e5f437c8ba78f296830edb79cff9e)
+++ b/boost-src/boost/libs/serialization/src/basic_text_woprimitive.cpp	(date 1714440647094)
@@ -20,6 +20,7 @@
 #  pragma warning (disable : 4786) // too long name, harmless warning
 #endif
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/detail/auto_link_warchive.hpp>
Index: boost-src/boost/libs/serialization/src/basic_text_wiprimitive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/basic_text_wiprimitive.cpp b/boost-src/boost/libs/serialization/src/basic_text_wiprimitive.cpp
--- a/boost-src/boost/libs/serialization/src/basic_text_wiprimitive.cpp	(revision a20c4d97c37e5f437c8ba78f296830edb79cff9e)
+++ b/boost-src/boost/libs/serialization/src/basic_text_wiprimitive.cpp	(date 1714440647094)
@@ -20,6 +20,7 @@
 #  pragma warning (disable : 4786) // too long name, harmless warning
 #endif
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/detail/auto_link_warchive.hpp>
Index: openbabel-src/openbabel/src/math/matrix3x3.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/math/matrix3x3.cpp b/openbabel-src/openbabel/src/math/matrix3x3.cpp
--- a/openbabel-src/openbabel/src/math/matrix3x3.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/math/matrix3x3.cpp	(date 1714440647094)
@@ -545,7 +545,7 @@
     eigenvectors. The eigenvectors are normalized and mutually
     orthogonal.
   */
-  void matrix3x3::jacobi(unsigned int n, double *a, double *d, double *v)
+  void matrix3x3::jacobi(int n, double *a, double *d, double *v)
   {
     double onorm, dnorm;
     double b, dma, q, t, c, s;
@@ -557,9 +557,9 @@
 
     // Set v to the identity matrix, set the vector d to contain the
     // diagonal elements of the matrix a
-    for (j = 0; j < static_cast<int>(n); j++)
+    for (j = 0; j < n; j++)
       {
-        for (i = 0; i < static_cast<int>(n); i++)
+        for (i = 0; i < n; i++)
           v[n*i+j] = 0.0;
         v[n*j+j] = 1.0;
         d[j] = a[n*j+j];
@@ -572,7 +572,7 @@
         // onorm to the maximum norm of the off-diagonal elements
         dnorm = 0.0;
         onorm = 0.0;
-        for (j = 0; j < static_cast<int>(n); j++)
+        for (j = 0; j < n; j++)
           {
             dnorm += (double)fabs(d[j]);
             for (i = 0; i < j; i++)
@@ -582,7 +582,7 @@
         if((onorm/dnorm) <= 1.0e-12)
           goto Exit_now;
 
-        for (j = 1; j < static_cast<int>(n); j++)
+        for (j = 1; j < n; j++)
           {
             for (i = 0; i <= j - 1; i++)
               {
@@ -619,14 +619,14 @@
                         a[n*i+k] = atemp;
                       }
 
-                    for (k = j+1; k < static_cast<int>(n); k++)
+                    for (k = j+1; k < n; k++)
                       {
                         atemp = c * a[n*i+k] - s * a[n*j+k];
                         a[n*j+k] = s * a[n*i+k] + c * a[n*j+k];
                         a[n*i+k] = atemp;
                       }
 
-                    for (k = 0; k < static_cast<int>(n); k++)
+                    for (k = 0; k < n; k++)
                       {
                         vtemp = c * v[n*k+i] - s * v[n*k+j];
                         v[n*k+j] = s * v[n*k+i] + c * v[n*k+j];
@@ -647,11 +647,11 @@
     // smallest eigenvalues come first.
     nrot = l;
 
-    for (j = 0; j < static_cast<int>(n)-1; j++)
+    for (j = 0; j < n-1; j++)
       {
         k = j;
         dtemp = d[k];
-        for (i = j+1; i < static_cast<int>(n); i++)
+        for (i = j+1; i < n; i++)
           if(d[i] < dtemp)
             {
               k = i;
@@ -662,7 +662,7 @@
           {
             d[k] = d[j];
             d[j] = dtemp;
-            for (i = 0; i < static_cast<int>(n); i++)
+            for (i = 0; i < n; i++)
               {
                 dtemp = v[n*i+k];
                 v[n*i+k] = v[n*i+j];
Index: cppcoro-src/cppcoro/include/cppcoro/detail/when_all_ready_awaitable.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_ready_awaitable.hpp b/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_ready_awaitable.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_ready_awaitable.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_ready_awaitable.hpp	(date 1714440647094)
@@ -7,7 +7,7 @@
 
 #include <cppcoro/detail/when_all_counter.hpp>
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <tuple>
 
 namespace cppcoro
@@ -26,7 +26,7 @@
 			explicit constexpr when_all_ready_awaitable(std::tuple<>) noexcept {}
 
 			constexpr bool await_ready() const noexcept { return true; }
-			void await_suspend(std::experimental::coroutine_handle<>) noexcept {}
+			void await_suspend(std::coroutine_handle<>) noexcept {}
 			std::tuple<> await_resume() const noexcept { return {}; }
 
 		};
@@ -66,7 +66,7 @@
 						return m_awaitable.is_ready();
 					}
 
-					bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+					bool await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 					{
 						return m_awaitable.try_await(awaitingCoroutine);
 					}
@@ -98,7 +98,7 @@
 						return m_awaitable.is_ready();
 					}
 
-					bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+					bool await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 					{
 						return m_awaitable.try_await(awaitingCoroutine);
 					}
@@ -124,7 +124,7 @@
 				return m_counter.is_ready();
 			}
 
-			bool try_await(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+			bool try_await(std::coroutine_handle<> awaitingCoroutine) noexcept
 			{
 				start_tasks(std::make_integer_sequence<std::size_t, sizeof...(TASKS)>{});
 				return m_counter.try_await(awaitingCoroutine);
@@ -177,7 +177,7 @@
 						return m_awaitable.is_ready();
 					}
 
-					bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+					bool await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 					{
 						return m_awaitable.try_await(awaitingCoroutine);
 					}
@@ -212,7 +212,7 @@
 						return m_awaitable.is_ready();
 					}
 
-					bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+					bool await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 					{
 						return m_awaitable.try_await(awaitingCoroutine);
 					}
@@ -238,7 +238,7 @@
 				return m_counter.is_ready();
 			}
 
-			bool try_await(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+			bool try_await(std::coroutine_handle<> awaitingCoroutine) noexcept
 			{
 				for (auto&& task : m_tasks)
 				{
Index: indigo-src/indigo/core/indigo-core/common/base_c/defs.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/common/base_c/defs.h b/indigo-src/indigo/core/indigo-core/common/base_c/defs.h
--- a/indigo-src/indigo/core/indigo-core/common/base_c/defs.h	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/core/indigo-core/common/base_c/defs.h	(date 1714440647094)
@@ -19,9 +19,7 @@
 #ifndef __defs_h__
 #define __defs_h__
 
-#if !defined(__sign)
-#define __sign(a) (a > 0 ? 1 : (a < 0 ? -1 : 0))
-#endif
+#include "indigo_core_export.h"
 
 #if defined(_WIN32) && !defined(__MINGW32__)
 // #define vsnprintf _vsnprintf
@@ -67,26 +65,12 @@
 #endif
 
 #ifndef EXPORT_SYMBOL
-#ifdef _WIN32
-#define EXPORT_SYMBOL __declspec(dllexport)
-#elif (defined __GNUC__ || defined __APPLE__)
-#define EXPORT_SYMBOL __attribute__((visibility("default")))
-#else
-#define EXPORT_SYMBOL
-#endif
+#define EXPORT_SYMBOL INDIGO_CORE_EXPORT
 #endif
 
 #ifndef DLLEXPORT
-#ifdef _WIN32
-#ifdef INDIGO_PLUGIN
-#define DLLEXPORT __declspec(dllimport)
-#else
-#define DLLEXPORT EXPORT_SYMBOL
-#endif
-#else
 #define DLLEXPORT EXPORT_SYMBOL
 #endif
-#endif
 
 #ifndef CEXPORT
 #ifndef __cplusplus
Index: cppcoro-src/cppcoro/include/cppcoro/net/socket_accept_operation.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/net/socket_accept_operation.hpp b/cppcoro-src/cppcoro/include/cppcoro/net/socket_accept_operation.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/net/socket_accept_operation.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/net/socket_accept_operation.hpp	(date 1714440647094)
@@ -15,7 +15,7 @@
 
 # include <atomic>
 # include <optional>
-# include <experimental/coroutine>
+# include <coroutine>
 
 namespace cppcoro
 {
Index: cppcoro-src/cppcoro/include/cppcoro/detail/sync_wait_task.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/detail/sync_wait_task.hpp b/cppcoro-src/cppcoro/include/cppcoro/detail/sync_wait_task.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/detail/sync_wait_task.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/detail/sync_wait_task.hpp	(date 1714440647094)
@@ -9,7 +9,7 @@
 #include <cppcoro/awaitable_traits.hpp>
 #include <cppcoro/detail/lightweight_manual_reset_event.hpp>
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <cassert>
 #include <exception>
 #include <utility>
@@ -24,7 +24,7 @@
 		template<typename RESULT>
 		class sync_wait_task_promise final
 		{
-			using coroutine_handle_t = std::experimental::coroutine_handle<sync_wait_task_promise<RESULT>>;
+			using coroutine_handle_t = std::coroutine_handle<sync_wait_task_promise<RESULT>>;
 
 		public:
 
@@ -44,7 +44,7 @@
 				return coroutine_handle_t::from_promise(*this);
 			}
 
-			std::experimental::suspend_always initial_suspend() noexcept
+			std::suspend_always initial_suspend() noexcept
 			{
 				return{};
 			}
@@ -89,7 +89,7 @@
 					bool await_ready() noexcept {
 						return true;
 					}
-					void await_suspend(std::experimental::coroutine_handle<>) noexcept {}
+					void await_suspend(std::coroutine_handle<>) noexcept {}
 					sync_wait_task_promise& await_resume() noexcept
 					{
 						return *m_promise;
@@ -140,7 +140,7 @@
 		template<>
 		class sync_wait_task_promise<void>
 		{
-			using coroutine_handle_t = std::experimental::coroutine_handle<sync_wait_task_promise<void>>;
+			using coroutine_handle_t = std::coroutine_handle<sync_wait_task_promise<void>>;
 
 		public:
 
@@ -158,7 +158,7 @@
 				return coroutine_handle_t::from_promise(*this);
 			}
 
-			std::experimental::suspend_always initial_suspend() noexcept
+			std::suspend_always initial_suspend() noexcept
 			{
 				return{};
 			}
@@ -211,7 +211,7 @@
 
 			using promise_type = sync_wait_task_promise<RESULT>;
 
-			using coroutine_handle_t = std::experimental::coroutine_handle<promise_type>;
+			using coroutine_handle_t = std::coroutine_handle<promise_type>;
 
 			sync_wait_task(coroutine_handle_t coroutine) noexcept
 				: m_coroutine(coroutine)
Index: cppcoro-src/cppcoro/include/cppcoro/detail/when_all_counter.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_counter.hpp b/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_counter.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_counter.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_counter.hpp	(date 1714440647094)
@@ -5,7 +5,7 @@
 #ifndef CPPCORO_DETAIL_WHEN_ALL_COUNTER_HPP_INCLUDED
 #define CPPCORO_DETAIL_WHEN_ALL_COUNTER_HPP_INCLUDED
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <atomic>
 #include <cstdint>
 
@@ -29,7 +29,7 @@
 				return static_cast<bool>(m_awaitingCoroutine);
 			}
 
-			bool try_await(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+			bool try_await(std::coroutine_handle<> awaitingCoroutine) noexcept
 			{
 				m_awaitingCoroutine = awaitingCoroutine;
 				return m_count.fetch_sub(1, std::memory_order_acq_rel) > 1;
@@ -46,7 +46,7 @@
 		protected:
 
 			std::atomic<std::size_t> m_count;
-			std::experimental::coroutine_handle<> m_awaitingCoroutine;
+			std::coroutine_handle<> m_awaitingCoroutine;
 
 		};
 	}
Index: arrow-src/arrow/cpp/src/arrow/acero/visibility.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/arrow-src/arrow/cpp/src/arrow/acero/visibility.h b/arrow-src/arrow/cpp/src/arrow/acero/visibility.h
--- a/arrow-src/arrow/cpp/src/arrow/acero/visibility.h	(revision 6a28035c2b49b432dc63f5ee7524d76b4ed2d762)
+++ b/arrow-src/arrow/cpp/src/arrow/acero/visibility.h	(date 1714440647094)
@@ -18,32 +18,15 @@
 // This API is EXPERIMENTAL.
 
 #pragma once
-
-#if defined(_WIN32) || defined(__CYGWIN__)
-#if defined(_MSC_VER)
-#pragma warning(push)
-#pragma warning(disable : 4251)
-#else
-#pragma GCC diagnostic ignored "-Wattributes"
-#endif
+#include <arrow/util/visibility.h>
 
-#ifdef ARROW_ACERO_STATIC
-#define ARROW_ACERO_EXPORT
-#elif defined(ARROW_ACERO_EXPORTING)
-#define ARROW_ACERO_EXPORT __declspec(dllexport)
-#else
-#define ARROW_ACERO_EXPORT __declspec(dllimport)
-#endif
-
-#define ARROW_ACERO_NO_EXPORT
-#else  // Not Windows
 #ifndef ARROW_ACERO_EXPORT
-#define ARROW_ACERO_EXPORT __attribute__((visibility("default")))
+#define ARROW_ACERO_EXPORT ARROW_EXPORT
 #endif
+
 #ifndef ARROW_ACERO_NO_EXPORT
-#define ARROW_ACERO_NO_EXPORT __attribute__((visibility("hidden")))
+#define ARROW_ACERO_NO_EXPORT ARROW_NO_EXPORT
 #endif
-#endif  // Not-Windows
 
 #if defined(_MSC_VER)
 #pragma warning(pop)
Index: fluentui-src/fluentui/src/FluTreeModel.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/FluTreeModel.cpp b/fluentui-src/fluentui/src/FluTreeModel.cpp
--- a/fluentui-src/fluentui/src/FluTreeModel.cpp	(revision 5fd7c7d10ed60349b126393c1e5aef8efbf4325e)
+++ b/fluentui-src/fluentui/src/FluTreeModel.cpp	(date 1714440647094)
@@ -101,7 +101,7 @@
             QList<FluTreeNode *> children = item->_children;
             if (!children.isEmpty()) {
                 std::reverse(children.begin(), children.end());
-                        foreach (auto c, children) {
+                        Q_FOREACH (auto c, children) {
                         stack.append(c);
                     }
             }
@@ -195,7 +195,7 @@
         QList<FluTreeNode *> children = item->_children;
         if (!children.isEmpty()) {
             std::reverse(children.begin(), children.end());
-                    foreach (auto c, children) {
+                    Q_FOREACH (auto c, children) {
                     stack.append(c);
                 }
         }
@@ -234,7 +234,7 @@
         QList<FluTreeNode *> children = item->_children;
         if (!children.isEmpty()) {
             std::reverse(children.begin(), children.end());
-                    foreach (auto c, children) {
+                    Q_FOREACH (auto c, children) {
                     stack.append(c);
                 }
         }
@@ -256,7 +256,7 @@
         QList<FluTreeNode *> children = item->_children;
         if (!children.isEmpty()) {
             std::reverse(children.begin(), children.end());
-                    foreach (auto c, children) {
+                    Q_FOREACH (auto c, children) {
                     stack.append(c);
                 }
         }
@@ -267,7 +267,7 @@
 
 QVariant FluTreeModel::selectionModel(){
     QList<FluTreeNode *> data;
-    foreach (auto item, _dataSource) {
+    Q_FOREACH (auto item, _dataSource) {
         if (item->checked()) {
             data.append(item);
         }
Index: openbabel-src/openbabel/src/charges/eqeq.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/charges/eqeq.cpp b/openbabel-src/openbabel/src/charges/eqeq.cpp
--- a/openbabel-src/openbabel/src/charges/eqeq.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/charges/eqeq.cpp	(date 1714440647094)
@@ -15,7 +15,7 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 ***********************************************************************/
-
+#include <openbabel/babelconfig.h>
 #ifdef HAVE_EIGEN3
 
 #include "eqeq.h"
@@ -52,7 +52,7 @@
     char buffer[BUFF_SIZE];
 
     // open data/eqeqIonizations.txt
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "eqeqIonizations.txt").length() == 0)
     {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open eqeqIonizations.txt", obError);
Index: boost-src/boost/libs/serialization/src/binary_wiarchive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/binary_wiarchive.cpp b/boost-src/boost/libs/serialization/src/binary_wiarchive.cpp
--- a/boost-src/boost/libs/serialization/src/binary_wiarchive.cpp	(revision a20c4d97c37e5f437c8ba78f296830edb79cff9e)
+++ b/boost-src/boost/libs/serialization/src/binary_wiarchive.cpp	(date 1714440647094)
@@ -14,6 +14,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/archive/binary_wiarchive.hpp>
 #include <boost/archive/detail/archive_serializer_map.hpp>
Index: openbabel-src/openbabel/src/stereo/perception.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/stereo/perception.cpp b/openbabel-src/openbabel/src/stereo/perception.cpp
--- a/openbabel-src/openbabel/src/stereo/perception.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/stereo/perception.cpp	(date 1714440647094)
@@ -2969,9 +2969,6 @@
   }
 
   void StereoRefToImplicit(OBMol& mol, OBStereo::Ref atomId) {
-    // The following is for use in replace_if(...) below
-    const std::binder1st<std::equal_to<OBStereo::Ref> > equal_to_atomId = std::bind1st (equal_to<OBStereo::Ref>(), atomId);
-
     std::vector<OBGenericData*> vdata = mol.GetAllData(OBGenericDataType::StereoData);
     for (std::vector<OBGenericData*>::iterator data = vdata.begin(); data != vdata.end(); ++data) {
       OBStereo::Type datatype = ((OBStereoBase*)*data)->GetType();
@@ -2987,23 +2984,20 @@
       if (datatype == OBStereo::CisTrans) {
         OBCisTransStereo *ct = dynamic_cast<OBCisTransStereo*>(*data);
         OBCisTransStereo::Config ct_cfg = ct->GetConfig();
-        replace_if(ct_cfg.refs.begin(), ct_cfg.refs.end(), equal_to_atomId, (OBStereo::Ref) OBStereo::ImplicitRef);
+        replace(ct_cfg.refs.begin(), ct_cfg.refs.end(), atomId, (OBStereo::Ref) OBStereo::ImplicitRef);
         ct->SetConfig(ct_cfg);
       }
       else if (datatype == OBStereo::Tetrahedral) {
         OBTetrahedralStereo *ts = dynamic_cast<OBTetrahedralStereo*>(*data);
         OBTetrahedralStereo::Config ts_cfg = ts->GetConfig();
         if (ts_cfg.from == atomId) ts_cfg.from = OBStereo::ImplicitRef;
-        replace_if(ts_cfg.refs.begin(), ts_cfg.refs.end(), equal_to_atomId, (OBStereo::Ref) OBStereo::ImplicitRef);
+        replace(ts_cfg.refs.begin(), ts_cfg.refs.end(), atomId, (OBStereo::Ref) OBStereo::ImplicitRef);
         ts->SetConfig(ts_cfg);
       }
     }
   }
 
   void ImplicitRefToStereo(OBMol& mol, OBStereo::Ref centerId, OBStereo::Ref newId) {
-    // The following is for use in replace_if(...) below
-    const std::binder1st<std::equal_to<OBStereo::Ref> > equal_to_implicitRef = std::bind1st (equal_to<OBStereo::Ref>(), (OBStereo::Ref) OBStereo::ImplicitRef);
-
     std::vector<OBGenericData*> vdata = mol.GetAllData(OBGenericDataType::StereoData);
     for (std::vector<OBGenericData*>::iterator data = vdata.begin(); data != vdata.end(); ++data) {
       OBStereo::Type datatype = ((OBStereoBase*)*data)->GetType();
@@ -3022,9 +3016,9 @@
         if (ct_cfg.begin == centerId || ct_cfg.end == centerId) {
           // Assumption: the first two refs are on the begin atom, the last two on the end atom
           if (ct_cfg.begin == centerId)
-            replace_if(ct_cfg.refs.begin(), ct_cfg.refs.begin()+2, equal_to_implicitRef, (OBStereo::Ref) newId);
+            replace(ct_cfg.refs.begin(), ct_cfg.refs.begin()+2, (OBStereo::Ref) OBStereo::ImplicitRef, (OBStereo::Ref) newId);
           if (ct_cfg.end == centerId)
-            replace_if(ct_cfg.refs.begin()+2, ct_cfg.refs.end(), equal_to_implicitRef, (OBStereo::Ref) newId);
+            replace(ct_cfg.refs.begin()+2, ct_cfg.refs.end(), (OBStereo::Ref) OBStereo::ImplicitRef, (OBStereo::Ref) newId);
           ct->SetConfig(ct_cfg);
         }
       }
@@ -3033,7 +3027,7 @@
         OBTetrahedralStereo::Config ts_cfg = ts->GetConfig();
         if (ts_cfg.center == centerId) {
           if (ts_cfg.from == OBStereo::ImplicitRef) ts_cfg.from = newId;
-          replace_if(ts_cfg.refs.begin(), ts_cfg.refs.end(), equal_to_implicitRef, (OBStereo::Ref) newId);
+          replace(ts_cfg.refs.begin(), ts_cfg.refs.end(), (OBStereo::Ref) OBStereo::ImplicitRef, (OBStereo::Ref) newId);
           ts->SetConfig(ts_cfg);
         }
       }
Index: fluentui-src/fluentui/src/FluApp.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/FluApp.h b/fluentui-src/fluentui/src/FluApp.h
--- a/fluentui-src/fluentui/src/FluApp.h	(revision 5fd7c7d10ed60349b126393c1e5aef8efbf4325e)
+++ b/fluentui-src/fluentui/src/FluApp.h	(date 1714441205118)
@@ -36,8 +36,6 @@
 
     Q_INVOKABLE void init(QObject *target, QLocale locale = QLocale::system());
 
-    [[maybe_unused]] Q_INVOKABLE static QJsonArray iconDatas(const QString &keyword = "");
-
 private:
     QQmlEngine *_engine{};
     QTranslator *_translator = nullptr;
Index: arrow-src/arrow/cpp/src/arrow/engine/substrait/visibility.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/arrow-src/arrow/cpp/src/arrow/engine/substrait/visibility.h b/arrow-src/arrow/cpp/src/arrow/engine/substrait/visibility.h
--- a/arrow-src/arrow/cpp/src/arrow/engine/substrait/visibility.h	(revision 6a28035c2b49b432dc63f5ee7524d76b4ed2d762)
+++ b/arrow-src/arrow/cpp/src/arrow/engine/substrait/visibility.h	(date 1714440647094)
@@ -21,6 +21,14 @@
 
 #pragma once
 
+#ifndef ARROW_ENGINE_EXPORT
+#define ARROW_ENGINE_EXPORT ARROW_EXPORT
+#endif
+
+#ifndef ARROW_ENGINE_NO_EXPORT
+#define ARROW_ENGINE_NO_EXPORT ARROW_NO_EXPORT
+#endif
+
 #if defined(_WIN32) || defined(__CYGWIN__)
 #if defined(_MSC_VER)
 #pragma warning(push)
@@ -28,23 +36,6 @@
 #else
 #pragma GCC diagnostic ignored "-Wattributes"
 #endif
-
-#ifdef ARROW_ENGINE_STATIC
-#define ARROW_ENGINE_EXPORT
-#elif defined(ARROW_ENGINE_EXPORTING)
-#define ARROW_ENGINE_EXPORT __declspec(dllexport)
-#else
-#define ARROW_ENGINE_EXPORT __declspec(dllimport)
-#endif
-
-#define ARROW_ENGINE_NO_EXPORT
-#else  // Not Windows
-#ifndef ARROW_ENGINE_EXPORT
-#define ARROW_ENGINE_EXPORT __attribute__((visibility("default")))
-#endif
-#ifndef ARROW_ENGINE_NO_EXPORT
-#define ARROW_ENGINE_NO_EXPORT __attribute__((visibility("hidden")))
-#endif
 #endif  // Non-Windows
 
 #if defined(_MSC_VER)
Index: openbabel-src/openbabel/src/charges/qeq.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/charges/qeq.cpp b/openbabel-src/openbabel/src/charges/qeq.cpp
--- a/openbabel-src/openbabel/src/charges/qeq.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/charges/qeq.cpp	(date 1714440647094)
@@ -15,7 +15,7 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 ***********************************************************************/
-
+#include <openbabel/babelconfig.h>
 #ifdef HAVE_EIGEN
 
 #include "qeq.h"
@@ -125,7 +125,7 @@
     char buffer[BUFF_SIZE];
 
     // open data/qeq.txt
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "qeq.txt").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open qeq.txt", obError);
       return;
Index: cppcoro-src/cppcoro/include/cppcoro/detail/when_all_task.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_task.hpp b/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_task.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_task.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_task.hpp	(date 1714440647094)
@@ -10,7 +10,7 @@
 #include <cppcoro/detail/when_all_counter.hpp>
 #include <cppcoro/detail/void_value.hpp>
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <cassert>
 
 namespace cppcoro
@@ -28,7 +28,7 @@
 		{
 		public:
 
-			using coroutine_handle_t = std::experimental::coroutine_handle<when_all_task_promise<RESULT>>;
+			using coroutine_handle_t = std::coroutine_handle<when_all_task_promise<RESULT>>;
 
 			when_all_task_promise() noexcept
 			{}
@@ -38,7 +38,7 @@
 				return coroutine_handle_t::from_promise(*this);
 			}
 
-			std::experimental::suspend_always initial_suspend() noexcept
+			std::suspend_always initial_suspend() noexcept
 			{
 				return{};
 			}
@@ -97,7 +97,7 @@
 					bool await_ready() noexcept {
 						return true;
 					}
-					void await_suspend(std::experimental::coroutine_handle<>) noexcept {}
+					void await_suspend(std::coroutine_handle<>) noexcept {}
 					when_all_task_promise& await_resume() noexcept
 					{
 						return *m_promise;
@@ -155,7 +155,7 @@
 		{
 		public:
 
-			using coroutine_handle_t = std::experimental::coroutine_handle<when_all_task_promise<void>>;
+			using coroutine_handle_t = std::coroutine_handle<when_all_task_promise<void>>;
 
 			when_all_task_promise() noexcept
 			{}
@@ -165,7 +165,7 @@
 				return coroutine_handle_t::from_promise(*this);
 			}
 
-			std::experimental::suspend_always initial_suspend() noexcept
+			std::suspend_always initial_suspend() noexcept
 			{
 				return{};
 			}
Index: openbabel-src/openbabel/src/charges/eem.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/charges/eem.cpp b/openbabel-src/openbabel/src/charges/eem.cpp
--- a/openbabel-src/openbabel/src/charges/eem.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/charges/eem.cpp	(date 1714440647094)
@@ -92,7 +92,7 @@
 
   void EEMCharges::_loadParameters()
   {
-    std::ifstream ifs;
+    std::istringstream ifs;
     if (!OpenDatafile(ifs, _parameters_file).length()) {
       obErrorLog.ThrowError(__FUNCTION__, std::string("Cannot open file with parameters: ").append(_parameters_file), obError);
       return;
Index: cppcoro-src/cppcoro/include/cppcoro/detail/win32_overlapped_operation.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/detail/win32_overlapped_operation.hpp b/cppcoro-src/cppcoro/include/cppcoro/detail/win32_overlapped_operation.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/detail/win32_overlapped_operation.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/detail/win32_overlapped_operation.hpp	(date 1714440647094)
@@ -13,7 +13,7 @@
 
 #include <optional>
 #include <system_error>
-#include <experimental/coroutine>
+#include <coroutine>
 #include <cassert>
 
 namespace cppcoro
@@ -100,7 +100,7 @@
 			bool await_ready() const noexcept { return false; }
 
 			CPPCORO_NOINLINE
-			bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine)
+			bool await_suspend(std::coroutine_handle<> awaitingCoroutine)
 			{
 				static_assert(std::is_base_of_v<win32_overlapped_operation, OPERATION>);
 
@@ -127,7 +127,7 @@
 				operation->m_awaitingCoroutine.resume();
 			}
 
-			std::experimental::coroutine_handle<> m_awaitingCoroutine;
+			std::coroutine_handle<> m_awaitingCoroutine;
 
 		};
 
@@ -186,7 +186,7 @@
 			}
 
 			CPPCORO_NOINLINE
-			bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine)
+			bool await_suspend(std::coroutine_handle<> awaitingCoroutine)
 			{
 				static_assert(std::is_base_of_v<win32_overlapped_operation_cancellable, OPERATION>);
 
@@ -367,7 +367,7 @@
 			std::atomic<state> m_state;
 			cppcoro::cancellation_token m_cancellationToken;
 			std::optional<cppcoro::cancellation_registration> m_cancellationCallback;
-			std::experimental::coroutine_handle<> m_awaitingCoroutine;
+			std::coroutine_handle<> m_awaitingCoroutine;
 
 		};
 	}
Index: openbabel-src/openbabel/src/charges/qtpie.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/charges/qtpie.cpp b/openbabel-src/openbabel/src/charges/qtpie.cpp
--- a/openbabel-src/openbabel/src/charges/qtpie.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/charges/qtpie.cpp	(date 1714440647094)
@@ -15,7 +15,7 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 ***********************************************************************/
-
+#include <openbabel/babelconfig.h>
 #ifdef HAVE_EIGEN
 
 #include "qtpie.h"
@@ -117,7 +117,7 @@
     char buffer[BUFF_SIZE];
 
     // open data/qeq.txt
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "qeq.txt").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open qeq.txt", obError);
       return;
Index: indigo-src/indigo/core/indigo-core/common/base_cpp/output.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/common/base_cpp/output.h b/indigo-src/indigo/core/indigo-core/common/base_cpp/output.h
--- a/indigo-src/indigo/core/indigo-core/common/base_cpp/output.h	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/core/indigo-core/common/base_cpp/output.h	(date 1714440647094)
@@ -24,6 +24,7 @@
 #include "base_cpp/array.h"
 #include "base_cpp/exception.h"
 #include "base_cpp/io_base.h"
+#include <cstdint>
 
 namespace indigo
 {
@@ -51,7 +52,7 @@
         void writeChar(char value);
         void writeBinaryInt(int value);
         void writeBinaryWord(word value);
-        void writeBinaryUInt16(uint16_t value);
+        void writeBinaryUInt16(std::uint16_t value);
 
         void writeBinaryFloat(float value);
         void writePackedShort(short value);
Index: cppcoro-src/cppcoro/include/cppcoro/detail/is_awaiter.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/detail/is_awaiter.hpp b/cppcoro-src/cppcoro/include/cppcoro/detail/is_awaiter.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/detail/is_awaiter.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/detail/is_awaiter.hpp	(date 1714440647094)
@@ -6,7 +6,7 @@
 #define CPPCORO_DETAIL_IS_AWAITER_HPP_INCLUDED
 
 #include <type_traits>
-#include <experimental/coroutine>
+#include <coroutine>
 
 namespace cppcoro
 {
@@ -18,7 +18,7 @@
 		{};
 
 		template<typename PROMISE>
-		struct is_coroutine_handle<std::experimental::coroutine_handle<PROMISE>>
+		struct is_coroutine_handle<std::coroutine_handle<PROMISE>>
 			: std::true_type
 		{};
 
@@ -42,12 +42,12 @@
 		template<typename T>
 		struct is_awaiter<T, std::void_t<
 			decltype(std::declval<T>().await_ready()),
-			decltype(std::declval<T>().await_suspend(std::declval<std::experimental::coroutine_handle<>>())),
+			decltype(std::declval<T>().await_suspend(std::declval<std::coroutine_handle<>>())),
 			decltype(std::declval<T>().await_resume())>> :
 			std::conjunction<
 				std::is_constructible<bool, decltype(std::declval<T>().await_ready())>,
 				detail::is_valid_await_suspend_return_value<
-					decltype(std::declval<T>().await_suspend(std::declval<std::experimental::coroutine_handle<>>()))>>
+					decltype(std::declval<T>().await_suspend(std::declval<std::coroutine_handle<>>()))>>
 		{};
 	}
 }
Index: indigo-src/indigo/core/indigo-core/common/base_cpp/output.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/common/base_cpp/output.cpp b/indigo-src/indigo/core/indigo-core/common/base_cpp/output.cpp
--- a/indigo-src/indigo/core/indigo-core/common/base_cpp/output.cpp	(revision 73c32dec301adcea5502320bc96e389975763707)
+++ b/indigo-src/indigo/core/indigo-core/common/base_cpp/output.cpp	(date 1714440647094)
@@ -61,7 +61,7 @@
     write(&value, sizeof(word));
 }
 
-void Output::writeBinaryUInt16(uint16_t value)
+void Output::writeBinaryUInt16(std::uint16_t value)
 {
     // value = htons(value);
     write(&value, sizeof(value));
Index: rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.cpp b/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.cpp	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.cpp	(date 1714440647094)
@@ -19,6 +19,14 @@
 namespace RDKit {
 namespace FMCS {
 
+void Seed::resizeMatchResult(const std::size_t& size) {
+  MatchResult.clear();
+  MatchResult.resize(size);
+  for(auto&p : MatchResult) {
+    p = std::make_shared<TargetMatch>();
+  }
+}
+
 unsigned int Seed::addAtom(const Atom *atom) {
   unsigned int i = MoleculeFragment.Atoms.size();
   unsigned int aqi = atom->getIdx();
Index: rdkit-src/rdkit/Code/GraphMol/FMCS/MaximumCommonSubgraph.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/FMCS/MaximumCommonSubgraph.cpp b/rdkit-src/rdkit/Code/GraphMol/FMCS/MaximumCommonSubgraph.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/FMCS/MaximumCommonSubgraph.cpp	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Code/GraphMol/FMCS/MaximumCommonSubgraph.cpp	(date 1714440647094)
@@ -278,7 +278,7 @@
       Seed seed;
       seed.setStoreAllDegenerateMCS(Parameters.StoreAll);
       seed.ExcludedBonds = excludedBonds;
-      seed.MatchResult.resize(Targets.size());
+      seed.resizeMatchResult(Targets.size());
 #ifdef VERBOSE_STATISTICS_ON
       {
         ++VerboseStatistics.Seed;
@@ -344,7 +344,7 @@
       //    continue;
       Seed seed;
       seed.setStoreAllDegenerateMCS(Parameters.StoreAll);
-      seed.MatchResult.resize(Targets.size());
+      seed.resizeMatchResult(Targets.size());
 
 #ifdef VERBOSE_STATISTICS_ON
       {
@@ -1248,7 +1248,7 @@
     { ++VerboseStatistics.MatchCall; }
 #endif
     bool target_matched = false;
-    if (!seed.MatchResult.empty() && !seed.MatchResult.at(itarget).empty()) {
+    if (!seed.MatchResult.empty() && !seed.MatchResult.at(itarget)->empty()) {
       target_matched = matchIncrementalFast(seed, itarget);
     }
     if (!target_matched) {  // slow full match
@@ -1259,11 +1259,11 @@
       // save current match info
       if (target_matched) {
         if (seed.MatchResult.empty()) {
-          seed.MatchResult.resize(Targets.size());
+          seed.resizeMatchResult(Targets.size());
         }
-        seed.MatchResult[itarget].init(seed, match, *QueryMolecule, tag);
+        seed.MatchResult[itarget]->init(seed, match, *QueryMolecule, tag);
       } else if (!seed.MatchResult.empty()) {
-        seed.MatchResult[itarget].clear();  //.Empty = true; // == fast clear();
+        seed.MatchResult[itarget]->clear();  //.Empty = true; // == fast clear();
       }
 #ifdef VERBOSE_STATISTICS_ON
       if (target_matched) {
@@ -1299,7 +1299,7 @@
   { ++VerboseStatistics.FastMatchCall; }
 #endif
   const auto& target = Targets.at(itarget);
-  auto& match = seed.MatchResult.at(itarget);
+  auto& match = *(seed.MatchResult.at(itarget));
   if (match.empty()) {
     return false;
   }
Index: rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.h b/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.h
--- a/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.h	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.h	(date 1714440647094)
@@ -91,13 +91,14 @@
   DuplicatedSeedCache::TKey DupCacheKey;
 #endif
   // for each target
-  std::vector<TargetMatch> MatchResult;
-
+  std::vector<std::shared_ptr<TargetMatch>> MatchResult;
  public:
   Seed()
 
   {}
 
+  void resizeMatchResult(const std::size_t& size);
+
   void setMoleculeFragment(const Seed& src) {
     MoleculeFragment = src.MoleculeFragment;
   }
Index: skia-src/skia/modules/skcms/skcms.cc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/modules/skcms/skcms.cc b/skia-src/skia/modules/skcms/skcms.cc
--- a/skia-src/skia/modules/skcms/skcms.cc	(revision 3d4e45907f9b239a54957001d619d2d4a6ca06b4)
+++ b/skia-src/skia/modules/skcms/skcms.cc	(date 1714440647094)
@@ -19,7 +19,7 @@
 #elif defined(__SSE__)
     #include <immintrin.h>
 
-    #if defined(__clang__)
+    #if defined(__clang__) && !defined(__EMSCRIPTEN__)
         // That #include <immintrin.h> is usually enough, but Clang's headers
         // "helpfully" skip including the whole kitchen sink when _MSC_VER is
         // defined, because lots of programs on Windows would include that and
Index: rdkit-src/rdkit/Code/GraphMol/SubstructLibrary/SubstructLibrary.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/SubstructLibrary/SubstructLibrary.h b/rdkit-src/rdkit/Code/GraphMol/SubstructLibrary/SubstructLibrary.h
--- a/rdkit-src/rdkit/Code/GraphMol/SubstructLibrary/SubstructLibrary.h	(revision ba0b6f3bafb391c17d7da9783f09817a4ba0f8f1)
+++ b/rdkit-src/rdkit/Code/GraphMol/SubstructLibrary/SubstructLibrary.h	(date 1714440647094)
@@ -415,7 +415,7 @@
       const std::vector<unsigned int> &indices) const override {
     std::vector<std::string> res;
     std::transform(indices.begin(), indices.end(), std::back_inserter(res),
-                   [=](unsigned idx) { return keys.at(idx); });
+                   [=, this](unsigned idx) { return keys.at(idx); });
     return res;
   }
   unsigned int size() const override { return keys.size(); }
Index: skia-src/skia/modules/skcms/src/skcms_TransformHsw.cc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/modules/skcms/src/skcms_TransformHsw.cc b/skia-src/skia/modules/skcms/src/skcms_TransformHsw.cc
--- a/skia-src/skia/modules/skcms/src/skcms_TransformHsw.cc	(revision 3d4e45907f9b239a54957001d619d2d4a6ca06b4)
+++ b/skia-src/skia/modules/skcms/src/skcms_TransformHsw.cc	(date 1714440647094)
@@ -19,7 +19,7 @@
 #elif defined(__SSE__)
     #include <immintrin.h>
 
-    #if defined(__clang__)
+    #if defined(__clang__) && !defined(__EMSCRIPTEN__)
         // That #include <immintrin.h> is usually enough, but Clang's headers
         // avoid #including the whole kitchen sink when _MSC_VER is defined,
         // because lots of programs on Windows would include that and it'd be
Index: skia-src/skia/modules/skcms/src/skcms_internals.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/modules/skcms/src/skcms_internals.h b/skia-src/skia/modules/skcms/src/skcms_internals.h
--- a/skia-src/skia/modules/skcms/src/skcms_internals.h	(revision 3d4e45907f9b239a54957001d619d2d4a6ca06b4)
+++ b/skia-src/skia/modules/skcms/src/skcms_internals.h	(date 1714440647094)
@@ -89,7 +89,7 @@
 
 // If we are in SKCMS_PORTABLE mode or running on a non-x86-64 platform, we can't enable HSW or SKX.
 // We also disable HSW/SKX on Android, even if it's Android on x64, since it's unlikely to benefit.
-#if defined(SKCMS_PORTABLE) || !defined(__x86_64__) || defined(ANDROID) || defined(__ANDROID__)
+#if defined(SKCMS_PORTABLE) || !defined(__x86_64__) || defined(ANDROID) || defined(__ANDROID__) || defined(__MINGW64__)
     #undef SKCMS_FORCE_HSW
     #if !defined(SKCMS_DISABLE_HSW)
         #define SKCMS_DISABLE_HSW 1
@@ -100,6 +100,18 @@
         #define SKCMS_DISABLE_SKX 1
     #endif
 #endif
+
+#if !defined(__AVX2__) || !defined(__AVX__) || !defined(__F16C__)
+#if !defined(SKCMS_DISABLE_HSW)
+#define SKCMS_DISABLE_HSW 1
+#endif
+#endif
+
+#if !defined(__AVX512__) || !defined(__AVX512F__)
+#if !defined(SKCMS_DISABLE_SKX)
+#define SKCMS_DISABLE_SKX 1
+#endif
+#endif
 
 // ~~~~ Shared ~~~~
 typedef struct skcms_ICCTag {
Index: skia-src/skia/modules/skcms/src/skcms_TransformSkx.cc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/modules/skcms/src/skcms_TransformSkx.cc b/skia-src/skia/modules/skcms/src/skcms_TransformSkx.cc
--- a/skia-src/skia/modules/skcms/src/skcms_TransformSkx.cc	(revision 3d4e45907f9b239a54957001d619d2d4a6ca06b4)
+++ b/skia-src/skia/modules/skcms/src/skcms_TransformSkx.cc	(date 1714440647094)
@@ -19,7 +19,7 @@
 #elif defined(__SSE__)
     #include <immintrin.h>
 
-    #if defined(__clang__)
+    #if defined(__clang__) && !defined(__EMSCRIPTEN__)
         // That #include <immintrin.h> is usually enough, but Clang's headers
         // avoid #including the whole kitchen sink when _MSC_VER is defined,
         // because lots of programs on Windows would include that and it'd be
Index: skia-src/skia/modules/skcms/src/skcms_TransformBaseline.cc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/modules/skcms/src/skcms_TransformBaseline.cc b/skia-src/skia/modules/skcms/src/skcms_TransformBaseline.cc
--- a/skia-src/skia/modules/skcms/src/skcms_TransformBaseline.cc	(revision 3d4e45907f9b239a54957001d619d2d4a6ca06b4)
+++ b/skia-src/skia/modules/skcms/src/skcms_TransformBaseline.cc	(date 1714440647094)
@@ -19,7 +19,7 @@
 #elif defined(__SSE__)
     #include <immintrin.h>
 
-    #if defined(__clang__)
+    #if defined(__clang__) && !defined(__EMSCRIPTEN__)
         // That #include <immintrin.h> is usually enough, but Clang's headers
         // avoid #including the whole kitchen sink when _MSC_VER is defined,
         // because lots of programs on Windows would include that and it'd be
diff --git a/nodeeditor-src/nodeeditor/src/ConnectionGraphicsObject.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionGraphicsObject.cpp
rename from nodeeditor-src/nodeeditor/src/ConnectionGraphicsObject.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionGraphicsObject.cpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeState.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeState.cpp
rename from nodeeditor-src/nodeeditor/src/NodeState.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeState.cpp
diff --git a/nodeeditor-src/nodeeditor/src/DefaultHorizontalNodeGeometry.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultHorizontalNodeGeometry.cpp
rename from nodeeditor-src/nodeeditor/src/DefaultHorizontalNodeGeometry.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultHorizontalNodeGeometry.cpp
diff --git a/nodeeditor-src/nodeeditor/src/locateNode.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/locateNode.cpp
rename from nodeeditor-src/nodeeditor/src/locateNode.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/locateNode.cpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeConnectionInteraction.hpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeConnectionInteraction.hpp
rename from nodeeditor-src/nodeeditor/src/NodeConnectionInteraction.hpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeConnectionInteraction.hpp
diff --git a/nodeeditor-src/nodeeditor/src/ConnectionPainter.hpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionPainter.hpp
rename from nodeeditor-src/nodeeditor/src/ConnectionPainter.hpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionPainter.hpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeDelegateModel.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeDelegateModel.cpp
rename from nodeeditor-src/nodeeditor/src/NodeDelegateModel.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeDelegateModel.cpp
diff --git a/nodeeditor-src/nodeeditor/src/DataFlowGraphModel.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DataFlowGraphModel.cpp
rename from nodeeditor-src/nodeeditor/src/DataFlowGraphModel.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DataFlowGraphModel.cpp
diff --git a/nodeeditor-src/nodeeditor/src/GraphicsView.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/GraphicsView.cpp
rename from nodeeditor-src/nodeeditor/src/GraphicsView.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/GraphicsView.cpp
diff --git a/nodeeditor-src/nodeeditor/src/Definitions.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/Definitions.cpp
rename from nodeeditor-src/nodeeditor/src/Definitions.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/Definitions.cpp
diff --git a/nodeeditor-src/nodeeditor/src/BasicGraphicsScene.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/BasicGraphicsScene.cpp
rename from nodeeditor-src/nodeeditor/src/BasicGraphicsScene.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/BasicGraphicsScene.cpp
diff --git a/nodeeditor-src/nodeeditor/src/ConnectionState.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionState.cpp
rename from nodeeditor-src/nodeeditor/src/ConnectionState.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionState.cpp
diff --git a/nodeeditor-src/nodeeditor/src/DataFlowGraphicsScene.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DataFlowGraphicsScene.cpp
rename from nodeeditor-src/nodeeditor/src/DataFlowGraphicsScene.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DataFlowGraphicsScene.cpp
diff --git a/nodeeditor-src/nodeeditor/src/UndoCommands.hpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/UndoCommands.hpp
rename from nodeeditor-src/nodeeditor/src/UndoCommands.hpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/UndoCommands.hpp
diff --git a/nodeeditor-src/nodeeditor/src/AbstractGraphModel.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/AbstractGraphModel.cpp
rename from nodeeditor-src/nodeeditor/src/AbstractGraphModel.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/AbstractGraphModel.cpp
diff --git a/nodeeditor-src/nodeeditor/src/DefaultVerticalNodeGeometry.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultVerticalNodeGeometry.cpp
rename from nodeeditor-src/nodeeditor/src/DefaultVerticalNodeGeometry.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultVerticalNodeGeometry.cpp
diff --git a/nodeeditor-src/nodeeditor/src/DefaultNodePainter.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultNodePainter.cpp
rename from nodeeditor-src/nodeeditor/src/DefaultNodePainter.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultNodePainter.cpp
diff --git a/nodeeditor-src/nodeeditor/src/AbstractNodeGeometry.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/AbstractNodeGeometry.cpp
rename from nodeeditor-src/nodeeditor/src/AbstractNodeGeometry.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/AbstractNodeGeometry.cpp
diff --git a/nodeeditor-src/nodeeditor/src/ConnectionStyle.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionStyle.cpp
rename from nodeeditor-src/nodeeditor/src/ConnectionStyle.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionStyle.cpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeConnectionInteraction.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeConnectionInteraction.cpp
rename from nodeeditor-src/nodeeditor/src/NodeConnectionInteraction.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeConnectionInteraction.cpp
diff --git a/nodeeditor-src/nodeeditor/src/GraphicsViewStyle.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/GraphicsViewStyle.cpp
rename from nodeeditor-src/nodeeditor/src/GraphicsViewStyle.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/GraphicsViewStyle.cpp
diff --git a/nodeeditor-src/nodeeditor/src/StyleCollection.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/StyleCollection.cpp
rename from nodeeditor-src/nodeeditor/src/StyleCollection.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/StyleCollection.cpp
diff --git a/nodeeditor-src/nodeeditor/src/ConnectionPainter.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionPainter.cpp
rename from nodeeditor-src/nodeeditor/src/ConnectionPainter.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionPainter.cpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeStyle.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeStyle.cpp
rename from nodeeditor-src/nodeeditor/src/NodeStyle.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeStyle.cpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeDelegateModelRegistry.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeDelegateModelRegistry.cpp
rename from nodeeditor-src/nodeeditor/src/NodeDelegateModelRegistry.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeDelegateModelRegistry.cpp
diff --git a/nodeeditor-src/nodeeditor/src/DefaultHorizontalNodeGeometry.hpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultHorizontalNodeGeometry.hpp
rename from nodeeditor-src/nodeeditor/src/DefaultHorizontalNodeGeometry.hpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultHorizontalNodeGeometry.hpp
diff --git a/nodeeditor-src/nodeeditor/src/DefaultVerticalNodeGeometry.hpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultVerticalNodeGeometry.hpp
rename from nodeeditor-src/nodeeditor/src/DefaultVerticalNodeGeometry.hpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultVerticalNodeGeometry.hpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeGraphicsObject.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeGraphicsObject.cpp
rename from nodeeditor-src/nodeeditor/src/NodeGraphicsObject.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeGraphicsObject.cpp
diff --git a/nodeeditor-src/nodeeditor/src/UndoCommands.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/UndoCommands.cpp
rename from nodeeditor-src/nodeeditor/src/UndoCommands.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/UndoCommands.cpp
