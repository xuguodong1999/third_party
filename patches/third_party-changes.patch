Subject: [PATCH] third_party-changes
---
Index: spdlog-src/spdlog/src/file_sinks.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/spdlog-src/spdlog/src/file_sinks.cpp b/spdlog-src/spdlog/src/file_sinks.cpp
--- a/spdlog-src/spdlog/src/file_sinks.cpp	(revision 7e635fca68d014934b4af8a1cf874f63989352b7)
+++ b/spdlog-src/spdlog/src/file_sinks.cpp	(date 1702005168510)
@@ -8,7 +8,6 @@
 #include <spdlog/details/null_mutex.h>
 #include <spdlog/details/file_helper-inl.h>
 #include <spdlog/sinks/basic_file_sink-inl.h>
-#include <spdlog/sinks/base_sink-inl.h>

 #include <mutex>


Index: svgpp-src/svgpp/include/svgpp/parser/grammar/angle.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/parser/grammar/angle.hpp b/svgpp-src/svgpp/include/svgpp/parser/grammar/angle.hpp
--- a/svgpp-src/svgpp/include/svgpp/parser/grammar/angle.hpp	(revision f460b2c7ceba92a875c0ba5c333826652863b396)
+++ b/svgpp-src/svgpp/include/svgpp/parser/grammar/angle.hpp	(date 1696647929779)
@@ -10,7 +10,7 @@
 #include <svgpp/definitions.hpp>
 #include <svgpp/parser/detail/common.hpp>
 #include <boost/spirit/include/qi.hpp>
-#include <boost/spirit/include/phoenix.hpp>
+#include <boost/phoenix.hpp>
 #include <boost/spirit/include/qi_grammar.hpp>
 
 namespace svgpp 
Index: svgpp-src/svgpp/include/svgpp/parser/grammar/clock_value.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/parser/grammar/clock_value.hpp b/svgpp-src/svgpp/include/svgpp/parser/grammar/clock_value.hpp
--- a/svgpp-src/svgpp/include/svgpp/parser/grammar/clock_value.hpp	(revision f460b2c7ceba92a875c0ba5c333826652863b396)
+++ b/svgpp-src/svgpp/include/svgpp/parser/grammar/clock_value.hpp	(date 1696647929779)
@@ -8,7 +8,7 @@
 #pragma once
 
 #include <boost/spirit/include/qi.hpp>
-#include <boost/spirit/include/phoenix.hpp>
+#include <boost/phoenix.hpp>
 
 namespace svgpp
 {
Index: svgpp-src/svgpp/include/svgpp/parser/grammar/color.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/parser/grammar/color.hpp b/svgpp-src/svgpp/include/svgpp/parser/grammar/color.hpp
--- a/svgpp-src/svgpp/include/svgpp/parser/grammar/color.hpp	(revision f460b2c7ceba92a875c0ba5c333826652863b396)
+++ b/svgpp-src/svgpp/include/svgpp/parser/grammar/color.hpp	(date 1696647929779)
@@ -10,7 +10,7 @@
 #include <svgpp/parser/detail/common.hpp>
 #include <boost/tuple/tuple.hpp>
 #include <boost/spirit/include/qi.hpp>
-#include <boost/spirit/include/phoenix.hpp>
+#include <boost/phoenix.hpp>
 
 namespace svgpp 
 {
Index: svgpp-src/svgpp/include/svgpp/parser/grammar/preserveAspectRatio.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/parser/grammar/preserveAspectRatio.hpp b/svgpp-src/svgpp/include/svgpp/parser/grammar/preserveAspectRatio.hpp
--- a/svgpp-src/svgpp/include/svgpp/parser/grammar/preserveAspectRatio.hpp	(revision f460b2c7ceba92a875c0ba5c333826652863b396)
+++ b/svgpp-src/svgpp/include/svgpp/parser/grammar/preserveAspectRatio.hpp	(date 1696647929779)
@@ -8,7 +8,7 @@
 #pragma once
 
 #include <boost/spirit/include/qi.hpp>
-#include <boost/spirit/include/phoenix.hpp>
+#include <boost/phoenix.hpp>
 #include <boost/spirit/include/qi_grammar.hpp>
 
 namespace svgpp 
Index: svgpp-src/svgpp/include/svgpp/parser/grammar/path_data.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/parser/grammar/path_data.hpp b/svgpp-src/svgpp/include/svgpp/parser/grammar/path_data.hpp
--- a/svgpp-src/svgpp/include/svgpp/parser/grammar/path_data.hpp	(revision f460b2c7ceba92a875c0ba5c333826652863b396)
+++ b/svgpp-src/svgpp/include/svgpp/parser/grammar/path_data.hpp	(date 1696647929779)
@@ -8,7 +8,7 @@
 #pragma once
 
 #include <boost/spirit/include/qi.hpp>
-#include <boost/spirit/include/phoenix.hpp>
+#include <boost/phoenix.hpp>
 #include <svgpp/definitions.hpp>
 #include <svgpp/number_type.hpp>
 #include <svgpp/parser/detail/common.hpp>
Index: svgpp-src/svgpp/include/svgpp/parser/grammar/urange.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/parser/grammar/urange.hpp b/svgpp-src/svgpp/include/svgpp/parser/grammar/urange.hpp
--- a/svgpp-src/svgpp/include/svgpp/parser/grammar/urange.hpp	(revision f460b2c7ceba92a875c0ba5c333826652863b396)
+++ b/svgpp-src/svgpp/include/svgpp/parser/grammar/urange.hpp	(date 1696647929779)
@@ -8,7 +8,7 @@
 #pragma once
 
 #include <boost/spirit/include/qi.hpp>
-#include <boost/spirit/include/phoenix.hpp>
+#include <boost/phoenix.hpp>
 #include <boost/spirit/include/qi_grammar.hpp>
 
 namespace svgpp 
Index: svgpp-src/svgpp/include/svgpp/parser/grammar/transform.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/parser/grammar/transform.hpp b/svgpp-src/svgpp/include/svgpp/parser/grammar/transform.hpp
--- a/svgpp-src/svgpp/include/svgpp/parser/grammar/transform.hpp	(revision f460b2c7ceba92a875c0ba5c333826652863b396)
+++ b/svgpp-src/svgpp/include/svgpp/parser/grammar/transform.hpp	(date 1696647929779)
@@ -9,7 +9,7 @@
 
 #include <boost/array.hpp>
 #include <boost/spirit/include/qi.hpp>
-#include <boost/spirit/include/phoenix.hpp>
+#include <boost/phoenix.hpp>
 #include <svgpp/parser/detail/common.hpp>
 #include <svgpp/policy/transform_events.hpp>
 
Index: svgpp-src/svgpp/include/svgpp/parser/grammar/length.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/parser/grammar/length.hpp b/svgpp-src/svgpp/include/svgpp/parser/grammar/length.hpp
--- a/svgpp-src/svgpp/include/svgpp/parser/grammar/length.hpp	(revision f460b2c7ceba92a875c0ba5c333826652863b396)
+++ b/svgpp-src/svgpp/include/svgpp/parser/grammar/length.hpp	(date 1696647929779)
@@ -10,7 +10,7 @@
 #include <svgpp/definitions.hpp>
 #include <svgpp/parser/detail/common.hpp>
 #include <boost/spirit/include/qi.hpp>
-#include <boost/spirit/include/phoenix.hpp>
+#include <boost/phoenix.hpp>
 #include <boost/spirit/include/qi_grammar.hpp>
 
 namespace svgpp 
Index: svgpp-src/svgpp/include/svgpp/parser/grammar/icc_color.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/parser/grammar/icc_color.hpp b/svgpp-src/svgpp/include/svgpp/parser/grammar/icc_color.hpp
--- a/svgpp-src/svgpp/include/svgpp/parser/grammar/icc_color.hpp	(revision f460b2c7ceba92a875c0ba5c333826652863b396)
+++ b/svgpp-src/svgpp/include/svgpp/parser/grammar/icc_color.hpp	(date 1696647929779)
@@ -10,7 +10,7 @@
 #include <svgpp/definitions.hpp>
 #include <svgpp/parser/detail/common.hpp>
 #include <boost/spirit/include/qi.hpp>
-#include <boost/spirit/include/phoenix.hpp>
+#include <boost/phoenix.hpp>
 
 namespace svgpp 
 {
Index: svgpp-src/svgpp/include/svgpp/parser/grammar/coordinate_pair.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/parser/grammar/coordinate_pair.hpp b/svgpp-src/svgpp/include/svgpp/parser/grammar/coordinate_pair.hpp
--- a/svgpp-src/svgpp/include/svgpp/parser/grammar/coordinate_pair.hpp	(revision f460b2c7ceba92a875c0ba5c333826652863b396)
+++ b/svgpp-src/svgpp/include/svgpp/parser/grammar/coordinate_pair.hpp	(date 1696647929779)
@@ -8,7 +8,7 @@
 #pragma once
 
 #include <boost/spirit/include/qi.hpp>
-#include <boost/spirit/include/phoenix.hpp>
+#include <boost/phoenix.hpp>
 #include <svgpp/parser/detail/common.hpp>
 
 namespace svgpp
Index: rdkit-src/rdkit/External/GA/ga/GaBase.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/External/GA/ga/GaBase.cpp b/rdkit-src/rdkit/External/GA/ga/GaBase.cpp
new file mode 100644
--- /dev/null	(date 1701849536985)
+++ b/rdkit-src/rdkit/External/GA/ga/GaBase.cpp	(date 1701849536985)
@@ -0,0 +1,9 @@
+#include "GaBase.h"
+
+using namespace GapeGa;
+
+GaBase::GaBase() {
+};
+
+GaBase::~GaBase() {
+};
\ No newline at end of file
Index: opencv-src/opencv/modules/core/src/parallel.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/core/src/parallel.cpp b/opencv-src/opencv/modules/core/src/parallel.cpp
--- a/opencv-src/opencv/modules/core/src/parallel.cpp	(revision 5199850039ad23f1f0e6cccea5061a9fea5efca6)
+++ b/opencv-src/opencv/modules/core/src/parallel.cpp	(date 1701848687859)
@@ -76,7 +76,7 @@
     #include <thread>
 #endif
 
-#ifdef _OPENMP
+#if defined(_OPENMP) && !defined(HAVE_OPENMP)
     #define HAVE_OPENMP
 #endif
 
Index: svgpp-src/svgpp/include/svgpp/parser/misc.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/parser/misc.hpp b/svgpp-src/svgpp/include/svgpp/parser/misc.hpp
--- a/svgpp-src/svgpp/include/svgpp/parser/misc.hpp	(revision f460b2c7ceba92a875c0ba5c333826652863b396)
+++ b/svgpp-src/svgpp/include/svgpp/parser/misc.hpp	(date 1696647929780)
@@ -23,7 +23,7 @@
 #include <svgpp/policy/value_events.hpp>
 #include <boost/mpl/pair.hpp>
 #include <boost/spirit/include/qi.hpp>
-#include <boost/spirit/include/phoenix.hpp>
+#include <boost/phoenix.hpp>
 
 namespace svgpp
 {
Index: rdkit-src/rdkit/Code/GraphMol/Canon.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/Canon.cpp b/rdkit-src/rdkit/Code/GraphMol/Canon.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/Canon.cpp	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/Code/GraphMol/Canon.cpp	(date 1701849536981)
@@ -79,7 +79,7 @@
            !details::isUnsaturated(atom, mol)));
 }
 
-auto _possibleCompare = [](const PossibleType &arg1, const PossibleType &arg2) {
+const auto _possibleCompare = [](const PossibleType &arg1, const PossibleType &arg2) {
   return (std::get<0>(arg1) < std::get<0>(arg2));
 };
 
Index: cppcoro-src/cppcoro/lib/socket_recv_from_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_recv_from_operation.cpp b/cppcoro-src/cppcoro/lib/socket_recv_from_operation.cpp
--- a/cppcoro-src/cppcoro/lib/socket_recv_from_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_recv_from_operation.cpp	(date 1701843666809)
@@ -9,10 +9,10 @@
 #if CPPCORO_OS_WINNT
 # include "socket_helpers.hpp"
 
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 
 bool cppcoro::net::socket_recv_from_operation_impl::try_start(
 	cppcoro::detail::win32_overlapped_operation_base& operation) noexcept
Index: cppcoro-src/cppcoro/lib/async_auto_reset_event.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/async_auto_reset_event.cpp b/cppcoro-src/cppcoro/lib/async_auto_reset_event.cpp
--- a/cppcoro-src/cppcoro/lib/async_auto_reset_event.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/async_auto_reset_event.cpp	(date 1701843666802)
@@ -241,7 +241,7 @@
 {}
 
 bool cppcoro::async_auto_reset_event_operation::await_suspend(
-	std::experimental::coroutine_handle<> awaiter) noexcept
+	std::coroutine_handle<> awaiter) noexcept
 {
 	m_awaiter = awaiter;
 
Index: cairo-src/cairo/boilerplate/cairo-boilerplate.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cairo-src/cairo/boilerplate/cairo-boilerplate.c b/cairo-src/cairo/boilerplate/cairo-boilerplate.c
--- a/cairo-src/cairo/boilerplate/cairo-boilerplate.c	(revision 3909090108bb2db55330e3eb148aebe664735363)
+++ b/cairo-src/cairo/boilerplate/cairo-boilerplate.c	(date 1701837435165)
@@ -498,6 +498,10 @@
 #endif
 }
 
+void
+_cairo_boilerplate_register_all (void)
+{}
+
 void
 _cairo_boilerplate_register_backend (const cairo_boilerplate_target_t *targets,
 				     unsigned int		       count)
Index: cppcoro-src/cppcoro/lib/win32.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/win32.cpp b/cppcoro-src/cppcoro/lib/win32.cpp
--- a/cppcoro-src/cppcoro/lib/win32.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/win32.cpp	(date 1701843666812)
@@ -8,7 +8,7 @@
 #ifndef WIN32_LEAN_AND_MEAN
 # define WIN32_LEAN_AND_MEAN
 #endif
-#include <Windows.h>
+#include <windows.h>
 
 void cppcoro::detail::win32::safe_handle::close() noexcept
 {
Index: skia-src/skia/src/gpu/ganesh/glsl/GrGLSLShaderBuilder.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/src/gpu/ganesh/glsl/GrGLSLShaderBuilder.cpp b/skia-src/skia/src/gpu/ganesh/glsl/GrGLSLShaderBuilder.cpp
--- a/skia-src/skia/src/gpu/ganesh/glsl/GrGLSLShaderBuilder.cpp	(revision 5f54e9f84cff8c42fd645ec53c1727857bdb12ab)
+++ b/skia-src/skia/src/gpu/ganesh/glsl/GrGLSLShaderBuilder.cpp	(date 1701851934716)
@@ -150,7 +150,7 @@
     // function, one for the (inverse) destination transfer function, and one for the gamut xform.
     // Any combination of these may be present, although some configurations are much more likely.
 
-    auto emitTFFunc = [=](const char* name, GrGLSLProgramDataManager::UniformHandle uniform,
+    auto emitTFFunc = [=, this](const char* name, GrGLSLProgramDataManager::UniformHandle uniform,
                           skcms_TFType tfType) {
         const GrShaderVar gTFArgs[] = { GrShaderVar("x", SkSLType::kFloat) };
         const char* coeffs = uniformHandler->getUniformCStr(uniform);
Index: cppcoro-src/cppcoro/lib/write_only_file.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/write_only_file.cpp b/cppcoro-src/cppcoro/lib/write_only_file.cpp
--- a/cppcoro-src/cppcoro/lib/write_only_file.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/write_only_file.cpp	(date 1701843666813)
@@ -3,17 +3,17 @@
 // Licenced under MIT license. See LICENSE.txt for details.
 ///////////////////////////////////////////////////////////////////////////////
 
-#include <cppcoro\write_only_file.hpp>
+#include <cppcoro/write_only_file.hpp>
 
 #if CPPCORO_OS_WINNT
 # ifndef WIN32_LEAN_AND_MEAN
 #  define WIN32_LEAN_AND_MEAN
 # endif
-# include <Windows.h>
+# include <windows.h>
 
 cppcoro::write_only_file cppcoro::write_only_file::open(
 	io_service& ioService,
-	const std::experimental::filesystem::path& path,
+	const std::filesystem::path& path,
 	file_open_mode openMode,
 	file_share_mode shareMode,
 	file_buffering_mode bufferingMode)
Index: cppcoro-src/cppcoro/lib/read_only_file.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/read_only_file.cpp b/cppcoro-src/cppcoro/lib/read_only_file.cpp
--- a/cppcoro-src/cppcoro/lib/read_only_file.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/read_only_file.cpp	(date 1701843666806)
@@ -3,17 +3,17 @@
 // Licenced under MIT license. See LICENSE.txt for details.
 ///////////////////////////////////////////////////////////////////////////////
 
-#include <cppcoro\read_only_file.hpp>
+#include <cppcoro/read_only_file.hpp>
 
 #if CPPCORO_OS_WINNT
 # ifndef WIN32_LEAN_AND_MEAN
 #  define WIN32_LEAN_AND_MEAN
 # endif
-# include <Windows.h>
+# include <windows.h>
 
 cppcoro::read_only_file cppcoro::read_only_file::open(
 	io_service& ioService,
-	const std::experimental::filesystem::path& path,
+	const std::filesystem::path& path,
 	file_share_mode shareMode,
 	file_buffering_mode bufferingMode)
 {
Index: cppcoro-src/cppcoro/lib/read_write_file.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/read_write_file.cpp b/cppcoro-src/cppcoro/lib/read_write_file.cpp
--- a/cppcoro-src/cppcoro/lib/read_write_file.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/read_write_file.cpp	(date 1701843666807)
@@ -3,17 +3,17 @@
 // Licenced under MIT license. See LICENSE.txt for details.
 ///////////////////////////////////////////////////////////////////////////////
 
-#include <cppcoro\read_write_file.hpp>
+#include <cppcoro/read_write_file.hpp>
 
 #if CPPCORO_OS_WINNT
 # ifndef WIN32_LEAN_AND_MEAN
 #  define WIN32_LEAN_AND_MEAN
 # endif
-# include <Windows.h>
+# include <windows.h>
 
 cppcoro::read_write_file cppcoro::read_write_file::open(
 	io_service& ioService,
-	const std::experimental::filesystem::path& path,
+	const std::filesystem::path& path,
 	file_open_mode openMode,
 	file_share_mode shareMode,
 	file_buffering_mode bufferingMode)
Index: rdkit-src/rdkit/Code/ForceField/MMFF/Params.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/ForceField/MMFF/Params.cpp b/rdkit-src/rdkit/Code/ForceField/MMFF/Params.cpp
--- a/rdkit-src/rdkit/Code/ForceField/MMFF/Params.cpp	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/Code/ForceField/MMFF/Params.cpp	(date 1701849536980)
@@ -10,7 +10,7 @@
 //  which is included in the file license.txt, found at the root
 //  of the RDKit source tree.
 //
-#ifdef WIN32
+#if defined(WIN32) && !defined(_USE_MATH_DEFINES)
 #define _USE_MATH_DEFINES
 #endif
 #include <cmath>
Index: cppcoro-src/cppcoro/lib/socket_send_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_send_operation.cpp b/cppcoro-src/cppcoro/lib/socket_send_operation.cpp
--- a/cppcoro-src/cppcoro/lib/socket_send_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_send_operation.cpp	(date 1701843666810)
@@ -7,10 +7,10 @@
 #include <cppcoro/net/socket.hpp>
 
 #if CPPCORO_OS_WINNT
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 
 bool cppcoro::net::socket_send_operation_impl::try_start(
 	cppcoro::detail::win32_overlapped_operation_base& operation) noexcept
Index: rdkit-src/rdkit/External/GA/util/export.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/External/GA/util/export.h b/rdkit-src/rdkit/External/GA/util/export.h
--- a/rdkit-src/rdkit/External/GA/util/export.h	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/External/GA/util/export.h	(date 1701849536986)
@@ -10,6 +10,6 @@
 
 #pragma once
 
-#include <RDGeneral/RDExportMacros.h>
+#include <RDGeneral/export.h>
 
-#define GA_EXPORT RDKIT_EXPORT_API
+#define GA_EXPORT RDKIT_GA_EXPORT
Index: cppcoro-src/cppcoro/lib/socket_disconnect_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_disconnect_operation.cpp b/cppcoro-src/cppcoro/lib/socket_disconnect_operation.cpp
--- a/cppcoro-src/cppcoro/lib/socket_disconnect_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_disconnect_operation.cpp	(date 1701843666808)
@@ -11,10 +11,10 @@
 #include <system_error>
 
 #if CPPCORO_OS_WINNT
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 
 bool cppcoro::net::socket_disconnect_operation_impl::try_start(
 	cppcoro::detail::win32_overlapped_operation_base& operation) noexcept
Index: cppcoro-src/cppcoro/lib/static_thread_pool.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/static_thread_pool.cpp b/cppcoro-src/cppcoro/lib/static_thread_pool.cpp
--- a/cppcoro-src/cppcoro/lib/static_thread_pool.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/static_thread_pool.cpp	(date 1701843666811)
@@ -12,6 +12,7 @@
 #include <cassert>
 #include <mutex>
 #include <chrono>
+#include <utility>
 
 namespace
 {
@@ -319,7 +320,7 @@
 	};
 
 	void static_thread_pool::schedule_operation::await_suspend(
-		std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+		std::coroutine_handle<> awaitingCoroutine) noexcept
 	{
 		m_awaitingCoroutine = awaitingCoroutine;
 		m_threadPool->schedule_impl(this);
Index: cppcoro-src/cppcoro/lib/spin_wait.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/spin_wait.cpp b/cppcoro-src/cppcoro/lib/spin_wait.cpp
--- a/cppcoro-src/cppcoro/lib/spin_wait.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/spin_wait.cpp	(date 1701843666810)
@@ -10,7 +10,7 @@
 
 #if CPPCORO_OS_WINNT
 # define WIN32_LEAN_AND_MEAN
-# include <Windows.h>
+# include <windows.h>
 #endif
 
 namespace
Index: rdkit-src/rdkit/External/GA/ga/GaBase.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/External/GA/ga/GaBase.h b/rdkit-src/rdkit/External/GA/ga/GaBase.h
--- a/rdkit-src/rdkit/External/GA/ga/GaBase.h	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/External/GA/ga/GaBase.h	(date 1701849536985)
@@ -34,8 +34,8 @@
   GaBase& operator=(const GaBase& other) = delete;
 
  public:
-  GaBase(){};
-  virtual ~GaBase(){};
+  GaBase();
+  virtual ~GaBase();
 
   double getSelectionPressure() const { return selectionPressure; }
 
Index: rdkit-src/rdkit/Code/ForceField/UFF/Params.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/ForceField/UFF/Params.cpp b/rdkit-src/rdkit/Code/ForceField/UFF/Params.cpp
--- a/rdkit-src/rdkit/Code/ForceField/UFF/Params.cpp	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/Code/ForceField/UFF/Params.cpp	(date 1701849536980)
@@ -7,7 +7,7 @@
 //  which is included in the file license.txt, found at the root
 //  of the RDKit source tree.
 //
-#ifdef WIN32
+#if defined(WIN32) && !defined(_USE_MATH_DEFINES)
 #define _USE_MATH_DEFINES
 #endif
 #include <cmath>
Index: cppcoro-src/cppcoro/lib/socket_recv_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_recv_operation.cpp b/cppcoro-src/cppcoro/lib/socket_recv_operation.cpp
--- a/cppcoro-src/cppcoro/lib/socket_recv_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_recv_operation.cpp	(date 1701843666810)
@@ -7,10 +7,10 @@
 #include <cppcoro/net/socket.hpp>
 
 #if CPPCORO_OS_WINNT
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 
 bool cppcoro::net::socket_recv_operation_impl::try_start(
 	cppcoro::detail::win32_overlapped_operation_base& operation) noexcept
Index: rdkit-src/rdkit/External/GA/util/Util.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/External/GA/util/Util.cpp b/rdkit-src/rdkit/External/GA/util/Util.cpp
--- a/rdkit-src/rdkit/External/GA/util/Util.cpp	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/External/GA/util/Util.cpp	(date 1701849536986)
@@ -40,18 +40,7 @@
 }
 
 string getUserName() {
-#ifdef WIN32
-  return "UNKNOWN";
-#else
-  const int bufsize = 100;
-  char buffer[bufsize];
-
-  if (!getlogin_r(buffer, bufsize)) {
-    return string(buffer);
-  } else {
-    return string("");
-  }
-#endif
+    return "UNKNOWN";
 }
 
 string &removeTrailingLF(string &line) {
Index: cppcoro-src/cppcoro/lib/file.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/file.cpp b/cppcoro-src/cppcoro/lib/file.cpp
--- a/cppcoro-src/cppcoro/lib/file.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/file.cpp	(date 1701843666804)
@@ -13,7 +13,7 @@
 # ifndef WIN32_LEAN_AND_MEAN
 #  define WIN32_LEAN_AND_MEAN
 # endif
-# include <Windows.h>
+# include <windows.h>
 #endif
 
 cppcoro::file::~file()
@@ -47,7 +47,7 @@
 cppcoro::detail::win32::safe_handle cppcoro::file::open(
 	detail::win32::dword_t fileAccess,
 	io_service& ioService,
-	const std::experimental::filesystem::path& path,
+	const std::filesystem::path& path,
 	file_open_mode openMode,
 	file_share_mode shareMode,
 	file_buffering_mode bufferingMode)
Index: cppcoro-src/cppcoro/lib/socket_accept_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_accept_operation.cpp b/cppcoro-src/cppcoro/lib/socket_accept_operation.cpp
--- a/cppcoro-src/cppcoro/lib/socket_accept_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_accept_operation.cpp	(date 1701843666808)
@@ -11,10 +11,10 @@
 #include <system_error>
 
 #if CPPCORO_OS_WINNT
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 
 // TODO: Eliminate duplication of implementation between socket_accept_operation
 // and socket_accept_operation_cancellable.
Index: cppcoro-src/cppcoro/lib/auto_reset_event.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/auto_reset_event.cpp b/cppcoro-src/cppcoro/lib/auto_reset_event.cpp
--- a/cppcoro-src/cppcoro/lib/auto_reset_event.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/auto_reset_event.cpp	(date 1701843666803)
@@ -7,7 +7,7 @@
 
 #if CPPCORO_OS_WINNT
 # define WIN32_LEAN_AND_MEAN
-# include <Windows.h>
+# include <windows.h>
 # include <system_error>
 #endif
 
Index: svgpp-src/svgpp/include/svgpp/parser/external_function/parse_paint_impl.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/parser/external_function/parse_paint_impl.hpp b/svgpp-src/svgpp/include/svgpp/parser/external_function/parse_paint_impl.hpp
--- a/svgpp-src/svgpp/include/svgpp/parser/external_function/parse_paint_impl.hpp	(revision f460b2c7ceba92a875c0ba5c333826652863b396)
+++ b/svgpp-src/svgpp/include/svgpp/parser/external_function/parse_paint_impl.hpp	(date 1696647929778)
@@ -51,13 +51,13 @@
       | qi::lit("currentColor")   [phx::ref(out_main_option) = paint_option_currentColor]
       | qi::lit("inherit")        [phx::ref(out_main_option) = paint_option_inherit]
       | color_optional_icc_color(boost::phoenix::ref(icc_color_factory))  
-          [phx::ref(out_color) = qi::_1, phx::ref(out_main_option) = paint_option_color]
+          [(phx::ref(out_color) = qi::_1, phx::ref(out_main_option) = paint_option_color)]
       | ( funciri_rule [phx::ref(out_iri) = qi::_1]
           >> - ( +space
                   >> ( qi::lit("none")          [phx::ref(out_funciri_suboption) = paint_option_none]
                       | qi::lit("currentColor")  [phx::ref(out_funciri_suboption) = paint_option_currentColor]
                       | color_optional_icc_color(boost::phoenix::ref(icc_color_factory)) 
-                        [phx::ref(out_color) = qi::_1, phx::ref(out_funciri_suboption) = paint_option_color]
+                        [(phx::ref(out_color) = qi::_1, phx::ref(out_funciri_suboption) = paint_option_color)]
                       )
                 )
         ) [phx::ref(out_main_option) = paint_option_funciri]
Index: cppcoro-src/cppcoro/lib/socket_helpers.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_helpers.cpp b/cppcoro-src/cppcoro/lib/socket_helpers.cpp
--- a/cppcoro-src/cppcoro/lib/socket_helpers.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_helpers.cpp	(date 1701843666809)
@@ -11,10 +11,10 @@
 #include <cstring>
 #include <cassert>
 
-#include <WinSock2.h>
-#include <WS2tcpip.h>
-#include <MSWSock.h>
-#include <Windows.h>
+#include <winsock2.h>
+#include <ws2tcpip.h>
+#include <mswsock.h>
+#include <windows.h>
 
 
 cppcoro::net::ip_endpoint
@@ -74,7 +74,11 @@
 		std::memcpy(&ipv6Address.sin6_addr, ipv6EndPoint.address().bytes(), 16);
 		ipv6Address.sin6_port = htons(ipv6EndPoint.port());
 		ipv6Address.sin6_flowinfo = 0;
+#ifdef SCOPEID_UNSPECIFIED_INIT
 		ipv6Address.sin6_scope_struct = SCOPEID_UNSPECIFIED_INIT;
+#else
+		ipv6Address.sin6_scope_struct = {0};
+#endif
 
 		std::memcpy(&address.get(), &ipv6Address, sizeof(ipv6Address));
 
Index: cppcoro-src/cppcoro/lib/async_manual_reset_event.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/async_manual_reset_event.cpp b/cppcoro-src/cppcoro/lib/async_manual_reset_event.cpp
--- a/cppcoro-src/cppcoro/lib/async_manual_reset_event.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/async_manual_reset_event.cpp	(date 1701843666802)
@@ -72,7 +72,7 @@
 }
 
 bool cppcoro::async_manual_reset_event_operation::await_suspend(
-	std::experimental::coroutine_handle<> awaiter) noexcept
+	std::coroutine_handle<> awaiter) noexcept
 {
 	m_awaiter = awaiter;
 
Index: cppcoro-src/cppcoro/lib/socket_send_to_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_send_to_operation.cpp b/cppcoro-src/cppcoro/lib/socket_send_to_operation.cpp
--- a/cppcoro-src/cppcoro/lib/socket_send_to_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_send_to_operation.cpp	(date 1701843666810)
@@ -9,10 +9,10 @@
 #if CPPCORO_OS_WINNT
 # include "socket_helpers.hpp"
 
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 
 bool cppcoro::net::socket_send_to_operation_impl::try_start(
 	cppcoro::detail::win32_overlapped_operation_base& operation) noexcept
Index: svgpp-src/svgpp/include/svgpp/traits/attribute_type.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/traits/attribute_type.hpp b/svgpp-src/svgpp/include/svgpp/traits/attribute_type.hpp
--- a/svgpp-src/svgpp/include/svgpp/traits/attribute_type.hpp	(revision f460b2c7ceba92a875c0ba5c333826652863b396)
+++ b/svgpp-src/svgpp/include/svgpp/traits/attribute_type.hpp	(date 1699257749242)
@@ -432,6 +432,9 @@
 template<class Element> struct attribute_type<Element, tag::attribute::class_                > { typedef tag::type::string type; }; // TODO: parse list of strings
 template<class Element> struct attribute_type<Element, tag::attribute::contentScriptType     > { typedef tag::type::string type; };
 template<class Element> struct attribute_type<Element, tag::attribute::contentStyleType      > { typedef tag::type::string type; };
+template<class Element> struct attribute_type<Element, tag::attribute::data_c                > { typedef tag::type::string type; };
+template<class Element> struct attribute_type<Element, tag::attribute::data_mjx_texclass     > { typedef tag::type::string type; };
+template<class Element> struct attribute_type<Element, tag::attribute::data_mml_node         > { typedef tag::type::string type; };
 template<class Element> struct attribute_type<Element, tag::attribute::id                    > { typedef tag::type::string type; };
 template<class Element> struct attribute_type<Element, tag::attribute::attributeName         > { typedef tag::type::string type; };
 template<class Element> struct attribute_type<Element, tag::attribute::font_family           > { typedef tag::type::string type; };
Index: indigo-src/indigo/core/indigo-core/molecule/src/inchi_wrapper.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/molecule/src/inchi_wrapper.cpp b/indigo-src/indigo/core/indigo-core/molecule/src/inchi_wrapper.cpp
--- a/indigo-src/indigo/core/indigo-core/molecule/src/inchi_wrapper.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/core/indigo-core/molecule/src/inchi_wrapper.cpp	(date 1701847510205)
@@ -17,6 +17,7 @@
  ***************************************************************************/
 
 #include <algorithm>
+#define TARGET_LIB_FOR_WINCHI
 #include <mode.h>
 
 #include "molecule/inchi_wrapper.h"
Index: fluentui-src/fluentui/src/Qt6/CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/Qt6/CMakeLists.txt b/fluentui-src/fluentui/src/Qt6/CMakeLists.txt
new file mode 100644
--- /dev/null	(date 1701846840739)
+++ b/fluentui-src/fluentui/src/Qt6/CMakeLists.txt	(date 1701846840739)
@@ -0,0 +1,73 @@
+project(fluentui)
+
+# fluentui
+set(ROOT_DIR ${CMAKE_CURRENT_SOURCE_DIR})
+set(INC_DIR ${ROOT_DIR}/../)
+set(SRC_DIR ${ROOT_DIR}/../)
+
+file(GLOB_RECURSE QML_PATHS ${ROOT_DIR}/*.qml)
+foreach (filepath ${QML_PATHS})
+    string(REPLACE "${ROOT_DIR}/" "" filename ${filepath})
+    list(APPEND qml_files ${filename})
+endforeach (filepath)
+
+file(GLOB_RECURSE RES_PATHS
+        ${ROOT_DIR}/*.png ${ROOT_DIR}/*.jpg
+        ${ROOT_DIR}/*.svg ${ROOT_DIR}/*.ico
+        ${ROOT_DIR}/*.ttf ${ROOT_DIR}/*.webp
+        ${ROOT_DIR}/*.js)
+foreach (filepath ${RES_PATHS})
+    string(REPLACE "${ROOT_DIR}/" "" filename ${filepath})
+    list(APPEND resource_files ${filename})
+endforeach (filepath)
+
+foreach (filepath IN LISTS qml_files resource_files)
+    string(REPLACE "imports/FluentUI/" "" filename ${filepath})
+    set_source_files_properties(${filepath} PROPERTIES QT_RESOURCE_ALIAS ${filename})
+endforeach ()
+
+if (CMAKE_RUNTIME_OUTPUT_DIRECTORY)
+    set(OUTPUT_DIRECTORY "${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/FluentUI")
+else ()
+    set(OUTPUT_DIRECTORY FluentUI)
+endif ()
+
+#set(CMAKE_AUTOMOC ON)
+#set(CMAKE_AUTORCC ON)
+
+xgd_add_library(${PROJECT_NAME} PRIVATE_INCLUDE_DIRS ${INC_DIR})
+xgd_link_libraries(${PROJECT_NAME} PRIVATE ZXing)
+xgd_link_qt(${PROJECT_NAME} PRIVATE Quick)
+
+aux_source_directory(${SRC_DIR} source_files)
+list(REMOVE_ITEM source_files "${SRC_DIR}/fluentuiplugin.cpp")
+
+# create target ${PROJECT_NAME}plugin
+qt_add_qml_module(${PROJECT_NAME}
+        PLUGIN_TARGET ""
+        OUTPUT_DIRECTORY "${OUTPUT_DIRECTORY}"
+        VERSION 1.0
+        URI FluentUI
+        TYPEINFO "plugins.qmltypes"
+        SOURCES ${source_files}
+        QML_FILES ${qml_files}
+        RESOURCES ${resource_files}
+        RESOURCE_PREFIX "/")
+
+if (NOT BUILD_SHARED_LIBS)
+    target_compile_definitions(fluentui PRIVATE FLUENTUI_BUILD_STATIC_LIB)
+endif ()
+
+# FIXME: build framelesshelper
+#xgd_add_library(framelesshelper_core
+#        INCLUDE_DIRS ${ROOT_DIR}/../../framelesshelper/include
+#        SRC_DIRS ${ROOT_DIR}/../../framelesshelper/src/core)
+#xgd_link_qt(framelesshelper_core PRIVATE Gui Core)
+#
+#xgd_add_library(framelesshelper_quick
+#        INCLUDE_DIRS ${ROOT_DIR}/../../framelesshelper/include
+#        SRC_DIRS ${ROOT_DIR}/../../framelesshelper/src/quick)
+#xgd_link_qt(framelesshelper_core PRIVATE Gui Core)
+#xgd_link_libraries(framelesshelper_quick PRIVATE framelesshelper_core)
+#
+#xgd_link_libraries(fluentui PRIVATE framelesshelper_quick framelesshelper_core)
\ No newline at end of file
Index: cppcoro-src/cppcoro/lib/file_read_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/file_read_operation.cpp b/cppcoro-src/cppcoro/lib/file_read_operation.cpp
--- a/cppcoro-src/cppcoro/lib/file_read_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/file_read_operation.cpp	(date 1701843666804)
@@ -9,7 +9,7 @@
 # ifndef WIN32_LEAN_AND_MEAN
 #  define WIN32_LEAN_AND_MEAN
 # endif
-# include <Windows.h>
+# include <windows.h>
 
 bool cppcoro::file_read_operation_impl::try_start(
 	cppcoro::detail::win32_overlapped_operation_base& operation) noexcept
Index: cppcoro-src/cppcoro/lib/file_write_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/file_write_operation.cpp b/cppcoro-src/cppcoro/lib/file_write_operation.cpp
--- a/cppcoro-src/cppcoro/lib/file_write_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/file_write_operation.cpp	(date 1701843666804)
@@ -9,7 +9,7 @@
 # ifndef WIN32_LEAN_AND_MEAN
 #  define WIN32_LEAN_AND_MEAN
 # endif
-# include <Windows.h>
+# include <windows.h>
 
 bool cppcoro::file_write_operation_impl::try_start(
 	cppcoro::detail::win32_overlapped_operation_base& operation) noexcept
Index: cppcoro-src/cppcoro/lib/async_mutex.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/async_mutex.cpp b/cppcoro-src/cppcoro/lib/async_mutex.cpp
--- a/cppcoro-src/cppcoro/lib/async_mutex.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/async_mutex.cpp	(date 1701843666803)
@@ -85,7 +85,7 @@
 	waitersHead->m_awaiter.resume();
 }
 
-bool cppcoro::async_mutex_lock_operation::await_suspend(std::experimental::coroutine_handle<> awaiter) noexcept
+bool cppcoro::async_mutex_lock_operation::await_suspend(std::coroutine_handle<> awaiter) noexcept
 {
 	m_awaiter = awaiter;
 
Index: cppcoro-src/cppcoro/lib/io_service.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/io_service.cpp b/cppcoro-src/cppcoro/lib/io_service.cpp
--- a/cppcoro-src/cppcoro/lib/io_service.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/io_service.cpp	(date 1701843666805)
@@ -18,10 +18,10 @@
 # ifndef NOMINMAX
 #  define NOMINMAX
 # endif
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 #endif
 
 namespace
@@ -642,7 +642,7 @@
 			{
 				// This was a coroutine scheduled via a call to
 				// io_service::schedule().
-				std::experimental::coroutine_handle<>::from_address(
+				std::coroutine_handle<>::from_address(
 					reinterpret_cast<void*>(completionKey)).resume();
 				return true;
 			}
@@ -911,7 +911,7 @@
 }
 
 void cppcoro::io_service::schedule_operation::await_suspend(
-	std::experimental::coroutine_handle<> awaiter) noexcept
+	std::coroutine_handle<> awaiter) noexcept
 {
 	m_awaiter = awaiter;
 	m_service.schedule_impl(this);
@@ -947,7 +947,7 @@
 }
 
 void cppcoro::io_service::timed_schedule_operation::await_suspend(
-	std::experimental::coroutine_handle<> awaiter)
+	std::coroutine_handle<> awaiter)
 {
 	m_scheduleOperation.m_awaiter = awaiter;
 
Index: cppcoro-src/cppcoro/lib/socket_helpers.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_helpers.hpp b/cppcoro-src/cppcoro/lib/socket_helpers.hpp
--- a/cppcoro-src/cppcoro/lib/socket_helpers.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_helpers.hpp	(date 1701843666809)
@@ -13,6 +13,9 @@
 struct sockaddr_storage;
 #endif
 
+# include <cstring>
+# include <memory>
+
 namespace cppcoro
 {
 	namespace net
Index: cppcoro-src/cppcoro/lib/socket_connect_operation.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket_connect_operation.cpp b/cppcoro-src/cppcoro/lib/socket_connect_operation.cpp
--- a/cppcoro-src/cppcoro/lib/socket_connect_operation.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket_connect_operation.cpp	(date 1701843666808)
@@ -14,10 +14,10 @@
 #include <system_error>
 
 #if CPPCORO_OS_WINNT
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 
 bool cppcoro::net::socket_connect_operation_impl::try_start(
 	cppcoro::detail::win32_overlapped_operation_base& operation) noexcept
Index: cppcoro-src/cppcoro/lib/lightweight_manual_reset_event.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/lightweight_manual_reset_event.cpp b/cppcoro-src/cppcoro/lib/lightweight_manual_reset_event.cpp
--- a/cppcoro-src/cppcoro/lib/lightweight_manual_reset_event.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/lightweight_manual_reset_event.cpp	(date 1701843666805)
@@ -11,7 +11,7 @@
 # ifndef WIN32_LEAN_AND_MEAN
 #  define WIN32_LEAN_AND_MEAN
 # endif
-# include <Windows.h>
+# include <windows.h>
 
 # if CPPCORO_OS_WINNT >= 0x0602
 
Index: cppcoro-src/cppcoro/lib/writable_file.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/writable_file.cpp b/cppcoro-src/cppcoro/lib/writable_file.cpp
--- a/cppcoro-src/cppcoro/lib/writable_file.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/writable_file.cpp	(date 1701843666812)
@@ -11,7 +11,7 @@
 # ifndef WIN32_LEAN_AND_MEAN
 #  define WIN32_LEAN_AND_MEAN
 # endif
-# include <Windows.h>
+# include <windows.h>
 
 void cppcoro::writable_file::set_size(
 	std::uint64_t fileSize)
Index: cppcoro-src/cppcoro/lib/socket.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/lib/socket.cpp b/cppcoro-src/cppcoro/lib/socket.cpp
--- a/cppcoro-src/cppcoro/lib/socket.cpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/lib/socket.cpp	(date 1701843666807)
@@ -17,10 +17,10 @@
 #include "socket_helpers.hpp"
 
 #if CPPCORO_OS_WINNT
-# include <WinSock2.h>
-# include <WS2tcpip.h>
-# include <MSWSock.h>
-# include <Windows.h>
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <mswsock.h>
+# include <windows.h>
 
 namespace
 {
Index: svgpp-src/svgpp/include/svgpp/utility/gil/mask.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/utility/gil/mask.hpp b/svgpp-src/svgpp/include/svgpp/utility/gil/mask.hpp
--- a/svgpp-src/svgpp/include/svgpp/utility/gil/mask.hpp	(revision f460b2c7ceba92a875c0ba5c333826652863b396)
+++ b/svgpp-src/svgpp/include/svgpp/utility/gil/mask.hpp	(date 1699257749242)
@@ -28,6 +28,7 @@
   GrayChannelValue operator()(const RedChannel& red, const GreenChannel& green, const BlueChannel& blue) const 
   {
     using namespace boost::gil;
+    using boost::gil::float32_t;
     return channel_convert<GrayChannelValue>(
       channel_convert<float32_t>(red  )*0.2125f +
       channel_convert<float32_t>(green)*0.7154f +
Index: openbabel-src/openbabel/src/alias.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/alias.cpp b/openbabel-src/openbabel/src/alias.cpp
--- a/openbabel-src/openbabel/src/alias.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/alias.cpp	(date 1696647929171)
@@ -222,7 +222,7 @@
 bool AliasData::LoadFile(SuperAtomTable& table)
 {
   //In table: key=alias left-form; value=pair<alias right-form, SMILES>
-  ifstream ifs;
+  istringstream ifs;
   if (OpenDatafile(ifs, "superatom.txt").length() == 0)
   {
     obErrorLog.ThrowError(__FUNCTION__, "Cannot open superatom.txt", obError);
@@ -250,7 +250,7 @@
 bool AliasData::LoadFile(SmartsTable& smtable)
 {
   //Re-parse the datafile. Seems simpler than trying to extract from the map.
-  ifstream ifs;
+  istringstream ifs;
   if (OpenDatafile(ifs, "superatom.txt").length() == 0)
   {
     obErrorLog.ThrowError(__FUNCTION__, "Cannot open superatom.txt", obError);
Index: cppcoro-src/cppcoro/include/cppcoro/async_scope.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/async_scope.hpp b/cppcoro-src/cppcoro/include/cppcoro/async_scope.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/async_scope.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/async_scope.hpp	(date 1701843666793)
@@ -8,7 +8,7 @@
 #include <cppcoro/on_scope_exit.hpp>
 
 #include <atomic>
-#include <experimental/coroutine>
+#include <coroutine>
 #include <type_traits>
 #include <cassert>
 
@@ -52,7 +52,7 @@
 					return m_scope->m_count.load(std::memory_order_acquire) == 0;
 				}
 
-				bool await_suspend(std::experimental::coroutine_handle<> continuation) noexcept
+				bool await_suspend(std::coroutine_handle<> continuation) noexcept
 				{
 					m_scope->m_continuation = continuation;
 					return m_scope->m_count.fetch_sub(1u, std::memory_order_acq_rel) > 1u;
@@ -85,8 +85,8 @@
 		{
 			struct promise_type
 			{
-				std::experimental::suspend_never initial_suspend() { return {}; }
-				std::experimental::suspend_never final_suspend() { return {}; }
+				std::suspend_never initial_suspend() { return {}; }
+				std::suspend_never final_suspend() { return {}; }
 				void unhandled_exception() { std::terminate(); }
 				oneway_task get_return_object() { return {}; }
 				void return_void() {}
@@ -94,7 +94,7 @@
 		};
 
 		std::atomic<size_t> m_count;
-		std::experimental::coroutine_handle<> m_continuation;
+		std::coroutine_handle<> m_continuation;
 
 	};
 }
Index: openbabel-src/openbabel/src/distgeom.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/distgeom.cpp b/openbabel-src/openbabel/src/distgeom.cpp
--- a/openbabel-src/openbabel/src/distgeom.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/distgeom.cpp	(date 1696647929175)
@@ -16,7 +16,7 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 ***********************************************************************/
-
+#include <openbabel/babelconfig.h>
 #ifdef HAVE_EIGEN
 
 #include <openbabel/distgeom.h>
Index: cppcoro-src/cppcoro/include/cppcoro/round_robin_scheduler.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/round_robin_scheduler.hpp b/cppcoro-src/cppcoro/include/cppcoro/round_robin_scheduler.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/round_robin_scheduler.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/round_robin_scheduler.hpp	(date 1701843666800)
@@ -7,7 +7,7 @@
 
 #include <cppcoro/config.hpp>
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <array>
 #include <cassert>
 #include <algorithm>
@@ -44,8 +44,8 @@
 				return false;
 			}
 
-			std::experimental::coroutine_handle<> await_suspend(
-				std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+			std::coroutine_handle<> await_suspend(
+				std::coroutine_handle<> awaitingCoroutine) noexcept
 			{
 				return m_scheduler.exchange_next(awaitingCoroutine);
 			}
@@ -61,7 +61,7 @@
 	public:
 		round_robin_scheduler() noexcept
 			: m_index(0)
-			, m_noop(std::experimental::noop_coroutine())
+			, m_noop(std::noop_coroutine())
 		{
 			for (size_t i = 0; i < N - 1; ++i)
 			{
@@ -104,8 +104,8 @@
 
 	private:
 
-		std::experimental::coroutine_handle exchange_next(
-			std::experimental::coroutine_handle<> coroutine) noexcept
+		std::coroutine_handle exchange_next(
+			std::coroutine_handle<> coroutine) noexcept
 		{
 			auto coroutineToResume = std::exchange(
 				m_scheduler.m_coroutines[m_scheduler.m_index],
@@ -115,8 +115,8 @@
 		}
 
 		size_t m_index;
-		const std::experimental::coroutine_handle<> m_noop;
-		std::array<std::experimental::coroutine_handle<>, N - 1> m_coroutines;
+		const std::coroutine_handle<> m_noop;
+		std::array<std::coroutine_handle<>, N - 1> m_coroutines;
 	};
 #endif
 }
Index: cppcoro-src/cppcoro/include/cppcoro/multi_producer_sequencer.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/multi_producer_sequencer.hpp b/cppcoro-src/cppcoro/include/cppcoro/multi_producer_sequencer.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/multi_producer_sequencer.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/multi_producer_sequencer.hpp	(date 1701843666799)
@@ -194,7 +194,7 @@
 			return m_barrierWait.await_ready();
 		}
 
-		auto await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+		auto await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 		{
 			return m_barrierWait.await_suspend(awaitingCoroutine);
 		}
@@ -273,7 +273,7 @@
 			return m_waitOp.await_ready();
 		}
 
-		auto await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+		auto await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 		{
 			return m_waitOp.await_suspend(awaitingCoroutine);
 		}
@@ -347,7 +347,7 @@
 			return !TRAITS::precedes(m_lastKnownPublished, m_targetSequence);
 		}
 
-		bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+		bool await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 		{
 			m_awaitingCoroutine = awaitingCoroutine;
 
@@ -384,7 +384,7 @@
 		SEQUENCE m_targetSequence;
 		SEQUENCE m_lastKnownPublished;
 		multi_producer_sequencer_wait_operation_base* m_next;
-		std::experimental::coroutine_handle<> m_awaitingCoroutine;
+		std::coroutine_handle<> m_awaitingCoroutine;
 		std::atomic<bool> m_readyToResume;
 	};
 
Index: openbabel-src/openbabel/src/op.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/op.cpp b/openbabel-src/openbabel/src/op.cpp
--- a/openbabel-src/openbabel/src/op.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/op.cpp	(date 1696647929196)
@@ -22,10 +22,6 @@
 using namespace std;
 namespace OpenBabel
 {
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-  // macro to implement static OBPlugin::PluginMapType& Map()
-  PLUGIN_CPP_FILE(OBOp)
-#endif
 }
 
 
Index: openbabel-src/openbabel/src/locale.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/locale.cpp b/openbabel-src/openbabel/src/locale.cpp
--- a/openbabel-src/openbabel/src/locale.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/locale.cpp	(date 1696647929193)
@@ -16,33 +16,19 @@
 GNU General Public License for more details.
 ***********************************************************************/
 
-#include <stdlib.h>
-#include <string.h>
 #include <openbabel/locale.h>
-
-#if HAVE_XLOCALE_H
-#include <xlocale.h>
-#endif
-#if HAVE_LOCALE_H
-#include <locale.h>
-#endif
+#include <string>
+#include <clocale>
 
 namespace OpenBabel
 {
   class OBLocalePrivate {
   public:
-    char *old_locale_string;
-#if HAVE_USELOCALE
-    locale_t new_c_num_locale;
-    locale_t old_locale;
-#endif
+    std::string old_locale_string;
     unsigned int counter; // Reference counter -- ensures balance in SetLocale/RestoreLocale calls
 
     OBLocalePrivate(): counter(0)
     {
-#if HAVE_USELOCALE
-      new_c_num_locale = newlocale(LC_NUMERIC_MASK, NULL, NULL);
-#endif
     }
 
     ~OBLocalePrivate()
@@ -92,21 +78,8 @@
   void OBLocale::SetLocale()
   {
     if (d->counter == 0) {
-      // Set the locale for number parsing to avoid locale issues: PR#1785463
-#if HAVE_USELOCALE
-      // Extended per-thread interface
-      d->old_locale = uselocale(d->new_c_num_locale);
-#else
-#ifndef ANDROID
-      // Original global POSIX interface
-      // regular UNIX, no USELOCALE, no ANDROID
-      d->old_locale_string = strdup(setlocale(LC_NUMERIC, nullptr));
-#else
-      // ANDROID should stay as "C" -- Igor Filippov
-      d->old_locale_string = "C";
-#endif
+      d->old_locale_string = std::setlocale(LC_ALL, nullptr);
   	  setlocale(LC_NUMERIC, "C");
-#endif
     }
 
     ++d->counter;
@@ -117,15 +90,7 @@
     --d->counter;
     if(d->counter == 0) {
       // return the locale to the original one
-#ifdef HAVE_USELOCALE
-      uselocale(d->old_locale);
-#else
-      setlocale(LC_NUMERIC, d->old_locale_string);
-#ifndef ANDROID
-      // Don't free on Android because "C" is a static ctring constant
-      free (d->old_locale_string);
-#endif
-#endif
+      std::setlocale(LC_NUMERIC, d->old_locale_string.c_str());
     }
   }
 
Index: openbabel-src/openbabel/src/config.h.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/config.h.cmake b/openbabel-src/openbabel/src/config.h.cmake
--- a/openbabel-src/openbabel/src/config.h.cmake	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/config.h.cmake	(date 1696647929173)
@@ -16,23 +16,12 @@
 /* The file extension used for shared modules */
 #define MODULE_EXTENSION "@MODULE_EXTENSION@"
 
+#include <openbabel_export.hpp>
 // If we are using a recent GCC version with visibility support use it
-#ifdef HAVE_GCC_VISIBILITY
-  #define OB_EXPORT __attribute__ ((visibility("default")))
-  #define OB_IMPORT __attribute__ ((visibility("default")))
-  #define OB_HIDDEN __attribute__ ((visibility("hidden")))
-#elif defined(WIN32) && defined(USING_DYNAMIC_LIBS) && !defined(__MINGW32__)
- #define OB_EXPORT __declspec(dllexport)
- #define OB_IMPORT __declspec(dllimport)
- #define OB_HIDDEN
-#else
- #define OB_EXPORT
- #define OB_IMPORT
- #define OB_HIDDEN
+#ifndef OB_EXPORT
+#define OB_EXPORT OPENBABEL_EXPORT
 #endif
 
-/* Used to export symbols for DLL / shared library builds */
-#if defined(MAKE_OBDLL) // e.g. in src/main.cpp
  #ifndef OB_EXTERN
   #define OB_EXTERN   OB_EXPORT extern
  #endif
@@ -60,39 +49,6 @@
  #ifndef OBDEPICT
   #define OBDEPICT OB_EXPORT
  #endif
-
-#else   // defined(MAKE_OBDLL)
-
- #ifndef OB_EXTERN
-  #define OB_EXTERN   OB_IMPORT extern
- #endif
- #ifndef OBAPI
-  #define OBAPI    OB_IMPORT
- #endif
- #ifndef OBCOMMON
-  #define OBCOMMON OB_IMPORT
- #endif
- #ifndef OBCONV
-  #define OBCONV   OB_IMPORT
- #endif
- #ifndef OBERROR
-  #define OBERROR  OB_IMPORT
- #endif
- #ifndef OBFPRT
-  #define OBFPRT   OB_IMPORT
- #endif
- #ifndef OBFPTR
-  #define OBFPTR   OB_IMPORT
- #endif
- #ifndef OBMCDL
- #define OBMCDL    OB_IMPORT
-  #ifndef OBDEPICT
- #define OBDEPICT  OB_IMPORT
- #endif
-
- #endif
-
-#endif
 
 #ifdef _MSC_VER
  // Suppress warning on deprecated functions
@@ -149,6 +105,22 @@
 /* have struct clock_t */
 #cmakedefine HAVE_CLOCK_T 1
 
+#cmakedefine HAVE_REGEX_H 1
+
+#cmakedefine HAVE_SHARED_POINTER 1
+
+#cmakedefine HAVE_EIGEN 1
+
+#cmakedefine HAVE_EIGEN3 1
+
+#cmakedefine HAVE_STATIC_INCHI 1
+
+#cmakedefine HAVE_LIBZ 1
+
+#cmakedefine HAVE_STATIC_LIBXML 1
+
+#cmakedefine HAVE_RPC_XDR_H 1
+
 /* shared pointer implementation to be used */
 #cmakedefine OB_SHARED_PTR_IMPLEMENTATION @OB_SHARED_PTR_IMPLEMENTATION@
 
Index: openbabel-src/openbabel/src/RDKitConv.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/RDKitConv.cpp b/openbabel-src/openbabel/src/RDKitConv.cpp
--- a/openbabel-src/openbabel/src/RDKitConv.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/RDKitConv.cpp	(date 1696647929171)
@@ -23,6 +23,9 @@
 ***********************************************************************/
 
 #include <openbabel/babelconfig.h>
+#include <openbabel/oberror.h>
+#include <openbabel/bond.h>
+#include <openbabel/bondtyper.h>
 #include <RDKitConv.h>
 
 using OpenBabel::OBMolAtomIter;
@@ -45,7 +48,7 @@
   {
     //bond order >3 needs doing properly
     //assume RDKit atom indices start at 0
-    RDMol.addBond(b->GetBeginAtomIdx()-1, b->GetEndAtomIdx()-1, (RDKit::Bond::BondType)b->GetBO());
+    RDMol.addBond(b->GetBeginAtomIdx()-1, b->GetEndAtomIdx()-1, (RDKit::Bond::BondType)b->GetBondOrder());
   }
   std::string msg("RWMol made from ");
   if(pOBMol->GetTitle())
Index: openbabel-src/openbabel/src/bondtyper.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/bondtyper.cpp b/openbabel-src/openbabel/src/bondtyper.cpp
--- a/openbabel-src/openbabel/src/bondtyper.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/bondtyper.cpp	(date 1696647929172)
@@ -24,8 +24,6 @@
 #include <openbabel/bondtyper.h>
 #include <openbabel/elements.h>
 
-// data header with default parameters
-#include "bondtyp.h"
 
 using namespace std;
 
@@ -54,7 +52,7 @@
     _envvar = "BABEL_DATADIR";
     _filename = "bondtyp.txt";
     _subdir = "data";
-    _dataptr = BondTypeData;
+    _dataptr = nullptr;
   }
 
   void OBBondTyper::ParseLine(const char *buffer)
Index: openbabel-src/openbabel/src/zipstreamimpl.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/zipstreamimpl.h b/openbabel-src/openbabel/src/zipstreamimpl.h
--- a/openbabel-src/openbabel/src/zipstreamimpl.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/zipstreamimpl.h	(date 1696647929202)
@@ -176,8 +176,7 @@
     }
     while(_err == Z_OK);
 
-    if(&_ostream)
-			_ostream.flush();
+    _ostream.flush();
 
     return total_written_byte_size;
 }
Index: openbabel-src/openbabel/src/mcdlutil.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/mcdlutil.cpp b/openbabel-src/openbabel/src/mcdlutil.cpp
--- a/openbabel-src/openbabel/src/mcdlutil.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/mcdlutil.cpp	(date 1696647929195)
@@ -5033,7 +5033,7 @@
 
     if (bondLabel != nullptr && nBonds() > 0) {
       bondLabel->resize(molecule1->nBonds());
-      if (test2) for (j=0; j<molecule1->nBonds(); j++) if (bSTested[j]>=0) (*bondLabel)[j]=1; else (*bondLabel)[j]=0;
+      if (test2) for (j=0; j<molecule1->nBonds(); j++) { if (bSTested[j]>=0) (*bondLabel)[j]=1; else (*bondLabel)[j]=0; }
     };
     result=test2;
 
@@ -5102,7 +5102,7 @@
   std::vector<TEditedMolecule *> TemplateRedraw::queryData;
 
   bool TemplateRedraw::loadTemplates() {
-    std::ifstream ifs;
+    std::istringstream ifs;
     string filename("templates.sdf");//("e:\\templates.sdf");
     TEditedMolecule sm;
     TEditedMolecule * em;
Index: openbabel-src/openbabel/src/format.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/format.cpp b/openbabel-src/openbabel/src/format.cpp
--- a/openbabel-src/openbabel/src/format.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/format.cpp	(date 1696647929178)
@@ -23,11 +23,6 @@
 using namespace std;
 namespace OpenBabel
 {
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-  // macro to implement static OBPlugin::PluginMapType& Map()
-  PLUGIN_CPP_FILE(OBFormat)
-#endif
-
 int OBFormat::RegisterFormat(const char* ID, const char* MIME)
 {
   GetMap()[ID] = this;
Index: cppcoro-src/cppcoro/include/cppcoro/file_read_operation.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/file_read_operation.hpp b/cppcoro-src/cppcoro/include/cppcoro/file_read_operation.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/file_read_operation.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/file_read_operation.hpp	(date 1701843666797)
@@ -11,7 +11,7 @@
 
 #include <atomic>
 #include <optional>
-#include <experimental/coroutine>
+#include <coroutine>
 
 #if CPPCORO_OS_WINNT
 # include <cppcoro/detail/win32.hpp>
Index: openbabel-src/openbabel/src/obmolecformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/obmolecformat.cpp b/openbabel-src/openbabel/src/obmolecformat.cpp
--- a/openbabel-src/openbabel/src/obmolecformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/obmolecformat.cpp	(date 1696647929196)
@@ -500,12 +500,12 @@
 
     NameIndexType::iterator itr;
 
-    ifstream indexstream;
+    istringstream indexstream;
     OpenDatafile(indexstream, datafilename + ".obindx");
     if(!indexstream)
       {
         //Need to prepare the index
-        ifstream datastream;
+        istringstream datastream;
         string datafilepath = OpenDatafile(datastream, datafilename);
         if(!datastream)
           {
Index: openbabel-src/openbabel/src/phmodel.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/phmodel.cpp b/openbabel-src/openbabel/src/phmodel.cpp
--- a/openbabel-src/openbabel/src/phmodel.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/phmodel.cpp	(date 1696647929199)
@@ -28,8 +28,6 @@
 
 #include <cstdlib>
 
-// private data header with default parameters
-#include "phmodeldata.h"
 
 #ifdef WIN32
 #pragma warning (disable : 4786)
@@ -50,7 +48,7 @@
     _envvar = "BABEL_DATADIR";
     _filename = "phmodel.txt";
     _subdir = "data";
-    _dataptr = PhModelData;
+    _dataptr = nullptr;
   }
 
   OBPhModel::~OBPhModel()
Index: cppcoro-src/cppcoro/include/cppcoro/async_generator.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/async_generator.hpp b/cppcoro-src/cppcoro/include/cppcoro/async_generator.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/async_generator.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/async_generator.hpp	(date 1701843666791)
@@ -12,7 +12,7 @@
 #include <atomic>
 #include <iterator>
 #include <type_traits>
-#include <experimental/coroutine>
+#include <coroutine>
 #include <functional>
 #include <cassert>
 
@@ -45,7 +45,7 @@
 			async_generator_promise_base(const async_generator_promise_base& other) = delete;
 			async_generator_promise_base& operator=(const async_generator_promise_base& other) = delete;
 
-			std::experimental::suspend_always initial_suspend() const noexcept
+			std::suspend_always initial_suspend() const noexcept
 			{
 				return {};
 			}
@@ -89,7 +89,7 @@
 
 			std::exception_ptr m_exception;
 
-			std::experimental::coroutine_handle<> m_consumerCoroutine;
+			std::coroutine_handle<> m_consumerCoroutine;
 
 		protected:
 
@@ -100,7 +100,7 @@
 		{
 		public:
 
-			async_generator_yield_operation(std::experimental::coroutine_handle<> consumer) noexcept
+			async_generator_yield_operation(std::coroutine_handle<> consumer) noexcept
 				: m_consumer(consumer)
 			{}
 
@@ -109,8 +109,8 @@
 				return false;
 			}
 
-			std::experimental::coroutine_handle<>
-			await_suspend([[maybe_unused]] std::experimental::coroutine_handle<> producer) noexcept
+			std::coroutine_handle<>
+			await_suspend([[maybe_unused]] std::coroutine_handle<> producer) noexcept
 			{
 				return m_consumer;
 			}
@@ -119,7 +119,7 @@
 
 		private:
 
-			std::experimental::coroutine_handle<> m_consumer;
+			std::coroutine_handle<> m_consumer;
 
 		};
 
@@ -145,7 +145,7 @@
 
 			async_generator_advance_operation(
 				async_generator_promise_base& promise,
-				std::experimental::coroutine_handle<> producerCoroutine) noexcept
+				std::coroutine_handle<> producerCoroutine) noexcept
 				: m_promise(std::addressof(promise))
 				, m_producerCoroutine(producerCoroutine)
 			{
@@ -155,8 +155,8 @@
 
 			bool await_ready() const noexcept { return false; }
 
-			std::experimental::coroutine_handle<>
-				await_suspend(std::experimental::coroutine_handle<> consumerCoroutine) noexcept
+			std::coroutine_handle<>
+				await_suspend(std::coroutine_handle<> consumerCoroutine) noexcept
 			{
 				m_promise->m_consumerCoroutine = consumerCoroutine;
 				return m_producerCoroutine;
@@ -165,7 +165,7 @@
 		protected:
 
 			async_generator_promise_base* m_promise;
-			std::experimental::coroutine_handle<> m_producerCoroutine;
+			std::coroutine_handle<> m_producerCoroutine;
 
 		};
 
@@ -242,7 +242,7 @@
 		class async_generator_iterator final
 		{
 			using promise_type = async_generator_promise<T>;
-			using handle_type = std::experimental::coroutine_handle<promise_type>;
+			using handle_type = std::coroutine_handle<promise_type>;
 
 		public:
 
@@ -307,7 +307,7 @@
 		class async_generator_begin_operation final : public async_generator_advance_operation
 		{
 			using promise_type = async_generator_promise<T>;
-			using handle_type = std::experimental::coroutine_handle<promise_type>;
+			using handle_type = std::coroutine_handle<promise_type>;
 
 		public:
 
@@ -358,7 +358,7 @@
 		{}
 
 		explicit async_generator(promise_type& promise) noexcept
-			: m_coroutine(std::experimental::coroutine_handle<promise_type>::from_promise(promise))
+			: m_coroutine(std::coroutine_handle<promise_type>::from_promise(promise))
 		{}
 
 		async_generator(async_generator&& other) noexcept
@@ -408,7 +408,7 @@
 
 	private:
 
-		std::experimental::coroutine_handle<promise_type> m_coroutine;
+		std::coroutine_handle<promise_type> m_coroutine;
 
 	};
 
@@ -451,7 +451,7 @@
 			async_generator_promise_base(const async_generator_promise_base& other) = delete;
 			async_generator_promise_base& operator=(const async_generator_promise_base& other) = delete;
 
-			std::experimental::suspend_always initial_suspend() const noexcept
+			std::suspend_always initial_suspend() const noexcept
 			{
 				return {};
 			}
@@ -556,7 +556,7 @@
 
 			std::exception_ptr m_exception;
 
-			std::experimental::coroutine_handle<> m_consumerCoroutine;
+			std::coroutine_handle<> m_consumerCoroutine;
 
 		protected:
 
@@ -579,7 +579,7 @@
 				return m_initialState == state::value_not_ready_consumer_suspended;
 			}
 
-			bool await_suspend(std::experimental::coroutine_handle<> producer) noexcept;
+			bool await_suspend(std::coroutine_handle<> producer) noexcept;
 
 			void await_resume() noexcept {}
 
@@ -625,7 +625,7 @@
 		}
 
 		inline bool async_generator_yield_operation::await_suspend(
-			std::experimental::coroutine_handle<> producer) noexcept
+			std::coroutine_handle<> producer) noexcept
 		{
 			state currentState = m_initialState;
 			if (currentState == state::value_not_ready_consumer_active)
@@ -711,7 +711,7 @@
 
 			async_generator_advance_operation(
 				async_generator_promise_base& promise,
-				std::experimental::coroutine_handle<> producerCoroutine) noexcept
+				std::coroutine_handle<> producerCoroutine) noexcept
 				: m_promise(std::addressof(promise))
 				, m_producerCoroutine(producerCoroutine)
 			{
@@ -740,7 +740,7 @@
 				return m_initialState == state::value_ready_producer_suspended;
 			}
 
-			bool await_suspend(std::experimental::coroutine_handle<> consumerCoroutine) noexcept
+			bool await_suspend(std::coroutine_handle<> consumerCoroutine) noexcept
 			{
 				m_promise->m_consumerCoroutine = consumerCoroutine;
 
@@ -791,7 +791,7 @@
 		protected:
 
 			async_generator_promise_base* m_promise;
-			std::experimental::coroutine_handle<> m_producerCoroutine;
+			std::coroutine_handle<> m_producerCoroutine;
 
 		private:
 
@@ -872,7 +872,7 @@
 		class async_generator_iterator final
 		{
 			using promise_type = async_generator_promise<T>;
-			using handle_type = std::experimental::coroutine_handle<promise_type>;
+			using handle_type = std::coroutine_handle<promise_type>;
 
 		public:
 
@@ -937,7 +937,7 @@
 		class async_generator_begin_operation final : public async_generator_advance_operation
 		{
 			using promise_type = async_generator_promise<T>;
-			using handle_type = std::experimental::coroutine_handle<promise_type>;
+			using handle_type = std::coroutine_handle<promise_type>;
 
 		public:
 
@@ -988,7 +988,7 @@
 		{}
 
 		explicit async_generator(promise_type& promise) noexcept
-			: m_coroutine(std::experimental::coroutine_handle<promise_type>::from_promise(promise))
+			: m_coroutine(std::coroutine_handle<promise_type>::from_promise(promise))
 		{}
 
 		async_generator(async_generator&& other) noexcept
@@ -1041,7 +1041,7 @@
 
 	private:
 
-		std::experimental::coroutine_handle<promise_type> m_coroutine;
+		std::coroutine_handle<promise_type> m_coroutine;
 
 	};
 
Index: openbabel-src/openbabel/src/rotor.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/rotor.cpp b/openbabel-src/openbabel/src/rotor.cpp
--- a/openbabel-src/openbabel/src/rotor.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/rotor.cpp	(date 1696647929200)
@@ -31,8 +31,6 @@
 #include <set>
 #include <assert.h>
 
-// private data headers with default parameters
-#include "torlib.h"
 
 #ifndef M_PI
 #define M_PI 3.14159265358979323846
@@ -806,7 +804,7 @@
     _envvar = "BABEL_DATADIR";
     _filename = "torlib.txt";
     _subdir = "data";
-    _dataptr = TorsionDefaults;
+    _dataptr = nullptr;
   }
 
   void OBRotorRules::ParseLine(const char *buffer)
Index: cppcoro-src/cppcoro/include/cppcoro/async_manual_reset_event.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/async_manual_reset_event.hpp b/cppcoro-src/cppcoro/include/cppcoro/async_manual_reset_event.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/async_manual_reset_event.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/async_manual_reset_event.hpp	(date 1701843666792)
@@ -5,7 +5,7 @@
 #ifndef CPPCORO_ASYNC_MANUAL_RESET_EVENT_HPP_INCLUDED
 #define CPPCORO_ASYNC_MANUAL_RESET_EVENT_HPP_INCLUDED
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <atomic>
 #include <cstdint>
 
@@ -87,7 +87,7 @@
 		explicit async_manual_reset_event_operation(const async_manual_reset_event& event) noexcept;
 
 		bool await_ready() const noexcept;
-		bool await_suspend(std::experimental::coroutine_handle<> awaiter) noexcept;
+		bool await_suspend(std::coroutine_handle<> awaiter) noexcept;
 		void await_resume() const noexcept {}
 
 	private:
@@ -96,7 +96,7 @@
 
 		const async_manual_reset_event& m_event;
 		async_manual_reset_event_operation* m_next;
-		std::experimental::coroutine_handle<> m_awaiter;
+		std::coroutine_handle<> m_awaiter;
 
 	};
 }
Index: cppcoro-src/cppcoro/include/cppcoro/read_write_file.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/read_write_file.hpp b/cppcoro-src/cppcoro/include/cppcoro/read_write_file.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/read_write_file.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/read_write_file.hpp	(date 1701843666799)
@@ -11,7 +11,7 @@
 #include <cppcoro/file_buffering_mode.hpp>
 #include <cppcoro/file_open_mode.hpp>
 
-#include <experimental/filesystem>
+#include <filesystem>
 
 namespace cppcoro
 {
@@ -49,7 +49,7 @@
 		[[nodiscard]]
 		static read_write_file open(
 			io_service& ioService,
-			const std::experimental::filesystem::path& path,
+			const std::filesystem::path& path,
 			file_open_mode openMode = file_open_mode::create_or_open,
 			file_share_mode shareMode = file_share_mode::none,
 			file_buffering_mode bufferingMode = file_buffering_mode::default_);
Index: openbabel-src/openbabel/src/confsearch.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/confsearch.cpp b/openbabel-src/openbabel/src/confsearch.cpp
--- a/openbabel-src/openbabel/src/confsearch.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/confsearch.cpp	(date 1696647929174)
@@ -131,7 +131,7 @@
 
     const double arr[] = {3.0, 2.0, 1.5, 1.0, 0.5, 0.25};
     std::vector<double> vec (arr, arr + sizeof(arr) / sizeof(arr[0]) );
-    vec.erase(std::remove_if(vec.begin(), vec.end(), std::bind2nd(std::less<double>(), (cutoff + 0.1) )), vec.end());
+    vec.erase(std::remove_if(vec.begin(), vec.end(), std::bind(std::less<double>(), std::placeholders::_1, (cutoff + 0.1) )), vec.end());
     vec.push_back(cutoff);
 
     levels = vec;
@@ -293,7 +293,7 @@
   std::vector <OBDiversePoses::PosePair> confs, newconfs;
 
   // The leaf iterator will (in effect) iterate over the nodes just at the loweset level
-  for (OBDiversePoses::Tree::leaf_iterator node = poses->begin(); node != poses->end(); ++node)
+  for (auto node = poses->begin(); node != poses->end(); ++node)
     if (node->first.size() > 0) // Don't include the dummy head node
       confs.push_back(*node);
 
@@ -441,7 +441,7 @@
     UpdateConformersFromTree(&_mol, _energies, &divposes, verbose);
 
     // Add back the energy offset
-    transform(_energies.begin(), _energies.end(), _energies.begin(), bind2nd(std::plus<double>(), energy_offset));
+    transform(_energies.begin(), _energies.end(), _energies.begin(), std::bind(std::plus<double>(), std::placeholders::_1, energy_offset));
 
     // Clean up
     delete [] store_initial;
Index: cppcoro-src/cppcoro/include/cppcoro/recursive_generator.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/recursive_generator.hpp b/cppcoro-src/cppcoro/include/cppcoro/recursive_generator.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/recursive_generator.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/recursive_generator.hpp	(date 1701843666799)
@@ -7,7 +7,7 @@
 
 #include <cppcoro/generator.hpp>
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <type_traits>
 #include <utility>
 #include <cassert>
@@ -39,12 +39,12 @@
 				return recursive_generator<T>{ *this };
 			}
 
-			std::experimental::suspend_always initial_suspend() noexcept
+			std::suspend_always initial_suspend() noexcept
 			{
 				return {};
 			}
 
-			std::experimental::suspend_always final_suspend() noexcept
+			std::suspend_always final_suspend() noexcept
 			{
 				return {};
 			}
@@ -56,13 +56,13 @@
 
 			void return_void() noexcept {}
 
-			std::experimental::suspend_always yield_value(T& value) noexcept
+			std::suspend_always yield_value(T& value) noexcept
 			{
 				m_value = std::addressof(value);
 				return {};
 			}
 
-			std::experimental::suspend_always yield_value(T&& value) noexcept
+			std::suspend_always yield_value(T&& value) noexcept
 			{
 				m_value = std::addressof(value);
 				return {};
@@ -87,7 +87,7 @@
 						return this->m_childPromise == nullptr;
 					}
 
-					void await_suspend(std::experimental::coroutine_handle<promise_type>) noexcept
+					void await_suspend(std::coroutine_handle<promise_type>) noexcept
 					{}
 
 					void await_resume()
@@ -122,11 +122,11 @@
 
 			// Don't allow any use of 'co_await' inside the recursive_generator coroutine.
 			template<typename U>
-			std::experimental::suspend_never await_transform(U&& value) = delete;
+			std::suspend_never await_transform(U&& value) = delete;
 
 			void destroy() noexcept
 			{
-				std::experimental::coroutine_handle<promise_type>::from_promise(*this).destroy();
+				std::coroutine_handle<promise_type>::from_promise(*this).destroy();
 			}
 
 			void throw_if_exception()
@@ -139,7 +139,7 @@
 
 			bool is_complete() noexcept
 			{
-				return std::experimental::coroutine_handle<promise_type>::from_promise(*this).done();
+				return std::coroutine_handle<promise_type>::from_promise(*this).done();
 			}
 
 			T& value() noexcept
@@ -167,7 +167,7 @@
 
 			void resume() noexcept
 			{
-				std::experimental::coroutine_handle<promise_type>::from_promise(*this).resume();
+				std::coroutine_handle<promise_type>::from_promise(*this).resume();
 			}
 
 			std::add_pointer_t<T> m_value;
Index: svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns_utils.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns_utils.hpp b/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns_utils.hpp
new file mode 100644
--- /dev/null	(date 1696647929773)
+++ b/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns_utils.hpp	(date 1696647929773)
@@ -0,0 +1,122 @@
+#ifndef RAPIDXML_NS_UTILS_HPP_INCLUDED
+#define RAPIDXML_NS_UTILS_HPP_INCLUDED
+
+// Copyright (C) 2006, 2009 Marcin Kalicinski
+// Version 1.13
+// Revision $DateTime: 2009/05/15 23:02:39 $
+//! \file rapidxml_utils.hpp This file contains high-level rapidxml utilities that can be useful
+//! in certain simple scenarios. They should probably not be used if maximizing performance is the main objective.
+
+#include "rapidxml_ns.hpp"
+#include <vector>
+#include <string>
+#include <fstream>
+#include <stdexcept>
+
+namespace rapidxml_ns
+{
+
+    //! Represents data loaded from a file
+    template<class Ch = char>
+    class file
+    {
+        
+    public:
+        
+        //! Loads file into the memory. Data will be automatically destroyed by the destructor.
+        //! \param filename Filename to load.
+        file(const char *filename)
+        {
+            using namespace std;
+
+            // Open stream
+            basic_ifstream<Ch> stream(filename, ios::binary);
+            if (!stream)
+                throw runtime_error(string("cannot open file ") + filename);
+            stream.unsetf(ios::skipws);
+            
+            // Determine stream size
+            stream.seekg(0, ios::end);
+            size_t size = stream.tellg();
+            stream.seekg(0);   
+            
+            // Load data and add terminating 0
+            m_data.resize(size + 1);
+            stream.read(&m_data.front(), static_cast<streamsize>(size));
+            m_data[size] = 0;
+        }
+
+        //! Loads file into the memory. Data will be automatically destroyed by the destructor
+        //! \param stream Stream to load from
+        file(std::basic_istream<Ch> &stream)
+        {
+            using namespace std;
+
+            // Load data and add terminating 0
+            stream.unsetf(ios::skipws);
+            m_data.assign(istreambuf_iterator<Ch>(stream), istreambuf_iterator<Ch>());
+            if (stream.fail() || stream.bad())
+                throw runtime_error("error reading stream");
+            m_data.push_back(0);
+        }
+        
+        //! Gets file data.
+        //! \return Pointer to data of file.
+        Ch *data()
+        {
+            return &m_data.front();
+        }
+
+        //! Gets file data.
+        //! \return Pointer to data of file.
+        const Ch *data() const
+        {
+            return &m_data.front();
+        }
+
+        //! Gets file data size.
+        //! \return Size of file data, in characters.
+        std::size_t size() const
+        {
+            return m_data.size();
+        }
+
+    private:
+
+        std::vector<Ch> m_data;   // File data
+
+    };
+
+    //! Counts children of node. Time complexity is O(n).
+    //! \return Number of children of node
+    template<class Ch>
+    inline std::size_t count_children(xml_node<Ch> *node)
+    {
+        xml_node<Ch> *child = node->first_node();
+        std::size_t count = 0;
+        while (child)
+        {
+            ++count;
+            child = child->next_sibling();
+        }
+        return count;
+    }
+
+    //! Counts attributes of node. Time complexity is O(n).
+    //! \return Number of attributes of node
+    template<class Ch>
+    inline std::size_t count_attributes(xml_node<Ch> *node)
+    {
+        xml_attribute<Ch> *attr = node->first_attribute();
+        std::size_t count = 0;
+        while (attr)
+        {
+            ++count;
+            attr = attr->next_attribute();
+        }
+        return count;
+    }
+
+}
+
+#endif
Index: cppcoro-src/cppcoro/include/cppcoro/file.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/file.hpp b/cppcoro-src/cppcoro/include/cppcoro/file.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/file.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/file.hpp	(date 1701843666797)
@@ -15,7 +15,7 @@
 # include <cppcoro/detail/win32.hpp>
 #endif
 
-#include <experimental/filesystem>
+#include <filesystem>
 
 namespace cppcoro
 {
@@ -40,7 +40,7 @@
 		static detail::win32::safe_handle open(
 			detail::win32::dword_t fileAccess,
 			io_service& ioService,
-			const std::experimental::filesystem::path& path,
+			const std::filesystem::path& path,
 			file_open_mode openMode,
 			file_share_mode shareMode,
 			file_buffering_mode bufferingMode);
Index: cppcoro-src/cppcoro/include/cppcoro/generator.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/generator.hpp b/cppcoro-src/cppcoro/include/cppcoro/generator.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/generator.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/generator.hpp	(date 1701843666797)
@@ -5,7 +5,7 @@
 #ifndef CPPCORO_GENERATOR_HPP_INCLUDED
 #define CPPCORO_GENERATOR_HPP_INCLUDED
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <type_traits>
 #include <utility>
 #include <exception>
@@ -32,19 +32,19 @@
 
 			generator<T> get_return_object() noexcept;
 
-			constexpr std::experimental::suspend_always initial_suspend() const noexcept { return {}; }
-			constexpr std::experimental::suspend_always final_suspend() const noexcept { return {}; }
+			constexpr std::suspend_always initial_suspend() const noexcept { return {}; }
+			constexpr std::suspend_always final_suspend() const noexcept { return {}; }
 
 			template<
 				typename U = T,
 				std::enable_if_t<!std::is_rvalue_reference<U>::value, int> = 0>
-			std::experimental::suspend_always yield_value(std::remove_reference_t<T>& value) noexcept
+			std::suspend_always yield_value(std::remove_reference_t<T>& value) noexcept
 			{
 				m_value = std::addressof(value);
 				return {};
 			}
 
-			std::experimental::suspend_always yield_value(std::remove_reference_t<T>&& value) noexcept
+			std::suspend_always yield_value(std::remove_reference_t<T>&& value) noexcept
 			{
 				m_value = std::addressof(value);
 				return {};
@@ -66,7 +66,7 @@
 
 			// Don't allow any use of 'co_await' inside the generator coroutine.
 			template<typename U>
-			std::experimental::suspend_never await_transform(U&& value) = delete;
+			std::suspend_never await_transform(U&& value) = delete;
 
 			void rethrow_if_exception()
 			{
@@ -88,7 +88,7 @@
 		template<typename T>
 		class generator_iterator
 		{
-			using coroutine_handle = std::experimental::coroutine_handle<generator_promise<T>>;
+			using coroutine_handle = std::coroutine_handle<generator_promise<T>>;
 
 		public:
 
@@ -223,11 +223,11 @@
 
 		friend class detail::generator_promise<T>;
 
-		explicit generator(std::experimental::coroutine_handle<promise_type> coroutine) noexcept
+		explicit generator(std::coroutine_handle<promise_type> coroutine) noexcept
 			: m_coroutine(coroutine)
 		{}
 
-		std::experimental::coroutine_handle<promise_type> m_coroutine;
+		std::coroutine_handle<promise_type> m_coroutine;
 
 	};
 
@@ -242,7 +242,7 @@
 		template<typename T>
 		generator<T> generator_promise<T>::get_return_object() noexcept
 		{
-			using coroutine_handle = std::experimental::coroutine_handle<generator_promise<T>>;
+			using coroutine_handle = std::coroutine_handle<generator_promise<T>>;
 			return generator<T>{ coroutine_handle::from_promise(*this) };
 		}
 	}
Index: openbabel-src/openbabel/src/plugin.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/plugin.cpp b/openbabel-src/openbabel/src/plugin.cpp
--- a/openbabel-src/openbabel/src/plugin.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/plugin.cpp	(date 1696647929199)
@@ -285,6 +285,8 @@
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theHINFormat)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theJaguarOutputFormat)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theJaguarInputFormat)->GetID());
+  plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theChemDoodleJSONFormat)->GetID());
+  plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&thePubChemJSONFormat)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theLMPDATFormat)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theMCDLFormat)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theMOLFormat)->GetID());
@@ -315,6 +317,7 @@
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&thePDBQTFormat)->GetID());
 #ifdef HAVE_LIBZ
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&thePNGFormat)->GetID());
+  plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&thePNG2Format)->GetID());
 #endif
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&thePointCloudFormat)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&thePovrayFormat)->GetID());
@@ -354,6 +357,8 @@
 #endif
 #ifdef HAVE_STATIC_INCHI
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theInChIFormat)->GetID());
+  plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theInChICompareFormat)->GetID());
+  plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theInChIKeyFormat)->GetID());
 #endif
 #ifdef HAVE_RPC_XDR_H
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theXTCFormat)->GetID());
@@ -413,6 +418,7 @@
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOpFillUC)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOpEnergy)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOpMinimize)->GetID());
+  plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOp2D)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOpGen2D)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOpGen3D)->GetID());
   plugin_ids.push_back(reinterpret_cast<OBPlugin*>(&theOpNewS)->GetID());
Index: cppcoro-src/cppcoro/include/cppcoro/static_thread_pool.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/static_thread_pool.hpp b/cppcoro-src/cppcoro/include/cppcoro/static_thread_pool.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/static_thread_pool.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/static_thread_pool.hpp	(date 1701843666801)
@@ -11,7 +11,7 @@
 #include <thread>
 #include <vector>
 #include <mutex>
-#include <experimental/coroutine>
+#include <coroutine>
 
 namespace cppcoro
 {
@@ -38,7 +38,7 @@
 			schedule_operation(static_thread_pool* tp) noexcept : m_threadPool(tp) {}
 
 			bool await_ready() noexcept { return false; }
-			void await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept;
+			void await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept;
 			void await_resume() noexcept {}
 
 		private:
@@ -46,7 +46,7 @@
 			friend class static_thread_pool;
 
 			static_thread_pool* m_threadPool;
-			std::experimental::coroutine_handle<> m_awaitingCoroutine;
+			std::coroutine_handle<> m_awaitingCoroutine;
 			schedule_operation* m_next;
 
 		};
Index: svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns.hpp b/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns.hpp
new file mode 100644
--- /dev/null	(date 1696647929772)
+++ b/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns.hpp	(date 1696647929772)
@@ -0,0 +1,3113 @@
+#ifndef RAPIDXML_NS_HPP_INCLUDED
+#define RAPIDXML_NS_HPP_INCLUDED
+
+// Copyright (C) 2006, 2009 Marcin Kalicinski
+// Version 1.13
+// Revision $DateTime: 2009/05/13 01:46:17 $
+//! \file rapidxml_ns.hpp This file contains rapidxml_ns parser and DOM implementation
+
+// If standard library is disabled, user must provide implementations of required functions and typedefs
+#if !defined(RAPIDXML_NO_STDLIB)
+    #include <cstdlib>      // For std::size_t
+    #include <cassert>      // For assert
+    #include <new>          // For placement new
+    #include <vector>
+#endif
+
+// On MSVC, disable "conditional expression is constant" warning (level 4). 
+// This warning is almost impossible to avoid with certain types of templated code
+#ifdef _MSC_VER
+    #pragma warning(push)
+    #pragma warning(disable:4127)   // Conditional expression is constant
+#endif
+
+///////////////////////////////////////////////////////////////////////////
+// RAPIDXML_PARSE_ERROR
+    
+#if defined(RAPIDXML_NO_EXCEPTIONS)
+
+#define RAPIDXML_PARSE_ERROR(what, where) { parse_error_handler(what, where); assert(0); }
+
+namespace rapidxml_ns
+{
+    //! When exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, 
+    //! this function is called to notify user about the error.
+    //! It must be defined by the user.
+    //! <br><br>
+    //! This function cannot return. If it does, the results are undefined.
+    //! <br><br>
+    //! A very simple definition might look like that:
+    //! <pre>
+    //! void %rapidxml_ns::%parse_error_handler(const char *what, void *where)
+    //! {
+    //!     std::cout << "Parse error: " << what << "\n";
+    //!     std::abort();
+    //! }
+    //! </pre>
+    //! \param what Human readable description of the error.
+    //! \param where Pointer to character data where error was detected.
+    void parse_error_handler(const char *what, void *where);
+}
+
+#else
+    
+#include <exception>    // For std::exception
+
+#define RAPIDXML_PARSE_ERROR(what, where) throw parse_error(what, where)
+
+namespace rapidxml_ns
+{
+
+    //! Parse error exception. 
+    //! This exception is thrown by the parser when an error occurs. 
+    //! Use what() function to get human-readable error message. 
+    //! Use where() function to get a pointer to position within source text where error was detected.
+    //! <br><br>
+    //! If throwing exceptions by the parser is undesirable, 
+    //! it can be disabled by defining RAPIDXML_NO_EXCEPTIONS macro before rapidxml_ns.hpp is included.
+    //! This will cause the parser to call rapidxml_ns::parse_error_handler() function instead of throwing an exception.
+    //! This function must be defined by the user.
+    //! <br><br>
+    //! This class derives from <code>std::exception</code> class.
+    class parse_error: public std::exception
+    {
+    
+    public:
+    
+        //! Constructs parse error
+        parse_error(const char *what, void *where)
+            : m_what(what)
+            , m_where(where)
+        {
+        }
+
+        //! Gets human readable description of error.
+        //! \return Pointer to null terminated description of the error.
+        virtual const char *what() const throw()
+        {
+            return m_what;
+        }
+
+        //! Gets pointer to character data where error happened.
+        //! Ch should be the same as char type of xml_document that produced the error.
+        //! \return Pointer to location within the parsed string where error occured.
+        template<class Ch>
+        Ch *where() const
+        {
+            return reinterpret_cast<Ch *>(m_where);
+        }
+
+    private:  
+
+        const char *m_what;
+        void *m_where;
+
+    };
+}
+
+#endif
+
+///////////////////////////////////////////////////////////////////////////
+// Pool sizes
+
+#ifndef RAPIDXML_STATIC_POOL_SIZE
+    // Size of static memory block of memory_pool.
+    // Define RAPIDXML_STATIC_POOL_SIZE before including rapidxml_ns.hpp if you want to override the default value.
+    // No dynamic memory allocations are performed by memory_pool until static memory is exhausted.
+    #define RAPIDXML_STATIC_POOL_SIZE (64 * 1024)
+#endif
+
+#ifndef RAPIDXML_DYNAMIC_POOL_SIZE
+    // Size of dynamic memory block of memory_pool.
+    // Define RAPIDXML_DYNAMIC_POOL_SIZE before including rapidxml_ns.hpp if you want to override the default value.
+    // After the static block is exhausted, dynamic blocks with approximately this size are allocated by memory_pool.
+    #define RAPIDXML_DYNAMIC_POOL_SIZE (64 * 1024)
+#endif
+
+#ifndef RAPIDXML_ALIGNMENT
+    // Memory allocation alignment.
+    // Define RAPIDXML_ALIGNMENT before including rapidxml_ns.hpp if you want to override the default value, which is the size of pointer.
+    // All memory allocations for nodes, attributes and strings will be aligned to this value.
+    // This must be a power of 2 and at least 1, otherwise memory_pool will not work.
+    #define RAPIDXML_ALIGNMENT sizeof(void *)
+#endif
+
+namespace rapidxml_ns
+{
+    // Forward declarations
+    template<class Ch> class xml_base;
+    template<class Ch> class xml_node;
+    template<class Ch> class xml_attribute;
+    template<class Ch> class xml_document;
+    
+    //! Enumeration listing all node types produced by the parser.
+    //! Use xml_node::type() function to query node type.
+    enum node_type
+    {
+        node_document,      //!< A document node. Name and value are empty.
+        node_element,       //!< An element node. Name contains element name. Value contains text of first data node.
+        node_data,          //!< A data node. Name is empty. Value contains data text.
+        node_cdata,         //!< A CDATA node. Name is empty. Value contains data text.
+        node_comment,       //!< A comment node. Name is empty. Value contains comment text.
+        node_declaration,   //!< A declaration node. Name and value are empty. Declaration parameters (version, encoding and standalone) are in node attributes.
+        node_doctype,       //!< A DOCTYPE node. Name is empty. Value contains DOCTYPE text.
+        node_pi             //!< A PI node. Name contains target. Value contains instructions.
+    };
+
+    ///////////////////////////////////////////////////////////////////////
+    // Parsing flags
+
+    //! Parse flag instructing the parser to not create data nodes. 
+    //! Text of first data node will still be placed in value of parent element, unless rapidxml_ns::parse_no_element_values flag is also specified.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_no_data_nodes = 0x1;            
+
+    //! Parse flag instructing the parser to not use text of first data node as a value of parent element.
+    //! Can be combined with other flags by use of | operator.
+    //! Note that child data nodes of element node take precendence over its value when printing. 
+    //! That is, if element has one or more child data nodes <em>and</em> a value, the value will be ignored.
+    //! Use rapidxml_ns::parse_no_data_nodes flag to prevent creation of data nodes if you want to manipulate data using values of elements.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_no_element_values = 0x2;
+    
+    //! Parse flag instructing the parser to not place zero terminators after strings in the source text.
+    //! By default zero terminators are placed, modifying source text.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_no_string_terminators = 0x4;
+    
+    //! Parse flag instructing the parser to not translate entities in the source text.
+    //! By default entities are translated, modifying source text.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_no_entity_translation = 0x8;
+    
+    //! Parse flag instructing the parser to disable UTF-8 handling and assume plain 8 bit characters.
+    //! By default, UTF-8 handling is enabled.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_no_utf8 = 0x10;
+    
+    //! Parse flag instructing the parser to create XML declaration node.
+    //! By default, declaration node is not created.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_declaration_node = 0x20;
+    
+    //! Parse flag instructing the parser to create comments nodes.
+    //! By default, comment nodes are not created.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_comment_nodes = 0x40;
+    
+    //! Parse flag instructing the parser to create DOCTYPE node.
+    //! By default, doctype node is not created.
+    //! Although W3C specification allows at most one DOCTYPE node, RapidXml will silently accept documents with more than one.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_doctype_node = 0x80;
+    
+    //! Parse flag instructing the parser to create PI nodes.
+    //! By default, PI nodes are not created.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_pi_nodes = 0x100;
+    
+    //! Parse flag instructing the parser to validate closing tag names. 
+    //! If not set, name inside closing tag is irrelevant to the parser.
+    //! By default, closing tags are not validated.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_validate_closing_tags = 0x200;
+    
+    //! Parse flag instructing the parser to trim all leading and trailing whitespace of data nodes.
+    //! By default, whitespace is not trimmed. 
+    //! This flag does not cause the parser to modify source text.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_trim_whitespace = 0x400;
+
+    //! Parse flag instructing the parser to condense all whitespace runs of data nodes to a single space character.
+    //! Trimming of leading and trailing whitespace of data is controlled by rapidxml_ns::parse_trim_whitespace flag.
+    //! By default, whitespace is not normalized. 
+    //! If this flag is specified, source text will be modified.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_normalize_whitespace = 0x800;
+
+    //! Parse flag instructing the parser to skip assigning XML namespace URI to elements and attributes.
+    //! I.e. to behave like original RapidXML parser.
+    //! By default, namespaces are set. 
+    //! This flag does not cause the parser to modify source text.
+    //! Can be combined with other flags by use of | operator.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_no_namespace = 0x1000;
+
+    // Compound flags
+    
+    //! Parse flags which represent default behaviour of the parser. 
+    //! This is always equal to 0, so that all other flags can be simply ored together.
+    //! Normally there is no need to inconveniently disable flags by anding with their negated (~) values.
+    //! This also means that meaning of each flag is a <i>negation</i> of the default setting. 
+    //! For example, if flag name is rapidxml_ns::parse_no_utf8, it means that utf-8 is <i>enabled</i> by default,
+    //! and using the flag will disable it.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_default = 0;
+    
+    //! A combination of parse flags that forbids any modifications of the source text. 
+    //! This also results in faster parsing. However, note that the following will occur:
+    //! <ul>
+    //! <li>names and values of nodes will not be zero terminated, you have to use xml_base::name_size() and xml_base::value_size() functions to determine where name and value ends</li>
+    //! <li>entities will not be translated</li>
+    //! <li>whitespace will not be normalized</li>
+    //! </ul>
+    //! See xml_document::parse() function.
+    const int parse_non_destructive = parse_no_string_terminators | parse_no_entity_translation;
+    
+    //! A combination of parse flags resulting in fastest possible parsing, without sacrificing important data.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_fastest = parse_non_destructive | parse_no_data_nodes;
+    
+    //! A combination of parse flags resulting in largest amount of data being extracted. 
+    //! This usually results in slowest parsing.
+    //! <br><br>
+    //! See xml_document::parse() function.
+    const int parse_full = parse_declaration_node | parse_comment_nodes | parse_doctype_node | parse_pi_nodes | parse_validate_closing_tags;
+
+    template<class Ch>
+    struct xml_namespace
+    {
+        static const size_t prefix_size = 3;
+
+        static Ch const * prefix()
+        {
+            static const Ch value[prefix_size] = {'x', 'm', 'l'};
+            return value;
+        }
+
+        static const size_t uri_size = 36;
+
+        // There should be only one instance of "http://www.w3.org/XML/1998/namespace" string, so
+        // that it can be compared as pointer
+        static Ch const * uri()
+        {
+            static const Ch value[uri_size] = 
+                {'h', 't', 't', 'p', ':', '/', '/', 'w', 'w', 'w', '.', 'w', '3', '.', 'o', 'r', 'g', 
+                 '/', 'X', 'M', 'L', '/', '1', '9', '9', '8', '/', 'n', 'a', 'm', 'e', 's', 'p', 'a', 'c', 'e'};
+            return value;
+        }
+    };
+
+    template<class Ch>
+    struct xmlns_namespace
+    {
+        static const size_t prefix_size = 5;
+
+        static Ch const * prefix()
+        {
+            static const Ch value[prefix_size] = {'x', 'm', 'l', 'n', 's'};
+            return value;
+        }
+
+        static const size_t uri_size = 29;
+
+        // There should be only one instance of "http://www.w3.org/2000/xmlns/" string, so
+        // that it can be compared as pointer
+        static Ch const * uri()
+        {
+            static const Ch value[uri_size] = 
+                {'h', 't', 't', 'p', ':', '/', '/', 'w', 'w', 'w', '.', 'w', '3', '.', 'o', 'r', 'g', 
+                 '/', '2', '0', '0', '0', '/', 'x', 'm', 'l', 'n', 's', '/'};
+            return value;
+        }
+    };
+
+    ///////////////////////////////////////////////////////////////////////
+    // Internals
+
+    //! \cond internal
+    namespace internal
+    {
+
+        // Struct that contains lookup tables for the parser
+        // It must be a template to allow correct linking (because it has static data members, which are defined in a header file).
+        template<int Dummy>
+        struct lookup_tables
+        {
+            static const unsigned char lookup_whitespace[256];              // Whitespace table
+            static const unsigned char lookup_node_name[256];               // Node name table
+            static const unsigned char lookup_node_ncname[256];             // Node NCName table
+            static const unsigned char lookup_text[256];                    // Text table
+            static const unsigned char lookup_text_pure_no_ws[256];         // Text table
+            static const unsigned char lookup_text_pure_with_ws[256];       // Text table
+            static const unsigned char lookup_attribute_name[256];          // Attribute name table
+            static const unsigned char lookup_attribute_ncname[256];        // Attribute NCName table
+            static const unsigned char lookup_attribute_data_1[256];        // Attribute data table with single quote
+            static const unsigned char lookup_attribute_data_1_pure[256];   // Attribute data table with single quote
+            static const unsigned char lookup_attribute_data_2[256];        // Attribute data table with double quotes
+            static const unsigned char lookup_attribute_data_2_pure[256];   // Attribute data table with double quotes
+            static const unsigned char lookup_digits[256];                  // Digits
+            static const unsigned char lookup_upcase[256];                  // To uppercase conversion table for ASCII characters
+        };
+
+        // Find length of the string
+        template<class Ch>
+        inline std::size_t measure(const Ch *p)
+        {
+            const Ch *tmp = p;
+            while (*tmp) 
+                ++tmp;
+            return tmp - p;
+        }
+
+        // Compare strings for equality
+        template<class Ch>
+        inline bool compare(const Ch *p1, std::size_t size1, const Ch *p2, std::size_t size2)
+        {
+            if (size1 != size2)
+                return false;
+            for (const Ch *end = p1 + size1; p1 < end; ++p1, ++p2)
+                if (*p1 != *p2)
+                    return false;
+            return true;
+        }
+
+        // Compare strings for equality with option to ignore case
+        template<class Ch>
+        inline bool compare(const Ch *p1, std::size_t size1, const Ch *p2, std::size_t size2, bool case_sensitive)
+        {
+            if (size1 != size2)
+                return false;
+            if (case_sensitive)
+            {
+                for (const Ch *end = p1 + size1; p1 < end; ++p1, ++p2)
+                    if (*p1 != *p2)
+                        return false;
+            }
+            else
+            {
+                for (const Ch *end = p1 + size1; p1 < end; ++p1, ++p2)
+                    if (lookup_tables<0>::lookup_upcase[static_cast<unsigned char>(*p1)] != lookup_tables<0>::lookup_upcase[static_cast<unsigned char>(*p2)])
+                        return false;
+            }
+            return true;
+        }
+
+        template<class Ch, class NamespaceStorage>
+        void assign_element_namespace_uris(xml_node<Ch> * element, NamespaceStorage & ns_storage)
+        {
+            xml_attribute<Ch> * first_prefixed_attribute = 0;
+            for (xml_attribute<Ch> *attr = element->first_attribute(); attr; attr = attr->next_attribute())
+            {
+                switch (attr->prefix_size())
+                {
+                case 0:
+                    if (compare(attr->name(), attr->name_size(), 
+                        xmlns_namespace<Ch>::prefix(), xmlns_namespace<Ch>::prefix_size))
+                    {
+                        attr->namespace_uri(xmlns_namespace<Ch>::uri(), xmlns_namespace<Ch>::uri_size);
+                        ns_storage.set_default_namespace(attr);
+                    }
+                    continue;
+                case xml_namespace<Ch>::prefix_size:
+                    if (compare(attr->prefix(), attr->prefix_size(), 
+                        xml_namespace<Ch>::prefix(), xml_namespace<Ch>::prefix_size))
+                    {
+                        attr->namespace_uri(xml_namespace<Ch>::uri(), xml_namespace<Ch>::uri_size);
+                        continue;
+                    }
+                    break;
+                case xmlns_namespace<Ch>::prefix_size:
+                    if (compare(attr->prefix(), attr->prefix_size(), 
+                        xmlns_namespace<Ch>::prefix(), xmlns_namespace<Ch>::prefix_size))
+                    {
+                        attr->namespace_uri(xmlns_namespace<Ch>::uri(), xmlns_namespace<Ch>::uri_size);
+                        ns_storage.add_namespace_prefix(attr);
+                        continue;
+                    }
+                    break;
+                } // switch
+                if (!first_prefixed_attribute)
+                    first_prefixed_attribute = attr;
+            } // for
+            if (element->prefix_size() == 0)
+                ns_storage.set_element_default_namespace_uri(element);
+            else
+                ns_storage.set_node_namespace_uri_by_prefix(element);
+
+            for (; first_prefixed_attribute; first_prefixed_attribute = first_prefixed_attribute->next_attribute())
+                if (first_prefixed_attribute->prefix_size() > 0 && first_prefixed_attribute->namespace_uri_size() == 0)
+                    ns_storage.set_node_namespace_uri_by_prefix(first_prefixed_attribute);
+        }
+
+        template<class Ch>
+        class xml_namespace_processor
+        {
+        public:
+            class scope
+            {
+            public:
+                scope(xml_namespace_processor & processor)
+                    : m_processor(processor)
+                    , m_stack_position(processor.m_namespace_prefixes.size())
+                    , m_default_namespace(0)
+                {
+                }
+
+                scope(scope const & parent_scope)
+                    : m_processor(parent_scope.m_processor)
+                    , m_stack_position(m_processor.m_namespace_prefixes.size())
+                    , m_default_namespace(parent_scope.m_default_namespace)
+                {
+                }
+
+                ~scope()
+                {
+                    m_processor.m_namespace_prefixes.resize(m_stack_position);
+                }
+
+                void process_element(xml_node<Ch> * element)
+                {
+                    assign_element_namespace_uris(element, *this);
+                }
+
+                void set_default_namespace(xml_attribute<Ch> * ns_attr)
+                {
+                    m_default_namespace = ns_attr;
+                }
+
+                void add_namespace_prefix(xml_attribute<Ch> * ns_attr)
+                {
+                    m_processor.m_namespace_prefixes.push_back(ns_attr);
+                }
+
+                void set_element_default_namespace_uri(xml_node<Ch> * element) const
+                {
+                    if (m_default_namespace)
+                        element->namespace_uri(m_default_namespace->value(), m_default_namespace->value_size());
+                }
+
+                void set_node_namespace_uri_by_prefix(xml_base<Ch> * node) const
+                {
+                    Ch const * prefix = node->prefix();
+                    std::size_t prefix_size = node->prefix_size();
+                    for (typename xml_namespace_processor::xmlns_attributes_t::const_reverse_iterator 
+                            it = m_processor.m_namespace_prefixes.rbegin();
+                            it != m_processor.m_namespace_prefixes.rend(); ++it)
+                        if (compare((*it)->local_name(), (*it)->local_name_size(), prefix, prefix_size))
+                        {
+                            node->namespace_uri((*it)->value(), (*it)->value_size());
+                            return;
+                        }
+                    RAPIDXML_PARSE_ERROR("No namespace definition found", 0);
+                }
+
+            private:
+                xml_namespace_processor & m_processor;
+                size_t const m_stack_position;
+                xml_attribute<Ch> * m_default_namespace;
+            };
+
+        private:
+            typedef std::vector<xml_attribute<Ch> *> xmlns_attributes_t;
+            xmlns_attributes_t m_namespace_prefixes;
+        };
+
+        template<class Ch>
+        class xml_namespace_processor_stub
+        {
+        public:
+          class scope
+          {
+          public:
+            scope(xml_namespace_processor_stub &)
+            {}
+
+            scope(scope const &)
+            {}
+
+            void process_element(xml_node<Ch> *) const
+            {}
+          };
+        };
+    }
+    //! \endcond
+
+    ///////////////////////////////////////////////////////////////////////
+    // Memory pool
+    
+    //! This class is used by the parser to create new nodes and attributes, without overheads of dynamic memory allocation.
+    //! In most cases, you will not need to use this class directly. 
+    //! However, if you need to create nodes manually or modify names/values of nodes, 
+    //! you are encouraged to use memory_pool of relevant xml_document to allocate the memory. 
+    //! Not only is this faster than allocating them by using <code>new</code> operator, 
+    //! but also their lifetime will be tied to the lifetime of document, 
+    //! possibly simplyfing memory management. 
+    //! <br><br>
+    //! Call allocate_node() or allocate_attribute() functions to obtain new nodes or attributes from the pool. 
+    //! You can also call allocate_string() function to allocate strings.
+    //! Such strings can then be used as names or values of nodes without worrying about their lifetime.
+    //! Note that there is no <code>free()</code> function -- all allocations are freed at once when clear() function is called, 
+    //! or when the pool is destroyed.
+    //! <br><br>
+    //! It is also possible to create a standalone memory_pool, and use it 
+    //! to allocate nodes, whose lifetime will not be tied to any document.
+    //! <br><br>
+    //! Pool maintains <code>RAPIDXML_STATIC_POOL_SIZE</code> bytes of statically allocated memory. 
+    //! Until static memory is exhausted, no dynamic memory allocations are done.
+    //! When static memory is exhausted, pool allocates additional blocks of memory of size <code>RAPIDXML_DYNAMIC_POOL_SIZE</code> each,
+    //! by using global <code>new[]</code> and <code>delete[]</code> operators. 
+    //! This behaviour can be changed by setting custom allocation routines. 
+    //! Use set_allocator() function to set them.
+    //! <br><br>
+    //! Allocations for nodes, attributes and strings are aligned at <code>RAPIDXML_ALIGNMENT</code> bytes.
+    //! This value defaults to the size of pointer on target architecture.
+    //! <br><br>
+    //! To obtain absolutely top performance from the parser,
+    //! it is important that all nodes are allocated from a single, contiguous block of memory.
+    //! Otherwise, cache misses when jumping between two (or more) disjoint blocks of memory can slow down parsing quite considerably.
+    //! If required, you can tweak <code>RAPIDXML_STATIC_POOL_SIZE</code>, <code>RAPIDXML_DYNAMIC_POOL_SIZE</code> and <code>RAPIDXML_ALIGNMENT</code> 
+    //! to obtain best wasted memory to performance compromise.
+    //! To do it, define their values before rapidxml_ns.hpp file is included.
+    //! \param Ch Character type of created nodes. 
+    template<class Ch = char>
+    class memory_pool
+    {
+        
+    public:
+
+        //! \cond internal
+        typedef void *(alloc_func)(std::size_t);       // Type of user-defined function used to allocate memory
+        typedef void (free_func)(void *);              // Type of user-defined function used to free memory
+        //! \endcond
+        
+        //! Constructs empty pool with default allocator functions.
+        memory_pool()
+            : m_alloc_func(0)
+            , m_free_func(0)
+        {
+            init();
+        }
+
+        //! Destroys pool and frees all the memory. 
+        //! This causes memory occupied by nodes allocated by the pool to be freed.
+        //! Nodes allocated from the pool are no longer valid.
+        ~memory_pool()
+        {
+            clear();
+        }
+
+        //! Allocates a new node from the pool, and optionally assigns name and value to it. 
+        //! If the allocation request cannot be accomodated, this function will throw <code>std::bad_alloc</code>.
+        //! If exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, this function
+        //! will call rapidxml_ns::parse_error_handler() function.
+        //! \param type Type of node to create.
+        //! \param name Name to assign to the node, or 0 to assign no name.
+        //! \param value Value to assign to the node, or 0 to assign no value.
+        //! \param name_size Size of name to assign, or 0 to automatically calculate size from name string.
+        //! \param value_size Size of value to assign, or 0 to automatically calculate size from value string.
+        //! \return Pointer to allocated node. This pointer will never be NULL.
+        xml_node<Ch> *allocate_node(node_type type, 
+                                    const Ch *name = 0, const Ch *value = 0, 
+                                    std::size_t name_size = 0, std::size_t value_size = 0)
+        {
+            void *memory = allocate_aligned(sizeof(xml_node<Ch>));
+            xml_node<Ch> *node = new(memory) xml_node<Ch>(type);
+            if (name)
+            {
+                if (name_size > 0)
+                    node->name(name, name_size);
+                else
+                    node->name(name);
+            }
+            if (value)
+            {
+                if (value_size > 0)
+                    node->value(value, value_size);
+                else
+                    node->value(value);
+            }
+            return node;
+        }
+
+        //! Allocates a new attribute from the pool, and optionally assigns name and value to it.
+        //! If the allocation request cannot be accomodated, this function will throw <code>std::bad_alloc</code>.
+        //! If exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, this function
+        //! will call rapidxml_ns::parse_error_handler() function.
+        //! \param name Name to assign to the attribute, or 0 to assign no name.
+        //! \param value Value to assign to the attribute, or 0 to assign no value.
+        //! \param name_size Size of name to assign, or 0 to automatically calculate size from name string.
+        //! \param value_size Size of value to assign, or 0 to automatically calculate size from value string.
+        //! \return Pointer to allocated attribute. This pointer will never be NULL.
+        xml_attribute<Ch> *allocate_attribute(const Ch *name = 0, const Ch *value = 0, 
+                                              std::size_t name_size = 0, std::size_t value_size = 0)
+        {
+            void *memory = allocate_aligned(sizeof(xml_attribute<Ch>));
+            xml_attribute<Ch> *attribute = new(memory) xml_attribute<Ch>;
+            if (name)
+            {
+                if (name_size > 0)
+                    attribute->name(name, name_size);
+                else
+                    attribute->name(name);
+            }
+            if (value)
+            {
+                if (value_size > 0)
+                    attribute->value(value, value_size);
+                else
+                    attribute->value(value);
+            }
+            return attribute;
+        }
+
+        //! Allocates a char array of given size from the pool, and optionally copies a given string to it.
+        //! If the allocation request cannot be accomodated, this function will throw <code>std::bad_alloc</code>.
+        //! If exceptions are disabled by defining RAPIDXML_NO_EXCEPTIONS, this function
+        //! will call rapidxml_ns::parse_error_handler() function.
+        //! \param source String to initialize the allocated memory with, or 0 to not initialize it.
+        //! \param size Number of characters to allocate, or zero to calculate it automatically from source string length; if size is 0, source string must be specified and null terminated.
+        //! \return Pointer to allocated char array. This pointer will never be NULL.
+        Ch *allocate_string(const Ch *source = 0, std::size_t size = 0)
+        {
+            assert(source || size);     // Either source or size (or both) must be specified
+            if (size == 0)
+                size = internal::measure(source) + 1;
+            Ch *result = static_cast<Ch *>(allocate_aligned(size * sizeof(Ch)));
+            if (source)
+                for (std::size_t i = 0; i < size; ++i)
+                    result[i] = source[i];
+            return result;
+        }
+
+        //! Clones an xml_node and its hierarchy of child nodes and attributes.
+        //! Nodes and attributes are allocated from this memory pool.
+        //! Names and values are not cloned, they are shared between the clone and the source.
+        //! Result node can be optionally specified as a second parameter, 
+        //! in which case its contents will be replaced with cloned source node.
+        //! This is useful when you want to clone entire document.
+        //! \param source Node to clone.
+        //! \param result Node to put results in, or 0 to automatically allocate result node
+        //! \return Pointer to cloned node. This pointer will never be NULL.
+        xml_node<Ch> *clone_node(const xml_node<Ch> *source, xml_node<Ch> *result = 0)
+        {
+            // Prepare result node
+            if (result)
+            {
+                result->remove_all_attributes();
+                result->remove_all_nodes();
+                result->type(source->type());
+            }
+            else
+                result = allocate_node(source->type());
+
+            // Clone name and value
+            result->qname(source->name(), source->name_size(), source->local_name());
+            result->value(source->value(), source->value_size());
+
+            // Clone child nodes and attributes
+            for (xml_node<Ch> *child = source->first_node(); child; child = child->next_sibling())
+                result->append_node(clone_node(child));
+            for (xml_attribute<Ch> *attr = source->first_attribute(); attr; attr = attr->next_attribute())
+                result->append_attribute(allocate_attribute(attr->name(), attr->value(), attr->name_size(), attr->value_size()));
+
+            return result;
+        }
+
+        //! Clears the pool. 
+        //! This causes memory occupied by nodes allocated by the pool to be freed.
+        //! Any nodes or strings allocated from the pool will no longer be valid.
+        void clear()
+        {
+            while (m_begin != m_static_memory)
+            {
+                char *previous_begin = reinterpret_cast<header *>(align(m_begin))->previous_begin;
+                if (m_free_func)
+                    m_free_func(m_begin);
+                else
+                    delete[] m_begin;
+                m_begin = previous_begin;
+            }
+            init();
+        }
+
+        //! Sets or resets the user-defined memory allocation functions for the pool.
+        //! This can only be called when no memory is allocated from the pool yet, otherwise results are undefined.
+        //! Allocation function must not return invalid pointer on failure. It should either throw,
+        //! stop the program, or use <code>longjmp()</code> function to pass control to other place of program. 
+        //! If it returns invalid pointer, results are undefined.
+        //! <br><br>
+        //! User defined allocation functions must have the following forms:
+        //! <br><code>
+        //! <br>void *allocate(std::size_t size);
+        //! <br>void free(void *pointer);
+        //! </code><br>
+        //! \param af Allocation function, or 0 to restore default function
+        //! \param ff Free function, or 0 to restore default function
+        void set_allocator(alloc_func *af, free_func *ff)
+        {
+            assert(m_begin == m_static_memory && m_ptr == align(m_begin));    // Verify that no memory is allocated yet
+            m_alloc_func = af;
+            m_free_func = ff;
+        }
+
+    private:
+
+        struct header
+        {
+            char *previous_begin;
+        };
+
+        void init()
+        {
+            m_begin = m_static_memory;
+            m_ptr = align(m_begin);
+            m_end = m_static_memory + sizeof(m_static_memory);
+        }
+        
+        char *align(char *ptr)
+        {
+            std::size_t alignment = ((RAPIDXML_ALIGNMENT - (std::size_t(ptr) & (RAPIDXML_ALIGNMENT - 1))) & (RAPIDXML_ALIGNMENT - 1));
+            return ptr + alignment;
+        }
+        
+        char *allocate_raw(std::size_t size)
+        {
+            // Allocate
+            void *memory;   
+            if (m_alloc_func)   // Allocate memory using either user-specified allocation function or global operator new[]
+            {
+                memory = m_alloc_func(size);
+                assert(memory); // Allocator is not allowed to return 0, on failure it must either throw, stop the program or use longjmp
+            }
+            else
+            {
+                memory = new char[size];
+#ifdef RAPIDXML_NO_EXCEPTIONS
+                if (!memory)            // If exceptions are disabled, verify memory allocation, because new will not be able to throw bad_alloc
+                    RAPIDXML_PARSE_ERROR("out of memory", 0);
+#endif
+            }
+            return static_cast<char *>(memory);
+        }
+        
+        void *allocate_aligned(std::size_t size)
+        {
+            // Calculate aligned pointer
+            char *result = align(m_ptr);
+
+            // If not enough memory left in current pool, allocate a new pool
+            if (result + size > m_end)
+            {
+                // Calculate required pool size (may be bigger than RAPIDXML_DYNAMIC_POOL_SIZE)
+                std::size_t pool_size = RAPIDXML_DYNAMIC_POOL_SIZE;
+                if (pool_size < size)
+                    pool_size = size;
+                
+                // Allocate
+                std::size_t alloc_size = sizeof(header) + (2 * RAPIDXML_ALIGNMENT - 2) + pool_size;     // 2 alignments required in worst case: one for header, one for actual allocation
+                char *raw_memory = allocate_raw(alloc_size);
+                    
+                // Setup new pool in allocated memory
+                char *pool = align(raw_memory);
+                header *new_header = reinterpret_cast<header *>(pool);
+                new_header->previous_begin = m_begin;
+                m_begin = raw_memory;
+                m_ptr = pool + sizeof(header);
+                m_end = raw_memory + alloc_size;
+
+                // Calculate aligned pointer again using new pool
+                result = align(m_ptr);
+            }
+
+            // Update pool and return aligned pointer
+            m_ptr = result + size;
+            return result;
+        }
+
+        char *m_begin;                                      // Start of raw memory making up current pool
+        char *m_ptr;                                        // First free byte in current pool
+        char *m_end;                                        // One past last available byte in current pool
+        char m_static_memory[RAPIDXML_STATIC_POOL_SIZE];    // Static raw memory
+        alloc_func *m_alloc_func;                           // Allocator function, or 0 if default is to be used
+        free_func *m_free_func;                             // Free function, or 0 if default is to be used
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    // XML base
+
+    //! Base class for xml_node and xml_attribute implementing common functions: 
+    //! name(), name_size(), value(), value_size() and parent().
+    //! \param Ch Character type to use
+    template<class Ch = char>
+    class xml_base
+    {
+
+    public:
+        
+        ///////////////////////////////////////////////////////////////////////////
+        // Construction & destruction
+    
+        // Construct a base with empty name, value and parent
+        xml_base()
+            : m_local_name(0)
+            , m_name(0)
+            , m_namespace_uri(0)
+            , m_value(0)
+            , m_parent(0)
+        {
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Node data access
+    
+        Ch *local_name() const
+        {
+            return m_local_name ? m_local_name : nullstr();
+        }
+
+        std::size_t local_name_size() const
+        {
+            return m_local_name ? (m_name_size - (m_local_name - m_name)) : 0;
+        }
+
+        //! Gets namespace prefix.
+        //! Returned string is never zero-terminated, regardless of parse_no_string_terminators. Use prefix_size()
+        //! "Note that the prefix functions only as a placeholder for a namespace name. Applications 
+        //! SHOULD use the namespace name, not the prefix, in constructing names whose scope extends beyond the containing 
+        //! document" Namespaces in XML 1.0 (Third Edition)
+        Ch *prefix() const
+        {
+            return m_name ? m_name : nullstr();
+        }
+
+        //! Gets size of namespace prefix, not including terminator character.
+        //! \return Size of namespace prefix, in characters.
+        std::size_t prefix_size() const
+        {
+            return (m_name && m_local_name > m_name) ? (m_local_name - m_name - 1) : 0;
+        }
+
+        //! Gets QName of the node. 
+        //! Interpretation of name depends on type of node.
+        //! Note that name will not be zero-terminated if rapidxml_ns::parse_no_string_terminators option was selected during parse.
+        //! <br><br>
+        //! Use name_size() function to determine length of the name.
+        //! \return Name of node, or empty string if node has no name.
+        Ch *name() const
+        {
+            return m_name ? m_name : nullstr();
+        }
+
+        //! Gets size of node QName, not including terminator character.
+        //! This function works correctly irrespective of whether name is or is not zero terminated.
+        //! \return Size of node name, in characters.
+        std::size_t name_size() const
+        {
+            return m_name ? m_name_size : 0;
+        }
+
+        //! Gets value of node. 
+        //! Interpretation of value depends on type of node.
+        //! Note that value will not be zero-terminated if rapidxml_ns::parse_no_string_terminators option was selected during parse.
+        //! <br><br>
+        //! Use value_size() function to determine length of the value.
+        //! \return Value of node, or empty string if node has no value.
+        Ch *value() const
+        {
+            return m_value ? m_value : nullstr();
+        }
+
+        //! Gets size of node value, not including terminator character.
+        //! This function works correctly irrespective of whether value is or is not zero terminated.
+        //! \return Size of node value, in characters.
+        std::size_t value_size() const
+        {
+            return m_value ? m_value_size : 0;
+        }
+
+        //! Gets namespace URI of the node. 
+        //! Note that URI will not be zero-terminated if rapidxml_ns::parse_no_string_terminators option was selected during parse.
+        //! Namespace URI is not assigned if rapidxml_ns::parse_no_namespace option was selected during parse.
+        //! <br><br>
+        //! Use namespace_uri_size() function to determine length of the name.
+        //! \return Namespace URI of node, or empty string if node has no namespace assigned.
+        Ch const *namespace_uri() const
+        {
+            return m_namespace_uri ? m_namespace_uri : nullstr();
+        }
+
+        //! Gets size of namespace URI value, not including terminator character.
+        //! This function works correctly irrespective of whether namespace URI is or is not zero terminated.
+        //! \return Size of namespace URI, in characters.
+        std::size_t namespace_uri_size() const
+        {
+            return m_namespace_uri ? m_namespace_uri_size : 0;
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Node modification
+    
+        //! Sets QName of node to a non zero-terminated string.
+        //! See \ref ownership_of_strings.
+        //! <br><br>
+        //! Note that node does not own its name or value, it only stores a pointer to it. 
+        //! It will not delete or otherwise free the pointer on destruction.
+        //! It is reponsibility of the user to properly manage lifetime of the string.
+        //! The easiest way to achieve it is to use memory_pool of the document to allocate the string -
+        //! on destruction of the document the string will be automatically freed.
+        //! <br><br>
+        //! Note that passed string will not be automatically divided to prefix and local_name,
+        //! it seems useless for manual node creation. qname() may be used instead
+        //! local_name() will be set to be equal to name()
+        //! <br><br>
+        //! Size of name must be specified separately, because name does not have to be zero terminated.
+        //! Use name(const Ch *) function to have the length automatically calculated (string must be zero terminated).
+        //! \param name QName of node to set. Does not have to be zero terminated.
+        //! \param size Size of name, in characters. This does not include zero terminator, if one is present.
+        void name(const Ch *name, std::size_t size)
+        {
+            qname(name, size);
+        }
+
+        //! Sets QName of node to a zero-terminated string.
+        //! See also \ref ownership_of_strings and xml_node::name(const Ch *, std::size_t).
+        //! \param name Name of node to set. Must be zero terminated.
+        void name(const Ch *name)
+        {
+            this->name(name, internal::measure(name));
+        }
+
+        //! Sets QName as PrefixedName or UnprefixedName where local_part points in QName string
+        void qname(const Ch *qname, std::size_t qname_size, const Ch * local_part)
+        {
+            m_name = const_cast<Ch *>(qname);
+            m_name_size = qname_size;
+            m_local_name = const_cast<Ch *>(local_part);
+        }
+
+        //! Sets QName as UnprefixedName
+        void qname(const Ch *qname, std::size_t qname_size)
+        {
+            m_name = const_cast<Ch *>(qname);
+            m_name_size = qname_size;
+            m_local_name = m_name;
+        }
+
+        void namespace_uri(const Ch *uri, std::size_t size)
+        {
+            m_namespace_uri = uri;
+            m_namespace_uri_size = size;
+        }
+
+        //! Sets value of node to a non zero-terminated string.
+        //! See \ref ownership_of_strings.
+        //! <br><br>
+        //! Note that node does not own its name or value, it only stores a pointer to it. 
+        //! It will not delete or otherwise free the pointer on destruction.
+        //! It is responsibility of the user to properly manage lifetime of the string.
+        //! The easiest way to achieve it is to use memory_pool of the document to allocate the string -
+        //! on destruction of the document the string will be automatically freed.
+        //! <br><br>
+        //! Size of value must be specified separately, because it does not have to be zero terminated.
+        //! Use value(const Ch *) function to have the length automatically calculated (string must be zero terminated).
+        //! <br><br>
+        //! If an element has a child node of type node_data, it will take precedence over element value when printing.
+        //! If you want to manipulate data of elements using values, use parser flag rapidxml_ns::parse_no_data_nodes to prevent creation of data nodes by the parser.
+        //! \param value value of node to set. Does not have to be zero terminated.
+        //! \param size Size of value, in characters. This does not include zero terminator, if one is present.
+        void value(const Ch *value, std::size_t size)
+        {
+            m_value = const_cast<Ch *>(value);
+            m_value_size = size;
+        }
+
+        //! Sets value of node to a zero-terminated string.
+        //! See also \ref ownership_of_strings and xml_node::value(const Ch *, std::size_t).
+        //! \param value Vame of node to set. Must be zero terminated.
+        void value(const Ch *value)
+        {
+            this->value(value, internal::measure(value));
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Related nodes access
+    
+        //! Gets node parent.
+        //! \return Pointer to parent node, or 0 if there is no parent.
+        xml_node<Ch> *parent() const
+        {
+            return m_parent;
+        }
+
+    protected:
+
+        // Return empty string
+        static Ch *nullstr()
+        {
+            static Ch zero = Ch('\0');
+            return &zero;
+        }
+
+        Ch *m_local_name;                   // Pointer into m_name where local part begins
+        Ch *m_name;                         // Name of node, or 0 if no name
+        Ch *m_value;                        // Value of node, or 0 if no value
+        Ch const *m_namespace_uri;
+        std::size_t m_name_size;            // Length of node name, or undefined of no name
+        std::size_t m_value_size;           // Length of node value, or undefined if no value
+        std::size_t m_namespace_uri_size;
+        xml_node<Ch> *m_parent;             // Pointer to parent node, or 0 if none
+
+    };
+
+    //! Class representing attribute node of XML document. 
+    //! Each attribute has name and value strings, which are available through name() and value() functions (inherited from xml_base).
+    //! Note that after parse, both name and value of attribute will point to interior of source text used for parsing. 
+    //! Thus, this text must persist in memory for the lifetime of attribute.
+    //! \param Ch Character type to use.
+    template<class Ch = char>
+    class xml_attribute: public xml_base<Ch>
+    {
+
+        friend class xml_node<Ch>;
+    
+    public:
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Construction & destruction
+    
+        //! Constructs an empty attribute with the specified type. 
+        //! Consider using memory_pool of appropriate xml_document if allocating attributes manually.
+        xml_attribute()
+        {
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Related nodes access
+    
+        //! Gets document of which attribute is a child.
+        //! \return Pointer to document that contains this attribute, or 0 if there is no parent document.
+        xml_document<Ch> *document() const
+        {
+            if (xml_node<Ch> *node = this->parent())
+            {
+                while (node->parent())
+                    node = node->parent();
+                return node->type() == node_document ? static_cast<xml_document<Ch> *>(node) : 0;
+            }
+            else
+                return 0;
+        }
+
+        //! Gets previous attribute, optionally matching attribute name. 
+        //! \param name Name of attribute to find, or 0 to return previous attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found attribute, or 0 if not found.
+        xml_attribute<Ch> *previous_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_attribute<Ch> *attribute = m_prev_attribute; attribute; attribute = attribute->m_prev_attribute)
+                    if (internal::compare(attribute->name(), attribute->name_size(), name, name_size, case_sensitive))
+                        return attribute;
+                return 0;
+            }
+            else
+                return this->m_parent ? m_prev_attribute : 0;
+        }
+
+        //! Gets next attribute, optionally matching attribute name. 
+        //! \param name Name of attribute to find, or 0 to return next attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found attribute, or 0 if not found.
+        xml_attribute<Ch> *next_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_attribute<Ch> *attribute = m_next_attribute; attribute; attribute = attribute->m_next_attribute)
+                    if (internal::compare(attribute->name(), attribute->name_size(), name, name_size, case_sensitive))
+                        return attribute;
+                return 0;
+            }
+            else
+                return this->m_parent ? m_next_attribute : 0;
+        }
+
+        //! Gets next attribute, matching attribute local name and attribute namespace URI . 
+        //! \param namespace_uri Namespace URI of attribute to find; this string have to be zero-terminated
+        //! \param local_name Local name of attribute to find; this string have to be zero-terminated
+        //! \param local_name_case_sensitive Should local name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found attribute, or 0 if not found.
+        xml_attribute<Ch> *next_attribute_ns(const Ch * namespace_uri, const Ch *local_name, 
+                                             bool local_name_case_sensitive = true) const
+        {
+            return next_attribute_ns(namespace_uri, internal::measure(namespace_uri), 
+                local_name, internal::measure(local_name), local_name_case_sensitive);
+        }
+
+        xml_attribute<Ch> *next_attribute_ns(const Ch * namespace_uri, std::size_t namespace_uri_size, 
+                                             const Ch *local_name,     std::size_t local_name_size, 
+                                             bool local_name_case_sensitive = true) const
+        {
+            for (xml_attribute<Ch> *attribute = m_next_attribute; attribute; attribute = attribute->m_next_attribute)
+                if (internal::compare(attribute->local_name(), attribute->local_name_size(), 
+                        local_name, local_name_size, local_name_case_sensitive)
+                    && internal::compare(attribute->namespace_uri(), attribute->namespace_uri_size(), 
+                        namespace_uri, namespace_uri_size))
+                    return attribute;
+            return 0;
+        }
+
+    private:
+
+        xml_attribute<Ch> *m_prev_attribute;        // Pointer to previous sibling of attribute, or 0 if none; only valid if parent is non-zero
+        xml_attribute<Ch> *m_next_attribute;        // Pointer to next sibling of attribute, or 0 if none; only valid if parent is non-zero
+    
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    // XML node
+
+    //! Class representing a node of XML document. 
+    //! Each node may have associated name and value strings, which are available through name() and value() functions. 
+    //! Interpretation of name and value depends on type of the node.
+    //! Type of node can be determined by using type() function.
+    //! <br><br>
+    //! Note that after parse, both name and value of node, if any, will point interior of source text used for parsing. 
+    //! Thus, this text must persist in the memory for the lifetime of node.
+    //! \param Ch Character type to use.
+    template<class Ch = char>
+    class xml_node: public xml_base<Ch>
+    {
+
+    public:
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Construction & destruction
+    
+        //! Constructs an empty node with the specified type. 
+        //! Consider using memory_pool of appropriate document to allocate nodes manually.
+        //! \param type Type of node to construct.
+        xml_node(node_type type)
+            : m_type(type)
+            , m_first_node(0)
+            , m_first_attribute(0)
+        {
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Node data access
+    
+        //! Gets type of node.
+        //! \return Type of node.
+        node_type type() const
+        {
+            return m_type;
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Related nodes access
+    
+        //! Gets document of which node is a child.
+        //! \return Pointer to document that contains this node, or 0 if there is no parent document.
+        xml_document<Ch> *document() const
+        {
+            xml_node<Ch> *node = const_cast<xml_node<Ch> *>(this);
+            while (node->parent())
+                node = node->parent();
+            return node->type() == node_document ? static_cast<xml_document<Ch> *>(node) : 0;
+        }
+
+        //! Gets first child node, optionally matching node name.
+        //! \param name Name of child to find, or 0 to return first child regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found child, or 0 if not found.
+        xml_node<Ch> *first_node(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_node<Ch> *child = m_first_node; child; child = child->next_sibling())
+                    if (internal::compare(child->name(), child->name_size(), name, name_size, case_sensitive))
+                        return child;
+                return 0;
+            }
+            else
+                return m_first_node;
+        }
+
+        //! Gets first child node, matching node local name and namespace URI.
+        //! \param namespace_uri Namespace URI of child to find; this string have to be zero-terminated
+        //! \param local_name Local name of child to find; this string have to be zero-terminated
+        //! \param local_name_case_sensitive Should local name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found child, or 0 if not found.
+        xml_node<Ch> *first_node_ns(const Ch * namespace_uri, const Ch *local_name, 
+                                    bool local_name_case_sensitive = true) const
+        {
+            return first_node_ns(namespace_uri, internal::measure(namespace_uri), 
+                local_name, internal::measure(local_name), local_name_case_sensitive);
+        }
+
+        xml_node<Ch> *first_node_ns(const Ch *namespace_uri,  std::size_t namespace_uri_size, 
+                                    const Ch *local_name,     std::size_t local_name_size, 
+                                    bool local_name_case_sensitive = true) const
+        {
+            for (xml_node<Ch> *child = m_first_node; child; child = child->next_sibling())
+                if (internal::compare(child->local_name(), child->local_name_size(), 
+                        local_name, local_name_size, local_name_case_sensitive)
+                    && internal::compare(child->namespace_uri(), child->namespace_uri_size(), 
+                        namespace_uri, namespace_uri_size))
+                    return child;
+            return 0;
+        }
+
+        xml_node<Ch> *first_node_ns(const Ch *namespace_uri, std::size_t namespace_uri_size = 0) const
+        {
+            if (namespace_uri_size == 0)
+                namespace_uri_size = internal::measure(namespace_uri);
+            for (xml_node<Ch> *child = m_first_node; child; child = child->next_sibling())
+                if (internal::compare(child->namespace_uri(), child->namespace_uri_size(), namespace_uri, namespace_uri_size))
+                    return child;
+            return 0;
+        }
+
+        //! Gets last child node, optionally matching node name. 
+        //! Behaviour is undefined if node has no children.
+        //! Use first_node() to test if node has children.
+        //! \param name Name of child to find, or 0 to return last child regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found child, or 0 if not found.
+        xml_node<Ch> *last_node(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            assert(m_first_node);  // Cannot query for last child if node has no children
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_node<Ch> *child = m_last_node; child; child = child->previous_sibling())
+                    if (internal::compare(child->name(), child->name_size(), name, name_size, case_sensitive))
+                        return child;
+                return 0;
+            }
+            else
+                return m_last_node;
+        }
+
+        //! Gets previous sibling node, optionally matching node name. 
+        //! Behaviour is undefined if node has no parent.
+        //! Use parent() to test if node has a parent.
+        //! \param name Name of sibling to find, or 0 to return previous sibling regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found sibling, or 0 if not found.
+        xml_node<Ch> *previous_sibling(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            assert(this->m_parent);     // Cannot query for siblings if node has no parent
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_node<Ch> *sibling = m_prev_sibling; sibling; sibling = sibling->m_prev_sibling)
+                    if (internal::compare(sibling->name(), sibling->name_size(), name, name_size, case_sensitive))
+                        return sibling;
+                return 0;
+            }
+            else
+                return m_prev_sibling;
+        }
+
+        //! Gets next sibling node, optionally matching node name. 
+        //! Behaviour is undefined if node has no parent.
+        //! Use parent() to test if node has a parent.
+        //! \param name Name of sibling to find, or 0 to return next sibling regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found sibling, or 0 if not found.
+        xml_node<Ch> *next_sibling(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            assert(this->m_parent);     // Cannot query for siblings if node has no parent
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_node<Ch> *sibling = m_next_sibling; sibling; sibling = sibling->m_next_sibling)
+                    if (internal::compare(sibling->name(), sibling->name_size(), name, name_size, case_sensitive))
+                        return sibling;
+                return 0;
+            }
+            else
+                return m_next_sibling;
+        }
+
+        xml_node<Ch> *next_sibling_ns(const Ch * namespace_uri, const Ch *local_name, 
+                                      bool local_name_case_sensitive = true) const
+        {
+            return next_sibling_ns(namespace_uri, internal::measure(namespace_uri), 
+                local_name, internal::measure(local_name), local_name_case_sensitive);
+        }
+
+        xml_node<Ch> *next_sibling_ns(const Ch * namespace_uri, std::size_t namespace_uri_size, 
+                                      const Ch *local_name,     std::size_t local_name_size, 
+                                      bool local_name_case_sensitive = true) const
+        {
+            for (xml_node<Ch> *sibling = m_next_sibling; sibling; sibling = sibling->m_next_sibling)
+                if (internal::compare(sibling->local_name(), sibling->local_name_size(), 
+                        local_name, local_name_size, local_name_case_sensitive)
+                    && internal::compare(sibling->namespace_uri(), sibling->namespace_uri_size(), 
+                        namespace_uri, namespace_uri_size))
+                    return sibling;
+            return 0;
+        }
+
+        xml_node<Ch> *next_sibling_ns(const Ch *namespace_uri, std::size_t namespace_uri_size = 0) const
+        {
+            if (namespace_uri_size == 0)
+                namespace_uri_size = internal::measure(namespace_uri);
+            for (xml_node<Ch> *sibling = m_next_sibling; sibling; sibling = sibling->m_next_sibling)
+                if (internal::compare(sibling->namespace_uri(), sibling->namespace_uri_size(), namespace_uri, namespace_uri_size))
+                    return sibling;
+            return 0;
+        }
+
+        //! Gets first attribute of node, optionally matching attribute name.
+        //! \param name Name of attribute to find, or 0 to return first attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found attribute, or 0 if not found.
+        xml_attribute<Ch> *first_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_attribute<Ch> *attribute = m_first_attribute; attribute; attribute = attribute->m_next_attribute)
+                    if (internal::compare(attribute->name(), attribute->name_size(), name, name_size, case_sensitive))
+                        return attribute;
+                return 0;
+            }
+            else
+                return m_first_attribute;
+        }
+
+        //! Gets first attribute of node, matching attribute namespace URI and local name.
+        //! \param namespace_uri Namespace URI of attribute to find; this string have to be zero-terminated
+        //! \param local_name Local name of attribute to find; this string have to be zero-terminated
+        //! \param local_name_case_sensitive Should local name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found attribute, or 0 if not found.
+        xml_attribute<Ch> *first_attribute_ns(const Ch * namespace_uri, const Ch *local_name, 
+                                             bool local_name_case_sensitive = true) const
+        {
+            return first_attribute_ns(namespace_uri, internal::measure(namespace_uri), 
+                local_name, internal::measure(local_name), local_name_case_sensitive);
+        }
+
+        xml_attribute<Ch> *first_attribute_ns(const Ch * namespace_uri, std::size_t namespace_uri_size, 
+                                             const Ch *local_name,     std::size_t local_name_size, 
+                                             bool local_name_case_sensitive = true) const
+        {
+            for (xml_attribute<Ch> *attribute = m_first_attribute; attribute; attribute = attribute->m_next_attribute)
+                if (internal::compare(attribute->local_name(), attribute->local_name_size(), 
+                        local_name, local_name_size, local_name_case_sensitive)
+                    && internal::compare(attribute->namespace_uri(), attribute->namespace_uri_size(), 
+                        namespace_uri, namespace_uri_size))
+                    return attribute;
+            return 0;
+        }
+
+        //! Gets last attribute of node, optionally matching attribute name.
+        //! \param name Name of attribute to find, or 0 to return last attribute regardless of its name; this string doesn't have to be zero-terminated if name_size is non-zero
+        //! \param name_size Size of name, in characters, or 0 to have size calculated automatically from string
+        //! \param case_sensitive Should name comparison be case-sensitive; non case-sensitive comparison works properly only for ASCII characters
+        //! \return Pointer to found attribute, or 0 if not found.
+        xml_attribute<Ch> *last_attribute(const Ch *name = 0, std::size_t name_size = 0, bool case_sensitive = true) const
+        {
+            if (name)
+            {
+                if (name_size == 0)
+                    name_size = internal::measure(name);
+                for (xml_attribute<Ch> *attribute = m_last_attribute; attribute; attribute = attribute->m_prev_attribute)
+                    if (internal::compare(attribute->name(), attribute->name_size(), name, name_size, case_sensitive))
+                        return attribute;
+                return 0;
+            }
+            else
+                return m_first_attribute ? m_last_attribute : 0;
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Node modification
+    
+        //! Sets type of node.
+        //! \param type Type of node to set.
+        void type(node_type type)
+        {
+            m_type = type;
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Node manipulation
+
+        //! Prepends a new child node.
+        //! The prepended child becomes the first child, and all existing children are moved one position back.
+        //! \param child Node to prepend.
+        void prepend_node(xml_node<Ch> *child)
+        {
+            assert(child && !child->parent() && child->type() != node_document);
+            if (first_node())
+            {
+                child->m_next_sibling = m_first_node;
+                m_first_node->m_prev_sibling = child;
+            }
+            else
+            {
+                child->m_next_sibling = 0;
+                m_last_node = child;
+            }
+            m_first_node = child;
+            child->m_parent = this;
+            child->m_prev_sibling = 0;
+        }
+
+        //! Appends a new child node. 
+        //! The appended child becomes the last child.
+        //! \param child Node to append.
+        void append_node(xml_node<Ch> *child)
+        {
+            assert(child && !child->parent() && child->type() != node_document);
+            if (first_node())
+            {
+                child->m_prev_sibling = m_last_node;
+                m_last_node->m_next_sibling = child;
+            }
+            else
+            {
+                child->m_prev_sibling = 0;
+                m_first_node = child;
+            }
+            m_last_node = child;
+            child->m_parent = this;
+            child->m_next_sibling = 0;
+        }
+
+        //! Inserts a new child node at specified place inside the node. 
+        //! All children after and including the specified node are moved one position back.
+        //! \param where Place where to insert the child, or 0 to insert at the back.
+        //! \param child Node to insert.
+        void insert_node(xml_node<Ch> *where, xml_node<Ch> *child)
+        {
+            assert(!where || where->parent() == this);
+            assert(child && !child->parent() && child->type() != node_document);
+            if (where == m_first_node)
+                prepend_node(child);
+            else if (where == 0)
+                append_node(child);
+            else
+            {
+                child->m_prev_sibling = where->m_prev_sibling;
+                child->m_next_sibling = where;
+                where->m_prev_sibling->m_next_sibling = child;
+                where->m_prev_sibling = child;
+                child->m_parent = this;
+            }
+        }
+
+        //! Removes first child node. 
+        //! If node has no children, behaviour is undefined.
+        //! Use first_node() to test if node has children.
+        void remove_first_node()
+        {
+            assert(first_node());
+            xml_node<Ch> *child = m_first_node;
+            m_first_node = child->m_next_sibling;
+            if (child->m_next_sibling)
+                child->m_next_sibling->m_prev_sibling = 0;
+            else
+                m_last_node = 0;
+            child->m_parent = 0;
+        }
+
+        //! Removes last child of the node. 
+        //! If node has no children, behaviour is undefined.
+        //! Use first_node() to test if node has children.
+        void remove_last_node()
+        {
+            assert(first_node());
+            xml_node<Ch> *child = m_last_node;
+            if (child->m_prev_sibling)
+            {
+                m_last_node = child->m_prev_sibling;
+                child->m_prev_sibling->m_next_sibling = 0;
+            }
+            else
+                m_first_node = 0;
+            child->m_parent = 0;
+        }
+
+        //! Removes specified child from the node
+        // \param where Pointer to child to be removed.
+        void remove_node(xml_node<Ch> *where)
+        {
+            assert(where && where->parent() == this);
+            assert(first_node());
+            if (where == m_first_node)
+                remove_first_node();
+            else if (where == m_last_node)
+                remove_last_node();
+            else
+            {
+                where->m_prev_sibling->m_next_sibling = where->m_next_sibling;
+                where->m_next_sibling->m_prev_sibling = where->m_prev_sibling;
+                where->m_parent = 0;
+            }
+        }
+
+        //! Removes all child nodes (but not attributes).
+        void remove_all_nodes()
+        {
+            for (xml_node<Ch> *node = first_node(); node; node = node->m_next_sibling)
+                node->m_parent = 0;
+            m_first_node = 0;
+        }
+
+        //! Prepends a new attribute to the node.
+        //! \param attribute Attribute to prepend.
+        void prepend_attribute(xml_attribute<Ch> *attribute)
+        {
+            assert(attribute && !attribute->parent());
+            if (first_attribute())
+            {
+                attribute->m_next_attribute = m_first_attribute;
+                m_first_attribute->m_prev_attribute = attribute;
+            }
+            else
+            {
+                attribute->m_next_attribute = 0;
+                m_last_attribute = attribute;
+            }
+            m_first_attribute = attribute;
+            attribute->m_parent = this;
+            attribute->m_prev_attribute = 0;
+        }
+
+        //! Appends a new attribute to the node.
+        //! \param attribute Attribute to append.
+        void append_attribute(xml_attribute<Ch> *attribute)
+        {
+            assert(attribute && !attribute->parent());
+            if (first_attribute())
+            {
+                attribute->m_prev_attribute = m_last_attribute;
+                m_last_attribute->m_next_attribute = attribute;
+            }
+            else
+            {
+                attribute->m_prev_attribute = 0;
+                m_first_attribute = attribute;
+            }
+            m_last_attribute = attribute;
+            attribute->m_parent = this;
+            attribute->m_next_attribute = 0;
+        }
+
+        //! Inserts a new attribute at specified place inside the node. 
+        //! All attributes after and including the specified attribute are moved one position back.
+        //! \param where Place where to insert the attribute, or 0 to insert at the back.
+        //! \param attribute Attribute to insert.
+        void insert_attribute(xml_attribute<Ch> *where, xml_attribute<Ch> *attribute)
+        {
+            assert(!where || where->parent() == this);
+            assert(attribute && !attribute->parent());
+            if (where == m_first_attribute)
+                prepend_attribute(attribute);
+            else if (where == 0)
+                append_attribute(attribute);
+            else
+            {
+                attribute->m_prev_attribute = where->m_prev_attribute;
+                attribute->m_next_attribute = where;
+                where->m_prev_attribute->m_next_attribute = attribute;
+                where->m_prev_attribute = attribute;
+                attribute->m_parent = this;
+            }
+        }
+
+        //! Removes first attribute of the node. 
+        //! If node has no attributes, behaviour is undefined.
+        //! Use first_attribute() to test if node has attributes.
+        void remove_first_attribute()
+        {
+            assert(first_attribute());
+            xml_attribute<Ch> *attribute = m_first_attribute;
+            if (attribute->m_next_attribute)
+            {
+                attribute->m_next_attribute->m_prev_attribute = 0;
+            }
+            else
+                m_last_attribute = 0;
+            attribute->m_parent = 0;
+            m_first_attribute = attribute->m_next_attribute;
+        }
+
+        //! Removes last attribute of the node. 
+        //! If node has no attributes, behaviour is undefined.
+        //! Use first_attribute() to test if node has attributes.
+        void remove_last_attribute()
+        {
+            assert(first_attribute());
+            xml_attribute<Ch> *attribute = m_last_attribute;
+            if (attribute->m_prev_attribute)
+            {
+                attribute->m_prev_attribute->m_next_attribute = 0;
+                m_last_attribute = attribute->m_prev_attribute;
+            }
+            else
+                m_first_attribute = 0;
+            attribute->m_parent = 0;
+        }
+
+        //! Removes specified attribute from node.
+        //! \param where Pointer to attribute to be removed.
+        void remove_attribute(xml_attribute<Ch> *where)
+        {
+            assert(first_attribute() && where->parent() == this);
+            if (where == m_first_attribute)
+                remove_first_attribute();
+            else if (where == m_last_attribute)
+                remove_last_attribute();
+            else
+            {
+                where->m_prev_attribute->m_next_attribute = where->m_next_attribute;
+                where->m_next_attribute->m_prev_attribute = where->m_prev_attribute;
+                where->m_parent = 0;
+            }
+        }
+
+        //! Removes all attributes of node.
+        void remove_all_attributes()
+        {
+            for (xml_attribute<Ch> *attribute = first_attribute(); attribute; attribute = attribute->m_next_attribute)
+                attribute->m_parent = 0;
+            m_first_attribute = 0;
+        }
+        
+    private:
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Restrictions
+
+        // No copying
+        xml_node(const xml_node &);
+        void operator =(const xml_node &);
+    
+        ///////////////////////////////////////////////////////////////////////////
+        // Data members
+    
+        // Note that some of the pointers below have UNDEFINED values if certain other pointers are 0.
+        // This is required for maximum performance, as it allows the parser to omit initialization of 
+        // unneded/redundant values.
+        //
+        // The rules are as follows:
+        // 1. first_node and first_attribute contain valid pointers, or 0 if node has no children/attributes respectively
+        // 2. last_node and last_attribute are valid only if node has at least one child/attribute respectively, otherwise they contain garbage
+        // 3. prev_sibling and next_sibling are valid only if node has a parent, otherwise they contain garbage
+
+        node_type m_type;                       // Type of node; always valid
+        xml_node<Ch> *m_first_node;             // Pointer to first child node, or 0 if none; always valid
+        xml_node<Ch> *m_last_node;              // Pointer to last child node, or 0 if none; this value is only valid if m_first_node is non-zero
+        xml_attribute<Ch> *m_first_attribute;   // Pointer to first attribute of node, or 0 if none; always valid
+        xml_attribute<Ch> *m_last_attribute;    // Pointer to last attribute of node, or 0 if none; this value is only valid if m_first_attribute is non-zero
+        xml_node<Ch> *m_prev_sibling;           // Pointer to previous sibling of node, or 0 if none; this value is only valid if m_parent is non-zero
+        xml_node<Ch> *m_next_sibling;           // Pointer to next sibling of node, or 0 if none; this value is only valid if m_parent is non-zero
+
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+    // XML document
+    
+    //! This class represents root of the DOM hierarchy. 
+    //! It is also an xml_node and a memory_pool through public inheritance.
+    //! Use parse() function to build a DOM tree from a zero-terminated XML text string.
+    //! parse() function allocates memory for nodes and attributes by using functions of xml_document, 
+    //! which are inherited from memory_pool.
+    //! To access root node of the document, use the document itself, as if it was an xml_node.
+    //! \param Ch Character type to use.
+    template<class Ch = char>
+    class xml_document: public xml_node<Ch>, public memory_pool<Ch>
+    {
+    
+    public:
+
+        //! Constructs empty XML document
+        xml_document()
+            : xml_node<Ch>(node_document)
+        {
+        }
+
+        //! Parses zero-terminated XML string according to given flags.
+        //! Passed string will be modified by the parser, unless rapidxml_ns::parse_non_destructive flag is used.
+        //! The string must persist for the lifetime of the document.
+        //! In case of error, rapidxml_ns::parse_error exception will be thrown.
+        //! <br><br>
+        //! If you want to parse contents of a file, you must first load the file into the memory, and pass pointer to its beginning.
+        //! Make sure that data is zero-terminated.
+        //! <br><br>
+        //! Document can be parsed into multiple times. 
+        //! Each new call to parse removes previous nodes and attributes (if any), but does not clear memory pool.
+        //! \param text XML data to parse; pointer is non-const to denote fact that this data may be modified by the parser.
+        template<int Flags>
+        void parse(Ch *text)
+        {
+            if (Flags & parse_no_namespace)
+                parse_ns<Flags, internal::xml_namespace_processor_stub<Ch> >(text);
+            else
+                parse_ns<Flags, internal::xml_namespace_processor<Ch> >(text);
+        }
+
+        //! Use parse() instead. 
+        //! Parses zero-terminated XML string according to given flags and NamespaceProcessor passed.
+        //! Should be called only when default xml_namespace_processor is substituted with custom one.
+        template<int Flags, class NamespaceProcessor>
+        void parse_ns(Ch *text)
+        {
+            assert(text);
+            
+            // Remove current contents
+            this->remove_all_nodes();
+            this->remove_all_attributes();
+            
+            NamespaceProcessor namespace_processor;
+            // Creating topmost namespace scope that actually won't be used
+            typename NamespaceProcessor::scope const namespace_scope(namespace_processor);
+
+            // Parse BOM, if any
+            parse_bom<Flags>(text);
+            
+            // Parse children
+            while (1)
+            {
+                // Skip whitespace before node
+                skip<whitespace_pred, Flags>(text);
+                if (*text == 0)
+                    break;
+
+                // Parse and append new child
+                if (*text == Ch('<'))
+                {
+                    ++text;     // Skip '<'
+                    if (xml_node<Ch> *node = parse_node<Flags, typename NamespaceProcessor::scope>(text, namespace_scope))
+                        this->append_node(node);
+                }
+                else
+                    RAPIDXML_PARSE_ERROR("expected <", text);
+            }
+
+        }
+
+        //! Clears the document by deleting all nodes and clearing the memory pool.
+        //! All nodes owned by document pool are destroyed.
+        void clear()
+        {
+            this->remove_all_nodes();
+            this->remove_all_attributes();
+            memory_pool<Ch>::clear();
+        }
+        
+    private:
+
+        ///////////////////////////////////////////////////////////////////////
+        // Internal character utility functions
+        
+        // Detect whitespace character
+        struct whitespace_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_whitespace[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect node name character
+        struct node_name_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_node_name[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect node name character without ':' (NCName) - namespace prefix or local name
+        struct node_ncname_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_node_ncname[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect attribute name character
+        struct attribute_name_pred
+        {
+          static unsigned char test(Ch ch)
+          {
+            return internal::lookup_tables<0>::lookup_attribute_name[static_cast<unsigned char>(ch)];
+          }
+        };
+
+        // Detect attribute name character without ':' (NCName) - namespace prefix or local name
+        struct attribute_ncname_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_attribute_ncname[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect text character (PCDATA)
+        struct text_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_text[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect text character (PCDATA) that does not require processing
+        struct text_pure_no_ws_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_text_pure_no_ws[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect text character (PCDATA) that does not require processing
+        struct text_pure_with_ws_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                return internal::lookup_tables<0>::lookup_text_pure_with_ws[static_cast<unsigned char>(ch)];
+            }
+        };
+
+        // Detect attribute value character
+        template<Ch Quote>
+        struct attribute_value_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                if (Quote == Ch('\''))
+                    return internal::lookup_tables<0>::lookup_attribute_data_1[static_cast<unsigned char>(ch)];
+                if (Quote == Ch('\"'))
+                    return internal::lookup_tables<0>::lookup_attribute_data_2[static_cast<unsigned char>(ch)];
+                return 0;       // Should never be executed, to avoid warnings on Comeau
+            }
+        };
+
+        // Detect attribute value character
+        template<Ch Quote>
+        struct attribute_value_pure_pred
+        {
+            static unsigned char test(Ch ch)
+            {
+                if (Quote == Ch('\''))
+                    return internal::lookup_tables<0>::lookup_attribute_data_1_pure[static_cast<unsigned char>(ch)];
+                if (Quote == Ch('\"'))
+                    return internal::lookup_tables<0>::lookup_attribute_data_2_pure[static_cast<unsigned char>(ch)];
+                return 0;       // Should never be executed, to avoid warnings on Comeau
+            }
+        };
+
+        // Insert coded character, using UTF8 or 8-bit ASCII
+        template<int Flags>
+        static void insert_coded_character(Ch *&text, unsigned long code)
+        {
+            if (Flags & parse_no_utf8)
+            {
+                // Insert 8-bit ASCII character
+                // Todo: possibly verify that code is less than 256 and use replacement char otherwise?
+                text[0] = static_cast<unsigned char>(code);
+                text += 1;
+            }
+            else
+            {
+                // Insert UTF8 sequence
+                if (code < 0x80)    // 1 byte sequence
+                {
+	                text[0] = static_cast<unsigned char>(code);
+                    text += 1;
+                }
+                else if (code < 0x800)  // 2 byte sequence
+                {
+	                text[1] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;
+	                text[0] = static_cast<unsigned char>(code | 0xC0);
+                    text += 2;
+                }
+	            else if (code < 0x10000)    // 3 byte sequence
+                {
+	                text[2] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;
+	                text[1] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;
+	                text[0] = static_cast<unsigned char>(code | 0xE0);
+                    text += 3;
+                }
+	            else if (code < 0x110000)   // 4 byte sequence
+                {
+	                text[3] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;
+	                text[2] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;
+	                text[1] = static_cast<unsigned char>((code | 0x80) & 0xBF); code >>= 6;
+	                text[0] = static_cast<unsigned char>(code | 0xF0);
+                    text += 4;
+                }
+                else    // Invalid, only codes up to 0x10FFFF are allowed in Unicode
+                {
+                    RAPIDXML_PARSE_ERROR("invalid numeric character entity", text);
+                }
+            }
+        }
+
+        // Skip characters until predicate evaluates to true
+        template<class StopPred, int Flags>
+        static void skip(Ch *&text)
+        {
+            Ch *tmp = text;
+            while (StopPred::test(*tmp))
+                ++tmp;
+            text = tmp;
+        }
+
+        // Skip characters until predicate evaluates to true while doing the following:
+        // - replacing XML character entity references with proper characters (&apos; &amp; &quot; &lt; &gt; &#...;)
+        // - condensing whitespace sequences to single space character
+        template<class StopPred, class StopPredPure, int Flags>
+        static Ch *skip_and_expand_character_refs(Ch *&text)
+        {
+            // If entity translation, whitespace condense and whitespace trimming is disabled, use plain skip
+            if (Flags & parse_no_entity_translation && 
+                !(Flags & parse_normalize_whitespace) &&
+                !(Flags & parse_trim_whitespace))
+            {
+                skip<StopPred, Flags>(text);
+                return text;
+            }
+            
+            // Use simple skip until first modification is detected
+            skip<StopPredPure, Flags>(text);
+
+            // Use translation skip
+            Ch *src = text;
+            Ch *dest = src;
+            while (StopPred::test(*src))
+            {
+                // If entity translation is enabled    
+                if (!(Flags & parse_no_entity_translation))
+                {
+                    // Test if replacement is needed
+                    if (src[0] == Ch('&'))
+                    {
+                        switch (src[1])
+                        {
+
+                        // &amp; &apos;
+                        case Ch('a'): 
+                            if (src[2] == Ch('m') && src[3] == Ch('p') && src[4] == Ch(';'))
+                            {
+                                *dest = Ch('&');
+                                ++dest;
+                                src += 5;
+                                continue;
+                            }
+                            if (src[2] == Ch('p') && src[3] == Ch('o') && src[4] == Ch('s') && src[5] == Ch(';'))
+                            {
+                                *dest = Ch('\'');
+                                ++dest;
+                                src += 6;
+                                continue;
+                            }
+                            break;
+
+                        // &quot;
+                        case Ch('q'): 
+                            if (src[2] == Ch('u') && src[3] == Ch('o') && src[4] == Ch('t') && src[5] == Ch(';'))
+                            {
+                                *dest = Ch('"');
+                                ++dest;
+                                src += 6;
+                                continue;
+                            }
+                            break;
+
+                        // &gt;
+                        case Ch('g'): 
+                            if (src[2] == Ch('t') && src[3] == Ch(';'))
+                            {
+                                *dest = Ch('>');
+                                ++dest;
+                                src += 4;
+                                continue;
+                            }
+                            break;
+
+                        // &lt;
+                        case Ch('l'): 
+                            if (src[2] == Ch('t') && src[3] == Ch(';'))
+                            {
+                                *dest = Ch('<');
+                                ++dest;
+                                src += 4;
+                                continue;
+                            }
+                            break;
+
+                        // &#...; - assumes ASCII
+                        case Ch('#'): 
+                            if (src[2] == Ch('x'))
+                            {
+                                unsigned long code = 0;
+                                src += 3;   // Skip &#x
+                                while (1)
+                                {
+                                    unsigned char digit = internal::lookup_tables<0>::lookup_digits[static_cast<unsigned char>(*src)];
+                                    if (digit == 0xFF)
+                                        break;
+                                    code = code * 16 + digit;
+                                    ++src;
+                                }
+                                insert_coded_character<Flags>(dest, code);    // Put character in output
+                            }
+                            else
+                            {
+                                unsigned long code = 0;
+                                src += 2;   // Skip &#
+                                while (1)
+                                {
+                                    unsigned char digit = internal::lookup_tables<0>::lookup_digits[static_cast<unsigned char>(*src)];
+                                    if (digit == 0xFF)
+                                        break;
+                                    code = code * 10 + digit;
+                                    ++src;
+                                }
+                                insert_coded_character<Flags>(dest, code);    // Put character in output
+                            }
+                            if (*src == Ch(';'))
+                                ++src;
+                            else
+                                RAPIDXML_PARSE_ERROR("expected ;", src);
+                            continue;
+
+                        // Something else
+                        default:
+                            // Ignore, just copy '&' verbatim
+                            break;
+
+                        }
+                    }
+                }
+                
+                // If whitespace condensing is enabled
+                if (Flags & parse_normalize_whitespace)
+                {
+                    // Test if condensing is needed                 
+                    if (whitespace_pred::test(*src))
+                    {
+                        *dest = Ch(' '); ++dest;    // Put single space in dest
+                        ++src;                      // Skip first whitespace char
+                        // Skip remaining whitespace chars
+                        while (whitespace_pred::test(*src))
+                            ++src;
+                        continue;
+                    }
+                }
+
+                // No replacement, only copy character
+                *dest++ = *src++;
+
+            }
+
+            // Return new end
+            text = src;
+            return dest;
+
+        }
+
+        ///////////////////////////////////////////////////////////////////////
+        // Internal parsing functions
+        
+        // Parse BOM, if any
+        template<int Flags>
+        void parse_bom(Ch *&text)
+        {
+            // UTF-8?
+            if (static_cast<unsigned char>(text[0]) == 0xEF && 
+                static_cast<unsigned char>(text[1]) == 0xBB && 
+                static_cast<unsigned char>(text[2]) == 0xBF)
+            {
+                text += 3;      // Skup utf-8 bom
+            }
+        }
+
+        // Parse XML declaration (<?xml...)
+        template<int Flags>
+        xml_node<Ch> *parse_xml_declaration(Ch *&text)
+        {
+            // If parsing of declaration is disabled
+            if (!(Flags & parse_declaration_node))
+            {
+                // Skip until end of declaration
+                while (text[0] != Ch('?') || text[1] != Ch('>'))
+                {
+                    if (!text[0])
+                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                    ++text;
+                }
+                text += 2;    // Skip '?>'
+                return 0;
+            }
+
+            // Create declaration
+            xml_node<Ch> *declaration = this->allocate_node(node_declaration);
+
+            // Skip whitespace before attributes or ?>
+            skip<whitespace_pred, Flags>(text);
+
+            // Parse declaration attributes
+            parse_node_attributes<Flags>(text, declaration);
+            
+            // Skip ?>
+            if (text[0] != Ch('?') || text[1] != Ch('>'))
+                RAPIDXML_PARSE_ERROR("expected ?>", text);
+            text += 2;
+            
+            return declaration;
+        }
+
+        // Parse XML comment (<!--...)
+        template<int Flags>
+        xml_node<Ch> *parse_comment(Ch *&text)
+        {
+            // If parsing of comments is disabled
+            if (!(Flags & parse_comment_nodes))
+            {
+                // Skip until end of comment
+                while (text[0] != Ch('-') || text[1] != Ch('-') || text[2] != Ch('>'))
+                {
+                    if (!text[0])
+                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                    ++text;
+                }
+                text += 3;     // Skip '-->'
+                return 0;      // Do not produce comment node
+            }
+
+            // Remember value start
+            Ch *value = text;
+
+            // Skip until end of comment
+            while (text[0] != Ch('-') || text[1] != Ch('-') || text[2] != Ch('>'))
+            {
+                if (!text[0])
+                    RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                ++text;
+            }
+
+            // Create comment node
+            xml_node<Ch> *comment = this->allocate_node(node_comment);
+            comment->value(value, text - value);
+            
+            // Place zero terminator after comment value
+            if (!(Flags & parse_no_string_terminators))
+                *text = Ch('\0');
+            
+            text += 3;     // Skip '-->'
+            return comment;
+        }
+
+        // Parse DOCTYPE
+        template<int Flags>
+        xml_node<Ch> *parse_doctype(Ch *&text)
+        {
+            // Remember value start
+            Ch *value = text;
+
+            // Skip to >
+            while (*text != Ch('>'))
+            {
+                // Determine character type
+                switch (*text)
+                {
+                
+                // If '[' encountered, scan for matching ending ']' using naive algorithm with depth
+                // This works for all W3C test files except for 2 most wicked
+                case Ch('['):
+                {
+                    ++text;     // Skip '['
+                    int depth = 1;
+                    while (depth > 0)
+                    {
+                        switch (*text)
+                        {
+                            case Ch('['): ++depth; break;
+                            case Ch(']'): --depth; break;
+                            case 0: RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                        }
+                        ++text;
+                    }
+                    break;
+                }
+                
+                // Error on end of text
+                case Ch('\0'):
+                    RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                
+                // Other character, skip it
+                default:
+                    ++text;
+
+                }
+            }
+            
+            // If DOCTYPE nodes enabled
+            if (Flags & parse_doctype_node)
+            {
+                // Create a new doctype node
+                xml_node<Ch> *doctype = this->allocate_node(node_doctype);
+                doctype->value(value, text - value);
+                
+                // Place zero terminator after value
+                if (!(Flags & parse_no_string_terminators))
+                    *text = Ch('\0');
+
+                text += 1;      // skip '>'
+                return doctype;
+            }
+            else
+            {
+                text += 1;      // skip '>'
+                return 0;
+            }
+
+        }
+
+        // Parse PI
+        template<int Flags>
+        xml_node<Ch> *parse_pi(Ch *&text)
+        {
+            // If creation of PI nodes is enabled
+            if (Flags & parse_pi_nodes)
+            {
+                // Create pi node
+                xml_node<Ch> *pi = this->allocate_node(node_pi);
+
+                // Extract PI target name
+                Ch *name = text;
+                skip<node_name_pred, Flags>(text);
+                if (text == name)
+                    RAPIDXML_PARSE_ERROR("expected PI target", text);
+                pi->name(name, text - name);
+                
+                // Skip whitespace between pi target and pi
+                skip<whitespace_pred, Flags>(text);
+
+                // Remember start of pi
+                Ch *value = text;
+                
+                // Skip to '?>'
+                while (text[0] != Ch('?') || text[1] != Ch('>'))
+                {
+                    if (*text == Ch('\0'))
+                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                    ++text;
+                }
+
+                // Set pi value (verbatim, no entity expansion or whitespace normalization)
+                pi->value(value, text - value);     
+                
+                // Place zero terminator after name and value
+                if (!(Flags & parse_no_string_terminators))
+                {
+                    pi->name()[pi->name_size()] = Ch('\0');
+                    pi->value()[pi->value_size()] = Ch('\0');
+                }
+                
+                text += 2;                          // Skip '?>'
+                return pi;
+            }
+            else
+            {
+                // Skip to '?>'
+                while (text[0] != Ch('?') || text[1] != Ch('>'))
+                {
+                    if (*text == Ch('\0'))
+                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                    ++text;
+                }
+                text += 2;    // Skip '?>'
+                return 0;
+            }
+        }
+
+        // Parse and append data
+        // Return character that ends data.
+        // This is necessary because this character might have been overwritten by a terminating 0
+        template<int Flags>
+        Ch parse_and_append_data(xml_node<Ch> *node, Ch *&text, Ch *contents_start)
+        {
+            // Backup to contents start if whitespace trimming is disabled
+            if (!(Flags & parse_trim_whitespace))
+                text = contents_start;     
+            
+            // Skip until end of data
+            Ch *value = text, *end;
+            if (Flags & parse_normalize_whitespace)
+                end = skip_and_expand_character_refs<text_pred, text_pure_with_ws_pred, Flags>(text);   
+            else
+                end = skip_and_expand_character_refs<text_pred, text_pure_no_ws_pred, Flags>(text);
+
+            // Trim trailing whitespace if flag is set; leading was already trimmed by whitespace skip after >
+            if (Flags & parse_trim_whitespace)
+            {
+                if (Flags & parse_normalize_whitespace)
+                {
+                    // Whitespace is already condensed to single space characters by skipping function, so just trim 1 char off the end
+                    if (*(end - 1) == Ch(' '))
+                        --end;
+                }
+                else
+                {
+                    // Backup until non-whitespace character is found
+                    while (whitespace_pred::test(*(end - 1)))
+                        --end;
+                }
+            }
+            
+            // If characters are still left between end and value (this test is only necessary if normalization is enabled)
+            // Create new data node
+            if (!(Flags & parse_no_data_nodes))
+            {
+                xml_node<Ch> *data = this->allocate_node(node_data);
+                data->value(value, end - value);
+                node->append_node(data);
+            }
+
+            // Add data to parent node if no data exists yet
+            if (!(Flags & parse_no_element_values)) 
+                if (*node->value() == Ch('\0'))
+                    node->value(value, end - value);
+
+            // Place zero terminator after value
+            if (!(Flags & parse_no_string_terminators))
+            {
+                Ch ch = *text;
+                *end = Ch('\0');
+                return ch;      // Return character that ends data; this is required because zero terminator overwritten it
+            }
+
+            // Return character that ends data
+            return *text;
+        }
+
+        // Parse CDATA
+        template<int Flags>
+        xml_node<Ch> *parse_cdata(Ch *&text)
+        {
+            // If CDATA is disabled
+            if (Flags & parse_no_data_nodes)
+            {
+                // Skip until end of cdata
+                while (text[0] != Ch(']') || text[1] != Ch(']') || text[2] != Ch('>'))
+                {
+                    if (!text[0])
+                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                    ++text;
+                }
+                text += 3;      // Skip ]]>
+                return 0;       // Do not produce CDATA node
+            }
+
+            // Skip until end of cdata
+            Ch *value = text;
+            while (text[0] != Ch(']') || text[1] != Ch(']') || text[2] != Ch('>'))
+            {
+                if (!text[0])
+                    RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                ++text;
+            }
+
+            // Create new cdata node
+            xml_node<Ch> *cdata = this->allocate_node(node_cdata);
+            cdata->value(value, text - value);
+
+            // Place zero terminator after value
+            if (!(Flags & parse_no_string_terminators))
+                *text = Ch('\0');
+
+            text += 3;      // Skip ]]>
+            return cdata;
+        }
+        
+        // Parse element node
+        template<int Flags, class NamespaceScope>
+        xml_node<Ch> *parse_element(Ch *&text, NamespaceScope namespace_scope)
+        {
+            // Create element node
+            xml_node<Ch> *element = this->allocate_node(node_element);
+
+            // Extract element name
+            Ch *name = text;
+            if (Flags & parse_no_namespace)
+                skip<node_name_pred, Flags>(text);
+            else
+                skip<node_ncname_pred, Flags>(text);
+            if (text == name)
+                RAPIDXML_PARSE_ERROR("expected element name", text);
+            if ((Flags & parse_no_namespace) == 0 && *text == Ch(':'))
+            {
+                // Namespace prefix found
+                ++text;
+                Ch *local_name = text;
+                skip<node_ncname_pred, Flags>(text);
+                if (*text == Ch(':'))
+                    RAPIDXML_PARSE_ERROR("second colon in element name", text);
+                if (text == local_name)
+                    RAPIDXML_PARSE_ERROR("expected local part of element name", text);
+                element->qname(name, text - name, local_name);
+            }
+            else
+                element->qname(name, text - name);
+            
+            // Skip whitespace between element name and attributes or >
+            skip<whitespace_pred, Flags>(text);
+
+            // Parse attributes, if any
+            parse_node_attributes<Flags>(text, element);
+
+            // Setting attributes and element own namespace_uri, adding declared
+            // namespace prefixes and probably setting default namespace
+            namespace_scope.process_element(element);
+
+            // Determine ending type
+            if (*text == Ch('>'))
+            {
+                ++text;
+                parse_node_contents<Flags, NamespaceScope>(text, element, namespace_scope);
+            }
+            else if (*text == Ch('/'))
+            {
+                ++text;
+                if (*text != Ch('>'))
+                    RAPIDXML_PARSE_ERROR("expected >", text);
+                ++text;
+            }
+            else
+                RAPIDXML_PARSE_ERROR("expected >", text);
+
+            // Place zero terminator after name
+            if (!(Flags & parse_no_string_terminators))
+                element->name()[element->name_size()] = Ch('\0');
+
+            // Return parsed element
+            return element;
+        }
+
+        // Determine node type, and parse it
+        template<int Flags, class NamespaceScope>
+        xml_node<Ch> *parse_node(Ch *&text, NamespaceScope const & namespace_scope)
+        {
+            // Parse proper node type
+            switch (text[0])
+            {
+
+            // <...
+            default: 
+                // Parse and append element node
+                return parse_element<Flags, NamespaceScope>(text, namespace_scope);
+
+            // <?...
+            case Ch('?'): 
+                ++text;     // Skip ?
+                if ((text[0] == Ch('x') || text[0] == Ch('X')) &&
+                    (text[1] == Ch('m') || text[1] == Ch('M')) && 
+                    (text[2] == Ch('l') || text[2] == Ch('L')) &&
+                    whitespace_pred::test(text[3]))
+                {
+                    // '<?xml ' - xml declaration
+                    text += 4;      // Skip 'xml '
+                    return parse_xml_declaration<Flags>(text);
+                }
+                else
+                {
+                    // Parse PI
+                    return parse_pi<Flags>(text);
+                }
+            
+            // <!...
+            case Ch('!'): 
+
+                // Parse proper subset of <! node
+                switch (text[1])    
+                {
+                
+                // <!-
+                case Ch('-'):
+                    if (text[2] == Ch('-'))
+                    {
+                        // '<!--' - xml comment
+                        text += 3;     // Skip '!--'
+                        return parse_comment<Flags>(text);
+                    }
+                    break;
+
+                // <![
+                case Ch('['):
+                    if (text[2] == Ch('C') && text[3] == Ch('D') && text[4] == Ch('A') && 
+                        text[5] == Ch('T') && text[6] == Ch('A') && text[7] == Ch('['))
+                    {
+                        // '<![CDATA[' - cdata
+                        text += 8;     // Skip '![CDATA['
+                        return parse_cdata<Flags>(text);
+                    }
+                    break;
+
+                // <!D
+                case Ch('D'):
+                    if (text[2] == Ch('O') && text[3] == Ch('C') && text[4] == Ch('T') && 
+                        text[5] == Ch('Y') && text[6] == Ch('P') && text[7] == Ch('E') && 
+                        whitespace_pred::test(text[8]))
+                    {
+                        // '<!DOCTYPE ' - doctype
+                        text += 9;      // skip '!DOCTYPE '
+                        return parse_doctype<Flags>(text);
+                    }
+
+                }   // switch
+
+                // Attempt to skip other, unrecognized node types starting with <!
+                ++text;     // Skip !
+                while (*text != Ch('>'))
+                {
+                    if (*text == 0)
+                        RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+                    ++text;
+                }
+                ++text;     // Skip '>'
+                return 0;   // No node recognized
+
+            }
+        }
+
+        // Parse contents of the node - children, data etc.
+        template<int Flags, class NamespaceScope>
+        void parse_node_contents(Ch *&text, xml_node<Ch> *node, NamespaceScope const & namespace_scope)
+        {
+            // For all children and text
+            while (1)
+            {
+                // Skip whitespace between > and node contents
+                Ch *contents_start = text;      // Store start of node contents before whitespace is skipped
+                skip<whitespace_pred, Flags>(text);
+                Ch next_char = *text;
+
+            // After data nodes, instead of continuing the loop, control jumps here.
+            // This is because zero termination inside parse_and_append_data() function
+            // would wreak havoc with the above code.
+            // Also, skipping whitespace after data nodes is unnecessary.
+            after_data_node:    
+                
+                // Determine what comes next: node closing, child node, data node, or 0?
+                switch (next_char)
+                {
+                
+                // Node closing or child node
+                case Ch('<'):
+                    if (text[1] == Ch('/'))
+                    {
+                        // Node closing
+                        text += 2;      // Skip '</'
+                        if (Flags & parse_validate_closing_tags)
+                        {
+                            // Skip and validate closing tag name
+                            Ch *closing_name = text;
+                            skip<node_name_pred, Flags>(text);
+                            if (!internal::compare(node->name(), node->name_size(), closing_name, text - closing_name, true))
+                                RAPIDXML_PARSE_ERROR("invalid closing tag name", text);
+                        }
+                        else
+                        {
+                            // No validation, just skip name
+                            skip<node_name_pred, Flags>(text);
+                        }
+                        // Skip remaining whitespace after node name
+                        skip<whitespace_pred, Flags>(text);
+                        if (*text != Ch('>'))
+                            RAPIDXML_PARSE_ERROR("expected >", text);
+                        ++text;     // Skip '>'
+                        return;     // Node closed, finished parsing contents
+                    }
+                    else
+                    {
+                        // Child node
+                        ++text;     // Skip '<'
+                        if (xml_node<Ch> *child = parse_node<Flags, NamespaceScope>(text, namespace_scope))
+                            node->append_node(child);
+                    }
+                    break;
+
+                // End of data - error
+                case Ch('\0'):
+                    RAPIDXML_PARSE_ERROR("unexpected end of data", text);
+
+                // Data node
+                default:
+                    next_char = parse_and_append_data<Flags>(node, text, contents_start);
+                    goto after_data_node;   // Bypass regular processing after data nodes
+
+                }
+            }
+        }
+        
+        // Parse XML attributes of the node
+        template<int Flags>
+        void parse_node_attributes(Ch *&text, xml_node<Ch> *node)
+        {
+            // For all attributes 
+            while ((Flags & parse_no_namespace) 
+                ? attribute_name_pred::test(*text) 
+                : attribute_ncname_pred::test(*text))
+            {
+                // Extract attribute name
+                Ch *name = text;
+                ++text;     // Skip first character of attribute name
+                if (Flags & parse_no_namespace)
+                    skip<attribute_name_pred, Flags>(text);
+                else
+                    skip<attribute_ncname_pred, Flags>(text);
+                if (text == name)
+                    RAPIDXML_PARSE_ERROR("expected attribute name", name);
+                // Create new attribute
+                xml_attribute<Ch> *attribute = this->allocate_attribute();
+                if ((Flags & parse_no_namespace) == 0 && *text == Ch(':'))
+                {
+                    // Namespace prefix found
+                    ++text;
+                    Ch *local_name = text;
+                    skip<attribute_ncname_pred, Flags>(text);
+                    if (text == local_name)
+                        RAPIDXML_PARSE_ERROR("expected local part of attribute name", local_name);
+                    attribute->qname(name, text - name, local_name);
+                }
+                else
+                    attribute->qname(name, text - name);
+                
+                node->append_attribute(attribute);
+
+                // Skip whitespace after attribute name
+                skip<whitespace_pred, Flags>(text);
+
+                // Skip =
+                if (*text != Ch('='))
+                    RAPIDXML_PARSE_ERROR("expected =", text);
+                ++text;
+
+                // Add terminating zero after name
+                if (!(Flags & parse_no_string_terminators))
+                    attribute->name()[attribute->name_size()] = 0;
+
+                // Skip whitespace after =
+                skip<whitespace_pred, Flags>(text);
+
+                // Skip quote and remember if it was ' or "
+                Ch quote = *text;
+                if (quote != Ch('\'') && quote != Ch('"'))
+                    RAPIDXML_PARSE_ERROR("expected ' or \"", text);
+                ++text;
+
+                // Extract attribute value and expand char refs in it
+                Ch *value = text, *end;
+                const int AttFlags = Flags & ~parse_normalize_whitespace;   // No whitespace normalization in attributes
+                if (quote == Ch('\''))
+                    end = skip_and_expand_character_refs<attribute_value_pred<Ch('\'')>, attribute_value_pure_pred<Ch('\'')>, AttFlags>(text);
+                else
+                    end = skip_and_expand_character_refs<attribute_value_pred<Ch('"')>, attribute_value_pure_pred<Ch('"')>, AttFlags>(text);
+                
+                // Set attribute value
+                attribute->value(value, end - value);
+                
+                // Make sure that end quote is present
+                if (*text != quote)
+                    RAPIDXML_PARSE_ERROR("expected ' or \"", text);
+                ++text;     // Skip quote
+
+                // Add terminating zero after value
+                if (!(Flags & parse_no_string_terminators))
+                    attribute->value()[attribute->value_size()] = 0;
+
+                // Skip whitespace after attribute value
+                skip<whitespace_pred, Flags>(text);
+            }
+        }
+
+    };
+
+    //! \cond internal
+    namespace internal
+    {
+
+        // Whitespace (space \n \r \t)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_whitespace[256] = 
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  0,  // 0
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 1
+             1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 2
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 3
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 4
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 5
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 6
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 7
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 8
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // 9
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // A
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // B
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // C
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // D
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  // E
+             0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0   // F
+        };
+
+        // Node name (anything but space \n \r \t / > ? \0)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_node_name[256] = 
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Node NCName (anything but space \n \r \t / > ? \0 :)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_node_ncname[256] = 
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  0,  0,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Text (i.e. PCDATA) (anything but < \0)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_text[256] = 
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Text (i.e. PCDATA) that does not require processing when ws normalization is disabled 
+        // (anything but < \0 &)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_text_pure_no_ws[256] = 
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Text (i.e. PCDATA) that does not require processing when ws normalizationis is enabled
+        // (anything but < \0 & space \n \r \t)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_text_pure_with_ws[256] = 
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             0,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Attribute name (anything but space \n \r \t / < > = ? ! \0)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_attribute_name[256] = 
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+        // Attribute name (anything but space \n \r \t / < > = ? ! \0 :)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_attribute_ncname[256] = 
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  0,  0,  0,  0,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Attribute data with single quote (anything but ' \0)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_1[256] = 
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Attribute data with single quote that does not require processing (anything but ' \0 &)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_1_pure[256] = 
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Attribute data with double quote (anything but " \0)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_2[256] = 
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Attribute data with double quote that does not require processing (anything but " \0 &)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_attribute_data_2_pure[256] = 
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+             0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 0
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 1
+             1,  1,  0,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 2
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 3
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 4
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 5
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 6
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 7
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 8
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // 9
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // A
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // B
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // C
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // D
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  // E
+             1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   // F
+        };
+
+        // Digits (dec and hex, 255 denotes end of numeric character reference)
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_digits[256] = 
+        {
+          // 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 0
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 1
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 2
+             0,  1,  2,  3,  4,  5,  6,  7,  8,  9,255,255,255,255,255,255,  // 3
+           255, 10, 11, 12, 13, 14, 15,255,255,255,255,255,255,255,255,255,  // 4
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 5
+           255, 10, 11, 12, 13, 14, 15,255,255,255,255,255,255,255,255,255,  // 6
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 7
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 8
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // 9
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // A
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // B
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // C
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // D
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  // E
+           255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255   // F
+        };
+    
+        // Upper case conversion
+        template<int Dummy>
+        const unsigned char lookup_tables<Dummy>::lookup_upcase[256] = 
+        {
+          // 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  A   B   C   D   E   F
+           0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15,   // 0
+           16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,   // 1
+           32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,   // 2
+           48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,   // 3
+           64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,   // 4
+           80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,   // 5
+           96, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,   // 6
+           80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 123,124,125,126,127,  // 7
+           128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,  // 8
+           144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,  // 9
+           160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,  // A
+           176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,  // B
+           192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,  // C
+           208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,  // D
+           224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,  // E
+           240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255   // F
+        };
+    }
+    //! \endcond
+
+}
+
+// Undefine internal macros
+#undef RAPIDXML_PARSE_ERROR
+
+// On MSVC, restore warnings state
+#ifdef _MSC_VER
+    #pragma warning(pop)
+#endif
+
+#endif
Index: cppcoro-src/cppcoro/include/cppcoro/single_consumer_async_auto_reset_event.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/single_consumer_async_auto_reset_event.hpp b/cppcoro-src/cppcoro/include/cppcoro/single_consumer_async_auto_reset_event.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/single_consumer_async_auto_reset_event.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/single_consumer_async_auto_reset_event.hpp	(date 1701843666800)
@@ -5,7 +5,7 @@
 #ifndef CPPCORO_SINGLE_CONSUMER_ASYNC_AUTO_RESET_EVENT_HPP_INCLUDED
 #define CPPCORO_SINGLE_CONSUMER_ASYNC_AUTO_RESET_EVENT_HPP_INCLUDED
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <atomic>
 #include <cstdint>
 #include <cassert>
@@ -26,7 +26,7 @@
 			if (oldValue != nullptr && oldValue != this)
 			{
 				// There was a waiting coroutine that we now need to resume.
-				auto handle = *static_cast<std::experimental::coroutine_handle<>*>(oldValue);
+				auto handle = *static_cast<std::coroutine_handle<>*>(oldValue);
 
 				// We also need to transition the state back to 'not set' before
 				// resuming the coroutine. This operation needs to be 'acquire'
@@ -54,7 +54,7 @@
 
 				bool await_ready() const noexcept { return false; }
 				
-				bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+				bool await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 				{
 					m_awaitingCoroutine = awaitingCoroutine;
 
@@ -82,7 +82,7 @@
 
 			private:
 				const single_consumer_async_auto_reset_event& m_event;
-				std::experimental::coroutine_handle<> m_awaitingCoroutine;
+				std::coroutine_handle<> m_awaitingCoroutine;
 			};
 
 			return awaiter{ *this };
Index: svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns_print.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns_print.hpp b/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns_print.hpp
new file mode 100644
--- /dev/null	(date 1696647929773)
+++ b/svgpp-src/svgpp/include/rapidxml_ns/rapidxml_ns_print.hpp	(date 1696647929773)
@@ -0,0 +1,432 @@
+#ifndef RAPIDXML_NS_PRINT_HPP_INCLUDED
+#define RAPIDXML_NS_PRINT_HPP_INCLUDED
+
+// Copyright (C) 2006, 2009 Marcin Kalicinski
+// Version 1.13
+// Revision $DateTime: 2009/05/13 01:46:17 $
+//! \file rapidxml_ns_print.hpp This file contains rapidxml printer implementation
+
+#include "rapidxml_ns.hpp"
+
+// Only include streams if not disabled
+#ifndef RAPIDXML_NO_STREAMS
+    #include <ostream>
+    #include <iterator>
+#endif
+
+namespace rapidxml_ns
+{
+
+    ///////////////////////////////////////////////////////////////////////
+    // Printing flags
+
+    const int print_no_indenting = 0x1;   //!< Printer flag instructing the printer to suppress indenting of XML. See print() function.
+
+    ///////////////////////////////////////////////////////////////////////
+    // Internal
+
+    //! \cond internal
+    namespace internal
+    {
+        
+        ///////////////////////////////////////////////////////////////////////////
+        // Internal character operations
+    
+        // Copy characters from given range to given output iterator
+        template<class OutIt, class Ch>
+        inline OutIt copy_chars(const Ch *begin, const Ch *end, OutIt out)
+        {
+            while (begin != end)
+                *out++ = *begin++;
+            return out;
+        }
+        
+        // Copy characters from given range to given output iterator and expand
+        // characters into references (&lt; &gt; &apos; &quot; &amp;)
+        template<class OutIt, class Ch>
+        inline OutIt copy_and_expand_chars(const Ch *begin, const Ch *end, Ch noexpand, OutIt out)
+        {
+            while (begin != end)
+            {
+                if (*begin == noexpand)
+                {
+                    *out++ = *begin;    // No expansion, copy character
+                }
+                else
+                {
+                    switch (*begin)
+                    {
+                    case Ch('<'):
+                        *out++ = Ch('&'); *out++ = Ch('l'); *out++ = Ch('t'); *out++ = Ch(';');
+                        break;
+                    case Ch('>'): 
+                        *out++ = Ch('&'); *out++ = Ch('g'); *out++ = Ch('t'); *out++ = Ch(';');
+                        break;
+                    case Ch('\''): 
+                        *out++ = Ch('&'); *out++ = Ch('a'); *out++ = Ch('p'); *out++ = Ch('o'); *out++ = Ch('s'); *out++ = Ch(';');
+                        break;
+                    case Ch('"'): 
+                        *out++ = Ch('&'); *out++ = Ch('q'); *out++ = Ch('u'); *out++ = Ch('o'); *out++ = Ch('t'); *out++ = Ch(';');
+                        break;
+                    case Ch('&'): 
+                        *out++ = Ch('&'); *out++ = Ch('a'); *out++ = Ch('m'); *out++ = Ch('p'); *out++ = Ch(';'); 
+                        break;
+                    default:
+                        *out++ = *begin;    // No expansion, copy character
+                    }
+                }
+                ++begin;    // Step to next character
+            }
+            return out;
+        }
+
+        // Fill given output iterator with repetitions of the same character
+        template<class OutIt, class Ch>
+        inline OutIt fill_chars(OutIt out, int n, Ch ch)
+        {
+            for (int i = 0; i < n; ++i)
+                *out++ = ch;
+            return out;
+        }
+
+        // Find character
+        template<class Ch, Ch ch>
+        inline bool find_char(const Ch *begin, const Ch *end)
+        {
+            while (begin != end)
+                if (*begin++ == ch)
+                    return true;
+            return false;
+        }
+
+        ///////////////////////////////////////////////////////////////////////////
+        // Internal printing operations
+   
+        // Printing function declarations (fix for clang bug in gcc and others: http://sourceforge.net/p/rapidxml/bugs/16/)
+
+        template<class OutIt, class Ch> inline OutIt print_children(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_element_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_data_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_cdata_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_declaration_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_comment_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_doctype_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+        template<class OutIt, class Ch> inline OutIt print_pi_node(OutIt out, const xml_node<Ch> *node, int flags, int indent);
+ 
+        // Print node
+        template<class OutIt, class Ch>
+        inline OutIt print_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            // Print proper node type
+            switch (node->type())
+            {
+
+            // Document
+            case node_document:
+                out = print_children(out, node, flags, indent);
+                break;
+
+            // Element
+            case node_element:
+                out = print_element_node(out, node, flags, indent);
+                break;
+            
+            // Data
+            case node_data:
+                out = print_data_node(out, node, flags, indent);
+                break;
+            
+            // CDATA
+            case node_cdata:
+                out = print_cdata_node(out, node, flags, indent);
+                break;
+
+            // Declaration
+            case node_declaration:
+                out = print_declaration_node(out, node, flags, indent);
+                break;
+
+            // Comment
+            case node_comment:
+                out = print_comment_node(out, node, flags, indent);
+                break;
+            
+            // Doctype
+            case node_doctype:
+                out = print_doctype_node(out, node, flags, indent);
+                break;
+
+            // Pi
+            case node_pi:
+                out = print_pi_node(out, node, flags, indent);
+                break;
+
+                // Unknown
+            default:
+                assert(0);
+                break;
+            }
+            
+            // If indenting not disabled, add line break after node
+            if (!(flags & print_no_indenting))
+                *out = Ch('\n'), ++out;
+
+            // Return modified iterator
+            return out;
+        }
+        
+        // Print children of the node                               
+        template<class OutIt, class Ch>
+        inline OutIt print_children(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            for (xml_node<Ch> *child = node->first_node(); child; child = child->next_sibling())
+                out = print_node(out, child, flags, indent);
+            return out;
+        }
+
+        // Print attributes of the node
+        template<class OutIt, class Ch>
+        inline OutIt print_attributes(OutIt out, const xml_node<Ch> *node, int flags)
+        {
+            for (xml_attribute<Ch> *attribute = node->first_attribute(); attribute; attribute = attribute->next_attribute())
+            {
+                if (attribute->name() && attribute->value())
+                {
+                    // Print attribute name
+                    *out = Ch(' '), ++out;
+                    out = copy_chars(attribute->name(), attribute->name() + attribute->name_size(), out);
+                    *out = Ch('='), ++out;
+                    // Print attribute value using appropriate quote type
+                    if (find_char<Ch, Ch('"')>(attribute->value(), attribute->value() + attribute->value_size()))
+                    {
+                        *out = Ch('\''), ++out;
+                        out = copy_and_expand_chars(attribute->value(), attribute->value() + attribute->value_size(), Ch('"'), out);
+                        *out = Ch('\''), ++out;
+                    }
+                    else
+                    {
+                        *out = Ch('"'), ++out;
+                        out = copy_and_expand_chars(attribute->value(), attribute->value() + attribute->value_size(), Ch('\''), out);
+                        *out = Ch('"'), ++out;
+                    }
+                }
+            }
+            return out;
+        }
+
+        // Print data node
+        template<class OutIt, class Ch>
+        inline OutIt print_data_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            assert(node->type() == node_data);
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            out = copy_and_expand_chars(node->value(), node->value() + node->value_size(), Ch(0), out);
+            return out;
+        }
+
+        // Print data node
+        template<class OutIt, class Ch>
+        inline OutIt print_cdata_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            assert(node->type() == node_cdata);
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            *out = Ch('<'); ++out;
+            *out = Ch('!'); ++out;
+            *out = Ch('['); ++out;
+            *out = Ch('C'); ++out;
+            *out = Ch('D'); ++out;
+            *out = Ch('A'); ++out;
+            *out = Ch('T'); ++out;
+            *out = Ch('A'); ++out;
+            *out = Ch('['); ++out;
+            out = copy_chars(node->value(), node->value() + node->value_size(), out);
+            *out = Ch(']'); ++out;
+            *out = Ch(']'); ++out;
+            *out = Ch('>'); ++out;
+            return out;
+        }
+
+        // Print element node
+        template<class OutIt, class Ch>
+        inline OutIt print_element_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            assert(node->type() == node_element);
+
+            // Print element name and attributes, if any
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            *out = Ch('<'), ++out;
+            out = copy_chars(node->name(), node->name() + node->name_size(), out);
+            out = print_attributes(out, node, flags);
+            
+            // If node is childless
+            if (node->value_size() == 0 && !node->first_node())
+            {
+                // Print childless node tag ending
+                *out = Ch('/'), ++out;
+                *out = Ch('>'), ++out;
+            }
+            else
+            {
+                // Print normal node tag ending
+                *out = Ch('>'), ++out;
+
+                // Test if node contains a single data node only (and no other nodes)
+                xml_node<Ch> *child = node->first_node();
+                if (!child)
+                {
+                    // If node has no children, only print its value without indenting
+                    out = copy_and_expand_chars(node->value(), node->value() + node->value_size(), Ch(0), out);
+                }
+                else if (child->next_sibling() == 0 && child->type() == node_data)
+                {
+                    // If node has a sole data child, only print its value without indenting
+                    out = copy_and_expand_chars(child->value(), child->value() + child->value_size(), Ch(0), out);
+                }
+                else
+                {
+                    // Print all children with full indenting
+                    if (!(flags & print_no_indenting))
+                        *out = Ch('\n'), ++out;
+                    out = print_children(out, node, flags, indent + 1);
+                    if (!(flags & print_no_indenting))
+                        out = fill_chars(out, indent, Ch('\t'));
+                }
+
+                // Print node end
+                *out = Ch('<'), ++out;
+                *out = Ch('/'), ++out;
+                out = copy_chars(node->name(), node->name() + node->name_size(), out);
+                *out = Ch('>'), ++out;
+            }
+            return out;
+        }
+
+        // Print declaration node
+        template<class OutIt, class Ch>
+        inline OutIt print_declaration_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            // Print declaration start
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            *out = Ch('<'), ++out;
+            *out = Ch('?'), ++out;
+            *out = Ch('x'), ++out;
+            *out = Ch('m'), ++out;
+            *out = Ch('l'), ++out;
+
+            // Print attributes
+            out = print_attributes(out, node, flags);
+            
+            // Print declaration end
+            *out = Ch('?'), ++out;
+            *out = Ch('>'), ++out;
+            
+            return out;
+        }
+
+        // Print comment node
+        template<class OutIt, class Ch>
+        inline OutIt print_comment_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            assert(node->type() == node_comment);
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            *out = Ch('<'), ++out;
+            *out = Ch('!'), ++out;
+            *out = Ch('-'), ++out;
+            *out = Ch('-'), ++out;
+            out = copy_chars(node->value(), node->value() + node->value_size(), out);
+            *out = Ch('-'), ++out;
+            *out = Ch('-'), ++out;
+            *out = Ch('>'), ++out;
+            return out;
+        }
+
+        // Print doctype node
+        template<class OutIt, class Ch>
+        inline OutIt print_doctype_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            assert(node->type() == node_doctype);
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            *out = Ch('<'), ++out;
+            *out = Ch('!'), ++out;
+            *out = Ch('D'), ++out;
+            *out = Ch('O'), ++out;
+            *out = Ch('C'), ++out;
+            *out = Ch('T'), ++out;
+            *out = Ch('Y'), ++out;
+            *out = Ch('P'), ++out;
+            *out = Ch('E'), ++out;
+            *out = Ch(' '), ++out;
+            out = copy_chars(node->value(), node->value() + node->value_size(), out);
+            *out = Ch('>'), ++out;
+            return out;
+        }
+
+        // Print pi node
+        template<class OutIt, class Ch>
+        inline OutIt print_pi_node(OutIt out, const xml_node<Ch> *node, int flags, int indent)
+        {
+            assert(node->type() == node_pi);
+            if (!(flags & print_no_indenting))
+                out = fill_chars(out, indent, Ch('\t'));
+            *out = Ch('<'), ++out;
+            *out = Ch('?'), ++out;
+            out = copy_chars(node->name(), node->name() + node->name_size(), out);
+            *out = Ch(' '), ++out;
+            out = copy_chars(node->value(), node->value() + node->value_size(), out);
+            *out = Ch('?'), ++out;
+            *out = Ch('>'), ++out;
+            return out;
+        }
+
+    }
+    //! \endcond
+
+    ///////////////////////////////////////////////////////////////////////////
+    // Printing
+
+    //! Prints XML to given output iterator.
+    //! \param out Output iterator to print to.
+    //! \param node Node to be printed. Pass xml_document to print entire document.
+    //! \param flags Flags controlling how XML is printed.
+    //! \return Output iterator pointing to position immediately after last character of printed text.
+    template<class OutIt, class Ch> 
+    inline OutIt print(OutIt out, const xml_node<Ch> &node, int flags = 0)
+    {
+        return internal::print_node(out, &node, flags, 0);
+    }
+
+#ifndef RAPIDXML_NO_STREAMS
+
+    //! Prints XML to given output stream.
+    //! \param out Output stream to print to.
+    //! \param node Node to be printed. Pass xml_document to print entire document.
+    //! \param flags Flags controlling how XML is printed.
+    //! \return Output stream.
+    template<class Ch> 
+    inline std::basic_ostream<Ch> &print(std::basic_ostream<Ch> &out, const xml_node<Ch> &node, int flags = 0)
+    {
+        print(std::ostream_iterator<Ch>(out), node, flags);
+        return out;
+    }
+
+    //! Prints formatted XML to given output stream. Uses default printing flags. Use print() function to customize printing process.
+    //! \param out Output stream to print to.
+    //! \param node Node to be printed.
+    //! \return Output stream.
+    template<class Ch> 
+    inline std::basic_ostream<Ch> &operator <<(std::basic_ostream<Ch> &out, const xml_node<Ch> &node)
+    {
+        return print(out, node);
+    }
+
+#endif
+
+}
+
+#endif
Index: openbabel-src/openbabel/src/descriptor.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/descriptor.cpp b/openbabel-src/openbabel/src/descriptor.cpp
--- a/openbabel-src/openbabel/src/descriptor.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/descriptor.cpp	(date 1696647929174)
@@ -25,11 +25,6 @@
 using namespace std;
 namespace OpenBabel
 {
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-  // macro to implement static OBPlugin::PluginMapType& Map()
-  PLUGIN_CPP_FILE(OBDescriptor)
-#endif
-
 /**
      Compare() is a virtual function and can be overridden to allow different
      comparison behaviour.
Index: openbabel-src/openbabel/src/builder.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/builder.cpp b/openbabel-src/openbabel/src/builder.cpp
--- a/openbabel-src/openbabel/src/builder.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/builder.cpp	(date 1696647929172)
@@ -97,7 +97,7 @@
 
   void OBBuilder::LoadFragments()  {
     // open data/fragments.txt
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "rigid-fragments-index.txt").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open ring-fragments-index.txt", obError);
       return;
@@ -171,7 +171,7 @@
       return coords;
     }
 
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "rigid-fragments.txt").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open rigid-fragments.txt", obError);
       return coords;
Index: cppcoro-src/cppcoro/include/cppcoro/async_auto_reset_event.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/async_auto_reset_event.hpp b/cppcoro-src/cppcoro/include/cppcoro/async_auto_reset_event.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/async_auto_reset_event.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/async_auto_reset_event.hpp	(date 1701843666791)
@@ -5,7 +5,7 @@
 #ifndef CPPCORO_ASYNC_AUTO_RESET_EVENT_HPP_INCLUDED
 #define CPPCORO_ASYNC_AUTO_RESET_EVENT_HPP_INCLUDED
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <atomic>
 #include <cstdint>
 
@@ -80,7 +80,7 @@
 		async_auto_reset_event_operation(const async_auto_reset_event_operation& other) noexcept;
 
 		bool await_ready() const noexcept { return m_event == nullptr; }
-		bool await_suspend(std::experimental::coroutine_handle<> awaiter) noexcept;
+		bool await_suspend(std::coroutine_handle<> awaiter) noexcept;
 		void await_resume() const noexcept {}
 
 	private:
@@ -89,7 +89,7 @@
 
 		const async_auto_reset_event* m_event;
 		async_auto_reset_event_operation* m_next;
-		std::experimental::coroutine_handle<> m_awaiter;
+		std::coroutine_handle<> m_awaiter;
 		std::atomic<std::uint32_t> m_refCount;
 
 	};
Index: cppcoro-src/cppcoro/include/cppcoro/single_producer_sequencer.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/single_producer_sequencer.hpp b/cppcoro-src/cppcoro/include/cppcoro/single_producer_sequencer.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/single_producer_sequencer.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/single_producer_sequencer.hpp	(date 1701843666801)
@@ -160,7 +160,7 @@
 			return m_consumerWaitOperation.await_ready();
 		}
 
-		auto await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+		auto await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 		{
 			return m_consumerWaitOperation.await_suspend(awaitingCoroutine);
 		}
@@ -199,7 +199,7 @@
 			return m_consumerWaitOperation.await_ready();
 		}
 
-		auto await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+		auto await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 		{
 			return m_consumerWaitOperation.await_suspend(awaitingCoroutine);
 		}
Index: cppcoro-src/cppcoro/include/cppcoro/single_consumer_event.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/single_consumer_event.hpp b/cppcoro-src/cppcoro/include/cppcoro/single_consumer_event.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/single_consumer_event.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/single_consumer_event.hpp	(date 1701843666800)
@@ -6,7 +6,7 @@
 #define CPPCORO_SINGLE_CONSUMER_EVENT_HPP_INCLUDED
 
 #include <atomic>
-#include <experimental/coroutine>
+#include <coroutine>
 
 namespace cppcoro
 {
@@ -84,7 +84,7 @@
 					return m_event.is_set();
 				}
 
-				bool await_suspend(std::experimental::coroutine_handle<> awaiter)
+				bool await_suspend(std::coroutine_handle<> awaiter)
 				{
 					m_event.m_awaiter = awaiter;
 
@@ -120,7 +120,7 @@
 		// by encoding 'not_set' as 0 (nullptr), 'set' as 1 and
 		// 'not_set_consumer_waiting' as a coroutine handle pointer.
 		std::atomic<state> m_state;
-		std::experimental::coroutine_handle<> m_awaiter;
+		std::coroutine_handle<> m_awaiter;
 
 	};
 }
Index: cppcoro-src/cppcoro/include/cppcoro/task.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/task.hpp b/cppcoro-src/cppcoro/include/cppcoro/task.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/task.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/task.hpp	(date 1701843666801)
@@ -18,7 +18,7 @@
 #include <cstdint>
 #include <cassert>
 
-#include <experimental/coroutine>
+#include <coroutine>
 
 namespace cppcoro
 {
@@ -36,8 +36,8 @@
 
 #if CPPCORO_COMPILER_SUPPORTS_SYMMETRIC_TRANSFER
 				template<typename PROMISE>
-				std::experimental::coroutine_handle<> await_suspend(
-					std::experimental::coroutine_handle<PROMISE> coro) noexcept
+				std::coroutine_handle<> await_suspend(
+					std::coroutine_handle<PROMISE> coro) noexcept
 				{
 					return coro.promise().m_continuation;
 				}
@@ -49,7 +49,7 @@
 				// were crashing under x86 optimised builds.
 				template<typename PROMISE>
 				CPPCORO_NOINLINE
-				void await_suspend(std::experimental::coroutine_handle<PROMISE> coroutine)
+				void await_suspend(std::coroutine_handle<PROMISE> coroutine)
 				{
 					task_promise_base& promise = coroutine.promise();
 
@@ -79,7 +79,7 @@
 
 			auto initial_suspend() noexcept
 			{
-				return std::experimental::suspend_always{};
+				return std::suspend_always{};
 			}
 
 			auto final_suspend() noexcept
@@ -88,12 +88,12 @@
 			}
 
 #if CPPCORO_COMPILER_SUPPORTS_SYMMETRIC_TRANSFER
-			void set_continuation(std::experimental::coroutine_handle<> continuation) noexcept
+			void set_continuation(std::coroutine_handle<> continuation) noexcept
 			{
 				m_continuation = continuation;
 			}
 #else
-			bool try_set_continuation(std::experimental::coroutine_handle<> continuation)
+			bool try_set_continuation(std::coroutine_handle<> continuation)
 			{
 				m_continuation = continuation;
 				return !m_state.exchange(true, std::memory_order_acq_rel);
@@ -102,7 +102,7 @@
 
 		private:
 
-			std::experimental::coroutine_handle<> m_continuation;
+			std::coroutine_handle<> m_continuation;
 
 #if !CPPCORO_COMPILER_SUPPORTS_SYMMETRIC_TRANSFER
 			// Initially false. Set to true when either a continuation is registered
@@ -292,9 +292,9 @@
 
 		struct awaitable_base
 		{
-			std::experimental::coroutine_handle<promise_type> m_coroutine;
+			std::coroutine_handle<promise_type> m_coroutine;
 
-			awaitable_base(std::experimental::coroutine_handle<promise_type> coroutine) noexcept
+			awaitable_base(std::coroutine_handle<promise_type> coroutine) noexcept
 				: m_coroutine(coroutine)
 			{}
 
@@ -304,14 +304,14 @@
 			}
 
 #if CPPCORO_COMPILER_SUPPORTS_SYMMETRIC_TRANSFER
-			std::experimental::coroutine_handle<> await_suspend(
-				std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+			std::coroutine_handle<> await_suspend(
+				std::coroutine_handle<> awaitingCoroutine) noexcept
 			{
 				m_coroutine.promise().set_continuation(awaitingCoroutine);
 				return m_coroutine;
 			}
 #else
-			bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+			bool await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 			{
 				// NOTE: We are using the bool-returning version of await_suspend() here
 				// to work around a potential stack-overflow issue if a coroutine
@@ -341,7 +341,7 @@
 			: m_coroutine(nullptr)
 		{}
 
-		explicit task(std::experimental::coroutine_handle<promise_type> coroutine)
+		explicit task(std::coroutine_handle<promise_type> coroutine)
 			: m_coroutine(coroutine)
 		{}
 
@@ -446,7 +446,7 @@
 
 	private:
 
-		std::experimental::coroutine_handle<promise_type> m_coroutine;
+		std::coroutine_handle<promise_type> m_coroutine;
 
 	};
 
@@ -455,18 +455,18 @@
 		template<typename T>
 		task<T> task_promise<T>::get_return_object() noexcept
 		{
-			return task<T>{ std::experimental::coroutine_handle<task_promise>::from_promise(*this) };
+			return task<T>{ std::coroutine_handle<task_promise>::from_promise(*this) };
 		}
 
 		inline task<void> task_promise<void>::get_return_object() noexcept
 		{
-			return task<void>{ std::experimental::coroutine_handle<task_promise>::from_promise(*this) };
+			return task<void>{ std::coroutine_handle<task_promise>::from_promise(*this) };
 		}
 
 		template<typename T>
 		task<T&> task_promise<T&>::get_return_object() noexcept
 		{
-			return task<T&>{ std::experimental::coroutine_handle<task_promise>::from_promise(*this) };
+			return task<T&>{ std::coroutine_handle<task_promise>::from_promise(*this) };
 		}
 	}
 
Index: openbabel-src/openbabel/src/data.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/data.cpp b/openbabel-src/openbabel/src/data.cpp
--- a/openbabel-src/openbabel/src/data.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/data.cpp	(date 1696647929174)
@@ -31,9 +31,6 @@
 #include <openbabel/oberror.h>
 #include <openbabel/elements.h>
 
-// data headers with default parameters
-#include "types.h"
-#include "resdata.h"
 
 
 #if !HAVE_STRNCASECMP
@@ -250,7 +247,7 @@
     _envvar = "BABEL_DATADIR";
     _filename = "types.txt";
     _subdir = "data";
-    _dataptr = TypesData;
+    _dataptr = nullptr;
     _linecount = 0;
     _from = _to = -1;
   }
@@ -434,7 +431,7 @@
     _envvar = "BABEL_DATADIR";
     _filename = "resdata.txt";
     _subdir = "data";
-    _dataptr = ResidueData;
+    _dataptr = nullptr;
   }
 
   bool OBResidueData::AssignBonds(OBMol &mol)
@@ -669,7 +666,7 @@
       return;
     _init = true;
 
-    ifstream ifs;
+    istringstream ifs;
     char charBuffer[BUFF_SIZE];
 
     // Set the locale for number parsing to avoid locale issues: PR#1785463
@@ -716,8 +713,6 @@
     // return the locale to the original one
     obLocale.RestoreLocale();
 
-    if (ifs)
-      ifs.close();
 
     if (GetSize() == 0)
       {
Index: indigo-src/indigo/core/indigo-core/molecule/src/haworth_projection_finder.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/molecule/src/haworth_projection_finder.cpp b/indigo-src/indigo/core/indigo-core/molecule/src/haworth_projection_finder.cpp
--- a/indigo-src/indigo/core/indigo-core/molecule/src/haworth_projection_finder.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/core/indigo-core/molecule/src/haworth_projection_finder.cpp	(date 1701847510205)
@@ -12,6 +12,11 @@
 
 CP_DEF(HaworthProjectionFinder);
 
+template<typename T>
+inline auto indigo_get_sign(T a){
+    return (a > 0 ? 1 : (a < 0 ? -1 : 0));
+}
+
 const float COS10_THRESHOLD = 0.015f;
 
 HaworthProjectionFinder::HaworthProjectionFinder(BaseMolecule& mol)
@@ -147,8 +152,8 @@
 
         float s = _getAngleSin(vi, e1i, e2i);
         if (sign == 0)
-            sign = __sign(s);
-        else if (sign != __sign(s))
+            sign = indigo_get_sign(s);
+        else if (sign != indigo_get_sign(s))
             return false; // Rotation direction is different => non-convex
 
         bool is_corner = _isCornerVertex(vi, e1i, e2i);
@@ -219,8 +224,8 @@
             {
                 // Count only non-horizontal bonds
                 if (sub_sign == 0)
-                    sub_sign = __sign(c2);
-                else if (sub_sign == __sign(c2))
+                    sub_sign = indigo_get_sign(c2);
+                else if (sub_sign == indigo_get_sign(c2))
                     return false; // Substituents are in the same direction
             }
         }
@@ -329,7 +334,7 @@
     float yn = _mol.getAtomXyz(vertices[left_next]).y;
     float yp = _mol.getAtomXyz(vertices[left_prev]).y;
 
-    int parity = __sign(yn - yp);
+    int parity = indigo_get_sign(yn - yp);
 
     for (int j = 0; j < vertices.size(); j++)
     {
@@ -411,7 +416,7 @@
     Vec2f d1(pv1.x - pv.x, pv1.y - pv.y);
     Vec2f d2(pv2.x - pv.x, pv2.y - pv.y);
 
-    return __sign(d1.x * d2.x) == 1;
+    return indigo_get_sign(d1.x * d2.x) == 1;
 }
 
 bool HaworthProjectionFinder::_isHorizontalEdge(int e, float cos_threshold)
Index: cppcoro-src/cppcoro/include/cppcoro/inline_scheduler.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/inline_scheduler.hpp b/cppcoro-src/cppcoro/include/cppcoro/inline_scheduler.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/inline_scheduler.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/inline_scheduler.hpp	(date 1701843666798)
@@ -5,7 +5,7 @@
 #ifndef CPPCORO_INLINE_SCHEDULER_HPP_INCLUDED
 #define CPPCORO_INLINE_SCHEDULER_HPP_INCLUDED
 
-#include <experimental/coroutine>
+#include <coroutine>
 
 namespace cppcoro
 {
@@ -15,7 +15,7 @@
 
 		inline_scheduler() noexcept = default;
 
-		std::experimental::suspend_never schedule() const noexcept
+		std::suspend_never schedule() const noexcept
 		{
 			return {};
 		}
Index: rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.cpp b/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.cpp	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.cpp	(date 1701849796141)
@@ -19,6 +19,14 @@
 namespace RDKit {
 namespace FMCS {
 
+void Seed::resizeMatchResult(const std::size_t& size) {
+  MatchResult.clear();
+  MatchResult.resize(size);
+  for(auto&p : MatchResult) {
+    p = std::make_shared<TargetMatch>();
+  }
+}
+
 unsigned int Seed::addAtom(const Atom *atom) {
   unsigned int i = MoleculeFragment.Atoms.size();
   unsigned int aqi = atom->getIdx();
Index: cppcoro-src/cppcoro/include/cppcoro/file_write_operation.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/file_write_operation.hpp b/cppcoro-src/cppcoro/include/cppcoro/file_write_operation.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/file_write_operation.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/file_write_operation.hpp	(date 1701843666797)
@@ -11,7 +11,7 @@
 
 #include <atomic>
 #include <optional>
-#include <experimental/coroutine>
+#include <coroutine>
 
 #if CPPCORO_OS_WINNT
 # include <cppcoro/detail/win32.hpp>
Index: cppcoro-src/cppcoro/include/cppcoro/write_only_file.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/write_only_file.hpp b/cppcoro-src/cppcoro/include/cppcoro/write_only_file.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/write_only_file.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/write_only_file.hpp	(date 1701843666801)
@@ -10,7 +10,7 @@
 #include <cppcoro/file_buffering_mode.hpp>
 #include <cppcoro/file_open_mode.hpp>
 
-#include <experimental/filesystem>
+#include <filesystem>
 
 namespace cppcoro
 {
@@ -48,7 +48,7 @@
 		[[nodiscard]]
 		static write_only_file open(
 			io_service& ioService,
-			const std::experimental::filesystem::path& path,
+			const std::filesystem::path& path,
 			file_open_mode openMode = file_open_mode::create_or_open,
 			file_share_mode shareMode = file_share_mode::none,
 			file_buffering_mode bufferingMode = file_buffering_mode::default_);
Index: rdkit-src/rdkit/Code/GraphMol/FMCS/MaximumCommonSubgraph.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/FMCS/MaximumCommonSubgraph.cpp b/rdkit-src/rdkit/Code/GraphMol/FMCS/MaximumCommonSubgraph.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/FMCS/MaximumCommonSubgraph.cpp	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/Code/GraphMol/FMCS/MaximumCommonSubgraph.cpp	(date 1701850363967)
@@ -278,7 +278,7 @@
       Seed seed;
       seed.setStoreAllDegenerateMCS(Parameters.StoreAll);
       seed.ExcludedBonds = excludedBonds;
-      seed.MatchResult.resize(Targets.size());
+      seed.resizeMatchResult(Targets.size());
 #ifdef VERBOSE_STATISTICS_ON
       {
         ++VerboseStatistics.Seed;
@@ -344,7 +344,7 @@
       //    continue;
       Seed seed;
       seed.setStoreAllDegenerateMCS(Parameters.StoreAll);
-      seed.MatchResult.resize(Targets.size());
+      seed.resizeMatchResult(Targets.size());
 
 #ifdef VERBOSE_STATISTICS_ON
       {
@@ -1248,7 +1248,7 @@
     { ++VerboseStatistics.MatchCall; }
 #endif
     bool target_matched = false;
-    if (!seed.MatchResult.empty() && !seed.MatchResult.at(itarget).empty()) {
+    if (!seed.MatchResult.empty() && !seed.MatchResult.at(itarget)->empty()) {
       target_matched = matchIncrementalFast(seed, itarget);
     }
     if (!target_matched) {  // slow full match
@@ -1259,11 +1259,11 @@
       // save current match info
       if (target_matched) {
         if (seed.MatchResult.empty()) {
-          seed.MatchResult.resize(Targets.size());
+          seed.resizeMatchResult(Targets.size());
         }
-        seed.MatchResult[itarget].init(seed, match, *QueryMolecule, tag);
+        seed.MatchResult[itarget]->init(seed, match, *QueryMolecule, tag);
       } else if (!seed.MatchResult.empty()) {
-        seed.MatchResult[itarget].clear();  //.Empty = true; // == fast clear();
+        seed.MatchResult[itarget]->clear();  //.Empty = true; // == fast clear();
       }
 #ifdef VERBOSE_STATISTICS_ON
       if (target_matched) {
@@ -1299,7 +1299,7 @@
   { ++VerboseStatistics.FastMatchCall; }
 #endif
   const auto& target = Targets.at(itarget);
-  auto& match = seed.MatchResult.at(itarget);
+  auto& match = *(seed.MatchResult.at(itarget));
   if (match.empty()) {
     return false;
   }
Index: cppcoro-src/cppcoro/include/cppcoro/async_mutex.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/async_mutex.hpp b/cppcoro-src/cppcoro/include/cppcoro/async_mutex.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/async_mutex.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/async_mutex.hpp	(date 1701843666793)
@@ -5,7 +5,7 @@
 #ifndef CPPCORO_ASYNC_MUTEX_HPP_INCLUDED
 #define CPPCORO_ASYNC_MUTEX_HPP_INCLUDED
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <atomic>
 #include <cstdint>
 #include <mutex> // for std::adopt_lock_t
@@ -166,7 +166,7 @@
 		{}
 
 		bool await_ready() const noexcept { return false; }
-		bool await_suspend(std::experimental::coroutine_handle<> awaiter) noexcept;
+		bool await_suspend(std::coroutine_handle<> awaiter) noexcept;
 		void await_resume() const noexcept {}
 
 	protected:
@@ -178,7 +178,7 @@
 	private:
 
 		async_mutex_lock_operation* m_next;
-		std::experimental::coroutine_handle<> m_awaiter;
+		std::coroutine_handle<> m_awaiter;
 
 	};
 
Index: openbabel-src/openbabel/src/typer.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/typer.cpp b/openbabel-src/openbabel/src/typer.cpp
--- a/openbabel-src/openbabel/src/typer.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/typer.cpp	(date 1696647929202)
@@ -27,8 +27,6 @@
 #include <openbabel/typer.h>
 #include <openbabel/elements.h>
 
-// private data headers with default parameters
-#include "atomtyp.h"
 
 #ifdef WIN32
 #pragma warning (disable : 4786)
@@ -64,7 +62,7 @@
     _envvar = "BABEL_DATADIR";
     _filename = "atomtyp.txt";
     _subdir = "data";
-    _dataptr = AtomTypeData;
+    _dataptr = nullptr;
   }
 
   void OBAtomTyper::ParseLine(const char *buffer)
Index: cppcoro-src/cppcoro/include/cppcoro/sequence_barrier.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/sequence_barrier.hpp b/cppcoro-src/cppcoro/include/cppcoro/sequence_barrier.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/sequence_barrier.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/sequence_barrier.hpp	(date 1701843666800)
@@ -15,7 +15,7 @@
 #include <cstdint>
 #include <limits>
 #include <optional>
-#include <experimental/coroutine>
+#include <coroutine>
 
 namespace cppcoro
 {
@@ -161,7 +161,7 @@
 			return !TRAITS::precedes(m_lastKnownPublished, m_targetSequence);
 		}
 
-		bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+		bool await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 		{
 			m_awaitingCoroutine = awaitingCoroutine;
 			m_barrier.add_awaiter(this);
@@ -192,7 +192,7 @@
 		const SEQUENCE m_targetSequence;
 		SEQUENCE m_lastKnownPublished;
 		sequence_barrier_wait_operation_base* m_next;
-		std::experimental::coroutine_handle<> m_awaitingCoroutine;
+		std::coroutine_handle<> m_awaitingCoroutine;
 		std::atomic<bool> m_readyToResume;
 
 	};
Index: rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.h b/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.h
--- a/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.h	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/Code/GraphMol/FMCS/Seed.h	(date 1701849830761)
@@ -91,13 +91,14 @@
   DuplicatedSeedCache::TKey DupCacheKey;
 #endif
   // for each target
-  std::vector<TargetMatch> MatchResult;
-
+  std::vector<std::shared_ptr<TargetMatch>> MatchResult;
  public:
   Seed()
 
   {}
 
+  void resizeMatchResult(const std::size_t& size);
+
   void setMoleculeFragment(const Seed& src) {
     MoleculeFragment = src.MoleculeFragment;
   }
Index: cppcoro-src/cppcoro/include/cppcoro/io_service.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/io_service.hpp b/cppcoro-src/cppcoro/include/cppcoro/io_service.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/io_service.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/io_service.hpp	(date 1701843666798)
@@ -19,7 +19,7 @@
 #include <atomic>
 #include <utility>
 #include <mutex>
-#include <experimental/coroutine>
+#include <coroutine>
 
 namespace cppcoro
 {
@@ -192,7 +192,7 @@
 		{}
 
 		bool await_ready() const noexcept { return false; }
-		void await_suspend(std::experimental::coroutine_handle<> awaiter) noexcept;
+		void await_suspend(std::coroutine_handle<> awaiter) noexcept;
 		void await_resume() const noexcept {}
 
 	private:
@@ -201,7 +201,7 @@
 		friend class io_service::timed_schedule_operation;
 
 		io_service& m_service;
-		std::experimental::coroutine_handle<> m_awaiter;
+		std::coroutine_handle<> m_awaiter;
 		schedule_operation* m_next;
 
 	};
@@ -224,7 +224,7 @@
 		timed_schedule_operation& operator=(const timed_schedule_operation& other) = delete;
 
 		bool await_ready() const noexcept;
-		void await_suspend(std::experimental::coroutine_handle<> awaiter);
+		void await_suspend(std::coroutine_handle<> awaiter);
 		void await_resume();
 
 	private:
Index: cppcoro-src/cppcoro/include/cppcoro/detail/when_all_counter.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_counter.hpp b/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_counter.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_counter.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_counter.hpp	(date 1701843666795)
@@ -5,7 +5,7 @@
 #ifndef CPPCORO_DETAIL_WHEN_ALL_COUNTER_HPP_INCLUDED
 #define CPPCORO_DETAIL_WHEN_ALL_COUNTER_HPP_INCLUDED
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <atomic>
 #include <cstdint>
 
@@ -29,7 +29,7 @@
 				return static_cast<bool>(m_awaitingCoroutine);
 			}
 
-			bool try_await(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+			bool try_await(std::coroutine_handle<> awaitingCoroutine) noexcept
 			{
 				m_awaitingCoroutine = awaitingCoroutine;
 				return m_count.fetch_sub(1, std::memory_order_acq_rel) > 1;
@@ -46,7 +46,7 @@
 		protected:
 
 			std::atomic<std::size_t> m_count;
-			std::experimental::coroutine_handle<> m_awaitingCoroutine;
+			std::coroutine_handle<> m_awaitingCoroutine;
 
 		};
 	}
Index: cppcoro-src/cppcoro/include/cppcoro/detail/when_all_task.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_task.hpp b/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_task.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_task.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_task.hpp	(date 1701843666796)
@@ -10,7 +10,7 @@
 #include <cppcoro/detail/when_all_counter.hpp>
 #include <cppcoro/detail/void_value.hpp>
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <cassert>
 
 namespace cppcoro
@@ -28,7 +28,7 @@
 		{
 		public:
 
-			using coroutine_handle_t = std::experimental::coroutine_handle<when_all_task_promise<RESULT>>;
+			using coroutine_handle_t = std::coroutine_handle<when_all_task_promise<RESULT>>;
 
 			when_all_task_promise() noexcept
 			{}
@@ -38,7 +38,7 @@
 				return coroutine_handle_t::from_promise(*this);
 			}
 
-			std::experimental::suspend_always initial_suspend() noexcept
+			std::suspend_always initial_suspend() noexcept
 			{
 				return{};
 			}
@@ -97,7 +97,7 @@
 					bool await_ready() noexcept {
 						return true;
 					}
-					void await_suspend(std::experimental::coroutine_handle<>) noexcept {}
+					void await_suspend(std::coroutine_handle<>) noexcept {}
 					when_all_task_promise& await_resume() noexcept
 					{
 						return *m_promise;
@@ -155,7 +155,7 @@
 		{
 		public:
 
-			using coroutine_handle_t = std::experimental::coroutine_handle<when_all_task_promise<void>>;
+			using coroutine_handle_t = std::coroutine_handle<when_all_task_promise<void>>;
 
 			when_all_task_promise() noexcept
 			{}
@@ -165,7 +165,7 @@
 				return coroutine_handle_t::from_promise(*this);
 			}
 
-			std::experimental::suspend_always initial_suspend() noexcept
+			std::suspend_always initial_suspend() noexcept
 			{
 				return{};
 			}
Index: ringdecomposerlib-src/ringdecomposerlib/src/RingDecomposerLib/RingDecomposerLib.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ringdecomposerlib-src/ringdecomposerlib/src/RingDecomposerLib/RingDecomposerLib.h b/ringdecomposerlib-src/ringdecomposerlib/src/RingDecomposerLib/RingDecomposerLib.h
--- a/ringdecomposerlib-src/ringdecomposerlib/src/RingDecomposerLib/RingDecomposerLib.h	(revision 7b1629781cfb7fda29716d1af14a6110bb553892)
+++ b/ringdecomposerlib-src/ringdecomposerlib/src/RingDecomposerLib/RingDecomposerLib.h	(date 1696647929752)
@@ -27,13 +27,10 @@
 #ifndef RING_DECOMPOSER_LIB_H
 #define RING_DECOMPOSER_LIB_H
 
-#if (defined( _WIN32 ) && defined( _MSC_VER ) )
-    /* Win32 & MS VC ++ */
-    #define RDL_API __declspec(dllexport)
-#elif __GNUC__ >= 4 || defined(__clang__)
-    #define RDL_API __attribute__((visibility("default")))
-#else
-    #define RDL_API
+#include "ringdecomposerlib_export.h"
+
+#ifndef RDL_API
+#define RDL_API RINGDECOMPOSERLIB_EXPORT
 #endif
 
 #ifdef __cplusplus
Index: cppcoro-src/cppcoro/include/cppcoro/detail/when_all_ready_awaitable.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_ready_awaitable.hpp b/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_ready_awaitable.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_ready_awaitable.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/detail/when_all_ready_awaitable.hpp	(date 1701843666795)
@@ -7,7 +7,7 @@
 
 #include <cppcoro/detail/when_all_counter.hpp>
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <tuple>
 
 namespace cppcoro
@@ -26,7 +26,7 @@
 			explicit constexpr when_all_ready_awaitable(std::tuple<>) noexcept {}
 
 			constexpr bool await_ready() const noexcept { return true; }
-			void await_suspend(std::experimental::coroutine_handle<>) noexcept {}
+			void await_suspend(std::coroutine_handle<>) noexcept {}
 			std::tuple<> await_resume() const noexcept { return {}; }
 
 		};
@@ -66,7 +66,7 @@
 						return m_awaitable.is_ready();
 					}
 
-					bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+					bool await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 					{
 						return m_awaitable.try_await(awaitingCoroutine);
 					}
@@ -98,7 +98,7 @@
 						return m_awaitable.is_ready();
 					}
 
-					bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+					bool await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 					{
 						return m_awaitable.try_await(awaitingCoroutine);
 					}
@@ -124,7 +124,7 @@
 				return m_counter.is_ready();
 			}
 
-			bool try_await(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+			bool try_await(std::coroutine_handle<> awaitingCoroutine) noexcept
 			{
 				start_tasks(std::make_integer_sequence<std::size_t, sizeof...(TASKS)>{});
 				return m_counter.try_await(awaitingCoroutine);
@@ -177,7 +177,7 @@
 						return m_awaitable.is_ready();
 					}
 
-					bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+					bool await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 					{
 						return m_awaitable.try_await(awaitingCoroutine);
 					}
@@ -212,7 +212,7 @@
 						return m_awaitable.is_ready();
 					}
 
-					bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+					bool await_suspend(std::coroutine_handle<> awaitingCoroutine) noexcept
 					{
 						return m_awaitable.try_await(awaitingCoroutine);
 					}
@@ -238,7 +238,7 @@
 				return m_counter.is_ready();
 			}
 
-			bool try_await(std::experimental::coroutine_handle<> awaitingCoroutine) noexcept
+			bool try_await(std::coroutine_handle<> awaitingCoroutine) noexcept
 			{
 				for (auto&& task : m_tasks)
 				{
Index: cppcoro-src/cppcoro/include/cppcoro/detail/sync_wait_task.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/detail/sync_wait_task.hpp b/cppcoro-src/cppcoro/include/cppcoro/detail/sync_wait_task.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/detail/sync_wait_task.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/detail/sync_wait_task.hpp	(date 1701843666794)
@@ -9,7 +9,7 @@
 #include <cppcoro/awaitable_traits.hpp>
 #include <cppcoro/detail/lightweight_manual_reset_event.hpp>
 
-#include <experimental/coroutine>
+#include <coroutine>
 #include <cassert>
 #include <exception>
 #include <utility>
@@ -24,7 +24,7 @@
 		template<typename RESULT>
 		class sync_wait_task_promise final
 		{
-			using coroutine_handle_t = std::experimental::coroutine_handle<sync_wait_task_promise<RESULT>>;
+			using coroutine_handle_t = std::coroutine_handle<sync_wait_task_promise<RESULT>>;
 
 		public:
 
@@ -44,7 +44,7 @@
 				return coroutine_handle_t::from_promise(*this);
 			}
 
-			std::experimental::suspend_always initial_suspend() noexcept
+			std::suspend_always initial_suspend() noexcept
 			{
 				return{};
 			}
@@ -89,7 +89,7 @@
 					bool await_ready() noexcept {
 						return true;
 					}
-					void await_suspend(std::experimental::coroutine_handle<>) noexcept {}
+					void await_suspend(std::coroutine_handle<>) noexcept {}
 					sync_wait_task_promise& await_resume() noexcept
 					{
 						return *m_promise;
@@ -140,7 +140,7 @@
 		template<>
 		class sync_wait_task_promise<void>
 		{
-			using coroutine_handle_t = std::experimental::coroutine_handle<sync_wait_task_promise<void>>;
+			using coroutine_handle_t = std::coroutine_handle<sync_wait_task_promise<void>>;
 
 		public:
 
@@ -158,7 +158,7 @@
 				return coroutine_handle_t::from_promise(*this);
 			}
 
-			std::experimental::suspend_always initial_suspend() noexcept
+			std::suspend_always initial_suspend() noexcept
 			{
 				return{};
 			}
@@ -211,7 +211,7 @@
 
 			using promise_type = sync_wait_task_promise<RESULT>;
 
-			using coroutine_handle_t = std::experimental::coroutine_handle<promise_type>;
+			using coroutine_handle_t = std::coroutine_handle<promise_type>;
 
 			sync_wait_task(coroutine_handle_t coroutine) noexcept
 				: m_coroutine(coroutine)
Index: cppcoro-src/cppcoro/include/cppcoro/detail/is_awaiter.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/detail/is_awaiter.hpp b/cppcoro-src/cppcoro/include/cppcoro/detail/is_awaiter.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/detail/is_awaiter.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/detail/is_awaiter.hpp	(date 1701843666794)
@@ -6,7 +6,7 @@
 #define CPPCORO_DETAIL_IS_AWAITER_HPP_INCLUDED
 
 #include <type_traits>
-#include <experimental/coroutine>
+#include <coroutine>
 
 namespace cppcoro
 {
@@ -18,7 +18,7 @@
 		{};
 
 		template<typename PROMISE>
-		struct is_coroutine_handle<std::experimental::coroutine_handle<PROMISE>>
+		struct is_coroutine_handle<std::coroutine_handle<PROMISE>>
 			: std::true_type
 		{};
 
@@ -42,12 +42,12 @@
 		template<typename T>
 		struct is_awaiter<T, std::void_t<
 			decltype(std::declval<T>().await_ready()),
-			decltype(std::declval<T>().await_suspend(std::declval<std::experimental::coroutine_handle<>>())),
+			decltype(std::declval<T>().await_suspend(std::declval<std::coroutine_handle<>>())),
 			decltype(std::declval<T>().await_resume())>> :
 			std::conjunction<
 				std::is_constructible<bool, decltype(std::declval<T>().await_ready())>,
 				detail::is_valid_await_suspend_return_value<
-					decltype(std::declval<T>().await_suspend(std::declval<std::experimental::coroutine_handle<>>()))>>
+					decltype(std::declval<T>().await_suspend(std::declval<std::coroutine_handle<>>()))>>
 		{};
 	}
 }
Index: cppcoro-src/cppcoro/include/cppcoro/detail/win32_overlapped_operation.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/detail/win32_overlapped_operation.hpp b/cppcoro-src/cppcoro/include/cppcoro/detail/win32_overlapped_operation.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/detail/win32_overlapped_operation.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/detail/win32_overlapped_operation.hpp	(date 1701843666796)
@@ -13,7 +13,7 @@
 
 #include <optional>
 #include <system_error>
-#include <experimental/coroutine>
+#include <coroutine>
 #include <cassert>
 
 namespace cppcoro
@@ -100,7 +100,7 @@
 			bool await_ready() const noexcept { return false; }
 
 			CPPCORO_NOINLINE
-			bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine)
+			bool await_suspend(std::coroutine_handle<> awaitingCoroutine)
 			{
 				static_assert(std::is_base_of_v<win32_overlapped_operation, OPERATION>);
 
@@ -127,7 +127,7 @@
 				operation->m_awaitingCoroutine.resume();
 			}
 
-			std::experimental::coroutine_handle<> m_awaitingCoroutine;
+			std::coroutine_handle<> m_awaitingCoroutine;
 
 		};
 
@@ -186,7 +186,7 @@
 			}
 
 			CPPCORO_NOINLINE
-			bool await_suspend(std::experimental::coroutine_handle<> awaitingCoroutine)
+			bool await_suspend(std::coroutine_handle<> awaitingCoroutine)
 			{
 				static_assert(std::is_base_of_v<win32_overlapped_operation_cancellable, OPERATION>);
 
@@ -367,7 +367,7 @@
 			std::atomic<state> m_state;
 			cppcoro::cancellation_token m_cancellationToken;
 			std::optional<cppcoro::cancellation_registration> m_cancellationCallback;
-			std::experimental::coroutine_handle<> m_awaitingCoroutine;
+			std::coroutine_handle<> m_awaitingCoroutine;
 
 		};
 	}
Index: openbabel-src/openbabel/src/ops/optransform.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/ops/optransform.cpp b/openbabel-src/openbabel/src/ops/optransform.cpp
--- a/openbabel-src/openbabel/src/ops/optransform.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/ops/optransform.cpp	(date 1696647929198)
@@ -40,9 +40,7 @@
 {
   _dataLoaded=true;
   _transforms.clear();
-  ifstream ifs;
-  if(ifs.is_open())
-    ifs.close();
+  istringstream ifs;
   char charBuffer[BUFF_SIZE];
 
   // Set the locale for number parsing to avoid locale issues: PR#1785463
Index: cppcoro-src/cppcoro/include/cppcoro/read_only_file.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/read_only_file.hpp b/cppcoro-src/cppcoro/include/cppcoro/read_only_file.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/read_only_file.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/read_only_file.hpp	(date 1701843666799)
@@ -9,7 +9,7 @@
 #include <cppcoro/file_share_mode.hpp>
 #include <cppcoro/file_buffering_mode.hpp>
 
-#include <experimental/filesystem>
+#include <filesystem>
 
 namespace cppcoro
 {
@@ -43,7 +43,7 @@
 		[[nodiscard]]
 		static read_only_file open(
 			io_service& ioService,
-			const std::experimental::filesystem::path& path,
+			const std::filesystem::path& path,
 			file_share_mode shareMode = file_share_mode::read,
 			file_buffering_mode bufferingMode = file_buffering_mode::default_);
 
Index: cppcoro-src/cppcoro/include/cppcoro/net/socket_accept_operation.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/net/socket_accept_operation.hpp b/cppcoro-src/cppcoro/include/cppcoro/net/socket_accept_operation.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/net/socket_accept_operation.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/net/socket_accept_operation.hpp	(date 1701843666799)
@@ -15,7 +15,7 @@
 
 # include <atomic>
 # include <optional>
-# include <experimental/coroutine>
+# include <coroutine>
 
 namespace cppcoro
 {
Index: openbabel-src/openbabel/src/tokenst.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/tokenst.cpp b/openbabel-src/openbabel/src/tokenst.cpp
--- a/openbabel-src/openbabel/src/tokenst.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/tokenst.cpp	(date 1696647929202)
@@ -24,7 +24,7 @@
 #include <limits>
 #include <cstring>
 #include <openbabel/tokenst.h>
-
+#include "text_assets.hpp"
 using namespace std;
 
 namespace OpenBabel
@@ -180,7 +180,7 @@
      or "BABEL_DATADIR" if @p envvar is not specified, or the compiled-in
      macro BABEL_DATADIR if the environment variable is not set
 
-     \param ifs        Stream to load
+     \param iss        Stream to load
      \param filename   Name of the data file to load
      \param envvar     Name of the environment variable
 
@@ -188,51 +188,16 @@
      unless it is in current directory
 
   **/
-  std::string OpenDatafile(std::ifstream& ifs, const std::string& filename,
+  std::string OpenDatafile(std::istringstream& iss, const std::string& filename,
                            const std::string& envvar)
   {
-    ios_base::openmode imode = ios_base::in;
-    #ifdef ALL_READS_BINARY //Makes unix files compatible with VC++6
-      imode = ios_base::in|ios_base::binary;
-    #endif
-
-    // check the current directory
-    ifs.close();
-    ifs.clear();
-    ifs.open(filename.c_str(),imode);
-    if(ifs)
-      return filename;
-
-    string file;
-    const char* datadir = getenv(envvar.c_str());
-    if(!datadir)
-      datadir = BABEL_DATADIR;
-
-    // check the subdirectory for this version number
-    file = datadir;
-    file += FILE_SEP_CHAR;
-    file += BABEL_VERSION;
-    file += FILE_SEP_CHAR + filename;
-
-    ifs.clear();
-    ifs.open(file.c_str(),imode);
-    if(ifs)
-      return file;
-
-    // couldn't find it with the version built in, so try the parent
-    file = datadir;
-    file += FILE_SEP_CHAR;
-    file += filename;
-
-    ifs.clear();
-    ifs.open(file.c_str(),imode);
-
-    if (ifs)
-      return file;
-
-    ifs.clear();
-    ifs.close();
-    return(""); // error
+    auto it = openbabel::OPENBABEL_ASSET_MAP.find(filename);
+    if(it==openbabel::OPENBABEL_ASSET_MAP.end()) {
+        return "";
+    }
+    iss.clear();
+    iss.str(it->second);
+    return filename;
   }
 
 
Index: cppcoro-src/cppcoro/include/cppcoro/shared_task.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/shared_task.hpp b/cppcoro-src/cppcoro/include/cppcoro/shared_task.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/shared_task.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/shared_task.hpp	(date 1701843666800)
@@ -17,7 +17,7 @@
 #include <utility>
 #include <type_traits>
 
-#include <experimental/coroutine>
+#include <coroutine>
 
 namespace cppcoro
 {
@@ -28,7 +28,7 @@
 	{
 		struct shared_task_waiter
 		{
-			std::experimental::coroutine_handle<> m_continuation;
+			std::coroutine_handle<> m_continuation;
 			shared_task_waiter* m_next;
 		};
 
@@ -41,7 +41,7 @@
 				bool await_ready() const noexcept { return false; }
 
 				template<typename PROMISE>
-				void await_suspend(std::experimental::coroutine_handle<PROMISE> h) noexcept
+				void await_suspend(std::coroutine_handle<PROMISE> h) noexcept
 				{
 					shared_task_promise_base& promise = h.promise();
 
@@ -79,7 +79,7 @@
 				, m_exception(nullptr)
 			{}
 
-			std::experimental::suspend_always initial_suspend() noexcept { return {}; }
+			std::suspend_always initial_suspend() noexcept { return {}; }
 			final_awaiter final_suspend() noexcept { return {}; }
 
 			void unhandled_exception() noexcept
@@ -124,7 +124,7 @@
 			/// waiter->m_coroutine will be resumed when the task completes.
 			/// false if the coroutine was already completed and the awaiting
 			/// coroutine can continue without suspending.
-			bool try_await(shared_task_waiter* waiter, std::experimental::coroutine_handle<> coroutine)
+			bool try_await(shared_task_waiter* waiter, std::coroutine_handle<> coroutine)
 			{
 				void* const valueReadyValue = this;
 				void* const notStartedValue = &this->m_waiters;
@@ -304,10 +304,10 @@
 
 		struct awaitable_base
 		{
-			std::experimental::coroutine_handle<promise_type> m_coroutine;
+			std::coroutine_handle<promise_type> m_coroutine;
 			detail::shared_task_waiter m_waiter;
 
-			awaitable_base(std::experimental::coroutine_handle<promise_type> coroutine) noexcept
+			awaitable_base(std::coroutine_handle<promise_type> coroutine) noexcept
 				: m_coroutine(coroutine)
 			{}
 
@@ -316,7 +316,7 @@
 				return !m_coroutine || m_coroutine.promise().is_ready();
 			}
 
-			bool await_suspend(std::experimental::coroutine_handle<> awaiter) noexcept
+			bool await_suspend(std::coroutine_handle<> awaiter) noexcept
 			{
 				m_waiter.m_continuation = awaiter;
 				return m_coroutine.promise().try_await(&m_waiter, m_coroutine);
@@ -329,7 +329,7 @@
 			: m_coroutine(nullptr)
 		{}
 
-		explicit shared_task(std::experimental::coroutine_handle<promise_type> coroutine)
+		explicit shared_task(std::coroutine_handle<promise_type> coroutine)
 			: m_coroutine(coroutine)
 		{
 			// Don't increment the ref-count here since it has already been
@@ -452,7 +452,7 @@
 			}
 		}
 
-		std::experimental::coroutine_handle<promise_type> m_coroutine;
+		std::coroutine_handle<promise_type> m_coroutine;
 
 	};
 
@@ -480,7 +480,7 @@
 		shared_task<T> shared_task_promise<T>::get_return_object() noexcept
 		{
 			return shared_task<T>{
-				std::experimental::coroutine_handle<shared_task_promise>::from_promise(*this)
+				std::coroutine_handle<shared_task_promise>::from_promise(*this)
 			};
 		}
 
@@ -488,14 +488,14 @@
 		shared_task<T&> shared_task_promise<T&>::get_return_object() noexcept
 		{
 			return shared_task<T&>{
-				std::experimental::coroutine_handle<shared_task_promise>::from_promise(*this)
+				std::coroutine_handle<shared_task_promise>::from_promise(*this)
 			};
 		}
 
 		inline shared_task<void> shared_task_promise<void>::get_return_object() noexcept
 		{
 			return shared_task<void>{
-				std::experimental::coroutine_handle<shared_task_promise>::from_promise(*this)
+				std::coroutine_handle<shared_task_promise>::from_promise(*this)
 			};
 		}
 	}
Index: cppcoro-src/cppcoro/include/cppcoro/fmap.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cppcoro-src/cppcoro/include/cppcoro/fmap.hpp b/cppcoro-src/cppcoro/include/cppcoro/fmap.hpp
--- a/cppcoro-src/cppcoro/include/cppcoro/fmap.hpp	(revision 391215262bd40d68ac6534810164131f5f9eb148)
+++ b/cppcoro-src/cppcoro/include/cppcoro/fmap.hpp	(date 1701843666797)
@@ -40,7 +40,7 @@
 			}
 
 			template<typename PROMISE>
-			decltype(auto) await_suspend(std::experimental::coroutine_handle<PROMISE> coro)
+			decltype(auto) await_suspend(std::coroutine_handle<PROMISE> coro)
 				noexcept(noexcept(static_cast<awaiter_t&&>(m_awaiter).await_suspend(std::move(coro))))
 			{
 				return static_cast<awaiter_t&&>(m_awaiter).await_suspend(std::move(coro));
Index: openbabel-src/openbabel/src/chargemodel.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/chargemodel.cpp b/openbabel-src/openbabel/src/chargemodel.cpp
--- a/openbabel-src/openbabel/src/chargemodel.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/chargemodel.cpp	(date 1696647929172)
@@ -26,11 +26,6 @@
 using namespace std;
 namespace OpenBabel
 {
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-  // macro to implement static OBPlugin::PluginMapType& Map()
-  PLUGIN_CPP_FILE(OBChargeModel)
-#endif
-
   void OBChargeModel::FillChargeVectors(OBMol &mol)
   {
     OBAtom *atom;
Index: openbabel-src/openbabel/src/patty.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/patty.cpp b/openbabel-src/openbabel/src/patty.cpp
--- a/openbabel-src/openbabel/src/patty.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/patty.cpp	(date 1696647929199)
@@ -25,6 +25,7 @@
 
 #include <cstring>
 #include <cstdlib>
+#include <fstream>
 
 // Simple programmable atom typer
 // WPW - 070199
Index: openbabel-src/openbabel/src/forcefield.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/forcefield.cpp b/openbabel-src/openbabel/src/forcefield.cpp
--- a/openbabel-src/openbabel/src/forcefield.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/forcefield.cpp	(date 1696647929177)
@@ -40,11 +40,6 @@
 
 namespace OpenBabel
 {
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-  // macro to implement static OBPlugin::PluginMapType& Map()
-  PLUGIN_CPP_FILE(OBForceField)
-#endif
-
   /** \class OBForceField forcefield.h <openbabel/forcefield.h>
       \brief Base class for molecular mechanics force fields
 
Index: openbabel-src/openbabel/src/fingerprint.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/fingerprint.cpp b/openbabel-src/openbabel/src/fingerprint.cpp
--- a/openbabel-src/openbabel/src/fingerprint.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/fingerprint.cpp	(date 1696647929176)
@@ -30,11 +30,6 @@
 using namespace std;
 namespace OpenBabel
 {
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-  // macro to implement static OBPlugin::PluginMapType& Map()
-  PLUGIN_CPP_FILE(OBFingerprint)
-#endif
-
   const unsigned int OBFingerprint::bitsperint = 8 * sizeof(unsigned int);
 
   void OBFingerprint::SetBit(vector<unsigned int>& vec, const unsigned int n)
Index: openbabel-src/openbabel/src/ops/sort.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/ops/sort.cpp b/openbabel-src/openbabel/src/ops/sort.cpp
--- a/openbabel-src/openbabel/src/ops/sort.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/ops/sort.cpp	(date 1696647929199)
@@ -29,7 +29,7 @@
 {
 
 template<class T>
-struct Order : public std::binary_function<std::pair<OBBase*,T>, std::pair<OBBase*,T>, bool>
+struct Order
 {
   Order(OBDescriptor* pDesc, bool rev) : _pDesc(pDesc), _rev(rev){}
   bool operator()(std::pair<OBBase*,T> p1, std::pair<OBBase*,T> p2) const
Index: rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmarts.cpp.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmarts.cpp.cmake b/rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmarts.cpp.cmake
--- a/rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmarts.cpp.cmake	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmarts.cpp.cmake	(date 1701849536984)
@@ -809,7 +809,7 @@
 #endif
 
 #include <cstdio>
-#ifdef WIN32
+#if defined(WIN32) || defined(__MINGW32__)
 #include <io.h>
 #endif
 
Index: openbabel-src/openbabel/src/depict/depict.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/depict/depict.cpp b/openbabel-src/openbabel/src/depict/depict.cpp
--- a/openbabel-src/openbabel/src/depict/depict.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/depict/depict.cpp	(date 1696647929174)
@@ -1235,7 +1235,7 @@
                       end.x() - offset.x(), end.y() - offset.y());
 
     static const float dashpattern[] = {5., 5.};
-    static const vector<double> pat = vector<double>(dashpattern,dashpattern + sizeof(dashpattern)/sizeof(double));
+    static const vector<double> pat = vector<double>(dashpattern, dashpattern + sizeof(dashpattern)/sizeof(float));
     painter->DrawLine(begin.x() + offset.x(), begin.y() + offset.y(),
                       end.x() + offset.x(), end.y() + offset.y(), pat);
   }
Index: openbabel-src/openbabel/src/math/matrix3x3.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/math/matrix3x3.cpp b/openbabel-src/openbabel/src/math/matrix3x3.cpp
--- a/openbabel-src/openbabel/src/math/matrix3x3.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/math/matrix3x3.cpp	(date 1696647929194)
@@ -545,7 +545,7 @@
     eigenvectors. The eigenvectors are normalized and mutually
     orthogonal.
   */
-  void matrix3x3::jacobi(unsigned int n, double *a, double *d, double *v)
+  void matrix3x3::jacobi(int n, double *a, double *d, double *v)
   {
     double onorm, dnorm;
     double b, dma, q, t, c, s;
@@ -557,9 +557,9 @@
 
     // Set v to the identity matrix, set the vector d to contain the
     // diagonal elements of the matrix a
-    for (j = 0; j < static_cast<int>(n); j++)
+    for (j = 0; j < n; j++)
       {
-        for (i = 0; i < static_cast<int>(n); i++)
+        for (i = 0; i < n; i++)
           v[n*i+j] = 0.0;
         v[n*j+j] = 1.0;
         d[j] = a[n*j+j];
@@ -572,7 +572,7 @@
         // onorm to the maximum norm of the off-diagonal elements
         dnorm = 0.0;
         onorm = 0.0;
-        for (j = 0; j < static_cast<int>(n); j++)
+        for (j = 0; j < n; j++)
           {
             dnorm += (double)fabs(d[j]);
             for (i = 0; i < j; i++)
@@ -582,7 +582,7 @@
         if((onorm/dnorm) <= 1.0e-12)
           goto Exit_now;
 
-        for (j = 1; j < static_cast<int>(n); j++)
+        for (j = 1; j < n; j++)
           {
             for (i = 0; i <= j - 1; i++)
               {
@@ -619,14 +619,14 @@
                         a[n*i+k] = atemp;
                       }
 
-                    for (k = j+1; k < static_cast<int>(n); k++)
+                    for (k = j+1; k < n; k++)
                       {
                         atemp = c * a[n*i+k] - s * a[n*j+k];
                         a[n*j+k] = s * a[n*i+k] + c * a[n*j+k];
                         a[n*i+k] = atemp;
                       }
 
-                    for (k = 0; k < static_cast<int>(n); k++)
+                    for (k = 0; k < n; k++)
                       {
                         vtemp = c * v[n*k+i] - s * v[n*k+j];
                         v[n*k+j] = s * v[n*k+i] + c * v[n*k+j];
@@ -647,11 +647,11 @@
     // smallest eigenvalues come first.
     nrot = l;
 
-    for (j = 0; j < static_cast<int>(n)-1; j++)
+    for (j = 0; j < n-1; j++)
       {
         k = j;
         dtemp = d[k];
-        for (i = j+1; i < static_cast<int>(n); i++)
+        for (i = j+1; i < n; i++)
           if(d[i] < dtemp)
             {
               k = i;
@@ -662,7 +662,7 @@
           {
             d[k] = d[j];
             d[j] = dtemp;
-            for (i = 0; i < static_cast<int>(n); i++)
+            for (i = 0; i < n; i++)
               {
                 dtemp = v[n*i+k];
                 v[n*i+k] = v[n*i+j];
Index: taskflow-src/taskflow/taskflow/taskflow.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/taskflow-src/taskflow/taskflow/taskflow.hpp b/taskflow-src/taskflow/taskflow/taskflow.hpp
--- a/taskflow-src/taskflow/taskflow/taskflow.hpp	(revision 12f8bd4e970ab27fd3dee3bffa24b5b48b54ba39)
+++ b/taskflow-src/taskflow/taskflow/taskflow.hpp	(date 1696647929790)
@@ -3,6 +3,7 @@
 #include "core/executor.hpp"
 #include "core/async.hpp"
 #include "algorithm/critical.hpp"
+#include "algorithm/for_each.hpp"
 
 /**
 @dir taskflow
Index: openbabel-src/openbabel/src/ops/op2d.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/ops/op2d.cpp b/openbabel-src/openbabel/src/ops/op2d.cpp
--- a/openbabel-src/openbabel/src/ops/op2d.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/ops/op2d.cpp	(date 1696647929198)
@@ -25,12 +25,13 @@
 #include <openbabel/babelconfig.h>
 #include <iostream>
 #include<openbabel/op.h>
+#include<openbabel/atom.h>
 #include<openbabel/mol.h>
+#include<openbabel/oberror.h>
 #include <RDKitConv.h>
 #include <GraphMol/Depictor/RDDepictor.h>
 #include <Geometry/point.h>
-#include <GraphMol/conformer.h>
-#include <GraphMol/molops.h>
+#include <GraphMol/MolOps.h>
 
 #ifndef OBERROR
  #define OBERROR
@@ -49,13 +50,13 @@
   }
   virtual bool WorksWith(OBBase* pOb)const{ return dynamic_cast<OBMol*>(pOb)!=NULL; }
 
-  virtual bool Do(OBBase* pOb, OpMap*, const char* OptionText);
+  virtual bool Do(OBBase* pOb, const char*, OpMap*, OBConversion*);
 };
 
 Op2D theOp2D("2D"); //Global instance
 
 /////////////////////////////////////////////////////////////////
-bool Op2D::Do(OBBase* pOb, OpMap*, const char* OptionText)
+bool Op2D::Do(OBBase* pOb, const char*, OpMap*, OBConversion*)
 {
   OBMol* pmol = dynamic_cast<OBMol*>(pOb);
   if(!pmol)
Index: openbabel-src/openbabel/src/ops/unique.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/ops/unique.cpp b/openbabel-src/openbabel/src/ops/unique.cpp
--- a/openbabel-src/openbabel/src/ops/unique.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/ops/unique.cpp	(date 1696647929199)
@@ -39,7 +39,7 @@
   #ifdef _LIBCPP_VERSION
     using std::unordered_map;
   #else
-    using std::tr1::unordered_map;
+    using std::unordered_map;
   #endif
 #endif
 namespace OpenBabel
Index: openbabel-src/openbabel/src/ops/gen3d.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/ops/gen3d.cpp b/openbabel-src/openbabel/src/ops/gen3d.cpp
--- a/openbabel-src/openbabel/src/ops/gen3d.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/ops/gen3d.cpp	(date 1696647929197)
@@ -70,8 +70,10 @@
   bool useDistGeom = false;
 
   // first try converting OptionText to an integer
-  char *endptr;
-  speed = strtol(OptionText, &endptr, 10);
+  char *endptr = nullptr;
+  if (OptionText) {
+    speed = strtol(OptionText, &endptr, 10);
+  }
   if (endptr == OptionText) { // not a number
     speed = 3; // we'll default to balanced
     // but let's also check if it's words like "fast" or "best"
@@ -131,12 +133,12 @@
       return true; // done
 
     // All other speed levels do some FF cleanup
-    // Try MMFF94 first and UFF if that doesn't work
-    OBForceField* pFF = OBForceField::FindForceField("MMFF94");
+    // Try UFF first and MMFF94 if that doesn't work
+    OBForceField* pFF = OBForceField::FindForceField("UFF");
     if (!pFF)
       return true;
     if (!pFF->Setup(molCopy)) {
-      pFF = OBForceField::FindForceField("UFF");
+      pFF = OBForceField::FindForceField("MMFF94");
       if (!pFF || !pFF->Setup(molCopy)) return true; // can't use either MMFF94 or UFF
     }
 
Index: openbabel-src/openbabel/src/ops/loader.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/ops/loader.cpp b/openbabel-src/openbabel/src/ops/loader.cpp
--- a/openbabel-src/openbabel/src/ops/loader.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/ops/loader.cpp	(date 1696647929198)
@@ -35,11 +35,6 @@
   const char* TypeID(){return "loaders";};
 };
 
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-// macro to implement static OBPlugin::PluginMapType& Map()
-PLUGIN_CPP_FILE(OBLoader)
-#endif
-
 //*********************************************************
 ///Class which makes instances of plugin classes from information in text file.
 ///This allows the commandline and GUI interfaces to be extended without recompiling.
@@ -55,7 +50,7 @@
   OBDefine(const char* ID, const char* filename)
     : OBLoader(ID, false), _filename(filename)
   {
-    ifstream ifs;
+    istringstream ifs;
     bool filefound = !OpenDatafile(ifs, filename).empty();
     if(!ifs)
     {
Index: openbabel-src/openbabel/src/charges/eem.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/charges/eem.cpp b/openbabel-src/openbabel/src/charges/eem.cpp
--- a/openbabel-src/openbabel/src/charges/eem.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/charges/eem.cpp	(date 1696647929173)
@@ -92,7 +92,7 @@
 
   void EEMCharges::_loadParameters()
   {
-    std::ifstream ifs;
+    std::istringstream ifs;
     if (!OpenDatafile(ifs, _parameters_file).length()) {
       obErrorLog.ThrowError(__FUNCTION__, std::string("Cannot open file with parameters: ").append(_parameters_file), obError);
       return;
Index: openbabel-src/openbabel/src/charges/qeq.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/charges/qeq.cpp b/openbabel-src/openbabel/src/charges/qeq.cpp
--- a/openbabel-src/openbabel/src/charges/qeq.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/charges/qeq.cpp	(date 1696647929173)
@@ -15,7 +15,7 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 ***********************************************************************/
-
+#include <openbabel/babelconfig.h>
 #ifdef HAVE_EIGEN
 
 #include "qeq.h"
@@ -125,7 +125,7 @@
     char buffer[BUFF_SIZE];
 
     // open data/qeq.txt
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "qeq.txt").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open qeq.txt", obError);
       return;
Index: openbabel-src/openbabel/src/charges/qtpie.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/charges/qtpie.cpp b/openbabel-src/openbabel/src/charges/qtpie.cpp
--- a/openbabel-src/openbabel/src/charges/qtpie.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/charges/qtpie.cpp	(date 1696647929173)
@@ -15,7 +15,7 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 ***********************************************************************/
-
+#include <openbabel/babelconfig.h>
 #ifdef HAVE_EIGEN
 
 #include "qtpie.h"
@@ -117,7 +117,7 @@
     char buffer[BUFF_SIZE];
 
     // open data/qeq.txt
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "qeq.txt").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open qeq.txt", obError);
       return;
Index: openbabel-src/openbabel/src/charges/eqeq.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/charges/eqeq.cpp b/openbabel-src/openbabel/src/charges/eqeq.cpp
--- a/openbabel-src/openbabel/src/charges/eqeq.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/charges/eqeq.cpp	(date 1696647929173)
@@ -15,7 +15,7 @@
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 ***********************************************************************/
-
+#include <openbabel/babelconfig.h>
 #ifdef HAVE_EIGEN3
 
 #include "eqeq.h"
@@ -52,7 +52,7 @@
     char buffer[BUFF_SIZE];
 
     // open data/eqeqIonizations.txt
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "eqeqIonizations.txt").length() == 0)
     {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open eqeqIonizations.txt", obError);
Index: opencv-src/opencv/modules/highgui/src/window_QT.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/highgui/src/window_QT.h b/opencv-src/opencv/modules/highgui/src/window_QT.h
--- a/opencv-src/opencv/modules/highgui/src/window_QT.h	(revision 5199850039ad23f1f0e6cccea5061a9fea5efca6)
+++ b/opencv-src/opencv/modules/highgui/src/window_QT.h	(date 1701848687873)
@@ -68,7 +68,7 @@
 #include <QBoxLayout>
 #include <QSettings>
 #include <qtimer.h>
-#include <QtConcurrentRun>
+#include <QtConcurrent/QtConcurrentRun>
 #include <QWaitCondition>
 #include <QKeyEvent>
 #include <QMetaObject>
@@ -96,17 +96,17 @@
 enum { CV_MODE_NORMAL = 0, CV_MODE_OPENGL = 1 };
 
 //we can change the keyboard shortcuts from here !
-enum {	shortcut_zoom_normal 	= Qt::CTRL + Qt::Key_Z,
-        shortcut_zoom_imgRegion = Qt::CTRL + Qt::Key_X,
-        shortcut_save_img		= Qt::CTRL + Qt::Key_S,
-        shortcut_copy_clipbrd   = Qt::CTRL + Qt::Key_C,
-        shortcut_properties_win	= Qt::CTRL + Qt::Key_P,
-        shortcut_zoom_in 		= Qt::CTRL + Qt::Key_Plus,//QKeySequence(QKeySequence::ZoomIn),
-        shortcut_zoom_out		= Qt::CTRL + Qt::Key_Minus,//QKeySequence(QKeySequence::ZoomOut),
-        shortcut_panning_left 	= Qt::CTRL + Qt::Key_Left,
-        shortcut_panning_right 	= Qt::CTRL + Qt::Key_Right,
-        shortcut_panning_up 	= Qt::CTRL + Qt::Key_Up,
-        shortcut_panning_down 	= Qt::CTRL + Qt::Key_Down
+enum {	shortcut_zoom_normal 	= (int)Qt::CTRL + Qt::Key_Z,
+        shortcut_zoom_imgRegion = (int)Qt::CTRL + Qt::Key_X,
+        shortcut_save_img		= (int)Qt::CTRL + Qt::Key_S,
+        shortcut_copy_clipbrd   = (int)Qt::CTRL + Qt::Key_C,
+        shortcut_properties_win	= (int)Qt::CTRL + Qt::Key_P,
+        shortcut_zoom_in 		= (int)Qt::CTRL + Qt::Key_Plus,//QKeySequence(QKeySequence::ZoomIn),
+        shortcut_zoom_out		= (int)Qt::CTRL + Qt::Key_Minus,//QKeySequence(QKeySequence::ZoomOut),
+        shortcut_panning_left 	= (int)Qt::CTRL + Qt::Key_Left,
+        shortcut_panning_right 	= (int)Qt::CTRL + Qt::Key_Right,
+        shortcut_panning_up 	= (int)Qt::CTRL + Qt::Key_Up,
+        shortcut_panning_down 	= (int)Qt::CTRL + Qt::Key_Down
     };
 //end enum
 
@@ -128,7 +128,7 @@
     bool bTimeOut;
     QTimer* timer;
 
-public slots:
+public Q_SLOTS:
     void createWindow( QString name, int flags = 0 );
     void destroyWindow(QString name);
     void destroyAllWindow();
@@ -204,7 +204,7 @@
     CvButtonCallback callback;
     void* userdata;
 
-private slots:
+private Q_SLOTS:
     void callCallBack(bool);
 };
 
@@ -221,7 +221,7 @@
     CvButtonCallback callback;
     void* userdata;
 
-private slots:
+private Q_SLOTS:
     void callCallBack(bool);
 };
 
@@ -238,7 +238,7 @@
     CvButtonCallback callback;
     void* userdata;
 
-private slots:
+private Q_SLOTS:
     void callCallBack(bool);
 };
 
@@ -252,7 +252,7 @@
 
     QPointer<QSlider> slider;
 
-private slots:
+private Q_SLOTS:
     void createDialog();
     void update(int myvalue);
 
@@ -377,7 +377,7 @@
     void showTools();
     QSize getAvailableSize();
 
-private slots:
+private Q_SLOTS:
     void displayPropertiesWin();
 };
 
@@ -518,7 +518,7 @@
 
     void setSize(QSize size_) CV_OVERRIDE;
 
-public slots:
+public Q_SLOTS:
     //reference:
     //http://www.qtcentre.org/wiki/index.php?title=QGraphicsView:_Smooth_Panning_and_Zooming
     //http://doc.qt.nokia.com/4.6/gestures-imagegestures-imagewidget-cpp.html
@@ -585,7 +585,7 @@
 
     void icvmouseProcessing(QPointF pt, int cv_event, int flags) CV_OVERRIDE;
 
-private slots:
+private Q_SLOTS:
     void stopDisplayInfo();
 };
 
Index: opencv-src/opencv/modules/highgui/src/window_QT.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/highgui/src/window_QT.cpp b/opencv-src/opencv/modules/highgui/src/window_QT.cpp
--- a/opencv-src/opencv/modules/highgui/src/window_QT.cpp	(revision 5199850039ad23f1f0e6cccea5061a9fea5efca6)
+++ b/opencv-src/opencv/modules/highgui/src/window_QT.cpp	(date 1701848687873)
@@ -438,7 +438,7 @@
 
     //This is not a very clean way to do the stuff. Indeed, QAction automatically generate toolTil (QLabel)
     //that can be grabbed here and crash the code at 'w->param_name==name'.
-    foreach (QWidget* widget, QApplication::topLevelWidgets())
+    Q_FOREACH (QWidget* widget, QApplication::topLevelWidgets())
     {
         if (widget->isWindow() && !widget->parentWidget())//is a window without parent
         {
@@ -529,7 +529,7 @@
     //"For any GUI application using Qt, there is precisely one QApplication object"
     if (!QApplication::instance())
     {
-#if QT_VERSION >= QT_VERSION_CHECK(5, 6, 0)
+#if QT_VERSION >= QT_VERSION_CHECK(5, 6, 0) and QT_VERSION <= QT_VERSION_CHECK(6, 0, 0)
         QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling, true);
 #endif
         new QApplication(*c, v);
@@ -1182,7 +1182,7 @@
 void GuiReceiver::enablePropertiesButtonEachWindow()
 {
     //For each window, enable window property button
-    foreach (QWidget* widget, QApplication::topLevelWidgets())
+    Q_FOREACH (QWidget* widget, QApplication::topLevelWidgets())
     {
         if (widget->isWindow() && !widget->parentWidget()) //is a window without parent
         {
@@ -2132,7 +2132,7 @@
     myToolBar = new QToolBar(this);
     myToolBar->setFloatable(false); //is not a window
 
-    foreach (QAction *a, vect_QActions)
+    Q_FOREACH (QAction *a, vect_QActions)
         myToolBar->addAction(a);
 }
 
@@ -2796,7 +2796,7 @@
     {
         QMenu menu(this);
 
-        foreach (QAction *a, centralWidget->vect_QActions)
+        Q_FOREACH (QAction *a, centralWidget->vect_QActions)
             menu.addAction(a);
 
         menu.exec(evnt->globalPos());
Index: openbabel-src/openbabel/src/stereo/perception.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/stereo/perception.cpp b/openbabel-src/openbabel/src/stereo/perception.cpp
--- a/openbabel-src/openbabel/src/stereo/perception.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/stereo/perception.cpp	(date 1696647929201)
@@ -2969,9 +2969,6 @@
   }
 
   void StereoRefToImplicit(OBMol& mol, OBStereo::Ref atomId) {
-    // The following is for use in replace_if(...) below
-    const std::binder1st<std::equal_to<OBStereo::Ref> > equal_to_atomId = std::bind1st (equal_to<OBStereo::Ref>(), atomId);
-
     std::vector<OBGenericData*> vdata = mol.GetAllData(OBGenericDataType::StereoData);
     for (std::vector<OBGenericData*>::iterator data = vdata.begin(); data != vdata.end(); ++data) {
       OBStereo::Type datatype = ((OBStereoBase*)*data)->GetType();
@@ -2987,23 +2984,20 @@
       if (datatype == OBStereo::CisTrans) {
         OBCisTransStereo *ct = dynamic_cast<OBCisTransStereo*>(*data);
         OBCisTransStereo::Config ct_cfg = ct->GetConfig();
-        replace_if(ct_cfg.refs.begin(), ct_cfg.refs.end(), equal_to_atomId, (OBStereo::Ref) OBStereo::ImplicitRef);
+        replace(ct_cfg.refs.begin(), ct_cfg.refs.end(), atomId, (OBStereo::Ref) OBStereo::ImplicitRef);
         ct->SetConfig(ct_cfg);
       }
       else if (datatype == OBStereo::Tetrahedral) {
         OBTetrahedralStereo *ts = dynamic_cast<OBTetrahedralStereo*>(*data);
         OBTetrahedralStereo::Config ts_cfg = ts->GetConfig();
         if (ts_cfg.from == atomId) ts_cfg.from = OBStereo::ImplicitRef;
-        replace_if(ts_cfg.refs.begin(), ts_cfg.refs.end(), equal_to_atomId, (OBStereo::Ref) OBStereo::ImplicitRef);
+        replace(ts_cfg.refs.begin(), ts_cfg.refs.end(), atomId, (OBStereo::Ref) OBStereo::ImplicitRef);
         ts->SetConfig(ts_cfg);
       }
     }
   }
 
   void ImplicitRefToStereo(OBMol& mol, OBStereo::Ref centerId, OBStereo::Ref newId) {
-    // The following is for use in replace_if(...) below
-    const std::binder1st<std::equal_to<OBStereo::Ref> > equal_to_implicitRef = std::bind1st (equal_to<OBStereo::Ref>(), (OBStereo::Ref) OBStereo::ImplicitRef);
-
     std::vector<OBGenericData*> vdata = mol.GetAllData(OBGenericDataType::StereoData);
     for (std::vector<OBGenericData*>::iterator data = vdata.begin(); data != vdata.end(); ++data) {
       OBStereo::Type datatype = ((OBStereoBase*)*data)->GetType();
@@ -3022,9 +3016,9 @@
         if (ct_cfg.begin == centerId || ct_cfg.end == centerId) {
           // Assumption: the first two refs are on the begin atom, the last two on the end atom
           if (ct_cfg.begin == centerId)
-            replace_if(ct_cfg.refs.begin(), ct_cfg.refs.begin()+2, equal_to_implicitRef, (OBStereo::Ref) newId);
+            replace(ct_cfg.refs.begin(), ct_cfg.refs.begin()+2, (OBStereo::Ref) OBStereo::ImplicitRef, (OBStereo::Ref) newId);
           if (ct_cfg.end == centerId)
-            replace_if(ct_cfg.refs.begin()+2, ct_cfg.refs.end(), equal_to_implicitRef, (OBStereo::Ref) newId);
+            replace(ct_cfg.refs.begin()+2, ct_cfg.refs.end(), (OBStereo::Ref) OBStereo::ImplicitRef, (OBStereo::Ref) newId);
           ct->SetConfig(ct_cfg);
         }
       }
@@ -3033,7 +3027,7 @@
         OBTetrahedralStereo::Config ts_cfg = ts->GetConfig();
         if (ts_cfg.center == centerId) {
           if (ts_cfg.from == OBStereo::ImplicitRef) ts_cfg.from = newId;
-          replace_if(ts_cfg.refs.begin(), ts_cfg.refs.end(), equal_to_implicitRef, (OBStereo::Ref) newId);
+          replace(ts_cfg.refs.begin(), ts_cfg.refs.end(), (OBStereo::Ref) OBStereo::ImplicitRef, (OBStereo::Ref) newId);
           ts->SetConfig(ts_cfg);
         }
       }
Index: rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmiles.cpp.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmiles.cpp.cmake b/rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmiles.cpp.cmake
--- a/rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmiles.cpp.cmake	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/Code/GraphMol/SmilesParse/lex.yysmiles.cpp.cmake	(date 1701849536985)
@@ -816,7 +816,7 @@
 #endif
 
 #include <cstdio>
-#ifdef WIN32
+#if defined(WIN32) || defined(__MINGW32__)
 #include <io.h>
 #endif
 
Index: freesasa-src/freesasa/src/xml.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/freesasa-src/freesasa/src/xml.c b/freesasa-src/freesasa/src/xml.c
--- a/freesasa-src/freesasa/src/xml.c	(revision aa3c67d174049c0103d39a2a97b4a3a931d55243)
+++ b/freesasa-src/freesasa/src/xml.c	(date 1701850191677)
@@ -3,6 +3,7 @@
 #endif
 #include <assert.h>
 #include <errno.h>
+#include <libxml/parser.h>
 #include <libxml/tree.h>
 #include <libxml/xmlwriter.h>
 #include <stdlib.h>
Index: openbabel-src/openbabel/src/formats/fchkformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/fchkformat.cpp b/openbabel-src/openbabel/src/formats/fchkformat.cpp
--- a/openbabel-src/openbabel/src/formats/fchkformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/fchkformat.cpp	(date 1696647929183)
@@ -665,16 +665,16 @@
            no atom numbers < 0 or > Natoms */
         if (NBond.end() != find_if(NBond.begin(),
                                    NBond.end(),
-                                   bind2nd(less_equal<int>(), 0)) ||
+                                   bind(less_equal<int>(), std::placeholders::_1, 0)) ||
             NBond.end() != find_if(NBond.begin(),
                                    NBond.end(),
-                                   bind2nd(greater<int>(), MxBond)) ||
+                                   bind(greater<int>(), std::placeholders::_1, MxBond)) ||
             IBond.end() != find_if(IBond.begin(),
                                    IBond.end(),
-                                   bind2nd(less<int>(), 0)) ||
+                                   bind(less<int>(), std::placeholders::_1, 0)) ||
             IBond.end() != find_if(IBond.begin(),
                                    IBond.end(),
-                                   bind2nd(greater<int>(), Natoms)))
+                                   bind(greater<int>(), std::placeholders::_1, Natoms)))
           {
             error_msg << "Invalid connectivity : check the \"NBond\" and/or"
                       << " \"IBond\" section(s).";
Index: openbabel-src/openbabel/src/formats/mdffformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/mdffformat.cpp b/openbabel-src/openbabel/src/formats/mdffformat.cpp
--- a/openbabel-src/openbabel/src/formats/mdffformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/mdffformat.cpp	(date 1696647929186)
@@ -30,9 +30,13 @@
 #include <algorithm>
 
 #ifdef _MSC_VER
+#ifndef INFINITY
 #define INFINITY (DBL_MAX+DBL_MAX)
+#endif
+#ifndef NAN
 #define NAN (INFINITY-INFINITY)
 #endif
+#endif
 
 using namespace std;
 namespace OpenBabel {
@@ -133,7 +137,7 @@
     //    path = buffer;
     string full_path = pConv->GetInFilename();
     size_t found = full_path.rfind("/");
-    string path = (found == string::npos) ? "" : path.substr(0, found);
+    string path = (found == string::npos) ? "" : full_path.substr(0, found);
     string short_fn = full_path.substr(path.length(), string::npos);
 
     // Open files
Index: openbabel-src/openbabel/src/formats/chemdrawcdx.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/chemdrawcdx.cpp b/openbabel-src/openbabel/src/formats/chemdrawcdx.cpp
--- a/openbabel-src/openbabel/src/formats/chemdrawcdx.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/chemdrawcdx.cpp	(date 1696647929181)
@@ -810,7 +810,7 @@
 ///////////////////////////////////////////////////////////////////////
 bool CDXReader::ParseEnums(map<CDXTag, string>& enummap, const string& filename)
 {
-  ifstream ihs;
+  istringstream ihs;
   if(OpenDatafile(ihs, filename).empty())
   {
     obErrorLog.ThrowError(__FUNCTION__, 
Index: openbabel-src/openbabel/src/formats/exampleformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/exampleformat.cpp b/openbabel-src/openbabel/src/formats/exampleformat.cpp
--- a/openbabel-src/openbabel/src/formats/exampleformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/exampleformat.cpp	(date 1696647929182)
@@ -32,6 +32,7 @@
 
 #include <openbabel/babelconfig.h>
 #include <openbabel/obmolecformat.h>
+#include <openbabel/mol.h>
 
 using namespace std;
 namespace OpenBabel
Index: rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTreeUtils.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTreeUtils.cpp b/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTreeUtils.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTreeUtils.cpp	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTreeUtils.cpp	(date 1701849536980)
@@ -16,7 +16,7 @@
 #include "FeatTree.h"
 
 #include <boost/graph/biconnected_components.hpp>
-#include <boost/property_map.hpp>
+#include <boost/property_map/property_map.hpp>
 #include <map>
 #include <set>
 
Index: rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTree.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTree.h b/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTree.h
--- a/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTree.h	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/Code/GraphMol/Basement/FeatTrees/FeatTree.h	(date 1701849536980)
@@ -13,7 +13,7 @@
 #define _RD_FEATTREE_H_
 
 #include <boost/graph/adjacency_list.hpp>
-#include <boost/property_map.hpp>
+#include <boost/property_map/property_map.hpp>
 #include <boost/shared_ptr.hpp>
 #include <set>
 
Index: ncnn-src/ncnn/cmake/ncnn_generate_shader_comp_header.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/cmake/ncnn_generate_shader_comp_header.cmake b/ncnn-src/ncnn/cmake/ncnn_generate_shader_comp_header.cmake
--- a/ncnn-src/ncnn/cmake/ncnn_generate_shader_comp_header.cmake	(revision 3116e028d28e08a48b21d667af8dd051ecf09c4b)
+++ b/ncnn-src/ncnn/cmake/ncnn_generate_shader_comp_header.cmake	(date 1701848218973)
@@ -15,8 +15,8 @@
 get_filename_component(SHADER_SRC_NAME_WE ${SHADER_SRC} NAME_WE)
 
 # text to hex
-file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/${SHADER_SRC_NAME_WE}.text2hex.txt "${comp_data}")
-file(READ ${CMAKE_CURRENT_BINARY_DIR}/${SHADER_SRC_NAME_WE}.text2hex.txt comp_data_hex HEX)
+file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/generated/ncnn/tmp/${SHADER_SRC_NAME_WE}.text2hex.txt "${comp_data}")
+file(READ ${CMAKE_CURRENT_BINARY_DIR}/generated/ncnn/tmp/${SHADER_SRC_NAME_WE}.text2hex.txt comp_data_hex HEX)
 string(REGEX REPLACE "([0-9a-f][0-9a-f])" "0x\\1," comp_data_hex ${comp_data_hex})
 string(FIND "${comp_data_hex}" "," tail_comma REVERSE)
 string(SUBSTRING "${comp_data_hex}" 0 ${tail_comma} comp_data_hex)
Index: ncnn-src/ncnn/cmake/ncnn_add_layer.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/cmake/ncnn_add_layer.cmake b/ncnn-src/ncnn/cmake/ncnn_add_layer.cmake
--- a/ncnn-src/ncnn/cmake/ncnn_add_layer.cmake	(revision 3116e028d28e08a48b21d667af8dd051ecf09c4b)
+++ b/ncnn-src/ncnn/cmake/ncnn_add_layer.cmake	(date 1701848218973)
@@ -1,28 +1,28 @@
-
+set(_CURRENT_DIR ${CMAKE_CURRENT_LIST_DIR})
 macro(ncnn_add_arch_opt_layer class NCNN_TARGET_ARCH_OPT NCNN_TARGET_ARCH_OPT_CFLAGS)
-    set(NCNN_${NCNN_TARGET_ARCH}_HEADER ${CMAKE_CURRENT_SOURCE_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.h)
-    set(NCNN_${NCNN_TARGET_ARCH}_SOURCE ${CMAKE_CURRENT_SOURCE_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.cpp)
+    set(NCNN_${NCNN_TARGET_ARCH}_HEADER ${_CURRENT_DIR}/../src/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.h)
+    set(NCNN_${NCNN_TARGET_ARCH}_SOURCE ${_CURRENT_DIR}/../src/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.cpp)
 
-    if(WITH_LAYER_${name} AND EXISTS ${NCNN_${NCNN_TARGET_ARCH}_HEADER} AND EXISTS ${NCNN_${NCNN_TARGET_ARCH}_SOURCE})
+    if (WITH_LAYER_${name} AND EXISTS ${NCNN_${NCNN_TARGET_ARCH}_HEADER} AND EXISTS ${NCNN_${NCNN_TARGET_ARCH}_SOURCE})
 
-        set(NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER ${CMAKE_CURRENT_BINARY_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.h)
-        set(NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE ${CMAKE_CURRENT_BINARY_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.cpp)
+        set(NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER ${CMAKE_CURRENT_BINARY_DIR}/generated/ncnn/include/ncnn/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.h)
+        set(NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE ${CMAKE_CURRENT_BINARY_DIR}/generated/ncnn/src/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.cpp)
 
         add_custom_command(
-            OUTPUT ${NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER}
-            COMMAND ${CMAKE_COMMAND} -DSRC=${NCNN_${NCNN_TARGET_ARCH}_HEADER} -DDST=${NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER} -DCLASS=${class} -P "${CMAKE_CURRENT_SOURCE_DIR}/../cmake/ncnn_generate_${NCNN_TARGET_ARCH_OPT}_source.cmake"
-            DEPENDS ${NCNN_${NCNN_TARGET_ARCH}_HEADER}
-            COMMENT "Generating source ${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.h"
-            VERBATIM
+                OUTPUT ${NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER}
+                COMMAND ${CMAKE_COMMAND} -DSRC=${NCNN_${NCNN_TARGET_ARCH}_HEADER} -DDST=${NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER} -DCLASS=${class} -P "${_CURRENT_DIR}/ncnn_generate_${NCNN_TARGET_ARCH_OPT}_source.cmake"
+                DEPENDS ${NCNN_${NCNN_TARGET_ARCH}_HEADER}
+                COMMENT "Generating source ${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.h"
+                VERBATIM
         )
         set_source_files_properties(${NCNN_${NCNN_TARGET_ARCH_OPT}_HEADER} PROPERTIES GENERATED TRUE)
 
         add_custom_command(
-            OUTPUT ${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE}
-            COMMAND ${CMAKE_COMMAND} -DSRC=${NCNN_${NCNN_TARGET_ARCH}_SOURCE} -DDST=${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE} -DCLASS=${class} -P "${CMAKE_CURRENT_SOURCE_DIR}/../cmake/ncnn_generate_${NCNN_TARGET_ARCH_OPT}_source.cmake"
-            DEPENDS ${NCNN_${NCNN_TARGET_ARCH}_SOURCE}
-            COMMENT "Generating source ${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.cpp"
-            VERBATIM
+                OUTPUT ${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE}
+                COMMAND ${CMAKE_COMMAND} -DSRC=${NCNN_${NCNN_TARGET_ARCH}_SOURCE} -DDST=${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE} -DCLASS=${class} -P "${_CURRENT_DIR}/ncnn_generate_${NCNN_TARGET_ARCH_OPT}_source.cmake"
+                DEPENDS ${NCNN_${NCNN_TARGET_ARCH}_SOURCE}
+                COMMENT "Generating source ${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.cpp"
+                VERBATIM
         )
         set_source_files_properties(${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE} PROPERTIES GENERATED TRUE)
 
@@ -67,7 +67,7 @@
 endmacro()
 
 macro(ncnn_add_arch_opt_source class NCNN_TARGET_ARCH_OPT NCNN_TARGET_ARCH_OPT_CFLAGS)
-    set(NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE ${CMAKE_CURRENT_SOURCE_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.cpp)
+    set(NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE ${_CURRENT_DIR}/../src/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}_${NCNN_TARGET_ARCH_OPT}.cpp)
 
     if(WITH_LAYER_${name} AND EXISTS ${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE})
         set_source_files_properties(${NCNN_${NCNN_TARGET_ARCH_OPT}_SOURCE} PROPERTIES COMPILE_FLAGS ${NCNN_TARGET_ARCH_OPT_CFLAGS})
@@ -80,9 +80,9 @@
 
     # WITH_LAYER_xxx option
     if(${ARGC} EQUAL 2)
-        option(WITH_LAYER_${name} "build with layer ${name}" ${ARGV1})
+        set(WITH_LAYER_${name} ${ARGV1})
     else()
-        option(WITH_LAYER_${name} "build with layer ${name}" ON)
+        set(WITH_LAYER_${name} ON)
     endif()
 
     if(NCNN_CMAKE_VERBOSE)
@@ -90,17 +90,17 @@
     endif()
 
     if(WITH_LAYER_${name})
-        list(APPEND ncnn_SRCS ${CMAKE_CURRENT_SOURCE_DIR}/layer/${name}.cpp)
+        list(APPEND ncnn_SRCS ${_CURRENT_DIR}/../src/layer/${name}.cpp)
 
         # look for arch specific implementation and append source
         # optimized implementation for armv7, aarch64 or x86
-        set(LAYER_ARCH_SRC ${CMAKE_CURRENT_SOURCE_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.cpp)
+        set(LAYER_ARCH_SRC ${_CURRENT_DIR}/../src/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.cpp)
         if(EXISTS ${LAYER_ARCH_SRC})
             set(WITH_LAYER_${name}_${NCNN_TARGET_ARCH} 1)
             list(APPEND ncnn_SRCS ${LAYER_ARCH_SRC})
         endif()
 
-        set(LAYER_VULKAN_SRC ${CMAKE_CURRENT_SOURCE_DIR}/layer/vulkan/${name}_vulkan.cpp)
+        set(LAYER_VULKAN_SRC ${_CURRENT_DIR}/../src/layer/vulkan/${name}_vulkan.cpp)
         if(NCNN_VULKAN AND EXISTS ${LAYER_VULKAN_SRC})
             set(WITH_LAYER_${name}_vulkan 1)
             list(APPEND ncnn_SRCS ${LAYER_VULKAN_SRC})
@@ -114,7 +114,7 @@
         set(create_pipeline_content "        { int ret = ${class}::create_pipeline(opt); if (ret) return ret; }\n")
         set(destroy_pipeline_content "        { int ret = ${class}::destroy_pipeline(opt); if (ret) return ret; }\n")
 
-        source_group ("sources\\\\layers" FILES "${CMAKE_CURRENT_SOURCE_DIR}/layer/${name}.cpp")
+        source_group("sources\\\\layers" FILES "${_CURRENT_DIR}/../src/layer/${name}.cpp")
     endif()
 
     if(WITH_LAYER_${name}_vulkan)
@@ -123,14 +123,14 @@
         set(create_pipeline_content "${create_pipeline_content}        if (vkdev) { int ret = ${class}_vulkan::create_pipeline(opt); if (ret) return ret; }\n")
         set(destroy_pipeline_content "        if (vkdev) { int ret = ${class}_vulkan::destroy_pipeline(opt); if (ret) return ret; }\n${destroy_pipeline_content}")
 
-        file(GLOB_RECURSE NCNN_SHADER_SRCS "layer/vulkan/shader/${name}.comp")
-        file(GLOB_RECURSE NCNN_SHADER_SUBSRCS "layer/vulkan/shader/${name}_*.comp")
+        file(GLOB_RECURSE NCNN_SHADER_SRCS "${_CURRENT_DIR}/../src/layer/vulkan/shader/${name}.comp")
+        file(GLOB_RECURSE NCNN_SHADER_SUBSRCS "${_CURRENT_DIR}/../src/layer/vulkan/shader/${name}_*.comp")
         list(APPEND NCNN_SHADER_SRCS ${NCNN_SHADER_SUBSRCS})
-        foreach(NCNN_SHADER_SRC ${NCNN_SHADER_SRCS})
+        foreach (NCNN_SHADER_SRC ${NCNN_SHADER_SRCS})
             ncnn_add_shader(${NCNN_SHADER_SRC})
-        endforeach()
+        endforeach ()
 
-        source_group ("sources\\\\layers\\\\vulkan" FILES "${CMAKE_CURRENT_SOURCE_DIR}/layer/vulkan/${name}_vulkan.cpp")
+        source_group("sources\\\\layers\\\\vulkan" FILES "${_CURRENT_DIR}/../src/layer/vulkan/${name}_vulkan.cpp")
     endif()
 
     if(WITH_LAYER_${name}_${NCNN_TARGET_ARCH})
@@ -139,7 +139,7 @@
         set(create_pipeline_content "${create_pipeline_content}        { int ret = ${class}_${NCNN_TARGET_ARCH}::create_pipeline(opt); if (ret) return ret; }\n")
         set(destroy_pipeline_content "        { int ret = ${class}_${NCNN_TARGET_ARCH}::destroy_pipeline(opt); if (ret) return ret; }\n${destroy_pipeline_content}")
 
-        source_group ("sources\\\\layers\\\\${NCNN_TARGET_ARCH}" FILES "${CMAKE_CURRENT_SOURCE_DIR}/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.cpp")
+        source_group("sources\\\\layers\\\\${NCNN_TARGET_ARCH}" FILES "${_CURRENT_DIR}/../src/layer/${NCNN_TARGET_ARCH}/${name}_${NCNN_TARGET_ARCH}.cpp")
     endif()
 
     if(WITH_LAYER_${name})
Index: openbabel-src/openbabel/src/formats/povrayformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/povrayformat.cpp b/openbabel-src/openbabel/src/formats/povrayformat.cpp
--- a/openbabel-src/openbabel/src/formats/povrayformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/povrayformat.cpp	(date 1696647929188)
@@ -523,7 +523,7 @@
 
         /* ---- Add a pigment - statement for start-atom of bond ---- */
         bond_type = bond->GetBeginAtom() -> GetType();
-        bond_type.erase(remove_if(bond_type.begin(), bond_type.end(), bind1st(equal_to<char>(), '.')), bond_type.end());
+        bond_type.erase(remove(bond_type.begin(), bond_type.end(), '.'), bond_type.end());
         ofs << "\t    pigment{color Color_"
             << bond_type
             << "}" << endl;
@@ -584,7 +584,7 @@
 
         /* ---- Add a pigment - statement for end-atom of bond i ---- */
         bond_type = bond->GetEndAtom() -> GetType();
-        bond_type.erase(remove_if(bond_type.begin(), bond_type.end(), bind1st(equal_to<char>(), '.')), bond_type.end());
+        bond_type.erase(remove(bond_type.begin(), bond_type.end(), '.'), bond_type.end());
 
         ofs << "\t    pigment{color Color_"
             << bond_type
Index: ncnn-src/ncnn/cmake/ncnn_add_shader.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/cmake/ncnn_add_shader.cmake b/ncnn-src/ncnn/cmake/ncnn_add_shader.cmake
--- a/ncnn-src/ncnn/cmake/ncnn_add_shader.cmake	(revision 3116e028d28e08a48b21d667af8dd051ecf09c4b)
+++ b/ncnn-src/ncnn/cmake/ncnn_add_shader.cmake	(date 1701848218973)
@@ -1,14 +1,14 @@
-
+set(_CURRENT_DIR ${CMAKE_CURRENT_LIST_DIR})
 macro(ncnn_add_shader NCNN_SHADER_SRC)
     get_filename_component(NCNN_SHADER_SRC_NAME_WE ${NCNN_SHADER_SRC} NAME_WE)
-    set(NCNN_SHADER_COMP_HEADER ${CMAKE_CURRENT_BINARY_DIR}/${NCNN_SHADER_SRC_NAME_WE}.comp.hex.h)
+    set(NCNN_SHADER_COMP_HEADER ${CMAKE_CURRENT_BINARY_DIR}/generated/ncnn/include/ncnn/layer/vulkan/shader/${NCNN_SHADER_SRC_NAME_WE}.comp.hex.h)
 
     add_custom_command(
-        OUTPUT ${NCNN_SHADER_COMP_HEADER}
-        COMMAND ${CMAKE_COMMAND} -DSHADER_SRC=${NCNN_SHADER_SRC} -DSHADER_COMP_HEADER=${NCNN_SHADER_COMP_HEADER} -P "${CMAKE_CURRENT_SOURCE_DIR}/../cmake/ncnn_generate_shader_comp_header.cmake"
-        DEPENDS ${NCNN_SHADER_SRC}
-        COMMENT "Preprocessing shader source ${NCNN_SHADER_SRC_NAME_WE}.comp"
-        VERBATIM
+            OUTPUT ${NCNN_SHADER_COMP_HEADER}
+            COMMAND ${CMAKE_COMMAND} -DSHADER_SRC=${NCNN_SHADER_SRC} -DSHADER_COMP_HEADER=${NCNN_SHADER_COMP_HEADER} -P "${_CURRENT_DIR}/ncnn_generate_shader_comp_header.cmake"
+            DEPENDS ${NCNN_SHADER_SRC}
+            COMMENT "Preprocessing shader source ${NCNN_SHADER_SRC_NAME_WE}.comp"
+            VERBATIM
     )
     set_source_files_properties(${NCNN_SHADER_COMP_HEADER} PROPERTIES GENERATED TRUE)
 
Index: rdkit-src/rdkit/Code/GraphMol/MolAlign/O3AAlignMolecules.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/MolAlign/O3AAlignMolecules.h b/rdkit-src/rdkit/Code/GraphMol/MolAlign/O3AAlignMolecules.h
--- a/rdkit-src/rdkit/Code/GraphMol/MolAlign/O3AAlignMolecules.h	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/Code/GraphMol/MolAlign/O3AAlignMolecules.h	(date 1701849536982)
@@ -27,7 +27,7 @@
 
 namespace RDKit {
 namespace MolAlign {
-struct RDKIT_MOLALIGN_EXPORT O3AFuncData {
+struct RDKIT_O3AALIGN_EXPORT O3AFuncData {
   const Conformer *prbConf;
   const Conformer *refConf;
   void *prbProp;
@@ -46,7 +46,7 @@
 //! is defined by a pair of atom indexes (one for the probe,
 //! one for the reference) and a weight. Constraints can
 //! can be added via the O3AConstraintVect class.
-class RDKIT_MOLALIGN_EXPORT O3AConstraint {
+class RDKIT_O3AALIGN_EXPORT O3AConstraint {
   friend class O3AConstraintVect;
 
  public:
@@ -66,7 +66,7 @@
 //! method is invoked, the vector is sorted to make lookup faster.
 //! Hence, constraints are not necessarily stored in the same order
 //! they were appended.
-class RDKIT_MOLALIGN_EXPORT O3AConstraintVect {
+class RDKIT_O3AALIGN_EXPORT O3AConstraintVect {
  public:
   O3AConstraintVect() {}
   ~O3AConstraintVect() = default;
@@ -128,7 +128,7 @@
   O3_LOCAL_ONLY = (1 << 2)
 };
 
-class RDKIT_MOLALIGN_EXPORT MolHistogram {
+class RDKIT_O3AALIGN_EXPORT MolHistogram {
  public:
   MolHistogram(const ROMol &mol, const double *dmat, bool cleanupDmat = false);
   ~MolHistogram() = default;
@@ -142,7 +142,7 @@
   boost::multi_array<int, 2> d_h;
 };
 
-class RDKIT_MOLALIGN_EXPORT LAP {
+class RDKIT_O3AALIGN_EXPORT LAP {
  public:
   LAP(unsigned int dim)
       : d_rowSol(dim),
@@ -184,7 +184,7 @@
   boost::multi_array<int, 2> d_cost;
 };
 
-class RDKIT_MOLALIGN_EXPORT SDM {
+class RDKIT_O3AALIGN_EXPORT SDM {
  public:
   // constructor
   SDM(const Conformer *prbConf = nullptr, const Conformer *refConf = nullptr,
@@ -271,7 +271,7 @@
   }
 };
 
-class RDKIT_MOLALIGN_EXPORT O3A {
+class RDKIT_O3AALIGN_EXPORT O3A {
  public:
   //! pre-defined atom typing schemes
   typedef enum { MMFF94 = 0, CRIPPEN } AtomTypeScheme;
@@ -319,30 +319,30 @@
   double d_o3aScore;
 };
 
-RDKIT_MOLALIGN_EXPORT void randomTransform(ROMol &mol, const int cid = -1,
+RDKIT_O3AALIGN_EXPORT void randomTransform(ROMol &mol, const int cid = -1,
                                            const int seed = -1);
-RDKIT_MOLALIGN_EXPORT const RDGeom::POINT3D_VECT *reflect(
+RDKIT_O3AALIGN_EXPORT const RDGeom::POINT3D_VECT *reflect(
     const Conformer &conf);
-RDKIT_MOLALIGN_EXPORT int o3aMMFFCostFunc(const unsigned int prbIdx,
+RDKIT_O3AALIGN_EXPORT int o3aMMFFCostFunc(const unsigned int prbIdx,
                                           const unsigned int refIdx,
                                           double hSum, void *data);
-RDKIT_MOLALIGN_EXPORT double o3aMMFFWeightFunc(const unsigned int prbIdx,
+RDKIT_O3AALIGN_EXPORT double o3aMMFFWeightFunc(const unsigned int prbIdx,
                                                const unsigned int refIdx,
                                                void *data);
-RDKIT_MOLALIGN_EXPORT double o3aMMFFScoringFunc(const unsigned int prbIdx,
+RDKIT_O3AALIGN_EXPORT double o3aMMFFScoringFunc(const unsigned int prbIdx,
                                                 const unsigned int refIdx,
                                                 void *data);
-RDKIT_MOLALIGN_EXPORT int o3aCrippenCostFunc(const unsigned int prbIdx,
+RDKIT_O3AALIGN_EXPORT int o3aCrippenCostFunc(const unsigned int prbIdx,
                                              const unsigned int refIdx,
                                              double hSum, void *data);
-RDKIT_MOLALIGN_EXPORT double o3aCrippenWeightFunc(const unsigned int prbIdx,
+RDKIT_O3AALIGN_EXPORT double o3aCrippenWeightFunc(const unsigned int prbIdx,
                                                   const unsigned int refIdx,
                                                   void *data);
-RDKIT_MOLALIGN_EXPORT double o3aCrippenScoringFunc(const unsigned int prbIdx,
+RDKIT_O3AALIGN_EXPORT double o3aCrippenScoringFunc(const unsigned int prbIdx,
                                                    const unsigned int refIdx,
                                                    void *data);
 
-RDKIT_MOLALIGN_EXPORT void getO3AForProbeConfs(
+RDKIT_O3AALIGN_EXPORT void getO3AForProbeConfs(
     ROMol &prbMol, const ROMol &refMol, void *prbProp, void *refProp,
     std::vector<boost::shared_ptr<O3A>> &res, int numThreads = 1,
     O3A::AtomTypeScheme atomTypes = O3A::MMFF94, const int refCid = -1,
Index: openbabel-src/openbabel/src/formats/vaspformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/vaspformat.cpp b/openbabel-src/openbabel/src/formats/vaspformat.cpp
--- a/openbabel-src/openbabel/src/formats/vaspformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/vaspformat.cpp	(date 1696647929191)
@@ -532,7 +532,7 @@
             for (size_t natom = 0; natom < pmol->NumAtoms(); ++natom) {
               const vector3 dxyz = currXyz[natom] - prevXyz[natom];
               vector3::const_iterator iter = std::find_if(dxyz.begin(), dxyz.end(),
-                      std::bind2nd(std::not_equal_to<double>(), 0.0));
+                      std::bind(std::not_equal_to<double>(), std::placeholders::_1, 0.0));
               if (iter != dxyz.end()) dipGrad[natom].SetRow(iter - dxyz.begin(),
                                                             (currDm - prevDm) / *iter);
             }
@@ -586,7 +586,7 @@
       if (max != 0.0) {
         // Normalize
         std::transform(Intensities.begin(), Intensities.end(), Intensities.begin(),
-                       std::bind2nd(std::divides<double>(), max / 100.0));
+                       std::bind(std::divides<double>(), std::placeholders::_1, max / 100.0));
       } else {
         Intensities.clear();
       }
Index: eigen-src/eigen/Eigen/src/Core/util/DisableStupidWarnings.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/eigen-src/eigen/Eigen/src/Core/util/DisableStupidWarnings.h b/eigen-src/eigen/Eigen/src/Core/util/DisableStupidWarnings.h
--- a/eigen-src/eigen/Eigen/src/Core/util/DisableStupidWarnings.h	(revision 3147391d946bb4b6c68edd901f2add6ac1f31f8c)
+++ b/eigen-src/eigen/Eigen/src/Core/util/DisableStupidWarnings.h	(date 1701843801258)
@@ -74,25 +74,25 @@
 #endif
 
 #if defined __NVCC__
-  #pragma diag_suppress boolean_controlling_expr_is_constant
+  #pragma nv_diag_suppress boolean_controlling_expr_is_constant
   // Disable the "statement is unreachable" message
-  #pragma diag_suppress code_is_unreachable
+  #pragma nv_diag_suppress code_is_unreachable
   // Disable the "dynamic initialization in unreachable code" message
-  #pragma diag_suppress initialization_not_reachable
+  #pragma nv_diag_suppress initialization_not_reachable
   // Disable the "invalid error number" message that we get with older versions of nvcc
-  #pragma diag_suppress 1222
+  #pragma nv_diag_suppress 1222
   // Disable the "calling a __host__ function from a __host__ __device__ function is not allowed" messages (yes, there are many of them and they seem to change with every version of the compiler)
-  #pragma diag_suppress 2527
-  #pragma diag_suppress 2529
-  #pragma diag_suppress 2651
-  #pragma diag_suppress 2653
-  #pragma diag_suppress 2668
-  #pragma diag_suppress 2669
-  #pragma diag_suppress 2670
-  #pragma diag_suppress 2671
-  #pragma diag_suppress 2735
-  #pragma diag_suppress 2737
-  #pragma diag_suppress 2739
+  #pragma nv_diag_suppress 2527
+  #pragma nv_diag_suppress 2529
+  #pragma nv_diag_suppress 2651
+  #pragma nv_diag_suppress 2653
+  #pragma nv_diag_suppress 2668
+  #pragma nv_diag_suppress 2669
+  #pragma nv_diag_suppress 2670
+  #pragma nv_diag_suppress 2671
+  #pragma nv_diag_suppress 2735
+  #pragma nv_diag_suppress 2737
+  #pragma nv_diag_suppress 2739
 #endif
 
 #else
Index: openbabel-src/openbabel/src/formats/nwchemformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/nwchemformat.cpp b/openbabel-src/openbabel/src/formats/nwchemformat.cpp
--- a/openbabel-src/openbabel/src/formats/nwchemformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/nwchemformat.cpp	(date 1696647929187)
@@ -303,10 +303,11 @@
         blank_line = false;
         if (vs[0][0] == '0')
             charge = atoi(vs[4].c_str());
-        else if (vs[0][0] == '1')
+        else if (vs[0][0] == '1') {
             for (unsigned int i = 0; i < 3; i++)
                 if (vs[i+1][0] == '1')
                     dipole[i] = atof(vs[4].c_str());
+        }
         else if (vs[0][0] == '2')
         {
             double value = atof(vs[4].c_str());
Index: openbabel-src/openbabel/src/formats/xtcformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/xtcformat.cpp b/openbabel-src/openbabel/src/formats/xtcformat.cpp
--- a/openbabel-src/openbabel/src/formats/xtcformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/xtcformat.cpp	(date 1696647929192)
@@ -29,7 +29,7 @@
 #include <vector>
 
 #define MAXID 20
-#define MAXABS INT_MAX-2
+#define MAXABS float(INT_MAX-2)
 
 #ifndef MIN
 #define MIN(x,y) ((x) < (y) ? (x):(y))
Index: openbabel-src/openbabel/src/formats/gamessukformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/gamessukformat.cpp b/openbabel-src/openbabel/src/formats/gamessukformat.cpp
--- a/openbabel-src/openbabel/src/formats/gamessukformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/gamessukformat.cpp	(date 1696647929184)
@@ -23,12 +23,7 @@
 
 #include <algorithm>
 #include <cmath>
-
-#ifdef _MSC_VER
 #include <regex>
-#else
-#include <regex.h>
-#endif
 
 using namespace std;
 
@@ -797,20 +792,15 @@
     //                     ------label--------   -------charge-------- < seems enough for a match
     string pattern(" *\\* *[a-zA-Z]{1,2}[0-9]* *[0-9]{1,3}\\.[0-9]{1}");
     bool iok;
-#ifdef _MSC_VER
-    std::tr1::regex myregex;
+    std::regex myregex;
     try {
       myregex.assign(pattern,
-                     std::tr1::regex_constants::extended |
-                     std::tr1::regex_constants::nosubs);
+                     std::regex_constants::extended |
+                     std::regex_constants::nosubs);
       iok = true;
-    } catch (std::tr1::regex_error ex) {
+    } catch (std::regex_error ex) {
       iok = false;
     }
-#else
-    regex_t *myregex = new regex_t;
-    iok = regcomp(myregex, pattern.c_str(), REG_EXTENDED | REG_NOSUB)==0;
-#endif
     if (!iok) cerr << "Error compiling regex in GUK OUTPUT!\n";
 
     // Read in the coordinates - we process them directly rather
@@ -820,11 +810,7 @@
 
       // End of geometry block
       if (strstr(buffer, "*************************") != nullptr) break;
-#ifdef _MSC_VER
-      if (std::tr1::regex_search(buffer, myregex)) {
-#else
-        if (regexec(myregex, buffer, 0, nullptr, 0) == 0) {
-#endif
+      if (std::regex_search(buffer, myregex)) {
           //cerr << "Got Coord line: " << buffer << endl;
           OBAtom *atom = mol.NewAtom();
           tokenize(tokens,buffer," ");
@@ -841,9 +827,6 @@
         }
       }
       mol.EndModify();
-#ifndef _MSC_VER
-      regfree(myregex);
-#endif
       return true;
     } // End ReadInitalCartesian
 
Index: openbabel-src/openbabel/src/formats/chemkinformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/chemkinformat.cpp b/openbabel-src/openbabel/src/formats/chemkinformat.cpp
--- a/openbabel-src/openbabel/src/formats/chemkinformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/chemkinformat.cpp	(date 1696647929181)
@@ -726,7 +726,7 @@
 
   string missing; // list of molecules which do not have thermodata
   OBConversion StdThermConv;
-  ifstream stdthermo;
+  istringstream stdthermo;
   OpenDatafile(stdthermo, datafilename);
   if(!stdthermo)
   {
Index: openbabel-src/openbabel/src/formats/orcaformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/orcaformat.cpp b/openbabel-src/openbabel/src/formats/orcaformat.cpp
--- a/openbabel-src/openbabel/src/formats/orcaformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/orcaformat.cpp	(date 1696647929187)
@@ -24,11 +24,7 @@
 #include <openbabel/generic.h>
 #include <cstdlib>
 
-#ifdef _MSC_VER
 #include <regex>
-#else
-#include <regex.h>
-#endif
 
 #include <iomanip>
 
@@ -696,38 +692,22 @@
 
 // small function to avoid wrong parsing
 // if there is no whitespace between the numbers in the column structure
-#ifdef _MSC_VER
   string OrcaOutputFormat::checkColumns(string checkBuffer)
   {
     string pattern ("[0-9]-");
-    std::tr1::regex myregex;
-    std::tr1::smatch pm;
+    std::regex myregex;
+    std::smatch pm;
     try {
       myregex.assign(pattern,
-                     std::tr1::regex_constants::extended);
+                     std::regex_constants::extended);
       //iok = true;
-    } catch (std::tr1::regex_error ex) {
+    } catch (std::regex_error ex) {
         return (checkBuffer); // do nothing
       //iok = false;
     }
-    while (std::tr1::regex_search (checkBuffer,pm,myregex)) {
+    while (std::regex_search (checkBuffer,pm,myregex)) {
         checkBuffer.insert(pm.position(0)+1, " ");
     }
     return (checkBuffer);
   }
-#else
-  string OrcaOutputFormat::checkColumns(string checkBuffer)
-  {
-      string pattern ("[0-9]-");
-      regmatch_t pm;
-      regex_t myregex;
-      int pos = regcomp(&myregex, pattern.c_str(), REG_EXTENDED);
-      if (pos !=0) return (checkBuffer); // do nothing
-
-      while (regexec(&myregex, checkBuffer.c_str(), 1, &pm, REG_EXTENDED) == 0) {
-          checkBuffer.insert(pm.rm_eo-1, " ");  // insert whitespace to separate the columns
-      }
-      return (checkBuffer);
-  }
-#endif
 } //namespace OpenBabel
Index: eigen-src/eigen/Eigen/src/Core/util/Macros.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/eigen-src/eigen/Eigen/src/Core/util/Macros.h b/eigen-src/eigen/Eigen/src/Core/util/Macros.h
--- a/eigen-src/eigen/Eigen/src/Core/util/Macros.h	(revision 3147391d946bb4b6c68edd901f2add6ac1f31f8c)
+++ b/eigen-src/eigen/Eigen/src/Core/util/Macros.h	(date 1701843801258)
@@ -59,7 +59,7 @@
 //------------------------------------------------------------------------------------------
 
 /// \internal EIGEN_COMP_GNUC set to 1 for all compilers compatible with GCC
-#ifdef __GNUC__
+#if defined(__GNUC__) && !defined(EMSCRIPTEN)
   #define EIGEN_COMP_GNUC (__GNUC__*10+__GNUC_MINOR__)
 #else
   #define EIGEN_COMP_GNUC 0
Index: eigen-src/eigen/Eigen/src/Core/util/ConfigureVectorization.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/eigen-src/eigen/Eigen/src/Core/util/ConfigureVectorization.h b/eigen-src/eigen/Eigen/src/Core/util/ConfigureVectorization.h
--- a/eigen-src/eigen/Eigen/src/Core/util/ConfigureVectorization.h	(revision 3147391d946bb4b6c68edd901f2add6ac1f31f8c)
+++ b/eigen-src/eigen/Eigen/src/Core/util/ConfigureVectorization.h	(date 1701843801257)
@@ -339,7 +339,7 @@
     extern "C" {
       // In theory we should only include immintrin.h and not the other *mmintrin.h header files directly.
       // Doing so triggers some issues with ICC. However old gcc versions seems to not have this file, thus:
-      #if EIGEN_COMP_ICC >= 1110
+      #if EIGEN_COMP_ICC >= 1110 || EIGEN_COMP_EMSCRIPTEN
         #include <immintrin.h>
       #else
         #include <mmintrin.h>
Index: rdkit-src/rdkit/Code/GraphMol/SLNParse/lex.yysln.cpp.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/SLNParse/lex.yysln.cpp.cmake b/rdkit-src/rdkit/Code/GraphMol/SLNParse/lex.yysln.cpp.cmake
--- a/rdkit-src/rdkit/Code/GraphMol/SLNParse/lex.yysln.cpp.cmake	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/Code/GraphMol/SLNParse/lex.yysln.cpp.cmake	(date 1701849536984)
@@ -727,8 +727,8 @@
 #endif
 
 #include <cstdio>
-#ifdef WIN32
-#include <io.h> 	 
+#if defined(WIN32) || defined(__MINGW32__)
+#include <io.h>
 #endif
 
 #include <RDGeneral/Exceptions.h>
Index: openbabel-src/openbabel/src/formats/pdbqtformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/pdbqtformat.cpp b/openbabel-src/openbabel/src/formats/pdbqtformat.cpp
--- a/openbabel-src/openbabel/src/formats/pdbqtformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/pdbqtformat.cpp	(date 1696647929188)
@@ -483,7 +483,7 @@
     return mol.DeleteNonPolarHydrogens();
   }
 
-  bool OutputTree(OBConversion* pConv, OBMol& mol, ostream& ofs, map <unsigned int, branch> & tree, unsigned int depth, bool moves_many, bool preserve_original_index)
+  bool OutputTree(OBConversion* pConv, OBMol& mol, ostream& ofs, map <size_t, branch> & tree, unsigned int depth, bool moves_many, bool preserve_original_index)
   {
     if (tree.empty()) {return false;}
     if (depth>= tree.size()-1) {depth=tree.size()-1;}
@@ -607,7 +607,7 @@
     return true;
   }
 
-  void ConstructTree (map <unsigned int, branch>& tree, vector <vector <int> > rigid_fragments, unsigned int root_piece, const OBMol& mol, bool flexible)
+  void ConstructTree (map <size_t, branch>& tree, vector <vector <int> > rigid_fragments, unsigned int root_piece, const OBMol& mol, bool flexible)
   {
     unsigned int first_atom = 0;
     unsigned int second_atom = 0;
@@ -651,7 +651,7 @@
             sprog.rigid_with.insert(sprog.index);
 
             (*tree.find(position)).second.children.insert(tree.size()); //tells the current parent it has an extra child
-                        tree.insert(pair<unsigned int, branch> (tree.size(), sprog)); //adds the current branch to the tree
+                        tree.insert(std::make_pair(tree.size(), sprog)); //adds the current branch to the tree
 
             rigid_fragments.erase(rigid_fragments.begin() + i);
             sterile=false;
@@ -747,7 +747,7 @@
     return false;
   }
 
-  unsigned int AtomsSoFar(const map <unsigned int, branch> & tree, unsigned int depth)
+  unsigned int AtomsSoFar(const map <size_t, branch> & tree, unsigned int depth)
   {
     if (depth > tree.size()) {return 0;}
     unsigned int numberAtoms=0;
@@ -985,7 +985,7 @@
 
       vector <vector <int> > rigid_fragments; //the vector of all the rigid molecule fragments, using atom indexes
       unsigned int best_root_atom=1;
-      map <unsigned int, branch> tree;
+      map <size_t, branch> tree;
       unsigned int torsdof=0;
       unsigned int root_piece=0;
       unsigned int rotatable_bonds=0;
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.h b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.h
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.h	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.h	(date 1696647928641)
@@ -35,7 +35,7 @@
 #ifndef __IXA_STATUS_H__
 #define __IXA_STATUS_H__
 
-#include "../../../../INCHI_BASE/src/ixa.h"
+#include "ixa.h"
 
 void STATUS_PushMessage( IXA_STATUS_HANDLE hStatus,
                         IXA_STATUS        vSeverity,
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_inchikey_builder.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_inchikey_builder.c b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_inchikey_builder.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_inchikey_builder.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_inchikey_builder.c	(date 1696647928640)
@@ -32,8 +32,8 @@
  */
 
 
-#include "../../../../INCHI_BASE/src/mode.h"
-#include "../../../../INCHI_BASE/src/inchi_api.h"
+#include "mode.h"
+#include "inchi_api.h"
 #include "ixa_status.h"
 #include <stdlib.h>
 #include <string.h>
Index: inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_main.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_main.c b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_main.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_main.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_main.c	(date 1696647928640)
@@ -34,7 +34,7 @@
 
 /* inchi_dll_main.c : Defines the entry point for the DLL application. */
 
-#include "../../../INCHI_BASE/src/mode.h"
+#include "mode.h"
 
 #if defined(_WIN32) && defined(_USRDLL) && defined(_DEBUG) && !(defined(__STDC__) && __STDC__ == 1)
 #include "inchi_dll_main.h"
Index: inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a2.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a2.c b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a2.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a2.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a2.c	(date 1696647928639)
@@ -43,31 +43,31 @@
 
 /*  */
 
-#include "../../../INCHI_BASE/src/mode.h"
-#include "../../../INCHI_BASE/src/ichitime.h"
-#include "../../../INCHI_BASE/src/incomdef.h"
-#include "../../../INCHI_BASE/src/ichidrp.h"
-#include "../../../INCHI_BASE/src/inpdef.h"
-#include "../../../INCHI_BASE/src/ichi.h"
-#include "../../../INCHI_BASE/src/strutil.h"
-#include "../../../INCHI_BASE/src/util.h"
-#include "../../../INCHI_BASE/src/ichidrp.h"
-#include "../../../INCHI_BASE/src/ichierr.h"
-#include "../../../INCHI_BASE/src/ichimain.h"
-#include "../../../INCHI_BASE/src/extr_ct.h"
-#include "../../../INCHI_BASE/src/ichitaut.h"
-#include "../../../INCHI_BASE/src/ichi_io.h"
-#include "../../../INCHI_BASE/src/ichinorm.h"
-#include "../../../INCHI_BASE/src/ichicant.h"
-#include "../../../INCHI_BASE/src/ichicano.h"
-#include "../../../INCHI_BASE/src/ichicomn.h"
-#include "../../../INCHI_BASE/src/ichimake.h"
-#include "../../../INCHI_BASE/src/ichister.h"
+#include "mode.h"
+#include "ichitime.h"
+#include "incomdef.h"
+#include "ichidrp.h"
+#include "inpdef.h"
+#include "ichi.h"
+#include "strutil.h"
+#include "util.h"
+#include "ichidrp.h"
+#include "ichierr.h"
+#include "ichimain.h"
+#include "extr_ct.h"
+#include "ichitaut.h"
+#include "ichi_io.h"
+#include "ichinorm.h"
+#include "ichicant.h"
+#include "ichicano.h"
+#include "ichicomn.h"
+#include "ichimake.h"
+#include "ichister.h"
 /* */
 #ifdef INCHI_LIB
 #include "ichi_lib.h"
 #endif
-#include "../../../INCHI_BASE/src/ichicomp.h"
+#include "ichicomp.h"
 
 /* for DisplayTheWholeStructure() */
 #define COMP_ORIG_0_MAIN  0x0001
@@ -77,9 +77,9 @@
 #define COMP_ORIG_1_MAIN  0x0010
 #define COMP_ORIG_1_RECN  0x0020
 
-#include "../../../INCHI_BASE/src/ichisize.h"
-#include "../../../INCHI_BASE/src/mode.h"
-#include "../../../INCHI_BASE/src/inchi_api.h"
+#include "ichisize.h"
+#include "mode.h"
+#include "inchi_api.h"
 #include "inchi_dll_a.h" /* not inchi_api.h as it hides internal data types */
 
 
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_builder.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_builder.c b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_builder.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_builder.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_builder.c	(date 1696647928640)
@@ -32,9 +32,9 @@
  */
 
 
-#include "../../../../INCHI_BASE/src/mode.h"
-#include "../../../../INCHI_BASE/src/inchi_api.h"
-#include "../../../../INCHI_BASE/src/inpdef.h"
+#include "mode.h"
+#include "inchi_api.h"
+#include "inpdef.h"
 #include "ixa_status.h"
 #include "ixa_mol.h"
 #include <ctype.h>
Index: openbabel-src/openbabel/src/formats/svgformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/svgformat.cpp b/openbabel-src/openbabel/src/formats/svgformat.cpp
--- a/openbabel-src/openbabel/src/formats/svgformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/svgformat.cpp	(date 1696647929190)
@@ -513,7 +513,7 @@
 //returns true if the file "svgformat.script" was inserted into the output
 bool SVGFormat::EmbedScript(ostream& ofs)
 {
-  ifstream ifs;
+  istringstream ifs;
   if(!ifs || OpenDatafile(ifs, "svgformat.script").empty())
     return false;
   ofs << ifs.rdbuf(); //copy whole file
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.h b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.h
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.h	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.h	(date 1696647928641)
@@ -35,7 +35,7 @@
 #ifndef __IXA_MOL_H__
 #define __IXA_MOL_H__
 
-#include "../../../../INCHI_BASE/src/ixa.h"
+#include "ixa.h"
 
 typedef struct
 {
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_inchi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_inchi.c b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_inchi.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_inchi.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_inchi.c	(date 1696647928641)
@@ -34,9 +34,9 @@
 
 #include "string.h"
 
-#include "../../../../INCHI_BASE/src/mode.h"
-#include "../../../../INCHI_BASE/src/inchi_api.h"
-#include "../../../../INCHI_BASE/src/util.h"
+#include "mode.h"
+#include "inchi_api.h"
+#include "util.h"
 #include "ixa_mol.h"
 #include "ixa_status.h"
 
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_mol.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_mol.c b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_mol.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_mol.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_read_mol.c	(date 1696647928641)
@@ -38,12 +38,12 @@
 #include <stdlib.h>
 #include <string.h>
 
-#include "../../../../INCHI_BASE/src/mode.h"
-#include "../../../../INCHI_BASE/src/inchi_api.h"
-#include "../../../../INCHI_BASE/src/ichicomp.h"
-#include "../../../../INCHI_BASE/src/util.h"
-#include "../../../../INCHI_BASE/src/mol_fmt.h"
-#include "../../../../INCHI_BASE/src/ichi_io.h"
+#include "mode.h"
+#include "inchi_api.h"
+#include "ichicomp.h"
+#include "util.h"
+#include "mol_fmt.h"
+#include "ichi_io.h"
 
 #include "ixa_status.h"
 #include "ixa_mol.h"
Index: cairo-src/cairo/src/cairo.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cairo-src/cairo/src/cairo.h b/cairo-src/cairo/src/cairo.h
--- a/cairo-src/cairo/src/cairo.h	(revision 3909090108bb2db55330e3eb148aebe664735363)
+++ b/cairo-src/cairo/src/cairo.h	(date 1701841902445)
@@ -38,6 +38,7 @@
 #ifndef CAIRO_H
 #define CAIRO_H
 
+#include "cairo_export.h"
 #include "cairo-version.h"
 #include "cairo-features.h"
 #include "cairo-deprecated.h"
@@ -50,22 +51,7 @@
 # define CAIRO_END_DECLS
 #endif
 
-#if (defined(_WIN32) || defined(__CYGWIN__)) && !defined(CAIRO_WIN32_STATIC_BUILD)
-# define _cairo_export __declspec(dllexport)
-# define _cairo_import __declspec(dllimport)
-#elif defined(__GNUC__) && (__GNUC__ >= 4)
-# define _cairo_export __attribute__((__visibility__("default")))
-# define _cairo_import
-#else
-# define _cairo_export
-# define _cairo_import
-#endif
-
-#ifdef CAIRO_COMPILATION
-# define _cairo_api _cairo_export
-#else
-# define _cairo_api _cairo_import
-#endif
+# define _cairo_api CAIRO_EXPORT
 
 #define cairo_public _cairo_api extern
 
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.c b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_mol.c	(date 1696647928640)
@@ -36,12 +36,12 @@
 #include <string.h>
 #include <limits.h>
 
-#include "../../../../INCHI_BASE/src/mode.h"
-#include "../../../../INCHI_BASE/src/ichierr.h"
-#include "../../../../INCHI_BASE/src/mol_fmt.h"
-#include "../../../../INCHI_BASE/src/inchi_api.h"
+#include "mode.h"
+#include "ichierr.h"
+#include "mol_fmt.h"
+#include "inchi_api.h"
 
-#include "../../../../INCHI_BASE/src/ichi_io.h"
+#include "ichi_io.h"
 
 #include "ixa_mol.h"
 #include "ixa_status.h"
Index: inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.c b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ixa/ixa_status.c	(date 1696647928641)
@@ -32,8 +32,8 @@
  */
 
 
-#include "../../../../INCHI_BASE/src/mode.h"
-#include "../../../../INCHI_BASE/src/inchi_api.h"
+#include "mode.h"
+#include "inchi_api.h"
 #include "ixa_status.h"
 #include <string.h>
 #include <stdarg.h>
Index: inchi-src/inchi/INCHI_API/libinchi/src/ichilnct.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/ichilnct.c b/inchi-src/inchi/INCHI_API/libinchi/src/ichilnct.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/ichilnct.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/ichilnct.c	(date 1696647928638)
@@ -42,16 +42,16 @@
 
 /* for use in the InChI library */
 
-#include "../../../INCHI_BASE/src/mode.h"
+#include "mode.h"
 
-#include "../../../INCHI_BASE/src/incomdef.h"
-#include "../../../INCHI_BASE/src/ichidrp.h"
-#include "../../../INCHI_BASE/src/inpdef.h"
-#include "../../../INCHI_BASE/src/util.h"
-#include "../../../INCHI_BASE/src/ichierr.h"
-#include "../../../INCHI_BASE/src/ichicomp.h"
-#include "../../../INCHI_BASE/src/ichi_io.h"
-#include "../../../INCHI_BASE/src/inchi_api.h"
+#include "incomdef.h"
+#include "ichidrp.h"
+#include "inpdef.h"
+#include "util.h"
+#include "ichierr.h"
+#include "ichicomp.h"
+#include "ichi_io.h"
+#include "inchi_api.h"
 
 #include "inchi_dll_b.h"
 
@@ -63,7 +63,7 @@
                        int *err, char *pStrErr );
 
 /* This contains executable code. Included in lReadAux.c, e_ReadINCH.c, ReadINCH.c,  */
-#include "../../../INCHI_BASE/src/readinch.h"
+#include "readinch.h"
 
 
 
Index: openssl-src/openssl/crypto/bn_conf.h.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openssl-src/openssl/crypto/bn_conf.h.cmake b/openssl-src/openssl/crypto/bn_conf.h.cmake
new file mode 100644
--- /dev/null	(date 1696647929423)
+++ b/openssl-src/openssl/crypto/bn_conf.h.cmake	(date 1696647929423)
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2016 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://www.openssl.org/source/license.html
+ */
+
+#ifndef OSSL_CRYPTO_BN_CONF_H
+# define OSSL_CRYPTO_BN_CONF_H
+
+/*
+ * The contents of this file are not used in the UEFI build, as
+ * both 32-bit and 64-bit builds are supported from a single run
+ * of the Configure script.
+ */
+
+/* Should we define BN_DIV2W here? */
+
+/* Only one for the following should be defined */
+#cmakedefine SIXTY_FOUR_BIT_LONG
+#cmakedefine SIXTY_FOUR_BIT
+#cmakedefine THIRTY_TWO_BIT
+
+#endif
Index: inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll.c b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll.c	(date 1696647928639)
@@ -42,25 +42,25 @@
 #include <float.h>
 #include <math.h>
 
-#include "../../../INCHI_BASE/src/mode.h"
+#include "mode.h"
 
-#include "../../../INCHI_BASE/src/incomdef.h"
-#include "../../../INCHI_BASE/src/ichidrp.h"
-#include "../../../INCHI_BASE/src/inpdef.h"
-#include "../../../INCHI_BASE/src/ichi.h"
-#include "../../../INCHI_BASE/src/strutil.h"
-#include "../../../INCHI_BASE/src/util.h"
-#include "../../../INCHI_BASE/src/ichierr.h"
-#include "../../../INCHI_BASE/src/ichimain.h"
-#include "../../../INCHI_BASE/src/extr_ct.h"
-#include "../../../INCHI_BASE/src/ichi_io.h"
-#include "../../../INCHI_BASE/src/ichicomp.h"
-#include "../../../INCHI_BASE/src/inchi_api.h"
-#include "../../../INCHI_BASE/src/readinch.h"
+#include "incomdef.h"
+#include "ichidrp.h"
+#include "inpdef.h"
+#include "ichi.h"
+#include "strutil.h"
+#include "util.h"
+#include "ichierr.h"
+#include "ichimain.h"
+#include "extr_ct.h"
+#include "ichi_io.h"
+#include "ichicomp.h"
+#include "inchi_api.h"
+#include "readinch.h"
 
-#include "../../../INCHI_BASE/src/ichitaut.h"
-#include "../../../INCHI_BASE/src/ichicant.h"
-#include "../../../INCHI_BASE/src/ichitime.h"
+#include "ichitaut.h"
+#include "ichicant.h"
+#include "ichitime.h"
 
 #include "inchi_dll.h"
 
Index: zlib-src/zlib/zconf.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/zlib-src/zlib/zconf.h b/zlib-src/zlib/zconf.h
--- a/zlib-src/zlib/zconf.h	(revision 09155eaa2f9270dc4ed1fa13e2b4b2613e6e4851)
+++ b/zlib-src/zlib/zconf.h	(date 1701828597237)
@@ -8,6 +8,7 @@
 #ifndef ZCONF_H
 #define ZCONF_H
 
+#include "zlib_export.h"
 /*
  * If you *really* need a unique prefix for all types and library functions,
  * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
@@ -334,63 +335,15 @@
 #    endif
 #  endif
 #endif
-
-#if defined(WINDOWS) || defined(WIN32)
-   /* If building or using zlib as a DLL, define ZLIB_DLL.
-    * This is not mandatory, but it offers a little performance increase.
-    */
-#  ifdef ZLIB_DLL
-#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
-#      ifdef ZLIB_INTERNAL
-#        define ZEXTERN extern __declspec(dllexport)
-#      else
-#        define ZEXTERN extern __declspec(dllimport)
-#      endif
-#    endif
-#  endif  /* ZLIB_DLL */
-   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
-    * define ZLIB_WINAPI.
-    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
-    */
-#  ifdef ZLIB_WINAPI
-#    ifdef FAR
-#      undef FAR
-#    endif
-#    ifndef WIN32_LEAN_AND_MEAN
-#      define WIN32_LEAN_AND_MEAN
-#    endif
-#    include <windows.h>
-     /* No need for _export, use ZLIB.DEF instead. */
-     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
-#    define ZEXPORT WINAPI
-#    ifdef WIN32
-#      define ZEXPORTVA WINAPIV
-#    else
-#      define ZEXPORTVA FAR CDECL
-#    endif
-#  endif
-#endif
-
-#if defined (__BEOS__)
-#  ifdef ZLIB_DLL
-#    ifdef ZLIB_INTERNAL
-#      define ZEXPORT   __declspec(dllexport)
-#      define ZEXPORTVA __declspec(dllexport)
-#    else
-#      define ZEXPORT   __declspec(dllimport)
-#      define ZEXPORTVA __declspec(dllimport)
-#    endif
-#  endif
-#endif
 
 #ifndef ZEXTERN
-#  define ZEXTERN extern
+#define ZEXTERN extern ZLIB_EXPORT
 #endif
 #ifndef ZEXPORT
-#  define ZEXPORT
+#define ZEXPORT
 #endif
 #ifndef ZEXPORTVA
-#  define ZEXPORTVA
+#define ZEXPORTVA
 #endif
 
 #ifndef FAR
Index: openssl-src/openssl/crypto/buildinf.h.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openssl-src/openssl/crypto/buildinf.h.cmake b/openssl-src/openssl/crypto/buildinf.h.cmake
new file mode 100644
--- /dev/null	(date 1696647929424)
+++ b/openssl-src/openssl/crypto/buildinf.h.cmake	(date 1696647929424)
@@ -0,0 +1,6 @@
+/* auto-generated for crypto/cversion.c */
+#define CFLAGS "compiler: @CMAKE_C_COMPILER_ID@ @CMAKE_C_FLAGS@"
+#define PLATFORM "platform: @CMAKE_SYSTEM_NAME@"
+#define DATE "built on: @BUILDINF_DATE@"
+static const char *compiler_flags = CFLAGS;
+
Index: inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_b.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_b.c b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_b.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_b.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_b.c	(date 1696647928640)
@@ -42,22 +42,22 @@
 #include <float.h>
 #include <math.h>
 
-#include "../../../INCHI_BASE/src/mode.h"
-#include "../../../INCHI_BASE/src/inchi_api.h"
-#include "../../../INCHI_BASE/src/incomdef.h"
-#include "../../../INCHI_BASE/src/ichidrp.h"
-#include "../../../INCHI_BASE/src/inpdef.h"
-#include "../../../INCHI_BASE/src/ichi.h"
-#include "../../../INCHI_BASE/src/strutil.h"
-#include "../../../INCHI_BASE/src/util.h"
-#include "../../../INCHI_BASE/src/ichierr.h"
-#include "../../../INCHI_BASE/src/ichimain.h"
-#include "../../../INCHI_BASE/src/extr_ct.h"
-#include "../../../INCHI_BASE/src/ichi_io.h"
-#include "../../../INCHI_BASE/src/ichicomp.h"
-#include "../../../INCHI_BASE/src/ichitime.h"
-#include "../../../INCHI_BASE/src/ichicant.h"
-#include "../../../INCHI_BASE/src/readinch.h"
+#include "mode.h"
+#include "inchi_api.h"
+#include "incomdef.h"
+#include "ichidrp.h"
+#include "inpdef.h"
+#include "ichi.h"
+#include "strutil.h"
+#include "util.h"
+#include "ichierr.h"
+#include "ichimain.h"
+#include "extr_ct.h"
+#include "ichi_io.h"
+#include "ichicomp.h"
+#include "ichitime.h"
+#include "ichicant.h"
+#include "readinch.h"
 
 #include "inchi_dll.h"
 #include "inchi_dll_b.h"
Index: inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.c b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.c
--- a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.c	(date 1696647928639)
@@ -46,26 +46,26 @@
 #include <limits.h>
 #include <float.h>
 #include <math.h>
-#include "../../../INCHI_BASE/src/incomdef.h"
-#include "../../../INCHI_BASE/src/ichidrp.h"
-#include "../../../INCHI_BASE/src/inpdef.h"
-#include "../../../INCHI_BASE/src/ichi.h"
-#include "../../../INCHI_BASE/src/strutil.h"
-#include "../../../INCHI_BASE/src/util.h"
-#include "../../../INCHI_BASE/src/ichierr.h"
-#include "../../../INCHI_BASE/src/ichimain.h"
-#include "../../../INCHI_BASE/src/extr_ct.h"
-#include "../../../INCHI_BASE/src/ichi_io.h"
-#include "../../../INCHI_BASE/src/mol_fmt.h"
-#include "../../../INCHI_BASE/src/ichicomp.h"
-#include "../../../INCHI_BASE/src/ichitaut.h"
-#include "../../../INCHI_BASE/src/ichinorm.h"
+#include "incomdef.h"
+#include "ichidrp.h"
+#include "inpdef.h"
+#include "ichi.h"
+#include "strutil.h"
+#include "util.h"
+#include "ichierr.h"
+#include "ichimain.h"
+#include "extr_ct.h"
+#include "ichi_io.h"
+#include "mol_fmt.h"
+#include "ichicomp.h"
+#include "ichitaut.h"
+#include "ichinorm.h"
 
 
-#include "../../../INCHI_BASE/src/ichisize.h"
-#include "../../../INCHI_BASE/src/ichitime.h"
-#include "../../../INCHI_BASE/src/mode.h"
-#include "../../../INCHI_BASE/src/inchi_api.h"
+#include "ichisize.h"
+#include "ichitime.h"
+#include "mode.h"
+#include "inchi_api.h"
 
 #include "inchi_dll_a.h" /* not inchi_api.h as it hides internal data types */
 #include "inchi_dll.h"
Index: inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.h b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.h
--- a/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.h	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_API/libinchi/src/inchi_dll_a.h	(date 1696647928639)
@@ -35,7 +35,7 @@
 #ifndef __INCHI_DLL_A_H__
 #define __INCHI_DLL_A_H__
 
-#include "../../../INCHI_BASE/src/ichicant.h"
+#include "ichicant.h"
 
 typedef struct tagCOMPONENT_TREAT_INFO
 {
@@ -128,25 +128,6 @@
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
 
 
-#if (defined( _WIN32 ) && defined( _MSC_VER ) && defined(BUILD_LINK_AS_DLL) )
-    /* Win32 & MS VC ++, compile and link as a DLL */
-#ifdef _USRDLL
-    /* InChI library dll */
-#define INCHI_API __declspec(dllexport)
-#define EXPIMP_TEMPLATE
-#define INCHI_DECL
-#else
-   /* calling the InChI dll program */
-#define INCHI_API __declspec(dllimport)
-#define EXPIMP_TEMPLATE extern
-#define INCHI_DECL
-#endif
-#else
-    /* create a statically linked InChI library or link to an executable */
-#define INCHI_API
-#define EXPIMP_TEMPLATE
-#define INCHI_DECL
-#endif
 
 
 
Index: skia-src/skia/include/private/base/SkAttributes.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/include/private/base/SkAttributes.h b/skia-src/skia/include/private/base/SkAttributes.h
--- a/skia-src/skia/include/private/base/SkAttributes.h	(revision 5f54e9f84cff8c42fd645ec53c1727857bdb12ab)
+++ b/skia-src/skia/include/private/base/SkAttributes.h	(date 1701851934714)
@@ -24,7 +24,7 @@
  *     SK_ALWAYS_INLINE void someMethod() { ... }   // should always be inlined
  */
 #if !defined(SK_ALWAYS_INLINE)
-#  if defined(SK_BUILD_FOR_WIN)
+#  if defined(SK_BUILD_FOR_WIN) && !defined(__MINGW32__)
 #    define SK_ALWAYS_INLINE __forceinline
 #  else
 #    define SK_ALWAYS_INLINE SK_ATTRIBUTE(always_inline) inline
Index: rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/DrawTextQt.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/DrawTextQt.h b/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/DrawTextQt.h
--- a/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/DrawTextQt.h	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/DrawTextQt.h	(date 1701849536982)
@@ -11,6 +11,7 @@
 #define RDKIT_DRAWTEXTQT_H
 
 #include <RDGeneral/export.h>
+#include <MolDraw2DQt/rdkit_export.hpp>
 #include <GraphMol/MolDraw2D/DrawTextNotFT.h>
 
 class QPainter;
Index: rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/MolDraw2DQt.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/MolDraw2DQt.h b/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/MolDraw2DQt.h
--- a/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/MolDraw2DQt.h	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/Code/GraphMol/MolDraw2D/Qt/MolDraw2DQt.h	(date 1701849536982)
@@ -10,10 +10,10 @@
 // This is a concrete class derived from MolDraw2D that uses RDKit to draw a
 // molecule into a QPainter.
 
-#include <RDGeneral/export.h>
 #ifndef MOLDRAW2DQT_H
 #define MOLDRAW2DQT_H
-
+#include <RDGeneral/export.h>
+#include <MolDraw2DQt/rdkit_export.hpp>
 #include <GraphMol/MolDraw2D/MolDraw2D.h>
 
 class QPainter;
Index: zlib-src/zlib/gzguts.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/zlib-src/zlib/gzguts.h b/zlib-src/zlib/gzguts.h
--- a/zlib-src/zlib/gzguts.h	(revision 09155eaa2f9270dc4ed1fa13e2b4b2613e6e4851)
+++ b/zlib-src/zlib/gzguts.h	(date 1701828597237)
@@ -36,6 +36,8 @@
 
 #if defined(__TURBOC__) || defined(_MSC_VER) || defined(_WIN32)
 #  include <io.h>
+#else
+#  include <unistd.h>
 #endif
 
 #if defined(_WIN32)
Index: openbabel-src/openbabel/src/formats/json/pubchemjsonformat.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/formats/json/pubchemjsonformat.cpp b/openbabel-src/openbabel/src/formats/json/pubchemjsonformat.cpp
--- a/openbabel-src/openbabel/src/formats/json/pubchemjsonformat.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/formats/json/pubchemjsonformat.cpp	(date 1696647929185)
@@ -760,7 +760,7 @@
       // Coordinates
       // TODO: An option to round coordinates to n decimal places?
       xcoords.PushBack(rapidjson::Value(patom->GetX()).Move(), al);
-      ycoords.PushBack(rapidjson::Value(patom->GetX()).Move(), al);
+      ycoords.PushBack(rapidjson::Value(patom->GetY()).Move(), al);
       if (pmol->GetDimension() == 3) {
         zcoords.PushBack(rapidjson::Value(patom->GetZ()).Move(), al);
       }
Index: openbabel-src/openbabel/src/forcefields/forcefielduff.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/forcefields/forcefielduff.cpp b/openbabel-src/openbabel/src/forcefields/forcefielduff.cpp
--- a/openbabel-src/openbabel/src/forcefields/forcefielduff.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/forcefields/forcefielduff.cpp	(date 1696647929178)
@@ -1614,7 +1614,7 @@
     OBFFParameter parameter;
 
     // open data/UFF.prm
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "UFF.prm").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open UFF.prm", obError);
       return false;
@@ -1647,7 +1647,10 @@
         parameter.b = 0; // used for tracking number of angles in 5-coordinate
         parameter.c = 0;
 
-        char coord = vs[1][2]; // 3rd character of atom type
+        char coord = '\0';
+        if (vs[1].size() > 2) {
+          coord = vs[1][2]; // 3rd character of atom type
+        }
         switch (coord) {
         case '1': // linear
           parameter._ipar.push_back(1);
@@ -1680,8 +1683,6 @@
       }
     }
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
@@ -1702,7 +1703,7 @@
     _mol.SetAtomTypesPerceived();
 
     // open data/UFF.prm
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "UFF.prm").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open UFF.prm", obError);
       return false;
@@ -1771,8 +1772,6 @@
 
     }
 
-    if (ifs)
-      ifs.close();
 
     // Free memory
     for (i = _vexttyp.begin();i != _vexttyp.end();++i) {
Index: openbabel-src/openbabel/src/forcefields/forcefieldghemical.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/forcefields/forcefieldghemical.cpp b/openbabel-src/openbabel/src/forcefields/forcefieldghemical.cpp
--- a/openbabel-src/openbabel/src/forcefields/forcefieldghemical.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/forcefields/forcefieldghemical.cpp	(date 1696647929177)
@@ -858,7 +858,7 @@
     OBFFParameter parameter;
 
     // open data/ghemical.prm
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "ghemical.prm").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open ghemical.prm", obError);
       return false;
@@ -942,8 +942,6 @@
       }
     }
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
@@ -964,7 +962,7 @@
     _mol.SetAtomTypesPerceived();
 
     // open data/ghemical.prm
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "ghemical.prm").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open ghemical.prm", obError);
       return false;
@@ -1026,8 +1024,6 @@
     //  else
     //    cout << "ATOMTYPE " << a->GetType() << endl;
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
Index: openbabel-src/openbabel/src/forcefields/forcefieldmm2.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/forcefields/forcefieldmm2.cpp b/openbabel-src/openbabel/src/forcefields/forcefieldmm2.cpp
--- a/openbabel-src/openbabel/src/forcefields/forcefieldmm2.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/forcefields/forcefieldmm2.cpp	(date 1696647929177)
@@ -18,6 +18,10 @@
 #include <openbabel/babelconfig.h>
 #include <openbabel/mol.h>
 #include <openbabel/locale.h>
+#include <openbabel/obiter.h>
+#include <openbabel/bond.h>
+#include <openbabel/oberror.h>
+#include <openbabel/data.h>
 #include "forcefieldmm2.h"
 
 using namespace std;
@@ -498,8 +502,8 @@
     {
       _mol = src._mol;
       _init = src._init;
-      return *this;
-    }
+    }
+    return *this;
   }
 
   bool OBForceFieldMM2::Setup(OBMol &mol)
@@ -522,7 +526,7 @@
     OBFFParameter parameter;
 
     // open data/mm2.prm
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "mm2.prm").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mm2.prm", obError);
       return false;
@@ -667,8 +671,6 @@
       }
     }
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
Index: zxing-src/zxing/core/src/Generator.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/zxing-src/zxing/core/src/Generator.h b/zxing-src/zxing/core/src/Generator.h
--- a/zxing-src/zxing/core/src/Generator.h	(revision 1bb03a85ef9846076fc5068b05646454f7fe6f6f)
+++ b/zxing-src/zxing/core/src/Generator.h	(date 1699257749242)
@@ -6,30 +6,15 @@
 #pragma once
 
 #ifdef __cpp_impl_coroutine
-#ifdef __ANDROID__
-// NDK 25.1.8937393 can compile this code with c++20 but needs a few tweaks:
-#include <experimental/coroutine>
-namespace std {
-	using experimental::suspend_always;
-	using experimental::coroutine_handle;
-	struct default_sentinel_t {};
-}
-#else
 #include <concepts>
 #include <coroutine>
-#endif
-
 #include <optional>
 #include <iterator>
 
 // this code is based on https://en.cppreference.com/w/cpp/coroutine/coroutine_handle#Example
 // but modified trying to prevent accidental copying of generated objects
 
-#ifdef __ANDROID__
-template <class T>
-#else
 template <std::movable T>
-#endif
 class Generator
 {
 public:
Index: openssl-src/openssl/crypto/dso_conf.h.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openssl-src/openssl/crypto/dso_conf.h.cmake b/openssl-src/openssl/crypto/dso_conf.h.cmake
new file mode 100644
--- /dev/null	(date 1696647929434)
+++ b/openssl-src/openssl/crypto/dso_conf.h.cmake	(date 1696647929434)
@@ -0,0 +1,17 @@
+/*
+ * Copyright 2016-2019 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://www.openssl.org/source/license.html
+ */
+
+#ifndef OSSL_CRYPTO_DSO_CONF_H
+# define OSSL_CRYPTO_DSO_CONF_H
+# define DSO_EXTENSION "@DSO_EXTENSION@"
+#cmakedefine DSO_NONE
+#cmakedefine DSO_WIN32
+#cmakedefine DSO_DLFCN
+#cmakedefine HAVE_DLFCN_H
+#endif
Index: openbabel-src/openbabel/src/fingerprints/finger3.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/fingerprints/finger3.cpp b/openbabel-src/openbabel/src/fingerprints/finger3.cpp
--- a/openbabel-src/openbabel/src/fingerprints/finger3.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/fingerprints/finger3.cpp	(date 1696647929176)
@@ -159,7 +159,7 @@
   bool ReadPatternFile(string& ver)
   {
     //Reads three types of file. See below
-    ifstream ifs;
+    istringstream ifs;
 	  stringstream errorMsg;
 
     if (OpenDatafile(ifs, _patternsfile).length() == 0)
@@ -238,8 +238,6 @@
       }
     }while(getline(ifs,line));
 
-    if (ifs)
-      ifs.close();
     return true;
   }
 
@@ -255,7 +253,8 @@
       int num =  ppat->numbits, div = ppat->numoccurrences+1, ngrp;
       while(num) //for each group of bits
       {
-        ngrp = (num + div -1)/div--; //rounds up
+        ngrp = (num + div -1)/div; //rounds up
+        --div;
         num -= ngrp;
         if(GetBit(fp, n) == bSet)
         {
Index: openbabel-src/openbabel/src/forcefields/forcefieldgaff.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/forcefields/forcefieldgaff.cpp b/openbabel-src/openbabel/src/forcefields/forcefieldgaff.cpp
--- a/openbabel-src/openbabel/src/forcefields/forcefieldgaff.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/forcefields/forcefieldgaff.cpp	(date 1696647929177)
@@ -1081,7 +1081,7 @@
     OBFFParameter parameter;
 
     // open data/gaff.dat
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "gaff.dat").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open gaff.dat", obError);
       return false;
@@ -1204,8 +1204,6 @@
 	    ifs.getline(buffer, BUFF_SIZE);
       }
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
@@ -1230,7 +1228,7 @@
     _mol.SetAtomTypesPerceived();
 
     // open data/gaff.prm
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, "gaff.prm").length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open gaff.prm", obError);
       return false;
@@ -1412,8 +1410,6 @@
     }
 
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
Index: opencv-src/opencv/modules/imgproc/src/generalized_hough.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/imgproc/src/generalized_hough.cpp b/opencv-src/opencv/modules/imgproc/src/generalized_hough.cpp
--- a/opencv-src/opencv/modules/imgproc/src/generalized_hough.cpp	(revision 5199850039ad23f1f0e6cccea5061a9fea5efca6)
+++ b/opencv-src/opencv/modules/imgproc/src/generalized_hough.cpp	(date 1701848687873)
@@ -692,7 +692,7 @@
         getContourPoints(edges, dx, dy, points);
 
         features.resize(levels_ + 1);
-        std::for_each(features.begin(), features.end(), [=](std::vector<Feature>& e) { e.clear(); e.reserve(maxBufferSize_); });
+        std::for_each(features.begin(), features.end(), [=, this](std::vector<Feature>& e) { e.clear(); e.reserve(maxBufferSize_); });
 
         for (size_t i = 0; i < points.size(); ++i)
         {
Index: openbabel-src/openbabel/src/forcefields/forcefieldmmff94.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/forcefields/forcefieldmmff94.cpp b/openbabel-src/openbabel/src/forcefields/forcefieldmmff94.cpp
--- a/openbabel-src/openbabel/src/forcefields/forcefieldmmff94.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/forcefields/forcefieldmmff94.cpp	(date 1696647929178)
@@ -874,7 +874,7 @@
     char buffer[80];
 
     // open data/_parFile
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, _parFile).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open parameter file", obError);
       return false;
@@ -913,8 +913,6 @@
         ParseParamVDW(vs[1]);
     }
 
-    if (ifs)
-      ifs.close();
 
     // return the locale to the original one
     obLocale.RestoreLocale();
@@ -929,7 +927,7 @@
     OBFFParameter parameter;
 
     // open data/mmffbond.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffbond.par", obError);
       return false;
@@ -950,8 +948,6 @@
       _ffbondparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -964,7 +960,7 @@
     OBFFParameter parameter;
 
     // open data/mmffbndk.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffbndk.par", obError);
       return false;
@@ -984,8 +980,6 @@
       _ffbndkparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -998,7 +992,7 @@
     OBFFParameter parameter;
 
     // open data/mmffang.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffang.par", obError);
       return false;
@@ -1020,8 +1014,6 @@
       _ffangleparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1034,7 +1026,7 @@
     OBFFParameter parameter;
 
     // open data/mmffstbn.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffstbn.par", obError);
       return false;
@@ -1056,8 +1048,6 @@
       _ffstrbndparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1070,7 +1060,7 @@
     OBFFParameter parameter;
 
     // open data/mmffdfsb.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffdfsb.par", obError);
       return false;
@@ -1091,8 +1081,6 @@
       _ffdfsbparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1105,7 +1093,7 @@
     OBFFParameter parameter;
 
     // open data/mmffoop.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffoop.par", obError);
       return false;
@@ -1126,8 +1114,6 @@
       _ffoopparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1140,7 +1126,7 @@
     OBFFParameter parameter;
 
     // open data/mmfftor.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmfftor.par", obError);
       return false;
@@ -1164,8 +1150,6 @@
       _fftorsionparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1178,7 +1162,7 @@
     OBFFParameter parameter;
 
     // open data/mmffvdw.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffvdw.par", obError);
       return false;
@@ -1205,8 +1189,6 @@
       _ffvdwparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1219,7 +1201,7 @@
     OBFFParameter parameter;
 
     // open data/mmffchg.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffchg.par", obError);
       return false;
@@ -1239,8 +1221,6 @@
       _ffchgparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1253,7 +1233,7 @@
     OBFFParameter parameter;
 
     // open data/mmffpbci.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffpbci", obError);
       return false;
@@ -1272,8 +1252,6 @@
       _ffpbciparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1286,7 +1264,7 @@
     OBFFParameter parameter;
 
     // open data/mmffprop.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffprop.par", obError);
       return false;
@@ -1321,8 +1299,6 @@
       _ffpropparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
@@ -1335,7 +1311,7 @@
     OBFFParameter parameter;
 
     // open data/mmffdef.par
-    ifstream ifs;
+    istringstream ifs;
     if (OpenDatafile(ifs, filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, "Cannot open mmffdef.par", obError);
       return false;
@@ -1356,8 +1332,6 @@
       _ffdefparams.push_back(parameter);
     }
 
-    if (ifs)
-      ifs.close();
 
     return 0;
   }
Index: opencv-src/opencv/modules/imgproc/src/spatialgradient.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/imgproc/src/spatialgradient.cpp b/opencv-src/opencv/modules/imgproc/src/spatialgradient.cpp
--- a/opencv-src/opencv/modules/imgproc/src/spatialgradient.cpp	(revision 5199850039ad23f1f0e6cccea5061a9fea5efca6)
+++ b/opencv-src/opencv/modules/imgproc/src/spatialgradient.cpp	(date 1701848687873)
@@ -58,7 +58,14 @@
  *           1  2  1
  */
 template <typename T>
-static inline void spatialGradientKernel( T& vx, T& vy,
+    static
+#if _MSC_VER >= 1930 && _MSC_VER < 1940 // FIXME: MSVC 2022, static build, got fatal error C1001
+    __declspec(noinline)
+#else
+    inline
+#endif
+    void spatialGradientKernel( T& vx, T& vy,
+
                                           const T& v00, const T& v01, const T& v02,
                                           const T& v10,               const T& v12,
                                           const T& v20, const T& v21, const T& v22 )
Index: openbabel-src/openbabel/src/descriptors/groupcontrib.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/src/descriptors/groupcontrib.cpp b/openbabel-src/openbabel/src/descriptors/groupcontrib.cpp
--- a/openbabel-src/openbabel/src/descriptors/groupcontrib.cpp	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/src/descriptors/groupcontrib.cpp	(date 1696647929175)
@@ -55,7 +55,7 @@
     OBSmartsPattern *sp;
 
     // open data file
-    ifstream ifs;
+    istringstream ifs;
 
     if (OpenDatafile(ifs, _filename).length() == 0) {
       obErrorLog.ThrowError(__FUNCTION__, " Could not find contribution data file.", obError);
Index: inchi-src/inchi/INCHI_BASE/src/runichi.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_BASE/src/runichi.c b/inchi-src/inchi/INCHI_BASE/src/runichi.c
--- a/inchi-src/inchi/INCHI_BASE/src/runichi.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_BASE/src/runichi.c	(date 1696647928660)
@@ -3083,7 +3083,9 @@
         (i.e., delete a whole connected component(s) comprising original atoms)
         */
         int natnums = 0;
-        atnums = (int *)inchi_calloc(max_atoms, sizeof(int));
+        if (max_atoms > 0) {
+            atnums = (int *) inchi_calloc(max_atoms, sizeof(int));
+        }
         if (!atnums)
         {
             return _IS_ERROR;
Index: boost-src/boost/libs/stacktrace/src/noop.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/stacktrace/src/noop.cpp b/boost-src/boost/libs/stacktrace/src/noop.cpp
--- a/boost-src/boost/libs/stacktrace/src/noop.cpp	(revision c6e771286801ca7f5f58b3d6a812b95b85e71bc0)
+++ b/boost-src/boost/libs/stacktrace/src/noop.cpp	(date 1696647928227)
@@ -6,6 +6,8 @@
 
 #define BOOST_STACKTRACE_INTERNAL_BUILD_LIBS
 #define BOOST_STACKTRACE_LINK
+#ifndef BOOST_STACKTRACE_USE_NOOP
 #define BOOST_STACKTRACE_USE_NOOP
+#endif
 #include <boost/stacktrace/detail/frame_noop.ipp>
 #include <boost/stacktrace/detail/safe_dump_noop.ipp>
Index: inchi-src/inchi/INCHI_BASE/src/ichicomp.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_BASE/src/ichicomp.h b/inchi-src/inchi/INCHI_BASE/src/ichicomp.h
--- a/inchi-src/inchi/INCHI_BASE/src/ichicomp.h	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_BASE/src/ichicomp.h	(date 1696647928645)
@@ -54,9 +54,6 @@
 
 /*  ANSI redefinitions */
 #ifdef COMPILE_ANSI_ONLY  /* { */
-#ifndef __isascii
-#define __isascii(val)  ((unsigned)(val) <= 0x7F)
-#endif
 
 /* #ifndef __GNUC__ */
 /* these non-ANSI functions are implemented in gcc */
Index: openbabel-src/openbabel/data/gaff.prm
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/data/gaff.prm b/openbabel-src/openbabel/data/gaff.prm
--- a/openbabel-src/openbabel/data/gaff.prm	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/data/gaff.prm	(date 1696647929152)
@@ -91,7 +91,7 @@
 atom [#6X3;R](=*)-*=*   						    ca "sp2 C in aromatic ring"
 atom [#6X3;R](=[#6X3])([#6])[#1]					    ca "sp2 C in aromatic ring"	
 atom [#6X3;R](=[#6])([#6])[F,Cl,Br,I]   				    c2 "sp2 C in a ring with 1 electron-withdrawal group"
-atom [#6X3;R](=[#6X3])([#6X4])[#6]					    c2 "sp2 C in a ring"		
+atom [#6X3;R](=[#6X3])([#6X4])[#6]					    c2 "sp2 C in a ring"
 atom [#6X3;R](=*)-*#*   						    cc "sp2 C in a conjugated ring"
 atom [#6X3;R](#*)-*#*   						    cc "sp2 C in a conjugated ring"
 atom [#6X3;R]:[#7,#8,#16]     	     	      				    cc "sp2 C in a ring with 1 electron-withdrawal group"
Index: inchi-src/inchi/INCHI_BASE/src/ichicano.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_BASE/src/ichicano.c b/inchi-src/inchi/INCHI_BASE/src/ichicano.c
--- a/inchi-src/inchi/INCHI_BASE/src/ichicano.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_BASE/src/ichicano.c	(date 1696647928644)
@@ -37,7 +37,6 @@
 #include <string.h>
 #include <ctype.h>
 #include <time.h>
-#include <sys/timeb.h>
 
 #include "mode.h"
 #include "ichicano.h"
Index: inchi-src/inchi/INCHI_BASE/src/inchi_api.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_BASE/src/inchi_api.h b/inchi-src/inchi/INCHI_BASE/src/inchi_api.h
--- a/inchi-src/inchi/INCHI_BASE/src/inchi_api.h	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_BASE/src/inchi_api.h	(date 1696647928657)
@@ -681,23 +681,17 @@
  *************************************************/
 
 
-#if (defined( _WIN32 ) && defined( _MSC_VER ) && defined(BUILD_LINK_AS_DLL) )
-    /* Win32 & MS VC ++, compile and link as a DLL */
-#ifdef _USRDLL
-    /* InChI library dll */
-#define INCHI_API __declspec(dllexport)
-#define EXPIMP_TEMPLATE
-#define INCHI_DECL
-#else
-   /* calling the InChI dll program */
-#define INCHI_API __declspec(dllimport)
+#include "inchi_export.h"
+
+#ifdef _MSC_VER
 #define EXPIMP_TEMPLATE extern
-#define INCHI_DECL
-#endif
 #else
-    /* create a statically linked InChI library or link to an executable */
-#define INCHI_API
 #define EXPIMP_TEMPLATE
+#endif
+#ifndef INCHI_API
+#define INCHI_API INCHI_EXPORT
+#endif
+#ifndef INCHI_DECL
 #define INCHI_DECL
 #endif
 
Index: openbabel-src/openbabel/data/patty.rules
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/data/patty.rules b/openbabel-src/openbabel/data/patty.rules
--- a/openbabel-src/openbabel/data/patty.rules	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/data/patty.rules	(date 1696647929154)
@@ -133,7 +133,7 @@
 # diaminopyrimidine (ring Ns are POL)
 #
 #        *==*
-#       /    \  
+#       /    \
 #     :N      C--NH2            (aromatic)
 #      \\    #  
 #        C--N:
@@ -186,7 +186,7 @@
 [#8,#16,#34;D1]C=[#8,#16,#34]           ANI
 [#8,#16,#34]=C[#8,#16,#34;D1]           ANI
 #        *==*
-#       /    \  
+#       /    \
 #      *      C==O              (aromatic)
 #      \\    /
 #        C--C                   And 4 Cs away
Index: inchi-src/inchi/INCHI_BASE/src/util.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/inchi-src/inchi/INCHI_BASE/src/util.c b/inchi-src/inchi/INCHI_BASE/src/util.c
--- a/inchi-src/inchi/INCHI_BASE/src/util.c	(revision 0fc7adc58d4ff1c481b26e0de53cc8a404c3d381)
+++ b/inchi-src/inchi/INCHI_BASE/src/util.c	(date 1696647928662)
@@ -38,10 +38,6 @@
 
 #include "mode.h"
 
-#if defined(COMPILE_ANSI_ONLY) && defined(__APPLE__)
-/*    For build under OSX, advice from Burt Leland */
-#include "ichicomp.h"    /* Needed for __isascii define */
-#endif
 
 #include "util.h"
 #include "extr_ct.h"
@@ -1741,13 +1737,13 @@
 
     if (p && ( len = (int) strlen( p ) ))
     {
-        for (i = 0; i < len && __isascii( p[i] ) && isspace( p[i] ); i++)
+        for (i = 0; i < len && isascii( p[i] ) && isspace( p[i] ); i++)
         {
             ;
         }
         if (i)
             (memmove) ( p, p + i, ( len -= i ) + 1 );
-        for (; 0 < len && __isascii( p[len - 1] ) && isspace( p[len - 1] ); len--)
+        for (; 0 < len && isascii( p[len - 1] ) && isspace( p[len - 1] ); len--)
         {
             ;
         }
Index: openbabel-src/openbabel/include/RDKitConv.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/RDKitConv.h b/openbabel-src/openbabel/include/RDKitConv.h
--- a/openbabel-src/openbabel/include/RDKitConv.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/RDKitConv.h	(date 1696647929163)
@@ -1,7 +1,7 @@
 #include <openbabel/mol.h>
 #include <openbabel/obiter.h>
-#include <graphmol/RWMol.h>
-#include <graphmol/Atom.h>
+#include <GraphMol/RWMol.h>
+#include <GraphMol/Atom.h>
 
 ///Convert OpenBabel OBMol to and from RGKit molecules
 RDKit::RWMol OBMolToRWMol(OpenBabel::OBMol* pOBMol);
Index: quickjs-src/quickjs/src/libregexp-opcode.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/src/libregexp-opcode.h b/quickjs-src/quickjs/src/libregexp-opcode.h
new file mode 100644
--- /dev/null	(date 1696647929598)
+++ b/quickjs-src/quickjs/src/libregexp-opcode.h	(date 1696647929598)
@@ -0,0 +1,58 @@
+/*
+ * Regular Expression Engine
+ * 
+ * Copyright (c) 2017-2018 Fabrice Bellard
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#ifdef DEF
+
+DEF(invalid, 1) /* never used */
+DEF(char, 3)
+DEF(char32, 5)
+DEF(dot, 1)
+DEF(any, 1) /* same as dot but match any character including line terminator */
+DEF(line_start, 1)
+DEF(line_end, 1)
+DEF(goto, 5)
+DEF(split_goto_first, 5)
+DEF(split_next_first, 5)
+DEF(match, 1)
+DEF(save_start, 2) /* save start position */
+DEF(save_end, 2) /* save end position, must come after saved_start */
+DEF(save_reset, 3) /* reset save positions */
+DEF(loop, 5) /* decrement the top the stack and goto if != 0 */
+DEF(push_i32, 5) /* push integer on the stack */
+DEF(drop, 1)
+DEF(word_boundary, 1)
+DEF(not_word_boundary, 1)
+DEF(back_reference, 2)
+DEF(backward_back_reference, 2) /* must come after back_reference */
+DEF(range, 3) /* variable length */
+DEF(range32, 3) /* variable length */
+DEF(lookahead, 5)
+DEF(negative_lookahead, 5)
+DEF(push_char_pos, 1) /* push the character position on the stack */
+DEF(bne_char_pos, 5) /* pop one stack element and jump if equal to the character
+ position */
+DEF(prev, 1) /* go to the previous char */
+DEF(simple_greedy_quant, 17)
+
+#endif /* DEF */
Index: quickjs-src/quickjs/libunicode.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/libunicode.c b/quickjs-src/quickjs/src/libunicode.c
rename from quickjs-src/quickjs/libunicode.c
rename to quickjs-src/quickjs/src/libunicode.c
--- a/quickjs-src/quickjs/libunicode.c	(revision 321dbfa770463b8867d8ac90493c7cec015a9c3a)
+++ b/quickjs-src/quickjs/src/libunicode.c	(date 1696647929599)
@@ -159,7 +159,7 @@
 
 static uint32_t get_le24(const uint8_t *ptr)
 {
-#if defined(__x86__) || defined(__x86_64__)
+#if defined(__x86__) || defined(__x86_64__) || defined(PLATFORM_IS_64BIT)
     return *(uint16_t *)ptr | (ptr[2] << 16);
 #else
     return ptr[0] | (ptr[1] << 8) | (ptr[2] << 16);
Index: quickjs-src/quickjs/src/quickjs-opcode.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/src/quickjs-opcode.h b/quickjs-src/quickjs/src/quickjs-opcode.h
new file mode 100644
--- /dev/null	(date 1696647929600)
+++ b/quickjs-src/quickjs/src/quickjs-opcode.h	(date 1696647929600)
@@ -0,0 +1,365 @@
+/*
+ * QuickJS opcode definitions
+ * 
+ * Copyright (c) 2017-2018 Fabrice Bellard
+ * Copyright (c) 2017-2018 Charlie Gordon
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#ifdef FMT
+FMT(none)
+FMT(none_int)
+FMT(none_loc)
+FMT(none_arg)
+FMT(none_var_ref)
+FMT(u8)
+FMT(i8)
+FMT(loc8)
+FMT(const8)
+FMT(label8)
+FMT(u16)
+FMT(i16)
+FMT(label16)
+FMT(npop)
+FMT(npopx)
+FMT(npop_u16)
+FMT(loc)
+FMT(arg)
+FMT(var_ref)
+FMT(u32)
+FMT(i32)
+FMT(const)
+FMT(label)
+FMT(atom)
+FMT(atom_u8)
+FMT(atom_u16)
+FMT(atom_label_u8)
+FMT(atom_label_u16)
+FMT(label_u16)
+#undef FMT
+#endif /* FMT */
+
+#ifdef DEF
+
+#ifndef def
+#define def(id, size, n_pop, n_push, f) DEF(id, size, n_pop, n_push, f)
+#endif
+
+DEF(invalid, 1, 0, 0, none) /* never emitted */
+
+/* push values */
+DEF(       push_i32, 5, 0, 1, i32)
+DEF(     push_const, 5, 0, 1, const)
+DEF(       fclosure, 5, 0, 1, const) /* must follow push_const */
+DEF(push_atom_value, 5, 0, 1, atom)
+DEF( private_symbol, 5, 0, 1, atom)
+DEF(      undefined, 1, 0, 1, none)
+DEF(           null, 1, 0, 1, none)
+DEF(      push_this, 1, 0, 1, none) /* only used at the start of a function */
+DEF(     push_false, 1, 0, 1, none)
+DEF(      push_true, 1, 0, 1, none)
+DEF(         object, 1, 0, 1, none)
+DEF( special_object, 2, 0, 1, u8) /* only used at the start of a function */
+DEF(           rest, 3, 0, 1, u16) /* only used at the start of a function */
+
+DEF(           drop, 1, 1, 0, none) /* a -> */
+DEF(            nip, 1, 2, 1, none) /* a b -> b */
+DEF(           nip1, 1, 3, 2, none) /* a b c -> b c */
+DEF(            dup, 1, 1, 2, none) /* a -> a a */
+DEF(           dup1, 1, 2, 3, none) /* a b -> a a b */
+DEF(           dup2, 1, 2, 4, none) /* a b -> a b a b */
+DEF(           dup3, 1, 3, 6, none) /* a b c -> a b c a b c */
+DEF(        insert2, 1, 2, 3, none) /* obj a -> a obj a (dup_x1) */
+DEF(        insert3, 1, 3, 4, none) /* obj prop a -> a obj prop a (dup_x2) */
+DEF(        insert4, 1, 4, 5, none) /* this obj prop a -> a this obj prop a */
+DEF(          perm3, 1, 3, 3, none) /* obj a b -> a obj b */
+DEF(          perm4, 1, 4, 4, none) /* obj prop a b -> a obj prop b */
+DEF(          perm5, 1, 5, 5, none) /* this obj prop a b -> a this obj prop b */
+DEF(           swap, 1, 2, 2, none) /* a b -> b a */
+DEF(          swap2, 1, 4, 4, none) /* a b c d -> c d a b */
+DEF(          rot3l, 1, 3, 3, none) /* x a b -> a b x */
+DEF(          rot3r, 1, 3, 3, none) /* a b x -> x a b */
+DEF(          rot4l, 1, 4, 4, none) /* x a b c -> a b c x */
+DEF(          rot5l, 1, 5, 5, none) /* x a b c d -> a b c d x */
+
+DEF(call_constructor, 3, 2, 1, npop) /* func new.target args -> ret. arguments are not counted in n_pop */
+DEF(           call, 3, 1, 1, npop) /* arguments are not counted in n_pop */
+DEF(      tail_call, 3, 1, 0, npop) /* arguments are not counted in n_pop */
+DEF(    call_method, 3, 2, 1, npop) /* arguments are not counted in n_pop */
+DEF(tail_call_method, 3, 2, 0, npop) /* arguments are not counted in n_pop */
+DEF(     array_from, 3, 0, 1, npop) /* arguments are not counted in n_pop */
+DEF(          apply, 3, 3, 1, u16)
+DEF(         return, 1, 1, 0, none)
+DEF(   return_undef, 1, 0, 0, none)
+DEF(check_ctor_return, 1, 1, 2, none)
+DEF(     check_ctor, 1, 0, 0, none)
+DEF(    check_brand, 1, 2, 2, none) /* this_obj func -> this_obj func */
+DEF(      add_brand, 1, 2, 0, none) /* this_obj home_obj -> */
+DEF(   return_async, 1, 1, 0, none)
+DEF(          throw, 1, 1, 0, none)
+DEF(    throw_error, 6, 0, 0, atom_u8)
+DEF(           eval, 5, 1, 1, npop_u16) /* func args... -> ret_val */
+DEF(     apply_eval, 3, 2, 1, u16) /* func array -> ret_eval */
+DEF(         regexp, 1, 2, 1, none) /* create a RegExp object from the pattern and a
+                                       bytecode string */
+DEF(      get_super, 1, 1, 1, none)
+DEF(         import, 1, 1, 1, none) /* dynamic module import */
+
+DEF(      check_var, 5, 0, 1, atom) /* check if a variable exists */
+DEF(  get_var_undef, 5, 0, 1, atom) /* push undefined if the variable does not exist */
+DEF(        get_var, 5, 0, 1, atom) /* throw an exception if the variable does not exist */
+DEF(        put_var, 5, 1, 0, atom) /* must come after get_var */
+DEF(   put_var_init, 5, 1, 0, atom) /* must come after put_var. Used to initialize a global lexical variable */
+DEF( put_var_strict, 5, 2, 0, atom) /* for strict mode variable write */
+
+DEF(  get_ref_value, 1, 2, 3, none)
+DEF(  put_ref_value, 1, 3, 0, none)
+
+DEF(     define_var, 6, 0, 0, atom_u8)
+DEF(check_define_var, 6, 0, 0, atom_u8)
+DEF(    define_func, 6, 1, 0, atom_u8)
+DEF(      get_field, 5, 1, 1, atom)
+DEF(     get_field2, 5, 1, 2, atom)
+DEF(      put_field, 5, 2, 0, atom)
+DEF( get_private_field, 1, 2, 1, none) /* obj prop -> value */
+DEF( put_private_field, 1, 3, 0, none) /* obj value prop -> */
+DEF(define_private_field, 1, 3, 1, none) /* obj prop value -> obj */
+DEF(   get_array_el, 1, 2, 1, none)
+DEF(  get_array_el2, 1, 2, 2, none) /* obj prop -> obj value */
+DEF(   put_array_el, 1, 3, 0, none)
+DEF(get_super_value, 1, 3, 1, none) /* this obj prop -> value */
+DEF(put_super_value, 1, 4, 0, none) /* this obj prop value -> */
+DEF(   define_field, 5, 2, 1, atom)
+DEF(       set_name, 5, 1, 1, atom)
+DEF(set_name_computed, 1, 2, 2, none)
+DEF(      set_proto, 1, 2, 1, none)
+DEF(set_home_object, 1, 2, 2, none)
+DEF(define_array_el, 1, 3, 2, none)
+DEF(         append, 1, 3, 2, none) /* append enumerated object, update length */
+DEF(copy_data_properties, 2, 3, 3, u8)
+DEF(  define_method, 6, 2, 1, atom_u8)
+DEF(define_method_computed, 2, 3, 1, u8) /* must come after define_method */
+DEF(   define_class, 6, 2, 2, atom_u8) /* parent ctor -> ctor proto */
+DEF(   define_class_computed, 6, 3, 3, atom_u8) /* field_name parent ctor -> field_name ctor proto (class with computed name) */
+
+DEF(        get_loc, 3, 0, 1, loc)
+DEF(        put_loc, 3, 1, 0, loc) /* must come after get_loc */
+DEF(        set_loc, 3, 1, 1, loc) /* must come after put_loc */
+DEF(        get_arg, 3, 0, 1, arg)
+DEF(        put_arg, 3, 1, 0, arg) /* must come after get_arg */
+DEF(        set_arg, 3, 1, 1, arg) /* must come after put_arg */
+DEF(    get_var_ref, 3, 0, 1, var_ref) 
+DEF(    put_var_ref, 3, 1, 0, var_ref) /* must come after get_var_ref */
+DEF(    set_var_ref, 3, 1, 1, var_ref) /* must come after put_var_ref */
+DEF(set_loc_uninitialized, 3, 0, 0, loc)
+DEF(  get_loc_check, 3, 0, 1, loc)
+DEF(  put_loc_check, 3, 1, 0, loc) /* must come after get_loc_check */
+DEF(  put_loc_check_init, 3, 1, 0, loc)
+DEF(get_var_ref_check, 3, 0, 1, var_ref) 
+DEF(put_var_ref_check, 3, 1, 0, var_ref) /* must come after get_var_ref_check */
+DEF(put_var_ref_check_init, 3, 1, 0, var_ref)
+DEF(      close_loc, 3, 0, 0, loc)
+DEF(       if_false, 5, 1, 0, label)
+DEF(        if_true, 5, 1, 0, label) /* must come after if_false */
+DEF(           goto, 5, 0, 0, label) /* must come after if_true */
+DEF(          catch, 5, 0, 1, label)
+DEF(          gosub, 5, 0, 0, label) /* used to execute the finally block */
+DEF(            ret, 1, 1, 0, none) /* used to return from the finally block */
+
+DEF(      to_object, 1, 1, 1, none)
+//DEF(      to_string, 1, 1, 1, none)
+DEF(     to_propkey, 1, 1, 1, none)
+DEF(    to_propkey2, 1, 2, 2, none)
+
+DEF(   with_get_var, 10, 1, 0, atom_label_u8)     /* must be in the same order as scope_xxx */
+DEF(   with_put_var, 10, 2, 1, atom_label_u8)     /* must be in the same order as scope_xxx */
+DEF(with_delete_var, 10, 1, 0, atom_label_u8)     /* must be in the same order as scope_xxx */
+DEF(  with_make_ref, 10, 1, 0, atom_label_u8)     /* must be in the same order as scope_xxx */
+DEF(   with_get_ref, 10, 1, 0, atom_label_u8)     /* must be in the same order as scope_xxx */
+DEF(with_get_ref_undef, 10, 1, 0, atom_label_u8)
+
+DEF(   make_loc_ref, 7, 0, 2, atom_u16)
+DEF(   make_arg_ref, 7, 0, 2, atom_u16)
+DEF(make_var_ref_ref, 7, 0, 2, atom_u16)
+DEF(   make_var_ref, 5, 0, 2, atom)
+
+DEF(   for_in_start, 1, 1, 1, none)
+DEF(   for_of_start, 1, 1, 3, none)
+DEF(for_await_of_start, 1, 1, 3, none)
+DEF(    for_in_next, 1, 1, 3, none)
+DEF(    for_of_next, 2, 3, 5, u8)
+DEF(iterator_check_object, 1, 1, 1, none)
+DEF(iterator_get_value_done, 1, 1, 2, none)
+DEF( iterator_close, 1, 3, 0, none)
+DEF(iterator_close_return, 1, 4, 4, none)
+DEF(  iterator_next, 1, 4, 4, none)
+DEF(  iterator_call, 2, 4, 5, u8)
+DEF(  initial_yield, 1, 0, 0, none)
+DEF(          yield, 1, 1, 2, none)
+DEF(     yield_star, 1, 1, 2, none)
+DEF(async_yield_star, 1, 1, 2, none)
+DEF(          await, 1, 1, 1, none)
+
+/* arithmetic/logic operations */
+DEF(            neg, 1, 1, 1, none)
+DEF(           plus, 1, 1, 1, none)
+DEF(            dec, 1, 1, 1, none)
+DEF(            inc, 1, 1, 1, none)
+DEF(       post_dec, 1, 1, 2, none)
+DEF(       post_inc, 1, 1, 2, none)
+DEF(        dec_loc, 2, 0, 0, loc8)
+DEF(        inc_loc, 2, 0, 0, loc8)
+DEF(        add_loc, 2, 1, 0, loc8)
+DEF(            not, 1, 1, 1, none)
+DEF(           lnot, 1, 1, 1, none)
+DEF(         typeof, 1, 1, 1, none)
+DEF(         delete, 1, 2, 1, none)
+DEF(     delete_var, 5, 0, 1, atom)
+
+DEF(            mul, 1, 2, 1, none)
+DEF(            div, 1, 2, 1, none)
+DEF(            mod, 1, 2, 1, none)
+DEF(            add, 1, 2, 1, none)
+DEF(            sub, 1, 2, 1, none)
+DEF(            pow, 1, 2, 1, none)
+DEF(            shl, 1, 2, 1, none)
+DEF(            sar, 1, 2, 1, none)
+DEF(            shr, 1, 2, 1, none)
+DEF(             lt, 1, 2, 1, none)
+DEF(            lte, 1, 2, 1, none)
+DEF(             gt, 1, 2, 1, none)
+DEF(            gte, 1, 2, 1, none)
+DEF(     instanceof, 1, 2, 1, none)
+DEF(             in, 1, 2, 1, none)
+DEF(             eq, 1, 2, 1, none)
+DEF(            neq, 1, 2, 1, none)
+DEF(      strict_eq, 1, 2, 1, none)
+DEF(     strict_neq, 1, 2, 1, none)
+DEF(            and, 1, 2, 1, none)
+DEF(            xor, 1, 2, 1, none)
+DEF(             or, 1, 2, 1, none)
+DEF(is_undefined_or_null, 1, 1, 1, none)
+#ifdef CONFIG_BIGNUM
+DEF(      mul_pow10, 1, 2, 1, none)
+DEF(       math_mod, 1, 2, 1, none)
+#endif
+/* must be the last non short and non temporary opcode */
+DEF(            nop, 1, 0, 0, none) 
+
+/* temporary opcodes: never emitted in the final bytecode */
+
+def(    enter_scope, 3, 0, 0, u16)  /* emitted in phase 1, removed in phase 2 */
+def(    leave_scope, 3, 0, 0, u16)  /* emitted in phase 1, removed in phase 2 */
+
+def(          label, 5, 0, 0, label) /* emitted in phase 1, removed in phase 3 */
+
+def(scope_get_var_undef, 7, 0, 1, atom_u16) /* emitted in phase 1, removed in phase 2 */
+def(  scope_get_var, 7, 0, 1, atom_u16) /* emitted in phase 1, removed in phase 2 */
+def(  scope_put_var, 7, 1, 0, atom_u16) /* emitted in phase 1, removed in phase 2 */
+def(scope_delete_var, 7, 0, 1, atom_u16) /* emitted in phase 1, removed in phase 2 */
+def( scope_make_ref, 11, 0, 2, atom_label_u16) /* emitted in phase 1, removed in phase 2 */
+def(  scope_get_ref, 7, 0, 2, atom_u16) /* emitted in phase 1, removed in phase 2 */
+def(scope_put_var_init, 7, 0, 2, atom_u16) /* emitted in phase 1, removed in phase 2 */
+def(scope_get_private_field, 7, 1, 1, atom_u16) /* obj -> value, emitted in phase 1, removed in phase 2 */
+def(scope_get_private_field2, 7, 1, 2, atom_u16) /* obj -> obj value, emitted in phase 1, removed in phase 2 */
+def(scope_put_private_field, 7, 1, 1, atom_u16) /* obj value ->, emitted in phase 1, removed in phase 2 */
+
+def( set_class_name, 5, 1, 1, u32) /* emitted in phase 1, removed in phase 2 */
+    
+def(       line_num, 5, 0, 0, u32) /* emitted in phase 1, removed in phase 3 */
+
+#if SHORT_OPCODES
+DEF(    push_minus1, 1, 0, 1, none_int)
+DEF(         push_0, 1, 0, 1, none_int)
+DEF(         push_1, 1, 0, 1, none_int)
+DEF(         push_2, 1, 0, 1, none_int)
+DEF(         push_3, 1, 0, 1, none_int)
+DEF(         push_4, 1, 0, 1, none_int)
+DEF(         push_5, 1, 0, 1, none_int)
+DEF(         push_6, 1, 0, 1, none_int)
+DEF(         push_7, 1, 0, 1, none_int)
+DEF(        push_i8, 2, 0, 1, i8)
+DEF(       push_i16, 3, 0, 1, i16)
+DEF(    push_const8, 2, 0, 1, const8)
+DEF(      fclosure8, 2, 0, 1, const8) /* must follow push_const8 */
+DEF(push_empty_string, 1, 0, 1, none)
+
+DEF(       get_loc8, 2, 0, 1, loc8)
+DEF(       put_loc8, 2, 1, 0, loc8)
+DEF(       set_loc8, 2, 1, 1, loc8)
+
+DEF(       get_loc0, 1, 0, 1, none_loc)
+DEF(       get_loc1, 1, 0, 1, none_loc)
+DEF(       get_loc2, 1, 0, 1, none_loc)
+DEF(       get_loc3, 1, 0, 1, none_loc)
+DEF(       put_loc0, 1, 1, 0, none_loc)
+DEF(       put_loc1, 1, 1, 0, none_loc)
+DEF(       put_loc2, 1, 1, 0, none_loc)
+DEF(       put_loc3, 1, 1, 0, none_loc)
+DEF(       set_loc0, 1, 1, 1, none_loc)
+DEF(       set_loc1, 1, 1, 1, none_loc)
+DEF(       set_loc2, 1, 1, 1, none_loc)
+DEF(       set_loc3, 1, 1, 1, none_loc)
+DEF(       get_arg0, 1, 0, 1, none_arg)
+DEF(       get_arg1, 1, 0, 1, none_arg)
+DEF(       get_arg2, 1, 0, 1, none_arg)
+DEF(       get_arg3, 1, 0, 1, none_arg)
+DEF(       put_arg0, 1, 1, 0, none_arg)
+DEF(       put_arg1, 1, 1, 0, none_arg)
+DEF(       put_arg2, 1, 1, 0, none_arg)
+DEF(       put_arg3, 1, 1, 0, none_arg)
+DEF(       set_arg0, 1, 1, 1, none_arg)
+DEF(       set_arg1, 1, 1, 1, none_arg)
+DEF(       set_arg2, 1, 1, 1, none_arg)
+DEF(       set_arg3, 1, 1, 1, none_arg)
+DEF(   get_var_ref0, 1, 0, 1, none_var_ref)
+DEF(   get_var_ref1, 1, 0, 1, none_var_ref)
+DEF(   get_var_ref2, 1, 0, 1, none_var_ref)
+DEF(   get_var_ref3, 1, 0, 1, none_var_ref)
+DEF(   put_var_ref0, 1, 1, 0, none_var_ref)
+DEF(   put_var_ref1, 1, 1, 0, none_var_ref)
+DEF(   put_var_ref2, 1, 1, 0, none_var_ref)
+DEF(   put_var_ref3, 1, 1, 0, none_var_ref)
+DEF(   set_var_ref0, 1, 1, 1, none_var_ref)
+DEF(   set_var_ref1, 1, 1, 1, none_var_ref)
+DEF(   set_var_ref2, 1, 1, 1, none_var_ref)
+DEF(   set_var_ref3, 1, 1, 1, none_var_ref)
+
+DEF(     get_length, 1, 1, 1, none)
+
+DEF(      if_false8, 2, 1, 0, label8)
+DEF(       if_true8, 2, 1, 0, label8) /* must come after if_false8 */
+DEF(          goto8, 2, 0, 0, label8) /* must come after if_true8 */
+DEF(         goto16, 3, 0, 0, label16)
+
+DEF(          call0, 1, 1, 1, npopx)
+DEF(          call1, 1, 1, 1, npopx)
+DEF(          call2, 1, 1, 1, npopx)
+DEF(          call3, 1, 1, 1, npopx)
+
+DEF(   is_undefined, 1, 1, 1, none)
+DEF(        is_null, 1, 1, 1, none)
+DEF(typeof_is_undefined, 1, 1, 1, none)
+DEF( typeof_is_function, 1, 1, 1, none)
+#endif
+
+#undef DEF
+#undef def
+#endif  /* DEF */
Index: quickjs-src/quickjs/quickjs-libc.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/quickjs-libc.c b/quickjs-src/quickjs/src/quickjs-libc.c
rename from quickjs-src/quickjs/quickjs-libc.c
rename to quickjs-src/quickjs/src/quickjs-libc.c
--- a/quickjs-src/quickjs/quickjs-libc.c	(revision 321dbfa770463b8867d8ac90493c7cec015a9c3a)
+++ b/quickjs-src/quickjs/src/quickjs-libc.c	(date 1696647929600)
@@ -28,43 +28,29 @@
 #include <inttypes.h>
 #include <string.h>
 #include <assert.h>
-#include <unistd.h>
 #include <errno.h>
 #include <fcntl.h>
-#include <sys/time.h>
 #include <time.h>
 #include <signal.h>
 #include <limits.h>
 #include <sys/stat.h>
-#include <dirent.h>
 #if defined(_WIN32)
 #include <windows.h>
 #include <conio.h>
-#include <utime.h>
+#ifndef PATH_MAX
+#define PATH_MAX MAX_PATH
+#endif
 #else
+#include <unistd.h>
+#include <dirent.h>
 #include <dlfcn.h>
 #include <termios.h>
 #include <sys/ioctl.h>
+#include <sys/time.h>
 #include <sys/wait.h>
-
 #if defined(__APPLE__)
 typedef sig_t sighandler_t;
-#if !defined(environ)
-#include <crt_externs.h>
-#define environ (*_NSGetEnviron())
-#endif
-#endif /* __APPLE__ */
-
-#endif
-
-#if !defined(_WIN32)
-/* enable the os.Worker API. IT relies on POSIX threads */
-#define USE_WORKER
 #endif
-
-#ifdef USE_WORKER
-#include <pthread.h>
-#include <stdatomic.h>
 #endif
 
 #include "cutils.h"
@@ -452,65 +438,6 @@
 typedef JSModuleDef *(JSInitModuleFunc)(JSContext *ctx,
                                         const char *module_name);
 
-
-#if defined(_WIN32)
-static JSModuleDef *js_module_loader_so(JSContext *ctx,
-                                        const char *module_name)
-{
-    JS_ThrowReferenceError(ctx, "shared library modules are not supported yet");
-    return NULL;
-}
-#else
-static JSModuleDef *js_module_loader_so(JSContext *ctx,
-                                        const char *module_name)
-{
-    JSModuleDef *m;
-    void *hd;
-    JSInitModuleFunc *init;
-    char *filename;
-    
-    if (!strchr(module_name, '/')) {
-        /* must add a '/' so that the DLL is not searched in the
-           system library paths */
-        filename = js_malloc(ctx, strlen(module_name) + 2 + 1);
-        if (!filename)
-            return NULL;
-        strcpy(filename, "./");
-        strcpy(filename + 2, module_name);
-    } else {
-        filename = (char *)module_name;
-    }
-    
-    /* C module */
-    hd = dlopen(filename, RTLD_NOW | RTLD_LOCAL);
-    if (filename != module_name)
-        js_free(ctx, filename);
-    if (!hd) {
-        JS_ThrowReferenceError(ctx, "could not load module filename '%s' as shared library",
-                               module_name);
-        goto fail;
-    }
-
-    init = dlsym(hd, "js_init_module");
-    if (!init) {
-        JS_ThrowReferenceError(ctx, "could not load module filename '%s': js_init_module not found",
-                               module_name);
-        goto fail;
-    }
-
-    m = init(ctx, module_name);
-    if (!m) {
-        JS_ThrowReferenceError(ctx, "could not load module filename '%s': initialization error",
-                               module_name);
-    fail:
-        if (hd)
-            dlclose(hd);
-        return NULL;
-    }
-    return m;
-}
-#endif /* !_WIN32 */
-
 int js_module_set_import_meta(JSContext *ctx, JSValueConst func_val,
                               JS_BOOL use_realpath, JS_BOOL is_main)
 {
@@ -564,40 +491,6 @@
     return 0;
 }
 
-JSModuleDef *js_module_loader(JSContext *ctx,
-                              const char *module_name, void *opaque)
-{
-    JSModuleDef *m;
-
-    if (has_suffix(module_name, ".so")) {
-        m = js_module_loader_so(ctx, module_name);
-    } else {
-        size_t buf_len;
-        uint8_t *buf;
-        JSValue func_val;
-    
-        buf = js_load_file(ctx, &buf_len, module_name);
-        if (!buf) {
-            JS_ThrowReferenceError(ctx, "could not load module filename '%s'",
-                                   module_name);
-            return NULL;
-        }
-        
-        /* compile the module */
-        func_val = JS_Eval(ctx, (char *)buf, buf_len, module_name,
-                           JS_EVAL_TYPE_MODULE | JS_EVAL_FLAG_COMPILE_ONLY);
-        js_free(ctx, buf);
-        if (JS_IsException(func_val))
-            return NULL;
-        /* XXX: could propagate the exception */
-        js_module_set_import_meta(ctx, func_val, TRUE, FALSE);
-        /* the module is already referenced, so we must free it */
-        m = JS_VALUE_GET_PTR(func_val);
-        JS_FreeValue(ctx, func_val);
-    }
-    return m;
-}
-
 static JSValue js_std_exit(JSContext *ctx, JSValueConst this_val,
                            int argc, JSValueConst *argv)
 {
@@ -675,45 +568,6 @@
     return JS_UNDEFINED;
 }
 
-/* return an object containing the list of the available environment
-   variables. */
-static JSValue js_std_getenviron(JSContext *ctx, JSValueConst this_val,
-                                 int argc, JSValueConst *argv)
-{
-    char **envp;
-    const char *name, *p, *value;
-    JSValue obj;
-    uint32_t idx;
-    size_t name_len;
-    JSAtom atom;
-    int ret;
-
-    obj = JS_NewObject(ctx);
-    if (JS_IsException(obj))
-        return JS_EXCEPTION;
-    envp = environ;
-    for(idx = 0; envp[idx] != NULL; idx++) {
-        name = envp[idx];
-        p = strchr(name, '=');
-        name_len = p - name;
-        if (!p)
-            continue;
-        value = p + 1;
-        atom = JS_NewAtomLen(ctx, name, name_len);
-        if (atom == JS_ATOM_NULL)
-            goto fail;
-        ret = JS_DefinePropertyValue(ctx, obj, atom, JS_NewString(ctx, value),
-                                     JS_PROP_C_W_E);
-        JS_FreeAtom(ctx, atom);
-        if (ret < 0)
-            goto fail;
-    }
-    return obj;
- fail:
-    JS_FreeValue(ctx, obj);
-    return JS_EXCEPTION;
-}
-
 static JSValue js_std_gc(JSContext *ctx, JSValueConst this_val,
                          int argc, JSValueConst *argv)
 {
@@ -784,28 +638,6 @@
     return ret;
 }
 
-static JSClassID js_std_file_class_id;
-
-typedef struct {
-    FILE *f;
-    BOOL close_in_finalizer;
-    BOOL is_popen;
-} JSSTDFile;
-
-static void js_std_file_finalizer(JSRuntime *rt, JSValue val)
-{
-    JSSTDFile *s = JS_GetOpaque(val, js_std_file_class_id);
-    if (s) {
-        if (s->f && s->close_in_finalizer) {
-            if (s->is_popen)
-                pclose(s->f);
-            else
-                fclose(s->f);
-        }
-        js_free_rt(rt, s);
-    }
-}
-
 static ssize_t js_get_errno(ssize_t ret)
 {
     if (ret == -1)
@@ -836,27 +668,6 @@
     JS_FreeCString(ctx, str);
     return obj;
 }
-
-static JSValue js_new_std_file(JSContext *ctx, FILE *f,
-                               BOOL close_in_finalizer,
-                               BOOL is_popen)
-{
-    JSSTDFile *s;
-    JSValue obj;
-    obj = JS_NewObjectClass(ctx, js_std_file_class_id);
-    if (JS_IsException(obj))
-        return obj;
-    s = js_mallocz(ctx, sizeof(*s));
-    if (!s) {
-        JS_FreeValue(ctx, obj);
-        return JS_EXCEPTION;
-    }
-    s->close_in_finalizer = close_in_finalizer;
-    s->is_popen = is_popen;
-    s->f = f;
-    JS_SetOpaque(obj, s);
-    return obj;
-}
 
 static void js_set_error_object(JSContext *ctx, JSValue obj, int err)
 {
@@ -865,123 +676,6 @@
     }
 }
 
-static JSValue js_std_open(JSContext *ctx, JSValueConst this_val,
-                           int argc, JSValueConst *argv)
-{
-    const char *filename, *mode = NULL;
-    FILE *f;
-    int err;
-    
-    filename = JS_ToCString(ctx, argv[0]);
-    if (!filename)
-        goto fail;
-    mode = JS_ToCString(ctx, argv[1]);
-    if (!mode)
-        goto fail;
-    if (mode[strspn(mode, "rwa+b")] != '\0') {
-        JS_ThrowTypeError(ctx, "invalid file mode");
-        goto fail;
-    }
-
-    f = fopen(filename, mode);
-    if (!f)
-        err = errno;
-    else
-        err = 0;
-    if (argc >= 3)
-        js_set_error_object(ctx, argv[2], err);
-    JS_FreeCString(ctx, filename);
-    JS_FreeCString(ctx, mode);
-    if (!f)
-        return JS_NULL;
-    return js_new_std_file(ctx, f, TRUE, FALSE);
- fail:
-    JS_FreeCString(ctx, filename);
-    JS_FreeCString(ctx, mode);
-    return JS_EXCEPTION;
-}
-
-static JSValue js_std_popen(JSContext *ctx, JSValueConst this_val,
-                            int argc, JSValueConst *argv)
-{
-    const char *filename, *mode = NULL;
-    FILE *f;
-    int err;
-    
-    filename = JS_ToCString(ctx, argv[0]);
-    if (!filename)
-        goto fail;
-    mode = JS_ToCString(ctx, argv[1]);
-    if (!mode)
-        goto fail;
-    if (mode[strspn(mode, "rw")] != '\0') {
-        JS_ThrowTypeError(ctx, "invalid file mode");
-        goto fail;
-    }
-
-    f = popen(filename, mode);
-    if (!f)
-        err = errno;
-    else
-        err = 0;
-    if (argc >= 3)
-        js_set_error_object(ctx, argv[2], err);
-    JS_FreeCString(ctx, filename);
-    JS_FreeCString(ctx, mode);
-    if (!f)
-        return JS_NULL;
-    return js_new_std_file(ctx, f, TRUE, TRUE);
- fail:
-    JS_FreeCString(ctx, filename);
-    JS_FreeCString(ctx, mode);
-    return JS_EXCEPTION;
-}
-
-static JSValue js_std_fdopen(JSContext *ctx, JSValueConst this_val,
-                             int argc, JSValueConst *argv)
-{
-    const char *mode;
-    FILE *f;
-    int fd, err;
-
-    if (JS_ToInt32(ctx, &fd, argv[0]))
-        return JS_EXCEPTION;
-    mode = JS_ToCString(ctx, argv[1]);
-    if (!mode)
-        goto fail;
-    if (mode[strspn(mode, "rwa+")] != '\0') {
-        JS_ThrowTypeError(ctx, "invalid file mode");
-        goto fail;
-    }
-
-    f = fdopen(fd, mode);
-    if (!f)
-        err = errno;
-    else
-        err = 0;
-    if (argc >= 3)
-        js_set_error_object(ctx, argv[2], err);
-    JS_FreeCString(ctx, mode);
-    if (!f)
-        return JS_NULL;
-    return js_new_std_file(ctx, f, TRUE, FALSE);
- fail:
-    JS_FreeCString(ctx, mode);
-    return JS_EXCEPTION;
-}
-
-static JSValue js_std_tmpfile(JSContext *ctx, JSValueConst this_val,
-                              int argc, JSValueConst *argv)
-{
-    FILE *f;
-    f = tmpfile();
-    if (argc >= 1)
-        js_set_error_object(ctx, argv[0], f ? 0 : errno);
-    if (!f)
-        return JS_NULL;
-    return js_new_std_file(ctx, f, TRUE, FALSE);
-}
-
 static JSValue js_std_sprintf(JSContext *ctx, JSValueConst this_val,
                           int argc, JSValueConst *argv)
 {
@@ -994,284 +688,6 @@
     return js_printf_internal(ctx, argc, argv, stdout);
 }
 
-static FILE *js_std_file_get(JSContext *ctx, JSValueConst obj)
-{
-    JSSTDFile *s = JS_GetOpaque2(ctx, obj, js_std_file_class_id);
-    if (!s)
-        return NULL;
-    if (!s->f) {
-        JS_ThrowTypeError(ctx, "invalid file handle");
-        return NULL;
-    }
-    return s->f;
-}
-
-static JSValue js_std_file_puts(JSContext *ctx, JSValueConst this_val,
-                                int argc, JSValueConst *argv, int magic)
-{
-    FILE *f;
-    int i;
-    const char *str;
-    size_t len;
-
-    if (magic == 0) {
-        f = stdout;
-    } else {
-        f = js_std_file_get(ctx, this_val);
-        if (!f)
-            return JS_EXCEPTION;
-    }
-    
-    for(i = 0; i < argc; i++) {
-        str = JS_ToCStringLen(ctx, &len, argv[i]);
-        if (!str)
-            return JS_EXCEPTION;
-        fwrite(str, 1, len, f);
-        JS_FreeCString(ctx, str);
-    }
-    return JS_UNDEFINED;
-}
-
-static JSValue js_std_file_close(JSContext *ctx, JSValueConst this_val,
-                                 int argc, JSValueConst *argv)
-{
-    JSSTDFile *s = JS_GetOpaque2(ctx, this_val, js_std_file_class_id);
-    int err;
-    if (!s)
-        return JS_EXCEPTION;
-    if (!s->f)
-        return JS_ThrowTypeError(ctx, "invalid file handle");
-    if (s->is_popen)
-        err = js_get_errno(pclose(s->f));
-    else
-        err = js_get_errno(fclose(s->f));
-    s->f = NULL;
-    return JS_NewInt32(ctx, err);
-}
-
-static JSValue js_std_file_printf(JSContext *ctx, JSValueConst this_val,
-                                  int argc, JSValueConst *argv)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    if (!f)
-        return JS_EXCEPTION;
-    return js_printf_internal(ctx, argc, argv, f);
-}
-
-static JSValue js_std_file_flush(JSContext *ctx, JSValueConst this_val,
-                                 int argc, JSValueConst *argv)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    if (!f)
-        return JS_EXCEPTION;
-    fflush(f);
-    return JS_UNDEFINED;
-}
-
-static JSValue js_std_file_tell(JSContext *ctx, JSValueConst this_val,
-                                int argc, JSValueConst *argv, int is_bigint)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    int64_t pos;
-    if (!f)
-        return JS_EXCEPTION;
-#if defined(__linux__)
-    pos = ftello(f);
-#else
-    pos = ftell(f);
-#endif
-    if (is_bigint)
-        return JS_NewBigInt64(ctx, pos);
-    else
-        return JS_NewInt64(ctx, pos);
-}
-
-static JSValue js_std_file_seek(JSContext *ctx, JSValueConst this_val,
-                                int argc, JSValueConst *argv)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    int64_t pos;
-    int whence, ret;
-    if (!f)
-        return JS_EXCEPTION;
-    if (JS_ToInt64Ext(ctx, &pos, argv[0]))
-        return JS_EXCEPTION;
-    if (JS_ToInt32(ctx, &whence, argv[1]))
-        return JS_EXCEPTION;
-#if defined(__linux__)
-    ret = fseeko(f, pos, whence);
-#else
-    ret = fseek(f, pos, whence);
-#endif
-    if (ret < 0)
-        ret = -errno;
-    return JS_NewInt32(ctx, ret);
-}
-
-static JSValue js_std_file_eof(JSContext *ctx, JSValueConst this_val,
-                               int argc, JSValueConst *argv)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    if (!f)
-        return JS_EXCEPTION;
-    return JS_NewBool(ctx, feof(f));
-}
-
-static JSValue js_std_file_error(JSContext *ctx, JSValueConst this_val,
-                               int argc, JSValueConst *argv)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    if (!f)
-        return JS_EXCEPTION;
-    return JS_NewBool(ctx, ferror(f));
-}
-
-static JSValue js_std_file_clearerr(JSContext *ctx, JSValueConst this_val,
-                                    int argc, JSValueConst *argv)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    if (!f)
-        return JS_EXCEPTION;
-    clearerr(f);
-    return JS_UNDEFINED;
-}
-
-static JSValue js_std_file_fileno(JSContext *ctx, JSValueConst this_val,
-                                  int argc, JSValueConst *argv)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    if (!f)
-        return JS_EXCEPTION;
-    return JS_NewInt32(ctx, fileno(f));
-}
-
-static JSValue js_std_file_read_write(JSContext *ctx, JSValueConst this_val,
-                                      int argc, JSValueConst *argv, int magic)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    uint64_t pos, len;
-    size_t size, ret;
-    uint8_t *buf;
-    
-    if (!f)
-        return JS_EXCEPTION;
-    if (JS_ToIndex(ctx, &pos, argv[1]))
-        return JS_EXCEPTION;
-    if (JS_ToIndex(ctx, &len, argv[2]))
-        return JS_EXCEPTION;
-    buf = JS_GetArrayBuffer(ctx, &size, argv[0]);
-    if (!buf)
-        return JS_EXCEPTION;
-    if (pos + len > size)
-        return JS_ThrowRangeError(ctx, "read/write array buffer overflow");
-    if (magic)
-        ret = fwrite(buf + pos, 1, len, f);
-    else
-        ret = fread(buf + pos, 1, len, f);
-    return JS_NewInt64(ctx, ret);
-}
-
-/* XXX: could use less memory and go faster */
-static JSValue js_std_file_getline(JSContext *ctx, JSValueConst this_val,
-                                   int argc, JSValueConst *argv)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    int c;
-    DynBuf dbuf;
-    JSValue obj;
-    
-    if (!f)
-        return JS_EXCEPTION;
-
-    js_std_dbuf_init(ctx, &dbuf);
-    for(;;) {
-        c = fgetc(f);
-        if (c == EOF) {
-            if (dbuf.size == 0) {
-                /* EOF */
-                dbuf_free(&dbuf);
-                return JS_NULL;
-            } else {
-                break;
-            }
-        }
-        if (c == '\n')
-            break;
-        if (dbuf_putc(&dbuf, c)) {
-            dbuf_free(&dbuf);
-            return JS_ThrowOutOfMemory(ctx);
-        }
-    }
-    obj = JS_NewStringLen(ctx, (const char *)dbuf.buf, dbuf.size);
-    dbuf_free(&dbuf);
-    return obj;
-}
-
-/* XXX: could use less memory and go faster */
-static JSValue js_std_file_readAsString(JSContext *ctx, JSValueConst this_val,
-                                        int argc, JSValueConst *argv)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    int c;
-    DynBuf dbuf;
-    JSValue obj;
-    uint64_t max_size64;
-    size_t max_size;
-    JSValueConst max_size_val;
-    
-    if (!f)
-        return JS_EXCEPTION;
-
-    if (argc >= 1)
-        max_size_val = argv[0];
-    else
-        max_size_val = JS_UNDEFINED;
-    max_size = (size_t)-1;
-    if (!JS_IsUndefined(max_size_val)) {
-        if (JS_ToIndex(ctx, &max_size64, max_size_val))
-            return JS_EXCEPTION;
-        if (max_size64 < max_size)
-            max_size = max_size64;
-    }
-
-    js_std_dbuf_init(ctx, &dbuf);
-    while (max_size != 0) {
-        c = fgetc(f);
-        if (c == EOF)
-            break;
-        if (dbuf_putc(&dbuf, c)) {
-            dbuf_free(&dbuf);
-            return JS_EXCEPTION;
-        }
-        max_size--;
-    }
-    obj = JS_NewStringLen(ctx, (const char *)dbuf.buf, dbuf.size);
-    dbuf_free(&dbuf);
-    return obj;
-}
-
-static JSValue js_std_file_getByte(JSContext *ctx, JSValueConst this_val,
-                                   int argc, JSValueConst *argv)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    if (!f)
-        return JS_EXCEPTION;
-    return JS_NewInt32(ctx, fgetc(f));
-}
-
-static JSValue js_std_file_putByte(JSContext *ctx, JSValueConst this_val,
-                                   int argc, JSValueConst *argv)
-{
-    FILE *f = js_std_file_get(ctx, this_val);
-    int c;
-    if (!f)
-        return JS_EXCEPTION;
-    if (JS_ToInt32(ctx, &c, argv[0]))
-        return JS_EXCEPTION;
-    c = fputc(c, f);
-    return JS_NewInt32(ctx, c);
-}
-
 /* urlGet */
 
 #define URL_GET_PROGRAM "curl -s -i"
@@ -1311,158 +727,6 @@
     return atoi(p);
 }
 
-static JSValue js_std_urlGet(JSContext *ctx, JSValueConst this_val,
-                             int argc, JSValueConst *argv)
-{
-    const char *url;
-    DynBuf cmd_buf;
-    DynBuf data_buf_s, *data_buf = &data_buf_s;
-    DynBuf header_buf_s, *header_buf = &header_buf_s;
-    char *buf; 
-    size_t i, len;
-    int c, status;
-    JSValue response = JS_UNDEFINED, ret_obj;
-    JSValueConst options_obj;
-    FILE *f;
-    BOOL binary_flag, full_flag;
-    
-    url = JS_ToCString(ctx, argv[0]);
-    if (!url)
-        return JS_EXCEPTION;
-    
-    binary_flag = FALSE;
-    full_flag = FALSE;
-    
-    if (argc >= 2) {
-        options_obj = argv[1];
-
-        if (get_bool_option(ctx, &binary_flag, options_obj, "binary"))
-            goto fail_obj;
-
-        if (get_bool_option(ctx, &full_flag, options_obj, "full")) {
-        fail_obj:
-            JS_FreeCString(ctx, url);
-            return JS_EXCEPTION;
-        }
-    }
-    
-    js_std_dbuf_init(ctx, &cmd_buf);
-    dbuf_printf(&cmd_buf, "%s ''", URL_GET_PROGRAM);
-    len = strlen(url);
-    for(i = 0; i < len; i++) {
-        c = url[i];
-        if (c == '\'' || c == '\\')
-            dbuf_putc(&cmd_buf, '\\');
-        dbuf_putc(&cmd_buf, c);
-    }
-    JS_FreeCString(ctx, url);
-    dbuf_putstr(&cmd_buf, "''");
-    dbuf_putc(&cmd_buf, '\0');
-    if (dbuf_error(&cmd_buf)) {
-        dbuf_free(&cmd_buf);
-        return JS_EXCEPTION;
-    }
-    //    printf("%s\n", (char *)cmd_buf.buf);
-    f = popen((char *)cmd_buf.buf, "r");
-    dbuf_free(&cmd_buf);
-    if (!f) {
-        return JS_ThrowTypeError(ctx, "could not start curl");
-    }
-
-    js_std_dbuf_init(ctx, data_buf);
-    js_std_dbuf_init(ctx, header_buf);
-    
-    buf = js_malloc(ctx, URL_GET_BUF_SIZE);
-    if (!buf)
-        goto fail;
-
-    /* get the HTTP status */
-    if (http_get_header_line(f, buf, URL_GET_BUF_SIZE, NULL) < 0) {
-        status = 0;
-        goto bad_header;
-    }
-    status = http_get_status(buf);
-    if (!full_flag && !(status >= 200 && status <= 299)) {
-        goto bad_header;
-    }
-    
-    /* wait until there is an empty line */
-    for(;;) {
-        if (http_get_header_line(f, buf, URL_GET_BUF_SIZE, header_buf) < 0) {
-        bad_header:
-            response = JS_NULL;
-            goto done;
-        }
-        if (!strcmp(buf, "\r\n"))
-            break;
-    }
-    if (dbuf_error(header_buf))
-        goto fail;
-    header_buf->size -= 2; /* remove the trailing CRLF */
-
-    /* download the data */
-    for(;;) {
-        len = fread(buf, 1, URL_GET_BUF_SIZE, f);
-        if (len == 0)
-            break;
-        dbuf_put(data_buf, (uint8_t *)buf, len);
-    }
-    if (dbuf_error(data_buf))
-        goto fail;
-    if (binary_flag) {
-        response = JS_NewArrayBufferCopy(ctx,
-                                         data_buf->buf, data_buf->size);
-    } else {
-        response = JS_NewStringLen(ctx, (char *)data_buf->buf, data_buf->size);
-    }
-    if (JS_IsException(response))
-        goto fail;
- done:
-    js_free(ctx, buf);
-    buf = NULL;
-    pclose(f);
-    f = NULL;
-    dbuf_free(data_buf);
-    data_buf = NULL;
-
-    if (full_flag) {
-        ret_obj = JS_NewObject(ctx);
-        if (JS_IsException(ret_obj))
-            goto fail;
-        JS_DefinePropertyValueStr(ctx, ret_obj, "response",
-                                  response,
-                                  JS_PROP_C_W_E);
-        if (!JS_IsNull(response)) {
-            JS_DefinePropertyValueStr(ctx, ret_obj, "responseHeaders",
-                                      JS_NewStringLen(ctx, (char *)header_buf->buf,
-                                                      header_buf->size),
-                                      JS_PROP_C_W_E);
-            JS_DefinePropertyValueStr(ctx, ret_obj, "status",
-                                      JS_NewInt32(ctx, status),
-                                      JS_PROP_C_W_E);
-        }
-    } else {
-        ret_obj = response;
-    }
-    dbuf_free(header_buf);
-    return ret_obj;
- fail:
-    if (f)
-        pclose(f);
-    js_free(ctx, buf);
-    if (data_buf)
-        dbuf_free(data_buf);
-    if (header_buf)
-        dbuf_free(header_buf);
-    JS_FreeValue(ctx, response);
-    return JS_EXCEPTION;
-}
-
-static JSClassDef js_std_file_class = {
-    "FILE",
-    .finalizer = js_std_file_finalizer,
-}; 
-
 static const JSCFunctionListEntry js_std_error_props[] = {
     /* various errno values */
 #define DEF(x) JS_PROP_INT32_DEF(#x, x, JS_PROP_CONFIGURABLE )
@@ -1488,18 +752,11 @@
     JS_CFUNC_DEF("getenv", 1, js_std_getenv ),
     JS_CFUNC_DEF("setenv", 1, js_std_setenv ),
     JS_CFUNC_DEF("unsetenv", 1, js_std_unsetenv ),
-    JS_CFUNC_DEF("getenviron", 1, js_std_getenviron ),
-    JS_CFUNC_DEF("urlGet", 1, js_std_urlGet ),
     JS_CFUNC_DEF("loadFile", 1, js_std_loadFile ),
     JS_CFUNC_DEF("strerror", 1, js_std_strerror ),
     JS_CFUNC_DEF("parseExtJSON", 1, js_std_parseExtJSON ),
     
     /* FILE I/O */
-    JS_CFUNC_DEF("open", 2, js_std_open ),
-    JS_CFUNC_DEF("popen", 2, js_std_popen ),
-    JS_CFUNC_DEF("fdopen", 2, js_std_fdopen ),
-    JS_CFUNC_DEF("tmpfile", 0, js_std_tmpfile ),
-    JS_CFUNC_MAGIC_DEF("puts", 1, js_std_file_puts, 0 ),
     JS_CFUNC_DEF("printf", 1, js_std_printf ),
     JS_CFUNC_DEF("sprintf", 1, js_std_sprintf ),
     JS_PROP_INT32_DEF("SEEK_SET", SEEK_SET, JS_PROP_CONFIGURABLE ),
@@ -1507,47 +764,16 @@
     JS_PROP_INT32_DEF("SEEK_END", SEEK_END, JS_PROP_CONFIGURABLE ),
     JS_OBJECT_DEF("Error", js_std_error_props, countof(js_std_error_props), JS_PROP_CONFIGURABLE),
 };
-    
-static const JSCFunctionListEntry js_std_file_proto_funcs[] = {
-    JS_CFUNC_DEF("close", 0, js_std_file_close ),
-    JS_CFUNC_MAGIC_DEF("puts", 1, js_std_file_puts, 1 ),
-    JS_CFUNC_DEF("printf", 1, js_std_file_printf ),
-    JS_CFUNC_DEF("flush", 0, js_std_file_flush ),
-    JS_CFUNC_MAGIC_DEF("tell", 0, js_std_file_tell, 0 ),
-    JS_CFUNC_MAGIC_DEF("tello", 0, js_std_file_tell, 1 ),
-    JS_CFUNC_DEF("seek", 2, js_std_file_seek ),
-    JS_CFUNC_DEF("eof", 0, js_std_file_eof ),
-    JS_CFUNC_DEF("fileno", 0, js_std_file_fileno ),
-    JS_CFUNC_DEF("error", 0, js_std_file_error ),
-    JS_CFUNC_DEF("clearerr", 0, js_std_file_clearerr ),
-    JS_CFUNC_MAGIC_DEF("read", 3, js_std_file_read_write, 0 ),
-    JS_CFUNC_MAGIC_DEF("write", 3, js_std_file_read_write, 1 ),
-    JS_CFUNC_DEF("getline", 0, js_std_file_getline ),
-    JS_CFUNC_DEF("readAsString", 0, js_std_file_readAsString ),
-    JS_CFUNC_DEF("getByte", 0, js_std_file_getByte ),
-    JS_CFUNC_DEF("putByte", 1, js_std_file_putByte ),
-    /* setvbuf, ...  */
-};
 
 static int js_std_init(JSContext *ctx, JSModuleDef *m)
 {
     JSValue proto;
     
     /* FILE class */
-    /* the class ID is created once */
-    JS_NewClassID(&js_std_file_class_id);
-    /* the class is created once per runtime */
-    JS_NewClass(JS_GetRuntime(ctx), js_std_file_class_id, &js_std_file_class);
     proto = JS_NewObject(ctx);
-    JS_SetPropertyFunctionList(ctx, proto, js_std_file_proto_funcs,
-                               countof(js_std_file_proto_funcs));
-    JS_SetClassProto(ctx, js_std_file_class_id, proto);
 
     JS_SetModuleExportList(ctx, m, js_std_funcs,
                            countof(js_std_funcs));
-    JS_SetModuleExport(ctx, m, "in", js_new_std_file(ctx, stdin, FALSE, FALSE));
-    JS_SetModuleExport(ctx, m, "out", js_new_std_file(ctx, stdout, FALSE, FALSE));
-    JS_SetModuleExport(ctx, m, "err", js_new_std_file(ctx, stderr, FALSE, FALSE));
     return 0;
 }
 
@@ -1567,256 +793,6 @@
 /**********************************************************/
 /* 'os' object */
 
-static JSValue js_os_open(JSContext *ctx, JSValueConst this_val,
-                          int argc, JSValueConst *argv)
-{
-    const char *filename;
-    int flags, mode, ret;
-
-    filename = JS_ToCString(ctx, argv[0]);
-    if (!filename)
-        return JS_EXCEPTION;
-    if (JS_ToInt32(ctx, &flags, argv[1]))
-        goto fail;
-    if (argc >= 3 && !JS_IsUndefined(argv[2])) {
-        if (JS_ToInt32(ctx, &mode, argv[2])) {
-        fail:
-            JS_FreeCString(ctx, filename);
-            return JS_EXCEPTION;
-        }
-    } else {
-        mode = 0666;
-    }
-#if defined(_WIN32)
-    /* force binary mode by default */
-    if (!(flags & O_TEXT))
-        flags |= O_BINARY;
-#endif
-    ret = js_get_errno(open(filename, flags, mode));
-    JS_FreeCString(ctx, filename);
-    return JS_NewInt32(ctx, ret);
-}
-
-static JSValue js_os_close(JSContext *ctx, JSValueConst this_val,
-                           int argc, JSValueConst *argv)
-{
-    int fd, ret;
-    if (JS_ToInt32(ctx, &fd, argv[0]))
-        return JS_EXCEPTION;
-    ret = js_get_errno(close(fd));
-    return JS_NewInt32(ctx, ret);
-}
-
-static JSValue js_os_seek(JSContext *ctx, JSValueConst this_val,
-                          int argc, JSValueConst *argv)
-{
-    int fd, whence;
-    int64_t pos, ret;
-    BOOL is_bigint;
-    
-    if (JS_ToInt32(ctx, &fd, argv[0]))
-        return JS_EXCEPTION;
-    is_bigint = JS_IsBigInt(ctx, argv[1]);
-    if (JS_ToInt64Ext(ctx, &pos, argv[1]))
-        return JS_EXCEPTION;
-    if (JS_ToInt32(ctx, &whence, argv[2]))
-        return JS_EXCEPTION;
-    ret = lseek(fd, pos, whence);
-    if (ret == -1)
-        ret = -errno;
-    if (is_bigint)
-        return JS_NewBigInt64(ctx, ret);
-    else
-        return JS_NewInt64(ctx, ret);
-}
-
-static JSValue js_os_read_write(JSContext *ctx, JSValueConst this_val,
-                                      int argc, JSValueConst *argv, int magic)
-{
-    int fd;
-    uint64_t pos, len;
-    size_t size;
-    ssize_t ret;
-    uint8_t *buf;
-    
-    if (JS_ToInt32(ctx, &fd, argv[0]))
-        return JS_EXCEPTION;
-    if (JS_ToIndex(ctx, &pos, argv[2]))
-        return JS_EXCEPTION;
-    if (JS_ToIndex(ctx, &len, argv[3]))
-        return JS_EXCEPTION;
-    buf = JS_GetArrayBuffer(ctx, &size, argv[1]);
-    if (!buf)
-        return JS_EXCEPTION;
-    if (pos + len > size)
-        return JS_ThrowRangeError(ctx, "read/write array buffer overflow");
-    if (magic)
-        ret = js_get_errno(write(fd, buf + pos, len));
-    else
-        ret = js_get_errno(read(fd, buf + pos, len));
-    return JS_NewInt64(ctx, ret);
-}
-
-static JSValue js_os_isatty(JSContext *ctx, JSValueConst this_val,
-                            int argc, JSValueConst *argv)
-{
-    int fd;
-    if (JS_ToInt32(ctx, &fd, argv[0]))
-        return JS_EXCEPTION;
-    return JS_NewBool(ctx, (isatty(fd) != 0));
-}
-
-#if defined(_WIN32)
-static JSValue js_os_ttyGetWinSize(JSContext *ctx, JSValueConst this_val,
-                                   int argc, JSValueConst *argv)
-{
-    int fd;
-    HANDLE handle;
-    CONSOLE_SCREEN_BUFFER_INFO info;
-    JSValue obj;
-
-    if (JS_ToInt32(ctx, &fd, argv[0]))
-        return JS_EXCEPTION;
-    handle = (HANDLE)_get_osfhandle(fd);
-    
-    if (!GetConsoleScreenBufferInfo(handle, &info))
-        return JS_NULL;
-    obj = JS_NewArray(ctx);
-    if (JS_IsException(obj))
-        return obj;
-    JS_DefinePropertyValueUint32(ctx, obj, 0, JS_NewInt32(ctx, info.dwSize.X), JS_PROP_C_W_E);
-    JS_DefinePropertyValueUint32(ctx, obj, 1, JS_NewInt32(ctx, info.dwSize.Y), JS_PROP_C_W_E);
-    return obj;
-}
-
-/* Windows 10 built-in VT100 emulation */
-#define __ENABLE_VIRTUAL_TERMINAL_PROCESSING 0x0004
-#define __ENABLE_VIRTUAL_TERMINAL_INPUT 0x0200
-
-static JSValue js_os_ttySetRaw(JSContext *ctx, JSValueConst this_val,
-                               int argc, JSValueConst *argv)
-{
-    int fd;
-    HANDLE handle;
-
-    if (JS_ToInt32(ctx, &fd, argv[0]))
-        return JS_EXCEPTION;
-    handle = (HANDLE)_get_osfhandle(fd);
-    SetConsoleMode(handle, ENABLE_WINDOW_INPUT | __ENABLE_VIRTUAL_TERMINAL_INPUT);
-    _setmode(fd, _O_BINARY);
-    if (fd == 0) {
-        handle = (HANDLE)_get_osfhandle(1); /* corresponding output */
-        SetConsoleMode(handle, ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT | __ENABLE_VIRTUAL_TERMINAL_PROCESSING);
-    }
-    return JS_UNDEFINED;
-}
-#else
-static JSValue js_os_ttyGetWinSize(JSContext *ctx, JSValueConst this_val,
-                                   int argc, JSValueConst *argv)
-{
-    int fd;
-    struct winsize ws;
-    JSValue obj;
-    
-    if (JS_ToInt32(ctx, &fd, argv[0]))
-        return JS_EXCEPTION;
-    if (ioctl(fd, TIOCGWINSZ, &ws) == 0 &&
-        ws.ws_col >= 4 && ws.ws_row >= 4) {
-        obj = JS_NewArray(ctx);
-        if (JS_IsException(obj))
-            return obj;
-        JS_DefinePropertyValueUint32(ctx, obj, 0, JS_NewInt32(ctx, ws.ws_col), JS_PROP_C_W_E);
-        JS_DefinePropertyValueUint32(ctx, obj, 1, JS_NewInt32(ctx, ws.ws_row), JS_PROP_C_W_E);
-        return obj;
-    } else {
-        return JS_NULL;
-    }
-}
-
-static struct termios oldtty;
-
-static void term_exit(void)
-{
-    tcsetattr(0, TCSANOW, &oldtty);
-}
-
-/* XXX: should add a way to go back to normal mode */
-static JSValue js_os_ttySetRaw(JSContext *ctx, JSValueConst this_val,
-                               int argc, JSValueConst *argv)
-{
-    struct termios tty;
-    int fd;
-    
-    if (JS_ToInt32(ctx, &fd, argv[0]))
-        return JS_EXCEPTION;
-    
-    memset(&tty, 0, sizeof(tty));
-    tcgetattr(fd, &tty);
-    oldtty = tty;
-
-    tty.c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP
-                          |INLCR|IGNCR|ICRNL|IXON);
-    tty.c_oflag |= OPOST;
-    tty.c_lflag &= ~(ECHO|ECHONL|ICANON|IEXTEN);
-    tty.c_cflag &= ~(CSIZE|PARENB);
-    tty.c_cflag |= CS8;
-    tty.c_cc[VMIN] = 1;
-    tty.c_cc[VTIME] = 0;
-
-    tcsetattr(fd, TCSANOW, &tty);
-
-    atexit(term_exit);
-    return JS_UNDEFINED;
-}
-
-#endif /* !_WIN32 */
-
-static JSValue js_os_remove(JSContext *ctx, JSValueConst this_val,
-                             int argc, JSValueConst *argv)
-{
-    const char *filename;
-    int ret;
-    
-    filename = JS_ToCString(ctx, argv[0]);
-    if (!filename)
-        return JS_EXCEPTION;
-#if defined(_WIN32)
-    {
-        struct stat st;
-        if (stat(filename, &st) == 0 && S_ISDIR(st.st_mode)) {
-            ret = rmdir(filename);
-        } else {
-            ret = unlink(filename);
-        }
-    }
-#else
-    ret = remove(filename);
-#endif
-    ret = js_get_errno(ret);
-    JS_FreeCString(ctx, filename);
-    return JS_NewInt32(ctx, ret);
-}
-
-static JSValue js_os_rename(JSContext *ctx, JSValueConst this_val,
-                            int argc, JSValueConst *argv)
-{
-    const char *oldpath, *newpath;
-    int ret;
-    
-    oldpath = JS_ToCString(ctx, argv[0]);
-    if (!oldpath)
-        return JS_EXCEPTION;
-    newpath = JS_ToCString(ctx, argv[1]);
-    if (!newpath) {
-        JS_FreeCString(ctx, oldpath);
-        return JS_EXCEPTION;
-    }
-    ret = js_get_errno(rename(oldpath, newpath));
-    JS_FreeCString(ctx, oldpath);
-    JS_FreeCString(ctx, newpath);
-    return JS_NewInt32(ctx, ret);
-}
-
 static BOOL is_main_thread(JSRuntime *rt)
 {
     JSThreadState *ts = JS_GetRuntimeOpaque(rt);
@@ -1916,53 +892,6 @@
 typedef void (*sighandler_t)(int sig_num);
 #endif
 
-static JSValue js_os_signal(JSContext *ctx, JSValueConst this_val,
-                            int argc, JSValueConst *argv)
-{
-    JSRuntime *rt = JS_GetRuntime(ctx);
-    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
-    JSOSSignalHandler *sh;
-    uint32_t sig_num;
-    JSValueConst func;
-    sighandler_t handler;
-
-    if (!is_main_thread(rt))
-        return JS_ThrowTypeError(ctx, "signal handler can only be set in the main thread");
-    
-    if (JS_ToUint32(ctx, &sig_num, argv[0]))
-        return JS_EXCEPTION;
-    if (sig_num >= 64)
-        return JS_ThrowRangeError(ctx, "invalid signal number");
-    func = argv[1];
-    /* func = null: SIG_DFL, func = undefined, SIG_IGN */
-    if (JS_IsNull(func) || JS_IsUndefined(func)) {
-        sh = find_sh(ts, sig_num);
-        if (sh) {
-            free_sh(JS_GetRuntime(ctx), sh);
-        }
-        if (JS_IsNull(func))
-            handler = SIG_DFL;
-        else
-            handler = SIG_IGN;
-        signal(sig_num, handler);
-    } else {
-        if (!JS_IsFunction(ctx, func))
-            return JS_ThrowTypeError(ctx, "not a function");
-        sh = find_sh(ts, sig_num);
-        if (!sh) {
-            sh = js_mallocz(ctx, sizeof(*sh));
-            if (!sh)
-                return JS_EXCEPTION;
-            sh->sig_num = sig_num;
-            list_add_tail(&sh->link, &ts->os_signal_handlers);
-        }
-        JS_FreeValue(ctx, sh->func);
-        sh->func = JS_DupValue(ctx, func);
-        signal(sig_num, os_signal_handler);
-    }
-    return JS_UNDEFINED;
-}
-
 #if defined(__linux__) || defined(__APPLE__)
 static int64_t get_time_ms(void)
 {
@@ -1970,8 +899,14 @@
     clock_gettime(CLOCK_MONOTONIC, &ts);
     return (uint64_t)ts.tv_sec * 1000 + (ts.tv_nsec / 1000000);
 }
+#elif defined(_MSC_VER)
+static int64_t get_time_ms(void)
+{
+	return GetTickCount();
+}
 #else
 /* more portable, but does not work if the date is updated */
+int gettimeofday(struct timeval *tp, void *tzp);
 static int64_t get_time_ms(void)
 {
     struct timeval tv;
@@ -2368,246 +1303,6 @@
     return make_obj_error(ctx, JS_NewString(ctx, buf), err);
 }
 
-/* return [cwd, errorcode] */
-static JSValue js_os_getcwd(JSContext *ctx, JSValueConst this_val,
-                            int argc, JSValueConst *argv)
-{
-    char buf[PATH_MAX];
-    int err;
-    
-    if (!getcwd(buf, sizeof(buf))) {
-        buf[0] = '\0';
-        err = errno;
-    } else {
-        err = 0;
-    }
-    return make_string_error(ctx, buf, err);
-}
-
-static JSValue js_os_chdir(JSContext *ctx, JSValueConst this_val,
-                           int argc, JSValueConst *argv)
-{
-    const char *target;
-    int err;
-
-    target = JS_ToCString(ctx, argv[0]);
-    if (!target)
-        return JS_EXCEPTION;
-    err = js_get_errno(chdir(target));
-    JS_FreeCString(ctx, target);
-    return JS_NewInt32(ctx, err);
-}
-
-static JSValue js_os_mkdir(JSContext *ctx, JSValueConst this_val,
-                           int argc, JSValueConst *argv)
-{
-    int mode, ret;
-    const char *path;
-    
-    if (argc >= 2) {
-        if (JS_ToInt32(ctx, &mode, argv[1]))
-            return JS_EXCEPTION;
-    } else {
-        mode = 0777;
-    }
-    path = JS_ToCString(ctx, argv[0]);
-    if (!path)
-        return JS_EXCEPTION;
-#if defined(_WIN32)
-    (void)mode;
-    ret = js_get_errno(mkdir(path));
-#else
-    ret = js_get_errno(mkdir(path, mode));
-#endif
-    JS_FreeCString(ctx, path);
-    return JS_NewInt32(ctx, ret);
-}
-
-/* return [array, errorcode] */
-static JSValue js_os_readdir(JSContext *ctx, JSValueConst this_val,
-                             int argc, JSValueConst *argv)
-{
-    const char *path;
-    DIR *f;
-    struct dirent *d;
-    JSValue obj;
-    int err;
-    uint32_t len;
-    
-    path = JS_ToCString(ctx, argv[0]);
-    if (!path)
-        return JS_EXCEPTION;
-    obj = JS_NewArray(ctx);
-    if (JS_IsException(obj)) {
-        JS_FreeCString(ctx, path);
-        return JS_EXCEPTION;
-    }
-    f = opendir(path);
-    if (!f)
-        err = errno;
-    else
-        err = 0;
-    JS_FreeCString(ctx, path);
-    if (!f)
-        goto done;
-    len = 0;
-    for(;;) {
-        errno = 0;
-        d = readdir(f);
-        if (!d) {
-            err = errno;
-            break;
-        }
-        JS_DefinePropertyValueUint32(ctx, obj, len++,
-                                     JS_NewString(ctx, d->d_name),
-                                     JS_PROP_C_W_E);
-    }
-    closedir(f);
- done:
-    return make_obj_error(ctx, obj, err);
-}
-
-#if !defined(_WIN32)
-static int64_t timespec_to_ms(const struct timespec *tv)
-{
-    return (int64_t)tv->tv_sec * 1000 + (tv->tv_nsec / 1000000);
-}
-#endif
-
-/* return [obj, errcode] */
-static JSValue js_os_stat(JSContext *ctx, JSValueConst this_val,
-                          int argc, JSValueConst *argv, int is_lstat)
-{
-    const char *path;
-    int err, res;
-    struct stat st;
-    JSValue obj;
-
-    path = JS_ToCString(ctx, argv[0]);
-    if (!path)
-        return JS_EXCEPTION;
-#if defined(_WIN32)
-    res = stat(path, &st);
-#else
-    if (is_lstat)
-        res = lstat(path, &st);
-    else
-        res = stat(path, &st);
-#endif
-    JS_FreeCString(ctx, path);
-    if (res < 0) {
-        err = errno;
-        obj = JS_NULL;
-    } else {
-        err = 0;
-        obj = JS_NewObject(ctx);
-        if (JS_IsException(obj))
-            return JS_EXCEPTION;
-        JS_DefinePropertyValueStr(ctx, obj, "dev",
-                                  JS_NewInt64(ctx, st.st_dev),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "ino",
-                                  JS_NewInt64(ctx, st.st_ino),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "mode",
-                                  JS_NewInt32(ctx, st.st_mode),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "nlink",
-                                  JS_NewInt64(ctx, st.st_nlink),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "uid",
-                                  JS_NewInt64(ctx, st.st_uid),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "gid",
-                                  JS_NewInt64(ctx, st.st_gid),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "rdev",
-                                  JS_NewInt64(ctx, st.st_rdev),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "size",
-                                  JS_NewInt64(ctx, st.st_size),
-                                  JS_PROP_C_W_E);
-#if !defined(_WIN32)
-        JS_DefinePropertyValueStr(ctx, obj, "blocks",
-                                  JS_NewInt64(ctx, st.st_blocks),
-                                  JS_PROP_C_W_E);
-#endif
-#if defined(_WIN32)
-        JS_DefinePropertyValueStr(ctx, obj, "atime",
-                                  JS_NewInt64(ctx, (int64_t)st.st_atime * 1000),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "mtime",
-                                  JS_NewInt64(ctx, (int64_t)st.st_mtime * 1000),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "ctime",
-                                  JS_NewInt64(ctx, (int64_t)st.st_ctime * 1000),
-                                  JS_PROP_C_W_E);
-#elif defined(__APPLE__)
-        JS_DefinePropertyValueStr(ctx, obj, "atime",
-                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_atimespec)),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "mtime",
-                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_mtimespec)),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "ctime",
-                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_ctimespec)),
-                                  JS_PROP_C_W_E);
-#else
-        JS_DefinePropertyValueStr(ctx, obj, "atime",
-                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_atim)),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "mtime",
-                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_mtim)),
-                                  JS_PROP_C_W_E);
-        JS_DefinePropertyValueStr(ctx, obj, "ctime",
-                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_ctim)),
-                                  JS_PROP_C_W_E);
-#endif
-    }
-    return make_obj_error(ctx, obj, err);
-}
-
-#if !defined(_WIN32)
-static void ms_to_timeval(struct timeval *tv, uint64_t v)
-{
-    tv->tv_sec = v / 1000;
-    tv->tv_usec = (v % 1000) * 1000;
-}
-#endif
-
-static JSValue js_os_utimes(JSContext *ctx, JSValueConst this_val,
-                            int argc, JSValueConst *argv)
-{
-    const char *path;
-    int64_t atime, mtime;
-    int ret;
-    
-    if (JS_ToInt64(ctx, &atime, argv[1]))
-        return JS_EXCEPTION;
-    if (JS_ToInt64(ctx, &mtime, argv[2]))
-        return JS_EXCEPTION;
-    path = JS_ToCString(ctx, argv[0]);
-    if (!path)
-        return JS_EXCEPTION;
-#if defined(_WIN32)
-    {
-        struct _utimbuf times;
-        times.actime = atime / 1000;
-        times.modtime = mtime / 1000;
-        ret = js_get_errno(_utime(path, &times));
-    }
-#else
-    {
-        struct timeval times[2];
-        ms_to_timeval(&times[0], atime);
-        ms_to_timeval(&times[1], mtime);
-        ret = js_get_errno(utimes(path, times));
-    }
-#endif
-    JS_FreeCString(ctx, path);
-    return JS_NewInt32(ctx, ret);
-}
-
 /* sleep(delay_ms) */
 static JSValue js_os_sleep(JSContext *ctx, JSValueConst this_val,
                           int argc, JSValueConst *argv)
@@ -2832,204 +1527,6 @@
     return -1;
 }
 
-/* exec(args[, options]) -> exitcode */
-static JSValue js_os_exec(JSContext *ctx, JSValueConst this_val,
-                          int argc, JSValueConst *argv)
-{
-    JSValueConst options, args = argv[0];
-    JSValue val, ret_val;
-    const char **exec_argv, *file = NULL, *str, *cwd = NULL;
-    char **envp = environ;
-    uint32_t exec_argc, i;
-    int ret, pid, status;
-    BOOL block_flag = TRUE, use_path = TRUE;
-    static const char *std_name[3] = { "stdin", "stdout", "stderr" };
-    int std_fds[3];
-    uint32_t uid = -1, gid = -1;
-    
-    val = JS_GetPropertyStr(ctx, args, "length");
-    if (JS_IsException(val))
-        return JS_EXCEPTION;
-    ret = JS_ToUint32(ctx, &exec_argc, val);
-    JS_FreeValue(ctx, val);
-    if (ret)
-        return JS_EXCEPTION;
-    /* arbitrary limit to avoid overflow */
-    if (exec_argc < 1 || exec_argc > 65535) {
-        return JS_ThrowTypeError(ctx, "invalid number of arguments");
-    }
-    exec_argv = js_mallocz(ctx, sizeof(exec_argv[0]) * (exec_argc + 1));
-    if (!exec_argv)
-        return JS_EXCEPTION;
-    for(i = 0; i < exec_argc; i++) {
-        val = JS_GetPropertyUint32(ctx, args, i);
-        if (JS_IsException(val))
-            goto exception;
-        str = JS_ToCString(ctx, val);
-        JS_FreeValue(ctx, val);
-        if (!str)
-            goto exception;
-        exec_argv[i] = str;
-    }
-    exec_argv[exec_argc] = NULL;
-
-    for(i = 0; i < 3; i++)
-        std_fds[i] = i;
-    
-    /* get the options, if any */
-    if (argc >= 2) {
-        options = argv[1];
-
-        if (get_bool_option(ctx, &block_flag, options, "block"))
-            goto exception;
-        if (get_bool_option(ctx, &use_path, options, "usePath"))
-            goto exception;
-        
-        val = JS_GetPropertyStr(ctx, options, "file");
-        if (JS_IsException(val))
-            goto exception;
-        if (!JS_IsUndefined(val)) {
-            file = JS_ToCString(ctx, val);
-            JS_FreeValue(ctx, val);
-            if (!file)
-                goto exception;
-        }
-
-        val = JS_GetPropertyStr(ctx, options, "cwd");
-        if (JS_IsException(val))
-            goto exception;
-        if (!JS_IsUndefined(val)) {
-            cwd = JS_ToCString(ctx, val);
-            JS_FreeValue(ctx, val);
-            if (!cwd)
-                goto exception;
-        }
-
-        /* stdin/stdout/stderr handles */
-        for(i = 0; i < 3; i++) {
-            val = JS_GetPropertyStr(ctx, options, std_name[i]);
-            if (JS_IsException(val))
-                goto exception;
-            if (!JS_IsUndefined(val)) {
-                int fd;
-                ret = JS_ToInt32(ctx, &fd, val);
-                JS_FreeValue(ctx, val);
-                if (ret)
-                    goto exception;
-                std_fds[i] = fd;
-            }
-        }
-
-        val = JS_GetPropertyStr(ctx, options, "env");
-        if (JS_IsException(val))
-            goto exception;
-        if (!JS_IsUndefined(val)) {
-            envp = build_envp(ctx, val);
-            JS_FreeValue(ctx, val);
-            if (!envp)
-                goto exception;
-        }
-        
-        val = JS_GetPropertyStr(ctx, options, "uid");
-        if (JS_IsException(val))
-            goto exception;
-        if (!JS_IsUndefined(val)) {
-            ret = JS_ToUint32(ctx, &uid, val);
-            JS_FreeValue(ctx, val);
-            if (ret)
-                goto exception;
-        }
-
-        val = JS_GetPropertyStr(ctx, options, "gid");
-        if (JS_IsException(val))
-            goto exception;
-        if (!JS_IsUndefined(val)) {
-            ret = JS_ToUint32(ctx, &gid, val);
-            JS_FreeValue(ctx, val);
-            if (ret)
-                goto exception;
-        }
-    }
-
-    pid = fork();
-    if (pid < 0) {
-        JS_ThrowTypeError(ctx, "fork error");
-        goto exception;
-    }
-    if (pid == 0) {
-        /* child */
-        int fd_max = sysconf(_SC_OPEN_MAX);
-
-        /* remap the stdin/stdout/stderr handles if necessary */
-        for(i = 0; i < 3; i++) {
-            if (std_fds[i] != i) {
-                if (dup2(std_fds[i], i) < 0)
-                    _exit(127);
-            }
-        }
-
-        for(i = 3; i < fd_max; i++)
-            close(i);
-        if (cwd) {
-            if (chdir(cwd) < 0)
-                _exit(127);
-        }
-        if (uid != -1) {
-            if (setuid(uid) < 0)
-                _exit(127);
-        }
-        if (gid != -1) {
-            if (setgid(gid) < 0)
-                _exit(127);
-        }
-
-        if (!file)
-            file = exec_argv[0];
-        if (use_path)
-            ret = my_execvpe(file, (char **)exec_argv, envp);
-        else
-            ret = execve(file, (char **)exec_argv, envp);
-        _exit(127);
-    }
-    /* parent */
-    if (block_flag) {
-        for(;;) {
-            ret = waitpid(pid, &status, 0);
-            if (ret == pid) {
-                if (WIFEXITED(status)) {
-                    ret = WEXITSTATUS(status);
-                    break;
-                } else if (WIFSIGNALED(status)) {
-                    ret = -WTERMSIG(status);
-                    break;
-                }
-            }
-        }
-    } else {
-        ret = pid;
-    }
-    ret_val = JS_NewInt32(ctx, ret);
- done:
-    JS_FreeCString(ctx, file);
-    JS_FreeCString(ctx, cwd);
-    for(i = 0; i < exec_argc; i++)
-        JS_FreeCString(ctx, exec_argv[i]);
-    js_free(ctx, exec_argv);
-    if (envp != environ) {
-        char **p;
-        p = envp;
-        while (*p != NULL) {
-            js_free(ctx, *p);
-            p++;
-        }
-        js_free(ctx, envp);
-    }
-    return ret_val;
- exception:
-    ret_val = JS_EXCEPTION;
-    goto done;
-}
-
 /* waitpid(pid, block) -> [pid, status] */
 static JSValue js_os_waitpid(JSContext *ctx, JSValueConst this_val,
                              int argc, JSValueConst *argv)
@@ -3288,7 +1785,7 @@
     ts = JS_GetRuntimeOpaque(rt);
     ts->recv_pipe = args->recv_pipe;
     ts->send_pipe = args->send_pipe;
-    
+
     /* function pointer to avoid linking the whole JS_NewContext() if
        not needed */
     ctx = js_worker_new_context_func(rt);
@@ -3578,7 +2075,6 @@
 #define OS_FLAG(x) JS_PROP_INT32_DEF(#x, x, JS_PROP_CONFIGURABLE )
 
 static const JSCFunctionListEntry js_os_funcs[] = {
-    JS_CFUNC_DEF("open", 2, js_os_open ),
     OS_FLAG(O_RDONLY),
     OS_FLAG(O_WRONLY),
     OS_FLAG(O_RDWR),
@@ -3590,18 +2086,8 @@
     OS_FLAG(O_BINARY),
     OS_FLAG(O_TEXT),
 #endif
-    JS_CFUNC_DEF("close", 1, js_os_close ),
-    JS_CFUNC_DEF("seek", 3, js_os_seek ),
-    JS_CFUNC_MAGIC_DEF("read", 4, js_os_read_write, 0 ),
-    JS_CFUNC_MAGIC_DEF("write", 4, js_os_read_write, 1 ),
-    JS_CFUNC_DEF("isatty", 1, js_os_isatty ),
-    JS_CFUNC_DEF("ttyGetWinSize", 1, js_os_ttyGetWinSize ),
-    JS_CFUNC_DEF("ttySetRaw", 1, js_os_ttySetRaw ),
-    JS_CFUNC_DEF("remove", 1, js_os_remove ),
-    JS_CFUNC_DEF("rename", 2, js_os_rename ),
     JS_CFUNC_MAGIC_DEF("setReadHandler", 2, js_os_setReadHandler, 0 ),
     JS_CFUNC_MAGIC_DEF("setWriteHandler", 2, js_os_setReadHandler, 1 ),
-    JS_CFUNC_DEF("signal", 2, js_os_signal ),
     OS_FLAG(SIGINT),
     OS_FLAG(SIGABRT),
     OS_FLAG(SIGFPE),
@@ -3624,32 +2110,16 @@
     JS_CFUNC_DEF("setTimeout", 2, js_os_setTimeout ),
     JS_CFUNC_DEF("clearTimeout", 1, js_os_clearTimeout ),
     JS_PROP_STRING_DEF("platform", OS_PLATFORM, 0 ),
-    JS_CFUNC_DEF("getcwd", 0, js_os_getcwd ),
-    JS_CFUNC_DEF("chdir", 0, js_os_chdir ),
-    JS_CFUNC_DEF("mkdir", 1, js_os_mkdir ),
-    JS_CFUNC_DEF("readdir", 1, js_os_readdir ),
     /* st_mode constants */
     OS_FLAG(S_IFMT),
-    OS_FLAG(S_IFIFO),
     OS_FLAG(S_IFCHR),
     OS_FLAG(S_IFDIR),
-    OS_FLAG(S_IFBLK),
     OS_FLAG(S_IFREG),
-#if !defined(_WIN32)
-    OS_FLAG(S_IFSOCK),
-    OS_FLAG(S_IFLNK),
-    OS_FLAG(S_ISGID),
-    OS_FLAG(S_ISUID),
-#endif
-    JS_CFUNC_MAGIC_DEF("stat", 1, js_os_stat, 0 ),
-    JS_CFUNC_DEF("utimes", 3, js_os_utimes ),
     JS_CFUNC_DEF("sleep", 1, js_os_sleep ),
     JS_CFUNC_DEF("realpath", 1, js_os_realpath ),
 #if !defined(_WIN32)
-    JS_CFUNC_MAGIC_DEF("lstat", 1, js_os_stat, 1 ),
     JS_CFUNC_DEF("symlink", 2, js_os_symlink ),
     JS_CFUNC_DEF("readlink", 1, js_os_readlink ),
-    JS_CFUNC_DEF("exec", 1, js_os_exec ),
     JS_CFUNC_DEF("waitpid", 2, js_os_waitpid ),
     OS_FLAG(WNOHANG),
     JS_CFUNC_DEF("pipe", 0, js_os_pipe ),
@@ -3829,7 +2299,7 @@
 static void js_dump_obj(JSContext *ctx, FILE *f, JSValueConst val)
 {
     const char *str;
-    
+
     str = JS_ToCString(ctx, val);
     if (str) {
         fprintf(f, "%s\n", str);
Index: quickjs-src/quickjs/libunicode-table.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/libunicode-table.h b/quickjs-src/quickjs/src/libunicode-table.h
rename from quickjs-src/quickjs/libunicode-table.h
rename to quickjs-src/quickjs/src/libunicode-table.h
--- a/quickjs-src/quickjs/libunicode-table.h	(revision 321dbfa770463b8867d8ac90493c7cec015a9c3a)
+++ b/quickjs-src/quickjs/src/libunicode-table.h	(date 1696647929599)
@@ -160,41 +160,40 @@
     0x006b, 0x00e5,
 };
 
-static const uint8_t unicode_prop_Cased1_table[196] = {
+static const uint8_t unicode_prop_Cased1_table[188] = {
     0x40, 0xa9, 0x80, 0x8e, 0x80, 0xfc, 0x80, 0xd3,
     0x80, 0x8c, 0x80, 0x8d, 0x81, 0x8d, 0x02, 0x80,
     0xe1, 0x80, 0x91, 0x85, 0x9a, 0x01, 0x00, 0x01,
     0x11, 0x00, 0x01, 0x04, 0x08, 0x01, 0x08, 0x30,
     0x08, 0x01, 0x15, 0x20, 0x00, 0x39, 0x99, 0x31,
     0x9d, 0x84, 0x40, 0x94, 0x80, 0xd6, 0x82, 0xa6,
-    0x80, 0x41, 0x62, 0x80, 0xa6, 0x80, 0x4b, 0x72,
-    0x80, 0x4c, 0x02, 0xf8, 0x02, 0x80, 0x8f, 0x80,
-    0xb0, 0x40, 0xdb, 0x08, 0x80, 0x41, 0xd0, 0x80,
-    0x8c, 0x80, 0x8f, 0x8c, 0xe4, 0x03, 0x01, 0x89,
-    0x00, 0x14, 0x28, 0x10, 0x11, 0x02, 0x01, 0x18,
-    0x0b, 0x24, 0x4b, 0x26, 0x01, 0x01, 0x86, 0xe5,
-    0x80, 0x60, 0x79, 0xb6, 0x81, 0x40, 0x91, 0x81,
-    0xbd, 0x88, 0x94, 0x05, 0x80, 0x98, 0x80, 0xa2,
-    0x00, 0x80, 0x9b, 0x12, 0x82, 0x43, 0x34, 0xa2,
-    0x06, 0x80, 0x8d, 0x60, 0x5c, 0x15, 0x01, 0x10,
-    0xa9, 0x80, 0x88, 0x60, 0xcc, 0x44, 0xd4, 0x80,
-    0xc6, 0x01, 0x08, 0x09, 0x0b, 0x80, 0x8b, 0x00,
-    0x06, 0x80, 0xc0, 0x03, 0x0f, 0x06, 0x80, 0x9b,
-    0x03, 0x04, 0x00, 0x16, 0x80, 0x41, 0x53, 0x81,
-    0x98, 0x80, 0x98, 0x80, 0x9e, 0x80, 0x98, 0x80,
+    0x80, 0x41, 0x62, 0x80, 0xa6, 0x80, 0x57, 0x76,
+    0xf8, 0x02, 0x80, 0x8f, 0x80, 0xb0, 0x40, 0xdb,
+    0x08, 0x80, 0x41, 0xd0, 0x80, 0x8c, 0x80, 0x8f,
+    0x8c, 0xe4, 0x03, 0x01, 0x89, 0x00, 0x14, 0x28,
+    0x10, 0x11, 0x02, 0x01, 0x18, 0x0b, 0x24, 0x4b,
+    0x26, 0x01, 0x01, 0x86, 0xe5, 0x80, 0x60, 0x79,
+    0xb6, 0x81, 0x40, 0x91, 0x81, 0xbd, 0x88, 0x94,
+    0x05, 0x80, 0x98, 0x80, 0xa2, 0x00, 0x80, 0xa1,
+    0x82, 0x43, 0x34, 0xa2, 0x06, 0x80, 0x8c, 0x60,
+    0x5c, 0x16, 0x01, 0x10, 0xa9, 0x80, 0x88, 0x60,
+    0xcc, 0x44, 0xd4, 0x80, 0xc6, 0x01, 0x08, 0x09,
+    0x0b, 0x80, 0x8b, 0x00, 0x06, 0x80, 0xc0, 0x03,
+    0x0f, 0x06, 0x80, 0x9b, 0x03, 0x04, 0x00, 0x16,
+    0x80, 0x41, 0x53, 0x81, 0x98, 0x80, 0x98, 0x80,
     0x9e, 0x80, 0x98, 0x80, 0x9e, 0x80, 0x98, 0x80,
-    0x9e, 0x80, 0x98, 0x07, 0x47, 0x33, 0x89, 0x80,
-    0x93, 0x2d, 0x41, 0x04, 0xbd, 0x50, 0xc1, 0x99,
+    0x9e, 0x80, 0x98, 0x80, 0x9e, 0x80, 0x98, 0x07,
+    0x47, 0x33, 0x89, 0x80, 0x93, 0x52, 0x10, 0x99,
     0x85, 0x99, 0x85, 0x99,
 };
 
-static const uint8_t unicode_prop_Cased1_index[21] = {
-    0xb9, 0x02, 0xe0, 0xc0, 0x1d, 0x20, 0xe5, 0x2c,
-    0x20, 0xb1, 0x07, 0x21, 0xc1, 0xd6, 0x21, 0x4a,
-    0xf1, 0x01, 0x8a, 0xf1, 0x01,
+static const uint8_t unicode_prop_Cased1_index[18] = {
+    0xb9, 0x02, 0xe0, 0xa0, 0x1e, 0x40, 0x9e, 0xa6,
+    0x40, 0x55, 0xd4, 0x61, 0xfb, 0xd6, 0x21, 0x8a,
+    0xf1, 0x01,
 };
 
-static const uint8_t unicode_prop_Case_Ignorable_table[737] = {
+static const uint8_t unicode_prop_Case_Ignorable_table[720] = {
     0xa6, 0x05, 0x80, 0x8a, 0x80, 0xa2, 0x00, 0x80,
     0xc6, 0x03, 0x00, 0x03, 0x01, 0x81, 0x41, 0xf6,
     0x40, 0xbf, 0x19, 0x18, 0x88, 0x08, 0x80, 0x40,
@@ -216,7 +215,7 @@
     0x01, 0x05, 0x04, 0x81, 0x93, 0x81, 0x9b, 0x81,
     0xb8, 0x0b, 0x1f, 0x80, 0x93, 0x81, 0x9c, 0x80,
     0xc7, 0x06, 0x10, 0x80, 0xd9, 0x01, 0x86, 0x8a,
-    0x88, 0xe1, 0x01, 0x88, 0x88, 0x00, 0x86, 0xc8,
+    0x88, 0xe1, 0x01, 0x88, 0x88, 0x00, 0x85, 0xc9,
     0x81, 0x9a, 0x00, 0x00, 0x80, 0xb6, 0x8d, 0x04,
     0x01, 0x84, 0x8a, 0x80, 0xa3, 0x88, 0x80, 0xe5,
     0x18, 0x28, 0x09, 0x81, 0x98, 0x0b, 0x82, 0x8f,
@@ -257,37 +256,34 @@
     0x80, 0x40, 0x94, 0x84, 0x44, 0x04, 0x28, 0xa9,
     0x80, 0x88, 0x42, 0x45, 0x10, 0x0c, 0x83, 0xa7,
     0x13, 0x80, 0x40, 0xa4, 0x81, 0x42, 0x3c, 0x83,
-    0x41, 0x82, 0x81, 0xcf, 0x82, 0xc5, 0x8a, 0xb0,
-    0x83, 0xfa, 0x80, 0xb5, 0x8e, 0xa8, 0x01, 0x81,
-    0x89, 0x82, 0xb0, 0x19, 0x09, 0x03, 0x80, 0x89,
-    0x80, 0xb1, 0x82, 0xa3, 0x20, 0x87, 0xbd, 0x80,
-    0x8b, 0x81, 0xb3, 0x88, 0x89, 0x19, 0x80, 0xde,
-    0x11, 0x00, 0x0d, 0x01, 0x80, 0x40, 0x9c, 0x02,
-    0x87, 0x94, 0x81, 0xb8, 0x0a, 0x80, 0xa4, 0x32,
-    0x84, 0x40, 0xc2, 0x39, 0x10, 0x80, 0x96, 0x80,
-    0xd3, 0x28, 0x03, 0x08, 0x81, 0x40, 0xed, 0x1d,
-    0x08, 0x81, 0x9a, 0x81, 0xd4, 0x39, 0x00, 0x81,
-    0xe9, 0x00, 0x01, 0x28, 0x80, 0xe4, 0x11, 0x18,
-    0x84, 0x41, 0x02, 0x88, 0x01, 0x40, 0xff, 0x08,
-    0x03, 0x80, 0x40, 0x8f, 0x19, 0x0b, 0x80, 0x9f,
-    0x89, 0xa7, 0x29, 0x1f, 0x80, 0x88, 0x29, 0x82,
-    0xad, 0x8c, 0x01, 0x41, 0x95, 0x30, 0x28, 0x80,
-    0xd1, 0x95, 0x0e, 0x01, 0x01, 0xf9, 0x2a, 0x00,
-    0x08, 0x30, 0x80, 0xc7, 0x0a, 0x00, 0x80, 0x41,
-    0x5a, 0x81, 0x8a, 0x81, 0xb3, 0x24, 0x00, 0x80,
-    0x54, 0xec, 0x90, 0x85, 0x8e, 0x60, 0x36, 0x99,
-    0x84, 0xba, 0x86, 0x88, 0x83, 0x44, 0x0a, 0x80,
-    0xbe, 0x90, 0xbf, 0x08, 0x81, 0x60, 0x40, 0x0a,
-    0x18, 0x30, 0x81, 0x4c, 0x9d, 0x08, 0x83, 0x52,
-    0x5b, 0xad, 0x81, 0x96, 0x42, 0x1f, 0x82, 0x88,
-    0x8f, 0x0e, 0x9d, 0x83, 0x40, 0x93, 0x82, 0x47,
-    0xba, 0xb6, 0x83, 0xb1, 0x38, 0x8d, 0x80, 0x95,
-    0x20, 0x8e, 0x45, 0x4f, 0x30, 0x90, 0x0e, 0x01,
-    0x04, 0x84, 0xbd, 0xa0, 0x80, 0x40, 0x9f, 0x8d,
-    0x41, 0x6f, 0x80, 0xbc, 0x83, 0x41, 0xfa, 0x84,
-    0x43, 0xdf, 0x86, 0xec, 0x87, 0x4a, 0xae, 0x84,
-    0x6c, 0x0c, 0x00, 0x80, 0x9d, 0xdf, 0xff, 0x40,
-    0xef,
+    0x41, 0x82, 0x81, 0x40, 0x98, 0x8a, 0xb0, 0x83,
+    0xfa, 0x80, 0xb5, 0x8e, 0xa8, 0x01, 0x81, 0x89,
+    0x82, 0xb0, 0x19, 0x09, 0x03, 0x80, 0x89, 0x80,
+    0xb1, 0x82, 0xa3, 0x20, 0x87, 0xbd, 0x80, 0x8b,
+    0x81, 0xb3, 0x88, 0x89, 0x19, 0x80, 0xde, 0x11,
+    0x00, 0x0d, 0x80, 0x40, 0x9f, 0x02, 0x87, 0x94,
+    0x81, 0xb8, 0x0a, 0x80, 0xa4, 0x32, 0x84, 0x40,
+    0xc2, 0x39, 0x10, 0x80, 0x96, 0x80, 0xd3, 0x28,
+    0x03, 0x08, 0x81, 0x40, 0xed, 0x1d, 0x08, 0x81,
+    0x9a, 0x81, 0xd4, 0x39, 0x00, 0x81, 0xe9, 0x00,
+    0x01, 0x28, 0x80, 0xe4, 0x11, 0x18, 0x84, 0x41,
+    0x02, 0x88, 0x01, 0x40, 0xff, 0x08, 0x03, 0x80,
+    0x40, 0x8f, 0x19, 0x0b, 0x80, 0x9f, 0x89, 0xa7,
+    0x29, 0x1f, 0x80, 0x88, 0x29, 0x82, 0xad, 0x8c,
+    0x01, 0x41, 0x95, 0x30, 0x28, 0x80, 0xd1, 0x95,
+    0x0e, 0x01, 0x01, 0xf9, 0x2a, 0x00, 0x08, 0x30,
+    0x80, 0xc7, 0x0a, 0x00, 0x80, 0x41, 0x5a, 0x81,
+    0x55, 0x3a, 0x88, 0x60, 0x36, 0xb6, 0x84, 0xba,
+    0x86, 0x88, 0x83, 0x44, 0x0a, 0x80, 0xbe, 0x90,
+    0xbf, 0x08, 0x81, 0x60, 0x40, 0x0a, 0x18, 0x30,
+    0x81, 0x4c, 0x9d, 0x08, 0x83, 0x52, 0x5b, 0xad,
+    0x81, 0x96, 0x42, 0x1f, 0x82, 0x88, 0x8f, 0x0e,
+    0x9d, 0x83, 0x40, 0x93, 0x82, 0x47, 0xba, 0xb6,
+    0x83, 0xb1, 0x38, 0x8d, 0x80, 0x95, 0x20, 0x8e,
+    0x45, 0x4f, 0x30, 0x90, 0x0e, 0x01, 0x04, 0x41,
+    0x04, 0x8d, 0x41, 0x6f, 0x80, 0xbc, 0x83, 0x45,
+    0xdf, 0x86, 0xec, 0x87, 0x4a, 0xae, 0x84, 0x6c,
+    0x0c, 0x00, 0x80, 0x9d, 0xdf, 0xff, 0x40, 0xef,
 };
 
 static const uint8_t unicode_prop_Case_Ignorable_index[69] = {
@@ -296,13 +292,13 @@
     0x10, 0x80, 0xd4, 0x17, 0x40, 0xcf, 0x1a, 0x20,
     0xf5, 0x1c, 0x00, 0x80, 0x20, 0x00, 0x16, 0xa0,
     0x00, 0xc6, 0xa8, 0x00, 0xc2, 0xaa, 0x60, 0x56,
-    0xfe, 0x20, 0xb1, 0x07, 0x01, 0x75, 0x10, 0x01,
-    0xeb, 0x12, 0x21, 0x41, 0x16, 0x01, 0x5c, 0x1a,
-    0x01, 0x43, 0x1f, 0x01, 0x2e, 0xcf, 0x41, 0x25,
-    0xe0, 0x01, 0xf0, 0x01, 0x0e,
+    0xfe, 0x20, 0xb1, 0x07, 0x01, 0x82, 0x10, 0x21,
+    0x02, 0x13, 0x21, 0xb8, 0x16, 0x61, 0x97, 0x1a,
+    0x01, 0x37, 0x6b, 0x21, 0x8c, 0xd1, 0x01, 0xd7,
+    0xe8, 0x41, 0xf0, 0x01, 0x0e,
 };
 
-static const uint8_t unicode_prop_ID_Start_table[1100] = {
+static const uint8_t unicode_prop_ID_Start_table[1079] = {
     0xc0, 0x99, 0x85, 0x99, 0xae, 0x80, 0x89, 0x03,
     0x04, 0x96, 0x80, 0x9e, 0x80, 0x41, 0xc9, 0x83,
     0x8b, 0x8d, 0x26, 0x00, 0x80, 0x40, 0x80, 0x20,
@@ -396,54 +392,51 @@
     0xad, 0x94, 0x9a, 0x96, 0x8b, 0xb4, 0xb8, 0x09,
     0x80, 0x8c, 0xac, 0x9f, 0x98, 0x99, 0xa3, 0x9c,
     0x01, 0x07, 0xa2, 0x10, 0x8b, 0xaf, 0x8d, 0x83,
-    0x94, 0x00, 0x80, 0xa2, 0x91, 0x80, 0x98, 0x92,
-    0x81, 0xbe, 0x30, 0x00, 0x18, 0x8e, 0x80, 0x89,
-    0x86, 0xae, 0xa5, 0x39, 0x09, 0x95, 0x06, 0x01,
-    0x04, 0x10, 0x91, 0x80, 0x8b, 0x84, 0x40, 0x9d,
-    0xb4, 0x91, 0x83, 0x93, 0x82, 0x9d, 0xaf, 0x93,
-    0x08, 0x80, 0x40, 0xb7, 0xae, 0xa8, 0x83, 0xa3,
-    0xaf, 0x93, 0x80, 0xba, 0xaa, 0x8c, 0x80, 0xc6,
-    0x9a, 0xa4, 0x86, 0x40, 0xb8, 0xab, 0xf3, 0xbf,
-    0x9e, 0x39, 0x01, 0x38, 0x08, 0x97, 0x8e, 0x00,
-    0x80, 0xdd, 0x39, 0xa6, 0x8f, 0x00, 0x80, 0x9b,
-    0x80, 0x89, 0xa7, 0x30, 0x94, 0x80, 0x8a, 0xad,
-    0x92, 0x80, 0x91, 0xc8, 0x41, 0x06, 0x88, 0x80,
-    0xa4, 0x90, 0x80, 0xb0, 0x9d, 0xef, 0x30, 0x08,
-    0xa5, 0x94, 0x80, 0x98, 0x28, 0x08, 0x9f, 0x8d,
-    0x80, 0x41, 0x46, 0x92, 0x8e, 0x00, 0x8c, 0x80,
-    0xa1, 0xfb, 0x80, 0xce, 0x43, 0x99, 0xe5, 0xee,
-    0x90, 0x40, 0xc3, 0x4a, 0x4b, 0xe0, 0x8e, 0x44,
-    0x2f, 0x90, 0x85, 0x4f, 0xb8, 0x42, 0x46, 0x60,
+    0x94, 0x00, 0x80, 0xa2, 0x91, 0x80, 0x98, 0xd3,
+    0x30, 0x00, 0x18, 0x8e, 0x80, 0x89, 0x86, 0xae,
+    0xa5, 0x39, 0x09, 0x95, 0x06, 0x01, 0x04, 0x10,
+    0x91, 0x80, 0x8b, 0x84, 0x40, 0x9d, 0xb4, 0x91,
+    0x83, 0x93, 0x82, 0x9d, 0xaf, 0x93, 0x08, 0x80,
+    0x40, 0xb7, 0xae, 0xa8, 0x83, 0xa3, 0xaf, 0x93,
+    0x80, 0xba, 0xaa, 0x8c, 0x80, 0xc6, 0x9a, 0xa4,
+    0x86, 0x40, 0xb8, 0xab, 0xf3, 0xbf, 0x9e, 0x39,
+    0x01, 0x38, 0x08, 0x97, 0x8e, 0x00, 0x80, 0xdd,
+    0x39, 0xa6, 0x8f, 0x00, 0x80, 0x9b, 0x80, 0x89,
+    0xa7, 0x30, 0x94, 0x80, 0x8a, 0xad, 0x92, 0x80,
+    0x91, 0xc8, 0x41, 0x06, 0x88, 0x80, 0xa4, 0x90,
+    0x80, 0xb0, 0x9d, 0xef, 0x30, 0x08, 0xa5, 0x94,
+    0x80, 0x98, 0x28, 0x08, 0x9f, 0x8d, 0x80, 0x41,
+    0x46, 0x92, 0x40, 0xbc, 0x80, 0xce, 0x43, 0x99,
+    0xe5, 0xee, 0x90, 0x40, 0xc3, 0x4a, 0x4b, 0xe0,
+    0x8e, 0x44, 0x2e, 0x4f, 0xd0, 0x42, 0x46, 0x60,
     0x21, 0xb8, 0x42, 0x38, 0x86, 0x9e, 0x90, 0xce,
     0x90, 0x9d, 0x91, 0xaf, 0x8f, 0x83, 0x9e, 0x94,
     0x84, 0x92, 0x42, 0xaf, 0xbf, 0xff, 0xca, 0x20,
     0xc1, 0x8c, 0xbf, 0x08, 0x80, 0x9b, 0x57, 0xf7,
     0x87, 0x44, 0xd5, 0xa9, 0x88, 0x60, 0x22, 0xe6,
-    0x18, 0x30, 0x08, 0x41, 0x22, 0x8e, 0x80, 0x9c,
-    0x11, 0x80, 0x8d, 0x1f, 0x41, 0x8b, 0x49, 0x03,
-    0xea, 0x84, 0x8c, 0x82, 0x88, 0x86, 0x89, 0x57,
-    0x65, 0xd4, 0x80, 0xc6, 0x01, 0x08, 0x09, 0x0b,
-    0x80, 0x8b, 0x00, 0x06, 0x80, 0xc0, 0x03, 0x0f,
-    0x06, 0x80, 0x9b, 0x03, 0x04, 0x00, 0x16, 0x80,
-    0x41, 0x53, 0x81, 0x98, 0x80, 0x98, 0x80, 0x9e,
-    0x80, 0x98, 0x80, 0x9e, 0x80, 0x98, 0x80, 0x9e,
-    0x80, 0x98, 0x80, 0x9e, 0x80, 0x98, 0x07, 0x47,
-    0x33, 0x9e, 0x2d, 0x41, 0x04, 0xbd, 0x40, 0x91,
-    0xac, 0x89, 0x86, 0x8f, 0x80, 0x41, 0x40, 0x9d,
-    0x91, 0xab, 0x41, 0xe3, 0x9b, 0x42, 0xf3, 0x30,
-    0x18, 0x08, 0x8e, 0x80, 0x40, 0xc4, 0xba, 0xc3,
-    0x30, 0x44, 0xb3, 0x18, 0x9a, 0x01, 0x00, 0x08,
-    0x80, 0x89, 0x03, 0x00, 0x00, 0x28, 0x18, 0x00,
-    0x00, 0x02, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00,
-    0x00, 0x01, 0x00, 0x0b, 0x06, 0x03, 0x03, 0x00,
-    0x80, 0x89, 0x80, 0x90, 0x22, 0x04, 0x80, 0x90,
-    0x51, 0x43, 0x60, 0xa6, 0xdf, 0x9f, 0x50, 0x39,
-    0x85, 0x40, 0xdd, 0x81, 0x56, 0x81, 0x8d, 0x5d,
-    0x30, 0x4c, 0x1e, 0x42, 0x1d, 0x45, 0xe1, 0x53,
-    0x4a, 0x84, 0x50, 0x5f,
+    0x18, 0x30, 0x08, 0x41, 0x22, 0xac, 0x82, 0x90,
+    0x1f, 0x41, 0x8b, 0x49, 0x03, 0xea, 0x84, 0x8c,
+    0x82, 0x88, 0x86, 0x89, 0x57, 0x65, 0xd4, 0x80,
+    0xc6, 0x01, 0x08, 0x09, 0x0b, 0x80, 0x8b, 0x00,
+    0x06, 0x80, 0xc0, 0x03, 0x0f, 0x06, 0x80, 0x9b,
+    0x03, 0x04, 0x00, 0x16, 0x80, 0x41, 0x53, 0x81,
+    0x98, 0x80, 0x98, 0x80, 0x9e, 0x80, 0x98, 0x80,
+    0x9e, 0x80, 0x98, 0x80, 0x9e, 0x80, 0x98, 0x80,
+    0x9e, 0x80, 0x98, 0x07, 0x47, 0x33, 0x9e, 0x41,
+    0xe0, 0xac, 0x89, 0x86, 0x8f, 0x80, 0x41, 0x40,
+    0x9d, 0x91, 0xab, 0x44, 0xf3, 0x30, 0x18, 0x08,
+    0x8e, 0x80, 0x40, 0xc4, 0xba, 0xc3, 0x30, 0x44,
+    0xb3, 0x18, 0x9a, 0x01, 0x00, 0x08, 0x80, 0x89,
+    0x03, 0x00, 0x00, 0x28, 0x18, 0x00, 0x00, 0x02,
+    0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x01,
+    0x00, 0x0b, 0x06, 0x03, 0x03, 0x00, 0x80, 0x89,
+    0x80, 0x90, 0x22, 0x04, 0x80, 0x90, 0x51, 0x43,
+    0x60, 0xa6, 0xdf, 0x9f, 0x50, 0x38, 0x86, 0x40,
+    0xdd, 0x81, 0x56, 0x81, 0x8d, 0x5d, 0x30, 0x4c,
+    0x1e, 0x42, 0x1d, 0x45, 0xe1, 0x53, 0x4a,
 };
 
-static const uint8_t unicode_prop_ID_Start_index[105] = {
+static const uint8_t unicode_prop_ID_Start_index[102] = {
     0xf6, 0x03, 0x20, 0xa6, 0x07, 0x00, 0xa9, 0x09,
     0x20, 0xb1, 0x0a, 0x00, 0xba, 0x0b, 0x20, 0x3b,
     0x0d, 0x20, 0xc7, 0x0e, 0x20, 0x49, 0x12, 0x00,
@@ -452,15 +445,14 @@
     0x32, 0x00, 0xda, 0xa7, 0x00, 0x4c, 0xaa, 0x20,
     0xc7, 0xd7, 0x20, 0xfc, 0xfd, 0x20, 0x9d, 0x02,
     0x21, 0x96, 0x05, 0x01, 0xf3, 0x08, 0x01, 0xb3,
-    0x0c, 0x21, 0x73, 0x11, 0x61, 0x34, 0x13, 0x01,
-    0x1b, 0x17, 0x21, 0x8a, 0x1a, 0x01, 0x34, 0x1f,
-    0x21, 0xbf, 0x6a, 0x01, 0x23, 0xb1, 0xa1, 0xad,
-    0xd4, 0x01, 0x6f, 0xd7, 0x01, 0xff, 0xe7, 0x61,
-    0x5e, 0xee, 0x01, 0xe1, 0xeb, 0x22, 0xb0, 0x23,
-    0x03,
+    0x0c, 0x21, 0x73, 0x11, 0x61, 0x3e, 0x13, 0x01,
+    0x47, 0x17, 0x21, 0x9e, 0x1a, 0x01, 0x9a, 0x23,
+    0x01, 0x78, 0x6b, 0x01, 0xfc, 0xb2, 0x61, 0x3a,
+    0xd5, 0x01, 0x2d, 0xe1, 0x41, 0x33, 0xee, 0x01,
+    0xe0, 0xa6, 0x62, 0x4b, 0x13, 0x03,
 };
 
-static const uint8_t unicode_prop_ID_Continue1_table[660] = {
+static const uint8_t unicode_prop_ID_Continue1_table[640] = {
     0xaf, 0x89, 0xa4, 0x80, 0xd6, 0x80, 0x42, 0x47,
     0xef, 0x96, 0x80, 0x40, 0xfa, 0x84, 0x41, 0x08,
     0xac, 0x00, 0x01, 0x01, 0x00, 0xc7, 0x8a, 0xaf,
@@ -478,88 +470,85 @@
     0xba, 0x22, 0x10, 0x83, 0x88, 0x80, 0x8d, 0x89,
     0x8f, 0x84, 0xb6, 0x00, 0x30, 0x10, 0x1e, 0x81,
     0x8a, 0x09, 0x89, 0x90, 0x82, 0xb7, 0x00, 0x30,
-    0x10, 0x1e, 0x81, 0x8a, 0x09, 0x89, 0x10, 0x8b,
-    0x83, 0xb6, 0x08, 0x30, 0x10, 0x83, 0x88, 0x80,
-    0x89, 0x09, 0x89, 0x90, 0x82, 0xc5, 0x03, 0x28,
-    0x00, 0x3d, 0x89, 0x09, 0xbc, 0x01, 0x86, 0x8b,
-    0x38, 0x89, 0xd6, 0x01, 0x88, 0x8a, 0x30, 0x89,
-    0xbd, 0x0d, 0x89, 0x8a, 0x00, 0x00, 0x03, 0x81,
-    0xb0, 0x93, 0x01, 0x84, 0x8a, 0x80, 0xa3, 0x88,
-    0x80, 0xe3, 0x93, 0x80, 0x89, 0x8b, 0x1b, 0x10,
-    0x11, 0x32, 0x83, 0x8c, 0x8b, 0x80, 0x8e, 0x42,
-    0xbe, 0x82, 0x88, 0x88, 0x43, 0x9f, 0x83, 0x9b,
-    0x82, 0x9c, 0x81, 0x9d, 0x81, 0xbf, 0x9f, 0x88,
-    0x01, 0x89, 0xa0, 0x10, 0x8a, 0x40, 0x8e, 0x80,
-    0xf5, 0x8b, 0x83, 0x8b, 0x89, 0x89, 0xff, 0x8a,
-    0xbb, 0x84, 0xb8, 0x89, 0x80, 0x9c, 0x81, 0x8a,
-    0x85, 0x89, 0x95, 0x8d, 0x80, 0x8f, 0xb0, 0x84,
-    0xae, 0x90, 0x8a, 0x89, 0x90, 0x88, 0x8b, 0x82,
-    0x9d, 0x8c, 0x81, 0x89, 0xab, 0x8d, 0xaf, 0x93,
-    0x87, 0x89, 0x85, 0x89, 0xf5, 0x10, 0x94, 0x18,
-    0x28, 0x0a, 0x40, 0xc5, 0xbf, 0x42, 0x3e, 0x81,
-    0x92, 0x80, 0xfa, 0x8c, 0x18, 0x82, 0x8b, 0x4b,
-    0xfd, 0x82, 0x40, 0x8c, 0x80, 0xdf, 0x9f, 0x42,
-    0x29, 0x85, 0xe8, 0x81, 0x60, 0x75, 0x84, 0x89,
-    0xc4, 0x03, 0x89, 0x9f, 0x81, 0xcf, 0x81, 0x41,
-    0x0f, 0x02, 0x03, 0x80, 0x96, 0x23, 0x80, 0xd2,
-    0x81, 0xb1, 0x91, 0x89, 0x89, 0x85, 0x91, 0x8c,
-    0x8a, 0x9b, 0x87, 0x98, 0x8c, 0xab, 0x83, 0xae,
-    0x8d, 0x8e, 0x89, 0x8a, 0x80, 0x89, 0x89, 0xae,
-    0x8d, 0x8b, 0x07, 0x09, 0x89, 0xa0, 0x82, 0xb1,
-    0x00, 0x11, 0x0c, 0x08, 0x80, 0xa8, 0x24, 0x81,
-    0x40, 0xeb, 0x38, 0x09, 0x89, 0x60, 0x4f, 0x23,
-    0x80, 0x42, 0xe0, 0x8f, 0x8f, 0x8f, 0x11, 0x97,
-    0x82, 0x40, 0xbf, 0x89, 0xa4, 0x80, 0x42, 0xbc,
-    0x80, 0x40, 0xe1, 0x80, 0x40, 0x94, 0x84, 0x41,
-    0x24, 0x89, 0x45, 0x56, 0x10, 0x0c, 0x83, 0xa7,
-    0x13, 0x80, 0x40, 0xa4, 0x81, 0x42, 0x3c, 0x1f,
-    0x89, 0x41, 0x70, 0x81, 0xcf, 0x82, 0xc5, 0x8a,
-    0xb0, 0x83, 0xf9, 0x82, 0xb4, 0x8e, 0x9e, 0x8a,
-    0x09, 0x89, 0x83, 0xac, 0x8a, 0x30, 0xac, 0x89,
-    0x2a, 0xa3, 0x8d, 0x80, 0x89, 0x21, 0xab, 0x80,
-    0x8b, 0x82, 0xaf, 0x8d, 0x3b, 0x80, 0x8b, 0xd1,
-    0x8b, 0x28, 0x08, 0x40, 0x9c, 0x8b, 0x84, 0x89,
-    0x2b, 0xb6, 0x08, 0x31, 0x09, 0x82, 0x88, 0x80,
-    0x89, 0x09, 0x32, 0x84, 0x40, 0xbf, 0x91, 0x88,
-    0x89, 0x18, 0xd0, 0x93, 0x8b, 0x89, 0x40, 0xd4,
-    0x31, 0x88, 0x9a, 0x81, 0xd1, 0x90, 0x8e, 0x89,
-    0xd0, 0x8c, 0x87, 0x89, 0xd2, 0x8e, 0x83, 0x89,
-    0x40, 0xf1, 0x8e, 0x40, 0xa4, 0x89, 0xc5, 0x28,
-    0x09, 0x18, 0x00, 0x81, 0x8b, 0x89, 0xf6, 0x31,
-    0x32, 0x80, 0x9b, 0x89, 0xa7, 0x30, 0x1f, 0x80,
-    0x88, 0x8a, 0xad, 0x8f, 0x41, 0x94, 0x38, 0x87,
-    0x8f, 0x89, 0xb7, 0x95, 0x80, 0x8d, 0xf9, 0x2a,
-    0x00, 0x08, 0x30, 0x07, 0x89, 0xaf, 0x20, 0x08,
-    0x27, 0x89, 0x41, 0x48, 0x83, 0x88, 0x08, 0x80,
-    0xaf, 0x32, 0x84, 0x8c, 0x89, 0x54, 0xe5, 0x05,
-    0x8e, 0x60, 0x36, 0x09, 0x89, 0xd5, 0x89, 0xa5,
-    0x84, 0xba, 0x86, 0x98, 0x89, 0x43, 0xf4, 0x00,
-    0xb6, 0x33, 0xd0, 0x80, 0x8a, 0x81, 0x60, 0x4c,
-    0xaa, 0x81, 0x52, 0x60, 0xad, 0x81, 0x96, 0x42,
-    0x1d, 0x22, 0x2f, 0x39, 0x86, 0x9d, 0x83, 0x40,
-    0x93, 0x82, 0x45, 0x88, 0xb1, 0x41, 0xff, 0xb6,
-    0x83, 0xb1, 0x38, 0x8d, 0x80, 0x95, 0x20, 0x8e,
-    0x45, 0x4f, 0x30, 0x90, 0x0e, 0x01, 0x04, 0xe3,
-    0x80, 0x40, 0x9f, 0x86, 0x88, 0x89, 0x41, 0x63,
-    0x80, 0xbc, 0x8d, 0x41, 0xf1, 0x8d, 0x43, 0xd5,
-    0x86, 0xec, 0x34, 0x89, 0x52, 0x95, 0x89, 0x6c,
-    0x05, 0x05, 0x40, 0xef,
+    0x10, 0x1e, 0x81, 0x8a, 0x09, 0x89, 0x8f, 0x83,
+    0xb6, 0x08, 0x30, 0x10, 0x83, 0x88, 0x80, 0x89,
+    0x09, 0x89, 0x90, 0x82, 0xc5, 0x03, 0x28, 0x00,
+    0x3d, 0x89, 0x09, 0xbc, 0x01, 0x86, 0x8b, 0x38,
+    0x89, 0xd6, 0x01, 0x88, 0x8a, 0x29, 0x89, 0xbd,
+    0x0d, 0x89, 0x8a, 0x00, 0x00, 0x03, 0x81, 0xb0,
+    0x93, 0x01, 0x84, 0x8a, 0x80, 0xa3, 0x88, 0x80,
+    0xe3, 0x93, 0x80, 0x89, 0x8b, 0x1b, 0x10, 0x11,
+    0x32, 0x83, 0x8c, 0x8b, 0x80, 0x8e, 0x42, 0xbe,
+    0x82, 0x88, 0x88, 0x43, 0x9f, 0x83, 0x9b, 0x82,
+    0x9c, 0x81, 0x9d, 0x81, 0xbf, 0x9f, 0x88, 0x01,
+    0x89, 0xa0, 0x10, 0x8a, 0x40, 0x8e, 0x80, 0xf5,
+    0x8b, 0x83, 0x8b, 0x89, 0x89, 0xff, 0x8a, 0xbb,
+    0x84, 0xb8, 0x89, 0x80, 0x9c, 0x81, 0x8a, 0x85,
+    0x89, 0x95, 0x8d, 0x80, 0x8f, 0xb0, 0x84, 0xae,
+    0x90, 0x8a, 0x89, 0x90, 0x88, 0x8b, 0x82, 0x9d,
+    0x8c, 0x81, 0x89, 0xab, 0x8d, 0xaf, 0x93, 0x87,
+    0x89, 0x85, 0x89, 0xf5, 0x10, 0x94, 0x18, 0x28,
+    0x0a, 0x40, 0xc5, 0xbf, 0x42, 0x3e, 0x81, 0x92,
+    0x80, 0xfa, 0x8c, 0x18, 0x82, 0x8b, 0x4b, 0xfd,
+    0x82, 0x40, 0x8c, 0x80, 0xdf, 0x9f, 0x42, 0x29,
+    0x85, 0xe8, 0x81, 0x60, 0x75, 0x84, 0x89, 0xc4,
+    0x03, 0x89, 0x9f, 0x81, 0xcf, 0x81, 0x41, 0x0f,
+    0x02, 0x03, 0x80, 0x96, 0x23, 0x80, 0xd2, 0x81,
+    0xb1, 0x91, 0x89, 0x89, 0x85, 0x91, 0x8c, 0x8a,
+    0x9b, 0x87, 0x98, 0x8c, 0xab, 0x83, 0xae, 0x8d,
+    0x8e, 0x89, 0x8a, 0x80, 0x89, 0x89, 0xae, 0x8d,
+    0x8b, 0x07, 0x09, 0x89, 0xa0, 0x82, 0xb1, 0x00,
+    0x11, 0x0c, 0x08, 0x80, 0xa8, 0x24, 0x81, 0x40,
+    0xeb, 0x38, 0x09, 0x89, 0x60, 0x4f, 0x23, 0x80,
+    0x42, 0xe0, 0x8f, 0x8f, 0x8f, 0x11, 0x97, 0x82,
+    0x40, 0xbf, 0x89, 0xa4, 0x80, 0x42, 0xbc, 0x80,
+    0x40, 0xe1, 0x80, 0x40, 0x94, 0x84, 0x41, 0x24,
+    0x89, 0x45, 0x56, 0x10, 0x0c, 0x83, 0xa7, 0x13,
+    0x80, 0x40, 0xa4, 0x81, 0x42, 0x3c, 0x1f, 0x89,
+    0x41, 0x70, 0x81, 0x40, 0x98, 0x8a, 0xb0, 0x83,
+    0xf9, 0x82, 0xb4, 0x8e, 0x9e, 0x8a, 0x09, 0x89,
+    0x83, 0xac, 0x8a, 0x30, 0xac, 0x89, 0x2a, 0xa3,
+    0x8d, 0x80, 0x89, 0x21, 0xab, 0x80, 0x8b, 0x82,
+    0xaf, 0x8d, 0x3b, 0x80, 0x8b, 0xd1, 0x8b, 0x28,
+    0x40, 0x9f, 0x8b, 0x84, 0x89, 0x2b, 0xb6, 0x08,
+    0x31, 0x09, 0x82, 0x88, 0x80, 0x89, 0x09, 0x32,
+    0x84, 0x40, 0xbf, 0x91, 0x88, 0x89, 0x18, 0xd0,
+    0x93, 0x8b, 0x89, 0x40, 0xd4, 0x31, 0x88, 0x9a,
+    0x81, 0xd1, 0x90, 0x8e, 0x89, 0xd0, 0x8c, 0x87,
+    0x89, 0xd2, 0x8e, 0x83, 0x89, 0x40, 0xf1, 0x8e,
+    0x40, 0xa4, 0x89, 0xc5, 0x28, 0x09, 0x18, 0x00,
+    0x81, 0x8b, 0x89, 0xf6, 0x31, 0x32, 0x80, 0x9b,
+    0x89, 0xa7, 0x30, 0x1f, 0x80, 0x88, 0x8a, 0xad,
+    0x8f, 0x41, 0x94, 0x38, 0x87, 0x8f, 0x89, 0xb7,
+    0x95, 0x80, 0x8d, 0xf9, 0x2a, 0x00, 0x08, 0x30,
+    0x07, 0x89, 0xaf, 0x20, 0x08, 0x27, 0x89, 0x41,
+    0x48, 0x83, 0x60, 0x4b, 0x68, 0x89, 0xd5, 0x89,
+    0xa5, 0x84, 0xba, 0x86, 0x98, 0x89, 0x43, 0xf4,
+    0x00, 0xb6, 0x33, 0xd0, 0x80, 0x8a, 0x81, 0x60,
+    0x4c, 0xaa, 0x81, 0x52, 0x60, 0xad, 0x81, 0x96,
+    0x42, 0x1d, 0x22, 0x2f, 0x39, 0x86, 0x9d, 0x83,
+    0x40, 0x93, 0x82, 0x45, 0x88, 0xb1, 0x41, 0xff,
+    0xb6, 0x83, 0xb1, 0x38, 0x8d, 0x80, 0x95, 0x20,
+    0x8e, 0x45, 0x4f, 0x30, 0x90, 0x0e, 0x01, 0x04,
+    0x41, 0x04, 0x86, 0x88, 0x89, 0x41, 0x63, 0x80,
+    0xbc, 0x8d, 0x45, 0xd5, 0x86, 0xec, 0x34, 0x89,
+    0x52, 0x95, 0x89, 0x6c, 0x05, 0x05, 0x40, 0xef,
 };
 
-static const uint8_t unicode_prop_ID_Continue1_index[63] = {
+static const uint8_t unicode_prop_ID_Continue1_index[60] = {
     0xfa, 0x06, 0x00, 0x70, 0x09, 0x00, 0xf0, 0x0a,
-    0x40, 0x57, 0x0c, 0x00, 0xf0, 0x0d, 0x60, 0xc7,
-    0x0f, 0x20, 0xea, 0x17, 0x40, 0x05, 0x1b, 0x00,
-    0x41, 0x20, 0x00, 0x0c, 0xa8, 0x80, 0x37, 0xaa,
-    0x20, 0x50, 0xfe, 0x20, 0x3a, 0x0d, 0x21, 0x74,
-    0x11, 0x01, 0x5a, 0x14, 0x21, 0x44, 0x19, 0x81,
-    0x5a, 0x1d, 0xa1, 0xf5, 0x6a, 0x21, 0x45, 0xd2,
-    0x41, 0xaf, 0xe2, 0x21, 0xf0, 0x01, 0x0e,
+    0x40, 0x57, 0x0c, 0x00, 0xf0, 0x0d, 0x40, 0xc7,
+    0x0f, 0x00, 0xea, 0x17, 0x20, 0x45, 0x1b, 0x20,
+    0x55, 0x20, 0x20, 0x0c, 0xa8, 0x60, 0x37, 0xaa,
+    0x00, 0x50, 0xfe, 0x00, 0x3a, 0x0d, 0x01, 0x83,
+    0x11, 0x01, 0xc4, 0x14, 0x21, 0x44, 0x19, 0x21,
+    0x5a, 0x1d, 0x41, 0x9f, 0xbc, 0x61, 0xb0, 0xda,
+    0x21, 0xf0, 0x01, 0x0e,
 };
 
 #ifdef CONFIG_ALL_UNICODE
 
-static const uint8_t unicode_cc_table[899] = {
+static const uint8_t unicode_cc_table[881] = {
     0xb2, 0xcf, 0xd4, 0x00, 0xe8, 0x03, 0xdc, 0x00,
     0xe8, 0x00, 0xd8, 0x04, 0xdc, 0x01, 0xca, 0x03,
     0xdc, 0x01, 0xca, 0x0a, 0xdc, 0x04, 0x01, 0x03,
@@ -642,40 +631,38 @@
     0xb6, 0x61, 0x00, 0xdc, 0x80, 0xc0, 0xa7, 0xc0,
     0x00, 0x01, 0x00, 0xdc, 0x83, 0x00, 0x09, 0xb0,
     0x74, 0xc0, 0x00, 0xdc, 0xb2, 0x0c, 0xc3, 0xb1,
-    0x52, 0xc1, 0xb0, 0x1f, 0x02, 0xdc, 0xb0, 0x15,
-    0x01, 0xdc, 0xc2, 0x00, 0xdc, 0xc0, 0x03, 0xdc,
-    0xb0, 0x00, 0xc0, 0x00, 0xdc, 0xc0, 0x00, 0xdc,
-    0xb0, 0x8f, 0x00, 0x09, 0xa8, 0x00, 0x09, 0x8d,
-    0x00, 0x09, 0xb0, 0x08, 0x00, 0x09, 0x00, 0x07,
-    0xb0, 0x14, 0xc2, 0xaf, 0x01, 0x09, 0xb0, 0x0d,
-    0x00, 0x07, 0xb0, 0x1b, 0x00, 0x09, 0x88, 0x00,
-    0x07, 0xb0, 0x39, 0x00, 0x09, 0x00, 0x07, 0xb0,
-    0x81, 0x00, 0x07, 0x00, 0x09, 0xb0, 0x1f, 0x01,
-    0x07, 0x8f, 0x00, 0x09, 0x97, 0xc6, 0x82, 0xc4,
-    0xb0, 0x9c, 0x00, 0x09, 0x82, 0x00, 0x07, 0x96,
-    0xc0, 0xb0, 0x32, 0x00, 0x09, 0x00, 0x07, 0xb0,
-    0xca, 0x00, 0x09, 0x00, 0x07, 0xb0, 0x4d, 0x00,
-    0x09, 0xb0, 0x45, 0x00, 0x09, 0x00, 0x07, 0xb0,
-    0x42, 0x00, 0x09, 0xb0, 0xdc, 0x00, 0x09, 0x00,
-    0x07, 0xb0, 0xd1, 0x01, 0x09, 0x83, 0x00, 0x07,
-    0xb0, 0x6b, 0x00, 0x09, 0xb0, 0x22, 0x00, 0x09,
-    0x91, 0x00, 0x09, 0xb0, 0x20, 0x00, 0x09, 0xb1,
-    0x74, 0x00, 0x09, 0xb0, 0xd1, 0x00, 0x07, 0x80,
-    0x01, 0x09, 0xb0, 0x20, 0x00, 0x09, 0xb1, 0x78,
-    0x01, 0x09, 0xb8, 0x43, 0x7c, 0x04, 0x01, 0xb0,
+    0x52, 0xc1, 0xb0, 0x68, 0x01, 0xdc, 0xc2, 0x00,
+    0xdc, 0xc0, 0x03, 0xdc, 0xb0, 0x00, 0xc0, 0x00,
+    0xdc, 0xc0, 0x00, 0xdc, 0xb0, 0x8f, 0x00, 0x09,
+    0xa8, 0x00, 0x09, 0x8d, 0x00, 0x09, 0xb0, 0x08,
+    0x00, 0x09, 0x00, 0x07, 0xb0, 0x14, 0xc2, 0xaf,
+    0x01, 0x09, 0xb0, 0x0d, 0x00, 0x07, 0xb0, 0x1b,
+    0x00, 0x09, 0x88, 0x00, 0x07, 0xb0, 0x39, 0x00,
+    0x09, 0x00, 0x07, 0xb0, 0x81, 0x00, 0x07, 0x00,
+    0x09, 0xb0, 0x1f, 0x01, 0x07, 0x8f, 0x00, 0x09,
+    0x97, 0xc6, 0x82, 0xc4, 0xb0, 0x9c, 0x00, 0x09,
+    0x82, 0x00, 0x07, 0x96, 0xc0, 0xb0, 0x32, 0x00,
+    0x09, 0x00, 0x07, 0xb0, 0xca, 0x00, 0x09, 0x00,
+    0x07, 0xb0, 0x4d, 0x00, 0x09, 0xb0, 0x45, 0x00,
+    0x09, 0x00, 0x07, 0xb0, 0x42, 0x00, 0x09, 0xb0,
+    0xdc, 0x00, 0x09, 0x00, 0x07, 0xb0, 0xd1, 0x01,
+    0x09, 0x83, 0x00, 0x07, 0xb0, 0x6b, 0x00, 0x09,
+    0xb0, 0x22, 0x00, 0x09, 0x91, 0x00, 0x09, 0xb0,
+    0x20, 0x00, 0x09, 0xb1, 0x74, 0x00, 0x09, 0xb0,
+    0xd1, 0x00, 0x07, 0x80, 0x01, 0x09, 0xb0, 0x20,
+    0x00, 0x09, 0xb8, 0x45, 0x27, 0x04, 0x01, 0xb0,
     0x0a, 0xc6, 0xb4, 0x88, 0x01, 0x06, 0xb8, 0x44,
     0x7b, 0x00, 0x01, 0xb8, 0x0c, 0x95, 0x01, 0xd8,
     0x02, 0x01, 0x82, 0x00, 0xe2, 0x04, 0xd8, 0x87,
     0x07, 0xdc, 0x81, 0xc4, 0x01, 0xdc, 0x9d, 0xc3,
     0xb0, 0x63, 0xc2, 0xb8, 0x05, 0x8a, 0xc6, 0x80,
     0xd0, 0x81, 0xc6, 0x80, 0xc1, 0x80, 0xc4, 0xb0,
-    0x33, 0xc0, 0xb0, 0x6f, 0xc6, 0xb1, 0x46, 0xc0,
-    0xb0, 0x0c, 0xc3, 0xb1, 0xcb, 0x01, 0xe8, 0x00,
-    0xdc, 0xc0, 0xb3, 0xaf, 0x06, 0xdc, 0xb0, 0x3c,
-    0xc5, 0x00, 0x07,
+    0xd4, 0xc6, 0xb1, 0x46, 0xc0, 0xb0, 0x0c, 0xc3,
+    0xb5, 0xaf, 0x06, 0xdc, 0xb0, 0x3c, 0xc5, 0x00,
+    0x07,
 };
 
-static const uint8_t unicode_cc_index[87] = {
+static const uint8_t unicode_cc_index[84] = {
     0x4d, 0x03, 0x00, 0x97, 0x05, 0x20, 0xc6, 0x05,
     0x00, 0xe7, 0x06, 0x00, 0x45, 0x07, 0x00, 0x9c,
     0x08, 0x00, 0x4d, 0x09, 0x00, 0x3c, 0x0b, 0x00,
@@ -683,13 +670,13 @@
     0x20, 0x3a, 0x19, 0x00, 0xcb, 0x1a, 0x20, 0xd3,
     0x1c, 0x00, 0xcf, 0x1d, 0x00, 0xe2, 0x20, 0x00,
     0x2e, 0x30, 0x20, 0x2b, 0xa9, 0x20, 0xed, 0xab,
-    0x00, 0x39, 0x0a, 0x01, 0x51, 0x0f, 0x01, 0x73,
-    0x11, 0x01, 0x75, 0x13, 0x01, 0x2b, 0x17, 0x21,
-    0x3f, 0x1c, 0x21, 0x9e, 0xbc, 0x21, 0x08, 0xe0,
-    0x01, 0x44, 0xe9, 0x01, 0x4b, 0xe9, 0x01,
+    0x00, 0x39, 0x0a, 0x01, 0x84, 0x0f, 0x21, 0xc0,
+    0x11, 0x01, 0x43, 0x14, 0x01, 0x39, 0x18, 0x21,
+    0x42, 0x1d, 0x21, 0x67, 0xd1, 0x01, 0x30, 0xe1,
+    0x21, 0x4b, 0xe9, 0x01,
 };
 
-static const uint32_t unicode_decomp_table1[699] = {
+static const uint32_t unicode_decomp_table1[693] = {
     0x00280081, 0x002a0097, 0x002a8081, 0x002bc097,
     0x002c8115, 0x002d0097, 0x002d4081, 0x002e0097,
     0x002e4115, 0x002f0199, 0x00302016, 0x00400842,
@@ -853,21 +840,20 @@
     0x75e24081, 0x75e2832d, 0x75e4089f, 0x75e84081,
     0x75e8839f, 0x75ea4081, 0x75ea8c9f, 0x75f0c081,
     0x75f1042d, 0x75f3851f, 0x75f6051f, 0x75f8851f,
-    0x75fb051f, 0x75fd851f, 0x780c049f, 0x780e419f,
-    0x780f059f, 0x7811c203, 0x7812d0ad, 0x781b0103,
-    0x7b80022d, 0x7b814dad, 0x7b884203, 0x7b89c081,
-    0x7b8a452d, 0x7b8d0403, 0x7b908081, 0x7b91dc03,
-    0x7ba0052d, 0x7ba2c8ad, 0x7ba84483, 0x7baac8ad,
-    0x7c400097, 0x7c404521, 0x7c440d25, 0x7c4a8087,
-    0x7c4ac115, 0x7c4b4117, 0x7c4c0d1f, 0x7c528217,
-    0x7c538099, 0x7c53c097, 0x7c5a8197, 0x7c640097,
-    0x7c80012f, 0x7c808081, 0x7c841603, 0x7c9004c1,
-    0x7c940103, 0x7efc051f, 0xbe0001ac, 0xbe00d110,
-    0xbe0947ac, 0xbe0d3910, 0xbe29872c, 0xbe2d022c,
-    0xbe2e3790, 0xbe49ff90, 0xbe69bc10,
+    0x75fb051f, 0x75fd851f, 0x7b80022d, 0x7b814dad,
+    0x7b884203, 0x7b89c081, 0x7b8a452d, 0x7b8d0403,
+    0x7b908081, 0x7b91dc03, 0x7ba0052d, 0x7ba2c8ad,
+    0x7ba84483, 0x7baac8ad, 0x7c400097, 0x7c404521,
+    0x7c440d25, 0x7c4a8087, 0x7c4ac115, 0x7c4b4117,
+    0x7c4c0d1f, 0x7c528217, 0x7c538099, 0x7c53c097,
+    0x7c5a8197, 0x7c640097, 0x7c80012f, 0x7c808081,
+    0x7c841603, 0x7c9004c1, 0x7c940103, 0x7efc051f,
+    0xbe0001ac, 0xbe00d110, 0xbe0947ac, 0xbe0d3910,
+    0xbe29872c, 0xbe2d022c, 0xbe2e3790, 0xbe49ff90,
+    0xbe69bc10,
 };
 
-static const uint16_t unicode_decomp_table2[699] = {
+static const uint16_t unicode_decomp_table2[693] = {
     0x0020, 0x0000, 0x0061, 0x0002, 0x0004, 0x0006, 0x03bc, 0x0008,
     0x000a, 0x000c, 0x0015, 0x0095, 0x00a5, 0x00b9, 0x00c1, 0x00c3,
     0x00c7, 0x00cb, 0x00d1, 0x00d7, 0x00dd, 0x00e0, 0x00e6, 0x00f8,
@@ -949,16 +935,15 @@
     0x2207, 0x1dc8, 0x2202, 0x1dca, 0x1dd2, 0x03f4, 0x1dd4, 0x2207,
     0x1dd6, 0x2202, 0x1dd8, 0x1de0, 0x03f4, 0x1de2, 0x2207, 0x1de4,
     0x2202, 0x1de6, 0x1dee, 0x03f4, 0x1df0, 0x2207, 0x1df2, 0x2202,
-    0x1df4, 0x1dfe, 0x1e00, 0x1e02, 0x1e04, 0x1e06, 0x1e08, 0x1e0a,
-    0x1e0c, 0x1e0e, 0x1e16, 0x1e39, 0x1e3d, 0x1e43, 0x1e60, 0x062d,
-    0x1e68, 0x1e74, 0x062c, 0x1e84, 0x1ef4, 0x1f00, 0x1f13, 0x1f25,
-    0x1f38, 0x1f3a, 0x1f3e, 0x1f44, 0x1f4a, 0x1f4c, 0x1f50, 0x1f52,
-    0x1f5a, 0x1f5d, 0x1f5f, 0x1f65, 0x1f67, 0x30b5, 0x1f6d, 0x1fc5,
-    0x1fdb, 0x1fdf, 0x1fe1, 0x1fe6, 0x2033, 0x2044, 0x2145, 0x2155,
-    0x215b, 0x2255, 0x2373,
+    0x1df4, 0x1dfe, 0x1e00, 0x1e02, 0x1e04, 0x1e06, 0x1e08, 0x1e0e,
+    0x1e2b, 0x062d, 0x1e33, 0x1e3f, 0x062c, 0x1e4f, 0x1ebf, 0x1ecb,
+    0x1ede, 0x1ef0, 0x1f03, 0x1f05, 0x1f09, 0x1f0f, 0x1f15, 0x1f17,
+    0x1f1b, 0x1f1d, 0x1f25, 0x1f28, 0x1f2a, 0x1f30, 0x1f32, 0x30b5,
+    0x1f38, 0x1f90, 0x1fa6, 0x1faa, 0x1fac, 0x1fb1, 0x1ffe, 0x200f,
+    0x2110, 0x2120, 0x2126, 0x2220, 0x233e,
 };
 
-static const uint8_t unicode_decomp_data[9345] = {
+static const uint8_t unicode_decomp_data[9292] = {
     0x20, 0x88, 0x20, 0x84, 0x32, 0x33, 0x20, 0x81,
     0x20, 0xa7, 0x31, 0x6f, 0x31, 0xd0, 0x34, 0x31,
     0xd0, 0x32, 0x33, 0xd0, 0x34, 0x41, 0x80, 0x41,
@@ -1920,214 +1905,207 @@
     0xa3, 0x03, 0xb1, 0x03, 0xd1, 0x03, 0x24, 0x00,
     0x1f, 0x04, 0x20, 0x05, 0x0b, 0x0c, 0x30, 0x00,
     0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00,
-    0x30, 0x04, 0x3a, 0x04, 0x3e, 0x04, 0x4b, 0x04,
-    0x4d, 0x04, 0x4e, 0x04, 0x89, 0xa6, 0x30, 0x04,
-    0xa9, 0x26, 0x28, 0xb9, 0x7f, 0x9f, 0x00, 0x01,
-    0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x0a,
-    0x0b, 0x0e, 0x0f, 0x11, 0x13, 0x14, 0x15, 0x16,
-    0x17, 0x18, 0x1a, 0x1b, 0x61, 0x26, 0x25, 0x2f,
-    0x7b, 0x51, 0xa6, 0xb1, 0x04, 0x27, 0x06, 0x00,
-    0x01, 0x05, 0x08, 0x2a, 0x06, 0x1e, 0x08, 0x03,
-    0x0d, 0x20, 0x19, 0x1a, 0x1b, 0x1c, 0x09, 0x0f,
-    0x17, 0x0b, 0x18, 0x07, 0x0a, 0x00, 0x01, 0x04,
-    0x06, 0x0c, 0x0e, 0x10, 0x44, 0x90, 0x77, 0x45,
-    0x28, 0x06, 0x2c, 0x06, 0x00, 0x00, 0x47, 0x06,
-    0x33, 0x06, 0x17, 0x10, 0x11, 0x12, 0x13, 0x00,
-    0x06, 0x0e, 0x02, 0x0f, 0x34, 0x06, 0x2a, 0x06,
-    0x2b, 0x06, 0x2e, 0x06, 0x00, 0x00, 0x36, 0x06,
-    0x00, 0x00, 0x3a, 0x06, 0x2d, 0x06, 0x00, 0x00,
-    0x4a, 0x06, 0x00, 0x00, 0x44, 0x06, 0x00, 0x00,
-    0x46, 0x06, 0x33, 0x06, 0x39, 0x06, 0x00, 0x00,
-    0x35, 0x06, 0x42, 0x06, 0x00, 0x00, 0x34, 0x06,
-    0x00, 0x00, 0x00, 0x00, 0x2e, 0x06, 0x00, 0x00,
-    0x36, 0x06, 0x00, 0x00, 0x3a, 0x06, 0x00, 0x00,
-    0xba, 0x06, 0x00, 0x00, 0x6f, 0x06, 0x00, 0x00,
-    0x28, 0x06, 0x2c, 0x06, 0x00, 0x00, 0x47, 0x06,
-    0x00, 0x00, 0x00, 0x00, 0x2d, 0x06, 0x37, 0x06,
-    0x4a, 0x06, 0x43, 0x06, 0x00, 0x00, 0x45, 0x06,
-    0x46, 0x06, 0x33, 0x06, 0x39, 0x06, 0x41, 0x06,
-    0x35, 0x06, 0x42, 0x06, 0x00, 0x00, 0x34, 0x06,
-    0x2a, 0x06, 0x2b, 0x06, 0x2e, 0x06, 0x00, 0x00,
-    0x36, 0x06, 0x38, 0x06, 0x3a, 0x06, 0x6e, 0x06,
-    0x00, 0x00, 0xa1, 0x06, 0x27, 0x06, 0x00, 0x01,
-    0x05, 0x08, 0x20, 0x21, 0x0b, 0x06, 0x10, 0x23,
+    0x27, 0x06, 0x00, 0x01, 0x05, 0x08, 0x2a, 0x06,
+    0x1e, 0x08, 0x03, 0x0d, 0x20, 0x19, 0x1a, 0x1b,
+    0x1c, 0x09, 0x0f, 0x17, 0x0b, 0x18, 0x07, 0x0a,
+    0x00, 0x01, 0x04, 0x06, 0x0c, 0x0e, 0x10, 0x44,
+    0x90, 0x77, 0x45, 0x28, 0x06, 0x2c, 0x06, 0x00,
+    0x00, 0x47, 0x06, 0x33, 0x06, 0x17, 0x10, 0x11,
+    0x12, 0x13, 0x00, 0x06, 0x0e, 0x02, 0x0f, 0x34,
+    0x06, 0x2a, 0x06, 0x2b, 0x06, 0x2e, 0x06, 0x00,
+    0x00, 0x36, 0x06, 0x00, 0x00, 0x3a, 0x06, 0x2d,
+    0x06, 0x00, 0x00, 0x4a, 0x06, 0x00, 0x00, 0x44,
+    0x06, 0x00, 0x00, 0x46, 0x06, 0x33, 0x06, 0x39,
+    0x06, 0x00, 0x00, 0x35, 0x06, 0x42, 0x06, 0x00,
+    0x00, 0x34, 0x06, 0x00, 0x00, 0x00, 0x00, 0x2e,
+    0x06, 0x00, 0x00, 0x36, 0x06, 0x00, 0x00, 0x3a,
+    0x06, 0x00, 0x00, 0xba, 0x06, 0x00, 0x00, 0x6f,
+    0x06, 0x00, 0x00, 0x28, 0x06, 0x2c, 0x06, 0x00,
+    0x00, 0x47, 0x06, 0x00, 0x00, 0x00, 0x00, 0x2d,
+    0x06, 0x37, 0x06, 0x4a, 0x06, 0x43, 0x06, 0x00,
+    0x00, 0x45, 0x06, 0x46, 0x06, 0x33, 0x06, 0x39,
+    0x06, 0x41, 0x06, 0x35, 0x06, 0x42, 0x06, 0x00,
+    0x00, 0x34, 0x06, 0x2a, 0x06, 0x2b, 0x06, 0x2e,
+    0x06, 0x00, 0x00, 0x36, 0x06, 0x38, 0x06, 0x3a,
+    0x06, 0x6e, 0x06, 0x00, 0x00, 0xa1, 0x06, 0x27,
+    0x06, 0x00, 0x01, 0x05, 0x08, 0x20, 0x21, 0x0b,
+    0x06, 0x10, 0x23, 0x2a, 0x06, 0x1a, 0x1b, 0x1c,
+    0x09, 0x0f, 0x17, 0x0b, 0x18, 0x07, 0x0a, 0x00,
+    0x01, 0x04, 0x06, 0x0c, 0x0e, 0x10, 0x28, 0x06,
+    0x2c, 0x06, 0x2f, 0x06, 0x00, 0x00, 0x48, 0x06,
+    0x32, 0x06, 0x2d, 0x06, 0x37, 0x06, 0x4a, 0x06,
     0x2a, 0x06, 0x1a, 0x1b, 0x1c, 0x09, 0x0f, 0x17,
     0x0b, 0x18, 0x07, 0x0a, 0x00, 0x01, 0x04, 0x06,
-    0x0c, 0x0e, 0x10, 0x28, 0x06, 0x2c, 0x06, 0x2f,
-    0x06, 0x00, 0x00, 0x48, 0x06, 0x32, 0x06, 0x2d,
-    0x06, 0x37, 0x06, 0x4a, 0x06, 0x2a, 0x06, 0x1a,
-    0x1b, 0x1c, 0x09, 0x0f, 0x17, 0x0b, 0x18, 0x07,
-    0x0a, 0x00, 0x01, 0x04, 0x06, 0x0c, 0x0e, 0x10,
-    0x30, 0x2e, 0x30, 0x00, 0x2c, 0x00, 0x28, 0x00,
-    0x41, 0x00, 0x29, 0x00, 0x14, 0x30, 0x53, 0x00,
-    0x15, 0x30, 0x43, 0x52, 0x43, 0x44, 0x57, 0x5a,
-    0x41, 0x00, 0x48, 0x56, 0x4d, 0x56, 0x53, 0x44,
-    0x53, 0x53, 0x50, 0x50, 0x56, 0x57, 0x43, 0x4d,
-    0x43, 0x4d, 0x44, 0x4d, 0x52, 0x44, 0x4a, 0x4b,
-    0x30, 0x30, 0x00, 0x68, 0x68, 0x4b, 0x62, 0x57,
-    0x5b, 0xcc, 0x53, 0xc7, 0x30, 0x8c, 0x4e, 0x1a,
-    0x59, 0xe3, 0x89, 0x29, 0x59, 0xa4, 0x4e, 0x20,
-    0x66, 0x21, 0x71, 0x99, 0x65, 0x4d, 0x52, 0x8c,
-    0x5f, 0x8d, 0x51, 0xb0, 0x65, 0x1d, 0x52, 0x42,
-    0x7d, 0x1f, 0x75, 0xa9, 0x8c, 0xf0, 0x58, 0x39,
-    0x54, 0x14, 0x6f, 0x95, 0x62, 0x55, 0x63, 0x00,
-    0x4e, 0x09, 0x4e, 0x4a, 0x90, 0xe6, 0x5d, 0x2d,
-    0x4e, 0xf3, 0x53, 0x07, 0x63, 0x70, 0x8d, 0x53,
-    0x62, 0x81, 0x79, 0x7a, 0x7a, 0x08, 0x54, 0x80,
-    0x6e, 0x09, 0x67, 0x08, 0x67, 0x33, 0x75, 0x72,
-    0x52, 0xb6, 0x55, 0x4d, 0x91, 0x14, 0x30, 0x15,
-    0x30, 0x2c, 0x67, 0x09, 0x4e, 0x8c, 0x4e, 0x89,
-    0x5b, 0xb9, 0x70, 0x53, 0x62, 0xd7, 0x76, 0xdd,
-    0x52, 0x57, 0x65, 0x97, 0x5f, 0xef, 0x53, 0x30,
-    0x00, 0x38, 0x4e, 0x05, 0x00, 0x09, 0x22, 0x01,
-    0x60, 0x4f, 0xae, 0x4f, 0xbb, 0x4f, 0x02, 0x50,
-    0x7a, 0x50, 0x99, 0x50, 0xe7, 0x50, 0xcf, 0x50,
-    0x9e, 0x34, 0x3a, 0x06, 0x4d, 0x51, 0x54, 0x51,
-    0x64, 0x51, 0x77, 0x51, 0x1c, 0x05, 0xb9, 0x34,
-    0x67, 0x51, 0x8d, 0x51, 0x4b, 0x05, 0x97, 0x51,
-    0xa4, 0x51, 0xcc, 0x4e, 0xac, 0x51, 0xb5, 0x51,
-    0xdf, 0x91, 0xf5, 0x51, 0x03, 0x52, 0xdf, 0x34,
-    0x3b, 0x52, 0x46, 0x52, 0x72, 0x52, 0x77, 0x52,
-    0x15, 0x35, 0x02, 0x00, 0x20, 0x80, 0x80, 0x00,
-    0x08, 0x00, 0x00, 0xc7, 0x52, 0x00, 0x02, 0x1d,
-    0x33, 0x3e, 0x3f, 0x50, 0x82, 0x8a, 0x93, 0xac,
-    0xb6, 0xb8, 0xb8, 0xb8, 0x2c, 0x0a, 0x70, 0x70,
-    0xca, 0x53, 0xdf, 0x53, 0x63, 0x0b, 0xeb, 0x53,
-    0xf1, 0x53, 0x06, 0x54, 0x9e, 0x54, 0x38, 0x54,
-    0x48, 0x54, 0x68, 0x54, 0xa2, 0x54, 0xf6, 0x54,
-    0x10, 0x55, 0x53, 0x55, 0x63, 0x55, 0x84, 0x55,
-    0x84, 0x55, 0x99, 0x55, 0xab, 0x55, 0xb3, 0x55,
-    0xc2, 0x55, 0x16, 0x57, 0x06, 0x56, 0x17, 0x57,
-    0x51, 0x56, 0x74, 0x56, 0x07, 0x52, 0xee, 0x58,
-    0xce, 0x57, 0xf4, 0x57, 0x0d, 0x58, 0x8b, 0x57,
-    0x32, 0x58, 0x31, 0x58, 0xac, 0x58, 0xe4, 0x14,
-    0xf2, 0x58, 0xf7, 0x58, 0x06, 0x59, 0x1a, 0x59,
-    0x22, 0x59, 0x62, 0x59, 0xa8, 0x16, 0xea, 0x16,
-    0xec, 0x59, 0x1b, 0x5a, 0x27, 0x5a, 0xd8, 0x59,
-    0x66, 0x5a, 0xee, 0x36, 0xfc, 0x36, 0x08, 0x5b,
-    0x3e, 0x5b, 0x3e, 0x5b, 0xc8, 0x19, 0xc3, 0x5b,
-    0xd8, 0x5b, 0xe7, 0x5b, 0xf3, 0x5b, 0x18, 0x1b,
-    0xff, 0x5b, 0x06, 0x5c, 0x53, 0x5f, 0x22, 0x5c,
-    0x81, 0x37, 0x60, 0x5c, 0x6e, 0x5c, 0xc0, 0x5c,
-    0x8d, 0x5c, 0xe4, 0x1d, 0x43, 0x5d, 0xe6, 0x1d,
-    0x6e, 0x5d, 0x6b, 0x5d, 0x7c, 0x5d, 0xe1, 0x5d,
-    0xe2, 0x5d, 0x2f, 0x38, 0xfd, 0x5d, 0x28, 0x5e,
-    0x3d, 0x5e, 0x69, 0x5e, 0x62, 0x38, 0x83, 0x21,
-    0x7c, 0x38, 0xb0, 0x5e, 0xb3, 0x5e, 0xb6, 0x5e,
-    0xca, 0x5e, 0x92, 0xa3, 0xfe, 0x5e, 0x31, 0x23,
-    0x31, 0x23, 0x01, 0x82, 0x22, 0x5f, 0x22, 0x5f,
-    0xc7, 0x38, 0xb8, 0x32, 0xda, 0x61, 0x62, 0x5f,
-    0x6b, 0x5f, 0xe3, 0x38, 0x9a, 0x5f, 0xcd, 0x5f,
-    0xd7, 0x5f, 0xf9, 0x5f, 0x81, 0x60, 0x3a, 0x39,
-    0x1c, 0x39, 0x94, 0x60, 0xd4, 0x26, 0xc7, 0x60,
-    0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-    0x00, 0x08, 0x00, 0x0a, 0x00, 0x00, 0x02, 0x08,
-    0x00, 0x80, 0x08, 0x00, 0x00, 0x08, 0x80, 0x28,
-    0x80, 0x02, 0x00, 0x00, 0x02, 0x48, 0x61, 0x00,
-    0x04, 0x06, 0x04, 0x32, 0x46, 0x6a, 0x5c, 0x67,
-    0x96, 0xaa, 0xae, 0xc8, 0xd3, 0x5d, 0x62, 0x00,
-    0x54, 0x77, 0xf3, 0x0c, 0x2b, 0x3d, 0x63, 0xfc,
-    0x62, 0x68, 0x63, 0x83, 0x63, 0xe4, 0x63, 0xf1,
-    0x2b, 0x22, 0x64, 0xc5, 0x63, 0xa9, 0x63, 0x2e,
-    0x3a, 0x69, 0x64, 0x7e, 0x64, 0x9d, 0x64, 0x77,
-    0x64, 0x6c, 0x3a, 0x4f, 0x65, 0x6c, 0x65, 0x0a,
-    0x30, 0xe3, 0x65, 0xf8, 0x66, 0x49, 0x66, 0x19,
-    0x3b, 0x91, 0x66, 0x08, 0x3b, 0xe4, 0x3a, 0x92,
-    0x51, 0x95, 0x51, 0x00, 0x67, 0x9c, 0x66, 0xad,
-    0x80, 0xd9, 0x43, 0x17, 0x67, 0x1b, 0x67, 0x21,
-    0x67, 0x5e, 0x67, 0x53, 0x67, 0xc3, 0x33, 0x49,
-    0x3b, 0xfa, 0x67, 0x85, 0x67, 0x52, 0x68, 0x85,
-    0x68, 0x6d, 0x34, 0x8e, 0x68, 0x1f, 0x68, 0x14,
-    0x69, 0x9d, 0x3b, 0x42, 0x69, 0xa3, 0x69, 0xea,
-    0x69, 0xa8, 0x6a, 0xa3, 0x36, 0xdb, 0x6a, 0x18,
-    0x3c, 0x21, 0x6b, 0xa7, 0x38, 0x54, 0x6b, 0x4e,
-    0x3c, 0x72, 0x6b, 0x9f, 0x6b, 0xba, 0x6b, 0xbb,
-    0x6b, 0x8d, 0x3a, 0x0b, 0x1d, 0xfa, 0x3a, 0x4e,
-    0x6c, 0xbc, 0x3c, 0xbf, 0x6c, 0xcd, 0x6c, 0x67,
-    0x6c, 0x16, 0x6d, 0x3e, 0x6d, 0x77, 0x6d, 0x41,
-    0x6d, 0x69, 0x6d, 0x78, 0x6d, 0x85, 0x6d, 0x1e,
-    0x3d, 0x34, 0x6d, 0x2f, 0x6e, 0x6e, 0x6e, 0x33,
-    0x3d, 0xcb, 0x6e, 0xc7, 0x6e, 0xd1, 0x3e, 0xf9,
-    0x6d, 0x6e, 0x6f, 0x5e, 0x3f, 0x8e, 0x3f, 0xc6,
-    0x6f, 0x39, 0x70, 0x1e, 0x70, 0x1b, 0x70, 0x96,
-    0x3d, 0x4a, 0x70, 0x7d, 0x70, 0x77, 0x70, 0xad,
-    0x70, 0x25, 0x05, 0x45, 0x71, 0x63, 0x42, 0x9c,
-    0x71, 0xab, 0x43, 0x28, 0x72, 0x35, 0x72, 0x50,
-    0x72, 0x08, 0x46, 0x80, 0x72, 0x95, 0x72, 0x35,
-    0x47, 0x02, 0x20, 0x00, 0x00, 0x20, 0x00, 0x00,
-    0x00, 0x00, 0x08, 0x80, 0x00, 0x00, 0x02, 0x02,
-    0x80, 0x8a, 0x00, 0x00, 0x20, 0x00, 0x08, 0x0a,
-    0x00, 0x80, 0x88, 0x80, 0x20, 0x14, 0x48, 0x7a,
-    0x73, 0x8b, 0x73, 0xac, 0x3e, 0xa5, 0x73, 0xb8,
-    0x3e, 0xb8, 0x3e, 0x47, 0x74, 0x5c, 0x74, 0x71,
-    0x74, 0x85, 0x74, 0xca, 0x74, 0x1b, 0x3f, 0x24,
-    0x75, 0x36, 0x4c, 0x3e, 0x75, 0x92, 0x4c, 0x70,
-    0x75, 0x9f, 0x21, 0x10, 0x76, 0xa1, 0x4f, 0xb8,
-    0x4f, 0x44, 0x50, 0xfc, 0x3f, 0x08, 0x40, 0xf4,
-    0x76, 0xf3, 0x50, 0xf2, 0x50, 0x19, 0x51, 0x33,
-    0x51, 0x1e, 0x77, 0x1f, 0x77, 0x1f, 0x77, 0x4a,
-    0x77, 0x39, 0x40, 0x8b, 0x77, 0x46, 0x40, 0x96,
-    0x40, 0x1d, 0x54, 0x4e, 0x78, 0x8c, 0x78, 0xcc,
-    0x78, 0xe3, 0x40, 0x26, 0x56, 0x56, 0x79, 0x9a,
-    0x56, 0xc5, 0x56, 0x8f, 0x79, 0xeb, 0x79, 0x2f,
-    0x41, 0x40, 0x7a, 0x4a, 0x7a, 0x4f, 0x7a, 0x7c,
-    0x59, 0xa7, 0x5a, 0xa7, 0x5a, 0xee, 0x7a, 0x02,
-    0x42, 0xab, 0x5b, 0xc6, 0x7b, 0xc9, 0x7b, 0x27,
-    0x42, 0x80, 0x5c, 0xd2, 0x7c, 0xa0, 0x42, 0xe8,
-    0x7c, 0xe3, 0x7c, 0x00, 0x7d, 0x86, 0x5f, 0x63,
-    0x7d, 0x01, 0x43, 0xc7, 0x7d, 0x02, 0x7e, 0x45,
-    0x7e, 0x34, 0x43, 0x28, 0x62, 0x47, 0x62, 0x59,
-    0x43, 0xd9, 0x62, 0x7a, 0x7f, 0x3e, 0x63, 0x95,
-    0x7f, 0xfa, 0x7f, 0x05, 0x80, 0xda, 0x64, 0x23,
-    0x65, 0x60, 0x80, 0xa8, 0x65, 0x70, 0x80, 0x5f,
-    0x33, 0xd5, 0x43, 0xb2, 0x80, 0x03, 0x81, 0x0b,
-    0x44, 0x3e, 0x81, 0xb5, 0x5a, 0xa7, 0x67, 0xb5,
-    0x67, 0x93, 0x33, 0x9c, 0x33, 0x01, 0x82, 0x04,
-    0x82, 0x9e, 0x8f, 0x6b, 0x44, 0x91, 0x82, 0x8b,
-    0x82, 0x9d, 0x82, 0xb3, 0x52, 0xb1, 0x82, 0xb3,
-    0x82, 0xbd, 0x82, 0xe6, 0x82, 0x3c, 0x6b, 0xe5,
-    0x82, 0x1d, 0x83, 0x63, 0x83, 0xad, 0x83, 0x23,
-    0x83, 0xbd, 0x83, 0xe7, 0x83, 0x57, 0x84, 0x53,
-    0x83, 0xca, 0x83, 0xcc, 0x83, 0xdc, 0x83, 0x36,
-    0x6c, 0x6b, 0x6d, 0x02, 0x00, 0x00, 0x20, 0x22,
-    0x2a, 0xa0, 0x0a, 0x00, 0x20, 0x80, 0x28, 0x00,
-    0xa8, 0x20, 0x20, 0x00, 0x02, 0x80, 0x22, 0x02,
-    0x8a, 0x08, 0x00, 0xaa, 0x00, 0x00, 0x00, 0x02,
-    0x00, 0x00, 0x28, 0xd5, 0x6c, 0x2b, 0x45, 0xf1,
-    0x84, 0xf3, 0x84, 0x16, 0x85, 0xca, 0x73, 0x64,
-    0x85, 0x2c, 0x6f, 0x5d, 0x45, 0x61, 0x45, 0xb1,
-    0x6f, 0xd2, 0x70, 0x6b, 0x45, 0x50, 0x86, 0x5c,
-    0x86, 0x67, 0x86, 0x69, 0x86, 0xa9, 0x86, 0x88,
-    0x86, 0x0e, 0x87, 0xe2, 0x86, 0x79, 0x87, 0x28,
-    0x87, 0x6b, 0x87, 0x86, 0x87, 0xd7, 0x45, 0xe1,
-    0x87, 0x01, 0x88, 0xf9, 0x45, 0x60, 0x88, 0x63,
-    0x88, 0x67, 0x76, 0xd7, 0x88, 0xde, 0x88, 0x35,
-    0x46, 0xfa, 0x88, 0xbb, 0x34, 0xae, 0x78, 0x66,
-    0x79, 0xbe, 0x46, 0xc7, 0x46, 0xa0, 0x8a, 0xed,
-    0x8a, 0x8a, 0x8b, 0x55, 0x8c, 0xa8, 0x7c, 0xab,
-    0x8c, 0xc1, 0x8c, 0x1b, 0x8d, 0x77, 0x8d, 0x2f,
-    0x7f, 0x04, 0x08, 0xcb, 0x8d, 0xbc, 0x8d, 0xf0,
-    0x8d, 0xde, 0x08, 0xd4, 0x8e, 0x38, 0x8f, 0xd2,
-    0x85, 0xed, 0x85, 0x94, 0x90, 0xf1, 0x90, 0x11,
-    0x91, 0x2e, 0x87, 0x1b, 0x91, 0x38, 0x92, 0xd7,
-    0x92, 0xd8, 0x92, 0x7c, 0x92, 0xf9, 0x93, 0x15,
-    0x94, 0xfa, 0x8b, 0x8b, 0x95, 0x95, 0x49, 0xb7,
-    0x95, 0x77, 0x8d, 0xe6, 0x49, 0xc3, 0x96, 0xb2,
-    0x5d, 0x23, 0x97, 0x45, 0x91, 0x1a, 0x92, 0x6e,
-    0x4a, 0x76, 0x4a, 0xe0, 0x97, 0x0a, 0x94, 0xb2,
-    0x4a, 0x96, 0x94, 0x0b, 0x98, 0x0b, 0x98, 0x29,
-    0x98, 0xb6, 0x95, 0xe2, 0x98, 0x33, 0x4b, 0x29,
-    0x99, 0xa7, 0x99, 0xc2, 0x99, 0xfe, 0x99, 0xce,
-    0x4b, 0x30, 0x9b, 0x12, 0x9b, 0x40, 0x9c, 0xfd,
-    0x9c, 0xce, 0x4c, 0xed, 0x4c, 0x67, 0x9d, 0xce,
-    0xa0, 0xf8, 0x4c, 0x05, 0xa1, 0x0e, 0xa2, 0x91,
-    0xa2, 0xbb, 0x9e, 0x56, 0x4d, 0xf9, 0x9e, 0xfe,
-    0x9e, 0x05, 0x9f, 0x0f, 0x9f, 0x16, 0x9f, 0x3b,
-    0x9f, 0x00, 0xa6, 0x02, 0x88, 0xa0, 0x00, 0x00,
-    0x00, 0x00, 0x80, 0x00, 0x28, 0x00, 0x08, 0xa0,
-    0x80, 0xa0, 0x80, 0x00, 0x80, 0x80, 0x00, 0x0a,
-    0x88, 0x80, 0x00, 0x80, 0x00, 0x20, 0x2a, 0x00,
-    0x80,
+    0x0c, 0x0e, 0x10, 0x30, 0x2e, 0x30, 0x00, 0x2c,
+    0x00, 0x28, 0x00, 0x41, 0x00, 0x29, 0x00, 0x14,
+    0x30, 0x53, 0x00, 0x15, 0x30, 0x43, 0x52, 0x43,
+    0x44, 0x57, 0x5a, 0x41, 0x00, 0x48, 0x56, 0x4d,
+    0x56, 0x53, 0x44, 0x53, 0x53, 0x50, 0x50, 0x56,
+    0x57, 0x43, 0x4d, 0x43, 0x4d, 0x44, 0x4d, 0x52,
+    0x44, 0x4a, 0x4b, 0x30, 0x30, 0x00, 0x68, 0x68,
+    0x4b, 0x62, 0x57, 0x5b, 0xcc, 0x53, 0xc7, 0x30,
+    0x8c, 0x4e, 0x1a, 0x59, 0xe3, 0x89, 0x29, 0x59,
+    0xa4, 0x4e, 0x20, 0x66, 0x21, 0x71, 0x99, 0x65,
+    0x4d, 0x52, 0x8c, 0x5f, 0x8d, 0x51, 0xb0, 0x65,
+    0x1d, 0x52, 0x42, 0x7d, 0x1f, 0x75, 0xa9, 0x8c,
+    0xf0, 0x58, 0x39, 0x54, 0x14, 0x6f, 0x95, 0x62,
+    0x55, 0x63, 0x00, 0x4e, 0x09, 0x4e, 0x4a, 0x90,
+    0xe6, 0x5d, 0x2d, 0x4e, 0xf3, 0x53, 0x07, 0x63,
+    0x70, 0x8d, 0x53, 0x62, 0x81, 0x79, 0x7a, 0x7a,
+    0x08, 0x54, 0x80, 0x6e, 0x09, 0x67, 0x08, 0x67,
+    0x33, 0x75, 0x72, 0x52, 0xb6, 0x55, 0x4d, 0x91,
+    0x14, 0x30, 0x15, 0x30, 0x2c, 0x67, 0x09, 0x4e,
+    0x8c, 0x4e, 0x89, 0x5b, 0xb9, 0x70, 0x53, 0x62,
+    0xd7, 0x76, 0xdd, 0x52, 0x57, 0x65, 0x97, 0x5f,
+    0xef, 0x53, 0x30, 0x00, 0x38, 0x4e, 0x05, 0x00,
+    0x09, 0x22, 0x01, 0x60, 0x4f, 0xae, 0x4f, 0xbb,
+    0x4f, 0x02, 0x50, 0x7a, 0x50, 0x99, 0x50, 0xe7,
+    0x50, 0xcf, 0x50, 0x9e, 0x34, 0x3a, 0x06, 0x4d,
+    0x51, 0x54, 0x51, 0x64, 0x51, 0x77, 0x51, 0x1c,
+    0x05, 0xb9, 0x34, 0x67, 0x51, 0x8d, 0x51, 0x4b,
+    0x05, 0x97, 0x51, 0xa4, 0x51, 0xcc, 0x4e, 0xac,
+    0x51, 0xb5, 0x51, 0xdf, 0x91, 0xf5, 0x51, 0x03,
+    0x52, 0xdf, 0x34, 0x3b, 0x52, 0x46, 0x52, 0x72,
+    0x52, 0x77, 0x52, 0x15, 0x35, 0x02, 0x00, 0x20,
+    0x80, 0x80, 0x00, 0x08, 0x00, 0x00, 0xc7, 0x52,
+    0x00, 0x02, 0x1d, 0x33, 0x3e, 0x3f, 0x50, 0x82,
+    0x8a, 0x93, 0xac, 0xb6, 0xb8, 0xb8, 0xb8, 0x2c,
+    0x0a, 0x70, 0x70, 0xca, 0x53, 0xdf, 0x53, 0x63,
+    0x0b, 0xeb, 0x53, 0xf1, 0x53, 0x06, 0x54, 0x9e,
+    0x54, 0x38, 0x54, 0x48, 0x54, 0x68, 0x54, 0xa2,
+    0x54, 0xf6, 0x54, 0x10, 0x55, 0x53, 0x55, 0x63,
+    0x55, 0x84, 0x55, 0x84, 0x55, 0x99, 0x55, 0xab,
+    0x55, 0xb3, 0x55, 0xc2, 0x55, 0x16, 0x57, 0x06,
+    0x56, 0x17, 0x57, 0x51, 0x56, 0x74, 0x56, 0x07,
+    0x52, 0xee, 0x58, 0xce, 0x57, 0xf4, 0x57, 0x0d,
+    0x58, 0x8b, 0x57, 0x32, 0x58, 0x31, 0x58, 0xac,
+    0x58, 0xe4, 0x14, 0xf2, 0x58, 0xf7, 0x58, 0x06,
+    0x59, 0x1a, 0x59, 0x22, 0x59, 0x62, 0x59, 0xa8,
+    0x16, 0xea, 0x16, 0xec, 0x59, 0x1b, 0x5a, 0x27,
+    0x5a, 0xd8, 0x59, 0x66, 0x5a, 0xee, 0x36, 0xfc,
+    0x36, 0x08, 0x5b, 0x3e, 0x5b, 0x3e, 0x5b, 0xc8,
+    0x19, 0xc3, 0x5b, 0xd8, 0x5b, 0xe7, 0x5b, 0xf3,
+    0x5b, 0x18, 0x1b, 0xff, 0x5b, 0x06, 0x5c, 0x53,
+    0x5f, 0x22, 0x5c, 0x81, 0x37, 0x60, 0x5c, 0x6e,
+    0x5c, 0xc0, 0x5c, 0x8d, 0x5c, 0xe4, 0x1d, 0x43,
+    0x5d, 0xe6, 0x1d, 0x6e, 0x5d, 0x6b, 0x5d, 0x7c,
+    0x5d, 0xe1, 0x5d, 0xe2, 0x5d, 0x2f, 0x38, 0xfd,
+    0x5d, 0x28, 0x5e, 0x3d, 0x5e, 0x69, 0x5e, 0x62,
+    0x38, 0x83, 0x21, 0x7c, 0x38, 0xb0, 0x5e, 0xb3,
+    0x5e, 0xb6, 0x5e, 0xca, 0x5e, 0x92, 0xa3, 0xfe,
+    0x5e, 0x31, 0x23, 0x31, 0x23, 0x01, 0x82, 0x22,
+    0x5f, 0x22, 0x5f, 0xc7, 0x38, 0xb8, 0x32, 0xda,
+    0x61, 0x62, 0x5f, 0x6b, 0x5f, 0xe3, 0x38, 0x9a,
+    0x5f, 0xcd, 0x5f, 0xd7, 0x5f, 0xf9, 0x5f, 0x81,
+    0x60, 0x3a, 0x39, 0x1c, 0x39, 0x94, 0x60, 0xd4,
+    0x26, 0xc7, 0x60, 0x02, 0x02, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0a, 0x00,
+    0x00, 0x02, 0x08, 0x00, 0x80, 0x08, 0x00, 0x00,
+    0x08, 0x80, 0x28, 0x80, 0x02, 0x00, 0x00, 0x02,
+    0x48, 0x61, 0x00, 0x04, 0x06, 0x04, 0x32, 0x46,
+    0x6a, 0x5c, 0x67, 0x96, 0xaa, 0xae, 0xc8, 0xd3,
+    0x5d, 0x62, 0x00, 0x54, 0x77, 0xf3, 0x0c, 0x2b,
+    0x3d, 0x63, 0xfc, 0x62, 0x68, 0x63, 0x83, 0x63,
+    0xe4, 0x63, 0xf1, 0x2b, 0x22, 0x64, 0xc5, 0x63,
+    0xa9, 0x63, 0x2e, 0x3a, 0x69, 0x64, 0x7e, 0x64,
+    0x9d, 0x64, 0x77, 0x64, 0x6c, 0x3a, 0x4f, 0x65,
+    0x6c, 0x65, 0x0a, 0x30, 0xe3, 0x65, 0xf8, 0x66,
+    0x49, 0x66, 0x19, 0x3b, 0x91, 0x66, 0x08, 0x3b,
+    0xe4, 0x3a, 0x92, 0x51, 0x95, 0x51, 0x00, 0x67,
+    0x9c, 0x66, 0xad, 0x80, 0xd9, 0x43, 0x17, 0x67,
+    0x1b, 0x67, 0x21, 0x67, 0x5e, 0x67, 0x53, 0x67,
+    0xc3, 0x33, 0x49, 0x3b, 0xfa, 0x67, 0x85, 0x67,
+    0x52, 0x68, 0x85, 0x68, 0x6d, 0x34, 0x8e, 0x68,
+    0x1f, 0x68, 0x14, 0x69, 0x9d, 0x3b, 0x42, 0x69,
+    0xa3, 0x69, 0xea, 0x69, 0xa8, 0x6a, 0xa3, 0x36,
+    0xdb, 0x6a, 0x18, 0x3c, 0x21, 0x6b, 0xa7, 0x38,
+    0x54, 0x6b, 0x4e, 0x3c, 0x72, 0x6b, 0x9f, 0x6b,
+    0xba, 0x6b, 0xbb, 0x6b, 0x8d, 0x3a, 0x0b, 0x1d,
+    0xfa, 0x3a, 0x4e, 0x6c, 0xbc, 0x3c, 0xbf, 0x6c,
+    0xcd, 0x6c, 0x67, 0x6c, 0x16, 0x6d, 0x3e, 0x6d,
+    0x77, 0x6d, 0x41, 0x6d, 0x69, 0x6d, 0x78, 0x6d,
+    0x85, 0x6d, 0x1e, 0x3d, 0x34, 0x6d, 0x2f, 0x6e,
+    0x6e, 0x6e, 0x33, 0x3d, 0xcb, 0x6e, 0xc7, 0x6e,
+    0xd1, 0x3e, 0xf9, 0x6d, 0x6e, 0x6f, 0x5e, 0x3f,
+    0x8e, 0x3f, 0xc6, 0x6f, 0x39, 0x70, 0x1e, 0x70,
+    0x1b, 0x70, 0x96, 0x3d, 0x4a, 0x70, 0x7d, 0x70,
+    0x77, 0x70, 0xad, 0x70, 0x25, 0x05, 0x45, 0x71,
+    0x63, 0x42, 0x9c, 0x71, 0xab, 0x43, 0x28, 0x72,
+    0x35, 0x72, 0x50, 0x72, 0x08, 0x46, 0x80, 0x72,
+    0x95, 0x72, 0x35, 0x47, 0x02, 0x20, 0x00, 0x00,
+    0x20, 0x00, 0x00, 0x00, 0x00, 0x08, 0x80, 0x00,
+    0x00, 0x02, 0x02, 0x80, 0x8a, 0x00, 0x00, 0x20,
+    0x00, 0x08, 0x0a, 0x00, 0x80, 0x88, 0x80, 0x20,
+    0x14, 0x48, 0x7a, 0x73, 0x8b, 0x73, 0xac, 0x3e,
+    0xa5, 0x73, 0xb8, 0x3e, 0xb8, 0x3e, 0x47, 0x74,
+    0x5c, 0x74, 0x71, 0x74, 0x85, 0x74, 0xca, 0x74,
+    0x1b, 0x3f, 0x24, 0x75, 0x36, 0x4c, 0x3e, 0x75,
+    0x92, 0x4c, 0x70, 0x75, 0x9f, 0x21, 0x10, 0x76,
+    0xa1, 0x4f, 0xb8, 0x4f, 0x44, 0x50, 0xfc, 0x3f,
+    0x08, 0x40, 0xf4, 0x76, 0xf3, 0x50, 0xf2, 0x50,
+    0x19, 0x51, 0x33, 0x51, 0x1e, 0x77, 0x1f, 0x77,
+    0x1f, 0x77, 0x4a, 0x77, 0x39, 0x40, 0x8b, 0x77,
+    0x46, 0x40, 0x96, 0x40, 0x1d, 0x54, 0x4e, 0x78,
+    0x8c, 0x78, 0xcc, 0x78, 0xe3, 0x40, 0x26, 0x56,
+    0x56, 0x79, 0x9a, 0x56, 0xc5, 0x56, 0x8f, 0x79,
+    0xeb, 0x79, 0x2f, 0x41, 0x40, 0x7a, 0x4a, 0x7a,
+    0x4f, 0x7a, 0x7c, 0x59, 0xa7, 0x5a, 0xa7, 0x5a,
+    0xee, 0x7a, 0x02, 0x42, 0xab, 0x5b, 0xc6, 0x7b,
+    0xc9, 0x7b, 0x27, 0x42, 0x80, 0x5c, 0xd2, 0x7c,
+    0xa0, 0x42, 0xe8, 0x7c, 0xe3, 0x7c, 0x00, 0x7d,
+    0x86, 0x5f, 0x63, 0x7d, 0x01, 0x43, 0xc7, 0x7d,
+    0x02, 0x7e, 0x45, 0x7e, 0x34, 0x43, 0x28, 0x62,
+    0x47, 0x62, 0x59, 0x43, 0xd9, 0x62, 0x7a, 0x7f,
+    0x3e, 0x63, 0x95, 0x7f, 0xfa, 0x7f, 0x05, 0x80,
+    0xda, 0x64, 0x23, 0x65, 0x60, 0x80, 0xa8, 0x65,
+    0x70, 0x80, 0x5f, 0x33, 0xd5, 0x43, 0xb2, 0x80,
+    0x03, 0x81, 0x0b, 0x44, 0x3e, 0x81, 0xb5, 0x5a,
+    0xa7, 0x67, 0xb5, 0x67, 0x93, 0x33, 0x9c, 0x33,
+    0x01, 0x82, 0x04, 0x82, 0x9e, 0x8f, 0x6b, 0x44,
+    0x91, 0x82, 0x8b, 0x82, 0x9d, 0x82, 0xb3, 0x52,
+    0xb1, 0x82, 0xb3, 0x82, 0xbd, 0x82, 0xe6, 0x82,
+    0x3c, 0x6b, 0xe5, 0x82, 0x1d, 0x83, 0x63, 0x83,
+    0xad, 0x83, 0x23, 0x83, 0xbd, 0x83, 0xe7, 0x83,
+    0x57, 0x84, 0x53, 0x83, 0xca, 0x83, 0xcc, 0x83,
+    0xdc, 0x83, 0x36, 0x6c, 0x6b, 0x6d, 0x02, 0x00,
+    0x00, 0x20, 0x22, 0x2a, 0xa0, 0x0a, 0x00, 0x20,
+    0x80, 0x28, 0x00, 0xa8, 0x20, 0x20, 0x00, 0x02,
+    0x80, 0x22, 0x02, 0x8a, 0x08, 0x00, 0xaa, 0x00,
+    0x00, 0x00, 0x02, 0x00, 0x00, 0x28, 0xd5, 0x6c,
+    0x2b, 0x45, 0xf1, 0x84, 0xf3, 0x84, 0x16, 0x85,
+    0xca, 0x73, 0x64, 0x85, 0x2c, 0x6f, 0x5d, 0x45,
+    0x61, 0x45, 0xb1, 0x6f, 0xd2, 0x70, 0x6b, 0x45,
+    0x50, 0x86, 0x5c, 0x86, 0x67, 0x86, 0x69, 0x86,
+    0xa9, 0x86, 0x88, 0x86, 0x0e, 0x87, 0xe2, 0x86,
+    0x79, 0x87, 0x28, 0x87, 0x6b, 0x87, 0x86, 0x87,
+    0xd7, 0x45, 0xe1, 0x87, 0x01, 0x88, 0xf9, 0x45,
+    0x60, 0x88, 0x63, 0x88, 0x67, 0x76, 0xd7, 0x88,
+    0xde, 0x88, 0x35, 0x46, 0xfa, 0x88, 0xbb, 0x34,
+    0xae, 0x78, 0x66, 0x79, 0xbe, 0x46, 0xc7, 0x46,
+    0xa0, 0x8a, 0xed, 0x8a, 0x8a, 0x8b, 0x55, 0x8c,
+    0xa8, 0x7c, 0xab, 0x8c, 0xc1, 0x8c, 0x1b, 0x8d,
+    0x77, 0x8d, 0x2f, 0x7f, 0x04, 0x08, 0xcb, 0x8d,
+    0xbc, 0x8d, 0xf0, 0x8d, 0xde, 0x08, 0xd4, 0x8e,
+    0x38, 0x8f, 0xd2, 0x85, 0xed, 0x85, 0x94, 0x90,
+    0xf1, 0x90, 0x11, 0x91, 0x2e, 0x87, 0x1b, 0x91,
+    0x38, 0x92, 0xd7, 0x92, 0xd8, 0x92, 0x7c, 0x92,
+    0xf9, 0x93, 0x15, 0x94, 0xfa, 0x8b, 0x8b, 0x95,
+    0x95, 0x49, 0xb7, 0x95, 0x77, 0x8d, 0xe6, 0x49,
+    0xc3, 0x96, 0xb2, 0x5d, 0x23, 0x97, 0x45, 0x91,
+    0x1a, 0x92, 0x6e, 0x4a, 0x76, 0x4a, 0xe0, 0x97,
+    0x0a, 0x94, 0xb2, 0x4a, 0x96, 0x94, 0x0b, 0x98,
+    0x0b, 0x98, 0x29, 0x98, 0xb6, 0x95, 0xe2, 0x98,
+    0x33, 0x4b, 0x29, 0x99, 0xa7, 0x99, 0xc2, 0x99,
+    0xfe, 0x99, 0xce, 0x4b, 0x30, 0x9b, 0x12, 0x9b,
+    0x40, 0x9c, 0xfd, 0x9c, 0xce, 0x4c, 0xed, 0x4c,
+    0x67, 0x9d, 0xce, 0xa0, 0xf8, 0x4c, 0x05, 0xa1,
+    0x0e, 0xa2, 0x91, 0xa2, 0xbb, 0x9e, 0x56, 0x4d,
+    0xf9, 0x9e, 0xfe, 0x9e, 0x05, 0x9f, 0x0f, 0x9f,
+    0x16, 0x9f, 0x3b, 0x9f, 0x00, 0xa6, 0x02, 0x88,
+    0xa0, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x28,
+    0x00, 0x08, 0xa0, 0x80, 0xa0, 0x80, 0x00, 0x80,
+    0x80, 0x00, 0x0a, 0x88, 0x80, 0x00, 0x80, 0x00,
+    0x20, 0x2a, 0x00, 0x80,
 };
 
 static const uint16_t unicode_comp_table[945] = {
@@ -2335,7 +2313,7 @@
     "C,Other"                  "\0"
 ;
 
-static const uint8_t unicode_gc_table[3948] = {
+static const uint8_t unicode_gc_table[3897] = {
     0xfa, 0x18, 0x17, 0x56, 0x0d, 0x56, 0x12, 0x13,
     0x16, 0x0c, 0x16, 0x11, 0x36, 0xe9, 0x02, 0x36,
     0x4c, 0x36, 0xe1, 0x12, 0x12, 0x16, 0x13, 0x0e,
@@ -2421,415 +2399,409 @@
     0x85, 0x20, 0x06, 0x05, 0x07, 0x06, 0x87, 0x00,
     0x06, 0x27, 0x00, 0x27, 0x26, 0xc0, 0x27, 0xa0,
     0x25, 0x00, 0x25, 0x26, 0x20, 0xe9, 0x02, 0x00,
-    0x25, 0x07, 0xe0, 0x04, 0x26, 0x27, 0xe5, 0x01,
-    0x00, 0x45, 0x00, 0xe5, 0x21, 0x26, 0x05, 0x47,
-    0x66, 0x00, 0x47, 0x00, 0x47, 0x06, 0x05, 0x0f,
-    0x60, 0x45, 0x07, 0xcb, 0x45, 0x26, 0x20, 0xe9,
-    0x02, 0xeb, 0x01, 0x0f, 0xa5, 0x00, 0x06, 0x27,
-    0x00, 0xe5, 0x0a, 0x40, 0xe5, 0x10, 0x00, 0xe5,
-    0x01, 0x00, 0x05, 0x20, 0xc5, 0x40, 0x06, 0x60,
-    0x47, 0x46, 0x00, 0x06, 0x00, 0xe7, 0x00, 0xa0,
-    0xe9, 0x02, 0x20, 0x27, 0x16, 0xe0, 0x04, 0xe5,
-    0x28, 0x06, 0x25, 0xc6, 0x60, 0x0d, 0xa5, 0x04,
-    0xe6, 0x00, 0x16, 0xe9, 0x02, 0x36, 0xe0, 0x1d,
-    0x25, 0x00, 0x05, 0x00, 0x85, 0x00, 0xe5, 0x10,
-    0x00, 0x05, 0x00, 0xe5, 0x02, 0x06, 0x25, 0xe6,
-    0x01, 0x05, 0x20, 0x85, 0x00, 0x04, 0x00, 0xc6,
-    0x00, 0xe9, 0x02, 0x20, 0x65, 0xe0, 0x18, 0x05,
-    0x4f, 0xf6, 0x07, 0x0f, 0x16, 0x4f, 0x26, 0xaf,
-    0xe9, 0x02, 0xeb, 0x02, 0x0f, 0x06, 0x0f, 0x06,
-    0x0f, 0x06, 0x12, 0x13, 0x12, 0x13, 0x27, 0xe5,
-    0x00, 0x00, 0xe5, 0x1c, 0x60, 0xe6, 0x06, 0x07,
-    0x86, 0x16, 0x26, 0x85, 0xe6, 0x03, 0x00, 0xe6,
-    0x1c, 0x00, 0xef, 0x00, 0x06, 0xaf, 0x00, 0x2f,
-    0x96, 0x6f, 0x36, 0xe0, 0x1d, 0xe5, 0x23, 0x27,
-    0x66, 0x07, 0xa6, 0x07, 0x26, 0x27, 0x26, 0x05,
-    0xe9, 0x02, 0xb6, 0xa5, 0x27, 0x26, 0x65, 0x46,
-    0x05, 0x47, 0x25, 0xc7, 0x45, 0x66, 0xe5, 0x05,
-    0x06, 0x27, 0x26, 0xa7, 0x06, 0x05, 0x07, 0xe9,
-    0x02, 0x47, 0x06, 0x2f, 0xe1, 0x1e, 0x00, 0x01,
-    0x80, 0x01, 0x20, 0xe2, 0x23, 0x16, 0x04, 0x42,
-    0xe5, 0x80, 0xc1, 0x00, 0x65, 0x20, 0xc5, 0x00,
-    0x05, 0x00, 0x65, 0x20, 0xe5, 0x21, 0x00, 0x65,
-    0x20, 0xe5, 0x19, 0x00, 0x65, 0x20, 0xc5, 0x00,
-    0x05, 0x00, 0x65, 0x20, 0xe5, 0x07, 0x00, 0xe5,
-    0x31, 0x00, 0x65, 0x20, 0xe5, 0x3b, 0x20, 0x46,
-    0xf6, 0x01, 0xeb, 0x0c, 0x40, 0xe5, 0x08, 0xef,
-    0x02, 0xa0, 0xe1, 0x4e, 0x20, 0xa2, 0x20, 0x11,
-    0xe5, 0x81, 0xe4, 0x0f, 0x16, 0xe5, 0x09, 0x17,
-    0xe5, 0x12, 0x12, 0x13, 0x40, 0xe5, 0x43, 0x56,
-    0x4a, 0xe5, 0x00, 0xc0, 0xe5, 0x0a, 0x46, 0x07,
-    0xe0, 0x01, 0xe5, 0x0b, 0x26, 0x07, 0x36, 0xe0,
-    0x01, 0xe5, 0x0a, 0x26, 0xe0, 0x04, 0xe5, 0x05,
-    0x00, 0x45, 0x00, 0x26, 0xe0, 0x04, 0xe5, 0x2c,
-    0x26, 0x07, 0xc6, 0xe7, 0x00, 0x06, 0x27, 0xe6,
-    0x03, 0x56, 0x04, 0x56, 0x0d, 0x05, 0x06, 0x20,
-    0xe9, 0x02, 0xa0, 0xeb, 0x02, 0xa0, 0xb6, 0x11,
-    0x76, 0x46, 0x1b, 0x06, 0xe9, 0x02, 0xa0, 0xe5,
-    0x1b, 0x04, 0xe5, 0x2d, 0xc0, 0x85, 0x26, 0xe5,
-    0x1a, 0x06, 0x05, 0x80, 0xe5, 0x3e, 0xe0, 0x02,
-    0xe5, 0x17, 0x00, 0x46, 0x67, 0x26, 0x47, 0x60,
-    0x27, 0x06, 0xa7, 0x46, 0x60, 0x0f, 0x40, 0x36,
-    0xe9, 0x02, 0xe5, 0x16, 0x20, 0x85, 0xe0, 0x03,
-    0xe5, 0x24, 0x60, 0xe5, 0x12, 0xa0, 0xe9, 0x02,
-    0x0b, 0x40, 0xef, 0x1a, 0xe5, 0x0f, 0x26, 0x27,
-    0x06, 0x20, 0x36, 0xe5, 0x2d, 0x07, 0x06, 0x07,
-    0xc6, 0x00, 0x06, 0x07, 0x06, 0x27, 0xe6, 0x00,
-    0xa7, 0xe6, 0x02, 0x20, 0x06, 0xe9, 0x02, 0xa0,
-    0xe9, 0x02, 0xa0, 0xd6, 0x04, 0xb6, 0x20, 0xe6,
-    0x06, 0x08, 0xe6, 0x08, 0xe0, 0x29, 0x66, 0x07,
-    0xe5, 0x27, 0x06, 0x07, 0x86, 0x07, 0x06, 0x87,
-    0x06, 0x27, 0xe5, 0x00, 0x40, 0xe9, 0x02, 0xd6,
-    0xef, 0x02, 0xe6, 0x01, 0xef, 0x01, 0x36, 0x00,
-    0x26, 0x07, 0xe5, 0x16, 0x07, 0x66, 0x27, 0x26,
-    0x07, 0x46, 0x25, 0xe9, 0x02, 0xe5, 0x24, 0x06,
-    0x07, 0x26, 0x47, 0x06, 0x07, 0x46, 0x27, 0xe0,
-    0x00, 0x76, 0xe5, 0x1c, 0xe7, 0x00, 0xe6, 0x00,
-    0x27, 0x26, 0x40, 0x96, 0xe9, 0x02, 0x40, 0x45,
-    0xe9, 0x02, 0xe5, 0x16, 0xa4, 0x36, 0xe2, 0x01,
-    0xc0, 0xe1, 0x23, 0x20, 0x41, 0xf6, 0x00, 0xe0,
-    0x00, 0x46, 0x16, 0xe6, 0x05, 0x07, 0xc6, 0x65,
-    0x06, 0xa5, 0x06, 0x25, 0x07, 0x26, 0x05, 0x80,
-    0xe2, 0x24, 0xe4, 0x37, 0xe2, 0x05, 0x04, 0xe2,
-    0x1a, 0xe4, 0x1d, 0xe6, 0x38, 0xff, 0x80, 0x0e,
-    0xe2, 0x00, 0xff, 0x5a, 0xe2, 0x00, 0xe1, 0x00,
-    0xa2, 0x20, 0xa1, 0x20, 0xe2, 0x00, 0xe1, 0x00,
-    0xe2, 0x00, 0xe1, 0x00, 0xa2, 0x20, 0xa1, 0x20,
-    0xe2, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01,
-    0x00, 0x3f, 0xc2, 0xe1, 0x00, 0xe2, 0x06, 0x20,
-    0xe2, 0x00, 0xe3, 0x00, 0xe2, 0x00, 0xe3, 0x00,
-    0xe2, 0x00, 0xe3, 0x00, 0x82, 0x00, 0x22, 0x61,
-    0x03, 0x0e, 0x02, 0x4e, 0x42, 0x00, 0x22, 0x61,
-    0x03, 0x4e, 0x62, 0x20, 0x22, 0x61, 0x00, 0x4e,
-    0xe2, 0x00, 0x81, 0x4e, 0x20, 0x42, 0x00, 0x22,
-    0x61, 0x03, 0x2e, 0x00, 0xf7, 0x03, 0x9b, 0xb1,
-    0x36, 0x14, 0x15, 0x12, 0x34, 0x15, 0x12, 0x14,
-    0xf6, 0x00, 0x18, 0x19, 0x9b, 0x17, 0xf6, 0x01,
-    0x14, 0x15, 0x76, 0x30, 0x56, 0x0c, 0x12, 0x13,
-    0xf6, 0x03, 0x0c, 0x16, 0x10, 0xf6, 0x02, 0x17,
-    0x9b, 0x00, 0xfb, 0x02, 0x0b, 0x04, 0x20, 0xab,
-    0x4c, 0x12, 0x13, 0x04, 0xeb, 0x02, 0x4c, 0x12,
-    0x13, 0x00, 0xe4, 0x05, 0x40, 0xed, 0x19, 0xe0,
-    0x07, 0xe6, 0x05, 0x68, 0x06, 0x48, 0xe6, 0x04,
-    0xe0, 0x07, 0x2f, 0x01, 0x6f, 0x01, 0x2f, 0x02,
-    0x41, 0x22, 0x41, 0x02, 0x0f, 0x01, 0x2f, 0x0c,
-    0x81, 0xaf, 0x01, 0x0f, 0x01, 0x0f, 0x01, 0x0f,
-    0x61, 0x0f, 0x02, 0x61, 0x02, 0x65, 0x02, 0x2f,
-    0x22, 0x21, 0x8c, 0x3f, 0x42, 0x0f, 0x0c, 0x2f,
-    0x02, 0x0f, 0xeb, 0x08, 0xea, 0x1b, 0x3f, 0x6a,
-    0x0b, 0x2f, 0x60, 0x8c, 0x8f, 0x2c, 0x6f, 0x0c,
-    0x2f, 0x0c, 0x2f, 0x0c, 0xcf, 0x0c, 0xef, 0x17,
-    0x2c, 0x2f, 0x0c, 0x0f, 0x0c, 0xef, 0x17, 0xec,
-    0x80, 0x84, 0xef, 0x00, 0x12, 0x13, 0x12, 0x13,
-    0xef, 0x0c, 0x2c, 0xcf, 0x12, 0x13, 0xef, 0x49,
-    0x0c, 0xef, 0x16, 0xec, 0x11, 0xef, 0x20, 0xac,
-    0xef, 0x3d, 0xe0, 0x11, 0xef, 0x03, 0xe0, 0x0d,
-    0xeb, 0x34, 0xef, 0x46, 0xeb, 0x0e, 0xef, 0x80,
-    0x2f, 0x0c, 0xef, 0x01, 0x0c, 0xef, 0x2e, 0xec,
-    0x00, 0xef, 0x67, 0x0c, 0xef, 0x80, 0x70, 0x12,
-    0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x12,
-    0x13, 0x12, 0x13, 0x12, 0x13, 0xeb, 0x16, 0xef,
-    0x24, 0x8c, 0x12, 0x13, 0xec, 0x17, 0x12, 0x13,
+    0x25, 0xe0, 0x05, 0x26, 0x27, 0xe5, 0x01, 0x00,
+    0x45, 0x00, 0xe5, 0x21, 0x26, 0x05, 0x47, 0x66,
+    0x00, 0x47, 0x00, 0x47, 0x06, 0x05, 0x0f, 0x60,
+    0x45, 0x07, 0xcb, 0x45, 0x26, 0x20, 0xe9, 0x02,
+    0xeb, 0x01, 0x0f, 0xa5, 0x00, 0x06, 0x27, 0x00,
+    0xe5, 0x0a, 0x40, 0xe5, 0x10, 0x00, 0xe5, 0x01,
+    0x00, 0x05, 0x20, 0xc5, 0x40, 0x06, 0x60, 0x47,
+    0x46, 0x00, 0x06, 0x00, 0xe7, 0x00, 0xa0, 0xe9,
+    0x02, 0x20, 0x27, 0x16, 0xe0, 0x04, 0xe5, 0x28,
+    0x06, 0x25, 0xc6, 0x60, 0x0d, 0xa5, 0x04, 0xe6,
+    0x00, 0x16, 0xe9, 0x02, 0x36, 0xe0, 0x1d, 0x25,
+    0x00, 0x05, 0x00, 0x85, 0x00, 0xe5, 0x10, 0x00,
+    0x05, 0x00, 0xe5, 0x02, 0x06, 0x25, 0xe6, 0x01,
+    0x05, 0x20, 0x85, 0x00, 0x04, 0x00, 0xa6, 0x20,
+    0xe9, 0x02, 0x20, 0x65, 0xe0, 0x18, 0x05, 0x4f,
+    0xf6, 0x07, 0x0f, 0x16, 0x4f, 0x26, 0xaf, 0xe9,
+    0x02, 0xeb, 0x02, 0x0f, 0x06, 0x0f, 0x06, 0x0f,
+    0x06, 0x12, 0x13, 0x12, 0x13, 0x27, 0xe5, 0x00,
+    0x00, 0xe5, 0x1c, 0x60, 0xe6, 0x06, 0x07, 0x86,
+    0x16, 0x26, 0x85, 0xe6, 0x03, 0x00, 0xe6, 0x1c,
+    0x00, 0xef, 0x00, 0x06, 0xaf, 0x00, 0x2f, 0x96,
+    0x6f, 0x36, 0xe0, 0x1d, 0xe5, 0x23, 0x27, 0x66,
+    0x07, 0xa6, 0x07, 0x26, 0x27, 0x26, 0x05, 0xe9,
+    0x02, 0xb6, 0xa5, 0x27, 0x26, 0x65, 0x46, 0x05,
+    0x47, 0x25, 0xc7, 0x45, 0x66, 0xe5, 0x05, 0x06,
+    0x27, 0x26, 0xa7, 0x06, 0x05, 0x07, 0xe9, 0x02,
+    0x47, 0x06, 0x2f, 0xe1, 0x1e, 0x00, 0x01, 0x80,
+    0x01, 0x20, 0xe2, 0x23, 0x16, 0x04, 0x42, 0xe5,
+    0x80, 0xc1, 0x00, 0x65, 0x20, 0xc5, 0x00, 0x05,
+    0x00, 0x65, 0x20, 0xe5, 0x21, 0x00, 0x65, 0x20,
+    0xe5, 0x19, 0x00, 0x65, 0x20, 0xc5, 0x00, 0x05,
+    0x00, 0x65, 0x20, 0xe5, 0x07, 0x00, 0xe5, 0x31,
+    0x00, 0x65, 0x20, 0xe5, 0x3b, 0x20, 0x46, 0xf6,
+    0x01, 0xeb, 0x0c, 0x40, 0xe5, 0x08, 0xef, 0x02,
+    0xa0, 0xe1, 0x4e, 0x20, 0xa2, 0x20, 0x11, 0xe5,
+    0x81, 0xe4, 0x0f, 0x16, 0xe5, 0x09, 0x17, 0xe5,
+    0x12, 0x12, 0x13, 0x40, 0xe5, 0x43, 0x56, 0x4a,
+    0xe5, 0x00, 0xc0, 0xe5, 0x0a, 0x46, 0x07, 0xe0,
+    0x01, 0xe5, 0x0b, 0x26, 0x07, 0x36, 0xe0, 0x01,
+    0xe5, 0x0a, 0x26, 0xe0, 0x04, 0xe5, 0x05, 0x00,
+    0x45, 0x00, 0x26, 0xe0, 0x04, 0xe5, 0x2c, 0x26,
+    0x07, 0xc6, 0xe7, 0x00, 0x06, 0x27, 0xe6, 0x03,
+    0x56, 0x04, 0x56, 0x0d, 0x05, 0x06, 0x20, 0xe9,
+    0x02, 0xa0, 0xeb, 0x02, 0xa0, 0xb6, 0x11, 0x76,
+    0x46, 0x1b, 0x06, 0xe9, 0x02, 0xa0, 0xe5, 0x1b,
+    0x04, 0xe5, 0x2d, 0xc0, 0x85, 0x26, 0xe5, 0x1a,
+    0x06, 0x05, 0x80, 0xe5, 0x3e, 0xe0, 0x02, 0xe5,
+    0x17, 0x00, 0x46, 0x67, 0x26, 0x47, 0x60, 0x27,
+    0x06, 0xa7, 0x46, 0x60, 0x0f, 0x40, 0x36, 0xe9,
+    0x02, 0xe5, 0x16, 0x20, 0x85, 0xe0, 0x03, 0xe5,
+    0x24, 0x60, 0xe5, 0x12, 0xa0, 0xe9, 0x02, 0x0b,
+    0x40, 0xef, 0x1a, 0xe5, 0x0f, 0x26, 0x27, 0x06,
+    0x20, 0x36, 0xe5, 0x2d, 0x07, 0x06, 0x07, 0xc6,
+    0x00, 0x06, 0x07, 0x06, 0x27, 0xe6, 0x00, 0xa7,
+    0xe6, 0x02, 0x20, 0x06, 0xe9, 0x02, 0xa0, 0xe9,
+    0x02, 0xa0, 0xd6, 0x04, 0xb6, 0x20, 0xe6, 0x06,
+    0x08, 0xe6, 0x08, 0xe0, 0x29, 0x66, 0x07, 0xe5,
+    0x27, 0x06, 0x07, 0x86, 0x07, 0x06, 0x87, 0x06,
+    0x27, 0xe5, 0x00, 0x40, 0xe9, 0x02, 0xd6, 0xef,
+    0x02, 0xe6, 0x01, 0xef, 0x01, 0x36, 0x00, 0x26,
+    0x07, 0xe5, 0x16, 0x07, 0x66, 0x27, 0x26, 0x07,
+    0x46, 0x25, 0xe9, 0x02, 0xe5, 0x24, 0x06, 0x07,
+    0x26, 0x47, 0x06, 0x07, 0x46, 0x27, 0xe0, 0x00,
+    0x76, 0xe5, 0x1c, 0xe7, 0x00, 0xe6, 0x00, 0x27,
+    0x26, 0x40, 0x96, 0xe9, 0x02, 0x40, 0x45, 0xe9,
+    0x02, 0xe5, 0x16, 0xa4, 0x36, 0xe2, 0x01, 0xc0,
+    0xe1, 0x23, 0x20, 0x41, 0xf6, 0x00, 0xe0, 0x00,
+    0x46, 0x16, 0xe6, 0x05, 0x07, 0xc6, 0x65, 0x06,
+    0xa5, 0x06, 0x25, 0x07, 0x26, 0x05, 0x80, 0xe2,
+    0x24, 0xe4, 0x37, 0xe2, 0x05, 0x04, 0xe2, 0x1a,
+    0xe4, 0x1d, 0xe6, 0x38, 0xff, 0x80, 0x0e, 0xe2,
+    0x00, 0xff, 0x5a, 0xe2, 0x00, 0xe1, 0x00, 0xa2,
+    0x20, 0xa1, 0x20, 0xe2, 0x00, 0xe1, 0x00, 0xe2,
+    0x00, 0xe1, 0x00, 0xa2, 0x20, 0xa1, 0x20, 0xe2,
+    0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
+    0x3f, 0xc2, 0xe1, 0x00, 0xe2, 0x06, 0x20, 0xe2,
+    0x00, 0xe3, 0x00, 0xe2, 0x00, 0xe3, 0x00, 0xe2,
+    0x00, 0xe3, 0x00, 0x82, 0x00, 0x22, 0x61, 0x03,
+    0x0e, 0x02, 0x4e, 0x42, 0x00, 0x22, 0x61, 0x03,
+    0x4e, 0x62, 0x20, 0x22, 0x61, 0x00, 0x4e, 0xe2,
+    0x00, 0x81, 0x4e, 0x20, 0x42, 0x00, 0x22, 0x61,
+    0x03, 0x2e, 0x00, 0xf7, 0x03, 0x9b, 0xb1, 0x36,
+    0x14, 0x15, 0x12, 0x34, 0x15, 0x12, 0x14, 0xf6,
+    0x00, 0x18, 0x19, 0x9b, 0x17, 0xf6, 0x01, 0x14,
+    0x15, 0x76, 0x30, 0x56, 0x0c, 0x12, 0x13, 0xf6,
+    0x03, 0x0c, 0x16, 0x10, 0xf6, 0x02, 0x17, 0x9b,
+    0x00, 0xfb, 0x02, 0x0b, 0x04, 0x20, 0xab, 0x4c,
+    0x12, 0x13, 0x04, 0xeb, 0x02, 0x4c, 0x12, 0x13,
+    0x00, 0xe4, 0x05, 0x40, 0xed, 0x19, 0xe0, 0x07,
+    0xe6, 0x05, 0x68, 0x06, 0x48, 0xe6, 0x04, 0xe0,
+    0x07, 0x2f, 0x01, 0x6f, 0x01, 0x2f, 0x02, 0x41,
+    0x22, 0x41, 0x02, 0x0f, 0x01, 0x2f, 0x0c, 0x81,
+    0xaf, 0x01, 0x0f, 0x01, 0x0f, 0x01, 0x0f, 0x61,
+    0x0f, 0x02, 0x61, 0x02, 0x65, 0x02, 0x2f, 0x22,
+    0x21, 0x8c, 0x3f, 0x42, 0x0f, 0x0c, 0x2f, 0x02,
+    0x0f, 0xeb, 0x08, 0xea, 0x1b, 0x3f, 0x6a, 0x0b,
+    0x2f, 0x60, 0x8c, 0x8f, 0x2c, 0x6f, 0x0c, 0x2f,
+    0x0c, 0x2f, 0x0c, 0xcf, 0x0c, 0xef, 0x17, 0x2c,
+    0x2f, 0x0c, 0x0f, 0x0c, 0xef, 0x17, 0xec, 0x80,
+    0x84, 0xef, 0x00, 0x12, 0x13, 0x12, 0x13, 0xef,
+    0x0c, 0x2c, 0xcf, 0x12, 0x13, 0xef, 0x49, 0x0c,
+    0xef, 0x16, 0xec, 0x11, 0xef, 0x20, 0xac, 0xef,
+    0x3d, 0xe0, 0x11, 0xef, 0x03, 0xe0, 0x0d, 0xeb,
+    0x34, 0xef, 0x46, 0xeb, 0x0e, 0xef, 0x80, 0x2f,
+    0x0c, 0xef, 0x01, 0x0c, 0xef, 0x2e, 0xec, 0x00,
+    0xef, 0x67, 0x0c, 0xef, 0x80, 0x70, 0x12, 0x13,
     0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13,
-    0xec, 0x08, 0xef, 0x80, 0x78, 0xec, 0x7b, 0x12,
-    0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x12,
-    0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x12,
-    0x13, 0x12, 0x13, 0x12, 0x13, 0xec, 0x37, 0x12,
-    0x13, 0x12, 0x13, 0xec, 0x18, 0x12, 0x13, 0xec,
-    0x80, 0x7a, 0xef, 0x28, 0xec, 0x0d, 0x2f, 0xac,
-    0xef, 0x1f, 0x20, 0xef, 0x18, 0x00, 0xef, 0x61,
-    0xe1, 0x28, 0xe2, 0x28, 0x5f, 0x21, 0x22, 0xdf,
-    0x41, 0x02, 0x3f, 0x02, 0x3f, 0x82, 0x24, 0x41,
-    0x02, 0xff, 0x5a, 0x02, 0xaf, 0x7f, 0x46, 0x3f,
-    0x80, 0x76, 0x0b, 0x36, 0xe2, 0x1e, 0x00, 0x02,
-    0x80, 0x02, 0x20, 0xe5, 0x30, 0xc0, 0x04, 0x16,
-    0xe0, 0x06, 0x06, 0xe5, 0x0f, 0xe0, 0x01, 0xc5,
-    0x00, 0xc5, 0x00, 0xc5, 0x00, 0xc5, 0x00, 0xc5,
-    0x00, 0xc5, 0x00, 0xc5, 0x00, 0xc5, 0x00, 0xe6,
-    0x18, 0x36, 0x14, 0x15, 0x14, 0x15, 0x56, 0x14,
-    0x15, 0x16, 0x14, 0x15, 0xf6, 0x01, 0x11, 0x36,
-    0x11, 0x16, 0x14, 0x15, 0x36, 0x14, 0x15, 0x12,
-    0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x96,
-    0x04, 0xf6, 0x02, 0x31, 0x76, 0x11, 0x16, 0x12,
-    0xf6, 0x05, 0x2f, 0x56, 0x12, 0x13, 0x12, 0x13,
-    0x12, 0x13, 0x12, 0x13, 0x11, 0xe0, 0x1a, 0xef,
-    0x12, 0x00, 0xef, 0x51, 0xe0, 0x04, 0xef, 0x80,
-    0x4e, 0xe0, 0x12, 0xef, 0x04, 0x60, 0x17, 0x56,
-    0x0f, 0x04, 0x05, 0x0a, 0x12, 0x13, 0x12, 0x13,
-    0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x2f, 0x12,
-    0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x11,
-    0x12, 0x33, 0x0f, 0xea, 0x01, 0x66, 0x27, 0x11,
-    0x84, 0x2f, 0x4a, 0x04, 0x05, 0x16, 0x2f, 0x00,
-    0xe5, 0x4e, 0x20, 0x26, 0x2e, 0x24, 0x05, 0x11,
-    0xe5, 0x52, 0x16, 0x44, 0x05, 0x80, 0xe5, 0x23,
-    0x00, 0xe5, 0x56, 0x00, 0x2f, 0x6b, 0xef, 0x02,
-    0xe5, 0x18, 0xef, 0x1c, 0xe0, 0x04, 0xe5, 0x08,
-    0xef, 0x17, 0x00, 0xeb, 0x02, 0xef, 0x16, 0xeb,
-    0x00, 0x0f, 0xeb, 0x07, 0xef, 0x18, 0xeb, 0x02,
-    0xef, 0x1f, 0xeb, 0x07, 0xef, 0x80, 0xb8, 0xe5,
-    0x99, 0x38, 0xef, 0x38, 0xe5, 0xc0, 0x11, 0x8d,
-    0x04, 0xe5, 0x83, 0xef, 0x40, 0xef, 0x2f, 0xe0,
-    0x01, 0xe5, 0x20, 0xa4, 0x36, 0xe5, 0x80, 0x84,
-    0x04, 0x56, 0xe5, 0x08, 0xe9, 0x02, 0x25, 0xe0,
-    0x0c, 0xff, 0x26, 0x05, 0x06, 0x48, 0x16, 0xe6,
-    0x02, 0x16, 0x04, 0xff, 0x14, 0x24, 0x26, 0xe5,
-    0x3e, 0xea, 0x02, 0x26, 0xb6, 0xe0, 0x00, 0xee,
-    0x0f, 0xe4, 0x01, 0x2e, 0xff, 0x06, 0x22, 0xff,
-    0x36, 0x04, 0xe2, 0x00, 0x9f, 0xff, 0x02, 0x04,
-    0x2e, 0x7f, 0x05, 0x7f, 0x22, 0xff, 0x0d, 0x61,
-    0x02, 0x81, 0x02, 0xff, 0x07, 0x41, 0x02, 0x3f,
-    0x80, 0x3f, 0x00, 0x02, 0x00, 0x02, 0x7f, 0xe0,
-    0x10, 0x44, 0x3f, 0x05, 0x24, 0x02, 0xc5, 0x06,
-    0x45, 0x06, 0x65, 0x06, 0xe5, 0x0f, 0x27, 0x26,
-    0x07, 0x6f, 0x06, 0x40, 0xab, 0x2f, 0x0d, 0x0f,
-    0xa0, 0xe5, 0x2c, 0x76, 0xe0, 0x00, 0x27, 0xe5,
-    0x2a, 0xe7, 0x08, 0x26, 0xe0, 0x00, 0x36, 0xe9,
-    0x02, 0xa0, 0xe6, 0x0a, 0xa5, 0x56, 0x05, 0x16,
-    0x25, 0x06, 0xe9, 0x02, 0xe5, 0x14, 0xe6, 0x00,
-    0x36, 0xe5, 0x0f, 0xe6, 0x03, 0x27, 0xe0, 0x03,
-    0x16, 0xe5, 0x15, 0x40, 0x46, 0x07, 0xe5, 0x27,
-    0x06, 0x27, 0x66, 0x27, 0x26, 0x47, 0xf6, 0x05,
-    0x00, 0x04, 0xe9, 0x02, 0x60, 0x36, 0x85, 0x06,
-    0x04, 0xe5, 0x01, 0xe9, 0x02, 0x85, 0x00, 0xe5,
-    0x21, 0xa6, 0x27, 0x26, 0x27, 0x26, 0xe0, 0x01,
-    0x45, 0x06, 0xe5, 0x00, 0x06, 0x07, 0x20, 0xe9,
-    0x02, 0x20, 0x76, 0xe5, 0x08, 0x04, 0xa5, 0x4f,
-    0x05, 0x07, 0x06, 0x07, 0xe5, 0x2a, 0x06, 0x05,
-    0x46, 0x25, 0x26, 0x85, 0x26, 0x05, 0x06, 0x05,
-    0xe0, 0x10, 0x25, 0x04, 0x36, 0xe5, 0x03, 0x07,
-    0x26, 0x27, 0x36, 0x05, 0x24, 0x07, 0x06, 0xe0,
-    0x02, 0xa5, 0x20, 0xa5, 0x20, 0xa5, 0xe0, 0x01,
-    0xc5, 0x00, 0xc5, 0x00, 0xe2, 0x23, 0x0e, 0x64,
-    0xe2, 0x01, 0x04, 0x2e, 0x60, 0xe2, 0x48, 0xe5,
-    0x1b, 0x27, 0x06, 0x27, 0x06, 0x27, 0x16, 0x07,
-    0x06, 0x20, 0xe9, 0x02, 0xa0, 0xe5, 0xab, 0x1c,
-    0xe0, 0x04, 0xe5, 0x0f, 0x60, 0xe5, 0x29, 0x60,
-    0xfc, 0x87, 0x78, 0xfd, 0x98, 0x78, 0xe5, 0x80,
-    0xe6, 0x20, 0xe5, 0x62, 0xe0, 0x1e, 0xc2, 0xe0,
-    0x04, 0x82, 0x80, 0x05, 0x06, 0xe5, 0x02, 0x0c,
-    0xe5, 0x05, 0x00, 0x85, 0x00, 0x05, 0x00, 0x25,
-    0x00, 0x25, 0x00, 0xe5, 0x64, 0xee, 0x09, 0xe0,
-    0x08, 0xe5, 0x80, 0xe3, 0x13, 0x12, 0xef, 0x08,
-    0xe5, 0x38, 0x20, 0xe5, 0x2e, 0xc0, 0x0f, 0xe0,
-    0x18, 0xe5, 0x04, 0x0d, 0x4f, 0xe6, 0x08, 0xd6,
-    0x12, 0x13, 0x16, 0xa0, 0xe6, 0x08, 0x16, 0x31,
-    0x30, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x12,
-    0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x12,
-    0x13, 0x36, 0x12, 0x13, 0x76, 0x50, 0x56, 0x00,
-    0x76, 0x11, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13,
-    0x56, 0x0c, 0x11, 0x4c, 0x00, 0x16, 0x0d, 0x36,
-    0x60, 0x85, 0x00, 0xe5, 0x7f, 0x20, 0x1b, 0x00,
-    0x56, 0x0d, 0x56, 0x12, 0x13, 0x16, 0x0c, 0x16,
-    0x11, 0x36, 0xe9, 0x02, 0x36, 0x4c, 0x36, 0xe1,
-    0x12, 0x12, 0x16, 0x13, 0x0e, 0x10, 0x0e, 0xe2,
-    0x12, 0x12, 0x0c, 0x13, 0x0c, 0x12, 0x13, 0x16,
-    0x12, 0x13, 0x36, 0xe5, 0x02, 0x04, 0xe5, 0x25,
-    0x24, 0xe5, 0x17, 0x40, 0xa5, 0x20, 0xa5, 0x20,
-    0xa5, 0x20, 0x45, 0x40, 0x2d, 0x0c, 0x0e, 0x0f,
-    0x2d, 0x00, 0x0f, 0x6c, 0x2f, 0xe0, 0x02, 0x5b,
-    0x2f, 0x20, 0xe5, 0x04, 0x00, 0xe5, 0x12, 0x00,
-    0xe5, 0x0b, 0x00, 0x25, 0x00, 0xe5, 0x07, 0x20,
-    0xe5, 0x06, 0xe0, 0x1a, 0xe5, 0x73, 0x80, 0x56,
-    0x60, 0xeb, 0x25, 0x40, 0xef, 0x01, 0xea, 0x2d,
-    0x6b, 0xef, 0x09, 0x2b, 0x4f, 0x00, 0xef, 0x05,
-    0x40, 0x0f, 0xe0, 0x27, 0xef, 0x25, 0x06, 0xe0,
-    0x7a, 0xe5, 0x15, 0x40, 0xe5, 0x29, 0xe0, 0x07,
-    0x06, 0xeb, 0x13, 0x60, 0xe5, 0x18, 0x6b, 0xe0,
-    0x01, 0xe5, 0x0c, 0x0a, 0xe5, 0x00, 0x0a, 0x80,
-    0xe5, 0x1e, 0x86, 0x80, 0xe5, 0x16, 0x00, 0x16,
-    0xe5, 0x1c, 0x60, 0xe5, 0x00, 0x16, 0x8a, 0xe0,
-    0x22, 0xe1, 0x20, 0xe2, 0x20, 0xe5, 0x46, 0x20,
-    0xe9, 0x02, 0xa0, 0xe1, 0x1c, 0x60, 0xe2, 0x1c,
-    0x60, 0xe5, 0x20, 0xe0, 0x00, 0xe5, 0x2c, 0xe0,
-    0x03, 0x16, 0xe1, 0x03, 0x00, 0xe1, 0x07, 0x00,
-    0xc1, 0x00, 0x21, 0x00, 0xe2, 0x03, 0x00, 0xe2,
-    0x07, 0x00, 0xc2, 0x00, 0x22, 0xe0, 0x3b, 0xe5,
-    0x80, 0xaf, 0xe0, 0x01, 0xe5, 0x0e, 0xe0, 0x02,
-    0xe5, 0x00, 0xe0, 0x10, 0xa4, 0x00, 0xe4, 0x22,
-    0x00, 0xe4, 0x01, 0xe0, 0x3d, 0xa5, 0x20, 0x05,
-    0x00, 0xe5, 0x24, 0x00, 0x25, 0x40, 0x05, 0x20,
-    0xe5, 0x0f, 0x00, 0x16, 0xeb, 0x00, 0xe5, 0x0f,
-    0x2f, 0xcb, 0xe5, 0x17, 0xe0, 0x00, 0xeb, 0x01,
-    0xe0, 0x28, 0xe5, 0x0b, 0x00, 0x25, 0x80, 0x8b,
-    0xe5, 0x0e, 0xab, 0x40, 0x16, 0xe5, 0x12, 0x80,
-    0x16, 0xe0, 0x38, 0xe5, 0x30, 0x60, 0x2b, 0x25,
-    0xeb, 0x08, 0x20, 0xeb, 0x26, 0x05, 0x46, 0x00,
-    0x26, 0x80, 0x66, 0x65, 0x00, 0x45, 0x00, 0xe5,
-    0x15, 0x20, 0x46, 0x60, 0x06, 0xeb, 0x01, 0xc0,
-    0xf6, 0x01, 0xc0, 0xe5, 0x15, 0x2b, 0x16, 0xe5,
-    0x15, 0x4b, 0xe0, 0x18, 0xe5, 0x00, 0x0f, 0xe5,
-    0x14, 0x26, 0x60, 0x8b, 0xd6, 0xe0, 0x01, 0xe5,
-    0x2e, 0x40, 0xd6, 0xe5, 0x0e, 0x20, 0xeb, 0x00,
-    0xe5, 0x0b, 0x80, 0xeb, 0x00, 0xe5, 0x0a, 0xc0,
-    0x76, 0xe0, 0x04, 0xcb, 0xe0, 0x48, 0xe5, 0x41,
-    0xe0, 0x2f, 0xe1, 0x2b, 0xe0, 0x05, 0xe2, 0x2b,
-    0xc0, 0xab, 0xe5, 0x1c, 0x66, 0xe0, 0x00, 0xe9,
-    0x02, 0xe0, 0x80, 0x9e, 0xeb, 0x17, 0x00, 0xe5,
-    0x22, 0x00, 0x26, 0x11, 0x20, 0x25, 0xe0, 0x43,
-    0x46, 0xe5, 0x15, 0xeb, 0x02, 0x05, 0xe0, 0x00,
-    0xe5, 0x0e, 0xe6, 0x03, 0x6b, 0x96, 0xe0, 0x0e,
-    0xe5, 0x0a, 0x66, 0x76, 0xe0, 0x1e, 0xe5, 0x0d,
-    0xcb, 0xe0, 0x0c, 0xe5, 0x0f, 0xe0, 0x01, 0x07,
-    0x06, 0x07, 0xe5, 0x2d, 0xe6, 0x07, 0xd6, 0x60,
-    0xeb, 0x0c, 0xe9, 0x02, 0x06, 0x25, 0x26, 0x05,
-    0xe0, 0x01, 0x46, 0x07, 0xe5, 0x25, 0x47, 0x66,
-    0x27, 0x26, 0x36, 0x1b, 0x76, 0x06, 0xe0, 0x02,
-    0x1b, 0x20, 0xe5, 0x11, 0xc0, 0xe9, 0x02, 0xa0,
-    0x46, 0xe5, 0x1c, 0x86, 0x07, 0xe6, 0x00, 0x00,
-    0xe9, 0x02, 0x76, 0x05, 0x27, 0x05, 0xe0, 0x00,
-    0xe5, 0x1b, 0x06, 0x36, 0x05, 0xe0, 0x01, 0x26,
-    0x07, 0xe5, 0x28, 0x47, 0xe6, 0x01, 0x27, 0x65,
-    0x76, 0x66, 0x16, 0x07, 0x06, 0xe9, 0x02, 0x05,
-    0x16, 0x05, 0x56, 0x00, 0xeb, 0x0c, 0xe0, 0x03,
-    0xe5, 0x0a, 0x00, 0xe5, 0x11, 0x47, 0x46, 0x27,
-    0x06, 0x07, 0x26, 0xb6, 0x06, 0x25, 0x06, 0xe0,
-    0x36, 0xc5, 0x00, 0x05, 0x00, 0x65, 0x00, 0xe5,
-    0x07, 0x00, 0xe5, 0x02, 0x16, 0xa0, 0xe5, 0x27,
-    0x06, 0x47, 0xe6, 0x00, 0x80, 0xe9, 0x02, 0xa0,
-    0x26, 0x27, 0x00, 0xe5, 0x00, 0x20, 0x25, 0x20,
-    0xe5, 0x0e, 0x00, 0xc5, 0x00, 0x25, 0x00, 0x85,
-    0x00, 0x26, 0x05, 0x27, 0x06, 0x67, 0x20, 0x27,
-    0x20, 0x47, 0x20, 0x05, 0xa0, 0x07, 0x80, 0x85,
-    0x27, 0x20, 0xc6, 0x40, 0x86, 0xe0, 0x80, 0x03,
-    0xe5, 0x2d, 0x47, 0xe6, 0x00, 0x27, 0x46, 0x07,
-    0x06, 0x65, 0x96, 0xe9, 0x02, 0x36, 0x00, 0x16,
-    0x06, 0x45, 0xe0, 0x16, 0xe5, 0x28, 0x47, 0xa6,
-    0x07, 0x06, 0x67, 0x26, 0x07, 0x26, 0x25, 0x16,
-    0x05, 0xe0, 0x00, 0xe9, 0x02, 0xe0, 0x80, 0x1e,
-    0xe5, 0x27, 0x47, 0x66, 0x20, 0x67, 0x26, 0x07,
-    0x26, 0xf6, 0x0f, 0x65, 0x26, 0xe0, 0x1a, 0xe5,
-    0x28, 0x47, 0xe6, 0x00, 0x27, 0x06, 0x07, 0x26,
-    0x56, 0x05, 0xe0, 0x03, 0xe9, 0x02, 0xa0, 0xf6,
-    0x05, 0xe0, 0x0b, 0xe5, 0x23, 0x06, 0x07, 0x06,
-    0x27, 0xa6, 0x07, 0x06, 0x05, 0x16, 0xa0, 0xe9,
-    0x02, 0xe0, 0x2e, 0xe5, 0x13, 0x20, 0x46, 0x27,
-    0x66, 0x07, 0x86, 0x60, 0xe9, 0x02, 0x2b, 0x56,
-    0x0f, 0xc5, 0xe0, 0x80, 0x31, 0xe5, 0x24, 0x47,
-    0xe6, 0x01, 0x07, 0x26, 0x16, 0xe0, 0x5c, 0xe1,
-    0x18, 0xe2, 0x18, 0xe9, 0x02, 0xeb, 0x01, 0xe0,
-    0x04, 0xe5, 0x00, 0x20, 0x05, 0x20, 0xe5, 0x00,
-    0x00, 0x25, 0x00, 0xe5, 0x10, 0xa7, 0x00, 0x27,
-    0x20, 0x26, 0x07, 0x06, 0x05, 0x07, 0x05, 0x07,
-    0x06, 0x56, 0xe0, 0x01, 0xe9, 0x02, 0xe0, 0x3e,
-    0xe5, 0x00, 0x20, 0xe5, 0x1f, 0x47, 0x66, 0x20,
-    0x26, 0x67, 0x06, 0x05, 0x16, 0x05, 0x07, 0xe0,
-    0x13, 0x05, 0xe6, 0x02, 0xe5, 0x20, 0xa6, 0x07,
-    0x05, 0x66, 0xf6, 0x00, 0x06, 0xe0, 0x00, 0x05,
-    0xa6, 0x27, 0x46, 0xe5, 0x26, 0xe6, 0x05, 0x07,
-    0x26, 0x56, 0x05, 0x96, 0xe0, 0x05, 0xe5, 0x41,
-    0xc0, 0xf6, 0x02, 0xe0, 0x80, 0x6e, 0xe5, 0x01,
-    0x00, 0xe5, 0x1d, 0x07, 0xc6, 0x00, 0xa6, 0x07,
-    0x06, 0x05, 0x96, 0xe0, 0x02, 0xe9, 0x02, 0xeb,
-    0x0b, 0x40, 0x36, 0xe5, 0x16, 0x20, 0xe6, 0x0e,
-    0x00, 0x07, 0xc6, 0x07, 0x26, 0x07, 0x26, 0xe0,
-    0x41, 0xc5, 0x00, 0x25, 0x00, 0xe5, 0x1e, 0xa6,
-    0x40, 0x06, 0x00, 0x26, 0x00, 0xc6, 0x05, 0x06,
-    0xe0, 0x00, 0xe9, 0x02, 0xa0, 0xa5, 0x00, 0x25,
-    0x00, 0xe5, 0x18, 0x87, 0x00, 0x26, 0x00, 0x27,
-    0x06, 0x07, 0x06, 0x05, 0xc0, 0xe9, 0x02, 0xe0,
-    0x80, 0xae, 0xe5, 0x0b, 0x26, 0x27, 0x36, 0xc0,
-    0x26, 0x05, 0x07, 0xe5, 0x05, 0x00, 0xe5, 0x1a,
-    0x27, 0x86, 0x40, 0x27, 0x06, 0x07, 0x06, 0xf6,
-    0x05, 0xe9, 0x02, 0xe0, 0x4e, 0x05, 0xe0, 0x07,
-    0xeb, 0x0d, 0xef, 0x00, 0x6d, 0xef, 0x09, 0xe0,
-    0x05, 0x16, 0xe5, 0x83, 0x12, 0xe0, 0x5e, 0xea,
-    0x67, 0x00, 0x96, 0xe0, 0x03, 0xe5, 0x80, 0x3c,
-    0xe0, 0x89, 0xc4, 0xe5, 0x59, 0x36, 0xe0, 0x05,
-    0xe5, 0x83, 0xa8, 0xfb, 0x08, 0x06, 0xa5, 0xe6,
-    0x07, 0xe0, 0x8f, 0x22, 0xe5, 0x81, 0xbf, 0xe0,
-    0xa1, 0x31, 0xe5, 0x81, 0xb1, 0xc0, 0xe5, 0x17,
-    0x00, 0xe9, 0x02, 0x60, 0x36, 0xe5, 0x47, 0x00,
-    0xe9, 0x02, 0xa0, 0xe5, 0x16, 0x20, 0x86, 0x16,
-    0xe0, 0x02, 0xe5, 0x28, 0xc6, 0x96, 0x6f, 0x64,
-    0x16, 0x0f, 0xe0, 0x02, 0xe9, 0x02, 0x00, 0xcb,
-    0x00, 0xe5, 0x0d, 0x80, 0xe5, 0x0b, 0xe0, 0x82,
-    0x28, 0xe1, 0x18, 0xe2, 0x18, 0xeb, 0x0f, 0x76,
-    0xe0, 0x5d, 0xe5, 0x43, 0x60, 0x06, 0x05, 0xe7,
-    0x2f, 0xc0, 0x66, 0xe4, 0x05, 0xe0, 0x38, 0x24,
-    0x16, 0x04, 0x06, 0xe0, 0x03, 0x27, 0xe0, 0x06,
-    0xe5, 0x97, 0x70, 0xe0, 0x00, 0xe5, 0x84, 0x4e,
-    0xe0, 0x22, 0xe5, 0x01, 0xe0, 0xa2, 0x5f, 0x64,
-    0x00, 0xc4, 0x00, 0x24, 0x00, 0xe5, 0x80, 0x9b,
-    0xe0, 0x07, 0x05, 0xe0, 0x15, 0x45, 0x20, 0x05,
-    0xe0, 0x06, 0x65, 0xe0, 0x00, 0xe5, 0x81, 0x04,
-    0xe0, 0x88, 0x7c, 0xe5, 0x63, 0x80, 0xe5, 0x05,
-    0x40, 0xe5, 0x01, 0xc0, 0xe5, 0x02, 0x20, 0x0f,
-    0x26, 0x16, 0x7b, 0xe0, 0x91, 0xd4, 0xe6, 0x26,
-    0x20, 0xe6, 0x0f, 0xe0, 0x01, 0xef, 0x6c, 0xe0,
-    0x34, 0xef, 0x80, 0x6e, 0xe0, 0x02, 0xef, 0x1f,
-    0x20, 0xef, 0x34, 0x27, 0x46, 0x4f, 0xa7, 0xfb,
-    0x00, 0xe6, 0x00, 0x2f, 0xc6, 0xef, 0x16, 0x66,
-    0xef, 0x35, 0xe0, 0x0d, 0xef, 0x3a, 0x46, 0x0f,
-    0xe0, 0x72, 0xeb, 0x0c, 0xe0, 0x04, 0xeb, 0x0c,
-    0xe0, 0x04, 0xef, 0x4f, 0xe0, 0x01, 0xeb, 0x11,
-    0xe0, 0x7f, 0xe1, 0x12, 0xe2, 0x12, 0xe1, 0x12,
-    0xc2, 0x00, 0xe2, 0x0a, 0xe1, 0x12, 0xe2, 0x12,
-    0x01, 0x00, 0x21, 0x20, 0x01, 0x20, 0x21, 0x20,
-    0x61, 0x00, 0xe1, 0x00, 0x62, 0x00, 0x02, 0x00,
-    0xc2, 0x00, 0xe2, 0x03, 0xe1, 0x12, 0xe2, 0x12,
-    0x21, 0x00, 0x61, 0x20, 0xe1, 0x00, 0x00, 0xc1,
-    0x00, 0xe2, 0x12, 0x21, 0x00, 0x61, 0x00, 0x81,
-    0x00, 0x01, 0x40, 0xc1, 0x00, 0xe2, 0x12, 0xe1,
-    0x12, 0xe2, 0x12, 0xe1, 0x12, 0xe2, 0x12, 0xe1,
-    0x12, 0xe2, 0x12, 0xe1, 0x12, 0xe2, 0x12, 0xe1,
-    0x12, 0xe2, 0x12, 0xe1, 0x12, 0xe2, 0x14, 0x20,
+    0x12, 0x13, 0x12, 0x13, 0xeb, 0x16, 0xef, 0x24,
+    0x8c, 0x12, 0x13, 0xec, 0x17, 0x12, 0x13, 0x12,
+    0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0xec,
+    0x08, 0xef, 0x80, 0x78, 0xec, 0x7b, 0x12, 0x13,
+    0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13,
+    0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13,
+    0x12, 0x13, 0x12, 0x13, 0xec, 0x37, 0x12, 0x13,
+    0x12, 0x13, 0xec, 0x18, 0x12, 0x13, 0xec, 0x80,
+    0x7a, 0xef, 0x28, 0xec, 0x0d, 0x2f, 0xac, 0xef,
+    0x1f, 0x20, 0xef, 0x18, 0x00, 0xef, 0x61, 0xe1,
+    0x28, 0xe2, 0x28, 0x5f, 0x21, 0x22, 0xdf, 0x41,
+    0x02, 0x3f, 0x02, 0x3f, 0x82, 0x24, 0x41, 0x02,
+    0xff, 0x5a, 0x02, 0xaf, 0x7f, 0x46, 0x3f, 0x80,
+    0x76, 0x0b, 0x36, 0xe2, 0x1e, 0x00, 0x02, 0x80,
+    0x02, 0x20, 0xe5, 0x30, 0xc0, 0x04, 0x16, 0xe0,
+    0x06, 0x06, 0xe5, 0x0f, 0xe0, 0x01, 0xc5, 0x00,
+    0xc5, 0x00, 0xc5, 0x00, 0xc5, 0x00, 0xc5, 0x00,
+    0xc5, 0x00, 0xc5, 0x00, 0xc5, 0x00, 0xe6, 0x18,
+    0x36, 0x14, 0x15, 0x14, 0x15, 0x56, 0x14, 0x15,
+    0x16, 0x14, 0x15, 0xf6, 0x01, 0x11, 0x36, 0x11,
+    0x16, 0x14, 0x15, 0x36, 0x14, 0x15, 0x12, 0x13,
+    0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x96, 0x04,
+    0xf6, 0x02, 0x31, 0x76, 0x11, 0x16, 0x12, 0xf6,
+    0x05, 0x2f, 0x56, 0x12, 0x13, 0x12, 0x13, 0x12,
+    0x13, 0x12, 0x13, 0x11, 0xe0, 0x1a, 0xef, 0x12,
+    0x00, 0xef, 0x51, 0xe0, 0x04, 0xef, 0x80, 0x4e,
+    0xe0, 0x12, 0xef, 0x04, 0x60, 0x17, 0x56, 0x0f,
+    0x04, 0x05, 0x0a, 0x12, 0x13, 0x12, 0x13, 0x12,
+    0x13, 0x12, 0x13, 0x12, 0x13, 0x2f, 0x12, 0x13,
+    0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x11, 0x12,
+    0x33, 0x0f, 0xea, 0x01, 0x66, 0x27, 0x11, 0x84,
+    0x2f, 0x4a, 0x04, 0x05, 0x16, 0x2f, 0x00, 0xe5,
+    0x4e, 0x20, 0x26, 0x2e, 0x24, 0x05, 0x11, 0xe5,
+    0x52, 0x16, 0x44, 0x05, 0x80, 0xe5, 0x23, 0x00,
+    0xe5, 0x56, 0x00, 0x2f, 0x6b, 0xef, 0x02, 0xe5,
+    0x18, 0xef, 0x1c, 0xe0, 0x04, 0xe5, 0x08, 0xef,
+    0x17, 0x00, 0xeb, 0x02, 0xef, 0x16, 0xeb, 0x00,
+    0x0f, 0xeb, 0x07, 0xef, 0x18, 0xeb, 0x02, 0xef,
+    0x1f, 0xeb, 0x07, 0xef, 0x80, 0xb8, 0xe5, 0x99,
+    0x38, 0xef, 0x38, 0xe5, 0xc0, 0x11, 0x8d, 0x04,
+    0xe5, 0x83, 0xef, 0x40, 0xef, 0x2f, 0xe0, 0x01,
+    0xe5, 0x20, 0xa4, 0x36, 0xe5, 0x80, 0x84, 0x04,
+    0x56, 0xe5, 0x08, 0xe9, 0x02, 0x25, 0xe0, 0x0c,
+    0xff, 0x26, 0x05, 0x06, 0x48, 0x16, 0xe6, 0x02,
+    0x16, 0x04, 0xff, 0x14, 0x24, 0x26, 0xe5, 0x3e,
+    0xea, 0x02, 0x26, 0xb6, 0xe0, 0x00, 0xee, 0x0f,
+    0xe4, 0x01, 0x2e, 0xff, 0x06, 0x22, 0xff, 0x36,
+    0x04, 0xe2, 0x00, 0x9f, 0xff, 0x02, 0x04, 0x2e,
+    0x7f, 0x05, 0x7f, 0x22, 0xff, 0x0d, 0x61, 0x02,
+    0x81, 0x02, 0xff, 0x07, 0x41, 0x02, 0x3f, 0x80,
+    0x3f, 0x00, 0x02, 0x00, 0x02, 0x7f, 0xe0, 0x10,
+    0x44, 0x3f, 0x05, 0x24, 0x02, 0xc5, 0x06, 0x45,
+    0x06, 0x65, 0x06, 0xe5, 0x0f, 0x27, 0x26, 0x07,
+    0x6f, 0x06, 0x40, 0xab, 0x2f, 0x0d, 0x0f, 0xa0,
+    0xe5, 0x2c, 0x76, 0xe0, 0x00, 0x27, 0xe5, 0x2a,
+    0xe7, 0x08, 0x26, 0xe0, 0x00, 0x36, 0xe9, 0x02,
+    0xa0, 0xe6, 0x0a, 0xa5, 0x56, 0x05, 0x16, 0x25,
+    0x06, 0xe9, 0x02, 0xe5, 0x14, 0xe6, 0x00, 0x36,
+    0xe5, 0x0f, 0xe6, 0x03, 0x27, 0xe0, 0x03, 0x16,
+    0xe5, 0x15, 0x40, 0x46, 0x07, 0xe5, 0x27, 0x06,
+    0x27, 0x66, 0x27, 0x26, 0x47, 0xf6, 0x05, 0x00,
+    0x04, 0xe9, 0x02, 0x60, 0x36, 0x85, 0x06, 0x04,
+    0xe5, 0x01, 0xe9, 0x02, 0x85, 0x00, 0xe5, 0x21,
+    0xa6, 0x27, 0x26, 0x27, 0x26, 0xe0, 0x01, 0x45,
+    0x06, 0xe5, 0x00, 0x06, 0x07, 0x20, 0xe9, 0x02,
+    0x20, 0x76, 0xe5, 0x08, 0x04, 0xa5, 0x4f, 0x05,
+    0x07, 0x06, 0x07, 0xe5, 0x2a, 0x06, 0x05, 0x46,
+    0x25, 0x26, 0x85, 0x26, 0x05, 0x06, 0x05, 0xe0,
+    0x10, 0x25, 0x04, 0x36, 0xe5, 0x03, 0x07, 0x26,
+    0x27, 0x36, 0x05, 0x24, 0x07, 0x06, 0xe0, 0x02,
+    0xa5, 0x20, 0xa5, 0x20, 0xa5, 0xe0, 0x01, 0xc5,
+    0x00, 0xc5, 0x00, 0xe2, 0x23, 0x0e, 0x64, 0xe2,
+    0x01, 0x04, 0x2e, 0x60, 0xe2, 0x48, 0xe5, 0x1b,
+    0x27, 0x06, 0x27, 0x06, 0x27, 0x16, 0x07, 0x06,
+    0x20, 0xe9, 0x02, 0xa0, 0xe5, 0xab, 0x1c, 0xe0,
+    0x04, 0xe5, 0x0f, 0x60, 0xe5, 0x29, 0x60, 0xfc,
+    0x87, 0x78, 0xfd, 0x98, 0x78, 0xe5, 0x80, 0xe6,
+    0x20, 0xe5, 0x62, 0xe0, 0x1e, 0xc2, 0xe0, 0x04,
+    0x82, 0x80, 0x05, 0x06, 0xe5, 0x02, 0x0c, 0xe5,
+    0x05, 0x00, 0x85, 0x00, 0x05, 0x00, 0x25, 0x00,
+    0x25, 0x00, 0xe5, 0x64, 0xee, 0x09, 0xe0, 0x08,
+    0xe5, 0x80, 0xe3, 0x13, 0x12, 0xef, 0x08, 0xe5,
+    0x38, 0x20, 0xe5, 0x2e, 0xc0, 0x0f, 0xe0, 0x18,
+    0xe5, 0x04, 0x0d, 0x4f, 0xe6, 0x08, 0xd6, 0x12,
+    0x13, 0x16, 0xa0, 0xe6, 0x08, 0x16, 0x31, 0x30,
+    0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13,
+    0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13,
+    0x36, 0x12, 0x13, 0x76, 0x50, 0x56, 0x00, 0x76,
+    0x11, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x56,
+    0x0c, 0x11, 0x4c, 0x00, 0x16, 0x0d, 0x36, 0x60,
+    0x85, 0x00, 0xe5, 0x7f, 0x20, 0x1b, 0x00, 0x56,
+    0x0d, 0x56, 0x12, 0x13, 0x16, 0x0c, 0x16, 0x11,
+    0x36, 0xe9, 0x02, 0x36, 0x4c, 0x36, 0xe1, 0x12,
+    0x12, 0x16, 0x13, 0x0e, 0x10, 0x0e, 0xe2, 0x12,
+    0x12, 0x0c, 0x13, 0x0c, 0x12, 0x13, 0x16, 0x12,
+    0x13, 0x36, 0xe5, 0x02, 0x04, 0xe5, 0x25, 0x24,
+    0xe5, 0x17, 0x40, 0xa5, 0x20, 0xa5, 0x20, 0xa5,
+    0x20, 0x45, 0x40, 0x2d, 0x0c, 0x0e, 0x0f, 0x2d,
+    0x00, 0x0f, 0x6c, 0x2f, 0xe0, 0x02, 0x5b, 0x2f,
+    0x20, 0xe5, 0x04, 0x00, 0xe5, 0x12, 0x00, 0xe5,
+    0x0b, 0x00, 0x25, 0x00, 0xe5, 0x07, 0x20, 0xe5,
+    0x06, 0xe0, 0x1a, 0xe5, 0x73, 0x80, 0x56, 0x60,
+    0xeb, 0x25, 0x40, 0xef, 0x01, 0xea, 0x2d, 0x6b,
+    0xef, 0x09, 0x2b, 0x4f, 0x00, 0xef, 0x05, 0x40,
+    0x0f, 0xe0, 0x27, 0xef, 0x25, 0x06, 0xe0, 0x7a,
+    0xe5, 0x15, 0x40, 0xe5, 0x29, 0xe0, 0x07, 0x06,
+    0xeb, 0x13, 0x60, 0xe5, 0x18, 0x6b, 0xe0, 0x01,
+    0xe5, 0x0c, 0x0a, 0xe5, 0x00, 0x0a, 0x80, 0xe5,
+    0x1e, 0x86, 0x80, 0xe5, 0x16, 0x00, 0x16, 0xe5,
+    0x1c, 0x60, 0xe5, 0x00, 0x16, 0x8a, 0xe0, 0x22,
+    0xe1, 0x20, 0xe2, 0x20, 0xe5, 0x46, 0x20, 0xe9,
+    0x02, 0xa0, 0xe1, 0x1c, 0x60, 0xe2, 0x1c, 0x60,
+    0xe5, 0x20, 0xe0, 0x00, 0xe5, 0x2c, 0xe0, 0x03,
+    0x16, 0xe1, 0x03, 0x00, 0xe1, 0x07, 0x00, 0xc1,
+    0x00, 0x21, 0x00, 0xe2, 0x03, 0x00, 0xe2, 0x07,
+    0x00, 0xc2, 0x00, 0x22, 0xe0, 0x3b, 0xe5, 0x80,
+    0xaf, 0xe0, 0x01, 0xe5, 0x0e, 0xe0, 0x02, 0xe5,
+    0x00, 0xe0, 0x10, 0xa4, 0x00, 0xe4, 0x22, 0x00,
+    0xe4, 0x01, 0xe0, 0x3d, 0xa5, 0x20, 0x05, 0x00,
+    0xe5, 0x24, 0x00, 0x25, 0x40, 0x05, 0x20, 0xe5,
+    0x0f, 0x00, 0x16, 0xeb, 0x00, 0xe5, 0x0f, 0x2f,
+    0xcb, 0xe5, 0x17, 0xe0, 0x00, 0xeb, 0x01, 0xe0,
+    0x28, 0xe5, 0x0b, 0x00, 0x25, 0x80, 0x8b, 0xe5,
+    0x0e, 0xab, 0x40, 0x16, 0xe5, 0x12, 0x80, 0x16,
+    0xe0, 0x38, 0xe5, 0x30, 0x60, 0x2b, 0x25, 0xeb,
+    0x08, 0x20, 0xeb, 0x26, 0x05, 0x46, 0x00, 0x26,
+    0x80, 0x66, 0x65, 0x00, 0x45, 0x00, 0xe5, 0x15,
+    0x20, 0x46, 0x60, 0x06, 0xeb, 0x01, 0xc0, 0xf6,
+    0x01, 0xc0, 0xe5, 0x15, 0x2b, 0x16, 0xe5, 0x15,
+    0x4b, 0xe0, 0x18, 0xe5, 0x00, 0x0f, 0xe5, 0x14,
+    0x26, 0x60, 0x8b, 0xd6, 0xe0, 0x01, 0xe5, 0x2e,
+    0x40, 0xd6, 0xe5, 0x0e, 0x20, 0xeb, 0x00, 0xe5,
+    0x0b, 0x80, 0xeb, 0x00, 0xe5, 0x0a, 0xc0, 0x76,
+    0xe0, 0x04, 0xcb, 0xe0, 0x48, 0xe5, 0x41, 0xe0,
+    0x2f, 0xe1, 0x2b, 0xe0, 0x05, 0xe2, 0x2b, 0xc0,
+    0xab, 0xe5, 0x1c, 0x66, 0xe0, 0x00, 0xe9, 0x02,
+    0xe0, 0x80, 0x9e, 0xeb, 0x17, 0x00, 0xe5, 0x22,
+    0x00, 0x26, 0x11, 0x20, 0x25, 0xe0, 0x46, 0xe5,
+    0x15, 0xeb, 0x02, 0x05, 0xe0, 0x00, 0xe5, 0x0e,
+    0xe6, 0x03, 0x6b, 0x96, 0xe0, 0x0e, 0xe5, 0x0a,
+    0x66, 0x76, 0xe0, 0x1e, 0xe5, 0x0d, 0xcb, 0xe0,
+    0x0c, 0xe5, 0x0f, 0xe0, 0x01, 0x07, 0x06, 0x07,
+    0xe5, 0x2d, 0xe6, 0x07, 0xd6, 0x60, 0xeb, 0x0c,
+    0xe9, 0x02, 0x06, 0x25, 0x26, 0x05, 0xe0, 0x01,
+    0x46, 0x07, 0xe5, 0x25, 0x47, 0x66, 0x27, 0x26,
+    0x36, 0x1b, 0x76, 0x06, 0xe0, 0x02, 0x1b, 0x20,
+    0xe5, 0x11, 0xc0, 0xe9, 0x02, 0xa0, 0x46, 0xe5,
+    0x1c, 0x86, 0x07, 0xe6, 0x00, 0x00, 0xe9, 0x02,
+    0x76, 0x05, 0x27, 0x05, 0xe0, 0x00, 0xe5, 0x1b,
+    0x06, 0x36, 0x05, 0xe0, 0x01, 0x26, 0x07, 0xe5,
+    0x28, 0x47, 0xe6, 0x01, 0x27, 0x65, 0x76, 0x66,
+    0x16, 0x07, 0x06, 0xe9, 0x02, 0x05, 0x16, 0x05,
+    0x56, 0x00, 0xeb, 0x0c, 0xe0, 0x03, 0xe5, 0x0a,
+    0x00, 0xe5, 0x11, 0x47, 0x46, 0x27, 0x06, 0x07,
+    0x26, 0xb6, 0x06, 0xe0, 0x39, 0xc5, 0x00, 0x05,
+    0x00, 0x65, 0x00, 0xe5, 0x07, 0x00, 0xe5, 0x02,
+    0x16, 0xa0, 0xe5, 0x27, 0x06, 0x47, 0xe6, 0x00,
+    0x80, 0xe9, 0x02, 0xa0, 0x26, 0x27, 0x00, 0xe5,
+    0x00, 0x20, 0x25, 0x20, 0xe5, 0x0e, 0x00, 0xc5,
+    0x00, 0x25, 0x00, 0x85, 0x00, 0x26, 0x05, 0x27,
+    0x06, 0x67, 0x20, 0x27, 0x20, 0x47, 0x20, 0x05,
+    0xa0, 0x07, 0x80, 0x85, 0x27, 0x20, 0xc6, 0x40,
+    0x86, 0xe0, 0x80, 0x03, 0xe5, 0x2d, 0x47, 0xe6,
+    0x00, 0x27, 0x46, 0x07, 0x06, 0x65, 0x96, 0xe9,
+    0x02, 0x36, 0x00, 0x16, 0x06, 0x45, 0xe0, 0x16,
+    0xe5, 0x28, 0x47, 0xa6, 0x07, 0x06, 0x67, 0x26,
+    0x07, 0x26, 0x25, 0x16, 0x05, 0xe0, 0x00, 0xe9,
+    0x02, 0xe0, 0x80, 0x1e, 0xe5, 0x27, 0x47, 0x66,
+    0x20, 0x67, 0x26, 0x07, 0x26, 0xf6, 0x0f, 0x65,
+    0x26, 0xe0, 0x1a, 0xe5, 0x28, 0x47, 0xe6, 0x00,
+    0x27, 0x06, 0x07, 0x26, 0x56, 0x05, 0xe0, 0x03,
+    0xe9, 0x02, 0xa0, 0xf6, 0x05, 0xe0, 0x0b, 0xe5,
+    0x23, 0x06, 0x07, 0x06, 0x27, 0xa6, 0x07, 0x06,
+    0x05, 0x16, 0xa0, 0xe9, 0x02, 0xe0, 0x2e, 0xe5,
+    0x13, 0x20, 0x46, 0x27, 0x66, 0x07, 0x86, 0x60,
+    0xe9, 0x02, 0x2b, 0x56, 0x0f, 0xc5, 0xe0, 0x80,
+    0x31, 0xe5, 0x24, 0x47, 0xe6, 0x01, 0x07, 0x26,
+    0x16, 0xe0, 0x5c, 0xe1, 0x18, 0xe2, 0x18, 0xe9,
+    0x02, 0xeb, 0x01, 0xe0, 0x04, 0xe5, 0x00, 0x20,
+    0x05, 0x20, 0xe5, 0x00, 0x00, 0x25, 0x00, 0xe5,
+    0x10, 0xa7, 0x00, 0x27, 0x20, 0x26, 0x07, 0x06,
+    0x05, 0x07, 0x05, 0x07, 0x06, 0x56, 0xe0, 0x01,
+    0xe9, 0x02, 0xe0, 0x3e, 0xe5, 0x00, 0x20, 0xe5,
+    0x1f, 0x47, 0x66, 0x20, 0x26, 0x67, 0x06, 0x05,
+    0x16, 0x05, 0x07, 0xe0, 0x13, 0x05, 0xe6, 0x02,
+    0xe5, 0x20, 0xa6, 0x07, 0x05, 0x66, 0xf6, 0x00,
+    0x06, 0xe0, 0x00, 0x05, 0xa6, 0x27, 0x46, 0xe5,
+    0x26, 0xe6, 0x05, 0x07, 0x26, 0x56, 0x05, 0x96,
+    0xe0, 0x05, 0xe5, 0x41, 0xe0, 0x80, 0x7f, 0xe5,
+    0x01, 0x00, 0xe5, 0x1d, 0x07, 0xc6, 0x00, 0xa6,
+    0x07, 0x06, 0x05, 0x96, 0xe0, 0x02, 0xe9, 0x02,
+    0xeb, 0x0b, 0x40, 0x36, 0xe5, 0x16, 0x20, 0xe6,
+    0x0e, 0x00, 0x07, 0xc6, 0x07, 0x26, 0x07, 0x26,
+    0xe0, 0x41, 0xc5, 0x00, 0x25, 0x00, 0xe5, 0x1e,
+    0xa6, 0x40, 0x06, 0x00, 0x26, 0x00, 0xc6, 0x05,
+    0x06, 0xe0, 0x00, 0xe9, 0x02, 0xa0, 0xa5, 0x00,
+    0x25, 0x00, 0xe5, 0x18, 0x87, 0x00, 0x26, 0x00,
+    0x27, 0x06, 0x07, 0x06, 0x05, 0xc0, 0xe9, 0x02,
+    0xe0, 0x80, 0xae, 0xe5, 0x0b, 0x26, 0x27, 0x36,
+    0xe0, 0x80, 0x2f, 0x05, 0xe0, 0x07, 0xeb, 0x0d,
+    0xef, 0x00, 0x6d, 0xef, 0x09, 0xe0, 0x05, 0x16,
+    0xe5, 0x83, 0x12, 0xe0, 0x5e, 0xea, 0x67, 0x00,
+    0x96, 0xe0, 0x03, 0xe5, 0x80, 0x3c, 0xe0, 0x89,
+    0xc4, 0xe5, 0x59, 0x36, 0xe0, 0x05, 0xe5, 0x83,
+    0xa7, 0x00, 0xfb, 0x01, 0xe0, 0x8f, 0x3f, 0xe5,
+    0x81, 0xbf, 0xe0, 0xa1, 0x31, 0xe5, 0x81, 0xb1,
+    0xc0, 0xe5, 0x17, 0x00, 0xe9, 0x02, 0x60, 0x36,
+    0xe5, 0x47, 0x00, 0xe9, 0x02, 0xa0, 0xe5, 0x16,
+    0x20, 0x86, 0x16, 0xe0, 0x02, 0xe5, 0x28, 0xc6,
+    0x96, 0x6f, 0x64, 0x16, 0x0f, 0xe0, 0x02, 0xe9,
+    0x02, 0x00, 0xcb, 0x00, 0xe5, 0x0d, 0x80, 0xe5,
+    0x0b, 0xe0, 0x82, 0x28, 0xe1, 0x18, 0xe2, 0x18,
+    0xeb, 0x0f, 0x76, 0xe0, 0x5d, 0xe5, 0x43, 0x60,
+    0x06, 0x05, 0xe7, 0x2f, 0xc0, 0x66, 0xe4, 0x05,
+    0xe0, 0x38, 0x24, 0x16, 0x04, 0x06, 0xe0, 0x03,
+    0x27, 0xe0, 0x06, 0xe5, 0x97, 0x70, 0xe0, 0x00,
+    0xe5, 0x84, 0x4e, 0xe0, 0x22, 0xe5, 0x01, 0xe0,
+    0xa2, 0x5f, 0x64, 0x00, 0xc4, 0x00, 0x24, 0x00,
+    0xe5, 0x80, 0x9b, 0xe0, 0x25, 0x45, 0xe0, 0x09,
+    0x65, 0xe0, 0x00, 0xe5, 0x81, 0x04, 0xe0, 0x88,
+    0x7c, 0xe5, 0x63, 0x80, 0xe5, 0x05, 0x40, 0xe5,
+    0x01, 0xc0, 0xe5, 0x02, 0x20, 0x0f, 0x26, 0x16,
+    0x7b, 0xe0, 0x91, 0xd4, 0xe6, 0x26, 0x20, 0xe6,
+    0x0f, 0xe0, 0x01, 0xef, 0x6c, 0xe0, 0x34, 0xef,
+    0x80, 0x6e, 0xe0, 0x02, 0xef, 0x1f, 0x20, 0xef,
+    0x34, 0x27, 0x46, 0x4f, 0xa7, 0xfb, 0x00, 0xe6,
+    0x00, 0x2f, 0xc6, 0xef, 0x16, 0x66, 0xef, 0x35,
+    0xe0, 0x0d, 0xef, 0x3a, 0x46, 0x0f, 0xe0, 0x80,
+    0x12, 0xeb, 0x0c, 0xe0, 0x04, 0xef, 0x4f, 0xe0,
+    0x01, 0xeb, 0x11, 0xe0, 0x7f, 0xe1, 0x12, 0xe2,
+    0x12, 0xe1, 0x12, 0xc2, 0x00, 0xe2, 0x0a, 0xe1,
+    0x12, 0xe2, 0x12, 0x01, 0x00, 0x21, 0x20, 0x01,
+    0x20, 0x21, 0x20, 0x61, 0x00, 0xe1, 0x00, 0x62,
+    0x00, 0x02, 0x00, 0xc2, 0x00, 0xe2, 0x03, 0xe1,
+    0x12, 0xe2, 0x12, 0x21, 0x00, 0x61, 0x20, 0xe1,
+    0x00, 0x00, 0xc1, 0x00, 0xe2, 0x12, 0x21, 0x00,
+    0x61, 0x00, 0x81, 0x00, 0x01, 0x40, 0xc1, 0x00,
+    0xe2, 0x12, 0xe1, 0x12, 0xe2, 0x12, 0xe1, 0x12,
+    0xe2, 0x12, 0xe1, 0x12, 0xe2, 0x12, 0xe1, 0x12,
+    0xe2, 0x12, 0xe1, 0x12, 0xe2, 0x12, 0xe1, 0x12,
+    0xe2, 0x14, 0x20, 0xe1, 0x11, 0x0c, 0xe2, 0x11,
+    0x0c, 0xa2, 0xe1, 0x11, 0x0c, 0xe2, 0x11, 0x0c,
+    0xa2, 0xe1, 0x11, 0x0c, 0xe2, 0x11, 0x0c, 0xa2,
     0xe1, 0x11, 0x0c, 0xe2, 0x11, 0x0c, 0xa2, 0xe1,
-    0x11, 0x0c, 0xe2, 0x11, 0x0c, 0xa2, 0xe1, 0x11,
-    0x0c, 0xe2, 0x11, 0x0c, 0xa2, 0xe1, 0x11, 0x0c,
-    0xe2, 0x11, 0x0c, 0xa2, 0xe1, 0x11, 0x0c, 0xe2,
-    0x11, 0x0c, 0xa2, 0x3f, 0x20, 0xe9, 0x2a, 0xef,
-    0x81, 0x78, 0xe6, 0x2f, 0x6f, 0xe6, 0x2a, 0xef,
-    0x00, 0x06, 0xef, 0x06, 0x06, 0x2f, 0x96, 0xe0,
-    0x07, 0x86, 0x00, 0xe6, 0x07, 0xe0, 0x83, 0xc8,
-    0xe2, 0x02, 0x05, 0xe2, 0x0c, 0xa0, 0xa2, 0xe0,
-    0x80, 0x4d, 0xc6, 0x00, 0xe6, 0x09, 0x20, 0xc6,
-    0x00, 0x26, 0x00, 0x86, 0x80, 0xe4, 0x36, 0xe0,
-    0x19, 0x06, 0xe0, 0x68, 0xe5, 0x25, 0x40, 0xc6,
-    0xc4, 0x20, 0xe9, 0x02, 0x60, 0x05, 0x0f, 0xe0,
-    0x80, 0xb8, 0xe5, 0x16, 0x06, 0xe0, 0x09, 0xe5,
-    0x24, 0x66, 0xe9, 0x02, 0x80, 0x0d, 0xe0, 0x81,
-    0x48, 0xe5, 0x13, 0x04, 0x66, 0xe9, 0x02, 0xe0,
-    0x82, 0x5e, 0xc5, 0x00, 0x65, 0x00, 0x25, 0x00,
-    0xe5, 0x07, 0x00, 0xe5, 0x80, 0x3d, 0x20, 0xeb,
-    0x01, 0xc6, 0xe0, 0x21, 0xe1, 0x1a, 0xe2, 0x1a,
-    0xc6, 0x04, 0x60, 0xe9, 0x02, 0x60, 0x36, 0xe0,
-    0x82, 0x89, 0xeb, 0x33, 0x0f, 0x4b, 0x0d, 0x6b,
-    0xe0, 0x44, 0xeb, 0x25, 0x0f, 0xeb, 0x07, 0xe0,
-    0x80, 0x3a, 0x65, 0x00, 0xe5, 0x13, 0x00, 0x25,
-    0x00, 0x05, 0x20, 0x05, 0x00, 0xe5, 0x02, 0x00,
-    0x65, 0x00, 0x05, 0x00, 0x05, 0xa0, 0x05, 0x60,
-    0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x45, 0x00,
-    0x25, 0x00, 0x05, 0x20, 0x05, 0x00, 0x05, 0x00,
-    0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x25, 0x00,
-    0x05, 0x20, 0x65, 0x00, 0xc5, 0x00, 0x65, 0x00,
-    0x65, 0x00, 0x05, 0x00, 0xe5, 0x02, 0x00, 0xe5,
-    0x09, 0x80, 0x45, 0x00, 0x85, 0x00, 0xe5, 0x09,
-    0xe0, 0x2c, 0x2c, 0xe0, 0x80, 0x86, 0xef, 0x24,
-    0x60, 0xef, 0x5c, 0xe0, 0x04, 0xef, 0x07, 0x20,
-    0xef, 0x07, 0x00, 0xef, 0x07, 0x00, 0xef, 0x1d,
-    0xe0, 0x02, 0xeb, 0x05, 0xef, 0x80, 0x19, 0xe0,
-    0x30, 0xef, 0x15, 0xe0, 0x05, 0xef, 0x24, 0x60,
-    0xef, 0x01, 0xc0, 0x2f, 0xe0, 0x06, 0xaf, 0xe0,
-    0x80, 0x12, 0xef, 0x80, 0x73, 0x8e, 0xef, 0x82,
-    0x50, 0x60, 0xef, 0x09, 0x40, 0xef, 0x05, 0x40,
-    0xef, 0x6f, 0x60, 0xef, 0x57, 0xa0, 0xef, 0x04,
-    0x60, 0x0f, 0xe0, 0x07, 0xef, 0x04, 0x60, 0xef,
-    0x30, 0xe0, 0x00, 0xef, 0x02, 0xa0, 0xef, 0x20,
-    0xe0, 0x00, 0xef, 0x16, 0x20, 0x2f, 0xe0, 0x46,
-    0xef, 0x80, 0xcc, 0xe0, 0x04, 0xef, 0x06, 0x20,
-    0xef, 0x05, 0x40, 0xef, 0x01, 0xc0, 0xef, 0x26,
-    0x00, 0xcf, 0xe0, 0x00, 0xef, 0x06, 0x60, 0xef,
-    0x01, 0xc0, 0xef, 0x01, 0xc0, 0xef, 0x80, 0x0b,
-    0x00, 0xef, 0x2f, 0xe0, 0x1d, 0xe9, 0x02, 0xe0,
-    0x83, 0x7e, 0xe5, 0xc0, 0x66, 0x58, 0xe0, 0x18,
-    0xe5, 0x8f, 0xb2, 0xa0, 0xe5, 0x80, 0x56, 0x20,
-    0xe5, 0x95, 0xfa, 0xe0, 0x06, 0xe5, 0x9c, 0xa9,
-    0xe0, 0x8b, 0x97, 0xe5, 0x81, 0x96, 0xe0, 0x85,
-    0x5a, 0xe5, 0x92, 0xc3, 0x80, 0xe5, 0x8f, 0xd8,
-    0xe0, 0xca, 0x9b, 0xc9, 0x1b, 0xe0, 0x16, 0xfb,
-    0x58, 0xe0, 0x78, 0xe6, 0x80, 0x68, 0xe0, 0xc0,
-    0xbd, 0x88, 0xfd, 0xc0, 0xbf, 0x76, 0x20, 0xfd,
-    0xc0, 0xbf, 0x76, 0x20,
+    0x11, 0x0c, 0xe2, 0x11, 0x0c, 0xa2, 0x3f, 0x20,
+    0xe9, 0x2a, 0xef, 0x81, 0x78, 0xe6, 0x2f, 0x6f,
+    0xe6, 0x2a, 0xef, 0x00, 0x06, 0xef, 0x06, 0x06,
+    0x2f, 0x96, 0xe0, 0x07, 0x86, 0x00, 0xe6, 0x07,
+    0xe0, 0x83, 0xc8, 0xe2, 0x02, 0x05, 0xe2, 0x0c,
+    0xe0, 0x80, 0x59, 0xc6, 0x00, 0xe6, 0x09, 0x20,
+    0xc6, 0x00, 0x26, 0x00, 0x86, 0xe0, 0x80, 0x4d,
+    0xe5, 0x25, 0x40, 0xc6, 0xc4, 0x20, 0xe9, 0x02,
+    0x60, 0x05, 0x0f, 0xe0, 0x80, 0xb8, 0xe5, 0x16,
+    0x06, 0xe0, 0x09, 0xe5, 0x24, 0x66, 0xe9, 0x02,
+    0x80, 0x0d, 0xe0, 0x84, 0x58, 0xc5, 0x00, 0x65,
+    0x00, 0x25, 0x00, 0xe5, 0x07, 0x00, 0xe5, 0x80,
+    0x3d, 0x20, 0xeb, 0x01, 0xc6, 0xe0, 0x21, 0xe1,
+    0x1a, 0xe2, 0x1a, 0xc6, 0x04, 0x60, 0xe9, 0x02,
+    0x60, 0x36, 0xe0, 0x82, 0x89, 0xeb, 0x33, 0x0f,
+    0x4b, 0x0d, 0x6b, 0xe0, 0x44, 0xeb, 0x25, 0x0f,
+    0xeb, 0x07, 0xe0, 0x80, 0x3a, 0x65, 0x00, 0xe5,
+    0x13, 0x00, 0x25, 0x00, 0x05, 0x20, 0x05, 0x00,
+    0xe5, 0x02, 0x00, 0x65, 0x00, 0x05, 0x00, 0x05,
+    0xa0, 0x05, 0x60, 0x05, 0x00, 0x05, 0x00, 0x05,
+    0x00, 0x45, 0x00, 0x25, 0x00, 0x05, 0x20, 0x05,
+    0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05,
+    0x00, 0x25, 0x00, 0x05, 0x20, 0x65, 0x00, 0xc5,
+    0x00, 0x65, 0x00, 0x65, 0x00, 0x05, 0x00, 0xe5,
+    0x02, 0x00, 0xe5, 0x09, 0x80, 0x45, 0x00, 0x85,
+    0x00, 0xe5, 0x09, 0xe0, 0x2c, 0x2c, 0xe0, 0x80,
+    0x86, 0xef, 0x24, 0x60, 0xef, 0x5c, 0xe0, 0x04,
+    0xef, 0x07, 0x20, 0xef, 0x07, 0x00, 0xef, 0x07,
+    0x00, 0xef, 0x1d, 0xe0, 0x02, 0xeb, 0x05, 0xef,
+    0x80, 0x19, 0xe0, 0x30, 0xef, 0x15, 0xe0, 0x05,
+    0xef, 0x24, 0x60, 0xef, 0x01, 0xc0, 0x2f, 0xe0,
+    0x06, 0xaf, 0xe0, 0x80, 0x12, 0xef, 0x80, 0x73,
+    0x8e, 0xef, 0x82, 0x50, 0x80, 0xef, 0x08, 0x40,
+    0xef, 0x05, 0x40, 0xef, 0x6c, 0xe0, 0x04, 0xef,
+    0x51, 0xc0, 0xef, 0x04, 0x60, 0x0f, 0xe0, 0x07,
+    0xef, 0x04, 0x60, 0xef, 0x30, 0xe0, 0x00, 0xef,
+    0x02, 0xa0, 0xef, 0x20, 0xe0, 0x00, 0xef, 0x16,
+    0x20, 0x2f, 0xe0, 0x46, 0xef, 0x80, 0xcc, 0xe0,
+    0x04, 0xef, 0x06, 0x20, 0x8f, 0x40, 0x8f, 0x40,
+    0xcf, 0xe0, 0x01, 0xef, 0x15, 0x40, 0xef, 0x03,
+    0x80, 0xaf, 0xe0, 0x02, 0xef, 0x02, 0xa0, 0xef,
+    0x00, 0xe0, 0x00, 0xcf, 0xe0, 0x01, 0xef, 0x80,
+    0x0b, 0x00, 0xef, 0x2f, 0xe0, 0x1d, 0xe9, 0x02,
+    0xe0, 0x83, 0x7e, 0xe5, 0xc0, 0x66, 0x58, 0xe0,
+    0x18, 0xe5, 0x8f, 0xb1, 0xc0, 0xe5, 0x80, 0x56,
+    0x20, 0xe5, 0x95, 0xfa, 0xe0, 0x06, 0xe5, 0x9c,
+    0xa9, 0xe0, 0x8b, 0x97, 0xe5, 0x81, 0x96, 0xe0,
+    0x85, 0x5a, 0xe5, 0x92, 0xc3, 0xe0, 0xca, 0xac,
+    0x2e, 0x1b, 0xe0, 0x16, 0xfb, 0x58, 0xe0, 0x78,
+    0xe6, 0x80, 0x68, 0xe0, 0xc0, 0xbd, 0x88, 0xfd,
+    0xc0, 0xbf, 0x76, 0x20, 0xfd, 0xc0, 0xbf, 0x76,
+    0x20,
 };
 
 typedef enum {
@@ -2896,7 +2868,6 @@
     UNICODE_SCRIPT_Kaithi,
     UNICODE_SCRIPT_Kannada,
     UNICODE_SCRIPT_Katakana,
-    UNICODE_SCRIPT_Kawi,
     UNICODE_SCRIPT_Kayah_Li,
     UNICODE_SCRIPT_Kharoshthi,
     UNICODE_SCRIPT_Khmer,
@@ -2931,7 +2902,6 @@
     UNICODE_SCRIPT_Multani,
     UNICODE_SCRIPT_Myanmar,
     UNICODE_SCRIPT_Nabataean,
-    UNICODE_SCRIPT_Nag_Mundari,
     UNICODE_SCRIPT_Nandinagari,
     UNICODE_SCRIPT_New_Tai_Lue,
     UNICODE_SCRIPT_Newa,
@@ -3063,7 +3033,6 @@
     "Kaithi,Kthi"                 "\0"
     "Kannada,Knda"                "\0"
     "Katakana,Kana"               "\0"
-    "Kawi,Kawi"                   "\0"
     "Kayah_Li,Kali"               "\0"
     "Kharoshthi,Khar"             "\0"
     "Khmer,Khmr"                  "\0"
@@ -3098,7 +3067,6 @@
     "Multani,Mult"                "\0"
     "Myanmar,Mymr"                "\0"
     "Nabataean,Nbat"              "\0"
-    "Nag_Mundari,Nagm"            "\0"
     "Nandinagari,Nand"            "\0"
     "New_Tai_Lue,Talu"            "\0"
     "Newa,Newa"                   "\0"
@@ -3166,12 +3134,12 @@
     "Zanabazar_Square,Zanb"       "\0"
 ;
 
-static const uint8_t unicode_script_table[2720] = {
-    0xc0, 0x19, 0x99, 0x47, 0x85, 0x19, 0x99, 0x47,
-    0xae, 0x19, 0x80, 0x47, 0x8e, 0x19, 0x80, 0x47,
-    0x84, 0x19, 0x96, 0x47, 0x80, 0x19, 0x9e, 0x47,
-    0x80, 0x19, 0xe1, 0x60, 0x47, 0xa6, 0x19, 0x84,
-    0x47, 0x84, 0x19, 0x81, 0x0d, 0x93, 0x19, 0xe0,
+static const uint8_t unicode_script_table[2690] = {
+    0xc0, 0x19, 0x99, 0x46, 0x85, 0x19, 0x99, 0x46,
+    0xae, 0x19, 0x80, 0x46, 0x8e, 0x19, 0x80, 0x46,
+    0x84, 0x19, 0x96, 0x46, 0x80, 0x19, 0x9e, 0x46,
+    0x80, 0x19, 0xe1, 0x60, 0x46, 0xa6, 0x19, 0x84,
+    0x46, 0x84, 0x19, 0x81, 0x0d, 0x93, 0x19, 0xe0,
     0x0f, 0x38, 0x83, 0x2c, 0x80, 0x19, 0x82, 0x2c,
     0x01, 0x83, 0x2c, 0x80, 0x19, 0x80, 0x2c, 0x03,
     0x80, 0x2c, 0x80, 0x19, 0x80, 0x2c, 0x80, 0x19,
@@ -3184,11 +3152,11 @@
     0x80, 0x19, 0x8d, 0x04, 0x80, 0x19, 0x82, 0x04,
     0x80, 0x19, 0x9f, 0x04, 0x80, 0x19, 0x89, 0x04,
     0x8a, 0x38, 0x99, 0x04, 0x80, 0x38, 0xe0, 0x0b,
-    0x04, 0x80, 0x19, 0xa1, 0x04, 0x8d, 0x8b, 0x00,
-    0xbb, 0x8b, 0x01, 0x82, 0x8b, 0xaf, 0x04, 0xb1,
-    0x95, 0x0d, 0xba, 0x66, 0x01, 0x82, 0x66, 0xad,
-    0x7f, 0x01, 0x8e, 0x7f, 0x00, 0x9b, 0x52, 0x01,
-    0x80, 0x52, 0x00, 0x8a, 0x8b, 0x04, 0x9e, 0x04,
+    0x04, 0x80, 0x19, 0xa1, 0x04, 0x8d, 0x89, 0x00,
+    0xbb, 0x89, 0x01, 0x82, 0x89, 0xaf, 0x04, 0xb1,
+    0x93, 0x0d, 0xba, 0x64, 0x01, 0x82, 0x64, 0xad,
+    0x7d, 0x01, 0x8e, 0x7d, 0x00, 0x9b, 0x51, 0x01,
+    0x80, 0x51, 0x00, 0x8a, 0x89, 0x04, 0x9e, 0x04,
     0x00, 0x81, 0x04, 0x05, 0xc9, 0x04, 0x80, 0x19,
     0x9c, 0x04, 0xd0, 0x20, 0x83, 0x38, 0x8e, 0x20,
     0x81, 0x19, 0x99, 0x20, 0x83, 0x0b, 0x00, 0x87,
@@ -3208,43 +3176,43 @@
     0x84, 0x2d, 0x01, 0x89, 0x2d, 0x00, 0x82, 0x2d,
     0x00, 0x82, 0x2d, 0x01, 0x80, 0x2d, 0x0e, 0x83,
     0x2d, 0x01, 0x8b, 0x2d, 0x06, 0x86, 0x2d, 0x00,
-    0x82, 0x74, 0x00, 0x87, 0x74, 0x01, 0x81, 0x74,
-    0x01, 0x95, 0x74, 0x00, 0x86, 0x74, 0x00, 0x81,
-    0x74, 0x00, 0x84, 0x74, 0x01, 0x88, 0x74, 0x01,
-    0x81, 0x74, 0x01, 0x82, 0x74, 0x06, 0x82, 0x74,
-    0x03, 0x81, 0x74, 0x00, 0x84, 0x74, 0x01, 0x91,
-    0x74, 0x09, 0x81, 0x92, 0x00, 0x85, 0x92, 0x02,
-    0x82, 0x92, 0x00, 0x83, 0x92, 0x02, 0x81, 0x92,
-    0x00, 0x80, 0x92, 0x00, 0x81, 0x92, 0x02, 0x81,
-    0x92, 0x02, 0x82, 0x92, 0x02, 0x8b, 0x92, 0x03,
-    0x84, 0x92, 0x02, 0x82, 0x92, 0x00, 0x83, 0x92,
-    0x01, 0x80, 0x92, 0x05, 0x80, 0x92, 0x0d, 0x94,
-    0x92, 0x04, 0x8c, 0x94, 0x00, 0x82, 0x94, 0x00,
-    0x96, 0x94, 0x00, 0x8f, 0x94, 0x01, 0x88, 0x94,
-    0x00, 0x82, 0x94, 0x00, 0x83, 0x94, 0x06, 0x81,
-    0x94, 0x00, 0x82, 0x94, 0x01, 0x80, 0x94, 0x01,
-    0x83, 0x94, 0x01, 0x89, 0x94, 0x06, 0x88, 0x94,
+    0x82, 0x72, 0x00, 0x87, 0x72, 0x01, 0x81, 0x72,
+    0x01, 0x95, 0x72, 0x00, 0x86, 0x72, 0x00, 0x81,
+    0x72, 0x00, 0x84, 0x72, 0x01, 0x88, 0x72, 0x01,
+    0x81, 0x72, 0x01, 0x82, 0x72, 0x06, 0x82, 0x72,
+    0x03, 0x81, 0x72, 0x00, 0x84, 0x72, 0x01, 0x91,
+    0x72, 0x09, 0x81, 0x90, 0x00, 0x85, 0x90, 0x02,
+    0x82, 0x90, 0x00, 0x83, 0x90, 0x02, 0x81, 0x90,
+    0x00, 0x80, 0x90, 0x00, 0x81, 0x90, 0x02, 0x81,
+    0x90, 0x02, 0x82, 0x90, 0x02, 0x8b, 0x90, 0x03,
+    0x84, 0x90, 0x02, 0x82, 0x90, 0x00, 0x83, 0x90,
+    0x01, 0x80, 0x90, 0x05, 0x80, 0x90, 0x0d, 0x94,
+    0x90, 0x04, 0x8c, 0x92, 0x00, 0x82, 0x92, 0x00,
+    0x96, 0x92, 0x00, 0x8f, 0x92, 0x01, 0x88, 0x92,
+    0x00, 0x82, 0x92, 0x00, 0x83, 0x92, 0x06, 0x81,
+    0x92, 0x00, 0x82, 0x92, 0x01, 0x80, 0x92, 0x01,
+    0x83, 0x92, 0x01, 0x89, 0x92, 0x06, 0x88, 0x92,
     0x8c, 0x3d, 0x00, 0x82, 0x3d, 0x00, 0x96, 0x3d,
     0x00, 0x89, 0x3d, 0x00, 0x84, 0x3d, 0x01, 0x88,
     0x3d, 0x00, 0x82, 0x3d, 0x00, 0x83, 0x3d, 0x06,
     0x81, 0x3d, 0x05, 0x81, 0x3d, 0x00, 0x83, 0x3d,
-    0x01, 0x89, 0x3d, 0x00, 0x82, 0x3d, 0x0b, 0x8c,
-    0x51, 0x00, 0x82, 0x51, 0x00, 0xb2, 0x51, 0x00,
-    0x82, 0x51, 0x00, 0x85, 0x51, 0x03, 0x8f, 0x51,
-    0x01, 0x99, 0x51, 0x00, 0x82, 0x85, 0x00, 0x91,
-    0x85, 0x02, 0x97, 0x85, 0x00, 0x88, 0x85, 0x00,
-    0x80, 0x85, 0x01, 0x86, 0x85, 0x02, 0x80, 0x85,
-    0x03, 0x85, 0x85, 0x00, 0x80, 0x85, 0x00, 0x87,
-    0x85, 0x05, 0x89, 0x85, 0x01, 0x82, 0x85, 0x0b,
-    0xb9, 0x96, 0x03, 0x80, 0x19, 0x9b, 0x96, 0x24,
-    0x81, 0x46, 0x00, 0x80, 0x46, 0x00, 0x84, 0x46,
-    0x00, 0x97, 0x46, 0x00, 0x80, 0x46, 0x00, 0x96,
-    0x46, 0x01, 0x84, 0x46, 0x00, 0x80, 0x46, 0x00,
-    0x86, 0x46, 0x00, 0x89, 0x46, 0x01, 0x83, 0x46,
-    0x1f, 0xc7, 0x97, 0x00, 0xa3, 0x97, 0x03, 0xa6,
-    0x97, 0x00, 0xa3, 0x97, 0x00, 0x8e, 0x97, 0x00,
-    0x86, 0x97, 0x83, 0x19, 0x81, 0x97, 0x24, 0xe0,
-    0x3f, 0x60, 0xa5, 0x28, 0x00, 0x80, 0x28, 0x04,
+    0x01, 0x89, 0x3d, 0x00, 0x81, 0x3d, 0x0c, 0x8c,
+    0x50, 0x00, 0x82, 0x50, 0x00, 0xb2, 0x50, 0x00,
+    0x82, 0x50, 0x00, 0x85, 0x50, 0x03, 0x8f, 0x50,
+    0x01, 0x99, 0x50, 0x00, 0x82, 0x83, 0x00, 0x91,
+    0x83, 0x02, 0x97, 0x83, 0x00, 0x88, 0x83, 0x00,
+    0x80, 0x83, 0x01, 0x86, 0x83, 0x02, 0x80, 0x83,
+    0x03, 0x85, 0x83, 0x00, 0x80, 0x83, 0x00, 0x87,
+    0x83, 0x05, 0x89, 0x83, 0x01, 0x82, 0x83, 0x0b,
+    0xb9, 0x94, 0x03, 0x80, 0x19, 0x9b, 0x94, 0x24,
+    0x81, 0x45, 0x00, 0x80, 0x45, 0x00, 0x84, 0x45,
+    0x00, 0x97, 0x45, 0x00, 0x80, 0x45, 0x00, 0x96,
+    0x45, 0x01, 0x84, 0x45, 0x00, 0x80, 0x45, 0x00,
+    0x85, 0x45, 0x01, 0x89, 0x45, 0x01, 0x83, 0x45,
+    0x1f, 0xc7, 0x95, 0x00, 0xa3, 0x95, 0x03, 0xa6,
+    0x95, 0x00, 0xa3, 0x95, 0x00, 0x8e, 0x95, 0x00,
+    0x86, 0x95, 0x83, 0x19, 0x81, 0x95, 0x24, 0xe0,
+    0x3f, 0x5f, 0xa5, 0x28, 0x00, 0x80, 0x28, 0x04,
     0x80, 0x28, 0x01, 0xaa, 0x28, 0x80, 0x19, 0x83,
     0x28, 0xe0, 0x9f, 0x31, 0xc8, 0x27, 0x00, 0x83,
     0x27, 0x01, 0x86, 0x27, 0x00, 0x80, 0x27, 0x00,
@@ -3254,32 +3222,32 @@
     0x8e, 0x27, 0x00, 0xb8, 0x27, 0x00, 0x83, 0x27,
     0x01, 0xc2, 0x27, 0x01, 0x9f, 0x27, 0x02, 0x99,
     0x27, 0x05, 0xd5, 0x17, 0x01, 0x85, 0x17, 0x01,
-    0xe2, 0x1f, 0x12, 0x9c, 0x69, 0x02, 0xca, 0x7e,
-    0x82, 0x19, 0x8a, 0x7e, 0x06, 0x95, 0x8c, 0x08,
-    0x80, 0x8c, 0x94, 0x33, 0x81, 0x19, 0x08, 0x93,
-    0x11, 0x0b, 0x8c, 0x8d, 0x00, 0x82, 0x8d, 0x00,
-    0x81, 0x8d, 0x0b, 0xdd, 0x42, 0x01, 0x89, 0x42,
-    0x05, 0x89, 0x42, 0x05, 0x81, 0x5d, 0x81, 0x19,
-    0x80, 0x5d, 0x80, 0x19, 0x93, 0x5d, 0x05, 0xd8,
-    0x5d, 0x06, 0xaa, 0x5d, 0x04, 0xc5, 0x12, 0x09,
-    0x9e, 0x49, 0x00, 0x8b, 0x49, 0x03, 0x8b, 0x49,
-    0x03, 0x80, 0x49, 0x02, 0x8b, 0x49, 0x9d, 0x8e,
-    0x01, 0x84, 0x8e, 0x0a, 0xab, 0x64, 0x03, 0x99,
-    0x64, 0x05, 0x8a, 0x64, 0x02, 0x81, 0x64, 0x9f,
-    0x42, 0x9b, 0x10, 0x01, 0x81, 0x10, 0xbe, 0x8f,
-    0x00, 0x9c, 0x8f, 0x01, 0x8a, 0x8f, 0x05, 0x89,
-    0x8f, 0x05, 0x8d, 0x8f, 0x01, 0x9e, 0x38, 0x30,
-    0xcc, 0x07, 0x02, 0xae, 0x07, 0x00, 0xbf, 0x89,
-    0xb3, 0x0a, 0x07, 0x83, 0x0a, 0xb7, 0x48, 0x02,
-    0x8e, 0x48, 0x02, 0x82, 0x48, 0xaf, 0x6a, 0x88,
+    0xe2, 0x1f, 0x12, 0x9c, 0x67, 0x02, 0xca, 0x7c,
+    0x82, 0x19, 0x8a, 0x7c, 0x06, 0x95, 0x8a, 0x08,
+    0x80, 0x8a, 0x94, 0x33, 0x81, 0x19, 0x08, 0x93,
+    0x11, 0x0b, 0x8c, 0x8b, 0x00, 0x82, 0x8b, 0x00,
+    0x81, 0x8b, 0x0b, 0xdd, 0x41, 0x01, 0x89, 0x41,
+    0x05, 0x89, 0x41, 0x05, 0x81, 0x5c, 0x81, 0x19,
+    0x80, 0x5c, 0x80, 0x19, 0x93, 0x5c, 0x05, 0xd8,
+    0x5c, 0x06, 0xaa, 0x5c, 0x04, 0xc5, 0x12, 0x09,
+    0x9e, 0x48, 0x00, 0x8b, 0x48, 0x03, 0x8b, 0x48,
+    0x03, 0x80, 0x48, 0x02, 0x8b, 0x48, 0x9d, 0x8c,
+    0x01, 0x84, 0x8c, 0x0a, 0xab, 0x62, 0x03, 0x99,
+    0x62, 0x05, 0x8a, 0x62, 0x02, 0x81, 0x62, 0x9f,
+    0x41, 0x9b, 0x10, 0x01, 0x81, 0x10, 0xbe, 0x8d,
+    0x00, 0x9c, 0x8d, 0x01, 0x8a, 0x8d, 0x05, 0x89,
+    0x8d, 0x05, 0x8d, 0x8d, 0x01, 0x9e, 0x38, 0x30,
+    0xcc, 0x07, 0x02, 0xae, 0x07, 0x00, 0xbf, 0x87,
+    0xb3, 0x0a, 0x07, 0x83, 0x0a, 0xb7, 0x47, 0x02,
+    0x8e, 0x47, 0x02, 0x82, 0x47, 0xaf, 0x68, 0x88,
     0x1d, 0x06, 0xaa, 0x28, 0x01, 0x82, 0x28, 0x87,
-    0x89, 0x07, 0x82, 0x38, 0x80, 0x19, 0x8c, 0x38,
+    0x87, 0x07, 0x82, 0x38, 0x80, 0x19, 0x8c, 0x38,
     0x80, 0x19, 0x86, 0x38, 0x83, 0x19, 0x80, 0x38,
     0x85, 0x19, 0x80, 0x38, 0x82, 0x19, 0x81, 0x38,
-    0x80, 0x19, 0x04, 0xa5, 0x47, 0x84, 0x2c, 0x80,
-    0x1d, 0xb0, 0x47, 0x84, 0x2c, 0x83, 0x47, 0x84,
-    0x2c, 0x8c, 0x47, 0x80, 0x1d, 0xc5, 0x47, 0x80,
-    0x2c, 0xbf, 0x38, 0xe0, 0x9f, 0x47, 0x95, 0x2c,
+    0x80, 0x19, 0x04, 0xa5, 0x46, 0x84, 0x2c, 0x80,
+    0x1d, 0xb0, 0x46, 0x84, 0x2c, 0x83, 0x46, 0x84,
+    0x2c, 0x8c, 0x46, 0x80, 0x1d, 0xc5, 0x46, 0x80,
+    0x2c, 0xbf, 0x38, 0xe0, 0x9f, 0x46, 0x95, 0x2c,
     0x01, 0x85, 0x2c, 0x01, 0xa5, 0x2c, 0x01, 0x85,
     0x2c, 0x01, 0x87, 0x2c, 0x00, 0x80, 0x2c, 0x00,
     0x80, 0x2c, 0x00, 0x80, 0x2c, 0x00, 0x9e, 0x2c,
@@ -3287,18 +3255,18 @@
     0x2c, 0x01, 0x85, 0x2c, 0x00, 0x92, 0x2c, 0x01,
     0x82, 0x2c, 0x00, 0x88, 0x2c, 0x00, 0x8b, 0x19,
     0x81, 0x38, 0xd6, 0x19, 0x00, 0x8a, 0x19, 0x80,
-    0x47, 0x01, 0x8a, 0x19, 0x80, 0x47, 0x8e, 0x19,
-    0x00, 0x8c, 0x47, 0x02, 0xa0, 0x19, 0x0e, 0xa0,
+    0x46, 0x01, 0x8a, 0x19, 0x80, 0x46, 0x8e, 0x19,
+    0x00, 0x8c, 0x46, 0x02, 0xa0, 0x19, 0x0e, 0xa0,
     0x38, 0x0e, 0xa5, 0x19, 0x80, 0x2c, 0x82, 0x19,
-    0x81, 0x47, 0x85, 0x19, 0x80, 0x47, 0x9a, 0x19,
-    0x80, 0x47, 0x90, 0x19, 0xa8, 0x47, 0x82, 0x19,
+    0x81, 0x46, 0x85, 0x19, 0x80, 0x46, 0x9a, 0x19,
+    0x80, 0x46, 0x90, 0x19, 0xa8, 0x46, 0x82, 0x19,
     0x03, 0xe2, 0x36, 0x19, 0x18, 0x8a, 0x19, 0x14,
     0xe3, 0x3f, 0x19, 0xe0, 0x9f, 0x0f, 0xe2, 0x13,
     0x19, 0x01, 0x9f, 0x19, 0x00, 0xe0, 0x08, 0x19,
-    0xdf, 0x29, 0x9f, 0x47, 0xe0, 0x13, 0x1a, 0x04,
+    0xdf, 0x29, 0x9f, 0x46, 0xe0, 0x13, 0x1a, 0x04,
     0x86, 0x1a, 0xa5, 0x28, 0x00, 0x80, 0x28, 0x04,
-    0x80, 0x28, 0x01, 0xb7, 0x98, 0x06, 0x81, 0x98,
-    0x0d, 0x80, 0x98, 0x96, 0x27, 0x08, 0x86, 0x27,
+    0x80, 0x28, 0x01, 0xb7, 0x96, 0x06, 0x81, 0x96,
+    0x0d, 0x80, 0x96, 0x96, 0x27, 0x08, 0x86, 0x27,
     0x00, 0x86, 0x27, 0x00, 0x86, 0x27, 0x00, 0x86,
     0x27, 0x00, 0x86, 0x27, 0x00, 0x86, 0x27, 0x00,
     0x86, 0x27, 0x00, 0x86, 0x27, 0x00, 0x9f, 0x1d,
@@ -3314,27 +3282,27 @@
     0x9e, 0x31, 0x00, 0xbf, 0x19, 0x9e, 0x31, 0xd0,
     0x19, 0xae, 0x3e, 0x80, 0x19, 0xd7, 0x3e, 0xe0,
     0x47, 0x19, 0xf0, 0x09, 0x5f, 0x30, 0xbf, 0x19,
-    0xf0, 0x41, 0x9f, 0x30, 0xe4, 0x2c, 0xa2, 0x02,
-    0xb6, 0xa2, 0x08, 0xaf, 0x4c, 0xe0, 0xcb, 0x9d,
+    0xf0, 0x41, 0x9f, 0x30, 0xe4, 0x2c, 0xa0, 0x02,
+    0xb6, 0xa0, 0x08, 0xaf, 0x4b, 0xe0, 0xcb, 0x9b,
     0x13, 0xdf, 0x1d, 0xd7, 0x08, 0x07, 0xa1, 0x19,
-    0xe0, 0x05, 0x47, 0x82, 0x19, 0xbf, 0x47, 0x04,
-    0x81, 0x47, 0x00, 0x80, 0x47, 0x00, 0x84, 0x47,
-    0x17, 0x8d, 0x47, 0xac, 0x8a, 0x02, 0x89, 0x19,
-    0x05, 0xb7, 0x7a, 0x07, 0xc5, 0x80, 0x07, 0x8b,
-    0x80, 0x05, 0x9f, 0x20, 0xad, 0x40, 0x80, 0x19,
-    0x80, 0x40, 0xa3, 0x7d, 0x0a, 0x80, 0x7d, 0x9c,
+    0xe0, 0x05, 0x46, 0x82, 0x19, 0xbf, 0x46, 0x04,
+    0x81, 0x46, 0x00, 0x80, 0x46, 0x00, 0x84, 0x46,
+    0x17, 0x8d, 0x46, 0xac, 0x88, 0x02, 0x89, 0x19,
+    0x05, 0xb7, 0x78, 0x07, 0xc5, 0x7e, 0x07, 0x8b,
+    0x7e, 0x05, 0x9f, 0x20, 0xad, 0x3f, 0x80, 0x19,
+    0x80, 0x3f, 0xa3, 0x7b, 0x0a, 0x80, 0x7b, 0x9c,
     0x31, 0x02, 0xcd, 0x3b, 0x00, 0x80, 0x19, 0x89,
-    0x3b, 0x03, 0x81, 0x3b, 0x9e, 0x60, 0x00, 0xb6,
+    0x3b, 0x03, 0x81, 0x3b, 0x9e, 0x5f, 0x00, 0xb6,
     0x16, 0x08, 0x8d, 0x16, 0x01, 0x89, 0x16, 0x01,
-    0x83, 0x16, 0x9f, 0x60, 0xc2, 0x90, 0x17, 0x84,
-    0x90, 0x96, 0x57, 0x09, 0x85, 0x27, 0x01, 0x85,
+    0x83, 0x16, 0x9f, 0x5f, 0xc2, 0x8e, 0x17, 0x84,
+    0x8e, 0x96, 0x56, 0x09, 0x85, 0x27, 0x01, 0x85,
     0x27, 0x01, 0x85, 0x27, 0x08, 0x86, 0x27, 0x00,
-    0x86, 0x27, 0x00, 0xaa, 0x47, 0x80, 0x19, 0x88,
-    0x47, 0x80, 0x2c, 0x83, 0x47, 0x81, 0x19, 0x03,
-    0xcf, 0x17, 0xad, 0x57, 0x01, 0x89, 0x57, 0x05,
+    0x86, 0x27, 0x00, 0xaa, 0x46, 0x80, 0x19, 0x88,
+    0x46, 0x80, 0x2c, 0x83, 0x46, 0x81, 0x19, 0x03,
+    0xcf, 0x17, 0xad, 0x56, 0x01, 0x89, 0x56, 0x05,
     0xf0, 0x1b, 0x43, 0x31, 0x0b, 0x96, 0x31, 0x03,
     0xb0, 0x31, 0x70, 0x10, 0xa3, 0xe1, 0x0d, 0x30,
-    0x01, 0xe0, 0x09, 0x30, 0x25, 0x86, 0x47, 0x0b,
+    0x01, 0xe0, 0x09, 0x30, 0x25, 0x86, 0x46, 0x0b,
     0x84, 0x05, 0x04, 0x99, 0x35, 0x00, 0x84, 0x35,
     0x00, 0x80, 0x35, 0x00, 0x81, 0x35, 0x00, 0x81,
     0x35, 0x00, 0x89, 0x35, 0xe0, 0x12, 0x04, 0x0f,
@@ -3343,134 +3311,130 @@
     0x8f, 0x38, 0x89, 0x19, 0x05, 0x8d, 0x38, 0x81,
     0x1d, 0xa2, 0x19, 0x00, 0x92, 0x19, 0x00, 0x83,
     0x19, 0x03, 0x84, 0x04, 0x00, 0xe0, 0x26, 0x04,
-    0x01, 0x80, 0x19, 0x00, 0x9f, 0x19, 0x99, 0x47,
-    0x85, 0x19, 0x99, 0x47, 0x8a, 0x19, 0x89, 0x3e,
+    0x01, 0x80, 0x19, 0x00, 0x9f, 0x19, 0x99, 0x46,
+    0x85, 0x19, 0x99, 0x46, 0x8a, 0x19, 0x89, 0x3e,
     0x80, 0x19, 0xac, 0x3e, 0x81, 0x19, 0x9e, 0x31,
     0x02, 0x85, 0x31, 0x01, 0x85, 0x31, 0x01, 0x85,
     0x31, 0x01, 0x82, 0x31, 0x02, 0x86, 0x19, 0x00,
-    0x86, 0x19, 0x09, 0x84, 0x19, 0x01, 0x8b, 0x4b,
-    0x00, 0x99, 0x4b, 0x00, 0x92, 0x4b, 0x00, 0x81,
-    0x4b, 0x00, 0x8e, 0x4b, 0x01, 0x8d, 0x4b, 0x21,
-    0xe0, 0x1a, 0x4b, 0x04, 0x82, 0x19, 0x03, 0xac,
+    0x86, 0x19, 0x09, 0x84, 0x19, 0x01, 0x8b, 0x4a,
+    0x00, 0x99, 0x4a, 0x00, 0x92, 0x4a, 0x00, 0x81,
+    0x4a, 0x00, 0x8e, 0x4a, 0x01, 0x8d, 0x4a, 0x21,
+    0xe0, 0x1a, 0x4a, 0x04, 0x82, 0x19, 0x03, 0xac,
     0x19, 0x02, 0x88, 0x19, 0xce, 0x2c, 0x00, 0x8c,
     0x19, 0x02, 0x80, 0x2c, 0x2e, 0xac, 0x19, 0x80,
-    0x38, 0x60, 0x21, 0x9c, 0x4d, 0x02, 0xb0, 0x13,
-    0x0e, 0x80, 0x38, 0x9a, 0x19, 0x03, 0xa3, 0x6c,
-    0x08, 0x82, 0x6c, 0x9a, 0x2a, 0x04, 0xaa, 0x6e,
-    0x04, 0x9d, 0x9c, 0x00, 0x80, 0x9c, 0xa3, 0x6f,
-    0x03, 0x8d, 0x6f, 0x29, 0xcf, 0x1f, 0xaf, 0x82,
-    0x9d, 0x76, 0x01, 0x89, 0x76, 0x05, 0xa3, 0x75,
-    0x03, 0xa3, 0x75, 0x03, 0xa7, 0x25, 0x07, 0xb3,
-    0x14, 0x0a, 0x80, 0x14, 0x8a, 0x9e, 0x00, 0x8e,
-    0x9e, 0x00, 0x86, 0x9e, 0x00, 0x81, 0x9e, 0x00,
-    0x8a, 0x9e, 0x00, 0x8e, 0x9e, 0x00, 0x86, 0x9e,
-    0x00, 0x81, 0x9e, 0x42, 0xe0, 0xd6, 0x4a, 0x08,
-    0x95, 0x4a, 0x09, 0x87, 0x4a, 0x17, 0x85, 0x47,
-    0x00, 0xa9, 0x47, 0x00, 0x88, 0x47, 0x44, 0x85,
+    0x38, 0x60, 0x21, 0x9c, 0x4c, 0x02, 0xb0, 0x13,
+    0x0e, 0x80, 0x38, 0x9a, 0x19, 0x03, 0xa3, 0x6a,
+    0x08, 0x82, 0x6a, 0x9a, 0x2a, 0x04, 0xaa, 0x6c,
+    0x04, 0x9d, 0x9a, 0x00, 0x80, 0x9a, 0xa3, 0x6d,
+    0x03, 0x8d, 0x6d, 0x29, 0xcf, 0x1f, 0xaf, 0x80,
+    0x9d, 0x74, 0x01, 0x89, 0x74, 0x05, 0xa3, 0x73,
+    0x03, 0xa3, 0x73, 0x03, 0xa7, 0x25, 0x07, 0xb3,
+    0x14, 0x0a, 0x80, 0x14, 0x8a, 0x9c, 0x00, 0x8e,
+    0x9c, 0x00, 0x86, 0x9c, 0x00, 0x81, 0x9c, 0x00,
+    0x8a, 0x9c, 0x00, 0x8e, 0x9c, 0x00, 0x86, 0x9c,
+    0x00, 0x81, 0x9c, 0x42, 0xe0, 0xd6, 0x49, 0x08,
+    0x95, 0x49, 0x09, 0x87, 0x49, 0x17, 0x85, 0x46,
+    0x00, 0xa9, 0x46, 0x00, 0x88, 0x46, 0x44, 0x85,
     0x1c, 0x01, 0x80, 0x1c, 0x00, 0xab, 0x1c, 0x00,
     0x81, 0x1c, 0x02, 0x80, 0x1c, 0x01, 0x80, 0x1c,
-    0x95, 0x37, 0x00, 0x88, 0x37, 0x9f, 0x78, 0x9e,
-    0x61, 0x07, 0x88, 0x61, 0x2f, 0x92, 0x34, 0x00,
-    0x81, 0x34, 0x04, 0x84, 0x34, 0x9b, 0x7b, 0x02,
-    0x80, 0x7b, 0x99, 0x4e, 0x04, 0x80, 0x4e, 0x3f,
-    0x9f, 0x5a, 0x97, 0x59, 0x03, 0x93, 0x59, 0x01,
-    0xad, 0x59, 0x83, 0x41, 0x00, 0x81, 0x41, 0x04,
-    0x87, 0x41, 0x00, 0x82, 0x41, 0x00, 0x9c, 0x41,
-    0x01, 0x82, 0x41, 0x03, 0x89, 0x41, 0x06, 0x88,
-    0x41, 0x06, 0x9f, 0x71, 0x9f, 0x6d, 0x1f, 0xa6,
-    0x53, 0x03, 0x8b, 0x53, 0x08, 0xb5, 0x06, 0x02,
+    0x95, 0x37, 0x00, 0x88, 0x37, 0x9f, 0x76, 0x9e,
+    0x60, 0x07, 0x88, 0x60, 0x2f, 0x92, 0x34, 0x00,
+    0x81, 0x34, 0x04, 0x84, 0x34, 0x9b, 0x79, 0x02,
+    0x80, 0x79, 0x99, 0x4d, 0x04, 0x80, 0x4d, 0x3f,
+    0x9f, 0x59, 0x97, 0x58, 0x03, 0x93, 0x58, 0x01,
+    0xad, 0x58, 0x83, 0x40, 0x00, 0x81, 0x40, 0x04,
+    0x87, 0x40, 0x00, 0x82, 0x40, 0x00, 0x9c, 0x40,
+    0x01, 0x82, 0x40, 0x03, 0x89, 0x40, 0x06, 0x88,
+    0x40, 0x06, 0x9f, 0x6f, 0x9f, 0x6b, 0x1f, 0xa6,
+    0x52, 0x03, 0x8b, 0x52, 0x08, 0xb5, 0x06, 0x02,
     0x86, 0x06, 0x95, 0x3a, 0x01, 0x87, 0x3a, 0x92,
-    0x39, 0x04, 0x87, 0x39, 0x91, 0x7c, 0x06, 0x83,
-    0x7c, 0x0b, 0x86, 0x7c, 0x4f, 0xc8, 0x72, 0x36,
-    0xb2, 0x6b, 0x0c, 0xb2, 0x6b, 0x06, 0x85, 0x6b,
+    0x39, 0x04, 0x87, 0x39, 0x91, 0x7a, 0x06, 0x83,
+    0x7a, 0x0b, 0x86, 0x7a, 0x4f, 0xc8, 0x70, 0x36,
+    0xb2, 0x69, 0x0c, 0xb2, 0x69, 0x06, 0x85, 0x69,
     0xa7, 0x32, 0x07, 0x89, 0x32, 0x60, 0xc5, 0x9e,
-    0x04, 0x00, 0xa9, 0xa1, 0x00, 0x82, 0xa1, 0x01,
-    0x81, 0xa1, 0x4a, 0x82, 0x04, 0xa7, 0x70, 0x07,
-    0xa9, 0x86, 0x15, 0x99, 0x73, 0x25, 0x9b, 0x18,
-    0x13, 0x96, 0x26, 0x08, 0xcd, 0x0e, 0x03, 0xa3,
-    0x0e, 0x08, 0x80, 0x0e, 0xc2, 0x3c, 0x09, 0x80,
-    0x3c, 0x01, 0x98, 0x87, 0x06, 0x89, 0x87, 0x05,
-    0xb4, 0x15, 0x00, 0x91, 0x15, 0x07, 0xa6, 0x50,
-    0x08, 0xdf, 0x81, 0x00, 0x93, 0x85, 0x0a, 0x91,
-    0x43, 0x00, 0xae, 0x43, 0x3d, 0x86, 0x5f, 0x00,
-    0x80, 0x5f, 0x00, 0x83, 0x5f, 0x00, 0x8e, 0x5f,
-    0x00, 0x8a, 0x5f, 0x05, 0xba, 0x45, 0x04, 0x89,
-    0x45, 0x05, 0x83, 0x2b, 0x00, 0x87, 0x2b, 0x01,
-    0x81, 0x2b, 0x01, 0x95, 0x2b, 0x00, 0x86, 0x2b,
-    0x00, 0x81, 0x2b, 0x00, 0x84, 0x2b, 0x00, 0x80,
-    0x38, 0x88, 0x2b, 0x01, 0x81, 0x2b, 0x01, 0x82,
-    0x2b, 0x01, 0x80, 0x2b, 0x05, 0x80, 0x2b, 0x04,
-    0x86, 0x2b, 0x01, 0x86, 0x2b, 0x02, 0x84, 0x2b,
-    0x60, 0x2a, 0xdb, 0x65, 0x00, 0x84, 0x65, 0x1d,
-    0xc7, 0x99, 0x07, 0x89, 0x99, 0x60, 0x45, 0xb5,
-    0x83, 0x01, 0xa5, 0x83, 0x21, 0xc4, 0x5c, 0x0a,
-    0x89, 0x5c, 0x05, 0x8c, 0x5d, 0x12, 0xb9, 0x91,
-    0x05, 0x89, 0x91, 0x35, 0x9a, 0x02, 0x01, 0x8e,
-    0x02, 0x03, 0x96, 0x02, 0x60, 0x58, 0xbb, 0x22,
-    0x60, 0x03, 0xd2, 0xa0, 0x0b, 0x80, 0xa0, 0x86,
-    0x21, 0x01, 0x80, 0x21, 0x01, 0x87, 0x21, 0x00,
-    0x81, 0x21, 0x00, 0x9d, 0x21, 0x00, 0x81, 0x21,
-    0x01, 0x8b, 0x21, 0x08, 0x89, 0x21, 0x45, 0x87,
-    0x63, 0x01, 0xad, 0x63, 0x01, 0x8a, 0x63, 0x1a,
-    0xc7, 0xa3, 0x07, 0xd2, 0x88, 0x0c, 0x8f, 0x12,
-    0xb8, 0x79, 0x06, 0x89, 0x20, 0x60, 0x95, 0x88,
-    0x0c, 0x00, 0xac, 0x0c, 0x00, 0x8d, 0x0c, 0x09,
-    0x9c, 0x0c, 0x02, 0x9f, 0x54, 0x01, 0x95, 0x54,
-    0x00, 0x8d, 0x54, 0x48, 0x86, 0x55, 0x00, 0x81,
-    0x55, 0x00, 0xab, 0x55, 0x02, 0x80, 0x55, 0x00,
-    0x81, 0x55, 0x00, 0x88, 0x55, 0x07, 0x89, 0x55,
-    0x05, 0x85, 0x2e, 0x00, 0x81, 0x2e, 0x00, 0xa4,
-    0x2e, 0x00, 0x81, 0x2e, 0x00, 0x85, 0x2e, 0x06,
-    0x89, 0x2e, 0x60, 0xd5, 0x98, 0x4f, 0x06, 0x90,
-    0x3f, 0x00, 0xa8, 0x3f, 0x02, 0x9b, 0x3f, 0x55,
-    0x80, 0x4c, 0x0e, 0xb1, 0x92, 0x0c, 0x80, 0x92,
-    0xe3, 0x39, 0x1b, 0x60, 0x05, 0xe0, 0x0e, 0x1b,
-    0x00, 0x84, 0x1b, 0x0a, 0xe0, 0x63, 0x1b, 0x69,
-    0xeb, 0xe0, 0x02, 0x1e, 0x0c, 0xe3, 0xf5, 0x24,
-    0x6f, 0x49, 0xe1, 0xe6, 0x03, 0x70, 0x11, 0x58,
-    0xe1, 0xd8, 0x08, 0x06, 0x9e, 0x5e, 0x00, 0x89,
-    0x5e, 0x03, 0x81, 0x5e, 0xce, 0x9a, 0x00, 0x89,
-    0x9a, 0x05, 0x9d, 0x09, 0x01, 0x85, 0x09, 0x09,
-    0xc5, 0x77, 0x09, 0x89, 0x77, 0x00, 0x86, 0x77,
-    0x00, 0x94, 0x77, 0x04, 0x92, 0x77, 0x62, 0x4f,
-    0xda, 0x56, 0x60, 0x04, 0xca, 0x5b, 0x03, 0xb8,
-    0x5b, 0x06, 0x90, 0x5b, 0x3f, 0x80, 0x93, 0x80,
-    0x67, 0x81, 0x30, 0x80, 0x44, 0x0a, 0x81, 0x30,
-    0x0d, 0xf0, 0x07, 0x97, 0x93, 0x07, 0xe2, 0x9f,
-    0x93, 0xe1, 0x75, 0x44, 0x29, 0x88, 0x93, 0x70,
-    0x12, 0x86, 0x83, 0x3e, 0x00, 0x86, 0x3e, 0x00,
-    0x81, 0x3e, 0x00, 0x80, 0x3e, 0xe0, 0xbe, 0x36,
-    0x82, 0x3e, 0x0e, 0x80, 0x36, 0x1c, 0x82, 0x36,
-    0x01, 0x80, 0x3e, 0x0d, 0x83, 0x3e, 0x07, 0xe1,
-    0x2b, 0x67, 0x68, 0xa3, 0xe0, 0x0a, 0x23, 0x04,
+    0x04, 0x00, 0xa9, 0x9f, 0x00, 0x82, 0x9f, 0x01,
+    0x81, 0x9f, 0x4d, 0xa7, 0x6e, 0x07, 0xa9, 0x84,
+    0x15, 0x99, 0x71, 0x25, 0x9b, 0x18, 0x13, 0x96,
+    0x26, 0x08, 0xcd, 0x0e, 0x03, 0xa3, 0x0e, 0x08,
+    0x80, 0x0e, 0xc2, 0x3c, 0x09, 0x80, 0x3c, 0x01,
+    0x98, 0x85, 0x06, 0x89, 0x85, 0x05, 0xb4, 0x15,
+    0x00, 0x91, 0x15, 0x07, 0xa6, 0x4f, 0x08, 0xdf,
+    0x7f, 0x00, 0x93, 0x83, 0x0a, 0x91, 0x42, 0x00,
+    0xab, 0x42, 0x40, 0x86, 0x5e, 0x00, 0x80, 0x5e,
+    0x00, 0x83, 0x5e, 0x00, 0x8e, 0x5e, 0x00, 0x8a,
+    0x5e, 0x05, 0xba, 0x44, 0x04, 0x89, 0x44, 0x05,
+    0x83, 0x2b, 0x00, 0x87, 0x2b, 0x01, 0x81, 0x2b,
+    0x01, 0x95, 0x2b, 0x00, 0x86, 0x2b, 0x00, 0x81,
+    0x2b, 0x00, 0x84, 0x2b, 0x00, 0x80, 0x38, 0x88,
+    0x2b, 0x01, 0x81, 0x2b, 0x01, 0x82, 0x2b, 0x01,
+    0x80, 0x2b, 0x05, 0x80, 0x2b, 0x04, 0x86, 0x2b,
+    0x01, 0x86, 0x2b, 0x02, 0x84, 0x2b, 0x60, 0x2a,
+    0xdb, 0x63, 0x00, 0x84, 0x63, 0x1d, 0xc7, 0x97,
+    0x07, 0x89, 0x97, 0x60, 0x45, 0xb5, 0x81, 0x01,
+    0xa5, 0x81, 0x21, 0xc4, 0x5b, 0x0a, 0x89, 0x5b,
+    0x05, 0x8c, 0x5c, 0x12, 0xb9, 0x8f, 0x05, 0x89,
+    0x8f, 0x35, 0x9a, 0x02, 0x01, 0x8e, 0x02, 0x03,
+    0x96, 0x02, 0x60, 0x58, 0xbb, 0x22, 0x60, 0x03,
+    0xd2, 0x9e, 0x0b, 0x80, 0x9e, 0x86, 0x21, 0x01,
+    0x80, 0x21, 0x01, 0x87, 0x21, 0x00, 0x81, 0x21,
+    0x00, 0x9d, 0x21, 0x00, 0x81, 0x21, 0x01, 0x8b,
+    0x21, 0x08, 0x89, 0x21, 0x45, 0x87, 0x61, 0x01,
+    0xad, 0x61, 0x01, 0x8a, 0x61, 0x1a, 0xc7, 0xa1,
+    0x07, 0xd2, 0x86, 0x0c, 0x8f, 0x12, 0xb8, 0x77,
+    0x60, 0xa6, 0x88, 0x0c, 0x00, 0xac, 0x0c, 0x00,
+    0x8d, 0x0c, 0x09, 0x9c, 0x0c, 0x02, 0x9f, 0x53,
+    0x01, 0x95, 0x53, 0x00, 0x8d, 0x53, 0x48, 0x86,
+    0x54, 0x00, 0x81, 0x54, 0x00, 0xab, 0x54, 0x02,
+    0x80, 0x54, 0x00, 0x81, 0x54, 0x00, 0x88, 0x54,
+    0x07, 0x89, 0x54, 0x05, 0x85, 0x2e, 0x00, 0x81,
+    0x2e, 0x00, 0xa4, 0x2e, 0x00, 0x81, 0x2e, 0x00,
+    0x85, 0x2e, 0x06, 0x89, 0x2e, 0x60, 0xd5, 0x98,
+    0x4e, 0x60, 0x56, 0x80, 0x4b, 0x0e, 0xb1, 0x90,
+    0x0c, 0x80, 0x90, 0xe3, 0x39, 0x1b, 0x60, 0x05,
+    0xe0, 0x0e, 0x1b, 0x00, 0x84, 0x1b, 0x0a, 0xe0,
+    0x63, 0x1b, 0x69, 0xeb, 0xe0, 0x02, 0x1e, 0x0c,
+    0xe3, 0xce, 0x24, 0x00, 0x88, 0x24, 0x6f, 0x66,
+    0xe1, 0xe6, 0x03, 0x70, 0x11, 0x58, 0xe1, 0xd8,
+    0x08, 0x06, 0x9e, 0x5d, 0x00, 0x89, 0x5d, 0x03,
+    0x81, 0x5d, 0xce, 0x98, 0x00, 0x89, 0x98, 0x05,
+    0x9d, 0x09, 0x01, 0x85, 0x09, 0x09, 0xc5, 0x75,
+    0x09, 0x89, 0x75, 0x00, 0x86, 0x75, 0x00, 0x94,
+    0x75, 0x04, 0x92, 0x75, 0x62, 0x4f, 0xda, 0x55,
+    0x60, 0x04, 0xca, 0x5a, 0x03, 0xb8, 0x5a, 0x06,
+    0x90, 0x5a, 0x3f, 0x80, 0x91, 0x80, 0x65, 0x81,
+    0x30, 0x80, 0x43, 0x0a, 0x81, 0x30, 0x0d, 0xf0,
+    0x07, 0x97, 0x91, 0x07, 0xe2, 0x9f, 0x91, 0xe1,
+    0x75, 0x43, 0x29, 0x88, 0x91, 0x70, 0x12, 0x86,
+    0x83, 0x3e, 0x00, 0x86, 0x3e, 0x00, 0x81, 0x3e,
+    0x00, 0x80, 0x3e, 0xe0, 0xbe, 0x36, 0x82, 0x3e,
+    0x2c, 0x82, 0x36, 0x10, 0x83, 0x3e, 0x07, 0xe1,
+    0x2b, 0x65, 0x68, 0xa3, 0xe0, 0x0a, 0x23, 0x04,
     0x8c, 0x23, 0x02, 0x88, 0x23, 0x06, 0x89, 0x23,
     0x01, 0x83, 0x23, 0x83, 0x19, 0x70, 0x01, 0xfb,
     0xad, 0x38, 0x01, 0x96, 0x38, 0x08, 0xe0, 0x13,
     0x19, 0x3b, 0xe0, 0x95, 0x19, 0x09, 0xa6, 0x19,
     0x01, 0xbd, 0x19, 0x82, 0x38, 0x90, 0x19, 0x87,
     0x38, 0x81, 0x19, 0x86, 0x38, 0x9d, 0x19, 0x83,
-    0x38, 0xbc, 0x19, 0x14, 0xc5, 0x2c, 0x60, 0x19,
-    0x93, 0x19, 0x0b, 0x93, 0x19, 0x0b, 0xd6, 0x19,
-    0x08, 0x98, 0x19, 0x60, 0x26, 0xd4, 0x19, 0x00,
-    0xc6, 0x19, 0x00, 0x81, 0x19, 0x01, 0x80, 0x19,
-    0x01, 0x81, 0x19, 0x01, 0x83, 0x19, 0x00, 0x8b,
-    0x19, 0x00, 0x80, 0x19, 0x00, 0x86, 0x19, 0x00,
-    0xc0, 0x19, 0x00, 0x83, 0x19, 0x01, 0x87, 0x19,
-    0x00, 0x86, 0x19, 0x00, 0x9b, 0x19, 0x00, 0x83,
-    0x19, 0x00, 0x84, 0x19, 0x00, 0x80, 0x19, 0x02,
-    0x86, 0x19, 0x00, 0xe0, 0xf3, 0x19, 0x01, 0xe0,
-    0xc3, 0x19, 0x01, 0xb1, 0x19, 0xe2, 0x2b, 0x84,
-    0x0e, 0x84, 0x84, 0x00, 0x8e, 0x84, 0x63, 0xef,
-    0x9e, 0x47, 0x05, 0x85, 0x47, 0x60, 0x74, 0x86,
-    0x29, 0x00, 0x90, 0x29, 0x01, 0x86, 0x29, 0x00,
-    0x81, 0x29, 0x00, 0x84, 0x29, 0x04, 0xbd, 0x1d,
-    0x20, 0x80, 0x1d, 0x60, 0x0f, 0xac, 0x68, 0x02,
-    0x8d, 0x68, 0x01, 0x89, 0x68, 0x03, 0x81, 0x68,
-    0x60, 0xdf, 0x9e, 0x9b, 0x10, 0xb9, 0x9f, 0x04,
-    0x80, 0x9f, 0x61, 0x6f, 0xa9, 0x62, 0x62, 0x85,
+    0x38, 0xbc, 0x19, 0x14, 0xc5, 0x2c, 0x60, 0x39,
+    0x93, 0x19, 0x0b, 0xd6, 0x19, 0x08, 0x98, 0x19,
+    0x60, 0x26, 0xd4, 0x19, 0x00, 0xc6, 0x19, 0x00,
+    0x81, 0x19, 0x01, 0x80, 0x19, 0x01, 0x81, 0x19,
+    0x01, 0x83, 0x19, 0x00, 0x8b, 0x19, 0x00, 0x80,
+    0x19, 0x00, 0x86, 0x19, 0x00, 0xc0, 0x19, 0x00,
+    0x83, 0x19, 0x01, 0x87, 0x19, 0x00, 0x86, 0x19,
+    0x00, 0x9b, 0x19, 0x00, 0x83, 0x19, 0x00, 0x84,
+    0x19, 0x00, 0x80, 0x19, 0x02, 0x86, 0x19, 0x00,
+    0xe0, 0xf3, 0x19, 0x01, 0xe0, 0xc3, 0x19, 0x01,
+    0xb1, 0x19, 0xe2, 0x2b, 0x82, 0x0e, 0x84, 0x82,
+    0x00, 0x8e, 0x82, 0x63, 0xef, 0x9e, 0x46, 0x60,
+    0x80, 0x86, 0x29, 0x00, 0x90, 0x29, 0x01, 0x86,
+    0x29, 0x00, 0x81, 0x29, 0x00, 0x84, 0x29, 0x60,
+    0x74, 0xac, 0x66, 0x02, 0x8d, 0x66, 0x01, 0x89,
+    0x66, 0x03, 0x81, 0x66, 0x60, 0xdf, 0x9e, 0x99,
+    0x10, 0xb9, 0x9d, 0x04, 0x80, 0x9d, 0x64, 0x7f,
     0x86, 0x27, 0x00, 0x83, 0x27, 0x00, 0x81, 0x27,
-    0x00, 0x8e, 0x27, 0x00, 0xe0, 0x64, 0x58, 0x01,
-    0x8f, 0x58, 0x28, 0xcb, 0x01, 0x03, 0x89, 0x01,
+    0x00, 0x8e, 0x27, 0x00, 0xe0, 0x64, 0x57, 0x01,
+    0x8f, 0x57, 0x28, 0xcb, 0x01, 0x03, 0x89, 0x01,
     0x03, 0x81, 0x01, 0x62, 0xb0, 0xc3, 0x19, 0x4b,
     0xbc, 0x19, 0x60, 0x61, 0x83, 0x04, 0x00, 0x9a,
     0x04, 0x00, 0x81, 0x04, 0x00, 0x80, 0x04, 0x01,
@@ -3491,85 +3455,86 @@
     0x19, 0x37, 0x99, 0x19, 0x80, 0x36, 0x81, 0x19,
     0x0c, 0xab, 0x19, 0x03, 0x88, 0x19, 0x06, 0x81,
     0x19, 0x0d, 0x85, 0x19, 0x60, 0x39, 0xe3, 0x77,
-    0x19, 0x03, 0x90, 0x19, 0x02, 0x8c, 0x19, 0x02,
-    0xe0, 0x16, 0x19, 0x03, 0xde, 0x19, 0x05, 0x8b,
+    0x19, 0x04, 0x8f, 0x19, 0x02, 0x8c, 0x19, 0x02,
+    0xe0, 0x13, 0x19, 0x0b, 0xd8, 0x19, 0x06, 0x8b,
     0x19, 0x03, 0x80, 0x19, 0x0e, 0x8b, 0x19, 0x03,
     0xb7, 0x19, 0x07, 0x89, 0x19, 0x05, 0xa7, 0x19,
     0x07, 0x9d, 0x19, 0x01, 0x81, 0x19, 0x4d, 0xe0,
-    0xf3, 0x19, 0x0b, 0x8d, 0x19, 0x01, 0x8c, 0x19,
-    0x02, 0x88, 0x19, 0x06, 0xad, 0x19, 0x00, 0x86,
-    0x19, 0x07, 0x8d, 0x19, 0x03, 0x88, 0x19, 0x06,
-    0x88, 0x19, 0x06, 0xe0, 0x32, 0x19, 0x00, 0xb6,
-    0x19, 0x24, 0x89, 0x19, 0x63, 0xa5, 0xf0, 0x96,
-    0x7f, 0x30, 0x1f, 0xef, 0xd9, 0x30, 0x05, 0xe0,
-    0x7d, 0x30, 0x01, 0xf0, 0x06, 0x21, 0x30, 0x0d,
-    0xf0, 0x0c, 0xd0, 0x30, 0x6b, 0xbe, 0xe1, 0xbd,
-    0x30, 0x65, 0x81, 0xf0, 0x02, 0xea, 0x30, 0x04,
-    0xef, 0xff, 0x30, 0x7a, 0xcb, 0xf0, 0x80, 0x19,
-    0x1d, 0xdf, 0x19, 0x60, 0x1f, 0xe0, 0x8f, 0x38,
+    0xf3, 0x19, 0x0b, 0x8d, 0x19, 0x01, 0x84, 0x19,
+    0x02, 0x84, 0x19, 0x02, 0x86, 0x19, 0x08, 0x9c,
+    0x19, 0x02, 0x8a, 0x19, 0x04, 0x85, 0x19, 0x09,
+    0x89, 0x19, 0x05, 0x87, 0x19, 0x07, 0x86, 0x19,
+    0x08, 0xe0, 0x32, 0x19, 0x00, 0xb6, 0x19, 0x24,
+    0x89, 0x19, 0x63, 0xa5, 0xf0, 0x96, 0x7f, 0x30,
+    0x1f, 0xef, 0xd8, 0x30, 0x06, 0xe0, 0x7d, 0x30,
+    0x01, 0xf0, 0x06, 0x21, 0x30, 0x0d, 0xf0, 0x0c,
+    0xd0, 0x30, 0x6b, 0xbe, 0xe1, 0xbd, 0x30, 0x65,
+    0x81, 0xf0, 0x02, 0xea, 0x30, 0x7a, 0xdc, 0x55,
+    0x80, 0x19, 0x1d, 0xdf, 0x19, 0x60, 0x1f, 0xe0,
+    0x8f, 0x38,
 };
 
 static const uint8_t unicode_script_ext_table[828] = {
     0x82, 0xc1, 0x00, 0x00, 0x01, 0x2c, 0x01, 0x00,
-    0x00, 0x01, 0x2c, 0x1c, 0x00, 0x0c, 0x01, 0x47,
-    0x80, 0x92, 0x00, 0x00, 0x02, 0x1d, 0x6e, 0x00,
-    0x02, 0x1d, 0x29, 0x01, 0x02, 0x1d, 0x47, 0x00,
+    0x00, 0x01, 0x2c, 0x1c, 0x00, 0x0c, 0x01, 0x46,
+    0x80, 0x92, 0x00, 0x00, 0x02, 0x1d, 0x6c, 0x00,
+    0x02, 0x1d, 0x29, 0x01, 0x02, 0x1d, 0x46, 0x00,
     0x02, 0x1d, 0x29, 0x81, 0x03, 0x00, 0x00, 0x06,
-    0x04, 0x66, 0x32, 0x8b, 0x95, 0xa1, 0x0d, 0x00,
-    0x00, 0x06, 0x04, 0x66, 0x32, 0x8b, 0x95, 0xa1,
-    0x00, 0x03, 0x04, 0x8b, 0x95, 0x01, 0x00, 0x00,
-    0x07, 0x01, 0x04, 0x66, 0x32, 0x8b, 0x95, 0xa1,
-    0x1f, 0x00, 0x00, 0x09, 0x01, 0x04, 0x52, 0x53,
-    0x73, 0x7c, 0x32, 0x86, 0x8b, 0x09, 0x00, 0x0a,
-    0x02, 0x04, 0x8b, 0x09, 0x00, 0x09, 0x03, 0x04,
-    0x95, 0xa1, 0x05, 0x00, 0x00, 0x02, 0x04, 0x8b,
+    0x04, 0x64, 0x32, 0x89, 0x93, 0x9f, 0x0d, 0x00,
+    0x00, 0x06, 0x04, 0x64, 0x32, 0x89, 0x93, 0x9f,
+    0x00, 0x03, 0x04, 0x89, 0x93, 0x01, 0x00, 0x00,
+    0x07, 0x01, 0x04, 0x64, 0x32, 0x89, 0x93, 0x9f,
+    0x1f, 0x00, 0x00, 0x09, 0x01, 0x04, 0x51, 0x52,
+    0x71, 0x7a, 0x32, 0x84, 0x89, 0x09, 0x00, 0x0a,
+    0x02, 0x04, 0x89, 0x09, 0x00, 0x09, 0x03, 0x04,
+    0x93, 0x9f, 0x05, 0x00, 0x00, 0x02, 0x04, 0x89,
     0x62, 0x00, 0x00, 0x02, 0x04, 0x32, 0x81, 0xfb,
     0x00, 0x00, 0x0d, 0x0b, 0x20, 0x2b, 0x2d, 0x2f,
-    0x3d, 0x47, 0x51, 0x74, 0x81, 0x92, 0x94, 0x99,
+    0x3d, 0x46, 0x50, 0x72, 0x7f, 0x90, 0x92, 0x97,
     0x00, 0x0c, 0x0b, 0x20, 0x2b, 0x2d, 0x2f, 0x3d,
-    0x47, 0x51, 0x74, 0x92, 0x94, 0x99, 0x10, 0x00,
-    0x00, 0x14, 0x0b, 0x20, 0x22, 0x2e, 0x55, 0x2b,
-    0x2d, 0x2f, 0x3d, 0x50, 0x51, 0x63, 0x74, 0x45,
-    0x85, 0x8a, 0x91, 0x92, 0x94, 0x99, 0x00, 0x15,
-    0x0b, 0x20, 0x22, 0x2e, 0x55, 0x2b, 0x2d, 0x2f,
-    0x3d, 0x49, 0x50, 0x51, 0x63, 0x74, 0x45, 0x85,
-    0x8a, 0x91, 0x92, 0x94, 0x99, 0x09, 0x04, 0x20,
-    0x22, 0x3c, 0x50, 0x75, 0x00, 0x09, 0x03, 0x0b,
-    0x15, 0x8a, 0x75, 0x00, 0x09, 0x02, 0x2f, 0x5f,
-    0x75, 0x00, 0x09, 0x02, 0x2d, 0x43, 0x80, 0x75,
-    0x00, 0x0d, 0x02, 0x2b, 0x92, 0x80, 0x71, 0x00,
-    0x09, 0x02, 0x3d, 0x63, 0x82, 0xcf, 0x00, 0x09,
-    0x03, 0x15, 0x60, 0x8e, 0x80, 0x30, 0x00, 0x00,
-    0x02, 0x28, 0x47, 0x85, 0xb8, 0x00, 0x01, 0x04,
-    0x11, 0x33, 0x8d, 0x8c, 0x80, 0x4a, 0x00, 0x01,
-    0x02, 0x5d, 0x7a, 0x00, 0x00, 0x00, 0x02, 0x5d,
-    0x7a, 0x84, 0x49, 0x00, 0x00, 0x04, 0x0b, 0x20,
+    0x46, 0x50, 0x72, 0x90, 0x92, 0x97, 0x10, 0x00,
+    0x00, 0x14, 0x0b, 0x20, 0x22, 0x2e, 0x54, 0x2b,
+    0x2d, 0x2f, 0x3d, 0x4f, 0x50, 0x61, 0x72, 0x44,
+    0x83, 0x88, 0x8f, 0x90, 0x92, 0x97, 0x00, 0x15,
+    0x0b, 0x20, 0x22, 0x2e, 0x54, 0x2b, 0x2d, 0x2f,
+    0x3d, 0x48, 0x4f, 0x50, 0x61, 0x72, 0x44, 0x83,
+    0x88, 0x8f, 0x90, 0x92, 0x97, 0x09, 0x04, 0x20,
+    0x22, 0x3c, 0x4f, 0x75, 0x00, 0x09, 0x03, 0x0b,
+    0x15, 0x88, 0x75, 0x00, 0x09, 0x02, 0x2f, 0x5e,
+    0x75, 0x00, 0x09, 0x02, 0x2d, 0x42, 0x80, 0x75,
+    0x00, 0x0d, 0x02, 0x2b, 0x90, 0x80, 0x71, 0x00,
+    0x09, 0x02, 0x3d, 0x61, 0x82, 0xcf, 0x00, 0x09,
+    0x03, 0x15, 0x5f, 0x8c, 0x80, 0x30, 0x00, 0x00,
+    0x02, 0x28, 0x46, 0x85, 0xb8, 0x00, 0x01, 0x04,
+    0x11, 0x33, 0x8b, 0x8a, 0x80, 0x4a, 0x00, 0x01,
+    0x02, 0x5c, 0x78, 0x00, 0x00, 0x00, 0x02, 0x5c,
+    0x78, 0x84, 0x49, 0x00, 0x00, 0x04, 0x0b, 0x20,
     0x2b, 0x3d, 0x00, 0x01, 0x20, 0x00, 0x04, 0x0b,
     0x20, 0x2b, 0x3d, 0x00, 0x02, 0x20, 0x2b, 0x00,
     0x01, 0x20, 0x01, 0x02, 0x0b, 0x20, 0x00, 0x02,
-    0x20, 0x81, 0x00, 0x02, 0x0b, 0x20, 0x00, 0x02,
-    0x20, 0x81, 0x00, 0x06, 0x20, 0x3d, 0x51, 0x74,
-    0x92, 0x94, 0x00, 0x01, 0x20, 0x01, 0x02, 0x20,
-    0x81, 0x01, 0x01, 0x20, 0x00, 0x02, 0x20, 0x81,
+    0x20, 0x7f, 0x00, 0x02, 0x0b, 0x20, 0x00, 0x02,
+    0x20, 0x7f, 0x00, 0x06, 0x20, 0x3d, 0x50, 0x72,
+    0x90, 0x92, 0x00, 0x01, 0x20, 0x01, 0x02, 0x20,
+    0x7f, 0x01, 0x01, 0x20, 0x00, 0x02, 0x20, 0x7f,
     0x00, 0x02, 0x0b, 0x20, 0x06, 0x01, 0x20, 0x00,
-    0x02, 0x20, 0x63, 0x00, 0x02, 0x0b, 0x20, 0x01,
+    0x02, 0x20, 0x61, 0x00, 0x02, 0x0b, 0x20, 0x01,
     0x01, 0x20, 0x00, 0x02, 0x0b, 0x20, 0x03, 0x01,
-    0x20, 0x00, 0x08, 0x0b, 0x20, 0x2b, 0x3d, 0x63,
-    0x74, 0x94, 0x99, 0x00, 0x02, 0x20, 0x2b, 0x00,
+    0x20, 0x00, 0x08, 0x0b, 0x20, 0x2b, 0x3d, 0x61,
+    0x72, 0x92, 0x97, 0x00, 0x02, 0x20, 0x2b, 0x00,
     0x03, 0x20, 0x2b, 0x3d, 0x01, 0x02, 0x0b, 0x20,
     0x00, 0x01, 0x0b, 0x01, 0x02, 0x20, 0x2b, 0x00,
-    0x01, 0x63, 0x80, 0x44, 0x00, 0x01, 0x01, 0x2c,
-    0x35, 0x00, 0x00, 0x02, 0x1d, 0x8b, 0x00, 0x00,
-    0x00, 0x01, 0x8b, 0x81, 0xb3, 0x00, 0x00, 0x02,
-    0x47, 0x5d, 0x80, 0x3f, 0x00, 0x00, 0x03, 0x20,
-    0x2b, 0x47, 0x8c, 0xd1, 0x00, 0x00, 0x02, 0x1d,
+    0x01, 0x61, 0x80, 0x44, 0x00, 0x01, 0x01, 0x2c,
+    0x35, 0x00, 0x00, 0x02, 0x1d, 0x89, 0x00, 0x00,
+    0x00, 0x01, 0x89, 0x81, 0xb3, 0x00, 0x00, 0x02,
+    0x46, 0x5c, 0x80, 0x3f, 0x00, 0x00, 0x03, 0x20,
+    0x2b, 0x46, 0x8c, 0xd1, 0x00, 0x00, 0x02, 0x1d,
     0x29, 0x81, 0x3c, 0x00, 0x01, 0x06, 0x0d, 0x31,
-    0x30, 0x36, 0x3e, 0xa2, 0x00, 0x05, 0x0d, 0x31,
+    0x30, 0x36, 0x3e, 0xa0, 0x00, 0x05, 0x0d, 0x31,
     0x30, 0x36, 0x3e, 0x01, 0x00, 0x00, 0x01, 0x30,
     0x00, 0x00, 0x09, 0x06, 0x0d, 0x31, 0x30, 0x36,
-    0x3e, 0xa2, 0x00, 0x00, 0x00, 0x05, 0x0d, 0x31,
+    0x3e, 0xa0, 0x00, 0x00, 0x00, 0x05, 0x0d, 0x31,
     0x30, 0x36, 0x3e, 0x07, 0x06, 0x0d, 0x31, 0x30,
-    0x36, 0x3e, 0xa2, 0x03, 0x05, 0x0d, 0x31, 0x30,
+    0x36, 0x3e, 0xa0, 0x03, 0x05, 0x0d, 0x31, 0x30,
     0x36, 0x3e, 0x09, 0x00, 0x03, 0x02, 0x0d, 0x30,
     0x01, 0x00, 0x00, 0x05, 0x0d, 0x31, 0x30, 0x36,
     0x3e, 0x04, 0x02, 0x36, 0x3e, 0x00, 0x00, 0x00,
@@ -3577,7 +3542,7 @@
     0x01, 0x03, 0x30, 0x36, 0x3e, 0x01, 0x01, 0x30,
     0x58, 0x00, 0x03, 0x02, 0x36, 0x3e, 0x02, 0x00,
     0x00, 0x02, 0x36, 0x3e, 0x59, 0x00, 0x00, 0x06,
-    0x0d, 0x31, 0x30, 0x36, 0x3e, 0xa2, 0x00, 0x02,
+    0x0d, 0x31, 0x30, 0x36, 0x3e, 0xa0, 0x00, 0x02,
     0x36, 0x3e, 0x80, 0x12, 0x00, 0x0f, 0x01, 0x30,
     0x1f, 0x00, 0x23, 0x01, 0x30, 0x3b, 0x00, 0x27,
     0x01, 0x30, 0x37, 0x00, 0x30, 0x01, 0x30, 0x0e,
@@ -3585,32 +3550,32 @@
     0x30, 0x57, 0x00, 0x18, 0x01, 0x30, 0x09, 0x00,
     0x04, 0x01, 0x30, 0x5f, 0x00, 0x1e, 0x01, 0x30,
     0xc0, 0x31, 0xef, 0x00, 0x00, 0x02, 0x1d, 0x29,
-    0x80, 0x0f, 0x00, 0x07, 0x02, 0x30, 0x47, 0x80,
+    0x80, 0x0f, 0x00, 0x07, 0x02, 0x30, 0x46, 0x80,
     0xa7, 0x00, 0x02, 0x0e, 0x20, 0x22, 0x2d, 0x2f,
-    0x43, 0x3d, 0x3c, 0x50, 0x51, 0x5c, 0x63, 0x45,
-    0x91, 0x99, 0x02, 0x0d, 0x20, 0x22, 0x2d, 0x2f,
-    0x43, 0x3d, 0x3c, 0x50, 0x5c, 0x63, 0x45, 0x91,
-    0x99, 0x03, 0x0b, 0x20, 0x22, 0x2d, 0x2f, 0x43,
-    0x3c, 0x50, 0x5c, 0x45, 0x91, 0x99, 0x80, 0x36,
+    0x42, 0x3d, 0x3c, 0x4f, 0x50, 0x5b, 0x61, 0x44,
+    0x8f, 0x97, 0x02, 0x0d, 0x20, 0x22, 0x2d, 0x2f,
+    0x42, 0x3d, 0x3c, 0x4f, 0x5b, 0x61, 0x44, 0x8f,
+    0x97, 0x03, 0x0b, 0x20, 0x22, 0x2d, 0x2f, 0x42,
+    0x3c, 0x4f, 0x5b, 0x44, 0x8f, 0x97, 0x80, 0x36,
     0x00, 0x00, 0x02, 0x0b, 0x20, 0x00, 0x00, 0x00,
-    0x02, 0x20, 0x92, 0x39, 0x00, 0x00, 0x03, 0x40,
-    0x47, 0x60, 0x80, 0x1f, 0x00, 0x00, 0x02, 0x10,
+    0x02, 0x20, 0x90, 0x39, 0x00, 0x00, 0x03, 0x3f,
+    0x46, 0x5f, 0x80, 0x1f, 0x00, 0x00, 0x02, 0x10,
     0x3b, 0xc0, 0x12, 0xed, 0x00, 0x01, 0x02, 0x04,
-    0x66, 0x80, 0x31, 0x00, 0x00, 0x02, 0x04, 0x95,
-    0x09, 0x00, 0x00, 0x02, 0x04, 0x95, 0x46, 0x00,
+    0x64, 0x80, 0x31, 0x00, 0x00, 0x02, 0x04, 0x93,
+    0x09, 0x00, 0x00, 0x02, 0x04, 0x93, 0x46, 0x00,
     0x01, 0x05, 0x0d, 0x31, 0x30, 0x36, 0x3e, 0x80,
     0x99, 0x00, 0x04, 0x06, 0x0d, 0x31, 0x30, 0x36,
-    0x3e, 0xa2, 0x09, 0x00, 0x00, 0x02, 0x36, 0x3e,
+    0x3e, 0xa0, 0x09, 0x00, 0x00, 0x02, 0x36, 0x3e,
     0x2c, 0x00, 0x01, 0x02, 0x36, 0x3e, 0x80, 0xdf,
-    0x00, 0x01, 0x03, 0x1e, 0x1c, 0x4b, 0x00, 0x02,
-    0x1c, 0x4b, 0x03, 0x00, 0x2c, 0x03, 0x1c, 0x4a,
-    0x4b, 0x02, 0x00, 0x08, 0x02, 0x1c, 0x4b, 0x81,
+    0x00, 0x01, 0x03, 0x1e, 0x1c, 0x4a, 0x00, 0x02,
+    0x1c, 0x4a, 0x03, 0x00, 0x2c, 0x03, 0x1c, 0x49,
+    0x4a, 0x02, 0x00, 0x08, 0x02, 0x1c, 0x4a, 0x81,
     0x1f, 0x00, 0x1b, 0x02, 0x04, 0x1a, 0x87, 0x75,
-    0x00, 0x00, 0x02, 0x53, 0x73, 0x87, 0x8d, 0x00,
-    0x00, 0x02, 0x2b, 0x92, 0x00, 0x00, 0x00, 0x02,
-    0x2b, 0x92, 0x36, 0x00, 0x01, 0x02, 0x2b, 0x92,
-    0x8c, 0x12, 0x00, 0x01, 0x02, 0x2b, 0x92, 0x00,
-    0x00, 0x00, 0x02, 0x2b, 0x92, 0xc0, 0x5c, 0x4b,
+    0x00, 0x00, 0x02, 0x52, 0x71, 0x87, 0x8d, 0x00,
+    0x00, 0x02, 0x2b, 0x90, 0x00, 0x00, 0x00, 0x02,
+    0x2b, 0x90, 0x36, 0x00, 0x01, 0x02, 0x2b, 0x90,
+    0x8c, 0x12, 0x00, 0x01, 0x02, 0x2b, 0x90, 0x00,
+    0x00, 0x00, 0x02, 0x2b, 0x90, 0xc0, 0x5c, 0x4b,
     0x00, 0x03, 0x01, 0x23, 0x96, 0x3b, 0x00, 0x11,
     0x01, 0x30, 0x9e, 0x5d, 0x00, 0x01, 0x01, 0x30,
     0xce, 0xcd, 0x2d, 0x00,
@@ -3651,7 +3616,7 @@
     0x80, 0x89, 0x80, 0x90, 0x22, 0x04, 0x80, 0x90,
 };
 
-static const uint8_t unicode_prop_Other_Alphabetic_table[428] = {
+static const uint8_t unicode_prop_Other_Alphabetic_table[417] = {
     0x43, 0x44, 0x80, 0x42, 0x69, 0x8d, 0x00, 0x01,
     0x01, 0x00, 0xc7, 0x8a, 0xaf, 0x8c, 0x06, 0x8f,
     0x80, 0xe4, 0x33, 0x19, 0x0b, 0x80, 0xa2, 0x80,
@@ -3663,61 +3628,59 @@
     0x0a, 0x80, 0x8a, 0x82, 0xb9, 0x38, 0x10, 0x81,
     0x94, 0x81, 0x95, 0x13, 0x82, 0xb9, 0x31, 0x09,
     0x81, 0x88, 0x81, 0x89, 0x81, 0x9d, 0x80, 0xba,
-    0x22, 0x10, 0x82, 0x89, 0x80, 0xa7, 0x84, 0xb8,
+    0x22, 0x10, 0x82, 0x89, 0x80, 0xa7, 0x83, 0xb9,
     0x30, 0x10, 0x17, 0x81, 0x8a, 0x81, 0x9c, 0x82,
-    0xb9, 0x30, 0x10, 0x17, 0x81, 0x8a, 0x81, 0x8e,
-    0x80, 0x8b, 0x83, 0xb9, 0x30, 0x10, 0x82, 0x89,
-    0x80, 0x89, 0x81, 0x9c, 0x82, 0xca, 0x28, 0x00,
-    0x87, 0x91, 0x81, 0xbc, 0x01, 0x86, 0x91, 0x80,
-    0xe2, 0x01, 0x28, 0x81, 0x8f, 0x80, 0x40, 0xa2,
-    0x92, 0x88, 0x8a, 0x80, 0xa3, 0xed, 0x8b, 0x00,
-    0x0b, 0x96, 0x1b, 0x10, 0x11, 0x32, 0x83, 0x8c,
-    0x8b, 0x00, 0x89, 0x83, 0x46, 0x73, 0x81, 0x9d,
-    0x81, 0x9d, 0x81, 0x9d, 0x81, 0xc1, 0x92, 0x40,
-    0xbb, 0x81, 0xa1, 0x80, 0xf5, 0x8b, 0x83, 0x88,
-    0x40, 0xdd, 0x84, 0xb8, 0x89, 0x81, 0x93, 0xc9,
-    0x81, 0x8a, 0x82, 0xb0, 0x84, 0xaf, 0x8e, 0xbb,
-    0x82, 0x9d, 0x88, 0x09, 0xb8, 0x8a, 0xb1, 0x92,
-    0x41, 0xaf, 0x8d, 0x46, 0xc0, 0xb3, 0x48, 0xf5,
-    0x9f, 0x60, 0x78, 0x73, 0x87, 0xa1, 0x81, 0x41,
-    0x61, 0x07, 0x80, 0x96, 0x84, 0xd7, 0x81, 0xb1,
-    0x8f, 0x00, 0xb8, 0x80, 0xa5, 0x84, 0x9b, 0x8b,
-    0xac, 0x83, 0xaf, 0x8b, 0xa4, 0x80, 0xc2, 0x8d,
-    0x8b, 0x07, 0x81, 0xac, 0x82, 0xb1, 0x00, 0x11,
-    0x0c, 0x80, 0xab, 0x24, 0x80, 0x40, 0xec, 0x87,
-    0x60, 0x4f, 0x32, 0x80, 0x48, 0x56, 0x84, 0x46,
-    0x85, 0x10, 0x0c, 0x83, 0x43, 0x13, 0x83, 0x41,
-    0x82, 0x81, 0x41, 0x52, 0x82, 0xb4, 0x8d, 0xac,
-    0x81, 0x8a, 0x82, 0xac, 0x88, 0x88, 0x80, 0xbc,
-    0x82, 0xa3, 0x8b, 0x91, 0x81, 0xb8, 0x82, 0xaf,
-    0x8c, 0x8d, 0x81, 0xdb, 0x88, 0x08, 0x28, 0x08,
-    0x40, 0x9c, 0x89, 0x96, 0x83, 0xb9, 0x31, 0x09,
-    0x81, 0x89, 0x80, 0x89, 0x81, 0x40, 0xd0, 0x8c,
-    0x02, 0xe9, 0x91, 0x40, 0xec, 0x31, 0x86, 0x9c,
-    0x81, 0xd1, 0x8e, 0x00, 0xe9, 0x8a, 0xe6, 0x8d,
-    0x41, 0x00, 0x8c, 0x40, 0xf6, 0x28, 0x09, 0x0a,
-    0x00, 0x80, 0x40, 0x8d, 0x31, 0x2b, 0x80, 0x9b,
-    0x89, 0xa9, 0x20, 0x83, 0x91, 0x8a, 0xad, 0x8d,
-    0x41, 0x96, 0x38, 0x86, 0xd2, 0x95, 0x80, 0x8d,
-    0xf9, 0x2a, 0x00, 0x08, 0x10, 0x02, 0x80, 0xc1,
-    0x20, 0x08, 0x83, 0x41, 0x5b, 0x83, 0x88, 0x08,
-    0x80, 0xaf, 0x32, 0x82, 0x60, 0x50, 0x0d, 0x00,
-    0xb6, 0x33, 0xdc, 0x81, 0x60, 0x4c, 0xab, 0x80,
-    0x60, 0x23, 0x60, 0x30, 0x90, 0x0e, 0x01, 0x04,
-    0xe3, 0x80, 0x48, 0xb6, 0x80, 0x47, 0xe7, 0x99,
-    0x85, 0x99, 0x85, 0x99,
+    0xb9, 0x30, 0x10, 0x17, 0x81, 0x8a, 0x81, 0x9b,
+    0x83, 0xb9, 0x30, 0x10, 0x82, 0x89, 0x80, 0x89,
+    0x81, 0x9c, 0x82, 0xca, 0x28, 0x00, 0x87, 0x91,
+    0x81, 0xbc, 0x01, 0x86, 0x91, 0x80, 0xe2, 0x01,
+    0x28, 0x81, 0x8f, 0x80, 0x40, 0xa2, 0x90, 0x8a,
+    0x8a, 0x80, 0xa3, 0xed, 0x8b, 0x00, 0x0b, 0x96,
+    0x1b, 0x10, 0x11, 0x32, 0x83, 0x8c, 0x8b, 0x00,
+    0x89, 0x83, 0x46, 0x73, 0x81, 0x9d, 0x81, 0x9d,
+    0x81, 0x9d, 0x81, 0xc1, 0x92, 0x40, 0xbb, 0x81,
+    0xa1, 0x80, 0xf5, 0x8b, 0x83, 0x88, 0x40, 0xdd,
+    0x84, 0xb8, 0x89, 0x81, 0x93, 0xc9, 0x81, 0x8a,
+    0x82, 0xb0, 0x84, 0xaf, 0x8e, 0xbb, 0x82, 0x9d,
+    0x88, 0x09, 0xb8, 0x8a, 0xb1, 0x92, 0x41, 0xaf,
+    0x8d, 0x46, 0xc0, 0xb3, 0x48, 0xf5, 0x9f, 0x60,
+    0x78, 0x73, 0x87, 0xa1, 0x81, 0x41, 0x61, 0x07,
+    0x80, 0x96, 0x84, 0xd7, 0x81, 0xb1, 0x8f, 0x00,
+    0xb8, 0x80, 0xa5, 0x84, 0x9b, 0x8b, 0xac, 0x83,
+    0xaf, 0x8b, 0xa4, 0x80, 0xc2, 0x8d, 0x8b, 0x07,
+    0x81, 0xac, 0x82, 0xb1, 0x00, 0x11, 0x0c, 0x80,
+    0xab, 0x24, 0x80, 0x40, 0xec, 0x87, 0x60, 0x4f,
+    0x32, 0x80, 0x48, 0x56, 0x84, 0x46, 0x85, 0x10,
+    0x0c, 0x83, 0x43, 0x13, 0x83, 0x41, 0x82, 0x81,
+    0x41, 0x52, 0x82, 0xb4, 0x8d, 0xac, 0x81, 0x8c,
+    0x80, 0xac, 0x88, 0x88, 0x80, 0xbc, 0x82, 0xa3,
+    0x8b, 0x91, 0x81, 0xb8, 0x82, 0xaf, 0x8c, 0x8d,
+    0x81, 0xdb, 0x88, 0x08, 0x28, 0x40, 0x9f, 0x89,
+    0x96, 0x83, 0xb9, 0x31, 0x09, 0x81, 0x89, 0x80,
+    0x89, 0x81, 0x40, 0xd0, 0x8c, 0x02, 0xe9, 0x91,
+    0x40, 0xec, 0x31, 0x86, 0x9c, 0x81, 0xd1, 0x8e,
+    0x00, 0xe9, 0x8a, 0xe6, 0x8d, 0x41, 0x00, 0x8c,
+    0x40, 0xf6, 0x28, 0x09, 0x0a, 0x00, 0x80, 0x40,
+    0x8d, 0x31, 0x2b, 0x80, 0x9b, 0x89, 0xa9, 0x20,
+    0x83, 0x91, 0x8a, 0xad, 0x8d, 0x41, 0x96, 0x38,
+    0x86, 0xd2, 0x95, 0x80, 0x8d, 0xf9, 0x2a, 0x00,
+    0x08, 0x10, 0x02, 0x80, 0xc1, 0x20, 0x08, 0x83,
+    0x41, 0x5b, 0x83, 0x60, 0x50, 0x57, 0x00, 0xb6,
+    0x33, 0xdc, 0x81, 0x60, 0x4c, 0xab, 0x80, 0x60,
+    0x23, 0x60, 0x30, 0x90, 0x0e, 0x01, 0x04, 0x49,
+    0x1b, 0x80, 0x47, 0xe7, 0x99, 0x85, 0x99, 0x85,
+    0x99,
 };
 
-static const uint8_t unicode_prop_Other_Lowercase_table[69] = {
+static const uint8_t unicode_prop_Other_Lowercase_table[59] = {
     0x40, 0xa9, 0x80, 0x8e, 0x80, 0x41, 0xf4, 0x88,
-    0x31, 0x9d, 0x84, 0xdf, 0x80, 0xb3, 0x80, 0x4d,
-    0x80, 0x80, 0x4c, 0x2e, 0xbe, 0x8c, 0x80, 0xa1,
-    0xa4, 0x42, 0xb0, 0x80, 0x8c, 0x80, 0x8f, 0x8c,
-    0x40, 0xd2, 0x8f, 0x43, 0x4f, 0x99, 0x47, 0x91,
-    0x81, 0x60, 0x7a, 0x1d, 0x81, 0x40, 0xd1, 0x80,
-    0x40, 0x80, 0x12, 0x81, 0x43, 0x61, 0x83, 0x88,
-    0x80, 0x60, 0x5c, 0x15, 0x01, 0x10, 0xa9, 0x80,
-    0x88, 0x60, 0xd8, 0x74, 0xbd,
+    0x31, 0x9d, 0x84, 0xdf, 0x80, 0xb3, 0x80, 0x59,
+    0xb0, 0xbe, 0x8c, 0x80, 0xa1, 0xa4, 0x42, 0xb0,
+    0x80, 0x8c, 0x80, 0x8f, 0x8c, 0x40, 0xd2, 0x8f,
+    0x43, 0x4f, 0x99, 0x47, 0x91, 0x81, 0x60, 0x7a,
+    0x1d, 0x81, 0x40, 0xd1, 0x80, 0x40, 0x86, 0x81,
+    0x43, 0x61, 0x83, 0x60, 0x5c, 0x1f, 0x01, 0x10,
+    0xa9, 0x80, 0x88,
 };
 
 static const uint8_t unicode_prop_Other_Uppercase_table[15] = {
@@ -3787,7 +3750,7 @@
     0x84,
 };
 
-static const uint8_t unicode_prop_Changes_When_NFKC_Casefolded1_table[451] = {
+static const uint8_t unicode_prop_Changes_When_NFKC_Casefolded1_table[448] = {
     0x40, 0x9f, 0x06, 0x00, 0x01, 0x00, 0x01, 0x12,
     0x10, 0x82, 0x9f, 0x80, 0xcf, 0x01, 0x80, 0x8b,
     0x07, 0x80, 0xfb, 0x01, 0x01, 0x80, 0xa5, 0x80,
@@ -3835,16 +3798,15 @@
     0x08, 0x09, 0x0b, 0x80, 0x8b, 0x00, 0x06, 0x80,
     0xc0, 0x03, 0x0f, 0x06, 0x80, 0x9b, 0x03, 0x04,
     0x00, 0x16, 0x80, 0x41, 0x53, 0x81, 0x41, 0x23,
-    0x81, 0xb1, 0x48, 0x2f, 0xbd, 0x4d, 0x91, 0x18,
-    0x9a, 0x01, 0x00, 0x08, 0x80, 0x89, 0x03, 0x00,
-    0x00, 0x28, 0x18, 0x00, 0x00, 0x02, 0x01, 0x00,
-    0x08, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0b,
-    0x06, 0x03, 0x03, 0x00, 0x80, 0x89, 0x80, 0x90,
-    0x22, 0x04, 0x80, 0x90, 0x42, 0x43, 0x8a, 0x84,
-    0x9e, 0x80, 0x9f, 0x99, 0x82, 0xa2, 0x80, 0xee,
-    0x82, 0x8c, 0xab, 0x83, 0x88, 0x31, 0x49, 0x9d,
-    0x89, 0x60, 0xfc, 0x05, 0x42, 0x1d, 0x6b, 0x05,
-    0xe1, 0x4f, 0xff,
+    0x81, 0xb1, 0x55, 0xff, 0x18, 0x9a, 0x01, 0x00,
+    0x08, 0x80, 0x89, 0x03, 0x00, 0x00, 0x28, 0x18,
+    0x00, 0x00, 0x02, 0x01, 0x00, 0x08, 0x00, 0x00,
+    0x00, 0x00, 0x01, 0x00, 0x0b, 0x06, 0x03, 0x03,
+    0x00, 0x80, 0x89, 0x80, 0x90, 0x22, 0x04, 0x80,
+    0x90, 0x42, 0x43, 0x8a, 0x84, 0x9e, 0x80, 0x9f,
+    0x99, 0x82, 0xa2, 0x80, 0xee, 0x82, 0x8c, 0xab,
+    0x83, 0x88, 0x31, 0x49, 0x9d, 0x89, 0x60, 0xfc,
+    0x05, 0x42, 0x1d, 0x6b, 0x05, 0xe1, 0x4f, 0xff,
 };
 
 static const uint8_t unicode_prop_ASCII_Hex_Digit_table[5] = {
@@ -3872,7 +3834,7 @@
     0x42, 0xb8, 0x81, 0x6d, 0xdc, 0xd5, 0x80,
 };
 
-static const uint8_t unicode_prop_Diacritic_table[399] = {
+static const uint8_t unicode_prop_Diacritic_table[391] = {
     0xdd, 0x00, 0x80, 0xc6, 0x05, 0x03, 0x01, 0x81,
     0x41, 0xf6, 0x40, 0x9e, 0x07, 0x25, 0x90, 0x0b,
     0x80, 0x88, 0x81, 0x40, 0xfc, 0x84, 0x40, 0xd0,
@@ -3907,21 +3869,20 @@
     0x00, 0x8f, 0x41, 0x0d, 0x00, 0x80, 0xae, 0x80,
     0xac, 0x81, 0xc2, 0x80, 0x42, 0xfb, 0x80, 0x44,
     0x9e, 0x28, 0xa9, 0x80, 0x88, 0x43, 0x29, 0x81,
-    0x42, 0x3a, 0x85, 0x41, 0xd4, 0x82, 0xc5, 0x8a,
-    0xb0, 0x83, 0x40, 0xbf, 0x80, 0xa8, 0x80, 0xc7,
-    0x81, 0xf7, 0x81, 0xbd, 0x80, 0xcb, 0x80, 0x88,
-    0x82, 0xe7, 0x81, 0x40, 0xb1, 0x81, 0xd0, 0x80,
-    0x8f, 0x80, 0x97, 0x32, 0x84, 0x40, 0xcc, 0x02,
-    0x80, 0xfa, 0x81, 0x40, 0xfa, 0x81, 0xfd, 0x80,
-    0xf5, 0x81, 0xf2, 0x80, 0x41, 0x0c, 0x81, 0x41,
-    0x01, 0x0b, 0x80, 0x40, 0x9b, 0x80, 0xd2, 0x80,
-    0x91, 0x80, 0xd0, 0x80, 0x41, 0xa4, 0x80, 0x41,
-    0x01, 0x00, 0x81, 0xd0, 0x80, 0x56, 0xae, 0x8e,
-    0x60, 0x36, 0x99, 0x84, 0xba, 0x86, 0x44, 0x57,
-    0x90, 0xcf, 0x81, 0x60, 0x3f, 0xfd, 0x18, 0x30,
-    0x81, 0x5f, 0x00, 0xad, 0x81, 0x96, 0x42, 0x1f,
-    0x12, 0x2f, 0x39, 0x86, 0x9d, 0x83, 0x4e, 0x81,
-    0xbd, 0x40, 0xc1, 0x86, 0x41, 0x76, 0x80, 0xbc,
+    0x42, 0x3a, 0x85, 0x42, 0x1d, 0x8a, 0xb0, 0x83,
+    0x40, 0xbf, 0x80, 0xa8, 0x80, 0xc7, 0x81, 0xf7,
+    0x81, 0xbd, 0x80, 0xcb, 0x80, 0x88, 0x82, 0xe7,
+    0x81, 0x40, 0xb1, 0x81, 0xd0, 0x80, 0x8f, 0x80,
+    0x97, 0x32, 0x84, 0x40, 0xcc, 0x02, 0x80, 0xfa,
+    0x81, 0x40, 0xfa, 0x81, 0xfd, 0x80, 0xf5, 0x81,
+    0xf2, 0x80, 0x41, 0x0c, 0x81, 0x41, 0x01, 0x0b,
+    0x80, 0x40, 0x9b, 0x80, 0xd2, 0x80, 0x91, 0x80,
+    0xd0, 0x80, 0x41, 0xa4, 0x80, 0x41, 0x01, 0x00,
+    0x81, 0xd0, 0x80, 0x60, 0x4d, 0x57, 0x84, 0xba,
+    0x86, 0x44, 0x57, 0x90, 0xcf, 0x81, 0x60, 0x3f,
+    0xfd, 0x18, 0x30, 0x81, 0x5f, 0x00, 0xad, 0x81,
+    0x96, 0x42, 0x1f, 0x12, 0x2f, 0x39, 0x86, 0x9d,
+    0x83, 0x4f, 0x81, 0x86, 0x41, 0x76, 0x80, 0xbc,
     0x83, 0x45, 0xdf, 0x86, 0xec, 0x10, 0x82,
 };
 
@@ -3953,16 +3914,16 @@
     0x60, 0x2f, 0xf1, 0x81,
 };
 
-static const uint8_t unicode_prop_Ideographic_table[69] = {
+static const uint8_t unicode_prop_Ideographic_table[66] = {
     0x60, 0x30, 0x05, 0x81, 0x98, 0x88, 0x8d, 0x82,
     0x43, 0xc4, 0x59, 0xbf, 0xbf, 0x60, 0x51, 0xff,
     0x60, 0x58, 0xff, 0x41, 0x6d, 0x81, 0xe9, 0x60,
     0x75, 0x09, 0x80, 0x9a, 0x57, 0xf7, 0x87, 0x44,
     0xd5, 0xa9, 0x88, 0x60, 0x24, 0x66, 0x41, 0x8b,
     0x60, 0x4d, 0x03, 0x60, 0xa6, 0xdf, 0x9f, 0x50,
-    0x39, 0x85, 0x40, 0xdd, 0x81, 0x56, 0x81, 0x8d,
+    0x38, 0x86, 0x40, 0xdd, 0x81, 0x56, 0x81, 0x8d,
     0x5d, 0x30, 0x4c, 0x1e, 0x42, 0x1d, 0x45, 0xe1,
-    0x53, 0x4a, 0x84, 0x50, 0x5f,
+    0x53, 0x4a,
 };
 
 static const uint8_t unicode_prop_Join_Control_table[4] = {
@@ -4018,7 +3979,7 @@
     0x61, 0xf1, 0xe5, 0x99,
 };
 
-static const uint8_t unicode_prop_Sentence_Terminal_table[196] = {
+static const uint8_t unicode_prop_Sentence_Terminal_table[194] = {
     0xa0, 0x80, 0x8b, 0x80, 0x8f, 0x80, 0x45, 0x48,
     0x80, 0x40, 0x92, 0x82, 0x40, 0xb3, 0x80, 0xaa,
     0x82, 0x40, 0xf5, 0x80, 0xbc, 0x00, 0x02, 0x81,
@@ -4040,13 +4001,13 @@
     0xeb, 0x80, 0x41, 0xa0, 0x81, 0x41, 0x74, 0x0c,
     0x8e, 0xe8, 0x81, 0x40, 0xf8, 0x82, 0x42, 0x04,
     0x00, 0x80, 0x40, 0xfa, 0x81, 0xd6, 0x81, 0x41,
-    0xa3, 0x81, 0x42, 0xb3, 0x81, 0xc9, 0x81, 0x60,
-    0x4b, 0x28, 0x81, 0x40, 0x84, 0x80, 0xc0, 0x81,
-    0x8a, 0x80, 0x43, 0x52, 0x80, 0x60, 0x4e, 0x05,
-    0x80, 0x5d, 0xe7, 0x80,
+    0xa3, 0x81, 0x42, 0xb3, 0x81, 0x60, 0x4b, 0x74,
+    0x81, 0x40, 0x84, 0x80, 0xc0, 0x81, 0x8a, 0x80,
+    0x43, 0x52, 0x80, 0x60, 0x4e, 0x05, 0x80, 0x5d,
+    0xe7, 0x80,
 };
 
-static const uint8_t unicode_prop_Soft_Dotted_table[79] = {
+static const uint8_t unicode_prop_Soft_Dotted_table[74] = {
     0xe8, 0x81, 0x40, 0xc3, 0x80, 0x41, 0x18, 0x80,
     0x9d, 0x80, 0xb3, 0x80, 0x93, 0x80, 0x41, 0x3f,
     0x80, 0xe1, 0x00, 0x80, 0x59, 0x08, 0x80, 0xb2,
@@ -4056,10 +4017,10 @@
     0x81, 0xb1, 0x81, 0xb1, 0x81, 0xb1, 0x81, 0xb1,
     0x81, 0xb1, 0x81, 0xb1, 0x81, 0xb1, 0x81, 0xb1,
     0x81, 0xb1, 0x81, 0xb1, 0x81, 0xb1, 0x81, 0x48,
-    0x85, 0x80, 0x41, 0x30, 0x81, 0x99, 0x80,
+    0x85, 0x80,
 };
 
-static const uint8_t unicode_prop_Terminal_Punctuation_table[248] = {
+static const uint8_t unicode_prop_Terminal_Punctuation_table[246] = {
     0xa0, 0x80, 0x89, 0x00, 0x80, 0x8a, 0x0a, 0x80,
     0x43, 0x3d, 0x07, 0x80, 0x42, 0x00, 0x80, 0xb8,
     0x80, 0xc7, 0x80, 0x8d, 0x00, 0x82, 0x40, 0xb3,
@@ -4087,19 +4048,19 @@
     0x82, 0x8b, 0x81, 0x41, 0x65, 0x1a, 0x8e, 0xe8,
     0x81, 0x40, 0xf8, 0x82, 0x42, 0x04, 0x00, 0x80,
     0x40, 0xfa, 0x81, 0xd6, 0x0b, 0x81, 0x41, 0x9d,
-    0x82, 0xac, 0x80, 0x42, 0x84, 0x81, 0xc9, 0x81,
-    0x45, 0x2a, 0x84, 0x60, 0x45, 0xf8, 0x81, 0x40,
-    0x84, 0x80, 0xc0, 0x82, 0x89, 0x80, 0x43, 0x51,
-    0x81, 0x60, 0x4e, 0x05, 0x80, 0x5d, 0xe6, 0x83,
+    0x82, 0xac, 0x80, 0x42, 0x84, 0x81, 0x45, 0x76,
+    0x84, 0x60, 0x45, 0xf8, 0x81, 0x40, 0x84, 0x80,
+    0xc0, 0x82, 0x89, 0x80, 0x43, 0x51, 0x81, 0x60,
+    0x4e, 0x05, 0x80, 0x5d, 0xe6, 0x83,
 };
 
-static const uint8_t unicode_prop_Unified_Ideograph_table[45] = {
+static const uint8_t unicode_prop_Unified_Ideograph_table[42] = {
     0x60, 0x33, 0xff, 0x59, 0xbf, 0xbf, 0x60, 0x51,
     0xff, 0x60, 0x5a, 0x0d, 0x08, 0x00, 0x81, 0x89,
     0x00, 0x00, 0x09, 0x82, 0x61, 0x05, 0xd5, 0x60,
-    0xa6, 0xdf, 0x9f, 0x50, 0x39, 0x85, 0x40, 0xdd,
+    0xa6, 0xdf, 0x9f, 0x50, 0x38, 0x86, 0x40, 0xdd,
     0x81, 0x56, 0x81, 0x8d, 0x5d, 0x30, 0x54, 0x1e,
-    0x53, 0x4a, 0x84, 0x50, 0x5f,
+    0x53, 0x4a,
 };
 
 static const uint8_t unicode_prop_Variation_Selector_table[13] = {
@@ -4164,11 +4125,11 @@
     0xbe, 0x8a, 0x28, 0x97, 0x31, 0x0f, 0x8b, 0x01,
     0x19, 0x03, 0x81, 0x8c, 0x09, 0x07, 0x81, 0x88,
     0x04, 0x82, 0x8b, 0x17, 0x11, 0x00, 0x03, 0x05,
-    0x02, 0x05, 0xd5, 0xaf, 0xc5, 0x27, 0x0a, 0x83,
-    0x89, 0x10, 0x01, 0x10, 0x81, 0x89, 0x40, 0xe2,
+    0x02, 0x05, 0xd5, 0xaf, 0xc5, 0x27, 0x0a, 0x84,
+    0x88, 0x10, 0x01, 0x10, 0x81, 0x89, 0x40, 0xe2,
     0x8b, 0x18, 0x41, 0x1a, 0xae, 0x80, 0x89, 0x80,
-    0x40, 0xb8, 0xef, 0x8c, 0x82, 0x88, 0x86, 0xad,
-    0x06, 0x87, 0x8d, 0x83, 0x88, 0x86, 0x88,
+    0x40, 0xb8, 0xef, 0x22, 0x22, 0x86, 0x88, 0x9c,
+    0x82, 0x8a, 0x25, 0x89, 0x89, 0x2f, 0x3e,
 };
 
 static const uint8_t unicode_prop_Emoji_Component_table[28] = {
@@ -4191,7 +4152,7 @@
     0xd2, 0x80, 0x8f, 0x82, 0x88, 0x80, 0x8a, 0x80,
     0x42, 0x3e, 0x01, 0x07, 0x3d, 0x80, 0x88, 0x89,
     0x0a, 0xb7, 0x80, 0xbc, 0x08, 0x08, 0x80, 0x90,
-    0x10, 0x8c, 0x40, 0xe4, 0x82, 0xa9, 0x88,
+    0x10, 0x8c, 0x40, 0xe4, 0x82, 0xa9, 0x86,
 };
 
 static const uint8_t unicode_prop_Emoji_Presentation_table[145] = {
@@ -4209,11 +4170,11 @@
     0x1c, 0x8b, 0x90, 0x10, 0x82, 0xc6, 0x00, 0x80,
     0x40, 0xba, 0x81, 0xbe, 0x8c, 0x18, 0x97, 0x91,
     0x80, 0x99, 0x81, 0x8c, 0x80, 0xd5, 0xd4, 0xaf,
-    0xc5, 0x28, 0x12, 0x0a, 0x1b, 0x8a, 0x0e, 0x88,
+    0xc5, 0x28, 0x12, 0x0a, 0x22, 0x8a, 0x0e, 0x88,
     0x40, 0xe2, 0x8b, 0x18, 0x41, 0x1a, 0xae, 0x80,
-    0x89, 0x80, 0x40, 0xb8, 0xef, 0x8c, 0x82, 0x88,
-    0x86, 0xad, 0x06, 0x87, 0x8d, 0x83, 0x88, 0x86,
-    0x88,
+    0x89, 0x80, 0x40, 0xb8, 0xef, 0x22, 0x22, 0x86,
+    0x88, 0x9c, 0x82, 0x8a, 0x25, 0x89, 0x89, 0x2f,
+    0x3e,
 };
 
 static const uint8_t unicode_prop_Extended_Pictographic_table[156] = {
Index: quickjs-src/quickjs/cutils.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/cutils.h b/quickjs-src/quickjs/src/cutils.h
rename from quickjs-src/quickjs/cutils.h
rename to quickjs-src/quickjs/src/cutils.h
--- a/quickjs-src/quickjs/cutils.h	(revision 321dbfa770463b8867d8ac90493c7cec015a9c3a)
+++ b/quickjs-src/quickjs/src/cutils.h	(date 1696647929597)
@@ -25,17 +25,18 @@
 #ifndef CUTILS_H
 #define CUTILS_H
 
+#include "quickjs-defs.h"
 #include <stdlib.h>
 #include <inttypes.h>
 
 /* set if CPU is big endian */
 #undef WORDS_BIGENDIAN
 
-#define likely(x)       __builtin_expect(!!(x), 1)
-#define unlikely(x)     __builtin_expect(!!(x), 0)
-#define force_inline inline __attribute__((always_inline))
-#define no_inline __attribute__((noinline))
-#define __maybe_unused __attribute__((unused))
+#define likely(x)       PLATFORM_LIKELY(x)
+#define unlikely(x)     PLATFORM_UNLIKELY(x)
+#define force_inline    PLATFORM_FORCE_INLINE
+#define no_inline       PLATFORM_NO_INLINE
+#define __maybe_unused  PLATFORM_MAYBE_UNUSED
 
 #define xglue(x, y) x ## y
 #define glue(x, y) xglue(x, y)
@@ -114,27 +115,65 @@
 /* WARNING: undefined if a = 0 */
 static inline int clz32(unsigned int a)
 {
+#if defined(PLATFORM_GNUC_LIKE)
     return __builtin_clz(a);
+#else
+    unsigned long idx;
+    _BitScanReverse(&idx, a);
+    return 31 ^ idx;
+#endif
 }
 
 /* WARNING: undefined if a = 0 */
 static inline int clz64(uint64_t a)
 {
+#if defined(PLATFORM_GNUC_LIKE)
     return __builtin_clzll(a);
+#else
+    unsigned long idx;
+#  if defined(_WIN64)
+    _BitScanReverse64(&idx, a);
+#  else
+    if (_BitScanReverse(&idx, (uint32_t)(a >> 32)))
+        return 63 ^ (idx + 32);
+    _BitScanReverse(&idx, (uint32_t)(a));
+#  endif
+    return 63 ^ idx;
+#endif
 }
 
 /* WARNING: undefined if a = 0 */
 static inline int ctz32(unsigned int a)
 {
+#if defined(PLATFORM_GNUC_LIKE)
     return __builtin_ctz(a);
+#else
+    unsigned long idx;
+    _BitScanForward(&idx, a);
+    return idx;
+#endif
 }
 
 /* WARNING: undefined if a = 0 */
 static inline int ctz64(uint64_t a)
 {
+#if defined(PLATFORM_GNUC_LIKE)
     return __builtin_ctzll(a);
+#else
+    unsigned long idx;
+#  if defined(_WIN64)
+    _BitScanForward64(&idx, a);
+    return idx;
+#  else
+    if (_BitScanForward(&idx, (uint32_t)(a)))
+        return idx;
+    _BitScanForward(&idx, (uint32_t)(a >> 32));
+    return idx + 32;
+#  endif
+#endif
 }
 
+#if defined(PLATFORM_GNUC_LIKE)
 struct __attribute__((packed)) packed_u64 {
     uint64_t v;
 };
@@ -146,6 +185,21 @@
 struct __attribute__((packed)) packed_u16 {
     uint16_t v;
 };
+#else
+#pragma pack(push, 1)
+struct packed_u64 {
+    uint64_t v;
+};
+
+struct packed_u32 {
+    uint32_t v;
+};
+
+struct packed_u16 {
+    uint16_t v;
+};
+#pragma pack(pop)
+#endif
 
 static inline uint64_t get_u64(const uint8_t *tab)
 {
@@ -262,8 +316,7 @@
 {
     return dbuf_put(s, (uint8_t *)&val, 8);
 }
-int __attribute__((format(printf, 2, 3))) dbuf_printf(DynBuf *s,
-                                                      const char *fmt, ...);
+int PLATFORM_PRINTF_LIKE(2, 3) dbuf_printf(DynBuf *s, const char *fmt, ...);
 void dbuf_free(DynBuf *s);
 static inline BOOL dbuf_error(DynBuf *s) {
     return s->error;
Index: quickjs-src/quickjs/libbf.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/libbf.c b/quickjs-src/quickjs/src/libbf.c
rename from quickjs-src/quickjs/libbf.c
rename to quickjs-src/quickjs/src/libbf.c
--- a/quickjs-src/quickjs/libbf.c	(revision 321dbfa770463b8867d8ac90493c7cec015a9c3a)
+++ b/quickjs-src/quickjs/src/libbf.c	(date 1696647929597)
@@ -37,12 +37,10 @@
 
 /* enable it to check the multiplication result */
 //#define USE_MUL_CHECK
-#ifdef CONFIG_BIGNUM
 /* enable it to use FFT/NTT multiplication */
 #define USE_FFT_MUL
 /* enable decimal floating point support */
 #define USE_BF_DEC
-#endif
 
 //#define inline __attribute__((always_inline))
 
@@ -166,21 +164,6 @@
     return r;
 }
 
-static inline __maybe_unused limb_t shrd(limb_t low, limb_t high, long shift)
-{
-    if (shift != 0)
-        low = (low >> shift) | (high << (LIMB_BITS - shift));
-    return low;
-}
-
-static inline __maybe_unused limb_t shld(limb_t a1, limb_t a0, long shift)
-{
-    if (shift != 0)
-        return (a1 << shift) | (a0 >> (LIMB_BITS - shift));
-    else
-        return a1;
-}
-
 #define malloc(s) malloc_is_forbidden(s)
 #define free(p) free_is_forbidden(p)
 #define realloc(p, s) realloc_is_forbidden(p, s)
@@ -253,7 +236,7 @@
         a1 = a >> 32;
         shift = clz(a1);
         r->tab[0] = a0 << shift;
-        r->tab[1] = shld(a1, a0, shift);
+        r->tab[1] = (a1 << shift) | (a0 >> (LIMB_BITS - shift));
         r->expn = 2 * LIMB_BITS - shift;
     }
 #endif
@@ -1602,9 +1585,7 @@
                 r = &tmp;
             }
             if (bf_resize(r, a_len + b_len)) {
-#ifdef USE_FFT_MUL
             fail:
-#endif                
                 bf_set_nan(r);
                 ret = BF_ST_MEM_ERROR;
                 goto done;
@@ -2301,14 +2282,11 @@
     bf_t a;
     int ret;
     
-#ifdef USE_BF_DEC
     if (a1 == 10 && b <= LIMB_DIGITS) {
         /* use precomputed powers. We do not round at this point
            because we expect the caller to do it */
         ret = bf_set_ui(r, mp_pow_dec[b]);
-    } else
-#endif        
-    {
+    } else {
         bf_init(r->ctx, &a);
         ret = bf_set_ui(&a, a1);
         ret |= bf_pow_ui(r, &a, b, prec, flags);
@@ -5414,6 +5392,21 @@
 
 #endif /* LIMB_BITS != 64 */
 
+static inline __maybe_unused limb_t shrd(limb_t low, limb_t high, long shift)
+{
+    if (shift != 0)
+        low = (low >> shift) | (high << (LIMB_BITS - shift));
+    return low;
+}
+
+static inline __maybe_unused limb_t shld(limb_t a1, limb_t a0, long shift)
+{
+    if (shift != 0)
+        return (a1 << shift) | (a0 >> (LIMB_BITS - shift));
+    else
+        return a1;
+}
+
 #if LIMB_DIGITS == 19
 
 /* WARNING: hardcoded for b = 1e19. It is assumed that:
Index: quickjs-src/quickjs/src/list.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/src/list.h b/quickjs-src/quickjs/src/list.h
new file mode 100644
--- /dev/null	(date 1696647929599)
+++ b/quickjs-src/quickjs/src/list.h	(date 1696647929599)
@@ -0,0 +1,100 @@
+/*
+ * Linux klist like system
+ * 
+ * Copyright (c) 2016-2017 Fabrice Bellard
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+#ifndef LIST_H
+#define LIST_H
+
+#ifndef NULL
+#include <stddef.h>
+#endif
+
+struct list_head {
+    struct list_head *prev;
+    struct list_head *next;
+};
+
+#define LIST_HEAD_INIT(el) { &(el), &(el) }
+
+/* return the pointer of type 'type *' containing 'el' as field 'member' */
+#define list_entry(el, type, member) \
+    ((type *)((uint8_t *)(el) - offsetof(type, member)))
+
+static inline void init_list_head(struct list_head *head)
+{
+    head->prev = head;
+    head->next = head;
+}
+
+/* insert 'el' between 'prev' and 'next' */
+static inline void __list_add(struct list_head *el, 
+                              struct list_head *prev, struct list_head *next)
+{
+    prev->next = el;
+    el->prev = prev;
+    el->next = next;
+    next->prev = el;
+}
+
+/* add 'el' at the head of the list 'head' (= after element head) */
+static inline void list_add(struct list_head *el, struct list_head *head)
+{
+    __list_add(el, head, head->next);
+}
+
+/* add 'el' at the end of the list 'head' (= before element head) */
+static inline void list_add_tail(struct list_head *el, struct list_head *head)
+{
+    __list_add(el, head->prev, head);
+}
+
+static inline void list_del(struct list_head *el)
+{
+    struct list_head *prev, *next;
+    prev = el->prev;
+    next = el->next;
+    prev->next = next;
+    next->prev = prev;
+    el->prev = NULL; /* fail safe */
+    el->next = NULL; /* fail safe */
+}
+
+static inline int list_empty(struct list_head *el)
+{
+    return el->next == el;
+}
+
+#define list_for_each(el, head) \
+  for(el = (head)->next; el != (head); el = el->next)
+
+#define list_for_each_safe(el, el1, head)                \
+    for(el = (head)->next, el1 = el->next; el != (head); \
+        el = el1, el1 = el->next)
+
+#define list_for_each_prev(el, head) \
+  for(el = (head)->prev; el != (head); el = el->prev)
+
+#define list_for_each_prev_safe(el, el1, head)           \
+    for(el = (head)->prev, el1 = el->prev; el != (head); \
+        el = el1, el1 = el->prev)
+
+#endif /* LIST_H */
Index: quickjs-src/quickjs/cutils.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/cutils.c b/quickjs-src/quickjs/src/cutils.c
rename from quickjs-src/quickjs/cutils.c
rename to quickjs-src/quickjs/src/cutils.c
--- a/quickjs-src/quickjs/cutils.c	(revision 321dbfa770463b8867d8ac90493c7cec015a9c3a)
+++ b/quickjs-src/quickjs/src/cutils.c	(date 1696647929596)
@@ -166,8 +166,7 @@
     return dbuf_put(s, (const uint8_t *)str, strlen(str));
 }
 
-int __attribute__((format(printf, 2, 3))) dbuf_printf(DynBuf *s,
-                                                      const char *fmt, ...)
+int PLATFORM_PRINTF_LIKE(2, 3) dbuf_printf(DynBuf *s, const char *fmt, ...)
 {
     va_list ap;
     char buf[128];
Index: quickjs-src/quickjs/src/libunicode.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/src/libunicode.h b/quickjs-src/quickjs/src/libunicode.h
new file mode 100644
--- /dev/null	(date 1696647929599)
+++ b/quickjs-src/quickjs/src/libunicode.h	(date 1696647929599)
@@ -0,0 +1,124 @@
+/*
+ * Unicode utilities
+ * 
+ * Copyright (c) 2017-2018 Fabrice Bellard
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+#ifndef LIBUNICODE_H
+#define LIBUNICODE_H
+
+#include <inttypes.h>
+
+#define LRE_BOOL  int       /* for documentation purposes */
+
+/* define it to include all the unicode tables (40KB larger) */
+#define CONFIG_ALL_UNICODE
+
+#define LRE_CC_RES_LEN_MAX 3
+
+typedef enum {
+    UNICODE_NFC,
+    UNICODE_NFD,
+    UNICODE_NFKC,
+    UNICODE_NFKD,
+} UnicodeNormalizationEnum;
+
+int lre_case_conv(uint32_t *res, uint32_t c, int conv_type);
+LRE_BOOL lre_is_cased(uint32_t c);
+LRE_BOOL lre_is_case_ignorable(uint32_t c);
+
+/* char ranges */
+
+typedef struct {
+    int len; /* in points, always even */
+    int size;
+    uint32_t *points; /* points sorted by increasing value */
+    void *mem_opaque;
+    void *(*realloc_func)(void *opaque, void *ptr, size_t size);
+} CharRange;
+
+typedef enum {
+    CR_OP_UNION,
+    CR_OP_INTER,
+    CR_OP_XOR,
+} CharRangeOpEnum;
+
+void cr_init(CharRange *cr, void *mem_opaque, void *(*realloc_func)(void *opaque, void *ptr, size_t size));
+void cr_free(CharRange *cr);
+int cr_realloc(CharRange *cr, int size);
+int cr_copy(CharRange *cr, const CharRange *cr1);
+
+static inline int cr_add_point(CharRange *cr, uint32_t v)
+{
+    if (cr->len >= cr->size) {
+        if (cr_realloc(cr, cr->len + 1))
+            return -1;
+    }
+    cr->points[cr->len++] = v;
+    return 0;
+}
+
+static inline int cr_add_interval(CharRange *cr, uint32_t c1, uint32_t c2)
+{
+    if ((cr->len + 2) > cr->size) {
+        if (cr_realloc(cr, cr->len + 2))
+            return -1;
+    }
+    cr->points[cr->len++] = c1;
+    cr->points[cr->len++] = c2;
+    return 0;
+}
+
+int cr_union1(CharRange *cr, const uint32_t *b_pt, int b_len);
+
+static inline int cr_union_interval(CharRange *cr, uint32_t c1, uint32_t c2)
+{
+    uint32_t b_pt[2];
+    b_pt[0] = c1;
+    b_pt[1] = c2 + 1;
+    return cr_union1(cr, b_pt, 2);
+}
+
+int cr_op(CharRange *cr, const uint32_t *a_pt, int a_len,
+          const uint32_t *b_pt, int b_len, int op);
+
+int cr_invert(CharRange *cr);
+
+#ifdef CONFIG_ALL_UNICODE
+
+LRE_BOOL lre_is_id_start(uint32_t c);
+LRE_BOOL lre_is_id_continue(uint32_t c);
+
+int unicode_normalize(uint32_t **pdst, const uint32_t *src, int src_len,
+                      UnicodeNormalizationEnum n_type,
+                      void *opaque, void *(*realloc_func)(void *opaque, void *ptr, size_t size));
+
+/* Unicode character range functions */
+
+int unicode_script(CharRange *cr,
+                   const char *script_name, LRE_BOOL is_ext);
+int unicode_general_category(CharRange *cr, const char *gc_name);
+int unicode_prop(CharRange *cr, const char *prop_name);
+
+#endif /* CONFIG_ALL_UNICODE */
+
+#undef LRE_BOOL
+
+#endif /* LIBUNICODE_H */
Index: rdkit-src/rdkit/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/.gitignore b/rdkit-src/rdkit/.gitignore
--- a/rdkit-src/rdkit/.gitignore	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/.gitignore	(date 1701856733722)
@@ -39,7 +39,6 @@
 
 /Code/RDBoost/test.h
 /Code/RDGeneral/RDConfig.h
-/Code/RDGeneral/export.h
 /Code/RDGeneral/test.h
 /Code/RDGeneral/versions.h
 /Code/RDGeneral/versions.cpp
Index: quickjs-src/quickjs/quickjs.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/quickjs.c b/quickjs-src/quickjs/src/quickjs.c
rename from quickjs-src/quickjs/quickjs.c
rename to quickjs-src/quickjs/src/quickjs.c
--- a/quickjs-src/quickjs/quickjs.c	(revision 321dbfa770463b8867d8ac90493c7cec015a9c3a)
+++ b/quickjs-src/quickjs/src/quickjs.c	(date 1696647929605)
@@ -22,13 +22,13 @@
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  * THE SOFTWARE.
  */
+#include "quickjs-defs.h"
 #include <stdlib.h>
 #include <stdio.h>
 #include <stdarg.h>
 #include <inttypes.h>
 #include <string.h>
 #include <assert.h>
-#include <sys/time.h>
 #include <time.h>
 #include <fenv.h>
 #include <math.h>
@@ -36,21 +36,27 @@
 #include <malloc/malloc.h>
 #elif defined(__linux__)
 #include <malloc.h>
-#elif defined(__FreeBSD__)
-#include <malloc_np.h>
+#endif
+
+#if defined(PLATFORM_IS_WINDOWS)
+# include <windows.h>
+#else
+# include <sys/time.h>
 #endif
 
 #include "cutils.h"
 #include "list.h"
 #include "quickjs.h"
 #include "libregexp.h"
+#ifdef CONFIG_BIGNUM
 #include "libbf.h"
+#endif
 
 #define OPTIMIZE         1
 #define SHORT_OPCODES    1
 #if defined(EMSCRIPTEN)
 #define DIRECT_DISPATCH  0
-#else
+#elif defined(PLATFORM_GNUC_LIKE)
 #define DIRECT_DISPATCH  1
 #endif
 
@@ -67,11 +73,11 @@
 
 /* define to include Atomics.* operations which depend on the OS
    threads */
-#if !defined(EMSCRIPTEN)
+#if !defined(EMSCRIPTEN) && !defined(_WIN32)
 #define CONFIG_ATOMICS
 #endif
 
-#if !defined(EMSCRIPTEN)
+#if !defined(EMSCRIPTEN) && !_MSC_VER && 0
 /* enable stack limitation */
 #define CONFIG_STACK_CHECK
 #endif
@@ -142,13 +148,15 @@
     JS_CLASS_UINT16_ARRAY,      /* u.array (typed_array) */
     JS_CLASS_INT32_ARRAY,       /* u.array (typed_array) */
     JS_CLASS_UINT32_ARRAY,      /* u.array (typed_array) */
+#ifdef CONFIG_BIGNUM
     JS_CLASS_BIG_INT64_ARRAY,   /* u.array (typed_array) */
     JS_CLASS_BIG_UINT64_ARRAY,  /* u.array (typed_array) */
+#endif
     JS_CLASS_FLOAT32_ARRAY,     /* u.array (typed_array) */
     JS_CLASS_FLOAT64_ARRAY,     /* u.array (typed_array) */
     JS_CLASS_DATAVIEW,          /* u.typed_array */
-    JS_CLASS_BIG_INT,           /* u.object_data */
 #ifdef CONFIG_BIGNUM
+    JS_CLASS_BIG_INT,           /* u.object_data */
     JS_CLASS_BIG_FLOAT,         /* u.object_data */
     JS_CLASS_FLOAT_ENV,         /* u.float_env */
     JS_CLASS_BIG_DECIMAL,       /* u.object_data */
@@ -200,7 +208,7 @@
 #define JS_STACK_SIZE_MAX 65534
 #define JS_STRING_LEN_MAX ((1 << 30) - 1)
 
-#define __exception __attribute__((warn_unused_result))
+#define __exception PLATFORM_WARN_UNUSED
 
 typedef struct JSShape JSShape;
 typedef struct JSString JSString;
@@ -214,6 +222,7 @@
 
 typedef enum OPCodeEnum OPCodeEnum;
 
+#ifdef CONFIG_BIGNUM
 /* function pointers are used for numeric operations so that it is
    possible to remove some numeric types */
 typedef struct {
@@ -231,6 +240,7 @@
                                     int64_t exponent);
     int (*mul_pow10)(JSContext *ctx, JSValue *sp);
 } JSNumericOperations;
+#endif
 
 struct JSRuntime {
     JSMallocFunctions mf;
@@ -264,7 +274,7 @@
     uintptr_t stack_size; /* in bytes, 0 if no limit */
     uintptr_t stack_top;
     uintptr_t stack_limit; /* lower stack limit */
-    
+
     JSValue current_exception;
     /* true if inside an out of memory error, to avoid recursing */
     BOOL in_out_of_memory : 8;
@@ -276,7 +286,9 @@
 
     JSHostPromiseRejectionTracker *host_promise_rejection_tracker;
     void *host_promise_rejection_tracker_opaque;
-    
+    JSHostPromiseRejectionTracker *host_unhandled_promise_rejection_tracker;
+    void *host_unhandled_promise_rejection_tracker_opaque;
+
     struct list_head job_list; /* list of JSJobEntry.link */
 
     JSModuleNormalizeFunc *module_normalize_func;
@@ -292,9 +304,9 @@
     int shape_hash_size;
     int shape_hash_count; /* number of hashed shapes */
     JSShape **shape_hash;
+#ifdef CONFIG_BIGNUM
     bf_context_t bf_ctx;
     JSNumericOperations bigint_ops;
-#ifdef CONFIG_BIGNUM
     JSNumericOperations bigfloat_ops;
     JSNumericOperations bigdecimal_ops;
     uint32_t operator_count;
@@ -374,13 +386,6 @@
     JSValue value; /* used when the variable is no longer on the stack */
 } JSVarRef;
 
-/* the same structure is used for big integers and big floats. Big
-   integers are never infinite or NaNs */
-typedef struct JSBigFloat {
-    JSRefCountHeader header; /* must come first, 32-bit */
-    bf_t num;
-} JSBigFloat;
-
 #ifdef CONFIG_BIGNUM
 typedef struct JSFloatEnv {
     limb_t prec;
@@ -388,6 +393,13 @@
     unsigned int status;
 } JSFloatEnv;
 
+/* the same structure is used for big integers and big floats. Big
+   integers are never infinite or NaNs */
+typedef struct JSBigFloat {
+    JSRefCountHeader header; /* must come first, 32-bit */
+    bf_t num;
+} JSBigFloat;
+
 typedef struct JSBigDecimal {
     JSRefCountHeader header; /* must come first, 32-bit */
     bfdec_t num;
@@ -431,8 +443,8 @@
     JSValue global_var_obj; /* contains the global let/const definitions */
 
     uint64_t random_state;
-    bf_context_t *bf_ctx;   /* points to rt->bf_ctx, shared by all contexts */
 #ifdef CONFIG_BIGNUM
+    bf_context_t *bf_ctx;   /* points to rt->bf_ctx, shared by all contexts */
     JSFloatEnv fp_env; /* global FP environment */
     BOOL bignum_ext : 8; /* enable math mode */
     BOOL allow_operator_overloading : 8;
@@ -1015,7 +1027,7 @@
                                             JSValue val, BOOL is_array_ctor);
 static JSValue JS_EvalObject(JSContext *ctx, JSValueConst this_obj,
                              JSValueConst val, int flags, int scope_idx);
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...);
+JSValue PLATFORM_PRINTF_LIKE(2, 3) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...);
 static __maybe_unused void JS_DumpAtoms(JSRuntime *rt);
 static __maybe_unused void JS_DumpString(JSRuntime *rt,
                                                   const JSString *p);
@@ -1111,18 +1123,6 @@
 static JSValue JS_ToObjectFree(JSContext *ctx, JSValue val);
 static JSProperty *add_property(JSContext *ctx,
                                 JSObject *p, JSAtom prop, int prop_flags);
-static JSValue JS_NewBigInt(JSContext *ctx);
-static inline bf_t *JS_GetBigInt(JSValueConst val)
-{
-    JSBigFloat *p = JS_VALUE_GET_PTR(val);
-    return &p->num;
-}
-static JSValue JS_CompactBigInt1(JSContext *ctx, JSValue val,
-                                 BOOL convert_to_safe_integer);
-static JSValue JS_CompactBigInt(JSContext *ctx, JSValue val);
-static int JS_ToBigInt64Free(JSContext *ctx, int64_t *pres, JSValue val);
-static bf_t *JS_ToBigInt(JSContext *ctx, bf_t *buf, JSValueConst val);
-static void JS_FreeBigInt(JSContext *ctx, bf_t *a, bf_t *buf);
 #ifdef CONFIG_BIGNUM
 static void js_float_env_finalizer(JSRuntime *rt, JSValue val);
 static JSValue JS_NewBigFloat(JSContext *ctx);
@@ -1137,6 +1137,18 @@
     JSBigDecimal *p = JS_VALUE_GET_PTR(val);
     return &p->num;
 }
+static JSValue JS_NewBigInt(JSContext *ctx);
+static inline bf_t *JS_GetBigInt(JSValueConst val)
+{
+    JSBigFloat *p = JS_VALUE_GET_PTR(val);
+    return &p->num;
+}
+static JSValue JS_CompactBigInt1(JSContext *ctx, JSValue val,
+                                 BOOL convert_to_safe_integer);
+static JSValue JS_CompactBigInt(JSContext *ctx, JSValue val);
+static int JS_ToBigInt64Free(JSContext *ctx, int64_t *pres, JSValue val);
+static bf_t *JS_ToBigInt(JSContext *ctx, bf_t *buf, JSValueConst val);
+static void JS_FreeBigInt(JSContext *ctx, bf_t *a, bf_t *buf);
 static bf_t *JS_ToBigFloat(JSContext *ctx, bf_t *buf, JSValueConst val);
 static JSValue JS_ToBigDecimalFree(JSContext *ctx, JSValue val,
                                    BOOL allow_null_or_undefined);
@@ -1305,12 +1317,14 @@
     return memset(ptr, 0, size);
 }
 
+#ifdef CONFIG_BIGNUM
 /* called by libbf */
 static void *js_bf_realloc(void *opaque, void *ptr, size_t size)
 {
     JSRuntime *rt = opaque;
     return js_realloc_rt(rt, ptr, size);
 }
+#endif /* CONFIG_BIGNUM */
 
 /* Throw out of memory in case of error */
 void *js_malloc(JSContext *ctx, size_t size)
@@ -1461,13 +1475,15 @@
     { JS_ATOM_Uint16Array, js_typed_array_finalizer, js_typed_array_mark },     /* JS_CLASS_UINT16_ARRAY */
     { JS_ATOM_Int32Array, js_typed_array_finalizer, js_typed_array_mark },      /* JS_CLASS_INT32_ARRAY */
     { JS_ATOM_Uint32Array, js_typed_array_finalizer, js_typed_array_mark },     /* JS_CLASS_UINT32_ARRAY */
+#ifdef CONFIG_BIGNUM
     { JS_ATOM_BigInt64Array, js_typed_array_finalizer, js_typed_array_mark },   /* JS_CLASS_BIG_INT64_ARRAY */
     { JS_ATOM_BigUint64Array, js_typed_array_finalizer, js_typed_array_mark },  /* JS_CLASS_BIG_UINT64_ARRAY */
+#endif
     { JS_ATOM_Float32Array, js_typed_array_finalizer, js_typed_array_mark },    /* JS_CLASS_FLOAT32_ARRAY */
     { JS_ATOM_Float64Array, js_typed_array_finalizer, js_typed_array_mark },    /* JS_CLASS_FLOAT64_ARRAY */
     { JS_ATOM_DataView, js_typed_array_finalizer, js_typed_array_mark },        /* JS_CLASS_DATAVIEW */
+#ifdef CONFIG_BIGNUM
     { JS_ATOM_BigInt, js_object_data_finalizer, js_object_data_mark },      /* JS_CLASS_BIG_INT */
-#ifdef CONFIG_BIGNUM
     { JS_ATOM_BigFloat, js_object_data_finalizer, js_object_data_mark },    /* JS_CLASS_BIG_FLOAT */
     { JS_ATOM_BigFloatEnv, js_float_env_finalizer, NULL },      /* JS_CLASS_FLOAT_ENV */
     { JS_ATOM_BigDecimal, js_object_data_finalizer, js_object_data_mark },    /* JS_CLASS_BIG_DECIMAL */
@@ -1502,6 +1518,7 @@
     return 0;
 }
 
+#ifdef CONFIG_BIGNUM
 static JSValue JS_ThrowUnsupportedOperation(JSContext *ctx)
 {
     return JS_ThrowTypeError(ctx, "unsupported operation");
@@ -1557,6 +1574,8 @@
     ops->mul_pow10 = invalid_mul_pow10;
 }
 
+#endif /* CONFIG_BIGNUM */
+
 #if !defined(CONFIG_STACK_CHECK)
 /* no stack limitation */
 static inline uintptr_t js_get_stack_pointer(void)
@@ -1572,7 +1591,11 @@
 /* Note: OS and CPU dependent */
 static inline uintptr_t js_get_stack_pointer(void)
 {
+#if defined(PLATFORM_GNUC_LIKE)
     return (uintptr_t)__builtin_frame_address(0);
+#else
+    return 0;
+#endif
 }
 
 static inline BOOL js_check_stack_overflow(JSRuntime *rt, size_t alloca_size)
@@ -1604,9 +1627,9 @@
     rt->malloc_state = ms;
     rt->malloc_gc_threshold = 256 * 1024;
 
+#ifdef CONFIG_BIGNUM
     bf_context_init(&rt->bf_ctx, js_bf_realloc, rt);
     set_dummy_numeric_ops(&rt->bigint_ops);
-#ifdef CONFIG_BIGNUM
     set_dummy_numeric_ops(&rt->bigfloat_ops);
     set_dummy_numeric_ops(&rt->bigdecimal_ops);
 #endif
@@ -1978,7 +2001,9 @@
     }
     js_free_rt(rt, rt->class_array);
 
+#ifdef CONFIG_BIGNUM
     bf_context_end(&rt->bf_ctx);
+#endif
 
 #ifdef DUMP_LEAKS
     /* only the atoms defined in JS_InitAtoms() should be left */
@@ -2116,8 +2141,8 @@
     }
     ctx->rt = rt;
     list_add_tail(&ctx->link, &rt->context_list);
-    ctx->bf_ctx = &rt->bf_ctx;
 #ifdef CONFIG_BIGNUM
+    ctx->bf_ctx = &rt->bf_ctx;
     ctx->fp_env.prec = 113;
     ctx->fp_env.flags = bf_set_exp_bits(15) | BF_RNDN | BF_FLAG_SUBNORMAL;
 #endif
@@ -2150,7 +2175,9 @@
     JS_AddIntrinsicMapSet(ctx);
     JS_AddIntrinsicTypedArrays(ctx);
     JS_AddIntrinsicPromise(ctx);
+#ifdef CONFIG_BIGNUM
     JS_AddIntrinsicBigInt(ctx);
+#endif
     return ctx;
 }
 
@@ -2358,11 +2385,6 @@
     JSStackFrame *sf = ctx->rt->current_stack_frame;
     return (sf && (sf->js_mode & JS_MODE_MATH));
 }
-#else
-static inline BOOL is_math_mode(JSContext *ctx)
-{
-    return FALSE;
-}
 #endif
 
 /* JSAtom support */
@@ -3370,6 +3392,17 @@
     return class_id;
 }
 
+JSClassID JS_GetClassID(JSValueConst v)
+{
+    JSObject *p;
+
+    if (JS_VALUE_GET_TAG(v) != JS_TAG_OBJECT)
+        return 0;
+    p = JS_VALUE_GET_OBJ(v);
+    assert(p != 0);
+    return p->class_id;
+}
+
 BOOL JS_IsRegisteredClass(JSRuntime *rt, JSClassID class_id)
 {
     return (class_id < rt->class_count &&
@@ -4770,8 +4803,10 @@
     case JS_CLASS_UINT16_ARRAY:
     case JS_CLASS_INT32_ARRAY:
     case JS_CLASS_UINT32_ARRAY:
+#ifdef CONFIG_BIGNUM
     case JS_CLASS_BIG_INT64_ARRAY:
     case JS_CLASS_BIG_UINT64_ARRAY:
+#endif
     case JS_CLASS_FLOAT32_ARRAY:
     case JS_CLASS_FLOAT64_ARRAY:
         p->is_exotic = 1;
@@ -4788,8 +4823,8 @@
     case JS_CLASS_BOOLEAN:
     case JS_CLASS_SYMBOL:
     case JS_CLASS_DATE:
-    case JS_CLASS_BIG_INT:
 #ifdef CONFIG_BIGNUM
+    case JS_CLASS_BIG_INT:
     case JS_CLASS_BIG_FLOAT:
     case JS_CLASS_BIG_DECIMAL:
 #endif
@@ -4851,8 +4886,8 @@
         case JS_CLASS_BOOLEAN:
         case JS_CLASS_SYMBOL:
         case JS_CLASS_DATE:
-        case JS_CLASS_BIG_INT:
 #ifdef CONFIG_BIGNUM
+        case JS_CLASS_BIG_INT:
         case JS_CLASS_BIG_FLOAT:
         case JS_CLASS_BIG_DECIMAL:
 #endif
@@ -4875,8 +4910,8 @@
         case JS_CLASS_BOOLEAN:
         case JS_CLASS_SYMBOL:
         case JS_CLASS_DATE:
-        case JS_CLASS_BIG_INT:
 #ifdef CONFIG_BIGNUM
+        case JS_CLASS_BIG_INT:
         case JS_CLASS_BIG_FLOAT:
         case JS_CLASS_BIG_DECIMAL:
 #endif
@@ -5503,17 +5538,15 @@
     case JS_TAG_MODULE:
         abort(); /* never freed here */
         break;
-    case JS_TAG_BIG_INT:
 #ifdef CONFIG_BIGNUM
+    case JS_TAG_BIG_INT:
     case JS_TAG_BIG_FLOAT:
-#endif        
         {
             JSBigFloat *bf = JS_VALUE_GET_PTR(v);
             bf_delete(&bf->num);
             js_free_rt(rt, bf);
         }
         break;
-#ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_DECIMAL:
         {
             JSBigDecimal *bf = JS_VALUE_GET_PTR(v);
@@ -5876,13 +5909,13 @@
     case JS_TAG_STRING:
         compute_jsstring_size(JS_VALUE_GET_STRING(val), hp);
         break;
-    case JS_TAG_BIG_INT:
 #ifdef CONFIG_BIGNUM
+    case JS_TAG_BIG_INT:
     case JS_TAG_BIG_FLOAT:
     case JS_TAG_BIG_DECIMAL:
-#endif
         /* should track JSBigFloat usage */
         break;
+#endif
     }
 }
 
@@ -6006,8 +6039,8 @@
         case JS_CLASS_BOOLEAN:           /* u.object_data */
         case JS_CLASS_SYMBOL:            /* u.object_data */
         case JS_CLASS_DATE:              /* u.object_data */
+#ifdef CONFIG_BIGNUM
         case JS_CLASS_BIG_INT:           /* u.object_data */
-#ifdef CONFIG_BIGNUM
         case JS_CLASS_BIG_FLOAT:         /* u.object_data */
         case JS_CLASS_BIG_DECIMAL:         /* u.object_data */
 #endif
@@ -6099,8 +6132,10 @@
         case JS_CLASS_UINT16_ARRAY:      /* u.typed_array / u.array */
         case JS_CLASS_INT32_ARRAY:       /* u.typed_array / u.array */
         case JS_CLASS_UINT32_ARRAY:      /* u.typed_array / u.array */
+#ifdef CONFIG_BIGNUM
         case JS_CLASS_BIG_INT64_ARRAY:   /* u.typed_array / u.array */
         case JS_CLASS_BIG_UINT64_ARRAY:  /* u.typed_array / u.array */
+#endif
         case JS_CLASS_FLOAT32_ARRAY:     /* u.typed_array / u.array */
         case JS_CLASS_FLOAT64_ARRAY:     /* u.typed_array / u.array */
         case JS_CLASS_DATAVIEW:          /* u.typed_array */
@@ -6590,7 +6625,7 @@
     return JS_ThrowError2(ctx, error_num, fmt, ap, add_backtrace);
 }
 
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowSyntaxError(JSContext *ctx, const char *fmt, ...)
+JSValue PLATFORM_PRINTF_LIKE(2, 3) JS_ThrowSyntaxError(JSContext *ctx, const char *fmt, ...)
 {
     JSValue val;
     va_list ap;
@@ -6601,7 +6636,7 @@
     return val;
 }
 
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowTypeError(JSContext *ctx, const char *fmt, ...)
+JSValue PLATFORM_PRINTF_LIKE(2, 3) JS_ThrowTypeError(JSContext *ctx, const char *fmt, ...)
 {
     JSValue val;
     va_list ap;
@@ -6612,7 +6647,7 @@
     return val;
 }
 
-static int __attribute__((format(printf, 3, 4))) JS_ThrowTypeErrorOrFalse(JSContext *ctx, int flags, const char *fmt, ...)
+static int PLATFORM_PRINTF_LIKE(3, 4) JS_ThrowTypeErrorOrFalse(JSContext *ctx, int flags, const char *fmt, ...)
 {
     va_list ap;
 
@@ -6628,7 +6663,7 @@
 }
 
 /* never use it directly */
-static JSValue __attribute__((format(printf, 3, 4))) __JS_ThrowTypeErrorAtom(JSContext *ctx, JSAtom atom, const char *fmt, ...)
+static JSValue PLATFORM_PRINTF_LIKE(3, 4) __JS_ThrowTypeErrorAtom(JSContext *ctx, JSAtom atom, const char *fmt, ...)
 {
     char buf[ATOM_GET_STR_BUF_SIZE];
     return JS_ThrowTypeError(ctx, fmt,
@@ -6636,7 +6671,7 @@
 }
 
 /* never use it directly */
-static JSValue __attribute__((format(printf, 3, 4))) __JS_ThrowSyntaxErrorAtom(JSContext *ctx, JSAtom atom, const char *fmt, ...)
+static JSValue PLATFORM_PRINTF_LIKE(3, 4) __JS_ThrowSyntaxErrorAtom(JSContext *ctx, JSAtom atom, const char *fmt, ...)
 {
     char buf[ATOM_GET_STR_BUF_SIZE];
     return JS_ThrowSyntaxError(ctx, fmt,
@@ -6659,7 +6694,7 @@
     }
 }
 
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowReferenceError(JSContext *ctx, const char *fmt, ...)
+JSValue PLATFORM_PRINTF_LIKE(2, 3) JS_ThrowReferenceError(JSContext *ctx, const char *fmt, ...)
 {
     JSValue val;
     va_list ap;
@@ -6670,7 +6705,7 @@
     return val;
 }
 
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowRangeError(JSContext *ctx, const char *fmt, ...)
+JSValue PLATFORM_PRINTF_LIKE(2, 3) JS_ThrowRangeError(JSContext *ctx, const char *fmt, ...)
 {
     JSValue val;
     va_list ap;
@@ -6681,7 +6716,7 @@
     return val;
 }
 
-JSValue __attribute__((format(printf, 2, 3))) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...)
+JSValue PLATFORM_PRINTF_LIKE(2, 3) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...)
 {
     JSValue val;
     va_list ap;
@@ -6861,10 +6896,10 @@
 static JSValueConst JS_GetPrototypePrimitive(JSContext *ctx, JSValueConst val)
 {
     switch(JS_VALUE_GET_NORM_TAG(val)) {
+#ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_INT:
         val = ctx->class_proto[JS_CLASS_BIG_INT];
         break;
-#ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_FLOAT:
         val = ctx->class_proto[JS_CLASS_BIG_FLOAT];
         break;
@@ -7228,7 +7263,7 @@
         JS_ThrowTypeErrorNotASymbol(ctx);
         goto fail;
     }
-    prop = js_symbol_to_atom(ctx, (JSValue)name);
+    prop = js_symbol_to_atom(ctx, name);
     p = JS_VALUE_GET_OBJ(obj);
     prs = find_own_property(&pr, p, prop);
     if (prs) {
@@ -7259,7 +7294,7 @@
     /* safety check */
     if (unlikely(JS_VALUE_GET_TAG(name) != JS_TAG_SYMBOL))
         return JS_ThrowTypeErrorNotASymbol(ctx);
-    prop = js_symbol_to_atom(ctx, (JSValue)name);
+    prop = js_symbol_to_atom(ctx, name);
     p = JS_VALUE_GET_OBJ(obj);
     prs = find_own_property(&pr, p, prop);
     if (!prs) {
@@ -7286,7 +7321,7 @@
         JS_ThrowTypeErrorNotASymbol(ctx);
         goto fail;
     }
-    prop = js_symbol_to_atom(ctx, (JSValue)name);
+    prop = js_symbol_to_atom(ctx, name);
     p = JS_VALUE_GET_OBJ(obj);
     prs = find_own_property(&pr, p, prop);
     if (!prs) {
@@ -7376,7 +7411,7 @@
     if (unlikely(JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT))
         goto not_obj;
     p = JS_VALUE_GET_OBJ(obj);
-    prs = find_own_property(&pr, p, js_symbol_to_atom(ctx, (JSValue)brand));
+    prs = find_own_property(&pr, p, js_symbol_to_atom(ctx, brand));
     if (!prs) {
         JS_ThrowTypeError(ctx, "invalid brand on object");
         return -1;
@@ -7841,6 +7876,8 @@
         uint32_t idx, len;
         /* fast path for array access */
         p = JS_VALUE_GET_OBJ(this_obj);
+        if (unlikely(!p->fast_array))
+            goto slow_path;
         idx = JS_VALUE_GET_INT(prop);
         len = (uint32_t)p->u.array.count;
         if (unlikely(idx >= len))
@@ -7862,10 +7899,12 @@
             return JS_NewInt32(ctx, p->u.array.u.int32_ptr[idx]);
         case JS_CLASS_UINT32_ARRAY:
             return JS_NewUint32(ctx, p->u.array.u.uint32_ptr[idx]);
+#ifdef CONFIG_BIGNUM
         case JS_CLASS_BIG_INT64_ARRAY:
             return JS_NewBigInt64(ctx, p->u.array.u.int64_ptr[idx]);
         case JS_CLASS_BIG_UINT64_ARRAY:
             return JS_NewBigUint64(ctx, p->u.array.u.uint64_ptr[idx]);
+#endif
         case JS_CLASS_FLOAT32_ARRAY:
             return __JS_NewFloat64(ctx, p->u.array.u.float_ptr[idx]);
         case JS_CLASS_FLOAT64_ARRAY:
@@ -8304,7 +8343,7 @@
     JSPropertyDescriptor desc;
     JSValue obj1;
     JSObject *p;
-    
+
     obj1 = JS_DupValue(ctx, obj);
     for(;;) {
         p = JS_VALUE_GET_OBJ(obj1);
@@ -8358,7 +8397,7 @@
         JS_FreeValue(ctx, val);
         return JS_ThrowTypeErrorOrFalse(ctx, flags, "receiver is not an object");
     }
-    
+
     p = JS_VALUE_GET_OBJ(this_obj);
 
     /* modify the property in this_obj if it already exists */
@@ -8707,6 +8746,7 @@
                 goto ta_out_of_bound;
             p->u.array.u.uint32_ptr[idx] = v;
             break;
+#ifdef CONFIG_BIGNUM
         case JS_CLASS_BIG_INT64_ARRAY:
         case JS_CLASS_BIG_UINT64_ARRAY:
             /* XXX: need specific conversion function */
@@ -8719,6 +8759,7 @@
                 p->u.array.u.uint64_ptr[idx] = v;
             }
             break;
+#endif
         case JS_CLASS_FLOAT32_ARRAY:
             if (JS_ToFloat64Free(ctx, &d, val))
                 return -1;
@@ -9024,7 +9065,7 @@
                 return -1;
             }
             /* this code relies on the fact that Uint32 are never allocated */
-            val = (JSValueConst)JS_NewUint32(ctx, array_length);
+            val = JS_NewUint32(ctx, array_length);
             /* prs may have been modified */
             prs = find_own_property(&pr, p, prop);
             assert(prs != NULL);
@@ -9917,10 +9958,9 @@
             JS_FreeValue(ctx, val);
             return ret;
         }
-    case JS_TAG_BIG_INT:
 #ifdef CONFIG_BIGNUM
+    case JS_TAG_BIG_INT:
     case JS_TAG_BIG_FLOAT:
-#endif        
         {
             JSBigFloat *p = JS_VALUE_GET_PTR(val);
             BOOL ret;
@@ -9928,7 +9968,6 @@
             JS_FreeValue(ctx, val);
             return ret;
         }
-#ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_DECIMAL:
         {
             JSBigDecimal *p = JS_VALUE_GET_PTR(val);
@@ -10059,16 +10098,15 @@
 #define ATOD_TYPE_MASK        (3 << 7)
 #define ATOD_TYPE_FLOAT64     (0 << 7)
 #define ATOD_TYPE_BIG_INT     (1 << 7)
-#ifdef CONFIG_BIGNUM
 #define ATOD_TYPE_BIG_FLOAT   (2 << 7)
 #define ATOD_TYPE_BIG_DECIMAL (3 << 7)
 /* assume bigint mode: floats are parsed as integers if no decimal
    point nor exponent */
 #define ATOD_MODE_BIGINT      (1 << 9) 
-#endif
 /* accept -0x1 */
 #define ATOD_ACCEPT_PREFIX_AFTER_SIGN (1 << 10)
 
+#ifdef CONFIG_BIGNUM
 static JSValue js_string_to_bigint(JSContext *ctx, const char *buf,
                                    int radix, int flags, slimb_t *pexponent)
 {
@@ -10084,15 +10122,10 @@
         JS_FreeValue(ctx, val);
         return JS_ThrowOutOfMemory(ctx);
     }
-#ifdef CONFIG_BIGNUM
     val = JS_CompactBigInt1(ctx, val, (flags & ATOD_MODE_BIGINT) != 0);
-#else
-    val = JS_CompactBigInt1(ctx, val, FALSE);
-#endif
     return val;
 }
 
-#ifdef CONFIG_BIGNUM
 static JSValue js_string_to_bigfloat(JSContext *ctx, const char *buf,
                                      int radix, int flags, slimb_t *pexponent)
 {
@@ -10138,6 +10171,7 @@
     }
     return val;
 }
+
 #endif
 
 /* return an exception in case of memory error. Return JS_NAN if
@@ -10212,11 +10246,8 @@
     } else {
  no_radix_prefix:
         if (!(flags & ATOD_INT_ONLY) &&
-            (atod_type == ATOD_TYPE_FLOAT64
-#ifdef CONFIG_BIGNUM
-             || atod_type == ATOD_TYPE_BIG_FLOAT
-#endif             
-             ) &&
+            (atod_type == ATOD_TYPE_FLOAT64 ||
+             atod_type == ATOD_TYPE_BIG_FLOAT) &&
             strstart(p, "Infinity", &p)) {
 #ifdef CONFIG_BIGNUM
             if (atod_type == ATOD_TYPE_BIG_FLOAT) {
@@ -10229,7 +10260,7 @@
             } else
 #endif
             {
-                double d = 1.0 / 0.0;
+                double d = INFINITY;
                 if (is_neg)
                     d = -d;
                 val = JS_NewFloat64(ctx, d);
@@ -10296,40 +10327,36 @@
     }
     buf[j] = '\0';
 
+#ifdef CONFIG_BIGNUM
     if (flags & ATOD_ACCEPT_SUFFIX) {
         if (*p == 'n') {
             p++;
             atod_type = ATOD_TYPE_BIG_INT;
-        } else
-#ifdef CONFIG_BIGNUM
-        if (*p == 'l') {
+        } else if (*p == 'l') {
             p++;
             atod_type = ATOD_TYPE_BIG_FLOAT;
         } else if (*p == 'm') {
             p++;
             atod_type = ATOD_TYPE_BIG_DECIMAL;
-        } else if (flags & ATOD_MODE_BIGINT) {
-            if (!is_float)
-                atod_type = ATOD_TYPE_BIG_INT;
-            if (has_legacy_octal)
-                goto fail;
-        } else
-#endif
-        {
-            if (is_float && radix != 10)
-                goto fail;
+        } else {
+            if (flags & ATOD_MODE_BIGINT) {
+                if (!is_float)
+                    atod_type = ATOD_TYPE_BIG_INT;
+                if (has_legacy_octal)
+                    goto fail;
+            } else {
+                if (is_float && radix != 10)
+                    goto fail;
+            }
         }
     } else {
         if (atod_type == ATOD_TYPE_FLOAT64) {
-#ifdef CONFIG_BIGNUM
             if (flags & ATOD_MODE_BIGINT) {
                 if (!is_float)
                     atod_type = ATOD_TYPE_BIG_INT;
                 if (has_legacy_octal)
                     goto fail;
-            } else
-#endif                
-            {
+            } else {
                 if (is_float && radix != 10)
                     goto fail;
             }
@@ -10350,7 +10377,6 @@
             goto fail;
         val = ctx->rt->bigint_ops.from_string(ctx, buf, radix, flags, NULL);
         break;
-#ifdef CONFIG_BIGNUM
     case ATOD_TYPE_BIG_FLOAT:
         if (has_legacy_octal)
             goto fail;
@@ -10362,10 +10388,19 @@
             goto fail;
         val = ctx->rt->bigdecimal_ops.from_string(ctx, buf, radix, flags, NULL);
         break;
-#endif        
     default:
         abort();
     }
+#else
+    {
+        double d;
+        (void)has_legacy_octal;
+        if (is_float && radix != 10)
+            goto fail;
+        d = js_strtod(buf, radix, is_float);
+        val = JS_NewFloat64(ctx, d);
+    }
+#endif
     
 done:
     if (buf_allocated)
@@ -10403,18 +10438,18 @@
  redo:
     tag = JS_VALUE_GET_NORM_TAG(val);
     switch(tag) {
-    case JS_TAG_BIG_INT:
+#ifdef CONFIG_BIGNUM
+    case JS_TAG_BIG_DECIMAL:
         if (flag != TON_FLAG_NUMERIC) {
             JS_FreeValue(ctx, val);
-            return JS_ThrowTypeError(ctx, "cannot convert bigint to number");
+            return JS_ThrowTypeError(ctx, "cannot convert bigdecimal to number");
         }
         ret = val;
         break;
-#ifdef CONFIG_BIGNUM
-    case JS_TAG_BIG_DECIMAL:
+    case JS_TAG_BIG_INT:
         if (flag != TON_FLAG_NUMERIC) {
             JS_FreeValue(ctx, val);
-            return JS_ThrowTypeError(ctx, "cannot convert bigdecimal to number");
+            return JS_ThrowTypeError(ctx, "cannot convert bigint to number");
         }
         ret = val;
         break;
@@ -10516,10 +10551,9 @@
     case JS_TAG_FLOAT64:
         d = JS_VALUE_GET_FLOAT64(val);
         break;
+#ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_INT:
-#ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_FLOAT:
-#endif
         {
             JSBigFloat *p = JS_VALUE_GET_PTR(val);
             /* XXX: there can be a double rounding issue with some
@@ -10529,6 +10563,7 @@
             JS_FreeValue(ctx, val);
         }
         break;
+#endif
     default:
         abort();
     }
@@ -10596,10 +10631,6 @@
             BOOL is_nan;
 
             a = JS_ToBigFloat(ctx, &a_s, val);
-            if (!a) {
-                JS_FreeValue(ctx, val);
-                return JS_EXCEPTION;
-            }
             if (!bf_is_finite(a)) {
                 is_nan = bf_is_nan(a);
                 if (is_nan)
@@ -11000,10 +11031,9 @@
             len = v;
         }
         break;
-    case JS_TAG_BIG_INT:
 #ifdef CONFIG_BIGNUM
+    case JS_TAG_BIG_INT:
     case JS_TAG_BIG_FLOAT:
-#endif        
         {
             JSBigFloat *p = JS_VALUE_GET_PTR(val);
             bf_t a;
@@ -11018,6 +11048,7 @@
                 goto fail;
         }
         break;
+#endif
     default:
         if (JS_TAG_IS_FLOAT64(tag)) {
             double d;
@@ -11121,13 +11152,13 @@
             u.d = JS_VALUE_GET_FLOAT64(val);
             return (u.u64 >> 63);
         }
+#ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_INT:
         {
             JSBigFloat *p = JS_VALUE_GET_PTR(val);
             /* Note: integer zeros are not necessarily positive */
             return p->num.sign && !bf_is_zero(&p->num);
         }
-#ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_FLOAT:
         {
             JSBigFloat *p = JS_VALUE_GET_PTR(val);
@@ -11146,6 +11177,8 @@
     }
 }
 
+#ifdef CONFIG_BIGNUM
+
 static JSValue js_bigint_to_string1(JSContext *ctx, JSValueConst val, int radix)
 {
     JSValue ret;
@@ -11175,8 +11208,6 @@
     return js_bigint_to_string1(ctx, val, 10);
 }
 
-#ifdef CONFIG_BIGNUM
-
 static JSValue js_ftoa(JSContext *ctx, JSValueConst val1, int radix,
                        limb_t prec, bf_flags_t flags)
 {
@@ -11189,10 +11220,6 @@
     if (JS_IsException(val))
         return val;
     a = JS_ToBigFloat(ctx, &a_s, val);
-    if (!a) {
-        JS_FreeValue(ctx, val);
-        return JS_EXCEPTION;
-    }
     saved_sign = a->sign;
     if (a->expn == BF_EXP_ZERO)
         a->sign = 0;
@@ -11249,8 +11276,6 @@
     int saved_sign;
 
     a = JS_ToBigDecimal(ctx, val);
-    if (!a)
-        return JS_EXCEPTION;
     saved_sign = a->sign;
     if (a->expn == BF_EXP_ZERO)
         a->sign = 0;
@@ -11583,9 +11608,9 @@
     case JS_TAG_FLOAT64:
         return js_dtoa(ctx, JS_VALUE_GET_FLOAT64(val), 10, 0,
                        JS_DTOA_VAR_FORMAT);
+#ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_INT:
         return ctx->rt->bigint_ops.to_string(ctx, val);
-#ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_FLOAT:
         return ctx->rt->bigfloat_ops.to_string(ctx, val);
     case JS_TAG_BIG_DECIMAL:
@@ -11746,8 +11771,10 @@
             case JS_CLASS_UINT16_ARRAY:
             case JS_CLASS_INT32_ARRAY:
             case JS_CLASS_UINT32_ARRAY:
+#ifdef CONFIG_BIGNUM
             case JS_CLASS_BIG_INT64_ARRAY:
             case JS_CLASS_BIG_UINT64_ARRAY:
+#endif
             case JS_CLASS_FLOAT32_ARRAY:
             case JS_CLASS_FLOAT64_ARRAY:
                 {
@@ -11874,6 +11901,7 @@
     case JS_TAG_FLOAT64:
         printf("%.14g", JS_VALUE_GET_FLOAT64(val));
         break;
+#ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_INT:
         {
             JSBigFloat *p = JS_VALUE_GET_PTR(val);
@@ -11884,7 +11912,6 @@
             bf_realloc(&rt->bf_ctx, str, 0);
         }
         break;
-#ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_FLOAT:
         {
             JSBigFloat *p = JS_VALUE_GET_PTR(val);
@@ -11986,6 +12013,8 @@
     }
 }
 
+#ifdef CONFIG_BIGNUM
+
 JSValue JS_NewBigInt64_1(JSContext *ctx, int64_t v)
 {
     JSValue val;
@@ -12030,6 +12059,70 @@
     return val;
 }
 
+/* if the returned bigfloat is allocated it is equal to
+   'buf'. Otherwise it is a pointer to the bigfloat in 'val'. Return
+   NULL in case of error. */
+static bf_t *JS_ToBigFloat(JSContext *ctx, bf_t *buf, JSValueConst val)
+{
+    uint32_t tag;
+    bf_t *r;
+    JSBigFloat *p;
+
+    tag = JS_VALUE_GET_NORM_TAG(val);
+    switch(tag) {
+    case JS_TAG_INT:
+    case JS_TAG_BOOL:
+    case JS_TAG_NULL:
+        r = buf;
+        bf_init(ctx->bf_ctx, r);
+        if (bf_set_si(r, JS_VALUE_GET_INT(val)))
+            goto fail;
+        break;
+    case JS_TAG_FLOAT64:
+        r = buf;
+        bf_init(ctx->bf_ctx, r);
+        if (bf_set_float64(r, JS_VALUE_GET_FLOAT64(val))) {
+        fail:
+            bf_delete(r);
+            return NULL;
+        }
+        break;
+    case JS_TAG_BIG_INT:
+    case JS_TAG_BIG_FLOAT:
+        p = JS_VALUE_GET_PTR(val);
+        r = &p->num;
+        break;
+    case JS_TAG_UNDEFINED:
+    default:
+        r = buf;
+        bf_init(ctx->bf_ctx, r);
+        bf_set_nan(r);
+        break;
+    }
+    return r;
+}
+
+/* return NULL if invalid type */
+static bfdec_t *JS_ToBigDecimal(JSContext *ctx, JSValueConst val)
+{
+    uint32_t tag;
+    JSBigDecimal *p;
+    bfdec_t *r;
+    
+    tag = JS_VALUE_GET_NORM_TAG(val);
+    switch(tag) {
+    case JS_TAG_BIG_DECIMAL:
+        p = JS_VALUE_GET_PTR(val);
+        r = &p->num;
+        break;
+    default:
+        JS_ThrowTypeError(ctx, "bigdecimal expected");
+        r = NULL;
+        break;
+    }
+    return r;
+}
+
 /* return NaN if bad bigint literal */
 static JSValue JS_StringToBigInt(JSContext *ctx, JSValue val)
 {
@@ -12047,10 +12140,8 @@
         val = JS_NewBigInt64(ctx, 0);
     } else {
         flags = ATOD_INT_ONLY | ATOD_ACCEPT_BIN_OCT | ATOD_TYPE_BIG_INT;
-#ifdef CONFIG_BIGNUM
         if (is_math_mode(ctx))
             flags |= ATOD_MODE_BIGINT;
-#endif        
         val = js_atof(ctx, p, &p, 0, flags);
         p += skip_spaces(p);
         if (!JS_IsException(val)) {
@@ -12111,7 +12202,6 @@
         p = JS_VALUE_GET_PTR(val);
         r = &p->num;
         break;
-#ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_FLOAT:
         if (!is_math_mode(ctx))
             goto fail;
@@ -12124,7 +12214,6 @@
         bf_rint(r, BF_RNDZ);
         JS_FreeValue(ctx, val);
         break;
-#endif        
     case JS_TAG_STRING:
         val = JS_StringToBigIntErr(ctx, val);
         if (JS_IsException(val))
@@ -12185,7 +12274,7 @@
     } else {
         JSBigFloat *p = (JSBigFloat *)((uint8_t *)a -
                                        offsetof(JSBigFloat, num));
-        JS_FreeValue(ctx, JS_MKPTR(JS_TAG_BIG_INT, p));
+        JS_FreeValue(ctx, JS_MKPTR(JS_TAG_BIG_FLOAT, p));
     }
 }
 
@@ -12220,6 +12309,28 @@
     return p;
 }
 
+static JSValue JS_NewBigFloat(JSContext *ctx)
+{
+    JSBigFloat *p;
+    p = js_malloc(ctx, sizeof(*p));
+    if (!p)
+        return JS_EXCEPTION;
+    p->header.ref_count = 1;
+    bf_init(ctx->bf_ctx, &p->num);
+    return JS_MKPTR(JS_TAG_BIG_FLOAT, p);
+}
+
+static JSValue JS_NewBigDecimal(JSContext *ctx)
+{
+    JSBigDecimal *p;
+    p = js_malloc(ctx, sizeof(*p));
+    if (!p)
+        return JS_EXCEPTION;
+    p->header.ref_count = 1;
+    bfdec_init(ctx->bf_ctx, &p->num);
+    return JS_MKPTR(JS_TAG_BIG_DECIMAL, p);
+}
+
 static JSValue JS_NewBigInt(JSContext *ctx)
 {
     JSBigFloat *p;
@@ -12261,110 +12372,6 @@
     return JS_CompactBigInt1(ctx, val, is_math_mode(ctx));
 }
 
-static JSValue throw_bf_exception(JSContext *ctx, int status)
-{
-    const char *str;
-    if (status & BF_ST_MEM_ERROR)
-        return JS_ThrowOutOfMemory(ctx);
-    if (status & BF_ST_DIVIDE_ZERO) {
-        str = "division by zero";
-    } else if (status & BF_ST_INVALID_OP) {
-        str = "invalid operation";
-    } else {
-        str = "integer overflow";
-    }
-    return JS_ThrowRangeError(ctx, "%s", str);
-}
-
-/* if the returned bigfloat is allocated it is equal to
-   'buf'. Otherwise it is a pointer to the bigfloat in 'val'. Return
-   NULL in case of error. */
-static bf_t *JS_ToBigFloat(JSContext *ctx, bf_t *buf, JSValueConst val)
-{
-    uint32_t tag;
-    bf_t *r;
-    JSBigFloat *p;
-
-    tag = JS_VALUE_GET_NORM_TAG(val);
-    switch(tag) {
-    case JS_TAG_INT:
-    case JS_TAG_BOOL:
-    case JS_TAG_NULL:
-        r = buf;
-        bf_init(ctx->bf_ctx, r);
-        if (bf_set_si(r, JS_VALUE_GET_INT(val)))
-            goto fail;
-        break;
-    case JS_TAG_FLOAT64:
-        r = buf;
-        bf_init(ctx->bf_ctx, r);
-        if (bf_set_float64(r, JS_VALUE_GET_FLOAT64(val))) {
-        fail:
-            bf_delete(r);
-            return NULL;
-        }
-        break;
-    case JS_TAG_BIG_INT:
-#ifdef CONFIG_BIGNUM
-    case JS_TAG_BIG_FLOAT:
-#endif
-        p = JS_VALUE_GET_PTR(val);
-        r = &p->num;
-        break;
-    case JS_TAG_UNDEFINED:
-    default:
-        r = buf;
-        bf_init(ctx->bf_ctx, r);
-        bf_set_nan(r);
-        break;
-    }
-    return r;
-}
-
-#ifdef CONFIG_BIGNUM
-/* return NULL if invalid type */
-static bfdec_t *JS_ToBigDecimal(JSContext *ctx, JSValueConst val)
-{
-    uint32_t tag;
-    JSBigDecimal *p;
-    bfdec_t *r;
-    
-    tag = JS_VALUE_GET_NORM_TAG(val);
-    switch(tag) {
-    case JS_TAG_BIG_DECIMAL:
-        p = JS_VALUE_GET_PTR(val);
-        r = &p->num;
-        break;
-    default:
-        JS_ThrowTypeError(ctx, "bigdecimal expected");
-        r = NULL;
-        break;
-    }
-    return r;
-}
-
-static JSValue JS_NewBigFloat(JSContext *ctx)
-{
-    JSBigFloat *p;
-    p = js_malloc(ctx, sizeof(*p));
-    if (!p)
-        return JS_EXCEPTION;
-    p->header.ref_count = 1;
-    bf_init(ctx->bf_ctx, &p->num);
-    return JS_MKPTR(JS_TAG_BIG_FLOAT, p);
-}
-
-static JSValue JS_NewBigDecimal(JSContext *ctx)
-{
-    JSBigDecimal *p;
-    p = js_malloc(ctx, sizeof(*p));
-    if (!p)
-        return JS_EXCEPTION;
-    p->header.ref_count = 1;
-    bfdec_init(ctx->bf_ctx, &p->num);
-    return JS_MKPTR(JS_TAG_BIG_DECIMAL, p);
-}
-
 /* must be kept in sync with JSOverloadableOperatorEnum */
 /* XXX: use atoms ? */
 static const char js_overloadable_operator_names[JS_OVOP_COUNT][4] = {
@@ -12688,104 +12695,114 @@
     return -1;
 }
 
-static int js_unary_arith_bigfloat(JSContext *ctx,
-                                   JSValue *pres, OPCodeEnum op, JSValue op1)
+static JSValue throw_bf_exception(JSContext *ctx, int status)
+{
+    const char *str;
+    if (status & BF_ST_MEM_ERROR)
+        return JS_ThrowOutOfMemory(ctx);
+    if (status & BF_ST_DIVIDE_ZERO) {
+        str = "division by zero";
+    } else if (status & BF_ST_INVALID_OP) {
+        str = "invalid operation";
+    } else {
+        str = "integer overflow";
+    }
+    return JS_ThrowRangeError(ctx, "%s", str);
+}
+
+static int js_unary_arith_bigint(JSContext *ctx,
+                                 JSValue *pres, OPCodeEnum op, JSValue op1)
 {
     bf_t a_s, *r, *a;
     int ret, v;
     JSValue res;
     
     if (op == OP_plus && !is_math_mode(ctx)) {
-        JS_ThrowTypeError(ctx, "bigfloat argument with unary +");
+        JS_ThrowTypeError(ctx, "bigint argument with unary +");
         JS_FreeValue(ctx, op1);
         return -1;
     }
-
-    res = JS_NewBigFloat(ctx);
+    res = JS_NewBigInt(ctx);
     if (JS_IsException(res)) {
         JS_FreeValue(ctx, op1);
         return -1;
     }
-    r = JS_GetBigFloat(res);
-    a = JS_ToBigFloat(ctx, &a_s, op1);
-    if (!a) {
-        JS_FreeValue(ctx, res);
-        JS_FreeValue(ctx, op1);
-        return -1;
-    }
+    r = JS_GetBigInt(res);
+    a = JS_ToBigInt(ctx, &a_s, op1);
     ret = 0;
     switch(op) {
     case OP_inc:
     case OP_dec:
         v = 2 * (op - OP_dec) - 1;
-        ret = bf_add_si(r, a, v, ctx->fp_env.prec, ctx->fp_env.flags);
+        ret = bf_add_si(r, a, v, BF_PREC_INF, BF_RNDZ);
         break;
     case OP_plus:
         ret = bf_set(r, a);
         break;
     case OP_neg:
         ret = bf_set(r, a);
+        bf_neg(r);
+        break;
+    case OP_not:
+        ret = bf_add_si(r, a, 1, BF_PREC_INF, BF_RNDZ);
         bf_neg(r);
         break;
     default:
         abort();
     }
-    if (a == &a_s)
-        bf_delete(a);
+    JS_FreeBigInt(ctx, a, &a_s);
     JS_FreeValue(ctx, op1);
-    if (unlikely(ret & BF_ST_MEM_ERROR)) {
+    if (unlikely(ret)) {
         JS_FreeValue(ctx, res);
         throw_bf_exception(ctx, ret);
         return -1;
     }
+    res = JS_CompactBigInt(ctx, res);
     *pres = res;
     return 0;
 }
 
-static int js_unary_arith_bigdecimal(JSContext *ctx,
-                                     JSValue *pres, OPCodeEnum op, JSValue op1)
+static int js_unary_arith_bigfloat(JSContext *ctx,
+                                   JSValue *pres, OPCodeEnum op, JSValue op1)
 {
-    bfdec_t *r, *a;
+    bf_t a_s, *r, *a;
     int ret, v;
     JSValue res;
     
     if (op == OP_plus && !is_math_mode(ctx)) {
-        JS_ThrowTypeError(ctx, "bigdecimal argument with unary +");
+        JS_ThrowTypeError(ctx, "bigfloat argument with unary +");
         JS_FreeValue(ctx, op1);
         return -1;
     }
 
-    res = JS_NewBigDecimal(ctx);
+    res = JS_NewBigFloat(ctx);
     if (JS_IsException(res)) {
         JS_FreeValue(ctx, op1);
         return -1;
     }
-    r = JS_GetBigDecimal(res);
-    a = JS_ToBigDecimal(ctx, op1);
-    if (!a) {
-        JS_FreeValue(ctx, res);
-        JS_FreeValue(ctx, op1);
-        return -1;
-    }
+    r = JS_GetBigFloat(res);
+    a = JS_ToBigFloat(ctx, &a_s, op1);
     ret = 0;
     switch(op) {
     case OP_inc:
     case OP_dec:
         v = 2 * (op - OP_dec) - 1;
-        ret = bfdec_add_si(r, a, v, BF_PREC_INF, BF_RNDZ);
+        ret = bf_add_si(r, a, v, ctx->fp_env.prec, ctx->fp_env.flags);
         break;
     case OP_plus:
-        ret = bfdec_set(r, a);
+        ret = bf_set(r, a);
         break;
     case OP_neg:
-        ret = bfdec_set(r, a);
-        bfdec_neg(r);
+        ret = bf_set(r, a);
+        bf_neg(r);
         break;
     default:
         abort();
     }
+    if (a == &a_s)
+        bf_delete(a);
     JS_FreeValue(ctx, op1);
-    if (unlikely(ret)) {
+    if (unlikely(ret & BF_ST_MEM_ERROR)) {
         JS_FreeValue(ctx, res);
         throw_bf_exception(ctx, ret);
         return -1;
@@ -12794,61 +12811,49 @@
     return 0;
 }
 
-#endif /* CONFIG_BIGNUM */
-
-static int js_unary_arith_bigint(JSContext *ctx,
-                                 JSValue *pres, OPCodeEnum op, JSValue op1)
+static int js_unary_arith_bigdecimal(JSContext *ctx,
+                                     JSValue *pres, OPCodeEnum op, JSValue op1)
 {
-    bf_t a_s, *r, *a;
+    bfdec_t *r, *a;
     int ret, v;
     JSValue res;
     
     if (op == OP_plus && !is_math_mode(ctx)) {
-        JS_ThrowTypeError(ctx, "bigint argument with unary +");
+        JS_ThrowTypeError(ctx, "bigdecimal argument with unary +");
         JS_FreeValue(ctx, op1);
         return -1;
     }
-    res = JS_NewBigInt(ctx);
+
+    res = JS_NewBigDecimal(ctx);
     if (JS_IsException(res)) {
         JS_FreeValue(ctx, op1);
         return -1;
     }
-    r = JS_GetBigInt(res);
-    a = JS_ToBigInt(ctx, &a_s, op1);
-    if (!a) {
-        JS_FreeValue(ctx, res);
-        JS_FreeValue(ctx, op1);
-        return -1;
-    }
+    r = JS_GetBigDecimal(res);
+    a = JS_ToBigDecimal(ctx, op1);
     ret = 0;
     switch(op) {
     case OP_inc:
     case OP_dec:
         v = 2 * (op - OP_dec) - 1;
-        ret = bf_add_si(r, a, v, BF_PREC_INF, BF_RNDZ);
+        ret = bfdec_add_si(r, a, v, BF_PREC_INF, BF_RNDZ);
         break;
     case OP_plus:
-        ret = bf_set(r, a);
+        ret = bfdec_set(r, a);
         break;
     case OP_neg:
-        ret = bf_set(r, a);
-        bf_neg(r);
-        break;
-    case OP_not:
-        ret = bf_add_si(r, a, 1, BF_PREC_INF, BF_RNDZ);
-        bf_neg(r);
+        ret = bfdec_set(r, a);
+        bfdec_neg(r);
         break;
     default:
         abort();
     }
-    JS_FreeBigInt(ctx, a, &a_s);
     JS_FreeValue(ctx, op1);
     if (unlikely(ret)) {
         JS_FreeValue(ctx, res);
         throw_bf_exception(ctx, ret);
         return -1;
     }
-    res = JS_CompactBigInt(ctx, res);
     *pres = res;
     return 0;
 }
@@ -12857,18 +12862,16 @@
                                                      JSValue *sp,
                                                      OPCodeEnum op)
 {
-    JSValue op1;
-    int v;
+    JSValue op1, val;
+    int v, ret;
     uint32_t tag;
 
     op1 = sp[-1];
     /* fast path for float64 */
     if (JS_TAG_IS_FLOAT64(JS_VALUE_GET_TAG(op1)))
         goto handle_float64;
-#ifdef CONFIG_BIGNUM
     if (JS_IsObject(op1)) {
-        JSValue val;
-        int ret = js_call_unary_op_fallback(ctx, &val, op1, op);
+        ret = js_call_unary_op_fallback(ctx, &val, op1, op);
         if (ret < 0)
             return -1;
         if (ret) {
@@ -12877,7 +12880,7 @@
             return 0;
         }
     }
-#endif
+
     op1 = JS_ToNumericFree(ctx, op1);
     if (JS_IsException(op1))
         goto exception;
@@ -12914,7 +12917,6 @@
         if (ctx->rt->bigint_ops.unary_arith(ctx, sp - 1, op, op1))
             goto exception;
         break;
-#ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_FLOAT:
         if (ctx->rt->bigfloat_ops.unary_arith(ctx, sp - 1, op, op1))
             goto exception;
@@ -12923,7 +12925,6 @@
         if (ctx->rt->bigdecimal_ops.unary_arith(ctx, sp - 1, op, op1))
             goto exception;
         break;
-#endif        
     default:
     handle_float64:
         {
@@ -12974,13 +12975,12 @@
 
 static no_inline int js_not_slow(JSContext *ctx, JSValue *sp)
 {
-    JSValue op1;
+    JSValue op1, val;
+    int ret;
     
     op1 = sp[-1];
-#ifdef CONFIG_BIGNUM
     if (JS_IsObject(op1)) {
-        JSValue val;
-        int ret = js_call_unary_op_fallback(ctx, &val, op1, OP_not);
+        ret = js_call_unary_op_fallback(ctx, &val, op1, OP_not);
         if (ret < 0)
             return -1;
         if (ret) {
@@ -12989,7 +12989,7 @@
             return 0;
         }
     }
-#endif
+
     op1 = JS_ToNumericFree(ctx, op1);
     if (JS_IsException(op1))
         goto exception;
@@ -13007,6 +13007,67 @@
     sp[-1] = JS_UNDEFINED;
     return -1;
 }
+
+static int js_binary_arith_bigfloat(JSContext *ctx, OPCodeEnum op,
+                                    JSValue *pres, JSValue op1, JSValue op2)
+{
+    bf_t a_s, b_s, *r, *a, *b;
+    int ret;
+    JSValue res;
+    
+    res = JS_NewBigFloat(ctx);
+    if (JS_IsException(res)) {
+        JS_FreeValue(ctx, op1);
+        JS_FreeValue(ctx, op2);
+        return -1;
+    }
+    r = JS_GetBigFloat(res);
+    a = JS_ToBigFloat(ctx, &a_s, op1);
+    b = JS_ToBigFloat(ctx, &b_s, op2);
+    bf_init(ctx->bf_ctx, r);
+    switch(op) {
+    case OP_add:
+        ret = bf_add(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);
+        break;
+    case OP_sub:
+        ret = bf_sub(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);
+        break;
+    case OP_mul:
+        ret = bf_mul(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);
+        break;
+    case OP_div:
+        ret = bf_div(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);
+        break;
+    case OP_math_mod:
+        /* Euclidian remainder */
+        ret = bf_rem(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags,
+                     BF_DIVREM_EUCLIDIAN);
+        break;
+    case OP_mod:
+        ret = bf_rem(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags,
+                     BF_RNDZ);
+        break;
+    case OP_pow:
+        ret = bf_pow(r, a, b, ctx->fp_env.prec,
+                     ctx->fp_env.flags | BF_POW_JS_QUIRKS);
+        break;
+    default:
+        abort();
+    }
+    if (a == &a_s)
+        bf_delete(a);
+    if (b == &b_s)
+        bf_delete(b);
+    JS_FreeValue(ctx, op1);
+    JS_FreeValue(ctx, op2);
+    if (unlikely(ret & BF_ST_MEM_ERROR)) {
+        JS_FreeValue(ctx, res);
+        throw_bf_exception(ctx, ret);
+        return -1;
+    }
+    *pres = res;
+    return 0;
+}
 
 static int js_binary_arith_bigint(JSContext *ctx, OPCodeEnum op,
                                   JSValue *pres, JSValue op1, JSValue op2)
@@ -13049,13 +13110,11 @@
             goto math_mode_div_pow;
         }
         break;
-#ifdef CONFIG_BIGNUM
     case OP_math_mod:
         /* Euclidian remainder */
         ret = bf_rem(r, a, b, BF_PREC_INF, BF_RNDZ,
                      BF_DIVREM_EUCLIDIAN) & BF_ST_INVALID_OP;
         break;
-#endif        
     case OP_mod:
         ret = bf_rem(r, a, b, BF_PREC_INF, BF_RNDZ,
                      BF_RNDZ) & BF_ST_INVALID_OP;
@@ -13066,7 +13125,6 @@
                 ret = BF_ST_INVALID_OP;
             } else {
             math_mode_div_pow:
-#ifdef CONFIG_BIGNUM
                 JS_FreeValue(ctx, res);
                 ret = js_call_binary_op_simple(ctx, &res, ctx->class_proto[JS_CLASS_BIG_INT], op1, op2, op);
                 if (ret != 0) {
@@ -13107,9 +13165,6 @@
                 }
                 *pres = res;
                 return 0;
-#else
-                abort();
-#endif
             }
         } else {
             ret = bf_pow(r, a, b, BF_PREC_INF, BF_RNDZ | BF_POW_JS_QUIRKS);
@@ -13168,79 +13223,6 @@
     JS_FreeValue(ctx, op2);
     return -1;
 }
-
-#ifdef CONFIG_BIGNUM
-static int js_binary_arith_bigfloat(JSContext *ctx, OPCodeEnum op,
-                                    JSValue *pres, JSValue op1, JSValue op2)
-{
-    bf_t a_s, b_s, *r, *a, *b;
-    int ret;
-    JSValue res;
-    
-    res = JS_NewBigFloat(ctx);
-    if (JS_IsException(res))
-        goto fail;
-    r = JS_GetBigFloat(res);
-    a = JS_ToBigFloat(ctx, &a_s, op1);
-    if (!a) {
-        JS_FreeValue(ctx, res);
-        goto fail;
-    }
-    b = JS_ToBigFloat(ctx, &b_s, op2);
-    if (!b) {
-        if (a == &a_s)
-            bf_delete(a);
-        JS_FreeValue(ctx, res);
-        goto fail;
-    }
-    bf_init(ctx->bf_ctx, r);
-    switch(op) {
-    case OP_add:
-        ret = bf_add(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);
-        break;
-    case OP_sub:
-        ret = bf_sub(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);
-        break;
-    case OP_mul:
-        ret = bf_mul(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);
-        break;
-    case OP_div:
-        ret = bf_div(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags);
-        break;
-    case OP_math_mod:
-        /* Euclidian remainder */
-        ret = bf_rem(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags,
-                     BF_DIVREM_EUCLIDIAN);
-        break;
-    case OP_mod:
-        ret = bf_rem(r, a, b, ctx->fp_env.prec, ctx->fp_env.flags,
-                     BF_RNDZ);
-        break;
-    case OP_pow:
-        ret = bf_pow(r, a, b, ctx->fp_env.prec,
-                     ctx->fp_env.flags | BF_POW_JS_QUIRKS);
-        break;
-    default:
-        abort();
-    }
-    if (a == &a_s)
-        bf_delete(a);
-    if (b == &b_s)
-        bf_delete(b);
-    JS_FreeValue(ctx, op1);
-    JS_FreeValue(ctx, op2);
-    if (unlikely(ret & BF_ST_MEM_ERROR)) {
-        JS_FreeValue(ctx, res);
-        throw_bf_exception(ctx, ret);
-        return -1;
-    }
-    *pres = res;
-    return 0;
- fail:
-    JS_FreeValue(ctx, op1);
-    JS_FreeValue(ctx, op2);
-    return -1;
-}
 
 /* b must be a positive integer */
 static int js_bfdec_pow(bfdec_t *r, const bfdec_t *a, const bfdec_t *b)
@@ -13328,13 +13310,13 @@
     JS_FreeValue(ctx, op2);
     return -1;
 }
-#endif /* CONFIG_BIGNUM */
 
 static no_inline __exception int js_binary_arith_slow(JSContext *ctx, JSValue *sp,
                                                       OPCodeEnum op)
 {
-    JSValue op1, op2;
+    JSValue op1, op2, res;
     uint32_t tag1, tag2;
+    int ret;
     double d1, d2;
 
     op1 = sp[-2];
@@ -13348,14 +13330,12 @@
         goto handle_float64;
     }
 
-#ifdef CONFIG_BIGNUM
     /* try to call an overloaded operator */
     if ((tag1 == JS_TAG_OBJECT &&
          (tag2 != JS_TAG_NULL && tag2 != JS_TAG_UNDEFINED)) ||
         (tag2 == JS_TAG_OBJECT &&
          (tag1 != JS_TAG_NULL && tag1 != JS_TAG_UNDEFINED))) {
-        JSValue res;
-        int ret = js_call_binary_op_fallback(ctx, &res, op1, op2, op, TRUE, 0);
+        ret = js_call_binary_op_fallback(ctx, &res, op1, op2, op, TRUE, 0);
         if (ret != 0) {
             JS_FreeValue(ctx, op1);
             JS_FreeValue(ctx, op2);
@@ -13367,7 +13347,6 @@
             }
         }
     }
-#endif
 
     op1 = JS_ToNumericFree(ctx, op1);
     if (JS_IsException(op1)) {
@@ -13406,7 +13385,6 @@
                 goto handle_bigint;
             sp[-2] = __JS_NewFloat64(ctx, (double)v1 / (double)v2);
             return 0;
-#ifdef CONFIG_BIGNUM
         case OP_math_mod:
             if (unlikely(v2 == 0)) {
                 throw_bf_exception(ctx, BF_ST_DIVIDE_ZERO);
@@ -13420,7 +13398,6 @@
                     v += v2;
             }
             break;
-#endif            
         case OP_mod:
             if (v1 < 0 || v2 <= 0) {
                 sp[-2] = JS_NewFloat64(ctx, fmod(v1, v2));
@@ -13441,17 +13418,13 @@
             abort();
         }
         sp[-2] = JS_NewInt64(ctx, v);
-    } else
-#ifdef CONFIG_BIGNUM
-    if (tag1 == JS_TAG_BIG_DECIMAL || tag2 == JS_TAG_BIG_DECIMAL) {
+    } else if (tag1 == JS_TAG_BIG_DECIMAL || tag2 == JS_TAG_BIG_DECIMAL) {
         if (ctx->rt->bigdecimal_ops.binary_arith(ctx, op, sp - 2, op1, op2))
             goto exception;
     } else if (tag1 == JS_TAG_BIG_FLOAT || tag2 == JS_TAG_BIG_FLOAT) {
         if (ctx->rt->bigfloat_ops.binary_arith(ctx, op, sp - 2, op1, op2))
             goto exception;
-    } else
-#endif        
-    if (tag1 == JS_TAG_BIG_INT || tag2 == JS_TAG_BIG_INT) {
+    } else if (tag1 == JS_TAG_BIG_INT || tag2 == JS_TAG_BIG_INT) {
     handle_bigint:
         if (ctx->rt->bigint_ops.binary_arith(ctx, op, sp - 2, op1, op2))
             goto exception;
@@ -13480,7 +13453,6 @@
         case OP_mod:
             dr = fmod(d1, d2);
             break;
-#ifdef CONFIG_BIGNUM
         case OP_math_mod:
             d2 = fabs(d2);
             dr = fmod(d1, d2);
@@ -13488,7 +13460,6 @@
             if (dr < 0)
                 dr += d2;
             break;
-#endif            
         case OP_pow:
             dr = js_pow(d1, d2);
             break;
@@ -13506,8 +13477,9 @@
 
 static no_inline __exception int js_add_slow(JSContext *ctx, JSValue *sp)
 {
-    JSValue op1, op2;
+    JSValue op1, op2, res;
     uint32_t tag1, tag2;
+    int ret;
 
     op1 = sp[-2];
     op2 = sp[-1];
@@ -13524,7 +13496,6 @@
     }
 
     if (tag1 == JS_TAG_OBJECT || tag2 == JS_TAG_OBJECT) {
-#ifdef CONFIG_BIGNUM
         /* try to call an overloaded operator */
         if ((tag1 == JS_TAG_OBJECT &&
              (tag2 != JS_TAG_NULL && tag2 != JS_TAG_UNDEFINED &&
@@ -13532,9 +13503,8 @@
             (tag2 == JS_TAG_OBJECT &&
              (tag1 != JS_TAG_NULL && tag1 != JS_TAG_UNDEFINED &&
               tag1 != JS_TAG_STRING))) {
-            JSValue res;
-            int ret = js_call_binary_op_fallback(ctx, &res, op1, op2, OP_add,
-                                                 FALSE, HINT_NONE);
+            ret = js_call_binary_op_fallback(ctx, &res, op1, op2, OP_add,
+                                             FALSE, HINT_NONE);
             if (ret != 0) {
                 JS_FreeValue(ctx, op1);
                 JS_FreeValue(ctx, op2);
@@ -13546,7 +13516,7 @@
                 }
             }
         }
-#endif
+
         op1 = JS_ToPrimitiveFree(ctx, op1, HINT_NONE);
         if (JS_IsException(op1)) {
             JS_FreeValue(ctx, op2);
@@ -13589,17 +13559,13 @@
         v2 = JS_VALUE_GET_INT(op2);
         v = (int64_t)v1 + (int64_t)v2;
         sp[-2] = JS_NewInt64(ctx, v);
-    } else
-#ifdef CONFIG_BIGNUM
-    if (tag1 == JS_TAG_BIG_DECIMAL || tag2 == JS_TAG_BIG_DECIMAL) {
+    } else if (tag1 == JS_TAG_BIG_DECIMAL || tag2 == JS_TAG_BIG_DECIMAL) {
         if (ctx->rt->bigdecimal_ops.binary_arith(ctx, OP_add, sp - 2, op1, op2))
             goto exception;
     } else if (tag1 == JS_TAG_BIG_FLOAT || tag2 == JS_TAG_BIG_FLOAT) {
         if (ctx->rt->bigfloat_ops.binary_arith(ctx, OP_add, sp - 2, op1, op2))
             goto exception;
-    } else
-#endif        
-    if (tag1 == JS_TAG_BIG_INT || tag2 == JS_TAG_BIG_INT) {
+    } else if (tag1 == JS_TAG_BIG_INT || tag2 == JS_TAG_BIG_INT) {
     handle_bigint:
         if (ctx->rt->bigint_ops.binary_arith(ctx, OP_add, sp - 2, op1, op2))
             goto exception;
@@ -13627,7 +13593,8 @@
                                                       JSValue *sp,
                                                       OPCodeEnum op)
 {
-    JSValue op1, op2;
+    JSValue op1, op2, res;
+    int ret;
     uint32_t tag1, tag2;
     uint32_t v1, v2, r;
 
@@ -13636,14 +13603,12 @@
     tag1 = JS_VALUE_GET_NORM_TAG(op1);
     tag2 = JS_VALUE_GET_NORM_TAG(op2);
 
-#ifdef CONFIG_BIGNUM
     /* try to call an overloaded operator */
     if ((tag1 == JS_TAG_OBJECT &&
          (tag2 != JS_TAG_NULL && tag2 != JS_TAG_UNDEFINED)) ||
         (tag2 == JS_TAG_OBJECT &&
          (tag1 != JS_TAG_NULL && tag1 != JS_TAG_UNDEFINED))) {
-        JSValue res;
-        int ret = js_call_binary_op_fallback(ctx, &res, op1, op2, op, TRUE, 0);
+        ret = js_call_binary_op_fallback(ctx, &res, op1, op2, op, TRUE, 0);
         if (ret != 0) {
             JS_FreeValue(ctx, op1);
             JS_FreeValue(ctx, op2);
@@ -13655,7 +13620,6 @@
             }
         }
     }
-#endif
 
     op1 = JS_ToNumericFree(ctx, op1);
     if (JS_IsException(op1)) {
@@ -13766,7 +13730,6 @@
     return res;
 }
 
-#ifdef CONFIG_BIGNUM
 static int js_compare_bigdecimal(JSContext *ctx, OPCodeEnum op,
                                  JSValue op1, JSValue op2)
 {
@@ -13786,8 +13749,8 @@
         JS_FreeValue(ctx, op1);
         return -1;
     }
-    a = JS_ToBigDecimal(ctx, op1); /* cannot fail */
-    b = JS_ToBigDecimal(ctx, op2); /* cannot fail */
+    a = JS_ToBigDecimal(ctx, op1);
+    b = JS_ToBigDecimal(ctx, op2);
     
     switch(op) {
     case OP_lt:
@@ -13812,12 +13775,11 @@
     JS_FreeValue(ctx, op2);
     return res;
 }
-#endif /* !CONFIG_BIGNUM */
 
 static no_inline int js_relational_slow(JSContext *ctx, JSValue *sp,
                                         OPCodeEnum op)
 {
-    JSValue op1, op2;
+    JSValue op1, op2, ret;
     int res;
     uint32_t tag1, tag2;
 
@@ -13825,13 +13787,11 @@
     op2 = sp[-1];
     tag1 = JS_VALUE_GET_NORM_TAG(op1);
     tag2 = JS_VALUE_GET_NORM_TAG(op2);
-#ifdef CONFIG_BIGNUM
     /* try to call an overloaded operator */
     if ((tag1 == JS_TAG_OBJECT &&
          (tag2 != JS_TAG_NULL && tag2 != JS_TAG_UNDEFINED)) ||
         (tag2 == JS_TAG_OBJECT &&
          (tag1 != JS_TAG_NULL && tag1 != JS_TAG_UNDEFINED))) {
-        JSValue ret;
         res = js_call_binary_op_fallback(ctx, &ret, op1, op2, op,
                                          FALSE, HINT_NUMBER);
         if (res != 0) {
@@ -13845,7 +13805,6 @@
             }
         }
     }
-#endif    
     op1 = JS_ToPrimitiveFree(ctx, op1, HINT_NUMBER);
     if (JS_IsException(op1)) {
         JS_FreeValue(ctx, op2);
@@ -13920,7 +13879,6 @@
         tag1 = JS_VALUE_GET_NORM_TAG(op1);
         tag2 = JS_VALUE_GET_NORM_TAG(op2);
 
-#ifdef CONFIG_BIGNUM
         if (tag1 == JS_TAG_BIG_DECIMAL || tag2 == JS_TAG_BIG_DECIMAL) {
             res = ctx->rt->bigdecimal_ops.compare(ctx, op, op1, op2);
             if (res < 0)
@@ -13929,9 +13887,7 @@
             res = ctx->rt->bigfloat_ops.compare(ctx, op, op1, op2);
             if (res < 0)
                 goto exception;
-        } else
-#endif            
-        if (tag1 == JS_TAG_BIG_INT || tag2 == JS_TAG_BIG_INT) {
+        } else if (tag1 == JS_TAG_BIG_INT || tag2 == JS_TAG_BIG_INT) {
             res = ctx->rt->bigint_ops.compare(ctx, op, op1, op2);
             if (res < 0)
                 goto exception;
@@ -13979,20 +13935,14 @@
 static BOOL tag_is_number(uint32_t tag)
 {
     return (tag == JS_TAG_INT || tag == JS_TAG_BIG_INT ||
-            tag == JS_TAG_FLOAT64
-#ifdef CONFIG_BIGNUM
-            || tag == JS_TAG_BIG_FLOAT || tag == JS_TAG_BIG_DECIMAL
-#endif
-            );
+            tag == JS_TAG_FLOAT64 || tag == JS_TAG_BIG_FLOAT ||
+            tag == JS_TAG_BIG_DECIMAL);
 }
 
 static no_inline __exception int js_eq_slow(JSContext *ctx, JSValue *sp,
                                             BOOL is_neq)
 {
-    JSValue op1, op2;
-#ifdef CONFIG_BIGNUM
-    JSValue ret;
-#endif
+    JSValue op1, op2, ret;
     int res;
     uint32_t tag1, tag2;
 
@@ -14020,9 +13970,7 @@
                 d2 = JS_VALUE_GET_INT(op2);
             }
             res = (d1 == d2);
-        } else
-#ifdef CONFIG_BIGNUM
-        if (tag1 == JS_TAG_BIG_DECIMAL || tag2 == JS_TAG_BIG_DECIMAL) {
+        } else if (tag1 == JS_TAG_BIG_DECIMAL || tag2 == JS_TAG_BIG_DECIMAL) {
             res = ctx->rt->bigdecimal_ops.compare(ctx, OP_eq, op1, op2);
             if (res < 0)
                 goto exception;
@@ -14030,15 +13978,12 @@
             res = ctx->rt->bigfloat_ops.compare(ctx, OP_eq, op1, op2);
             if (res < 0)
                 goto exception;
-        } else
-#endif            
-        {
+        } else {
             res = ctx->rt->bigint_ops.compare(ctx, OP_eq, op1, op2);
             if (res < 0)
                 goto exception;
         }
     } else if (tag1 == tag2) {
-#ifdef CONFIG_BIGNUM
         if (tag1 == JS_TAG_OBJECT) {
             /* try the fallback operator */
             res = js_call_binary_op_fallback(ctx, &ret, op1, op2,
@@ -14055,7 +14000,6 @@
                 }
             }
         }
-#endif        
         res = js_strict_eq2(ctx, op1, op2, JS_EQ_STRICT);
     } else if ((tag1 == JS_TAG_NULL && tag2 == JS_TAG_UNDEFINED) ||
                (tag2 == JS_TAG_NULL && tag1 == JS_TAG_UNDEFINED)) {
@@ -14103,7 +14047,7 @@
                 (tag_is_number(tag2) || tag2 == JS_TAG_STRING || tag2 == JS_TAG_SYMBOL)) ||
                (tag2 == JS_TAG_OBJECT &&
                 (tag_is_number(tag1) || tag1 == JS_TAG_STRING || tag1 == JS_TAG_SYMBOL))) {
-#ifdef CONFIG_BIGNUM
+
         /* try the fallback operator */
         res = js_call_binary_op_fallback(ctx, &ret, op1, op2,
                                          is_neq ? OP_neq : OP_eq,
@@ -14118,7 +14062,7 @@
                 return 0;
             }
         }
-#endif
+
         op1 = JS_ToPrimitiveFree(ctx, op1, HINT_NONE);
         if (JS_IsException(op1)) {
             JS_FreeValue(ctx, op2);
@@ -14190,7 +14134,6 @@
     return -1;
 }
 
-#ifdef CONFIG_BIGNUM
 static JSValue js_mul_pow10_to_float64(JSContext *ctx, const bf_t *a,
                                        int64_t exponent)
 {
@@ -14225,10 +14168,8 @@
     op1 = sp[-2];
     op2 = sp[-1];
     a = JS_ToBigFloat(ctx, &a_s, op1);
-    if (!a) {
-        JS_FreeValue(ctx, res);
+    if (!a)
         return -1;
-    }
     if (JS_IsBigInt(ctx, op2)) {
         ret = JS_ToBigInt64(ctx, &e, op2);
     } else {
@@ -14249,7 +14190,395 @@
     sp[-2] = res;
     return 0;
 }
-#endif
+
+#else /* !CONFIG_BIGNUM */
+
+static JSValue JS_ThrowUnsupportedBigint(JSContext *ctx)
+{
+    return JS_ThrowTypeError(ctx, "bigint is not supported");
+}
+
+JSValue JS_NewBigInt64(JSContext *ctx, int64_t v)
+{
+    return JS_ThrowUnsupportedBigint(ctx);
+}
+
+JSValue JS_NewBigUint64(JSContext *ctx, uint64_t v)
+{
+    return JS_ThrowUnsupportedBigint(ctx);
+}
+
+int JS_ToBigInt64(JSContext *ctx, int64_t *pres, JSValueConst val)
+{
+    JS_ThrowUnsupportedBigint(ctx);
+    *pres = 0;
+    return -1;
+}
+
+static no_inline __exception int js_unary_arith_slow(JSContext *ctx,
+                                                     JSValue *sp,
+                                                     OPCodeEnum op)
+{
+    JSValue op1;
+    double d;
+
+    op1 = sp[-1];
+    if (unlikely(JS_ToFloat64Free(ctx, &d, op1))) {
+        sp[-1] = JS_UNDEFINED;
+        return -1;
+    }
+    switch(op) {
+    case OP_inc:
+        d++;
+        break;
+    case OP_dec:
+        d--;
+        break;
+    case OP_plus:
+        break;
+    case OP_neg:
+        d = -d;
+        break;
+    default:
+        abort();
+    }
+    sp[-1] = JS_NewFloat64(ctx, d);
+    return 0;
+}
+
+/* specific case necessary for correct return value semantics */
+static __exception int js_post_inc_slow(JSContext *ctx,
+                                        JSValue *sp, OPCodeEnum op)
+{
+    JSValue op1;
+    double d, r;
+
+    op1 = sp[-1];
+    if (unlikely(JS_ToFloat64Free(ctx, &d, op1))) {
+        sp[-1] = JS_UNDEFINED;
+        return -1;
+    }
+    r = d + 2 * (op - OP_post_dec) - 1;
+    sp[0] = JS_NewFloat64(ctx, r);
+    sp[-1] = JS_NewFloat64(ctx, d);
+    return 0;
+}
+
+static no_inline __exception int js_binary_arith_slow(JSContext *ctx, JSValue *sp,
+                                                      OPCodeEnum op)
+{
+    JSValue op1, op2;
+    double d1, d2, r;
+
+    op1 = sp[-2];
+    op2 = sp[-1];
+    if (unlikely(JS_ToFloat64Free(ctx, &d1, op1))) {
+        JS_FreeValue(ctx, op2);
+        goto exception;
+    }
+    if (unlikely(JS_ToFloat64Free(ctx, &d2, op2))) {
+        goto exception;
+    }
+    switch(op) {
+    case OP_sub:
+        r = d1 - d2;
+        break;
+    case OP_mul:
+        r = d1 * d2;
+        break;
+    case OP_div:
+        r = d1 / d2;
+        break;
+    case OP_mod:
+        r = fmod(d1, d2);
+        break;
+    case OP_pow:
+        r = js_pow(d1, d2);
+        break;
+    default:
+        abort();
+    }
+    sp[-2] = JS_NewFloat64(ctx, r);
+    return 0;
+ exception:
+    sp[-2] = JS_UNDEFINED;
+    sp[-1] = JS_UNDEFINED;
+    return -1;
+}
+
+static no_inline __exception int js_add_slow(JSContext *ctx, JSValue *sp)
+{
+    JSValue op1, op2;
+    uint32_t tag1, tag2;
+
+    op1 = sp[-2];
+    op2 = sp[-1];
+    tag1 = JS_VALUE_GET_TAG(op1);
+    tag2 = JS_VALUE_GET_TAG(op2);
+    if ((tag1 == JS_TAG_INT || JS_TAG_IS_FLOAT64(tag1)) &&
+        (tag2 == JS_TAG_INT || JS_TAG_IS_FLOAT64(tag2))) {
+        goto add_numbers;
+    } else {
+        op1 = JS_ToPrimitiveFree(ctx, op1, HINT_NONE);
+        if (JS_IsException(op1)) {
+            JS_FreeValue(ctx, op2);
+            goto exception;
+        }
+        op2 = JS_ToPrimitiveFree(ctx, op2, HINT_NONE);
+        if (JS_IsException(op2)) {
+            JS_FreeValue(ctx, op1);
+            goto exception;
+        }
+        tag1 = JS_VALUE_GET_TAG(op1);
+        tag2 = JS_VALUE_GET_TAG(op2);
+        if (tag1 == JS_TAG_STRING || tag2 == JS_TAG_STRING) {
+            sp[-2] = JS_ConcatString(ctx, op1, op2);
+            if (JS_IsException(sp[-2]))
+                goto exception;
+        } else {
+            double d1, d2;
+        add_numbers:
+            if (JS_ToFloat64Free(ctx, &d1, op1)) {
+                JS_FreeValue(ctx, op2);
+                goto exception;
+            }
+            if (JS_ToFloat64Free(ctx, &d2, op2))
+                goto exception;
+            sp[-2] = JS_NewFloat64(ctx, d1 + d2);
+        }
+    }
+    return 0;
+ exception:
+    sp[-2] = JS_UNDEFINED;
+    sp[-1] = JS_UNDEFINED;
+    return -1;
+}
+
+static no_inline __exception int js_binary_logic_slow(JSContext *ctx,
+                                                      JSValue *sp,
+                                                      OPCodeEnum op)
+{
+    JSValue op1, op2;
+    uint32_t v1, v2, r;
+
+    op1 = sp[-2];
+    op2 = sp[-1];
+    if (unlikely(JS_ToInt32Free(ctx, (int32_t *)&v1, op1))) {
+        JS_FreeValue(ctx, op2);
+        goto exception;
+    }
+    if (unlikely(JS_ToInt32Free(ctx, (int32_t *)&v2, op2)))
+        goto exception;
+    switch(op) {
+    case OP_shl:
+        r = v1 << (v2 & 0x1f);
+        break;
+    case OP_sar:
+        r = (int)v1 >> (v2 & 0x1f);
+        break;
+    case OP_and:
+        r = v1 & v2;
+        break;
+    case OP_or:
+        r = v1 | v2;
+        break;
+    case OP_xor:
+        r = v1 ^ v2;
+        break;
+    default:
+        abort();
+    }
+    sp[-2] = JS_NewInt32(ctx, r);
+    return 0;
+ exception:
+    sp[-2] = JS_UNDEFINED;
+    sp[-1] = JS_UNDEFINED;
+    return -1;
+}
+
+static no_inline int js_not_slow(JSContext *ctx, JSValue *sp)
+{
+    int32_t v1;
+
+    if (unlikely(JS_ToInt32Free(ctx, &v1, sp[-1]))) {
+        sp[-1] = JS_UNDEFINED;
+        return -1;
+    }
+    sp[-1] = JS_NewInt32(ctx, ~v1);
+    return 0;
+}
+
+static no_inline int js_relational_slow(JSContext *ctx, JSValue *sp,
+                                        OPCodeEnum op)
+{
+    JSValue op1, op2;
+    int res;
+
+    op1 = sp[-2];
+    op2 = sp[-1];
+    op1 = JS_ToPrimitiveFree(ctx, op1, HINT_NUMBER);
+    if (JS_IsException(op1)) {
+        JS_FreeValue(ctx, op2);
+        goto exception;
+    }
+    op2 = JS_ToPrimitiveFree(ctx, op2, HINT_NUMBER);
+    if (JS_IsException(op2)) {
+        JS_FreeValue(ctx, op1);
+        goto exception;
+    }
+    if (JS_VALUE_GET_TAG(op1) == JS_TAG_STRING &&
+        JS_VALUE_GET_TAG(op2) == JS_TAG_STRING) {
+        JSString *p1, *p2;
+        p1 = JS_VALUE_GET_STRING(op1);
+        p2 = JS_VALUE_GET_STRING(op2);
+        res = js_string_compare(ctx, p1, p2);
+        JS_FreeValue(ctx, op1);
+        JS_FreeValue(ctx, op2);
+        switch(op) {
+        case OP_lt:
+            res = (res < 0);
+            break;
+        case OP_lte:
+            res = (res <= 0);
+            break;
+        case OP_gt:
+            res = (res > 0);
+            break;
+        default:
+        case OP_gte:
+            res = (res >= 0);
+            break;
+        }
+    } else {
+        double d1, d2;
+        if (JS_ToFloat64Free(ctx, &d1, op1)) {
+            JS_FreeValue(ctx, op2);
+            goto exception;
+        }
+        if (JS_ToFloat64Free(ctx, &d2, op2))
+            goto exception;
+        switch(op) {
+        case OP_lt:
+            res = (d1 < d2); /* if NaN return false */
+            break;
+        case OP_lte:
+            res = (d1 <= d2); /* if NaN return false */
+            break;
+        case OP_gt:
+            res = (d1 > d2); /* if NaN return false */
+            break;
+        default:
+        case OP_gte:
+            res = (d1 >= d2); /* if NaN return false */
+            break;
+        }
+    }
+    sp[-2] = JS_NewBool(ctx, res);
+    return 0;
+ exception:
+    sp[-2] = JS_UNDEFINED;
+    sp[-1] = JS_UNDEFINED;
+    return -1;
+}
+
+static no_inline __exception int js_eq_slow(JSContext *ctx, JSValue *sp,
+                                            BOOL is_neq)
+{
+    JSValue op1, op2;
+    int tag1, tag2;
+    BOOL res;
+
+    op1 = sp[-2];
+    op2 = sp[-1];
+ redo:
+    tag1 = JS_VALUE_GET_NORM_TAG(op1);
+    tag2 = JS_VALUE_GET_NORM_TAG(op2);
+    if (tag1 == tag2 ||
+        (tag1 == JS_TAG_INT && tag2 == JS_TAG_FLOAT64) ||
+        (tag2 == JS_TAG_INT && tag1 == JS_TAG_FLOAT64)) {
+        res = js_strict_eq(ctx, op1, op2);
+    } else if ((tag1 == JS_TAG_NULL && tag2 == JS_TAG_UNDEFINED) ||
+               (tag2 == JS_TAG_NULL && tag1 == JS_TAG_UNDEFINED)) {
+        res = TRUE;
+    } else if ((tag1 == JS_TAG_STRING && (tag2 == JS_TAG_INT ||
+                                   tag2 == JS_TAG_FLOAT64)) ||
+        (tag2 == JS_TAG_STRING && (tag1 == JS_TAG_INT ||
+                                   tag1 == JS_TAG_FLOAT64))) {
+        double d1;
+        double d2;
+        if (JS_ToFloat64Free(ctx, &d1, op1)) {
+            JS_FreeValue(ctx, op2);
+            goto exception;
+        }
+        if (JS_ToFloat64Free(ctx, &d2, op2))
+            goto exception;
+        res = (d1 == d2);
+    } else if (tag1 == JS_TAG_BOOL) {
+        op1 = JS_NewInt32(ctx, JS_VALUE_GET_INT(op1));
+        goto redo;
+    } else if (tag2 == JS_TAG_BOOL) {
+        op2 = JS_NewInt32(ctx, JS_VALUE_GET_INT(op2));
+        goto redo;
+    } else if (tag1 == JS_TAG_OBJECT &&
+               (tag2 == JS_TAG_INT || tag2 == JS_TAG_FLOAT64 || tag2 == JS_TAG_STRING || tag2 == JS_TAG_SYMBOL)) {
+        op1 = JS_ToPrimitiveFree(ctx, op1, HINT_NONE);
+        if (JS_IsException(op1)) {
+            JS_FreeValue(ctx, op2);
+            goto exception;
+        }
+        goto redo;
+    } else if (tag2 == JS_TAG_OBJECT &&
+               (tag1 == JS_TAG_INT || tag1 == JS_TAG_FLOAT64 || tag1 == JS_TAG_STRING || tag1 == JS_TAG_SYMBOL)) {
+        op2 = JS_ToPrimitiveFree(ctx, op2, HINT_NONE);
+        if (JS_IsException(op2)) {
+            JS_FreeValue(ctx, op1);
+            goto exception;
+        }
+        goto redo;
+    } else {
+        /* IsHTMLDDA object is equivalent to undefined for '==' and '!=' */
+        if ((JS_IsHTMLDDA(ctx, op1) &&
+             (tag2 == JS_TAG_NULL || tag2 == JS_TAG_UNDEFINED)) ||
+            (JS_IsHTMLDDA(ctx, op2) &&
+             (tag1 == JS_TAG_NULL || tag1 == JS_TAG_UNDEFINED))) {
+            res = TRUE;
+        } else {
+            res = FALSE;
+        }
+        JS_FreeValue(ctx, op1);
+        JS_FreeValue(ctx, op2);
+    }
+    sp[-2] = JS_NewBool(ctx, res ^ is_neq);
+    return 0;
+ exception:
+    sp[-2] = JS_UNDEFINED;
+    sp[-1] = JS_UNDEFINED;
+    return -1;
+}
+
+static no_inline int js_shr_slow(JSContext *ctx, JSValue *sp)
+{
+    JSValue op1, op2;
+    uint32_t v1, v2, r;
+
+    op1 = sp[-2];
+    op2 = sp[-1];
+    if (unlikely(JS_ToUint32Free(ctx, &v1, op1))) {
+        JS_FreeValue(ctx, op2);
+        goto exception;
+    }
+    if (unlikely(JS_ToUint32Free(ctx, &v2, op2)))
+        goto exception;
+    r = v1 >> (v2 & 0x1f);
+    sp[-2] = JS_NewUint32(ctx, r);
+    return 0;
+ exception:
+    sp[-2] = JS_UNDEFINED;
+    sp[-1] = JS_UNDEFINED;
+    return -1;
+}
+
+#endif /* !CONFIG_BIGNUM */
 
 /* XXX: Should take JSValueConst arguments */
 static BOOL js_strict_eq2(JSContext *ctx, JSValue op1, JSValue op2,
@@ -14343,6 +14672,7 @@
             res = (d1 == d2); /* if NaN return false and +0 == -0 */
         }
         goto done_no_free;
+#ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_INT:
         {
             bf_t a_s, *a, b_s, *b;
@@ -14350,8 +14680,8 @@
                 res = FALSE;
                 break;
             }
-            a = JS_ToBigFloat(ctx, &a_s, op1); /* cannot fail */
-            b = JS_ToBigFloat(ctx, &b_s, op2); /* cannot fail */
+            a = JS_ToBigFloat(ctx, &a_s, op1);
+            b = JS_ToBigFloat(ctx, &b_s, op2);
             res = bf_cmp_eq(a, b);
             if (a == &a_s)
                 bf_delete(a);
@@ -14359,7 +14689,6 @@
                 bf_delete(b);
         }
         break;
-#ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_FLOAT:
         {
             JSBigFloat *p1, *p2;
@@ -14505,10 +14834,10 @@
 
     tag = JS_VALUE_GET_NORM_TAG(op1);
     switch(tag) {
+#ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_INT:
         atom = JS_ATOM_bigint;
         break;
-#ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_FLOAT:
         atom = JS_ATOM_bigfloat;
         break;
@@ -15342,7 +15671,7 @@
     int ret, gpn_flags;
     JSPropertyDescriptor desc;
     BOOL is_enumerable;
-    
+
     if (JS_VALUE_GET_TAG(source) != JS_TAG_OBJECT)
         return 0;
 
@@ -15363,7 +15692,7 @@
     if (JS_GetOwnPropertyNamesInternal(ctx, &tab_atom, &tab_atom_count, p,
                                        gpn_flags))
         return -1;
-    
+
     for (i = 0; i < tab_atom_count; i++) {
         if (pexcl) {
             ret = JS_GetOwnPropertyInternal(ctx, NULL, pexcl, tab_atom[i].atom);
@@ -15737,7 +16066,7 @@
 #else
     sf->js_mode = 0;
 #endif
-    sf->cur_func = (JSValue)func_obj;
+    sf->cur_func = func_obj;
     sf->arg_count = argc;
     arg_buf = argv;
 
@@ -15981,7 +16310,7 @@
     sf->js_mode = b->js_mode;
     arg_buf = argv;
     sf->arg_count = argc;
-    sf->cur_func = (JSValue)func_obj;
+    sf->cur_func = func_obj;
     init_list_head(&sf->var_ref_list);
     var_refs = p->u.func.var_refs;
 
@@ -19837,9 +20166,11 @@
 static void free_token(JSParseState *s, JSToken *token)
 {
     switch(token->val) {
+#ifdef CONFIG_BIGNUM
     case TOK_NUMBER:
         JS_FreeValue(s->ctx, token->u.num.val);
         break;
+#endif
     case TOK_STRING:
     case TOK_TEMPLATE:
         JS_FreeValue(s->ctx, token->u.str.str);
@@ -19861,7 +20192,7 @@
     }
 }
 
-static void __attribute((unused)) dump_token(JSParseState *s,
+static void PLATFORM_MAYBE_UNUSED dump_token(JSParseState *s,
                                              const JSToken *token)
 {
     switch(token->val) {
@@ -19922,7 +20253,7 @@
     }
 }
 
-int __attribute__((format(printf, 2, 3))) js_parse_error(JSParseState *s, const char *fmt, ...)
+int PLATFORM_PRINTF_LIKE(2, 3) js_parse_error(JSParseState *s, const char *fmt, ...)
 {
     JSContext *ctx = s->ctx;
     va_list ap;
@@ -20585,8 +20916,8 @@
             int flags, radix;
             flags = ATOD_ACCEPT_BIN_OCT | ATOD_ACCEPT_LEGACY_OCTAL |
                 ATOD_ACCEPT_UNDERSCORES;
+#ifdef CONFIG_BIGNUM
             flags |= ATOD_ACCEPT_SUFFIX;
-#ifdef CONFIG_BIGNUM
             if (s->cur_func->js_mode & JS_MODE_MATH) {
                 flags |= ATOD_MODE_BIGINT;
                 if (s->cur_func->js_mode & JS_MODE_MATH)
@@ -33843,6 +34174,7 @@
     }
 }
 
+#ifdef CONFIG_BIGNUM
 static int JS_WriteBigNum(BCWriterState *s, JSValueConst obj)
 {
     uint32_t tag, tag1;
@@ -33857,14 +34189,12 @@
     case JS_TAG_BIG_INT:
         tag1 = BC_TAG_BIG_INT;
         break;
-#ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_FLOAT:
         tag1 = BC_TAG_BIG_FLOAT;
         break;
     case JS_TAG_BIG_DECIMAL:
         tag1 = BC_TAG_BIG_DECIMAL;
         break;
-#endif        
     default:
         abort();
     }
@@ -33979,6 +34309,7 @@
     }
     return 0;
 }
+#endif /* CONFIG_BIGNUM */
 
 static int JS_WriteObjectRec(BCWriterState *s, JSValueConst obj);
 
@@ -34335,8 +34666,8 @@
             case JS_CLASS_NUMBER:
             case JS_CLASS_STRING:
             case JS_CLASS_BOOLEAN:
+#ifdef CONFIG_BIGNUM
             case JS_CLASS_BIG_INT:
-#ifdef CONFIG_BIGNUM
             case JS_CLASS_BIG_FLOAT:
             case JS_CLASS_BIG_DECIMAL:
 #endif
@@ -34358,14 +34689,14 @@
                 goto fail;
         }
         break;
-    case JS_TAG_BIG_INT:
 #ifdef CONFIG_BIGNUM
+    case JS_TAG_BIG_INT:
     case JS_TAG_BIG_FLOAT:
     case JS_TAG_BIG_DECIMAL:
-#endif
         if (JS_WriteBigNum(s, obj))
             goto fail;
         break;
+#endif
     default:
     invalid_tag:
         JS_ThrowInternalError(s->ctx, "unsupported tag (%d)", tag);
@@ -34492,7 +34823,7 @@
 } BCReaderState;
 
 #ifdef DUMP_READ_OBJECT
-static void __attribute__((format(printf, 2, 3))) bc_read_trace(BCReaderState *s, const char *fmt, ...) {
+static void PLATFORM_PRINTF_LIKE(2, 3) bc_read_trace(BCReaderState *s, const char *fmt, ...) {
     va_list ap;
     int i, n, n0;
 
@@ -34757,6 +35088,7 @@
     return 0;
 }
 
+#ifdef CONFIG_BIGNUM
 static JSValue JS_ReadBigNum(BCReaderState *s, int tag)
 {
     JSValue obj = JS_UNDEFINED;
@@ -34776,14 +35108,12 @@
     case BC_TAG_BIG_INT:
         obj = JS_MKPTR(JS_TAG_BIG_INT, p);
         break;
-#ifdef CONFIG_BIGNUM
     case BC_TAG_BIG_FLOAT:
         obj = JS_MKPTR(JS_TAG_BIG_FLOAT, p);
         break;
     case BC_TAG_BIG_DECIMAL:
         obj = JS_MKPTR(JS_TAG_BIG_DECIMAL, p);
         break;
-#endif        
     default:
         abort();
     }
@@ -34890,6 +35220,7 @@
     JS_FreeValue(s->ctx, obj);
     return JS_EXCEPTION;
 }
+#endif /* CONFIG_BIGNUM */
 
 static JSValue JS_ReadObjectRec(BCReaderState *s);
 
@@ -34993,7 +35324,7 @@
     if (b->cpool_count != 0) {
         b->cpool = (void *)((uint8_t*)b + cpool_offset);
     }
-    
+
     add_gc_object(ctx->rt, &b->header, JS_GC_OBJ_TYPE_FUNCTION_BYTECODE);
             
     obj = JS_MKPTR(JS_TAG_FUNCTION_BYTECODE, b);
@@ -35514,13 +35845,13 @@
     case BC_TAG_OBJECT_VALUE:
         obj = JS_ReadObjectValue(s);
         break;
+#ifdef CONFIG_BIGNUM
     case BC_TAG_BIG_INT:
-#ifdef CONFIG_BIGNUM
     case BC_TAG_BIG_FLOAT:
     case BC_TAG_BIG_DECIMAL:
-#endif
         obj = JS_ReadBigNum(s, tag);
         break;
+#endif
     case BC_TAG_OBJECT_REFERENCE:
         {
             uint32_t val;
@@ -35952,10 +36283,10 @@
     case JS_TAG_OBJECT:
     case JS_TAG_EXCEPTION:
         return JS_DupValue(ctx, val);
+#ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_INT:
         obj = JS_NewObjectClass(ctx, JS_CLASS_BIG_INT);
         goto set_value;
-#ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_FLOAT:
         obj = JS_NewObjectClass(ctx, JS_CLASS_BIG_FLOAT);
         goto set_value;
@@ -37741,7 +38072,7 @@
             fromPresent = JS_TryGetPropertyInt64(ctx, obj, from, &val);
             if (fromPresent < 0)
                 goto exception;
-            
+
             if (fromPresent) {
                 if (JS_SetPropertyInt64(ctx, obj, to, val) < 0)
                     goto exception;
@@ -38010,41 +38341,6 @@
     return JS_IsArray(ctx, obj);
 }
 
-static JSValue js_array_at(JSContext *ctx, JSValueConst this_val,
-                           int argc, JSValueConst *argv)
-{
-    JSValue obj, ret;
-    int64_t len, idx;
-    JSValue *arrp;
-    uint32_t count;
-    
-    obj = JS_ToObject(ctx, this_val);
-    if (js_get_length64(ctx, &len, obj))
-        goto exception;
-
-    if (JS_ToInt64Sat(ctx, &idx, argv[0]))
-        goto exception;
-
-    if (idx < 0)
-        idx = len + idx;
-    if (idx < 0 || idx >= len) {
-        ret = JS_UNDEFINED;
-    } else if (js_get_fast_array(ctx, obj, &arrp, &count) && idx < count) {
-        ret = JS_DupValue(ctx, arrp[idx]);
-    } else {
-        int present = JS_TryGetPropertyInt64(ctx, obj, idx, &ret);
-        if (present < 0)
-            goto exception;
-        if (!present)
-            ret = JS_UNDEFINED;
-    }
-    JS_FreeValue(ctx, obj);
-    return ret;
- exception:
-    JS_FreeValue(ctx, obj);
-    return JS_EXCEPTION;
-}
-
 static JSValue js_array_concat(JSContext *ctx, JSValueConst this_val,
                                int argc, JSValueConst *argv)
 {
@@ -39010,8 +39306,8 @@
         if (!JS_IsUndefined(mapperFunction)) {
             JSValueConst args[3] = { element, JS_NewInt64(ctx, sourceIndex), source };
             element = JS_Call(ctx, mapperFunction, thisArg, 3, args);
-            JS_FreeValue(ctx, (JSValue)args[0]);
-            JS_FreeValue(ctx, (JSValue)args[1]);
+            JS_FreeValue(ctx, args[0]);
+            JS_FreeValue(ctx, args[1]);
             if (JS_IsException(element))
                 return -1;
         }
@@ -39406,7 +39702,6 @@
 };
 
 static const JSCFunctionListEntry js_array_proto_funcs[] = {
-    JS_CFUNC_DEF("at", 1, js_array_at ),
     JS_CFUNC_DEF("concat", 1, js_array_concat ),
     JS_CFUNC_MAGIC_DEF("every", 1, js_array_every, special_every ),
     JS_CFUNC_MAGIC_DEF("some", 1, js_array_every, special_some ),
@@ -39459,10 +39754,9 @@
         if (JS_IsException(val))
             return val;
         switch(JS_VALUE_GET_TAG(val)) {
-        case JS_TAG_BIG_INT:
 #ifdef CONFIG_BIGNUM
+        case JS_TAG_BIG_INT:
         case JS_TAG_BIG_FLOAT:
-#endif            
             {
                 JSBigFloat *p = JS_VALUE_GET_PTR(val);
                 double d;
@@ -39471,7 +39765,6 @@
                 val = __JS_NewFloat64(ctx, d);
             }
             break;
-#ifdef CONFIG_BIGNUM
         case JS_TAG_BIG_DECIMAL:
             val = JS_ToStringFree(ctx, val);
             if (JS_IsException(val))
@@ -40106,7 +40399,7 @@
 }
 
 static JSValue js_string_charAt(JSContext *ctx, JSValueConst this_val,
-                                int argc, JSValueConst *argv, int is_at)
+                                int argc, JSValueConst *argv)
 {
     JSValue val, ret;
     JSString *p;
@@ -40120,13 +40413,8 @@
         JS_FreeValue(ctx, val);
         return JS_EXCEPTION;
     }
-    if (idx < 0 && is_at)
-        idx += p->len;
     if (idx < 0 || idx >= p->len) {
-        if (is_at)
-            ret = JS_UNDEFINED;
-        else
-            ret = js_new_string8(ctx, NULL, 0);
+        ret = js_new_string8(ctx, NULL, 0);
     } else {
         if (p->is_wide_char)
             c = p->u.str16[idx];
@@ -40436,7 +40724,7 @@
         str = JS_NewString(ctx, "g");
         if (JS_IsException(str))
             goto fail;
-        args[args_len++] = (JSValueConst)str;
+        args[args_len++] = str;
     }
     rx = JS_CallConstructor(ctx, ctx->regexp_ctor, args_len, args);
     JS_FreeValue(ctx, str);
@@ -41385,9 +41673,8 @@
 
 static const JSCFunctionListEntry js_string_proto_funcs[] = {
     JS_PROP_INT32_DEF("length", 0, JS_PROP_CONFIGURABLE ),
-    JS_CFUNC_MAGIC_DEF("at", 1, js_string_charAt, 1 ),
     JS_CFUNC_DEF("charCodeAt", 1, js_string_charCodeAt ),
-    JS_CFUNC_MAGIC_DEF("charAt", 1, js_string_charAt, 0 ),
+    JS_CFUNC_DEF("charAt", 1, js_string_charAt ),
     JS_CFUNC_DEF("concat", 1, js_string_concat ),
     JS_CFUNC_DEF("codePointAt", 1, js_string_codePointAt ),
     JS_CFUNC_MAGIC_DEF("indexOf", 1, js_string_indexOf, 0 ),
@@ -41495,7 +41782,7 @@
     uint32_t tag;
 
     if (unlikely(argc == 0)) {
-        return __JS_NewFloat64(ctx, is_max ? -1.0 / 0.0 : 1.0 / 0.0);
+        return __JS_NewFloat64(ctx, is_max ? -INFINITY : INFINITY);
     }
 
     tag = JS_VALUE_GET_TAG(argv[0]);
@@ -41645,6 +41932,28 @@
     return x * 0x2545F4914F6CDD1D;
 }
 
+#if defined(PLATFORM_IS_WINDOWS)
+// From: https://stackoverflow.com/a/26085827
+int gettimeofday(struct timeval *tp, void *tzp)
+{
+    static const uint64_t EPOCH = ((uint64_t)116444736000000000ULL);
+
+    SYSTEMTIME system_time;
+    FILETIME file_time;
+    uint64_t time;
+
+    GetSystemTime(&system_time);
+    SystemTimeToFileTime(&system_time, &file_time);
+    time = ((uint64_t)file_time.dwLowDateTime);
+    time += ((uint64_t)file_time.dwHighDateTime) << 32;
+
+    tp->tv_sec = (long)((time - EPOCH) / 10000000L);
+    tp->tv_usec = (long)(system_time.wMilliseconds * 1000);
+
+    return 0;
+}
+#endif
+
 static void js_random_init(JSContext *ctx)
 {
     struct timeval tv;
@@ -41666,13 +41975,16 @@
     u.u64 = ((uint64_t)0x3ff << 52) | (v >> 12);
     return __JS_NewFloat64(ctx, u.d - 1.0);
 }
+static double js_math_floor(double value) { return floor(value); }
+static double js_math_ceil(double value) { return ceil(value); }
+static double js_math_log2(double value) { return log2(value); }
 
 static const JSCFunctionListEntry js_math_funcs[] = {
     JS_CFUNC_MAGIC_DEF("min", 2, js_math_min_max, 0 ),
     JS_CFUNC_MAGIC_DEF("max", 2, js_math_min_max, 1 ),
     JS_CFUNC_SPECIAL_DEF("abs", 1, f_f, fabs ),
-    JS_CFUNC_SPECIAL_DEF("floor", 1, f_f, floor ),
-    JS_CFUNC_SPECIAL_DEF("ceil", 1, f_f, ceil ),
+    JS_CFUNC_SPECIAL_DEF("floor", 1, f_f, js_math_floor ),
+    JS_CFUNC_SPECIAL_DEF("ceil", 1, f_f, js_math_ceil ),
     JS_CFUNC_SPECIAL_DEF("round", 1, f_f, js_math_round ),
     JS_CFUNC_SPECIAL_DEF("sqrt", 1, f_f, sqrt ),
 
@@ -41697,7 +42009,7 @@
     JS_CFUNC_SPECIAL_DEF("atanh", 1, f_f, atanh ),
     JS_CFUNC_SPECIAL_DEF("expm1", 1, f_f, expm1 ),
     JS_CFUNC_SPECIAL_DEF("log1p", 1, f_f, log1p ),
-    JS_CFUNC_SPECIAL_DEF("log2", 1, f_f, log2 ),
+    JS_CFUNC_SPECIAL_DEF("log2", 1, f_f, js_math_log2 ),
     JS_CFUNC_SPECIAL_DEF("log10", 1, f_f, log10 ),
     JS_CFUNC_SPECIAL_DEF("cbrt", 1, f_f, cbrt ),
     JS_CFUNC_DEF("hypot", 2, js_math_hypot ),
@@ -41750,7 +42062,9 @@
    between UTC time and local time 'd' in minutes */
 static int getTimezoneOffset(int64_t time) {
 #if defined(_WIN32)
-    /* XXX: TODO */
+    TIME_ZONE_INFORMATION tzi;
+    if (!GetTimeZoneInformation(&tzi))
+        return tzi.Bias;
     return 0;
 #else
     time_t ti;
@@ -43570,8 +43884,10 @@
     JSValue v;
     JSValueConst args[2];
 
-    if (JS_IsObject(val) ||
-        JS_IsBigInt(ctx, val)   /* XXX: probably useless */
+    if (JS_IsObject(val)
+#ifdef CONFIG_BIGNUM
+    ||  JS_IsBigInt(ctx, val)   /* XXX: probably useless */
+#endif
         ) {
             JSValue f = JS_GetProperty(ctx, val, JS_ATOM_toJSON);
             if (JS_IsException(f))
@@ -43609,7 +43925,9 @@
 #endif
     case JS_TAG_BOOL:
     case JS_TAG_NULL:
+#ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_INT:
+#endif
     case JS_TAG_EXCEPTION:
         return val;
     default:
@@ -43660,16 +43978,15 @@
             ret = string_buffer_concat_value(jsc->b, p->u.object_data);
             JS_FreeValue(ctx, val);
             return ret;
-        } else
+        }
 #ifdef CONFIG_BIGNUM
-        if (cl == JS_CLASS_BIG_FLOAT) {
+        else if (cl == JS_CLASS_BIG_FLOAT) {
             return string_buffer_concat_value_free(jsc->b, val);
-        } else
-#endif
-        if (cl == JS_CLASS_BIG_INT) {
+        } else if (cl == JS_CLASS_BIG_INT) {
             JS_ThrowTypeError(ctx, "bigint are forbidden in JSON.stringify");
             goto exception;
         }
+#endif
         v = js_array_includes(ctx, jsc->stack, 1, (JSValueConst *)&val);
         if (JS_IsException(v))
             goto exception;
@@ -43799,9 +44116,11 @@
     case JS_TAG_NULL:
     concat_value:
         return string_buffer_concat_value_free(jsc->b, val);
+#ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_INT:
         JS_ThrowTypeError(ctx, "bigint are forbidden in JSON.stringify");
         goto exception;
+#endif
     default:
         JS_FreeValue(ctx, val);
         return 0;
@@ -44974,10 +45293,6 @@
     JSProxyData *s = JS_GetOpaque(obj, JS_CLASS_PROXY);
     if (!s)
         return FALSE;
-    if (js_check_stack_overflow(ctx->rt, 0)) {
-        JS_ThrowStackOverflow(ctx);
-        return -1;
-    }
     if (s->is_revoked) {
         JS_ThrowTypeErrorRevokedProxy(ctx);
         return -1;
@@ -45464,7 +45779,7 @@
     } else {
         JS_DupValue(ctx, key);
     }
-    mr->key = (JSValue)key;
+    mr->key = key;
     h = map_hash_key(ctx, key) & (s->hash_size - 1);
     list_add_tail(&mr->hash_link, &s->hash_table[h]);
     list_add_tail(&mr->link, &s->records);
@@ -45686,7 +46001,7 @@
                 args[0] = args[1];
             else
                 args[0] = JS_DupValue(ctx, mr->value);
-            args[2] = (JSValue)this_val;
+            args[2] = this_val;
             ret = JS_Call(ctx, func, this_arg, 3, (JSValueConst *)args);
             JS_FreeValue(ctx, args[0]);
             if (!magic)
@@ -46015,6 +46330,7 @@
     struct list_head promise_reactions[2];
     BOOL is_handled; /* Note: only useful to debug */
     JSValue promise_result;
+    JSContext * ctx;
 } JSPromiseData;
 
 typedef struct JSPromiseFunctionDataResolved {
@@ -46095,6 +46411,15 @@
     rt->host_promise_rejection_tracker_opaque = opaque;
 }
 
+void JS_SetHostUnhandledPromiseRejectionTracker(JSRuntime *rt,
+                                       JSHostPromiseRejectionTracker *cb,
+                                       void *opaque)
+{
+    rt->host_unhandled_promise_rejection_tracker = cb;
+    rt->host_unhandled_promise_rejection_tracker_opaque = opaque;
+}
+
+
 static void fulfill_or_reject_promise(JSContext *ctx, JSValueConst promise,
                                       JSValueConst value, BOOL is_reject)
 {
@@ -46299,6 +46624,14 @@
 
     if (!s)
         return;
+    if (s->promise_state == JS_PROMISE_REJECTED && !s->is_handled) {
+        if (rt->host_unhandled_promise_rejection_tracker) {
+            rt->host_unhandled_promise_rejection_tracker(s->ctx, val, s->promise_result, FALSE,
+                                                         rt->host_unhandled_promise_rejection_tracker_opaque);
+        }
+    }
+
+
     for(i = 0; i < 2; i++) {
         list_for_each_safe(el, el1, &s->promise_reactions[i]) {
             JSPromiseReactionData *rd =
@@ -46349,6 +46682,7 @@
     s = js_mallocz(ctx, sizeof(*s));
     if (!s)
         goto fail;
+    s->ctx = ctx;
     s->promise_state = JS_PROMISE_PENDING;
     s->is_handled = FALSE;
     for(i = 0; i < 2; i++)
@@ -46664,7 +46998,7 @@
                 goto fail_reject;
             }
             resolve_element_data[0] = JS_NewBool(ctx, FALSE);
-            resolve_element_data[1] = (JSValueConst)JS_NewInt32(ctx, index);
+            resolve_element_data[1] = JS_NewInt32(ctx, index);
             resolve_element_data[2] = values;
             resolve_element_data[3] = resolving_funcs[is_promise_any];
             resolve_element_data[4] = resolve_element_env;
@@ -47023,7 +47357,7 @@
 {
     JSValueConst func_data[1];
 
-    func_data[0] = (JSValueConst)JS_NewBool(ctx, done);
+    func_data[0] = JS_NewBool(ctx, done);
     return JS_NewCFunctionData(ctx, js_async_from_sync_iterator_unwrap,
                                1, 0, 1, func_data);
 }
@@ -47328,7 +47662,7 @@
     return c < 0x100 && memchr(";/?:@&=+$,#", c, sizeof(";/?:@&=+$,#") - 1) != NULL;
 }
 
-static int __attribute__((format(printf, 2, 3))) js_throw_URIError(JSContext *ctx, const char *fmt, ...)
+static int PLATFORM_PRINTF_LIKE(2, 3) js_throw_URIError(JSContext *ctx, const char *fmt, ...)
 {
     va_list ap;
 
@@ -47601,7 +47935,7 @@
     JS_CFUNC_MAGIC_DEF("encodeURIComponent", 1, js_global_encodeURI, 1 ),
     JS_CFUNC_DEF("escape", 1, js_global_escape ),
     JS_CFUNC_DEF("unescape", 1, js_global_unescape ),
-    JS_PROP_DOUBLE_DEF("Infinity", 1.0 / 0.0, 0 ),
+    JS_PROP_DOUBLE_DEF("Infinity", INFINITY, 0 ),
     JS_PROP_DOUBLE_DEF("NaN", NAN, 0 ),
     JS_PROP_UNDEFINED_DEF("undefined", 0 ),
 
@@ -48068,7 +48402,7 @@
 static int string_get_digits(JSString *sp, int *pp, int64_t *pval) {
     int64_t v = 0;
     int c, p = *pp, p_start;
-    
+
     if (p >= sp->len)
         return -1;
     p_start = p;
@@ -48090,14 +48424,14 @@
 
 static int string_get_signed_digits(JSString *sp, int *pp, int64_t *pval) {
     int res, sgn, p = *pp;
-    
+
     if (p >= sp->len)
         return -1;
 
     sgn = string_get(sp, p);
     if (sgn == '-' || sgn == '+')
         p++;
- 
+
     res = string_get_digits(sp, &p, pval);
     if (res == 0 && sgn == '-')
         *pval = -*pval;
@@ -48851,7 +49185,6 @@
     js_operators_set_default(ctx, ctx->class_proto[JS_CLASS_BIG_FLOAT]);
     js_operators_set_default(ctx, ctx->class_proto[JS_CLASS_BIG_DECIMAL]);
 }
-#endif /* CONFIG_BIGNUM */
 
 /* BigInt */
 
@@ -48869,17 +49202,11 @@
     case JS_TAG_BIG_INT:
         break;
     case JS_TAG_FLOAT64:
-#ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_FLOAT:
-#endif        
         {
             bf_t *a, a_s;
             
             a = JS_ToBigFloat(ctx, &a_s, val);
-            if (!a) {
-                JS_FreeValue(ctx, val);
-                return JS_EXCEPTION;
-            }
             if (!bf_is_finite(a)) {
                 JS_FreeValue(ctx, val);
                 val = JS_ThrowRangeError(ctx, "cannot convert NaN or Infinity to bigint");
@@ -48909,13 +49236,11 @@
                 bf_delete(a);
         }
         break;
-#ifdef CONFIG_BIGNUM
     case JS_TAG_BIG_DECIMAL:
         val = JS_ToStringFree(ctx, val);
          if (JS_IsException(val))
             break;
         goto redo;
-#endif        
     case JS_TAG_STRING:
         val = JS_StringToBigIntErr(ctx, val);
         break;
@@ -48988,7 +49313,6 @@
     return js_thisBigIntValue(ctx, this_val);
 }
 
-#ifdef CONFIG_BIGNUM
 static JSValue js_bigint_div(JSContext *ctx,
                               JSValueConst this_val,
                               int argc, JSValueConst *argv, int magic)
@@ -49117,7 +49441,6 @@
     JS_FreeBigInt(ctx, a, &a_s);
     return JS_NewBigInt64(ctx, res);
 }
-#endif
 
 static JSValue js_bigint_asUintN(JSContext *ctx,
                                   JSValueConst this_val,
@@ -49162,7 +49485,6 @@
 static const JSCFunctionListEntry js_bigint_funcs[] = {
     JS_CFUNC_MAGIC_DEF("asUintN", 2, js_bigint_asUintN, 0 ),
     JS_CFUNC_MAGIC_DEF("asIntN", 2, js_bigint_asUintN, 1 ),
-#ifdef CONFIG_BIGNUM
     /* QuickJS extensions */
     JS_CFUNC_MAGIC_DEF("tdiv", 2, js_bigint_div, BF_RNDZ ),
     JS_CFUNC_MAGIC_DEF("fdiv", 2, js_bigint_div, BF_RNDD ),
@@ -49176,7 +49498,6 @@
     JS_CFUNC_MAGIC_DEF("sqrtrem", 1, js_bigint_sqrt, 1 ),
     JS_CFUNC_MAGIC_DEF("floorLog2", 1, js_bigint_op1, 0 ),
     JS_CFUNC_MAGIC_DEF("ctz", 1, js_bigint_op1, 1 ),
-#endif    
 };
 
 static const JSCFunctionListEntry js_bigint_proto_funcs[] = {
@@ -49195,7 +49516,7 @@
     rt->bigint_ops.unary_arith = js_unary_arith_bigint;
     rt->bigint_ops.binary_arith = js_binary_arith_bigint;
     rt->bigint_ops.compare = js_compare_bigfloat;
-
+    
     ctx->class_proto[JS_CLASS_BIG_INT] = JS_NewObject(ctx);
     JS_SetPropertyFunctionList(ctx, ctx->class_proto[JS_CLASS_BIG_INT],
                                js_bigint_proto_funcs,
@@ -49206,8 +49527,6 @@
                                countof(js_bigint_funcs));
 }
 
-#ifdef CONFIG_BIGNUM
-
 /* BigFloat */
 
 static JSValue js_thisBigFloatValue(JSContext *ctx, JSValueConst this_val)
@@ -49681,10 +50000,6 @@
     if (JS_IsException(op1))
         return op1;
     a = JS_ToBigFloat(ctx, &a_s, op1);
-    if (!a) {
-        JS_FreeValue(ctx, op1);
-        return JS_EXCEPTION;
-    }
     fe = &ctx->fp_env;
     if (argc > 1) {
         fe = JS_GetOpaque2(ctx, argv[1], JS_CLASS_FLOAT_ENV);
@@ -49783,11 +50098,7 @@
         return op2;
     }
     a = JS_ToBigFloat(ctx, &a_s, op1);
-    if (!a)
-        goto fail1;
     b = JS_ToBigFloat(ctx, &b_s, op2);
-    if (!b)
-        goto fail2;
     fe = &ctx->fp_env;
     if (argc > 2) {
         fe = JS_GetOpaque2(ctx, argv[2], JS_CLASS_FLOAT_ENV);
@@ -49797,12 +50108,10 @@
     res = JS_NewBigFloat(ctx);
     if (JS_IsException(res)) {
     fail:
-        if (b == &b_s)
-            bf_delete(b);
-    fail2:
         if (a == &a_s)
             bf_delete(a);
-    fail1:
+        if (b == &b_s)
+            bf_delete(b);
         JS_FreeValue(ctx, op1);
         JS_FreeValue(ctx, op2);
         return JS_EXCEPTION;
@@ -50876,7 +51185,9 @@
 
 static uint8_t const typed_array_size_log2[JS_TYPED_ARRAY_COUNT] = {
     0, 0, 0, 1, 1, 2, 2,
+#ifdef CONFIG_BIGNUM
     3, 3, /* BigInt64Array, BigUint64Array */
+#endif
     2, 3
 };
 
@@ -51437,32 +51748,6 @@
     return JS_EXCEPTION;
 }
 
-static JSValue js_typed_array_at(JSContext *ctx, JSValueConst this_val,
-                                 int argc, JSValueConst *argv)
-{
-    JSObject *p;
-    int64_t idx, len;
-
-    p = get_typed_array(ctx, this_val, 0);
-    if (!p)
-        return JS_EXCEPTION;
-
-    if (typed_array_is_detached(ctx, p)) {
-        JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
-        return JS_EXCEPTION;
-    }
-
-    if (JS_ToInt64Sat(ctx, &idx, argv[0]))
-        return JS_EXCEPTION;
-
-    len = p->u.array.count;
-    if (idx < 0)
-        idx = len + idx;
-    if (idx < 0 || idx >= len)
-        return JS_UNDEFINED;
-    return JS_GetPropertyUint32(ctx, this_val, idx);
-}
-
 static JSValue js_typed_array_set(JSContext *ctx,
                                   JSValueConst this_val,
                                   int argc, JSValueConst *argv)
@@ -51752,10 +52037,14 @@
         if (JS_ToUint32(ctx, &v, argv[0]))
             return JS_EXCEPTION;
         v64 = v;
-    } else if (p->class_id <= JS_CLASS_BIG_UINT64_ARRAY) {
+    } else
+#ifdef CONFIG_BIGNUM
+    if (p->class_id <= JS_CLASS_BIG_UINT64_ARRAY) {
         if (JS_ToBigInt64(ctx, (int64_t *)&v64, argv[0]))
             return JS_EXCEPTION;
-    } else {
+    } else
+#endif
+    {
         double d;
         if (JS_ToFloat64(ctx, &d, argv[0]))
             return JS_EXCEPTION;
@@ -51928,7 +52217,7 @@
             res = 0;
         goto done;
     }
-    
+
     is_bigint = 0;
     is_int = 0; /* avoid warning */
     v64 = 0; /* avoid warning */
@@ -51942,7 +52231,9 @@
         d = JS_VALUE_GET_FLOAT64(argv[0]);
         v64 = d;
         is_int = (v64 == d);
-    } else if (tag == JS_TAG_BIG_INT) {
+    } else
+#ifdef CONFIG_BIGNUM
+    if (tag == JS_TAG_BIG_INT) {
         JSBigFloat *p1 = JS_VALUE_GET_PTR(argv[0]);
         
         if (p->class_id == JS_CLASS_BIG_INT64_ARRAY) {
@@ -51956,7 +52247,9 @@
         }
         d = 0;
         is_bigint = 1;
-    } else {
+    } else
+#endif
+    {
         goto done;
     }
 
@@ -52073,6 +52366,7 @@
             }
         }
         break;
+#ifdef CONFIG_BIGNUM
     case JS_CLASS_BIG_INT64_ARRAY:
         if (is_bigint || (is_math_mode(ctx) && is_int &&
                           v64 >= -MAX_SAFE_INTEGER &&
@@ -52096,6 +52390,7 @@
             }
         }
         break;
+#endif
     }
 
 done:
@@ -52376,6 +52671,7 @@
     return (y < x) - (y > x);
 }
 
+#ifdef CONFIG_BIGNUM
 static int js_TA_cmp_int64(const void *a, const void *b, void *opaque) {
     int64_t x = *(const int64_t *)a;
     int64_t y = *(const int64_t *)b;
@@ -52387,6 +52683,7 @@
     uint64_t y = *(const uint64_t *)b;
     return (y < x) - (y > x);
 }
+#endif
 
 static int js_TA_cmp_float32(const void *a, const void *b, void *opaque) {
     return js_cmp_doubles(*(const float *)a, *(const float *)b);
@@ -52420,6 +52717,7 @@
     return JS_NewUint32(ctx, *(const uint32_t *)a);
 }
 
+#ifdef CONFIG_BIGNUM
 static JSValue js_TA_get_int64(JSContext *ctx, const void *a) {
     return JS_NewBigInt64(ctx, *(int64_t *)a);
 }
@@ -52427,6 +52725,7 @@
 static JSValue js_TA_get_uint64(JSContext *ctx, const void *a) {
     return JS_NewBigUint64(ctx, *(uint64_t *)a);
 }
+#endif
 
 static JSValue js_TA_get_float32(JSContext *ctx, const void *a) {
     return __JS_NewFloat64(ctx, *(const float *)a);
@@ -52487,8 +52786,8 @@
             psc->exception = 1;
         }
     done:
-        JS_FreeValue(ctx, (JSValue)argv[0]);
-        JS_FreeValue(ctx, (JSValue)argv[1]);
+        JS_FreeValue(ctx, argv[0]);
+        JS_FreeValue(ctx, argv[1]);
     }
     return cmp;
 }
@@ -52542,6 +52841,7 @@
             tsc.getfun = js_TA_get_uint32;
             cmpfun = js_TA_cmp_uint32;
             break;
+#ifdef CONFIG_BIGNUM
         case JS_CLASS_BIG_INT64_ARRAY:
             tsc.getfun = js_TA_get_int64;
             cmpfun = js_TA_cmp_int64;
@@ -52550,6 +52850,7 @@
             tsc.getfun = js_TA_get_uint64;
             cmpfun = js_TA_cmp_uint64;
             break;
+#endif
         case JS_CLASS_FLOAT32_ARRAY:
             tsc.getfun = js_TA_get_float32;
             cmpfun = js_TA_cmp_float32;
@@ -52637,7 +52938,6 @@
 
 static const JSCFunctionListEntry js_typed_array_base_proto_funcs[] = {
     JS_CGETSET_DEF("length", js_typed_array_get_length, NULL ),
-    JS_CFUNC_DEF("at", 1, js_typed_array_at ),
     JS_CGETSET_MAGIC_DEF("buffer", js_typed_array_get_buffer, NULL, 0 ),
     JS_CGETSET_MAGIC_DEF("byteLength", js_typed_array_get_byteLength, NULL, 0 ),
     JS_CGETSET_MAGIC_DEF("byteOffset", js_typed_array_get_byteOffset, NULL, 0 ),
@@ -53075,6 +53375,7 @@
         if (is_swap)
             v = bswap32(v);
         return JS_NewUint32(ctx, v);
+#ifdef CONFIG_BIGNUM
     case JS_CLASS_BIG_INT64_ARRAY:
         {
             uint64_t v;
@@ -53093,6 +53394,7 @@
             return JS_NewBigUint64(ctx, v);
         }
         break;
+#endif
     case JS_CLASS_FLOAT32_ARRAY:
         {
             union {
@@ -53146,10 +53448,14 @@
     if (class_id <= JS_CLASS_UINT32_ARRAY) {
         if (JS_ToUint32(ctx, &v, val))
             return JS_EXCEPTION;
-    } else if (class_id <= JS_CLASS_BIG_UINT64_ARRAY) {
+    } else
+#ifdef CONFIG_BIGNUM
+    if (class_id <= JS_CLASS_BIG_UINT64_ARRAY) {
         if (JS_ToBigInt64(ctx, (int64_t *)&v64, val))
             return JS_EXCEPTION;
-    } else {
+    } else
+#endif
+    {
         double d;
         if (JS_ToFloat64(ctx, &d, val))
             return JS_EXCEPTION;
@@ -53197,8 +53503,10 @@
             v = bswap32(v);
         put_u32(ptr, v);
         break;
+#ifdef CONFIG_BIGNUM
     case JS_CLASS_BIG_INT64_ARRAY:
     case JS_CLASS_BIG_UINT64_ARRAY:
+#endif
     case JS_CLASS_FLOAT64_ARRAY:
         if (is_swap)
             v64 = bswap64(v64);
@@ -53220,8 +53528,10 @@
     JS_CFUNC_MAGIC_DEF("getUint16", 1, js_dataview_getValue, JS_CLASS_UINT16_ARRAY ),
     JS_CFUNC_MAGIC_DEF("getInt32", 1, js_dataview_getValue, JS_CLASS_INT32_ARRAY ),
     JS_CFUNC_MAGIC_DEF("getUint32", 1, js_dataview_getValue, JS_CLASS_UINT32_ARRAY ),
+#ifdef CONFIG_BIGNUM
     JS_CFUNC_MAGIC_DEF("getBigInt64", 1, js_dataview_getValue, JS_CLASS_BIG_INT64_ARRAY ),
     JS_CFUNC_MAGIC_DEF("getBigUint64", 1, js_dataview_getValue, JS_CLASS_BIG_UINT64_ARRAY ),
+#endif
     JS_CFUNC_MAGIC_DEF("getFloat32", 1, js_dataview_getValue, JS_CLASS_FLOAT32_ARRAY ),
     JS_CFUNC_MAGIC_DEF("getFloat64", 1, js_dataview_getValue, JS_CLASS_FLOAT64_ARRAY ),
     JS_CFUNC_MAGIC_DEF("setInt8", 2, js_dataview_setValue, JS_CLASS_INT8_ARRAY ),
@@ -53230,8 +53540,10 @@
     JS_CFUNC_MAGIC_DEF("setUint16", 2, js_dataview_setValue, JS_CLASS_UINT16_ARRAY ),
     JS_CFUNC_MAGIC_DEF("setInt32", 2, js_dataview_setValue, JS_CLASS_INT32_ARRAY ),
     JS_CFUNC_MAGIC_DEF("setUint32", 2, js_dataview_setValue, JS_CLASS_UINT32_ARRAY ),
+#ifdef CONFIG_BIGNUM
     JS_CFUNC_MAGIC_DEF("setBigInt64", 2, js_dataview_setValue, JS_CLASS_BIG_INT64_ARRAY ),
     JS_CFUNC_MAGIC_DEF("setBigUint64", 2, js_dataview_setValue, JS_CLASS_BIG_UINT64_ARRAY ),
+#endif
     JS_CFUNC_MAGIC_DEF("setFloat32", 2, js_dataview_setValue, JS_CLASS_FLOAT32_ARRAY ),
     JS_CFUNC_MAGIC_DEF("setFloat64", 2, js_dataview_setValue, JS_CLASS_FLOAT64_ARRAY ),
     JS_PROP_STRING_DEF("[Symbol.toStringTag]", "DataView", JS_PROP_CONFIGURABLE ),
@@ -53268,12 +53580,20 @@
     if (JS_VALUE_GET_TAG(obj) != JS_TAG_OBJECT)
         goto fail;
     p = JS_VALUE_GET_OBJ(obj);
+#ifdef CONFIG_BIGNUM
     if (is_waitable)
         err = (p->class_id != JS_CLASS_INT32_ARRAY &&
                p->class_id != JS_CLASS_BIG_INT64_ARRAY);
     else
         err = !(p->class_id >= JS_CLASS_INT8_ARRAY &&
                 p->class_id <= JS_CLASS_BIG_UINT64_ARRAY);
+#else
+    if (is_waitable)
+        err = (p->class_id != JS_CLASS_INT32_ARRAY);
+    else
+        err = !(p->class_id >= JS_CLASS_INT8_ARRAY &&
+                p->class_id <= JS_CLASS_UINT32_ARRAY);
+#endif
     if (err) {
     fail:
         JS_ThrowTypeError(ctx, "integer TypedArray expected");
@@ -53315,7 +53635,11 @@
                              int argc, JSValueConst *argv, int op)
 {
     int size_log2;
+#ifdef CONFIG_BIGNUM
     uint64_t v, a, rep_val;
+#else
+    uint32_t v, a, rep_val;
+#endif
     void *ptr;
     JSValue ret;
     JSClassID class_id;
@@ -53329,6 +53653,7 @@
     if (op == ATOMICS_OP_LOAD) {
         v = 0;
     } else {
+#ifdef CONFIG_BIGNUM
         if (size_log2 == 3) {
             int64_t v64;
             if (JS_ToBigInt64(ctx, &v64, argv[2]))
@@ -53339,7 +53664,9 @@
                     return JS_EXCEPTION;
                 rep_val = v64;
             }
-        } else {
+        } else
+#endif
+        {
                 uint32_t v32;
                 if (JS_ToUint32(ctx, &v32, argv[2]))
                     return JS_EXCEPTION;
@@ -53356,6 +53683,7 @@
 
    switch(op | (size_log2 << 3)) {
             
+#ifdef CONFIG_BIGNUM
 #define OP(op_name, func_name)                          \
     case ATOMICS_OP_ ## op_name | (0 << 3):             \
        a = func_name((_Atomic(uint8_t) *)ptr, v);       \
@@ -53369,7 +53697,18 @@
     case ATOMICS_OP_ ## op_name | (3 << 3):             \
         a = func_name((_Atomic(uint64_t) *)ptr, v);     \
         break;
-       
+#else
+#define OP(op_name, func_name)                          \
+    case ATOMICS_OP_ ## op_name | (0 << 3):             \
+       a = func_name((_Atomic(uint8_t) *)ptr, v);       \
+       break;                                           \
+    case ATOMICS_OP_ ## op_name | (1 << 3):             \
+        a = func_name((_Atomic(uint16_t) *)ptr, v);     \
+        break;                                          \
+    case ATOMICS_OP_ ## op_name | (2 << 3):             \
+        a = func_name((_Atomic(uint32_t) *)ptr, v);     \
+        break;
+#endif
         OP(ADD, atomic_fetch_add)
         OP(AND, atomic_fetch_and)
         OP(OR, atomic_fetch_or)
@@ -53387,9 +53726,11 @@
     case ATOMICS_OP_LOAD | (2 << 3):
         a = atomic_load((_Atomic(uint32_t) *)ptr);
         break;
+#ifdef CONFIG_BIGNUM
     case ATOMICS_OP_LOAD | (3 << 3):
         a = atomic_load((_Atomic(uint64_t) *)ptr);
         break;
+#endif
         
     case ATOMICS_OP_COMPARE_EXCHANGE | (0 << 3):
         {
@@ -53412,6 +53753,7 @@
             a = v1;
         }
         break;
+#ifdef CONFIG_BIGNUM
     case ATOMICS_OP_COMPARE_EXCHANGE | (3 << 3):
         {
             uint64_t v1 = v;
@@ -53419,6 +53761,7 @@
             a = v1;
         }
         break;
+#endif
     default:
         abort();
     }
@@ -53443,12 +53786,14 @@
     case JS_CLASS_UINT32_ARRAY:
         ret = JS_NewUint32(ctx, a);
         break;
+#ifdef CONFIG_BIGNUM
     case JS_CLASS_BIG_INT64_ARRAY:
         ret = JS_NewBigInt64(ctx, a);
         break;
     case JS_CLASS_BIG_UINT64_ARRAY:
         ret = JS_NewBigUint64(ctx, a);
         break;
+#endif
     default:
         abort();
     }
@@ -53468,6 +53813,7 @@
                              argv[0], argv[1], 0);
     if (!ptr)
         return JS_EXCEPTION;
+#ifdef CONFIG_BIGNUM
     if (size_log2 == 3) {
         int64_t v64;
         ret = JS_ToBigIntValueFree(ctx, JS_DupValue(ctx, argv[2]));
@@ -53480,7 +53826,9 @@
         if (abuf->detached)
             return JS_ThrowTypeErrorDetachedArrayBuffer(ctx);
         atomic_store((_Atomic(uint64_t) *)ptr, v64);
-    } else {
+    } else
+#endif
+    {
         uint32_t v;
         /* XXX: spec, would be simpler to return the written value */
         ret = JS_ToIntegerFree(ctx, JS_DupValue(ctx, argv[2]));
@@ -53516,7 +53864,11 @@
     int v, ret;
     if (JS_ToInt32Sat(ctx, &v, argv[0]))
         return JS_EXCEPTION;
-    ret = (v == 1 || v == 2 || v == 4 || v == 8);
+    ret = (v == 1 || v == 2 || v == 4
+#ifdef CONFIG_BIGNUM
+           || v == 8
+#endif
+           );
     return JS_NewBool(ctx, ret);
 }
 
@@ -53548,10 +53900,13 @@
                              argv[0], argv[1], 2);
     if (!ptr)
         return JS_EXCEPTION;
+#ifdef CONFIG_BIGNUM
     if (size_log2 == 3) {
         if (JS_ToBigInt64(ctx, &v, argv[2]))
             return JS_EXCEPTION;
-    } else {        
+    } else
+#endif
+    {        
         if (JS_ToInt32(ctx, &v32, argv[2]))
             return JS_EXCEPTION;
         v = v32;
@@ -53773,3 +54128,4 @@
     JS_AddIntrinsicAtomics(ctx);
 #endif
 }
+
Index: quickjs-src/quickjs/libbf.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/libbf.h b/quickjs-src/quickjs/src/libbf.h
rename from quickjs-src/quickjs/libbf.h
rename to quickjs-src/quickjs/src/libbf.h
--- a/quickjs-src/quickjs/libbf.h	(revision 321dbfa770463b8867d8ac90493c7cec015a9c3a)
+++ b/quickjs-src/quickjs/src/libbf.h	(date 1696647929598)
@@ -24,10 +24,15 @@
 #ifndef LIBBF_H
 #define LIBBF_H
 
+#include "quickjs-defs.h"
 #include <stddef.h>
 #include <stdint.h>
 
-#if INTPTR_MAX >= INT64_MAX
+#if _MSC_VER
+#undef __AVX2__
+#endif
+
+#if INTPTR_MAX >= INT64_MAX && __AVX2__
 #define LIMB_LOG2_BITS 6
 #else
 #define LIMB_LOG2_BITS 5
Index: quickjs-src/quickjs/src/libregexp.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/src/libregexp.h b/quickjs-src/quickjs/src/libregexp.h
new file mode 100644
--- /dev/null	(date 1696647929598)
+++ b/quickjs-src/quickjs/src/libregexp.h	(date 1696647929598)
@@ -0,0 +1,92 @@
+/*
+ * Regular Expression Engine
+ * 
+ * Copyright (c) 2017-2018 Fabrice Bellard
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+#ifndef LIBREGEXP_H
+#define LIBREGEXP_H
+
+#include <stddef.h>
+
+#include "libunicode.h"
+
+#define LRE_BOOL  int       /* for documentation purposes */
+
+#define LRE_FLAG_GLOBAL     (1 << 0)
+#define LRE_FLAG_IGNORECASE (1 << 1)
+#define LRE_FLAG_MULTILINE  (1 << 2)
+#define LRE_FLAG_DOTALL     (1 << 3)
+#define LRE_FLAG_UTF16      (1 << 4)
+#define LRE_FLAG_STICKY     (1 << 5)
+
+#define LRE_FLAG_NAMED_GROUPS (1 << 7) /* named groups are present in the regexp */
+
+uint8_t *lre_compile(int *plen, char *error_msg, int error_msg_size,
+                     const char *buf, size_t buf_len, int re_flags,
+                     void *opaque);
+int lre_get_capture_count(const uint8_t *bc_buf);
+int lre_get_flags(const uint8_t *bc_buf);
+const char *lre_get_groupnames(const uint8_t *bc_buf);
+int lre_exec(uint8_t **capture,
+             const uint8_t *bc_buf, const uint8_t *cbuf, int cindex, int clen,
+             int cbuf_type, void *opaque);
+
+int lre_parse_escape(const uint8_t **pp, int allow_utf16);
+LRE_BOOL lre_is_space(int c);
+
+/* must be provided by the user */
+LRE_BOOL lre_check_stack_overflow(void *opaque, size_t alloca_size); 
+void *lre_realloc(void *opaque, void *ptr, size_t size);
+
+/* JS identifier test */
+extern uint32_t const lre_id_start_table_ascii[4];
+extern uint32_t const lre_id_continue_table_ascii[4];
+
+static inline int lre_js_is_ident_first(int c)
+{
+    if ((uint32_t)c < 128) {
+        return (lre_id_start_table_ascii[c >> 5] >> (c & 31)) & 1;
+    } else {
+#ifdef CONFIG_ALL_UNICODE
+        return lre_is_id_start(c);
+#else
+        return !lre_is_space(c);
+#endif
+    }
+}
+
+static inline int lre_js_is_ident_next(int c)
+{
+    if ((uint32_t)c < 128) {
+        return (lre_id_continue_table_ascii[c >> 5] >> (c & 31)) & 1;
+    } else {
+        /* ZWNJ and ZWJ are accepted in identifiers */
+#ifdef CONFIG_ALL_UNICODE
+        return lre_is_id_continue(c) || c == 0x200C || c == 0x200D;
+#else
+        return !lre_is_space(c) || c == 0x200C || c == 0x200D;
+#endif
+    }
+}
+
+#undef LRE_BOOL
+
+#endif /* LIBREGEXP_H */
Index: quickjs-src/quickjs/libregexp.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/libregexp.c b/quickjs-src/quickjs/src/libregexp.c
rename from quickjs-src/quickjs/libregexp.c
rename to quickjs-src/quickjs/src/libregexp.c
--- a/quickjs-src/quickjs/libregexp.c	(revision 321dbfa770463b8867d8ac90493c7cec015a9c3a)
+++ b/quickjs-src/quickjs/src/libregexp.c	(date 1696647929598)
@@ -427,7 +427,7 @@
     dbuf_put_u16(&s->byte_code, val);
 }
 
-static int __attribute__((format(printf, 2, 3))) re_parse_error(REParseState *s, const char *fmt, ...)
+static int PLATFORM_PRINTF_LIKE(2, 3) re_parse_error(REParseState *s, const char *fmt, ...)
 {
     va_list ap;
     va_start(ap, fmt);
Index: quickjs-src/quickjs/quickjs-atom.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/quickjs-atom.h b/quickjs-src/quickjs/src/quickjs-atom.h
rename from quickjs-src/quickjs/quickjs-atom.h
rename to quickjs-src/quickjs/src/quickjs-atom.h
--- a/quickjs-src/quickjs/quickjs-atom.h	(revision 321dbfa770463b8867d8ac90493c7cec015a9c3a)
+++ b/quickjs-src/quickjs/src/quickjs-atom.h	(date 1696647929599)
@@ -169,8 +169,8 @@
 DEF(status, "status")
 DEF(reason, "reason")
 DEF(globalThis, "globalThis")
-DEF(bigint, "bigint")
 #ifdef CONFIG_BIGNUM
+DEF(bigint, "bigint")
 DEF(bigfloat, "bigfloat")
 DEF(bigdecimal, "bigdecimal")
 DEF(roundingMode, "roundingMode")
@@ -209,13 +209,15 @@
 DEF(Uint16Array, "Uint16Array")
 DEF(Int32Array, "Int32Array")
 DEF(Uint32Array, "Uint32Array")
+#ifdef CONFIG_BIGNUM
 DEF(BigInt64Array, "BigInt64Array")
 DEF(BigUint64Array, "BigUint64Array")
+#endif
 DEF(Float32Array, "Float32Array")
 DEF(Float64Array, "Float64Array")
 DEF(DataView, "DataView")
+#ifdef CONFIG_BIGNUM
 DEF(BigInt, "BigInt")
-#ifdef CONFIG_BIGNUM
 DEF(BigFloat, "BigFloat")
 DEF(BigFloatEnv, "BigFloatEnv")
 DEF(BigDecimal, "BigDecimal")
Index: opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/convolution.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/convolution.hpp b/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/convolution.hpp
--- a/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/convolution.hpp	(revision 5199850039ad23f1f0e6cccea5061a9fea5efca6)
+++ b/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/convolution.hpp	(date 1701848687872)
@@ -63,7 +63,7 @@
     float* weightsWinoBufPtr;
     std::vector<float> biasBuf;
 
-#if CV_NEON && CV_NEON_AARCH64 && CV_FP16
+#if CONV_ARM_FP16
     std::vector<float16_t> weightsBuf_FP16;
     float16_t* weightsBufPtr_FP16;
     std::vector<float16_t> weightsWinoBuf_FP16;
Index: quickjs-src/quickjs/include/quickjspp.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/include/quickjspp.hpp b/quickjs-src/quickjs/include/quickjspp.hpp
new file mode 100644
--- /dev/null	(date 1696647929596)
+++ b/quickjs-src/quickjs/include/quickjspp.hpp	(date 1696647929596)
@@ -0,0 +1,2232 @@
+#pragma once
+
+#include "quickjs/quickjs.h"
+
+#include <vector>
+#include <string_view>
+#include <string>
+#include <cassert>
+#include <memory>
+#include <cstddef>
+#include <algorithm>
+#include <tuple>
+#include <functional>
+#include <stdexcept>
+#include <variant>
+#include <optional>
+#include <type_traits>
+#include <unordered_map>
+#include <fstream>
+#include <ios>
+#include <sstream>
+#include <filesystem>
+
+
+#if defined(__cpp_rtti)
+#define QJSPP_TYPENAME(...) (typeid(__VA_ARGS__).name())
+#else
+#define QJSPP_TYPENAME(...) #__VA_ARGS__
+#endif
+
+
+namespace qjs {
+
+class Context;
+class Value;
+
+/** Exception type.
+ * Indicates that exception has occured in JS context.
+ */
+class exception {
+    JSContext * ctx;
+public:
+    exception(JSContext * ctx) : ctx(ctx) {}
+    Context & context() const;
+
+    /// Clears and returns the occurred exception.
+    Value get();
+};
+
+/** std::shared_ptr, for compatibility with quickjspp v2. */
+template <class T> using shared_ptr = std::shared_ptr<T>;
+/** std::make_shared, for compatibility with quickjspp v2. */
+template <class T, typename... Args>
+shared_ptr<T> make_shared(JSContext *, Args&&... args)
+{
+    return std::make_shared<T>(std::forward<Args>(args)...);
+}
+
+/** Javascript conversion traits.
+ * Describes how to convert type R to/from JSValue. Second template argument can be used for SFINAE/enable_if type filters.
+ */
+template <typename R, typename /*_SFINAE*/ = void>
+struct js_traits
+{
+    /** Create an object of C++ type R given JSValue v and JSContext.
+     * This function is intentionally not implemented. User should implement this function for their own type.
+     * @param v This value is passed as JSValueConst so it should be freed by the caller.
+     * @throws exception in case of conversion error
+     */
+    static R unwrap(JSContext * ctx, JSValueConst v) = delete;
+
+    /** Create JSValue from an object of type R and JSContext.
+     * This function is intentionally not implemented. User should implement this function for their own type.
+     * @return Returns JSValue which should be freed by the caller or JS_EXCEPTION in case of error.
+     */
+    static JSValue wrap(JSContext * ctx, R value) = delete;
+};
+
+/** Conversion traits for JSValue (identity).
+ */
+template <>
+struct js_traits<JSValue>
+{
+    static JSValue unwrap(JSContext * ctx, JSValueConst v) noexcept
+    {
+        return JS_DupValue(ctx, v);
+    }
+
+    static JSValue wrap(JSContext * ctx, JSValue&& v) noexcept
+    {
+        return v;
+    }
+};
+
+/** Conversion traits for integers.
+ * Intentionally doesn't define traits for uint64_t since it can be typedefed to JSValue. (@see JS_NAN_BOXING)
+ */
+template <typename Int>
+struct js_traits<Int, std::enable_if_t<std::is_integral_v<Int> && sizeof(Int) <= sizeof(int64_t) && !std::is_same_v<Int, uint64_t>>>
+{
+    /// @throws exception
+    static Int unwrap(JSContext * ctx, JSValueConst v)
+    {
+        if constexpr (sizeof(Int) > sizeof(int32_t))
+        {
+            int64_t r;
+            if(JS_ToInt64(ctx, &r, v))
+                throw exception{ctx};
+            return static_cast<Int>(r);
+        }
+        else
+        {
+            int32_t r;
+            if(JS_ToInt32(ctx, &r, v))
+                throw exception{ctx};
+            return static_cast<Int>(r);
+        }
+    }
+
+    static JSValue wrap(JSContext * ctx, Int i) noexcept
+    {
+        if constexpr (std::is_same_v<Int, uint32_t> || sizeof(Int) > sizeof(int32_t))
+            return JS_NewInt64(ctx, static_cast<Int>(i));
+        else
+            return JS_NewInt32(ctx, static_cast<Int>(i));
+    }
+};
+
+/** Conversion traits for boolean.
+ */
+template <>
+struct js_traits<bool>
+{
+    static bool unwrap(JSContext * ctx, JSValueConst v) noexcept
+    {
+        // TODO: is this behaviour correct?
+        return JS_ToBool(ctx, v) > 0;
+    }
+
+    static JSValue wrap(JSContext * ctx, bool i) noexcept
+    {
+        return JS_NewBool(ctx, i);
+    }
+};
+
+/** Conversion trait for void.
+ */
+template <>
+struct js_traits<void>
+{
+    /// @throws exception if jsvalue is neither undefined nor null
+    static void unwrap(JSContext * ctx, JSValueConst value)
+    {
+        if(JS_IsException(value))
+            throw exception{ctx};
+    }
+};
+
+/** Conversion traits for float64/double.
+ */
+template <>
+struct js_traits<double>
+{
+    /// @throws exception
+    static double unwrap(JSContext * ctx, JSValueConst v)
+    {
+        double r;
+        if(JS_ToFloat64(ctx, &r, v))
+            throw exception{ctx};
+        return r;
+    }
+
+    static JSValue wrap(JSContext * ctx, double i) noexcept
+    {
+        return JS_NewFloat64(ctx, i);
+    }
+};
+
+namespace detail {
+/** Fake std::string_view which frees the string on destruction.
+*/
+class js_string : public std::string_view
+{
+    using Base = std::string_view;
+    JSContext * ctx = nullptr;
+
+    friend struct js_traits<std::string_view>;
+
+    js_string(JSContext * ctx, const char * ptr, std::size_t len) : Base(ptr, len), ctx(ctx) {}
+
+public:
+
+    template <typename... Args>
+    js_string(Args&& ... args) : Base(std::forward<Args>(args)...), ctx(nullptr) {}
+
+    js_string(const js_string& other) = delete;
+
+    operator const char *() const
+    {
+        return this->data();
+    }
+
+    ~js_string()
+    {
+        if(ctx)
+            JS_FreeCString(ctx, this->data());
+    }
+};
+} // namespace detail
+
+/** Conversion traits from std::string_view and to detail::js_string. */
+template <>
+struct js_traits<std::string_view>
+{
+    static detail::js_string unwrap(JSContext * ctx, JSValueConst v)
+    {
+        size_t plen;
+        const char * ptr = JS_ToCStringLen(ctx, &plen, v);
+        if(!ptr)
+            throw exception{ctx};
+        return detail::js_string{ctx, ptr, plen};
+    }
+
+    static JSValue wrap(JSContext * ctx, std::string_view str) noexcept
+    {
+        return JS_NewStringLen(ctx, str.data(), str.size());
+    }
+};
+
+/** Conversion traits for std::string */
+template <> // slower
+struct js_traits<std::string>
+{
+    static std::string unwrap(JSContext * ctx, JSValueConst v)
+    {
+        auto str_view = js_traits<std::string_view>::unwrap(ctx, v);
+        return std::string{str_view.data(), str_view.size()};
+    }
+
+    static JSValue wrap(JSContext * ctx, const std::string& str) noexcept
+    {
+        return JS_NewStringLen(ctx, str.data(), str.size());
+    }
+};
+
+/** Conversion from const char * */
+template <>
+struct js_traits<const char *>
+{
+    static JSValue wrap(JSContext * ctx, const char * str) noexcept
+    {
+        return JS_NewString(ctx, str);
+    }
+
+    static detail::js_string unwrap(JSContext * ctx, JSValueConst v)
+    {
+        return js_traits<std::string_view>::unwrap(ctx, v);
+    }
+};
+
+
+/** Conversion from const std::variant */
+template <typename ... Ts>
+struct js_traits<std::variant<Ts...>>
+{
+    static JSValue wrap(JSContext * ctx, std::variant<Ts...> value) noexcept
+    {
+        return std::visit([ctx](auto&& value) {
+            using T = std::decay_t<decltype(value)>;
+            return js_traits<T>::wrap(ctx, value);
+        }, std::move(value));
+    }
+
+
+    /* Useful type traits */
+    template <typename T> struct is_shared_ptr : std::false_type {};
+    template <typename T> struct is_shared_ptr<std::shared_ptr<T>> : std::true_type {};
+    template <typename T> struct is_string
+    {
+        static constexpr bool value = std::is_same_v<T, const char *> || std::is_same_v<std::decay_t<T>, std::string> ||
+                                      std::is_same_v<std::decay_t<T>, std::string_view>;
+    };
+    template <typename T> struct is_boolean { static constexpr bool value = std::is_same_v<std::decay_t<T>, bool>; };
+    template <typename T> struct is_double { static constexpr bool value = std::is_same_v<std::decay_t<T>, double>; };
+    template <typename T> struct is_vector : std::false_type {};
+    template <typename T> struct is_vector<std::vector<T>> : std::true_type {};
+    template <typename T> struct is_pair : std::false_type {};
+    template <typename U, typename V> struct is_pair<std::pair<U, V>> : std::true_type {};
+    template <typename T> struct is_variant : std::false_type {};
+    template <typename ... Us> struct is_variant<std::variant<Us...>> : std::true_type {};
+
+    /** Attempt to match common types (integral, floating-point, string, etc.) */
+    template <template <typename R> typename Trait, typename U, typename ... Us>
+    static std::optional<std::variant<Ts...>> unwrapImpl(JSContext * ctx, JSValueConst v)
+    {
+        if constexpr (Trait<U>::value)
+        {
+            return js_traits<U>::unwrap(ctx, v);
+        }
+        if constexpr ((sizeof ... (Us)) > 0)
+        {
+            return unwrapImpl<Trait, Us...>(ctx, v);
+        }
+        return std::nullopt;
+    }
+
+    /** Attempt to match class ID with type */
+    template <typename U, typename ... Us>
+    static std::optional<std::variant<Ts...>> unwrapObj(JSContext * ctx, JSValueConst v, JSClassID class_id)
+    {
+        if constexpr (is_shared_ptr<U>::value)
+        {
+            if(class_id == js_traits<U>::QJSClassId)
+            {
+                return js_traits<U>::unwrap(ctx, v);
+            }
+        }
+
+        // try to unwrap embedded variant (variant<variant<...>>), might be slow
+        if constexpr (is_variant<U>::value)
+        {
+            if(auto opt = js_traits<std::optional<U>>::unwrap(ctx, v))
+                return *opt;
+        }
+
+        if constexpr (is_vector<U>::value)
+        {
+            if(JS_IsArray(ctx, v) == 1)
+            {
+                auto firstElement = JS_GetPropertyUint32(ctx, v, 0);
+                bool ok = isCompatible<std::decay_t<typename U::value_type>>(ctx, firstElement);
+                JS_FreeValue(ctx, firstElement);
+                if(ok)
+                {
+                    return U{js_traits<U>::unwrap(ctx, v)};
+                }
+            }
+        }
+
+        if constexpr (is_pair<U>::value)
+        {
+            if(JS_IsArray(ctx, v) == 1)
+            {
+                // todo: check length?
+                auto firstElement = JS_GetPropertyUint32(ctx, v, 0);
+                auto secondElement = JS_GetPropertyUint32(ctx, v, 1);
+                bool ok = isCompatible<std::decay_t<typename U::first_type>>(ctx, firstElement)
+                          && isCompatible<std::decay_t<typename U::second_type>>(ctx, secondElement);
+                JS_FreeValue(ctx, firstElement);
+                JS_FreeValue(ctx, secondElement);
+                if(ok)
+                {
+                    return U{js_traits<U>::unwrap(ctx, v)};
+                }
+            }
+        }
+
+        if constexpr ((sizeof ... (Us)) > 0)
+        {
+            return unwrapObj<Us...>(ctx, v, class_id);
+        }
+        return std::nullopt;
+    }
+
+    /** Attempt to cast to types satisfying traits, ordered in terms of priority */
+    template <template <typename T> typename Trait, template <typename T> typename ... Traits>
+    static std::variant<Ts...> unwrapPriority(JSContext * ctx, JSValueConst v)
+    {
+        if(auto result = unwrapImpl<Trait, Ts...>(ctx, v))
+        {
+            return *result;
+        }
+        if constexpr ((sizeof ... (Traits)) > 0)
+        {
+            return unwrapPriority<Traits...>(ctx, v);
+        }
+        JS_ThrowTypeError(ctx, "Expected type %s", QJSPP_TYPENAME(std::variant<Ts...>));
+        throw exception{ctx};
+    }
+
+    template <typename T>
+    static bool isCompatible(JSContext * ctx, JSValueConst v) noexcept
+    {
+        //const char * type_name = typeid(T).name();
+        switch(JS_VALUE_GET_TAG(v))
+        {
+            case JS_TAG_STRING:
+                return is_string<T>::value;
+
+            case JS_TAG_FUNCTION_BYTECODE:
+                return std::is_function<T>::value;
+            case JS_TAG_OBJECT:
+                if(JS_IsArray(ctx, v) == 1)
+                    return is_vector<T>::value || is_pair<T>::value;
+                if constexpr (is_shared_ptr<T>::value)
+                {
+                    if(JS_GetClassID(v) == js_traits<T>::QJSClassId)
+                        return true;
+                }
+                return false;
+
+            case JS_TAG_INT:
+                [[fallthrough]];
+            case JS_TAG_BIG_INT:
+                return std::is_integral_v<T> || std::is_floating_point_v<T>;
+            case JS_TAG_BOOL:
+                return is_boolean<T>::value || std::is_integral_v<T> || std::is_floating_point_v<T>;
+
+            case JS_TAG_BIG_DECIMAL:
+                [[fallthrough]];
+            case JS_TAG_BIG_FLOAT:
+                [[fallthrough]];
+            case JS_TAG_FLOAT64:
+            default: // >JS_TAG_FLOAT64 (JS_NAN_BOXING)
+                return is_double<T>::value || std::is_floating_point_v<T>;
+
+            case JS_TAG_SYMBOL:
+                [[fallthrough]];
+            case JS_TAG_MODULE:
+                [[fallthrough]];
+            case JS_TAG_NULL:
+                [[fallthrough]];
+            case JS_TAG_UNDEFINED:
+                [[fallthrough]];
+            case JS_TAG_UNINITIALIZED:
+                [[fallthrough]];
+            case JS_TAG_CATCH_OFFSET:
+                [[fallthrough]];
+            case JS_TAG_EXCEPTION:
+                break;
+        }
+        return false;
+    }
+
+    static std::variant<Ts...> unwrap(JSContext * ctx, JSValueConst v)
+    {
+        const auto tag = JS_VALUE_GET_TAG(v);
+        switch(tag)
+        {
+            case JS_TAG_STRING:
+                return unwrapPriority<is_string>(ctx, v);
+
+            case JS_TAG_FUNCTION_BYTECODE:
+                return unwrapPriority<std::is_function>(ctx, v);
+            case JS_TAG_OBJECT:
+                if(auto result = unwrapObj<Ts...>(ctx, v, JS_GetClassID(v)))
+                {
+                    return *result;
+                }
+                JS_ThrowTypeError(ctx, "Expected type %s, got object with classid %d",
+                                  QJSPP_TYPENAME(std::variant<Ts...>), JS_GetClassID(v));
+                break;
+
+            case JS_TAG_INT:
+                [[fallthrough]];
+            case JS_TAG_BIG_INT:
+                return unwrapPriority<std::is_integral, std::is_floating_point>(ctx, v);
+            case JS_TAG_BOOL:
+                return unwrapPriority<is_boolean, std::is_integral, std::is_floating_point>(ctx, v);
+
+            case JS_TAG_SYMBOL:
+                [[fallthrough]];
+            case JS_TAG_MODULE:
+                [[fallthrough]];
+            case JS_TAG_NULL:
+                [[fallthrough]];
+            case JS_TAG_UNDEFINED:
+                [[fallthrough]];
+            case JS_TAG_UNINITIALIZED:
+                [[fallthrough]];
+            case JS_TAG_CATCH_OFFSET:
+                JS_ThrowTypeError(ctx, "Expected type %s, got tag %d", QJSPP_TYPENAME(std::variant<Ts...>), tag);
+                [[fallthrough]];
+            case JS_TAG_EXCEPTION:
+                break;
+
+            case JS_TAG_BIG_DECIMAL:
+                [[fallthrough]];
+            case JS_TAG_BIG_FLOAT:
+                [[fallthrough]];
+
+            case JS_TAG_FLOAT64:
+                [[fallthrough]];
+            default: // more than JS_TAG_FLOAT64 (nan boxing)
+                return unwrapPriority<is_double, std::is_floating_point>(ctx, v);
+        }
+
+        throw exception{ctx};
+    }
+};
+
+template <typename T>
+struct rest : std::vector<T>
+{
+    using std::vector<T>::vector;
+    using std::vector<T>::operator=;
+};
+
+namespace detail {
+
+/** Helper function to convert and then free JSValue. */
+template <typename T>
+T unwrap_free(JSContext * ctx, JSValue val)
+{
+    if constexpr(std::is_same_v<T, void>)
+    {
+        JS_FreeValue(ctx, val);
+        return js_traits<T>::unwrap(ctx, val);
+    }
+    else
+    {
+        try
+        {
+            T result = js_traits<std::decay_t<T>>::unwrap(ctx, val);
+            JS_FreeValue(ctx, val);
+            return result;
+        }
+        catch(...)
+        {
+            JS_FreeValue(ctx, val);
+            throw;
+        }
+    }
+}
+
+template <typename T, size_t I, size_t NArgs>
+struct unwrap_arg_impl {
+    static auto unwrap(JSContext * ctx, int argc, JSValueConst * argv)
+    {
+        if (size_t(argc) <= I) {
+            JS_ThrowTypeError(ctx, "Expected at least %lu arguments but received %d",
+                              (unsigned long)NArgs, argc);
+            throw exception{ctx};
+        }
+        return js_traits<std::decay_t<T>>::unwrap(ctx, argv[I]);
+    }
+};
+
+template <typename T, size_t I, size_t NArgs>
+struct unwrap_arg_impl<rest<T>, I, NArgs> {
+    static rest<T> unwrap(JSContext * ctx, int argc, JSValueConst * argv) {
+        static_assert(I == NArgs - 1, "The `rest` argument must be the last function argument.");
+        rest<T> result;
+        result.reserve(argc - I);
+        for (size_t i = I; i < size_t(argc); ++i)
+            result.push_back(js_traits<T>::unwrap(ctx, argv[i]));
+        return result;
+    }
+};
+
+template <class Tuple, std::size_t... I>
+Tuple unwrap_args_impl(JSContext * ctx, int argc, JSValueConst * argv, std::index_sequence<I...>)
+{
+    return Tuple{unwrap_arg_impl<std::tuple_element_t<I, Tuple>, I, sizeof...(I)>::unwrap(ctx, argc, argv)...};
+}
+
+/** Helper function to convert an array of JSValues to a tuple.
+ * @tparam Args C++ types of the argv array
+ */
+template <typename... Args>
+std::tuple<std::decay_t<Args>...> unwrap_args(JSContext * ctx, int argc, JSValueConst * argv)
+{
+    return unwrap_args_impl<std::tuple<std::decay_t<Args>...>>(ctx, argc, argv, std::make_index_sequence<sizeof...(Args)>());
+}
+
+/** Helper function to call f with an array of JSValues.
+ * @tparam R return type of f
+ * @tparam Args argument types of f
+ * @tparam Callable type of f (inferred)
+ * @param ctx JSContext
+ * @param f callable object
+ * @param argv array of JSValue's
+ * @return converted return value of f or JS_NULL if f returns void
+ */
+template <typename R, typename... Args, typename Callable>
+JSValue wrap_call(JSContext * ctx, Callable&& f, int argc, JSValueConst * argv) noexcept
+{
+    try
+    {
+        if constexpr(std::is_same_v<R, void>)
+        {
+            std::apply(std::forward<Callable>(f), unwrap_args<Args...>(ctx, argc, argv));
+            return JS_NULL;
+        }
+        else
+        {
+            return js_traits<std::decay_t<R>>::wrap(ctx,
+                                                    std::apply(std::forward<Callable>(f),
+                                                               unwrap_args<Args...>(ctx, argc, argv)));
+        }
+    }
+    catch(exception)
+    {
+        return JS_EXCEPTION;
+    }
+    catch (std::exception const & err)
+    {
+        JS_ThrowInternalError(ctx, "%s", err.what());
+        return JS_EXCEPTION;
+    }
+    catch (...)
+    {
+        JS_ThrowInternalError(ctx, "Unknown error");
+        return JS_EXCEPTION;
+    }
+}
+
+/** Same as wrap_call, but pass this_value as first argument.
+ * @tparam FirstArg type of this_value
+ */
+template <typename R, typename FirstArg, typename... Args, typename Callable>
+JSValue wrap_this_call(JSContext * ctx, Callable&& f, JSValueConst this_value, int argc, JSValueConst * argv) noexcept
+{
+    try
+    {
+        if constexpr(std::is_same_v<R, void>)
+        {
+            std::apply(std::forward<Callable>(f), std::tuple_cat(unwrap_args<FirstArg>(ctx, 1, &this_value),
+                                                                 unwrap_args<Args...>(ctx, argc, argv)));
+            return JS_NULL;
+        }
+        else
+        {
+            return js_traits<std::decay_t<R>>::wrap(ctx,
+                                                    std::apply(std::forward<Callable>(f),
+                                                               std::tuple_cat(
+                                                                       unwrap_args<FirstArg>(ctx, 1, &this_value),
+                                                                       unwrap_args<Args...>(ctx, argc, argv))));
+        }
+    }
+    catch(exception)
+    {
+        return JS_EXCEPTION;
+    }
+    catch (std::exception const & err)
+    {
+        JS_ThrowInternalError(ctx, "%s", err.what());
+        return JS_EXCEPTION;
+    }
+    catch (...)
+    {
+        JS_ThrowInternalError(ctx, "Unknown error");
+        return JS_EXCEPTION;
+    }
+}
+
+template <class Tuple, std::size_t... I>
+void wrap_args_impl(JSContext * ctx, JSValue * argv, Tuple tuple, std::index_sequence<I...>)
+{
+    ((argv[I] = js_traits<std::decay_t<std::tuple_element_t<I, Tuple>>>::wrap(ctx, std::get<I>(tuple))), ...);
+}
+
+/** Converts C++ args to JSValue array.
+ * @tparam Args argument types
+ * @param argv array of size at least sizeof...(Args)
+ */
+template <typename... Args>
+void wrap_args(JSContext * ctx, JSValue * argv, Args&& ... args)
+{
+    wrap_args_impl(ctx, argv, std::make_tuple(std::forward<Args>(args)...),
+                   std::make_index_sequence<sizeof...(Args)>());
+}
+
+// Helper trait to obtain `T` in `T::*` expressions
+template<typename T> struct class_from_member_pointer { using type = void; };
+template<typename T, typename U> struct class_from_member_pointer<T U::*> { using type = U; };
+template<typename T> using class_from_member_pointer_t = typename class_from_member_pointer<T>::type;
+
+} // namespace detail
+
+/** A wrapper type for free and class member functions.
+ * Pointer to function F is a template argument.
+ * @tparam F either a pointer to free function or a pointer to class member function
+ * @tparam PassThis if true and F is a pointer to free function, passes Javascript "this" value as first argument:
+ */
+template <auto F, bool PassThis = false /* pass this as the first argument */>
+struct fwrapper
+{
+    /// "name" property of the JS function object (not defined if nullptr)
+    const char * name = nullptr;
+};
+
+/** Conversion to JSValue for free function in fwrapper. */
+template <typename R, typename... Args, R (* F)(Args...), bool PassThis>
+struct js_traits<fwrapper<F, PassThis>>
+{
+    static JSValue wrap(JSContext * ctx, fwrapper<F, PassThis> fw) noexcept
+    {
+        return JS_NewCFunction(ctx, [](JSContext * ctx, JSValueConst this_value, int argc,
+                                       JSValueConst * argv) noexcept -> JSValue {
+            if constexpr(PassThis)
+                return detail::wrap_this_call<R, Args...>(ctx, F, this_value, argc, argv);
+            else
+                return detail::wrap_call<R, Args...>(ctx, F, argc, argv);
+        }, fw.name, sizeof...(Args));
+
+    }
+};
+
+/** Conversion to JSValue for class member function in fwrapper. PassThis is ignored and treated as true */
+template <typename R, class T, typename... Args, R (T::*F)(Args...), bool PassThis/*=ignored*/>
+struct js_traits<fwrapper<F, PassThis>>
+{
+    static JSValue wrap(JSContext * ctx, fwrapper<F, PassThis> fw) noexcept
+    {
+        return JS_NewCFunction(ctx, [](JSContext * ctx, JSValueConst this_value, int argc,
+                                       JSValueConst * argv) noexcept -> JSValue {
+            return detail::wrap_this_call<R, std::shared_ptr<T>, Args...>(ctx, F, this_value, argc, argv);
+        }, fw.name, sizeof...(Args));
+
+    }
+};
+
+/** Conversion to JSValue for const class member function in fwrapper. PassThis is ignored and treated as true */
+template <typename R, class T, typename... Args, R (T::*F)(Args...) const, bool PassThis/*=ignored*/>
+struct js_traits<fwrapper<F, PassThis>>
+{
+    static JSValue wrap(JSContext * ctx, fwrapper<F, PassThis> fw) noexcept
+    {
+        return JS_NewCFunction(ctx, [](JSContext * ctx, JSValueConst this_value, int argc,
+                                       JSValueConst * argv) noexcept -> JSValue {
+            return detail::wrap_this_call<R, std::shared_ptr<T>, Args...>(ctx, F, this_value, argc, argv);
+        }, fw.name, sizeof...(Args));
+
+    }
+};
+
+/** A wrapper type for constructor of type T with arguments Args.
+ * Compilation fails if no such constructor is defined.
+ * @tparam Args constructor arguments
+ */
+template <class T, typename... Args>
+struct ctor_wrapper
+{
+    static_assert(std::is_constructible<T, Args...>::value, "no such constructor!");
+    /// "name" property of JS constructor object
+    const char * name = nullptr;
+};
+
+namespace detail {
+/// equivalent to JS_GetPropertyStr(ctx, this_value, "prototype");
+inline JSValue GetPropertyPrototype(JSContext * ctx, JSValueConst this_value)
+{
+    // constant atom: doesn't need to be freed and doesn't change with context
+    static const JSAtom JS_ATOM_prototype = JS_NewAtom(ctx, "prototype");
+    return JS_GetProperty(ctx, this_value, JS_ATOM_prototype);
+}
+} // namespace detail
+
+/** Conversion to JSValue for ctor_wrapper. */
+template <class T, typename... Args>
+struct js_traits<ctor_wrapper<T, Args...>>
+{
+    static JSValue wrap(JSContext * ctx, ctor_wrapper<T, Args...> cw) noexcept
+    {
+        return JS_NewCFunction2(ctx, [](JSContext * ctx, JSValueConst this_value, int argc,
+                                        JSValueConst * argv) noexcept -> JSValue {
+
+            if(js_traits<std::shared_ptr<T>>::QJSClassId == 0) // not registered
+            {
+#if defined(__cpp_rtti)
+                // automatically register class on first use (no prototype)
+                js_traits<std::shared_ptr<T>>::register_class(ctx, typeid(T).name());
+#else
+                JS_ThrowTypeError(ctx, "quickjspp ctor_wrapper<T>::wrap: Class is not registered");
+                return JS_EXCEPTION;
+#endif
+            }
+
+            auto proto = detail::GetPropertyPrototype(ctx, this_value);
+            if(JS_IsException(proto))
+                return proto;
+            auto jsobj = JS_NewObjectProtoClass(ctx, proto, js_traits<std::shared_ptr<T>>::QJSClassId);
+            JS_FreeValue(ctx, proto);
+            if(JS_IsException(jsobj))
+                return jsobj;
+
+            try
+            {
+                std::shared_ptr<T> ptr = std::apply(std::make_shared<T, Args...>, detail::unwrap_args<Args...>(ctx, argc, argv));
+                JS_SetOpaque(jsobj, new std::shared_ptr<T>(std::move(ptr)));
+                return jsobj;
+            }
+            catch (exception)
+            {
+                JS_FreeValue(ctx, jsobj);
+                return JS_EXCEPTION;
+            }
+            catch (std::exception const & err)
+            {
+                JS_FreeValue(ctx, jsobj);
+                JS_ThrowInternalError(ctx, "%s", err.what());
+                return JS_EXCEPTION;
+            }
+            catch (...)
+            {
+                JS_FreeValue(ctx, jsobj);
+                JS_ThrowInternalError(ctx, "Unknown error");
+                return JS_EXCEPTION;
+            }
+
+            // return detail::wrap_call<std::shared_ptr<T>, Args...>(ctx, std::make_shared<T, Args...>, argv);
+        }, cw.name, sizeof...(Args), JS_CFUNC_constructor, 0);
+    }
+};
+
+
+/** Conversions for std::shared_ptr<T>. Empty shared_ptr corresponds to JS_NULL.
+ * T should be registered to a context before conversions.
+ * @tparam T class type
+ */
+template <class T>
+struct js_traits<std::shared_ptr<T>>
+{
+    /// Registered class id in QuickJS.
+    inline static JSClassID QJSClassId = 0;
+
+    /// Signature of the function to obtain the std::shared_ptr from the JSValue.
+    using ptr_cast_fcn_t = std::function<std::shared_ptr<T>(JSContext*, JSValueConst)>;
+
+    /// Used by registerDerivedClass to register new derived classes with this class' base type.
+    inline static std::function<void(JSClassID, ptr_cast_fcn_t)> registerWithBase;
+
+    /// Mapping between derived class' JSClassID and function to obtain the std::shared_ptr from the JSValue.
+    inline static std::unordered_map<JSClassID, ptr_cast_fcn_t> ptrCastFcnMap;
+
+    /** Register a class as a derived class.
+     * 
+     * @tparam D type of the derived class
+     * @param derived_class_id class id of the derived class
+     * @param ptr_cast_fcn function to obtain a std::shared_ptr from the JSValue
+     */
+    template<typename D>
+    static void registerDerivedClass(JSClassID derived_class_id, ptr_cast_fcn_t ptr_cast_fcn) {
+        static_assert(std::is_base_of<T,D>::value && !std::is_same<T,D>::value, "Type is not a derived class");
+        using derived_ptr_cast_fcn_t = typename js_traits<std::shared_ptr<D>>::ptr_cast_fcn_t;
+
+        // Register how to obtain the std::shared_ptr from the derived class.
+        ptrCastFcnMap[derived_class_id] = ptr_cast_fcn;
+
+        // Propagate the registration to our base class (if any).
+        if (registerWithBase) registerWithBase(derived_class_id, ptr_cast_fcn);
+
+        // Instrument the derived class so that it can propagate new derived classes to us.
+        auto old_registerWithBase = js_traits<std::shared_ptr<D>>::registerWithBase;
+        js_traits<std::shared_ptr<D>>::registerWithBase =
+            [old_registerWithBase = std::move(old_registerWithBase)]
+            (JSClassID derived_class_id, derived_ptr_cast_fcn_t derived_ptr_cast_fcn){
+                if (old_registerWithBase) old_registerWithBase(derived_class_id, derived_ptr_cast_fcn);
+                registerDerivedClass<D>(derived_class_id, [derived_cast_fcn = std::move(derived_ptr_cast_fcn)](JSContext * ctx, JSValueConst v) {
+                    return std::shared_ptr<T>(derived_cast_fcn(ctx, v));
+                });
+            };
+    }
+
+    template <typename B>
+    static
+    std::enable_if_t<std::is_same_v<B, T> || std::is_same_v<B, void>>
+    ensureCanCastToBase() { }
+
+    template <typename B>
+    static
+    std::enable_if_t<!std::is_same_v<B, T> && !std::is_same_v<B, void>>
+    ensureCanCastToBase() {
+        static_assert(std::is_base_of_v<B, T>, "Type is not a derived class");
+
+        if(js_traits<std::shared_ptr<T>>::QJSClassId == 0)
+            JS_NewClassID(&js_traits<std::shared_ptr<T>>::QJSClassId);
+
+        js_traits<std::shared_ptr<B>>::template registerDerivedClass<T>(QJSClassId, unwrap);
+    }
+
+    template <auto M>
+    static void ensureCanCastToBase() {
+        ensureCanCastToBase<detail::class_from_member_pointer_t<decltype(M)>>();
+    }
+
+    /** Stores offsets to qjs::Value members of T.
+     * These values should be marked by class_registrar::mark for QuickJS garbage collector
+     * so that the cycle removal algorithm can find the other objects referenced by this object.
+     */
+    static inline std::vector<Value T::*> markOffsets;
+
+    /** Register class in QuickJS context.
+     *
+     * @param ctx context
+     * @param name class name
+     * @param proto class prototype or JS_NULL
+     * @param call QJS call function. see quickjs doc
+     * @param exotic pointer to QJS exotic methods(static lifetime) which allow custom property handling. see quickjs doc
+     * @throws exception
+     */
+    static void register_class(JSContext * ctx, const char * name, JSValue proto = JS_NULL,
+                               JSClassCall * call = nullptr, JSClassExoticMethods * exotic = nullptr)
+    {
+        if(QJSClassId == 0)
+        {
+            JS_NewClassID(&QJSClassId);
+        }
+        auto rt = JS_GetRuntime(ctx);
+        if(!JS_IsRegisteredClass(rt, QJSClassId))
+        {
+            JSClassGCMark * marker = nullptr;
+            if(!markOffsets.empty())
+            {
+                marker = [](JSRuntime *rt, JSValueConst val, JS_MarkFunc *mark_func) {
+                    auto pptr = static_cast<std::shared_ptr<T> *>(JS_GetOpaque(val, QJSClassId));
+                    assert(pptr);
+                    const T * ptr = pptr->get();
+                    assert(ptr);
+                    for(Value T::* member : markOffsets)
+                    {
+                        JS_MarkValue(rt, (*ptr.*member).v, mark_func);
+                    }
+                };
+            }
+            JSClassDef def{
+                    name,
+                    // destructor (finalizer)
+                    [](JSRuntime * rt, JSValue obj) noexcept {
+                        auto pptr = static_cast<std::shared_ptr<T> *>(JS_GetOpaque(obj, QJSClassId));
+                        delete pptr;
+                    },
+                    // mark
+                    marker,
+                    // call
+                    call,
+                    // exotic
+                    exotic
+            };
+            int e = JS_NewClass(rt, QJSClassId, &def);
+            if(e < 0)
+            {
+                JS_ThrowInternalError(ctx, "Can't register class %s", name);
+                throw exception{ctx};
+            }
+        }
+        JS_SetClassProto(ctx, QJSClassId, proto);
+    }
+
+    /** Create a JSValue from std::shared_ptr<T>.
+     * Creates an object with class if #QJSClassId and sets its opaque pointer to a new copy of #ptr.
+     */
+    static JSValue wrap(JSContext * ctx, std::shared_ptr<T> ptr)
+    {
+        if(!ptr)
+            return JS_NULL;
+        if(QJSClassId == 0) // not registered
+        {
+#if defined(__cpp_rtti)
+            // automatically register class on first use (no prototype)
+            register_class(ctx, typeid(T).name());
+#else
+            JS_ThrowTypeError(ctx, "quickjspp std::shared_ptr<T>::wrap: Class is not registered");
+            return JS_EXCEPTION;
+#endif
+        }
+        auto jsobj = JS_NewObjectClass(ctx, QJSClassId);
+        if(JS_IsException(jsobj))
+            return jsobj;
+
+        auto pptr = new std::shared_ptr<T>(std::move(ptr));
+        JS_SetOpaque(jsobj, pptr);
+        return jsobj;
+    }
+
+    /// @throws exception if #v doesn't have the correct class id
+    static std::shared_ptr<T> unwrap(JSContext * ctx, JSValueConst v)
+    {
+        std::shared_ptr<T> ptr = nullptr;
+        if (JS_IsNull(v)) {
+            return ptr;
+        }
+        auto obj_class_id = JS_GetClassID(v);
+
+        if (obj_class_id == QJSClassId) {
+            // The JS object is of class T
+            void * opaque = JS_GetOpaque2(ctx, v, obj_class_id);
+            assert(opaque && "No opaque pointer in object");
+            ptr = *static_cast<std::shared_ptr<T> *>(opaque);
+        } else if (ptrCastFcnMap.count(obj_class_id)) {
+            // The JS object is of a class derived from T
+            ptr = ptrCastFcnMap[obj_class_id](ctx, v);
+        } else {
+            // The JS object does not derives from T
+            JS_ThrowTypeError(ctx, "Expected type %s, got object with classid %d",
+                              QJSPP_TYPENAME(T), obj_class_id);
+            throw exception{ctx};
+        }
+        if(!ptr) {
+            JS_ThrowInternalError(ctx, "Object's opaque pointer is NULL");
+            throw exception{ctx};
+        }
+        return ptr;
+    }
+};
+
+/** Conversions for non-owning pointers to class T. nullptr corresponds to JS_NULL.
+ * @tparam T class type
+ */
+template <class T>
+struct js_traits<T *, std::enable_if_t<std::is_class_v<T>>>
+{
+    static JSValue wrap(JSContext * ctx, T * ptr)
+    {
+        if (ptr == nullptr) {
+            return JS_NULL;
+        }   
+        if(js_traits<std::shared_ptr<T>>::QJSClassId == 0) // not registered
+        {
+#if defined(__cpp_rtti)
+            // If you have an error here with T=JSValueConst
+            // it probably means you are passing JSValueConst to where JSValue is expected
+            js_traits<std::shared_ptr<T>>::register_class(ctx, typeid(T).name());
+#else
+            JS_ThrowTypeError(ctx, "quickjspp js_traits<T *>::wrap: Class is not registered");
+            return JS_EXCEPTION;
+#endif
+        }
+        auto jsobj = JS_NewObjectClass(ctx, js_traits<std::shared_ptr<T>>::QJSClassId);
+        if(JS_IsException(jsobj))
+            return jsobj;
+
+        // shared_ptr with empty deleter since we don't own T*
+        auto pptr = new std::shared_ptr<T>(ptr, [](T *) {});
+        JS_SetOpaque(jsobj, pptr);
+        return jsobj;
+    }
+
+    static T * unwrap(JSContext * ctx, JSValueConst v)
+    {
+        if (JS_IsNull(v)) {
+            return nullptr;
+        }
+        auto ptr = js_traits<std::shared_ptr<T>>::unwrap(ctx, v);
+        return ptr.get();
+    }
+};
+
+/** Conversions for enums. */
+template <typename E>
+struct js_traits<E, std::enable_if_t<std::is_enum_v<E>>> {
+    using T = std::underlying_type_t<E>;
+    static E unwrap(JSContext* ctx, JSValue v) noexcept {
+        return static_cast<E>(js_traits<T>::unwrap(ctx, v));
+    }
+
+    static JSValue wrap(JSContext* ctx, E t) noexcept {
+        return js_traits<T>::wrap(ctx, static_cast<T>(t));;
+    }
+};
+
+namespace detail {
+/** A faster std::function-like object with type erasure.
+ * Used to convert any callable objects (including lambdas) to JSValue.
+ */
+struct function
+{
+    JSValue
+    (* invoker)(function * self, JSContext * ctx, JSValueConst this_value, int argc, JSValueConst * argv) = nullptr;
+
+    void (* destroyer)(function * self) = nullptr;
+
+    alignas(std::max_align_t) char functor[];
+
+    template <typename Functor>
+    static function * create(JSRuntime * rt, Functor&& f)
+    {
+        using Functor_t = std::decay_t<Functor>;
+        auto fptr = static_cast<function *>(js_malloc_rt(rt, sizeof(function) + sizeof(Functor_t)));
+        if(!fptr)
+            throw std::bad_alloc{};
+        new(fptr) function;
+        auto functorptr = reinterpret_cast<Functor_t *>(fptr->functor);
+        new(functorptr) Functor_t(std::forward<Functor>(f));
+        fptr->destroyer = nullptr;
+        if constexpr(!std::is_trivially_destructible_v<Functor_t>)
+        {
+            fptr->destroyer = [](function * fptr) {
+                auto functorptr = reinterpret_cast<Functor_t *>(fptr->functor);
+                functorptr->~Functor_t();
+            };
+        }
+        return fptr;
+    }
+};
+
+static_assert(std::is_trivially_destructible_v<function>);
+}
+
+template <>
+struct js_traits<detail::function>
+{
+    inline static JSClassID QJSClassId = 0;
+
+    // TODO: replace ctx with rt
+    static void register_class(JSContext * ctx, const char * name)
+    {
+        if(QJSClassId == 0)
+        {
+            JS_NewClassID(&QJSClassId);
+        }
+        auto rt = JS_GetRuntime(ctx);
+        if(JS_IsRegisteredClass(rt, QJSClassId))
+            return;
+        JSClassDef def{
+                name,
+                // destructor
+                [](JSRuntime * rt, JSValue obj) noexcept {
+                    auto fptr = static_cast<detail::function *>(JS_GetOpaque(obj, QJSClassId));
+                    assert(fptr);
+                    if(fptr->destroyer)
+                        fptr->destroyer(fptr);
+                    js_free_rt(rt, fptr);
+                },
+                nullptr, // mark
+                // call
+                [](JSContext * ctx, JSValueConst func_obj, JSValueConst this_val, int argc,
+                   JSValueConst * argv, int flags) -> JSValue {
+                    auto ptr = static_cast<detail::function *>(JS_GetOpaque2(ctx, func_obj, QJSClassId));
+                    if(!ptr)
+                        return JS_EXCEPTION;
+                    return ptr->invoker(ptr, ctx, this_val, argc, argv);
+                },
+                nullptr
+        };
+        int e = JS_NewClass(rt, QJSClassId, &def);
+        if(e < 0)
+            throw std::runtime_error{"Cannot register C++ function class"};
+    }
+};
+
+
+/** Traits for accessing object properties.
+ * @tparam Key property key type (uint32 and strings are supported)
+ */
+template <typename Key>
+struct js_property_traits
+{
+    static void set_property(JSContext * ctx, JSValue this_obj, Key key, JSValue value);
+
+    static JSValue get_property(JSContext * ctx, JSValue this_obj, Key key);
+};
+
+template <>
+struct js_property_traits<const char *>
+{
+    static void set_property(JSContext * ctx, JSValue this_obj, const char * name, JSValue value)
+    {
+        int err = JS_SetPropertyStr(ctx, this_obj, name, value);
+        if(err < 0)
+            throw exception{ctx};
+    }
+
+    static JSValue get_property(JSContext * ctx, JSValue this_obj, const char * name) noexcept
+    {
+        return JS_GetPropertyStr(ctx, this_obj, name);
+    }
+};
+
+template <>
+struct js_property_traits<uint32_t>
+{
+    static void set_property(JSContext * ctx, JSValue this_obj, uint32_t idx, JSValue value)
+    {
+        int err = JS_SetPropertyUint32(ctx, this_obj, idx, value);
+        if(err < 0)
+            throw exception{ctx};
+    }
+
+    static JSValue get_property(JSContext * ctx, JSValue this_obj, uint32_t idx) noexcept
+    {
+        return JS_GetPropertyUint32(ctx, this_obj, idx);
+    }
+};
+
+template <>
+struct js_property_traits<int> : js_property_traits<uint32_t> {};
+
+
+namespace detail {
+template <typename Key>
+struct property_proxy
+{
+    JSContext * ctx;
+    JSValue this_obj;
+    Key key;
+
+    /** Conversion helper function */
+    template <typename T>
+    T as() const
+    {
+        return unwrap_free<T>(ctx, js_property_traits<Key>::get_property(ctx, this_obj, key));
+    }
+
+    /** Explicit conversion operator (to any type) */
+    template <typename T>
+    explicit operator T() const { return as<T>(); }
+
+    /** Implicit converion to qjs::Value */
+    operator Value() const; // defined later due to Value being incomplete type
+
+    /// noncopyable
+    property_proxy& operator =(property_proxy) = delete;
+
+    template <typename T>
+    property_proxy& operator =(T&& value)
+    {
+        js_property_traits<Key>::set_property(ctx, this_obj, key,
+                                              js_traits<std::decay_t<T>>::wrap(ctx, std::forward<T>(value)));
+        return *this;
+    }
+
+    template <typename Key2>
+    property_proxy<Key2> operator[](Key2 key2) const
+    {
+        return {ctx, as<JSValue>(), std::move(key2)};
+    }
+
+    ~property_proxy() noexcept { JS_FreeValue(ctx, this_obj); }
+};
+
+
+// class member variable getter/setter
+template <auto M>
+struct get_set {};
+
+// M -  member object
+template <class T, typename R, R T::*M>
+struct get_set<M>
+{
+    using is_const = std::is_const<R>;
+
+    static const R& get(std::shared_ptr<T> ptr)
+    {
+        return *ptr.*M;
+    }
+
+    static R& set(std::shared_ptr<T> ptr, R value)
+    {
+        return *ptr.*M = std::move(value);
+    }
+
+};
+
+// M - static member object
+template <typename R, R *M>
+struct get_set<M>
+{
+    using is_const = std::is_const<R>;
+
+    static const R& get(bool)
+    {
+        return *M;
+    }
+
+    static R& set(bool, R value)
+    {
+        return *M = std::move(value);
+    }
+
+};
+
+} // namespace detail
+
+/** JSValue with RAAI semantics.
+ * A wrapper over (JSValue v, JSContext * ctx).
+ * Calls JS_FreeValue(ctx, v) on destruction. Can be copied and moved.
+ * A JSValue can be released by either JSValue x = std::move(value); or JSValue x = value.release(), then the Value becomes invalid and FreeValue won't be called
+ * Can be converted to C++ type, for example: auto string = value.as<std::string>(); qjs::exception would be thrown on error
+ * Properties can be accessed (read/write): value["property1"] = 1; value[2] = "2";
+ */
+class Value
+{
+public:
+    JSValue v;
+    JSContext * ctx = nullptr;
+
+public:
+    /** Use context.newValue(val) instead */
+    template <typename T>
+    Value(JSContext * ctx, T&& val) : ctx(ctx)
+    {
+        v = js_traits<std::decay_t<T>>::wrap(ctx, std::forward<T>(val));
+        if(JS_IsException(v))
+            throw exception{ctx};
+    }
+
+    Value(JSValue&& v) noexcept : v(std::move(v)), ctx(nullptr) {}
+
+    Value(const Value& rhs) noexcept
+    {
+        ctx = rhs.ctx;
+        v = JS_DupValue(ctx, rhs.v);
+    }
+
+    Value(Value&& rhs) noexcept
+    {
+        std::swap(ctx, rhs.ctx);
+        v = rhs.v;
+    }
+
+    Value& operator =(Value rhs) noexcept
+    {
+        std::swap(ctx, rhs.ctx);
+        std::swap(v, rhs.v);
+        return *this;
+    }
+
+    bool operator ==(JSValueConst other) const
+    {
+        return JS_VALUE_GET_TAG(v) == JS_VALUE_GET_TAG(other) && JS_VALUE_GET_PTR(v) == JS_VALUE_GET_PTR(other);
+    }
+
+    bool operator !=(JSValueConst other) const { return !((*this) == other); }
+
+    /** Returns true if 2 values are the same (equality for arithmetic types or point to the same object) */
+    bool operator ==(const Value& rhs) const
+    {
+        return (*this == rhs.v);
+    }
+
+    bool operator !=(const Value& rhs) const { return !((*this) == rhs); }
+
+
+    ~Value()
+    {
+        if(ctx) JS_FreeValue(ctx, v);
+    }
+
+    bool isError() const { return JS_IsError(ctx, v); }
+
+    /** Conversion helper function: value.as<T>()
+     * @tparam T type to convert to
+     * @return type returned by js_traits<std::decay_t<T>>::unwrap that should be implicitly convertible to T
+     * */
+    template <typename T>
+    auto as() const { return js_traits<std::decay_t<T>>::unwrap(ctx, v); }
+
+    /** Explicit conversion: static_cast<T>(value) or (T)value */
+    template <typename T>
+    explicit operator T() const { return as<T>(); }
+
+    JSValue release() noexcept// dont call freevalue
+    {
+        ctx = nullptr;
+        return v;
+    }
+
+    /** Implicit conversion to JSValue (rvalue only). Example: JSValue v = std::move(value); */
+    operator JSValue()&& noexcept { return release(); }
+
+
+    /** Access JS properties. Returns proxy type which is implicitly convertible to qjs::Value */
+    template <typename Key>
+    detail::property_proxy<Key> operator [](Key key)
+    {
+        assert(ctx && "Trying to access properties of Value with no JSContext");
+        return {ctx, JS_DupValue(ctx, v), std::move(key)};
+    }
+
+
+    // add("f", []() {...});
+    template <typename Function>
+    Value& add(const char * name, Function&& f)
+    {
+        (*this)[name] = js_traits<decltype(std::function{std::forward<Function>(f)})>::wrap(ctx,
+                                                                                            std::forward<Function>(f));
+        return *this;
+    }
+
+    // add<&f>("f");
+    // add<&T::f>("f");
+    template <auto F>
+    std::enable_if_t<std::is_member_function_pointer_v<decltype(F)> || std::is_function_v<std::remove_pointer_t<decltype(F)>>, Value&>
+    add(const char * name)
+    {
+        (*this)[name] = fwrapper<F>{name};
+        return *this;
+    }
+
+    // add_getter_setter<&T::get_member, &T::set_member>("member");
+    template <auto FGet, auto FSet>
+    Value& add_getter_setter(const char * name)
+    {
+        auto prop = JS_NewAtom(ctx, name);
+        using fgetter = fwrapper<FGet, true>;
+        using fsetter = fwrapper<FSet, true>;
+        int ret = JS_DefinePropertyGetSet(ctx, v, prop,
+                                          js_traits<fgetter>::wrap(ctx, fgetter{name}),
+                                          js_traits<fsetter>::wrap(ctx, fsetter{name}),
+                                          JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE | JS_PROP_ENUMERABLE
+        );
+        JS_FreeAtom(ctx, prop);
+        if(ret < 0)
+            throw exception{ctx};
+        return *this;
+    }
+
+    // add_getter<&T::get_member>("member");
+    template <auto FGet>
+    Value& add_getter(const char * name)
+    {
+        auto prop = JS_NewAtom(ctx, name);
+        using fgetter = fwrapper<FGet, true>;
+        int ret = JS_DefinePropertyGetSet(ctx, v, prop,
+                                          js_traits<fgetter>::wrap(ctx, fgetter{name}),
+                                          JS_UNDEFINED,
+                                          JS_PROP_CONFIGURABLE | JS_PROP_ENUMERABLE
+        );
+        JS_FreeAtom(ctx, prop);
+        if(ret < 0)
+            throw exception{ctx};
+        return *this;
+    }
+
+    // add<&T::member>("member");
+    template <auto M>
+    std::enable_if_t<std::is_member_object_pointer_v<decltype(M)>, Value&>
+    add(const char * name)
+    {
+        if constexpr (detail::get_set<M>::is_const::value)
+            return add_getter<detail::get_set<M>::get>(name);
+        else
+            return add_getter_setter<detail::get_set<M>::get, detail::get_set<M>::set>(name);
+    }
+
+    // add<&T::static_member>("static_member");
+    template <auto M>
+    std::enable_if_t<std::is_pointer_v<decltype(M)> && !std::is_function_v<std::remove_pointer_t<decltype(M)>> , Value&>
+    add(const char * name)
+    {
+        if constexpr (detail::get_set<M>::is_const::value)
+            return add_getter<detail::get_set<M>::get>(name);
+        else
+            return add_getter_setter<detail::get_set<M>::get, detail::get_set<M>::set>(name);
+    }
+
+    std::string
+    toJSON(const Value& replacer = JS_UNDEFINED, const Value& space = JS_UNDEFINED)
+    {
+        assert(ctx);
+        assert(!replacer.ctx || ctx == replacer.ctx);
+        assert(!space.ctx || ctx == space.ctx);
+        return (std::string) Value{ctx, JS_JSONStringify(ctx, v, replacer.v, space.v)};
+    }
+
+    /** same as Context::eval() but with this Value as 'this' */
+    Value evalThis(std::string_view buffer, const char * filename = "<evalThis>", int flags = 0)
+    {
+        assert(buffer.data()[buffer.size()] == '\0' && "eval buffer is not null-terminated"); // JS_Eval requirement
+        assert(ctx);
+        return Value{ctx, JS_EvalThis(ctx, v, buffer.data(), buffer.size(), filename, flags)};
+    }
+
+};
+
+/** Thin wrapper over JSRuntime * rt
+ * Calls JS_FreeRuntime on destruction. noncopyable.
+ */
+class Runtime
+{
+public:
+    JSRuntime * rt;
+
+    Runtime()
+    {
+        rt = JS_NewRuntime();
+        if(!rt)
+            throw std::runtime_error{"qjs: Cannot create runtime"};
+
+        JS_SetHostUnhandledPromiseRejectionTracker(rt, promise_unhandled_rejection_tracker, NULL);
+        JS_SetModuleLoaderFunc(rt, nullptr, module_loader, nullptr);
+    }
+
+    // noncopyable
+    Runtime(const Runtime&) = delete;
+
+    ~Runtime()
+    {
+        JS_FreeRuntime(rt);
+    }
+
+    /// @return pointer to qjs::Context of the executed job or nullptr if no job is pending
+    Context * executePendingJob();
+
+    bool isJobPending() const {
+        return JS_IsJobPending(rt);
+    }
+
+private:
+    static void promise_unhandled_rejection_tracker(JSContext *ctx, JSValueConst promise,
+                                                    JSValueConst reason, JS_BOOL is_handled, void *opaque);
+
+    static JSModuleDef *module_loader(JSContext *ctx,
+                                      const char *module_name, void *opaque);
+};
+
+namespace detail {
+
+inline std::optional<std::string> readFile(std::filesystem::path const & filepath)
+{
+    if (!std::filesystem::exists(filepath)) return std::nullopt;
+    std::ifstream f(filepath, std::ios::in | std::ios::binary);
+    if (!f.is_open()) return std::nullopt;
+    std::stringstream sstream;
+    sstream << f.rdbuf();
+    return sstream.str();
+}
+
+inline std::string toUri(std::string_view filename) {
+    auto fname = std::string{filename};
+    if (fname.find("://") < fname.find("/")) return fname;
+
+    auto fpath = std::filesystem::path(fname);
+    if (!fpath.is_absolute()) {
+        fpath = "." / fpath;
+    }
+    fpath = std::filesystem::weakly_canonical(fpath);
+    fname = "file://" + fpath.generic_string();
+    return fname;
+}
+
+}
+
+/** Wrapper over JSContext * ctx
+ * Calls JS_SetContextOpaque(ctx, this); on construction and JS_FreeContext on destruction
+ */
+class Context
+{
+public:
+    JSContext * ctx;
+
+    /** Module wrapper
+     * Workaround for lack of opaque pointer for module load function by keeping a list of modules in qjs::Context.
+     */
+    class Module
+    {
+        friend class Context;
+
+        JSModuleDef * m;
+        JSContext * ctx;
+        const char * name;
+
+        using nvp = std::pair<const char *, Value>;
+        std::vector<nvp> exports;
+    public:
+        Module(JSContext * ctx, const char * name) : ctx(ctx), name(name)
+        {
+            m = JS_NewCModule(ctx, name, [](JSContext * ctx, JSModuleDef * m) noexcept {
+                auto& context = Context::get(ctx);
+                auto it = std::find_if(context.modules.begin(), context.modules.end(),
+                                       [m](const Module& module) { return module.m == m; });
+                if(it == context.modules.end())
+                    return -1;
+                for(const auto& e : it->exports)
+                {
+                    if(JS_SetModuleExport(ctx, m, e.first, JS_DupValue(ctx, e.second.v)) != 0)
+                        return -1;
+                }
+                return 0;
+            });
+            if(!m)
+                throw exception{ctx};
+        }
+
+        Module& add(const char * name, JSValue&& value)
+        {
+            exports.push_back({name, {ctx, std::move(value)}});
+            JS_AddModuleExport(ctx, m, name);
+            return *this;
+        }
+
+
+        template <typename T>
+        Module& add(const char * name, T&& value)
+        {
+            return add(name, js_traits<T>::wrap(ctx, std::forward<T>(value)));
+        }
+
+        Module(const Module&) = delete;
+
+        Module(Module&&) = default;
+        //Module& operator=(Module&&) = default;
+
+
+        // function wrappers
+
+        /** Add free function F.
+         * Example:
+         * module.function<static_cast<double (*)(double)>(&::sin)>("sin");
+         */
+        template <auto F>
+        Module& function(const char * name)
+        {
+            return add(name, qjs::fwrapper<F>{name});
+        }
+
+        /** Add function object f.
+         * Slower than template version.
+         * Example: module.function("sin", [](double x) { return ::sin(x); });
+         */
+        template <typename F>
+        Module& function(const char * name, F&& f)
+        {
+            return add(name, js_traits<decltype(std::function{std::forward<F>(f)})>::wrap(ctx, std::forward<F>(f)));
+        }
+
+        // class register wrapper
+    private:
+        /** Helper class to register class members and constructors.
+         * See fun, constructor.
+         * Actual registration occurs at object destruction.
+         */
+        template <class T>
+        class class_registrar
+        {
+            const char * name;
+            qjs::Value prototype;
+            qjs::Context::Module& module;
+            qjs::Context& context;
+            qjs::Value ctor; // last added constructor
+        public:
+            explicit class_registrar(const char * name, qjs::Context::Module& module, qjs::Context& context) :
+                    name(name),
+                    prototype(context.newObject()),
+                    module(module),
+                    context(context),
+                    ctor(JS_NULL)
+            {
+            }
+
+            class_registrar(const class_registrar&) = delete;
+
+            /** Add functional object f
+             */
+            template <typename F>
+            class_registrar& fun(const char * name, F&& f)
+            {
+                prototype[name] = std::forward<F>(f);
+                return *this;
+            }
+
+            /** Add class member function or class member variable F
+             * Example:
+             * struct T { int var; int func(); }
+             * auto& module = context.addModule("module");
+             * module.class_<T>("T").fun<&T::var>("var").fun<&T::func>("func");
+             */
+            template <auto F>
+            class_registrar& fun(const char * name)
+            {
+                js_traits<std::shared_ptr<T>>::template ensureCanCastToBase<F>();
+                prototype.add<F>(name);
+                return *this;
+            }
+
+            /** Add a static member or function to the last added constructor.
+             * Example:
+             *  struct T { static int var; static int func(); }
+             *  module.class_<T>("T").contructor<>("T").static_fun<&T::var>("var").static_fun<&T::func>("func");
+             */
+            template <auto F>
+            class_registrar& static_fun(const char * name)
+            {
+                assert(!JS_IsNull(ctor.v) && "You should call .constructor before .static_fun");
+                js_traits<qjs::shared_ptr<T>>::template ensureCanCastToBase<F>();
+                ctor.add<F>(name);
+                return *this;
+            }
+
+            /** Add a property with custom getter and setter.
+             * Example:
+             * module.class_<T>("T").property<&T::getX, &T::setX>("x");
+             */
+            template <auto FGet, auto FSet = nullptr>
+            class_registrar& property(const char * name)
+            {
+                js_traits<std::shared_ptr<T>>::template ensureCanCastToBase<FGet>();
+                js_traits<std::shared_ptr<T>>::template ensureCanCastToBase<FSet>();
+                if constexpr (std::is_same_v<decltype(FSet), std::nullptr_t>)
+                    prototype.add_getter<FGet>(name);
+                else
+                    prototype.add_getter_setter<FGet, FSet>(name);
+                return *this;
+            }
+
+            /** Add class constructor
+             * @tparam Args contructor arguments
+             * @param name constructor name (if not specified class name will be used)
+             */
+            template <typename... Args>
+            class_registrar& constructor(const char * name = nullptr)
+            {
+                if(!name)
+                    name = this->name;
+                ctor = context.newValue(qjs::ctor_wrapper<T, Args...>{name});
+                JS_SetConstructor(context.ctx, ctor.v, prototype.v);
+                module.add(name, qjs::Value{ctor});
+                return *this;
+            }
+
+            /** Sets the base class
+             * @tparam B base class
+             */
+            template <class B>
+            class_registrar& base()
+            {
+                static_assert(!std::is_same_v<B, T>, "Type cannot be a base of itself");
+                assert(js_traits<std::shared_ptr<B>>::QJSClassId && "base class is not registered");
+                js_traits<std::shared_ptr<T>>::template ensureCanCastToBase<B>();
+                auto base_proto = JS_GetClassProto(context.ctx, js_traits<std::shared_ptr<B>>::QJSClassId);
+                int err = JS_SetPrototype(context.ctx, prototype.v, base_proto);
+                JS_FreeValue(context.ctx, base_proto);
+                if(err < 0)
+                    throw exception{context.ctx};
+                return *this;
+            }
+
+            /** All qjs::Value members of T should be marked by mark<> for QuickJS garbage collector
+             * so that the cycle removal algorithm can find the other objects referenced by this object.
+             */
+            template <Value T::* V>
+            class_registrar& mark()
+            {
+                js_traits<std::shared_ptr<T>>::markOffsets.push_back(V);
+                return *this;
+            }
+
+
+            ~class_registrar()
+            {
+                context.registerClass<T>(name, std::move(prototype));
+            }
+        };
+
+    public:
+        /** Add class to module.
+         * See \ref class_registrar.
+         */
+        template <class T>
+        class_registrar<T> class_(const char * name)
+        {
+            return class_registrar<T>{name, *this, qjs::Context::get(ctx)};
+        }
+
+    };
+
+    std::vector<Module> modules;
+private:
+    void init()
+    {
+        JS_SetContextOpaque(ctx, this);
+        js_traits<detail::function>::register_class(ctx, "C++ function");
+    }
+
+public:
+    Context(Runtime& rt) : Context(rt.rt) {}
+
+    Context(JSRuntime * rt)
+    {
+        ctx = JS_NewContext(rt);
+        if(!ctx)
+            throw std::runtime_error{"qjs: Cannot create context"};
+        init();
+    }
+
+    Context(JSContext * ctx) : ctx{ctx}
+    {
+        init();
+    }
+
+    // noncopyable
+    Context(const Context&) = delete;
+
+    ~Context()
+    {
+        modules.clear();
+        JS_FreeContext(ctx);
+    }
+
+    /** Callback triggered when a Promise rejection won't ever be handled */
+    std::function<void(Value)> onUnhandledPromiseRejection;
+
+    /** Data type returned by the moduleLoader function */
+    struct ModuleData {
+        std::optional<std::string> source, url;
+        ModuleData() : source(std::nullopt), url(std::nullopt) {}
+        ModuleData(std::optional<std::string> source) : source(std::move(source)), url(std::nullopt) {}
+        ModuleData(std::optional<std::string> url, std::optional<std::string> source) : source(std::move(source)), url(std::move(url)) {}
+    };
+
+    /** Function called to obtain the source of a module */
+    std::function<ModuleData(std::string_view)> moduleLoader =
+        [](std::string_view filename) -> ModuleData {
+            return ModuleData{ detail::toUri(filename), detail::readFile(filename) };
+        };
+
+    template <typename Function>
+    void enqueueJob(Function && job);
+
+    /** Create module and return a reference to it */
+    Module& addModule(const char * name)
+    {
+        modules.emplace_back(ctx, name);
+        return modules.back();
+    }
+
+    /** returns globalThis */
+    Value global() { return Value{ctx, JS_GetGlobalObject(ctx)}; }
+
+    /** returns new Object() */
+    Value newObject() { return Value{ctx, JS_NewObject(ctx)}; }
+
+    /** returns JS value converted from c++ object val */
+    template <typename T>
+    Value newValue(T&& val) { return Value{ctx, std::forward<T>(val)}; }
+
+    /** returns current exception associated with context and clears it. Should be called when qjs::exception is caught */
+    Value getException() { return Value{ctx, JS_GetException(ctx)}; }
+
+    /** Register class T for conversions to/from std::shared_ptr<T> to work.
+     * Wherever possible module.class_<T>("T")... should be used instead.
+     * @tparam T class type
+     * @param name class name in JS engine
+     * @param proto JS class prototype or JS_UNDEFINED
+     */
+    template <class T>
+    void registerClass(const char * name, JSValue proto = JS_NULL)
+    {
+        js_traits<std::shared_ptr<T>>::register_class(ctx, name, proto);
+    }
+
+    /// @see JS_Eval
+    Value eval(std::string_view buffer, const char * filename = "<eval>", int flags = 0)
+    {
+        assert(buffer.data()[buffer.size()] == '\0' && "eval buffer is not null-terminated"); // JS_Eval requirement
+        JSValue v = JS_Eval(ctx, buffer.data(), buffer.size(), filename, flags);
+        return Value{ctx, std::move(v)};
+    }
+
+    Value evalFile(const char * filename, int flags = 0)
+    {
+        auto buf = detail::readFile(filename);
+        if (!buf)
+            throw std::runtime_error{std::string{"evalFile: can't read file: "} + filename};
+        return eval(*buf, filename, flags);
+    }
+
+    /// @see JS_ParseJSON2
+    Value fromJSON(std::string_view buffer, const char * filename = "<fromJSON>", int flags = 0)
+    {
+        assert(buffer.data()[buffer.size()] == '\0' &&
+               "fromJSON buffer is not null-terminated"); // JS_ParseJSON requirement
+        return Value{ctx, JS_ParseJSON2(ctx, buffer.data(), buffer.size(), filename, flags)};
+    }
+
+    /** Get qjs::Context from JSContext opaque pointer */
+    static Context& get(JSContext * ctx)
+    {
+        void * ptr = JS_GetContextOpaque(ctx);
+        assert(ptr);
+        return *static_cast<Context *>(ptr);
+    }
+};
+
+/** Conversion traits for Value.
+ */
+template <>
+struct js_traits<Value>
+{
+    static Value unwrap(JSContext * ctx, JSValueConst v)
+    {
+        return Value{ctx, JS_DupValue(ctx, v)};
+    }
+
+    static JSValue wrap(JSContext * ctx, Value v) noexcept
+    {
+        assert(JS_GetRuntime(ctx) == JS_GetRuntime(v.ctx));
+        return v.release();
+    }
+};
+
+/** Convert to/from std::function. Actually accepts/returns callable object that is compatible with function<R (Args...)>.
+ * @tparam R return type
+ * @tparam Args argument types
+ */
+template <typename R, typename... Args>
+struct js_traits<std::function<R(Args...)>, int>
+{
+    static auto unwrap(JSContext * ctx, JSValueConst fun_obj)
+    {
+        const int argc = sizeof...(Args);
+        if constexpr(argc == 0)
+        {
+            return [jsfun_obj = Value{ctx, JS_DupValue(ctx, fun_obj)}]() -> R {
+                JSValue result = JS_Call(jsfun_obj.ctx, jsfun_obj.v, JS_UNDEFINED, 0, nullptr);
+                if(JS_IsException(result))
+                    throw exception{jsfun_obj.ctx};
+                return detail::unwrap_free<R>(jsfun_obj.ctx, result);
+            };
+        }
+        else
+        {
+            return [jsfun_obj = Value{ctx, JS_DupValue(ctx, fun_obj)}](Args ... args) -> R {
+                const int argc = sizeof...(Args);
+                JSValue argv[argc];
+                detail::wrap_args(jsfun_obj.ctx, argv, std::forward<Args>(args)...);
+                JSValue result = JS_Call(jsfun_obj.ctx, jsfun_obj.v, JS_UNDEFINED, argc,
+                                         const_cast<JSValueConst *>(argv));
+                for(int i = 0; i < argc; i++) JS_FreeValue(jsfun_obj.ctx, argv[i]);
+                if(JS_IsException(result))
+                    throw exception{jsfun_obj.ctx};
+                return detail::unwrap_free<R>(jsfun_obj.ctx, result);
+            };
+        }
+    }
+
+    /** Convert from function object functor to JSValue.
+     * Uses detail::function for type-erasure.
+     */
+    template <typename Functor>
+    static JSValue wrap(JSContext * ctx, Functor&& functor) noexcept
+    {
+        using detail::function;
+        assert(js_traits<function>::QJSClassId);
+        auto obj = JS_NewObjectClass(ctx, js_traits<function>::QJSClassId);
+        if(JS_IsException(obj))
+            return obj;
+        try
+        {
+            auto fptr = function::create(JS_GetRuntime(ctx), std::forward<Functor>(functor));
+            fptr->invoker = [](function * self, JSContext * ctx, JSValueConst this_value, int argc,
+                               JSValueConst * argv) {
+                assert(self);
+                auto f = reinterpret_cast<std::decay_t<Functor> *>(&self->functor);
+                return detail::wrap_call<R, Args...>(ctx, *f, argc, argv);
+            };
+            JS_SetOpaque(obj, fptr);
+            return obj;
+        }
+        catch(const std::exception& e)
+        {
+            JS_ThrowInternalError(ctx, "%s", e.what());
+            return JS_EXCEPTION;
+        }
+        catch(...)
+        {
+            JS_ThrowInternalError(ctx, "Unknown errror");
+            return JS_EXCEPTION;
+        }
+    }
+};
+
+namespace detail {
+
+template<typename T, typename = void>
+struct is_callable : std::is_function<T> { };
+
+template<typename T>
+struct is_callable<T, std::enable_if_t<std::is_same_v<decltype(void(&T::operator())), void>>> : std::true_type { };
+
+template<typename T>
+inline constexpr bool is_callable_v = is_callable<T>::value;
+
+}
+
+template <typename Function>
+struct js_traits<Function, std::enable_if_t<detail::is_callable_v<Function>>> {
+    static auto unwrap(JSContext * ctx, JSValueConst fun_obj)
+    {
+        return js_traits<
+            decltype(std::function{std::declval<Function>()}),
+            int
+        >::unwrap(ctx, fun_obj);
+    }
+
+    template <typename Functor>
+    static JSValue wrap(JSContext * ctx, Functor&& functor)
+    {
+        return js_traits<
+            decltype(std::function{std::declval<Function>()}),
+            int
+        >::wrap(ctx, std::forward<Functor>(functor));
+    }
+};
+
+/** Convert from std::vector<T> to Array and vice-versa. If Array holds objects that are non-convertible to T throws qjs::exception */
+template <class T>
+struct js_traits<std::vector<T>>
+{
+    static JSValue wrap(JSContext * ctx, const std::vector<T>& arr) noexcept
+    {
+        try
+        {
+            auto jsarray = Value{ctx, JS_NewArray(ctx)};
+            for(uint32_t i = 0; i < (uint32_t) arr.size(); i++)
+                jsarray[i] = arr[i];
+            return jsarray.release();
+        }
+        catch(exception)
+        {
+            return JS_EXCEPTION;
+        }
+        catch (std::exception const & err)
+        {
+            JS_ThrowInternalError(ctx, "%s", err.what());
+            return JS_EXCEPTION;
+        }
+        catch (...)
+        {
+            JS_ThrowInternalError(ctx, "Unknown error");
+            return JS_EXCEPTION;
+        }
+    }
+
+    static std::vector<T> unwrap(JSContext * ctx, JSValueConst jsarr)
+    {
+        int e = JS_IsArray(ctx, jsarr);
+        if(e == 0)
+            JS_ThrowTypeError(ctx, "js_traits<std::vector<T>>::unwrap expects array");
+        if(e <= 0)
+            throw exception{ctx};
+        Value jsarray{ctx, JS_DupValue(ctx, jsarr)};
+        std::vector<T> arr;
+        auto len = static_cast<int32_t>(jsarray["length"]);
+        arr.reserve((uint32_t) len);
+        for(uint32_t i = 0; i < (uint32_t) len; i++)
+            arr.push_back(static_cast<T>(jsarray[i]));
+        return arr;
+    }
+};
+
+
+template <typename U, typename V>
+struct js_traits<std::pair<U, V>>
+{
+    static JSValue wrap(JSContext * ctx, std::pair<U, V> obj) noexcept
+    {
+        try
+        {
+            auto jsarray = Value{ctx, JS_NewArray(ctx)};
+            jsarray[uint32_t(0)] = std::move(obj.first);
+            jsarray[uint32_t(1)] = std::move(obj.second);
+            return jsarray.release();
+        }
+        catch(exception)
+        {
+            return JS_EXCEPTION;
+        }
+        catch (std::exception const & err)
+        {
+            JS_ThrowInternalError(ctx, "%s", err.what());
+            return JS_EXCEPTION;
+        }
+        catch (...)
+        {
+            JS_ThrowInternalError(ctx, "Unknown error");
+            return JS_EXCEPTION;
+        }
+    }
+
+    static std::pair<U, V> unwrap(JSContext * ctx, JSValueConst jsarr)
+    {
+        int e = JS_IsArray(ctx, jsarr);
+        if(e == 0)
+            JS_ThrowTypeError(ctx, "js_traits<%s>::unwrap expects array", QJSPP_TYPENAME(std::pair<U, V>));
+        if(e <= 0)
+            throw exception{ctx};
+        Value jsarray{ctx, JS_DupValue(ctx, jsarr)};
+        const auto len = static_cast<uint32_t>(jsarray["length"]);
+        if(len != 2)
+        {
+            JS_ThrowTypeError(ctx, "js_traits<%s>::unwrap expected array of length 2, got length %d",
+                              QJSPP_TYPENAME(std::pair<U, V>), len);
+            throw exception{ctx};
+        }
+        return std::pair<U, V>{
+                static_cast<U>(jsarray[uint32_t(0)]),
+                static_cast<V>(jsarray[uint32_t(1)])
+        };
+    }
+};
+
+/** Conversions for std::optional.
+ * Unlike other types does not throw on unwrap but returns nullopt.
+ * Converts std::nullopt to null.
+ */
+template <typename T>
+struct js_traits<std::optional<T>>
+{
+    /** Wraps T or null. */
+    static JSValue wrap(JSContext * ctx, std::optional<T> obj) noexcept
+    {
+        if(obj)
+            return js_traits<std::decay_t<T>>::wrap(ctx, *obj);
+        return JS_NULL;
+    }
+
+    /** If conversion to T fails returns std::nullopt. */
+    static auto unwrap(JSContext * ctx, JSValueConst v) noexcept -> std::optional<decltype(js_traits<std::decay_t<T>>::unwrap(ctx, v))>
+    {
+        try
+        {
+            if(JS_IsNull(v))
+                return std::nullopt;
+            return js_traits<std::decay_t<T>>::unwrap(ctx, v);
+        }
+        catch(exception)
+        {
+            // ignore and clear exception
+            JS_FreeValue(ctx, JS_GetException(ctx));
+        }
+        return std::nullopt;
+    }
+};
+
+
+namespace detail {
+template <typename Key>
+property_proxy<Key>::operator Value() const
+{
+    return as<Value>();
+}
+}
+
+template <typename Function>
+void Context::enqueueJob(Function && job) {
+    JSValue job_val = js_traits<std::function<void()>>::wrap(ctx, std::forward<Function>(job));
+    JSValueConst arg = job_val;
+    int err = JS_EnqueueJob(ctx, [](JSContext *ctx, int argc, JSValueConst *argv){
+        try
+        {
+            assert(argc >= 1);
+            js_traits<std::function<void()>>::unwrap(ctx, argv[0])();
+        }
+        catch (exception)
+        {
+            return JS_EXCEPTION;
+        }
+        catch (std::exception const & err)
+        {
+            JS_ThrowInternalError(ctx, "%s", err.what());
+            return JS_EXCEPTION;
+        }
+        catch (...)
+        {
+            JS_ThrowInternalError(ctx, "Unknown error");
+            return JS_EXCEPTION;
+        }
+        return JS_UNDEFINED;
+    }, 1, &arg);
+    JS_FreeValue(ctx, job_val);
+    if(err < 0)
+        throw exception{ctx};
+}
+
+inline Context & exception::context() const {
+    return Context::get(ctx);
+}
+
+inline Value exception::get() {
+    return context().getException();
+}
+
+inline void Runtime::promise_unhandled_rejection_tracker(JSContext *ctx, JSValueConst promise,
+                                                         JSValueConst reason, JS_BOOL is_handled, void *opaque)
+{
+    auto & context = Context::get(ctx);
+    if (context.onUnhandledPromiseRejection) {
+        context.onUnhandledPromiseRejection(context.newValue(JS_DupValue(ctx, reason)));
+    }
+}
+
+inline JSModuleDef * Runtime::module_loader(JSContext *ctx,
+                                            const char *module_name, void *opaque)
+{
+    Context::ModuleData data;
+    auto & context = Context::get(ctx);
+
+    try {
+        if (context.moduleLoader) data = context.moduleLoader(module_name);
+
+        if (!data.source) {
+            JS_ThrowReferenceError(ctx, "could not load module filename '%s'", module_name);
+            return NULL;
+        }
+
+        if (!data.url) data.url = module_name;
+
+        // compile the module
+        auto func_val = context.eval(*data.source, module_name, JS_EVAL_TYPE_MODULE | JS_EVAL_FLAG_COMPILE_ONLY);
+        assert(JS_VALUE_GET_TAG(func_val.v) == JS_TAG_MODULE);
+        JSModuleDef * m = reinterpret_cast<JSModuleDef *>(JS_VALUE_GET_PTR(func_val.v));
+
+        // set import.meta
+        auto meta = context.newValue(JS_GetImportMeta(ctx, m));
+        meta["url"] = *data.url;
+        meta["main"] = false;
+
+        return m;
+    }
+    catch(exception)
+    {
+        return NULL;
+    }
+    catch (std::exception const & err)
+    {
+        JS_ThrowInternalError(ctx, "%s", err.what());
+        return NULL;
+    }
+    catch (...)
+    {
+        JS_ThrowInternalError(ctx, "Unknown error");
+        return NULL;
+    }
+}
+
+
+inline Context * Runtime::executePendingJob() {
+    JSContext * ctx;
+    auto err = JS_ExecutePendingJob(rt, &ctx);
+    if (err == 0) {
+        // There was no job to run
+        return nullptr;
+    } else if (err < 0) {
+        throw exception{ctx};
+    }
+    return &Context::get(ctx);
+}
+
+} // namespace qjs
Index: quickjs-src/quickjs/quickjs.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/quickjs.h b/quickjs-src/quickjs/include/quickjs/quickjs.h
rename from quickjs-src/quickjs/quickjs.h
rename to quickjs-src/quickjs/include/quickjs/quickjs.h
--- a/quickjs-src/quickjs/quickjs.h	(revision 321dbfa770463b8867d8ac90493c7cec015a9c3a)
+++ b/quickjs-src/quickjs/include/quickjs/quickjs.h	(date 1696647929596)
@@ -25,6 +25,7 @@
 #ifndef QUICKJS_H
 #define QUICKJS_H
 
+#include "quickjs-defs.h"
 #include <stdio.h>
 #include <stdint.h>
 
@@ -32,17 +33,10 @@
 extern "C" {
 #endif
 
-#if defined(__GNUC__) || defined(__clang__)
-#define js_likely(x)          __builtin_expect(!!(x), 1)
-#define js_unlikely(x)        __builtin_expect(!!(x), 0)
-#define js_force_inline       inline __attribute__((always_inline))
-#define __js_printf_like(f, a)   __attribute__((format(printf, f, a)))
-#else
-#define js_likely(x)     (x)
-#define js_unlikely(x)   (x)
-#define js_force_inline  inline
-#define __js_printf_like(a, b)
-#endif
+#define js_likely(x)           PLATFORM_LIKELY(x)
+#define js_unlikely(x)         PLATFORM_UNLIKELY(x)
+#define js_force_inline        PLATFORM_FORCE_INLINE
+#define __js_printf_like(f, a) PLATFORM_PRINTF_LIKE(f, a)
 
 #define JS_BOOL int
 
@@ -215,8 +209,14 @@
 #define JS_VALUE_GET_FLOAT64(v) ((v).u.float64)
 #define JS_VALUE_GET_PTR(v) ((v).u.ptr)
 
+// error C4576: a parenthesized type followed by an initializer list is a non-standard explicit type conversion syntax
+#if _MSC_VER && __cplusplus
+#define JS_MKVAL(tag, val) JSValue{ JSValueUnion{ .int32 = val }, tag }
+#define JS_MKPTR(tag, p) JSValue{ JSValueUnion{ .ptr = p }, tag }
+#else
 #define JS_MKVAL(tag, val) (JSValue){ (JSValueUnion){ .int32 = val }, tag }
 #define JS_MKPTR(tag, p) (JSValue){ (JSValueUnion){ .ptr = p }, tag }
+#endif
 
 #define JS_TAG_IS_FLOAT64(tag) ((unsigned)(tag) == JS_TAG_FLOAT64)
 
@@ -497,6 +497,7 @@
 } JSClassDef;
 
 JSClassID JS_NewClassID(JSClassID *pclass_id);
+JSClassID JS_GetClassID(JSValueConst v);
 int JS_NewClass(JSRuntime *rt, JSClassID class_id, const JSClassDef *class_def);
 int JS_IsRegisteredClass(JSRuntime *rt, JSClassID class_id);
 
@@ -666,7 +667,7 @@
         JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);
         p->ref_count++;
     }
-    return (JSValue)v;
+    return v;
 }
 
 static inline JSValue JS_DupValueRT(JSRuntime *rt, JSValueConst v)
@@ -675,7 +676,7 @@
         JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);
         p->ref_count++;
     }
-    return (JSValue)v;
+    return v;
 }
 
 int JS_ToBool(JSContext *ctx, JSValueConst val); /* return -1 for JS_EXCEPTION */
@@ -838,6 +839,7 @@
                                            JSValueConst reason,
                                            JS_BOOL is_handled, void *opaque);
 void JS_SetHostPromiseRejectionTracker(JSRuntime *rt, JSHostPromiseRejectionTracker *cb, void *opaque);
+void JS_SetHostUnhandledPromiseRejectionTracker(JSRuntime *rt, JSHostPromiseRejectionTracker *cb, void *opaque);
 
 /* return != 0 if the JS code needs to be interrupted */
 typedef int JSInterruptHandler(JSRuntime *rt, void *opaque);
Index: quickjs-src/quickjs/include/quickjs/quickjs-libc.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/include/quickjs/quickjs-libc.h b/quickjs-src/quickjs/include/quickjs/quickjs-libc.h
new file mode 100644
--- /dev/null	(date 1696647929596)
+++ b/quickjs-src/quickjs/include/quickjs/quickjs-libc.h	(date 1696647929596)
@@ -0,0 +1,59 @@
+/*
+ * QuickJS C library
+ * 
+ * Copyright (c) 2017-2018 Fabrice Bellard
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+#ifndef QUICKJS_LIBC_H
+#define QUICKJS_LIBC_H
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "quickjs.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+JSModuleDef *js_init_module_std(JSContext *ctx, const char *module_name);
+JSModuleDef *js_init_module_os(JSContext *ctx, const char *module_name);
+void js_std_add_helpers(JSContext *ctx, int argc, char **argv);
+void js_std_loop(JSContext *ctx);
+void js_std_init_handlers(JSRuntime *rt);
+void js_std_free_handlers(JSRuntime *rt);
+void js_std_dump_error(JSContext *ctx);
+uint8_t *js_load_file(JSContext *ctx, size_t *pbuf_len, const char *filename);
+int js_module_set_import_meta(JSContext *ctx, JSValueConst func_val,
+                              JS_BOOL use_realpath, JS_BOOL is_main);
+JSModuleDef *js_module_loader(JSContext *ctx,
+                              const char *module_name, void *opaque);
+void js_std_eval_binary(JSContext *ctx, const uint8_t *buf, size_t buf_len,
+                        int flags);
+void js_std_promise_rejection_tracker(JSContext *ctx, JSValueConst promise,
+                                      JSValueConst reason,
+                                      JS_BOOL is_handled, void *opaque);
+void js_std_set_worker_new_context_func(JSContext *(*func)(JSRuntime *rt));
+                                        
+#ifdef __cplusplus
+} /* extern "C" { */
+#endif
+
+#endif /* QUICKJS_LIBC_H */
Index: quickjs-src/quickjs/include/quickjs/quickjs-defs.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/quickjs-src/quickjs/include/quickjs/quickjs-defs.h b/quickjs-src/quickjs/include/quickjs/quickjs-defs.h
new file mode 100644
--- /dev/null	(date 1696647929596)
+++ b/quickjs-src/quickjs/include/quickjs/quickjs-defs.h	(date 1696647929596)
@@ -0,0 +1,116 @@
+#pragma once
+
+#include <stdint.h>
+
+//////////////////////////////////////////////////////////////////////////
+#if defined(_DEBUG) || defined(FORCE_DEBUG)
+#  define PLATFORM_IS_DEBUG 1
+#else
+#  define PLATFORM_IS_NDEBUG 1
+#endif
+
+#if defined(_WIN32)
+#  include <intrin.h>
+#  define PLATFORM_IS_WINDOWS 1
+#  if defined(_WIN64)
+#    define PLATFORM_IS_WIN64 1
+#  endif
+#endif
+
+#if defined(__ANDROID__)
+#  define PLATFORM_IS_ANDROID 1
+#endif
+
+#if defined(__APPLE__)
+#  define PLATFORM_IS_APPLE 1
+#  include <TargetConditionals.h>
+#  if TARGET_IPHONE_SIMULATOR
+#    define PLATFORM_IS_IPHONE 1
+#    define PLATFORM_IS_IPHONE_SIMULATOR 1
+#  elif TARGET_OS_IPHONE
+#    define PLATFORM_IS_IPHONE 1
+#  elif TARGET_OS_MAC
+#    define PLATFORM_IS_MAC 1
+#  endif
+#endif
+
+#if defined(__linux__)
+#  define PLATFORM_IS_LINUX 1
+#endif
+
+#if defined(__FreeBSD__)
+#  define PLATFORM_IS_FREEBSD 1
+#endif
+
+#if defined(__unix__)
+#  define PLATFORM_IS_UNIX 1
+#endif
+
+#if defined(__x86_64__) || defined(_M_X64)
+#  define PLATFORM_ARCH_X86 1
+#  define PLATFORM_IS_X64 1
+#elif defined(__i386__) || defined(_M_IX86)
+#  define PLATFORM_ARCH_X86 1
+#  define PLATFORM_IS_X86 1
+#endif
+
+#if defined(__aarch64__)
+#  define PLATFORM_ARCH_ARM 1
+#  define PLATFORM_IS_ARM64 1
+#elif defined(__arm__) || defined(_M_ARM)
+#  define PLATFORM_ARCH_ARM 1
+#  define PLATFORM_IS_ARM32 1
+#endif
+
+//////////////////////////////////////////////////////////////////////////
+#if UINTPTR_MAX == UINT32_MAX
+#  define PLATFORM_IS_32BIT 1
+#else
+#  define PLATFORM_IS_64BIT 1
+#endif
+
+//////////////////////////////////////////////////////////////////////////
+#if defined(__clang__) || defined(__GNUC__)
+#  define PLATFORM_GNUC_LIKE 1
+#  if defined(PLATFORM_ARCH_X86)
+#    include <x86intrin.h>
+#  elif defined(PLATFORM_ARCH_ARM)
+#    include <arm_acle.h>
+#    if defined(__ARM_NEON__)
+#      include <arm_neon.h>
+#    endif
+#  endif
+#elif defined(_MSC_VER)
+#  define PLATFORM_MSVC_LIKE 1
+#else
+#  error Cannot detect compiler environment!
+#endif
+
+//////////////////////////////////////////////////////////////////////////
+#if defined(PLATFORM_GNUC_LIKE)
+#  define PLATFORM_LIKELY(x)			__builtin_expect(!!(x), 1)
+#  define PLATFORM_UNLIKELY(x)			__builtin_expect(!!(x), 0)
+#  define PLATFORM_FORCE_INLINE			inline __attribute__((always_inline))
+#  define PLATFORM_NO_INLINE			__attribute__((noinline))
+#  define PLATFORM_MAYBE_UNUSED			__attribute__((unused))
+#  define PLATFORM_WARN_UNUSED			__attribute__((warn_unused_result))
+#  define PLATFORM_PRINTF_LIKE(f, a)	__attribute__((format(printf, f, a)))
+#else
+#  define PLATFORM_LIKELY(x)			x
+#  define PLATFORM_UNLIKELY(x)			x
+#  define PLATFORM_FORCE_INLINE			__forceinline
+#  define PLATFORM_NO_INLINE			__declspec(noinline)
+#  define PLATFORM_MAYBE_UNUSED
+#  define PLATFORM_WARN_UNUSED
+#  define PLATFORM_PRINTF_LIKE(f, a)
+#endif
+
+//////////////////////////////////////////////////////////////////////////
+#if defined(PLATFORM_IS_WINDOWS)
+
+typedef intptr_t ssize_t;
+
+
+#endif
+
+//////////////////////////////////////////////////////////////////////////
Index: indigo-src/indigo/api/c/indigo/src/indigo_misc.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_misc.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_misc.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_misc.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_misc.cpp	(date 1701847510201)
@@ -42,7 +42,7 @@
 #include "indigo_savers.h"
 #include "indigo_structure_checker.h"
 
-CEXPORT int indigoAromatize(int object)
+int indigoAromatize(int object)
 {
     INDIGO_BEGIN
     {
@@ -58,7 +58,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDearomatize(int object)
+int indigoDearomatize(int object)
 {
     INDIGO_BEGIN
     {
@@ -78,7 +78,7 @@
 }
 
 #define INDIGO_SET_OPTION(SUFFIX, TYPE)                                                                                                                        \
-    CEXPORT int indigoSetOption##SUFFIX(const char* name, TYPE value)                                                                                          \
+    int indigoSetOption##SUFFIX(const char* name, TYPE value)                                                                                          \
     {                                                                                                                                                          \
         INDIGO_BEGIN                                                                                                                                           \
         {                                                                                                                                                      \
@@ -93,7 +93,7 @@
 INDIGO_SET_OPTION(Bool, int)
 INDIGO_SET_OPTION(Float, float)
 
-CEXPORT int indigoSetOptionColor(const char* name, float r, float g, float b)
+int indigoSetOptionColor(const char* name, float r, float g, float b)
 {
     INDIGO_BEGIN
     {
@@ -102,7 +102,7 @@
     }
     INDIGO_END(-1);
 }
-CEXPORT int indigoSetOptionXY(const char* name, int x, int y)
+int indigoSetOptionXY(const char* name, int x, int y)
 {
     INDIGO_BEGIN
     {
@@ -112,7 +112,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetOption(const char* name)
+const char* indigoGetOption(const char* name)
 {
     INDIGO_BEGIN
     {
@@ -123,7 +123,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoGetOptionInt(const char* name, int* value)
+int indigoGetOptionInt(const char* name, int* value)
 {
     INDIGO_BEGIN
     {
@@ -136,7 +136,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetOptionBool(const char* name, int* value)
+int indigoGetOptionBool(const char* name, int* value)
 {
     INDIGO_BEGIN
     {
@@ -149,7 +149,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetOptionFloat(const char* name, float* value)
+int indigoGetOptionFloat(const char* name, float* value)
 {
     INDIGO_BEGIN
     {
@@ -162,7 +162,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetOptionColor(const char* name, float* r, float* g, float* b)
+int indigoGetOptionColor(const char* name, float* r, float* g, float* b)
 {
     INDIGO_BEGIN
     {
@@ -175,7 +175,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetOptionXY(const char* name, int* x, int* y)
+int indigoGetOptionXY(const char* name, int* x, int* y)
 {
     INDIGO_BEGIN
     {
@@ -188,7 +188,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetOptionType(const char* name)
+const char* indigoGetOptionType(const char* name)
 {
     INDIGO_BEGIN
     {
@@ -199,7 +199,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoResetOptions()
+int indigoResetOptions()
 {
     INDIGO_BEGIN
     {
@@ -229,7 +229,7 @@
     }
 }
 
-CEXPORT const char* indigoCheckBadValence(int handle)
+const char* indigoCheckBadValence(int handle)
 {
     INDIGO_BEGIN
     {
@@ -318,7 +318,7 @@
         }
 }
 
-CEXPORT const char* indigoCheckAmbiguousH(int handle)
+const char* indigoCheckAmbiguousH(int handle)
 {
     INDIGO_BEGIN
     {
@@ -375,7 +375,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoSmiles(int item)
+const char* indigoSmiles(int item)
 {
     INDIGO_BEGIN
     {
@@ -387,7 +387,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoCanonicalSmiles(int item)
+const char* indigoCanonicalSmiles(int item)
 {
     INDIGO_BEGIN
     {
@@ -400,7 +400,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int64_t indigoHash(int item)
+int64_t indigoHash(int item)
 {
     INDIGO_BEGIN
     {
@@ -421,7 +421,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoSmarts(int item)
+const char* indigoSmarts(int item)
 {
     INDIGO_BEGIN
     {
@@ -434,7 +434,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoCanonicalSmarts(int item)
+const char* indigoCanonicalSmarts(int item)
 {
     INDIGO_BEGIN
     {
@@ -447,7 +447,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoUnfoldHydrogens(int item)
+int indigoUnfoldHydrogens(int item)
 {
     INDIGO_BEGIN
     {
@@ -499,7 +499,7 @@
     return to_remove.size() > 0;
 }
 
-CEXPORT int indigoFoldHydrogens(int item)
+int indigoFoldHydrogens(int item)
 {
     INDIGO_BEGIN
     {
@@ -523,7 +523,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetName(int handle, const char* name)
+int indigoSetName(int handle, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -540,7 +540,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoName(int handle)
+const char* indigoName(int handle)
 {
     INDIGO_BEGIN
     {
@@ -549,7 +549,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoRawData(int handler)
+const char* indigoRawData(int handler)
 {
     INDIGO_BEGIN
     {
@@ -579,7 +579,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoRemove(int item)
+int indigoRemove(int item)
 {
     INDIGO_BEGIN
     {
@@ -591,7 +591,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAt(int item, int index)
+int indigoAt(int item, int index)
 {
     INDIGO_BEGIN
     {
@@ -636,7 +636,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCount(int item)
+int indigoCount(int item)
 {
     INDIGO_BEGIN
     {
@@ -659,7 +659,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSerialize(int item, byte** buf, int* size)
+int indigoSerialize(int item, byte** buf, int* size)
 {
     INDIGO_BEGIN
     {
@@ -696,7 +696,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoUnserialize(const byte* buf, int size)
+int indigoUnserialize(const byte* buf, int size)
 {
     INDIGO_BEGIN
     {
@@ -722,7 +722,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClear(int item)
+int indigoClear(int item)
 {
     INDIGO_BEGIN
     {
@@ -745,7 +745,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoHighlight(int item)
+int indigoHighlight(int item)
 {
     INDIGO_BEGIN
     {
@@ -771,7 +771,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoUnhighlight(int item)
+int indigoUnhighlight(int item)
 {
     INDIGO_BEGIN
     {
@@ -809,7 +809,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIsHighlighted(int item)
+int indigoIsHighlighted(int item)
 {
     INDIGO_BEGIN
     {
@@ -835,7 +835,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSelect(int item)
+int indigoSelect(int item)
 {
     INDIGO_BEGIN
     {
@@ -861,7 +861,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoUnselect(int item)
+int indigoUnselect(int item)
 {
     INDIGO_BEGIN
     {
@@ -899,7 +899,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIsSelected(int item)
+int indigoIsSelected(int item)
 {
     INDIGO_BEGIN
     {
@@ -925,7 +925,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoOptimize(int query, const char* options)
+int indigoOptimize(int query, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -981,17 +981,17 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoHasZCoord(int item)
+int indigoHasZCoord(int item)
 {
     return _indigoHasCoord(item, BaseMolecule::hasZCoord, "indigoHasZCoord");
 }
 
-CEXPORT int indigoHasCoord(int item)
+int indigoHasCoord(int item)
 {
     return _indigoHasCoord(item, BaseMolecule::hasCoord, "indigoHasCoord");
 }
 
-CEXPORT const char* indigoDbgInternalType(int object)
+const char* indigoDbgInternalType(int object)
 {
     INDIGO_BEGIN
     {
@@ -1006,7 +1006,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoNormalize(int structure, const char* options)
+int indigoNormalize(int structure, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -1057,7 +1057,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoStandardize(int object)
+int indigoStandardize(int object)
 {
     INDIGO_BEGIN
     {
@@ -1082,7 +1082,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIonize(int object, float pH, float pH_toll)
+int indigoIonize(int object, float pH, float pH_toll)
 {
     INDIGO_BEGIN
     {
@@ -1094,7 +1094,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoBuildPkaModel(int max_level, float threshold, const char* filename)
+int indigoBuildPkaModel(int max_level, float threshold, const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -1106,7 +1106,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT float* indigoGetAcidPkaValue(int object, int atom, int level, int min_level)
+float* indigoGetAcidPkaValue(int object, int atom, int level, int min_level)
 {
     INDIGO_BEGIN
     {
@@ -1129,7 +1129,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT float* indigoGetBasicPkaValue(int object, int atom, int level, int min_level)
+float* indigoGetBasicPkaValue(int object, int atom, int level, int min_level)
 {
     INDIGO_BEGIN
     {
@@ -1152,7 +1152,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoIsPossibleFischerProjection(int object, const char* options)
+int indigoIsPossibleFischerProjection(int object, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -1205,7 +1205,7 @@
     }
 }
 
-CEXPORT int indigoTransformHELMtoSCSR(int object)
+int indigoTransformHELMtoSCSR(int object)
 {
     INDIGO_BEGIN
     {
@@ -1254,7 +1254,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCheckQuery(int item)
+int indigoCheckQuery(int item)
 {
     INDIGO_BEGIN
     {
@@ -1297,7 +1297,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCheckChirality(int item)
+int indigoCheckChirality(int item)
 {
     INDIGO_BEGIN
     {
@@ -1321,7 +1321,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCheck3DStereo(int item)
+int indigoCheck3DStereo(int item)
 {
     INDIGO_BEGIN
     {
@@ -1358,7 +1358,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCheckStereo(int item)
+int indigoCheckStereo(int item)
 {
     INDIGO_BEGIN
     {
@@ -1401,7 +1401,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoCheck(const char* item, const char* check_flags, const char* load_params)
+const char* indigoCheck(const char* item, const char* check_flags, const char* load_params)
 {
     INDIGO_BEGIN
     {
@@ -1416,7 +1416,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoCheckObj(int item, const char* check_flags)
+const char* indigoCheckObj(int item, const char* check_flags)
 {
     INDIGO_BEGIN
     {
@@ -1430,7 +1430,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoCheckStructure(const char* structure, const char* props)
+const char* indigoCheckStructure(const char* structure, const char* props)
 {
     INDIGO_BEGIN
     {
@@ -1456,7 +1456,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoJson(int item)
+const char* indigoJson(int item)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/option_manager.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/option_manager.h b/indigo-src/indigo/api/c/indigo/src/option_manager.h
--- a/indigo-src/indigo/api/c/indigo/src/option_manager.h	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/option_manager.h	(date 1701847510204)
@@ -21,12 +21,13 @@
 
 #include "base_cpp/os_sync_wrapper.h"
 #include "base_cpp/red_black.h"
+#include "indigo.h"
 
 #include <sstream>
 
 using namespace indigo;
 
-#define DECL_SET_OPT_HANDLER(suffix, ftype, type, map) DLLEXPORT void setOptionHandler##suffix(const char* name, ftype func);
+#define DECL_SET_OPT_HANDLER(suffix, ftype, type, map) INDIGO_EXPORT void setOptionHandler##suffix(const char* name, ftype func);
 
 #define DEF_HANDLER(suffix, ftype, type, map)                                                                                                                  \
     void setOptionHandler##suffix(const char* name, ftype func)                                                                                                \
@@ -84,7 +85,7 @@
         value.push(0);                                                                                                                                         \
     }
 
-class DLLEXPORT IndigoOptionManager
+class INDIGO_EXPORT IndigoOptionManager
 {
 public:
     IndigoOptionManager() = default;
@@ -186,4 +187,7 @@
     IndigoOptionManager(const IndigoOptionManager&);
 };
 
+INDIGO_EXPORT sf::safe_shared_hide_obj<IndigoOptionManager> &
+indigoGetOptionManager(const qword id = TL_GET_SESSION_ID());
+
 #endif //__otion_manager_h__
Index: indigo-src/indigo/api/c/indigo/src/indigo_match.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_match.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_match.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_match.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_match.cpp	(date 1701847510200)
@@ -72,7 +72,7 @@
     label_list.push(Element::fromString(buf.ptr()));
 }
 
-CEXPORT int indigoSetTautomerRule(int n, const char* beg, const char* end)
+int indigoSetTautomerRule(int n, const char* beg, const char* end)
 {
     INDIGO_BEGIN
     {
@@ -91,7 +91,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearTautomerRules()
+int indigoClearTautomerRules()
 {
     INDIGO_BEGIN
     {
@@ -101,7 +101,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRemoveTautomerRule(int n)
+int indigoRemoveTautomerRule(int n)
 {
     INDIGO_BEGIN
     {
@@ -111,7 +111,7 @@
     INDIGO_END(-1);
 }
 
-DLLEXPORT bool _indigoParseTautomerFlags(const char* flags, IndigoTautomerParams& params)
+bool _indigoParseTautomerFlags(const char* flags, IndigoTautomerParams& params)
 {
     if (flags == 0)
         return false;
@@ -135,7 +135,7 @@
     return true;
 }
 
-DLLEXPORT int _indigoParseExactFlags(const char* flags, bool reaction, float* rms_threshold)
+int _indigoParseExactFlags(const char* flags, bool reaction, float* rms_threshold)
 {
     if (flags == 0)
         throw IndigoError("_indigoParseExactFlags(): zero string pointer");
@@ -243,7 +243,7 @@
     return res;
 }
 
-CEXPORT int indigoExactMatch(int handler1, int handler2, const char* flags)
+int indigoExactMatch(int handler1, int handler2, const char* flags)
 {
     INDIGO_BEGIN
     {
@@ -727,7 +727,7 @@
     return true;
 }
 
-CEXPORT int indigoSubstructureMatcher(int target, const char* mode_str)
+int indigoSubstructureMatcher(int target, const char* mode_str)
 {
     INDIGO_BEGIN
     {
@@ -797,7 +797,7 @@
                                        method);
 }
 
-CEXPORT int indigoIgnoreAtom(int target_matcher, int atom_object)
+int indigoIgnoreAtom(int target_matcher, int atom_object)
 {
     INDIGO_BEGIN
     {
@@ -811,7 +811,7 @@
 }
 
 // Ignore target atom in the substructure matcher
-CEXPORT int indigoUnignoreAtom(int target_matcher, int atom_object)
+int indigoUnignoreAtom(int target_matcher, int atom_object)
 {
     INDIGO_BEGIN
     {
@@ -824,7 +824,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoUnignoreAllAtoms(int target_matcher)
+int indigoUnignoreAllAtoms(int target_matcher)
 {
     INDIGO_BEGIN
     {
@@ -835,7 +835,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoMatch(int target_matcher, int query)
+int indigoMatch(int target_matcher, int query)
 {
     INDIGO_BEGIN
     {
@@ -947,7 +947,7 @@
     return indigoCountMatchesWithLimit(target_matcher, query, 0);
 }
 
-CEXPORT int indigoCountMatchesWithLimit(int target_matcher, int query, int embeddings_limit)
+int indigoCountMatchesWithLimit(int target_matcher, int query, int embeddings_limit)
 {
     INDIGO_BEGIN
     {
Index: openbabel-src/openbabel/include/openbabel/inchiformat.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/inchiformat.h b/openbabel-src/openbabel/include/openbabel/inchiformat.h
--- a/openbabel-src/openbabel/include/openbabel/inchiformat.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/inchiformat.h	(date 1696647929166)
@@ -131,7 +131,6 @@
   // and "CH4" is less than "C2H6"
   // and "CH4" is less than "ClH" (hydrogen chloride)
   struct InchiLess
-    : public std::binary_function<const std::string&, const std::string&, bool>
   {
     bool operator()(const std::string& s1, const std::string& s2) const
     {
@@ -146,12 +145,14 @@
           {
             n1 = atoi(&*p1);
             //skip over number
-            while(p1!=s1.end() && isdigit(*p1++)); --p1;
+            while(p1!=s1.end() && isdigit(*p1++)) {}
+            --p1;
           }
         if(isdigit(*p2))
           {
             n2 = atoi(&*p2);
-            while(p2!=s2.end() && isdigit(*p2++)); --p2;
+            while(p2!=s2.end() && isdigit(*p2++)) {}
+            --p2;
           }
         if(n1<0 && n2 < 0)
           {
Index: openbabel-src/openbabel/include/openbabel/plugin.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/plugin.h b/openbabel-src/openbabel/include/openbabel/plugin.h
--- a/openbabel-src/openbabel/include/openbabel/plugin.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/plugin.h	(date 1696647929169)
@@ -20,7 +20,6 @@
 #define OB_PLUGIN_H
 
 #include <openbabel/babelconfig.h>
-#include <openbabel/dlhandler.h>
 #include <string>
 #include <iostream>
 #include <vector>
@@ -38,7 +37,7 @@
 ///@{
 
 /// @brief Case insensitive string comparison for PluginMapType key.
-struct OBERROR CharPtrLess : public std::binary_function<const char*,const char*, bool>
+struct OBERROR CharPtrLess
 {
   bool operator()(const char* p1,const char* p2) const
   { return strcasecmp(p1,p2)<0; }
@@ -150,53 +149,13 @@
   const char* _id;
 };
 
-#if defined(__CYGWIN__) || defined(__MINGW32__)
-
 //Macro to be added to definition of the base class
 #define MAKE_PLUGIN(BaseClass)\
-protected:\
-  static PluginMapType& Map();\
-  virtual PluginMapType& GetMap() const {\
-    return Map();\
-  }\
-public:\
-  static BaseClass*& Default() {\
-    static BaseClass* d;\
-    return d;\
-  }\
-  BaseClass(const char* ID, bool IsDefault=false) {\
-    _id=ID;\
-    if (ID&&*ID) {\
-      if (IsDefault || Map().empty()) {\
-        Default() = this;\
-      }\
-      if (Map().count(ID) == 0) {\
-        Map()[ID] = this;\
-        PluginMap()[TypeID()] = this;\
-      }\
-    }\
-  }\
-  static BaseClass* FindType(const char* ID) {\
-    if (!ID || *ID==0 || *ID==' ') {\
-      return Default();\
-    }\
-    return static_cast<BaseClass*>(BaseFindType(Map(),ID));\
-  }
-
-#define PLUGIN_CPP_FILE(BaseClass)\
-OBPlugin::PluginMapType& BaseClass::Map() {\
-  static OBPlugin::PluginMapType map;\
-  return map;\
-}
-
-#else // __CYGWIN__ || __MINGW32__
-
-//Macro to be added to definition of the base class
-#define MAKE_PLUGIN(BaseClass)\
+private:\
+   inline static PluginMapType mPluginMapHolder;\
 protected:\
   static PluginMapType& Map() {\
-    static PluginMapType m;\
-    return m;\
+    return mPluginMapHolder;\
   }\
   virtual PluginMapType& GetMap() const {\
     return Map();\
@@ -223,9 +182,8 @@
       return Default();\
     }\
     return static_cast<BaseClass*>(BaseFindType(Map(),ID));\
-  }
-
-#endif // __CYGWIN__ || __MINGW32__
+  }\
+  private:
 
 /** \file plugin.h
    \brief Simplify 'plugin' classes to be discovered and/or loaded at runtime.
@@ -371,7 +329,7 @@
 
 #define OB_STATIC_PLUGIN(className,instanceName) \
   class className; \
-  OBAPI OB_EXTERN className instanceName;
+  OB_EXTERN className instanceName;
 
   // formats
   OB_STATIC_PLUGIN(ABINITFormat, theABINITFormat)
@@ -430,6 +388,8 @@
   OB_STATIC_PLUGIN(HINFormat, theHINFormat)
   OB_STATIC_PLUGIN(JaguarOutputFormat, theJaguarOutputFormat)
   OB_STATIC_PLUGIN(JaguarInputFormat, theJaguarInputFormat)
+  OB_STATIC_PLUGIN(ChemDoodleJSONFormat, theChemDoodleJSONFormat)
+  OB_STATIC_PLUGIN(PubChemJSONFormat, thePubChemJSONFormat)
   OB_STATIC_PLUGIN(LMPDATFormat, theLMPDATFormat)
   OB_STATIC_PLUGIN(MCDLFormat, theMCDLFormat)
   OB_STATIC_PLUGIN(MOLFormat, theMOLFormat)
@@ -463,6 +423,7 @@
   OB_STATIC_PLUGIN(PDBQTFormat, thePDBQTFormat)
 #ifdef HAVE_LIBZ
   OB_STATIC_PLUGIN(PNGFormat, thePNGFormat)
+  OB_STATIC_PLUGIN(PNG2Format, thePNG2Format)
 #endif
   OB_STATIC_PLUGIN(PointCloudFormat, thePointCloudFormat)
   OB_STATIC_PLUGIN(PovrayFormat, thePovrayFormat)
@@ -502,6 +463,8 @@
 #endif
 #ifdef HAVE_STATIC_INCHI
   OB_STATIC_PLUGIN(InChIFormat, theInChIFormat)
+  OB_STATIC_PLUGIN(InChICompareFormat, theInChICompareFormat)
+  OB_STATIC_PLUGIN(InChIKeyFormat, theInChIKeyFormat)
 #endif
 #ifdef HAVE_REGEX_H
   OB_STATIC_PLUGIN(GAMESSUKInputFormat, theGAMESSUKInputFormat)
@@ -560,6 +523,7 @@
   OB_STATIC_PLUGIN(OpFillUC, theOpFillUC)
   OB_STATIC_PLUGIN(OpEnergy, theOpEnergy)
   OB_STATIC_PLUGIN(OpMinimize, theOpMinimize)
+  OB_STATIC_PLUGIN(Op2D, theOp2D)
   OB_STATIC_PLUGIN(OpGen2D, theOpGen2D)
   OB_STATIC_PLUGIN(OpGen3D, theOpGen3D)
   OB_STATIC_PLUGIN(OpNewS, theOpNewS)
Index: indigo-src/indigo/api/c/indigo/src/indigo_calc.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_calc.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_calc.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_calc.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_calc.cpp	(date 1701847510198)
@@ -37,7 +37,7 @@
     ReactionGrossFormula::toString_Hill(*gross, str, self.gross_formula_options.add_rsites);
 }
 
-CEXPORT int indigoGrossFormula(int object)
+int indigoGrossFormula(int object)
 {
     INDIGO_BEGIN
     {
@@ -81,7 +81,7 @@
     }
 }
 
-CEXPORT double indigoMolecularWeight(int molecule)
+double indigoMolecularWeight(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -93,7 +93,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT double indigoMostAbundantMass(int molecule)
+double indigoMostAbundantMass(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -105,7 +105,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT double indigoMonoisotopicMass(int molecule)
+double indigoMonoisotopicMass(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -117,7 +117,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoMassComposition(int molecule)
+const char* indigoMassComposition(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -133,7 +133,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT double indigoTPSA(const int molecule, const int includeSP)
+double indigoTPSA(const int molecule, const int includeSP)
 {
     INDIGO_BEGIN
     {
@@ -148,7 +148,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoNumRotatableBonds(const int molecule)
+int indigoNumRotatableBonds(const int molecule)
 {
     INDIGO_BEGIN
     {
@@ -163,7 +163,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoNumHydrogenBondAcceptors(const int molecule)
+int indigoNumHydrogenBondAcceptors(const int molecule)
 {
     INDIGO_BEGIN
     {
@@ -178,7 +178,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoNumHydrogenBondDonors(const int molecule)
+int indigoNumHydrogenBondDonors(const int molecule)
 {
     INDIGO_BEGIN
     {
@@ -193,7 +193,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT double indigoLogP(const int molecule)
+double indigoLogP(const int molecule)
 {
     INDIGO_BEGIN
     {
@@ -208,7 +208,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT double indigoMolarRefractivity(const int molecule)
+double indigoMolarRefractivity(const int molecule)
 {
     INDIGO_BEGIN
     {
@@ -223,7 +223,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT double indigoPka(const int molecule)
+double indigoPka(const int molecule)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.h b/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.h	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.h	(date 1701847510199)
@@ -26,7 +26,7 @@
 #pragma warning(disable : 4251)
 #endif
 
-class DLLEXPORT IndigoFingerprint : public IndigoObject
+class INDIGO_EXPORT IndigoFingerprint : public IndigoObject
 {
 public:
     IndigoFingerprint();
Index: freetype-src/freetype/include/freetype/config/ftoption.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/freetype-src/freetype/include/freetype/config/ftoption.h b/freetype-src/freetype/include/freetype/config/ftoption.h
--- a/freetype-src/freetype/include/freetype/config/ftoption.h	(revision 920c5502cc3ddda88f6c7d85ee834ac611bb11cc)
+++ b/freetype-src/freetype/include/freetype/config/ftoption.h	(date 1701847331244)
@@ -273,7 +273,7 @@
    *   options set by those programs have precedence, overwriting the value
    *   here with the configured one.
    */
-/* #define FT_CONFIG_OPTION_USE_PNG */
+#define FT_CONFIG_OPTION_USE_PNG
 
 
   /**************************************************************************
Index: indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.cpp	(date 1701847510198)
@@ -1564,7 +1564,7 @@
     return false;
 }
 
-CEXPORT int indigoDecomposeMolecules(int scaffold, int structures)
+int indigoDecomposeMolecules(int scaffold, int structures)
 {
     INDIGO_BEGIN
     {
@@ -1585,7 +1585,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateDecomposedMolecules(int decomp)
+int indigoIterateDecomposedMolecules(int decomp)
 {
     INDIGO_BEGIN
     {
@@ -1601,7 +1601,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDecomposedMoleculeScaffold(int decomp)
+int indigoDecomposedMoleculeScaffold(int decomp)
 {
     INDIGO_BEGIN
     {
@@ -1658,7 +1658,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDecomposedMoleculeHighlighted(int decomp)
+int indigoDecomposedMoleculeHighlighted(int decomp)
 {
     INDIGO_BEGIN
     {
@@ -1694,7 +1694,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDecomposedMoleculeSubstituents(int decomp)
+int indigoDecomposedMoleculeSubstituents(int decomp)
 {
     INDIGO_BEGIN
     {
@@ -1732,7 +1732,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDecomposedMoleculeWithRGroups(int decomp)
+int indigoDecomposedMoleculeWithRGroups(int decomp)
 {
     INDIGO_BEGIN
     {
@@ -1775,7 +1775,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateDecomposer(int scaffold)
+int indigoCreateDecomposer(int scaffold)
 {
     INDIGO_BEGIN
     {
@@ -1792,7 +1792,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDecomposeMolecule(int decomp, int mol)
+int indigoDecomposeMolecule(int decomp, int mol)
 {
     INDIGO_BEGIN
     {
@@ -1813,7 +1813,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateDecompositions(int deco_item)
+int indigoIterateDecompositions(int deco_item)
 {
     INDIGO_BEGIN
     {
@@ -1837,7 +1837,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddDecomposition(int decomp, int q_match)
+int indigoAddDecomposition(int decomp, int q_match)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_internal.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_internal.h b/indigo-src/indigo/api/c/indigo/src/indigo_internal.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_internal.h	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_internal.h	(date 1701847510199)
@@ -68,9 +68,7 @@
     typedef ObjArray<PropertiesMap> MonomersProperties;
 } // namespace indigo
 
-extern DLLEXPORT sf::safe_shared_hide_obj<IndigoOptionManager>& indigoGetOptionManager(const qword id = TL_GET_SESSION_ID());
-
-class DLLEXPORT IndigoObject
+class INDIGO_EXPORT IndigoObject
 {
 public:
     explicit IndigoObject(int type_);
@@ -229,7 +227,7 @@
     std::unique_ptr<std::pair<PtrArray<GROSS_UNITS>, PtrArray<GROSS_UNITS>>> gross;
 };
 
-struct DLLEXPORT ProductEnumeratorParams
+struct INDIGO_EXPORT ProductEnumeratorParams
 {
     ProductEnumeratorParams()
     {
@@ -256,7 +254,7 @@
     int max_product_count;
 };
 
-class DLLEXPORT Indigo
+class INDIGO_EXPORT Indigo
 {
 public:
     Indigo();
@@ -378,7 +376,7 @@
     std::unique_ptr<abbreviations::IndigoAbbreviations> _abbreviations = nullptr;
 };
 
-class DLLEXPORT IndigoPluginContext
+class INDIGO_EXPORT IndigoPluginContext
 {
 public:
     IndigoPluginContext();
@@ -417,9 +415,9 @@
     return fail;                                                                                                                                               \
     }
 
-DLLEXPORT Indigo& indigoGetInstance();
+INDIGO_EXPORT Indigo& indigoGetInstance();
 
-class DLLEXPORT IndigoError : public Exception
+class INDIGO_EXPORT IndigoError : public Exception
 {
 public:
     explicit IndigoError(const char* format, ...);
Index: indigo-src/indigo/api/c/indigo/src/indigo_array.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_array.h b/indigo-src/indigo/api/c/indigo/src/indigo_array.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_array.h	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_array.h	(date 1701847510197)
@@ -26,7 +26,7 @@
 #pragma warning(disable : 4251)
 #endif
 
-class DLLEXPORT IndigoArray : public IndigoObject
+class INDIGO_EXPORT IndigoArray : public IndigoObject
 {
 public:
     IndigoArray();
@@ -41,7 +41,7 @@
     PtrArray<IndigoObject> objects;
 };
 
-class DLLEXPORT IndigoArrayElement : public IndigoObject
+class INDIGO_EXPORT IndigoArrayElement : public IndigoObject
 {
 public:
     IndigoArrayElement(IndigoArray& arr, int idx_);
Index: indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_fingerprints.cpp	(date 1701847510199)
@@ -118,7 +118,7 @@
         throw IndigoError("unknown molecule fingerprint type: %s", type);
 }
 
-CEXPORT int indigoFingerprint(int item, const char* type)
+int indigoFingerprint(int item, const char* type)
 {
     INDIGO_BEGIN
     {
@@ -153,7 +153,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadFingerprintFromBuffer(const byte* buffer, int size)
+int indigoLoadFingerprintFromBuffer(const byte* buffer, int size)
 {
     INDIGO_BEGIN
     {
@@ -164,7 +164,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadFingerprintFromDescriptors(const double* arr, int arr_len, int size, double density)
+int indigoLoadFingerprintFromDescriptors(const double* arr, int arr_len, int size, double density)
 {
     INDIGO_BEGIN
     {
@@ -402,7 +402,7 @@
     return 1;
 }
 
-CEXPORT float indigoSimilarity(int item1, int item2, const char* metrics)
+float indigoSimilarity(int item1, int item2, const char* metrics)
 {
     INDIGO_BEGIN
     {
@@ -459,7 +459,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountBits(int fingerprint)
+int indigoCountBits(int fingerprint)
 {
     INDIGO_BEGIN
     {
@@ -469,7 +469,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCommonBits(int fingerprint1, int fingerprint2)
+int indigoCommonBits(int fingerprint1, int fingerprint2)
 {
     INDIGO_BEGIN
     {
@@ -484,7 +484,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoOneBitsList(int fingerprint)
+const char* indigoOneBitsList(int fingerprint)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_basic.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_basic.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_basic.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_basic.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_basic.cpp	(date 1701847510197)
@@ -21,7 +21,7 @@
 #include "indigo_internal.h"
 #include <memory>
 
-CEXPORT int indigoNext(int iter)
+int indigoNext(int iter)
 {
     INDIGO_BEGIN
     {
@@ -35,7 +35,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoHasNext(int iter)
+int indigoHasNext(int iter)
 {
     INDIGO_BEGIN
     {
@@ -44,7 +44,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIndex(int handle)
+int indigoIndex(int handle)
 {
     INDIGO_BEGIN
     {
@@ -53,7 +53,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClone(int object)
+int indigoClone(int object)
 {
     INDIGO_BEGIN
     {
Index: opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_winograd_f63.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_winograd_f63.cpp b/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_winograd_f63.cpp
--- a/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_winograd_f63.cpp	(revision 5199850039ad23f1f0e6cccea5061a9fea5efca6)
+++ b/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_winograd_f63.cpp	(date 1701848687871)
@@ -17,6 +17,479 @@
 
 namespace cv { namespace dnn {
 
+// NEON code work around.
+namespace opt_NEON
+{
+
+#if CV_NEON && CV_NEON_AARCH64
+/* Accumulate */
+void winofunc_accum_f32(const float* inwptr, const float* wptr, float* outbuf, int Cg, int iblock,
+                        const int winoIblock, const int winoKblock, const int winoAtomF32, const int winoNatomF32);
+
+/*Input transform*/
+void winofunc_BtXB_8x8_f32(const float* inptr, int inpstep,
+                            float* outptr, int Cg, const int winoIblock, const int winoAtomF32);
+
+/*Output transform*/
+void winofunc_AtXA_8x8_f32(const float* inptr, int inpstep,
+                            float* bpptr, int bpstep, float* outptr, int outstep,
+                            float bias, float minval, float maxval, bool ifMinMaxAct);
+
+void winofunc_accum_f32(const float* inwptr, const float* wptr, float* outbuf, int Cg, int iblock,
+                            const int winoIblock, const int winoKblock, const int winoAtomF32, const int winoNatomF32)
+{
+    CV_Assert(winoIblock == 6 && winoKblock == 4 && winoAtomF32 == 4);
+    if (iblock > 3)
+    {
+        for (int atom_id = 0; atom_id < winoNatomF32; atom_id++,
+                outbuf += winoAtomF32)
+        {
+            float32x4_t s00 = vdupq_n_f32(0.f), s01 = s00, s02 = s00, s03 = s00, s04 = s00, s05 = s00;
+            float32x4_t s10 = vdupq_n_f32(0.f), s11 = s00, s12 = s00, s13 = s00, s14 = s00, s15 = s00;
+            float32x4_t s20 = vdupq_n_f32(0.f), s21 = s00, s22 = s00, s23 = s00, s24 = s00, s25 = s00;
+            float32x4_t s30 = vdupq_n_f32(0.f), s31 = s00, s32 = s00, s33 = s00, s34 = s00, s35 = s00;
+            for (int c = 0; c < Cg; c++, inwptr += winoIblock*winoAtomF32,
+                                         wptr += winoKblock*winoAtomF32) {
+                float32x4_t w0 = vld1q_f32(wptr), w1 = vld1q_f32(wptr + 4);
+                float32x4_t w2 = vld1q_f32(wptr + 8), w3 = vld1q_f32(wptr + 12);
+                float32x4_t x0, x1;
+                x0 = vld1q_f32(inwptr);
+                x1 = vld1q_f32(inwptr + 4);
+                s00 = vfmaq_f32(s00, w0, x0);
+                s01 = vfmaq_f32(s01, w0, x1);
+                s10 = vfmaq_f32(s10, w1, x0);
+                s11 = vfmaq_f32(s11, w1, x1);
+                s20 = vfmaq_f32(s20, w2, x0);
+                s21 = vfmaq_f32(s21, w2, x1);
+                s30 = vfmaq_f32(s30, w3, x0);
+                s31 = vfmaq_f32(s31, w3, x1);
+                x0 = vld1q_f32(inwptr + 8);
+                x1 = vld1q_f32(inwptr + 12);
+                s02 = vfmaq_f32(s02, w0, x0);
+                s03 = vfmaq_f32(s03, w0, x1);
+                s12 = vfmaq_f32(s12, w1, x0);
+                s13 = vfmaq_f32(s13, w1, x1);
+                s22 = vfmaq_f32(s22, w2, x0);
+                s23 = vfmaq_f32(s23, w2, x1);
+                s32 = vfmaq_f32(s32, w3, x0);
+                s33 = vfmaq_f32(s33, w3, x1);
+                x0 = vld1q_f32(inwptr + 16);
+                x1 = vld1q_f32(inwptr + 20);
+                s04 = vfmaq_f32(s04, w0, x0);
+                s05 = vfmaq_f32(s05, w0, x1);
+                s14 = vfmaq_f32(s14, w1, x0);
+                s15 = vfmaq_f32(s15, w1, x1);
+                s24 = vfmaq_f32(s24, w2, x0);
+                s25 = vfmaq_f32(s25, w2, x1);
+                s34 = vfmaq_f32(s34, w3, x0);
+                s35 = vfmaq_f32(s35, w3, x1);
+            }
+
+            vst1q_f32(outbuf, s00);
+            vst1q_f32(outbuf + 1*64, s01);
+            vst1q_f32(outbuf + 2*64, s02);
+            vst1q_f32(outbuf + 3*64, s03);
+            vst1q_f32(outbuf + 4*64, s04);
+            vst1q_f32(outbuf + 5*64, s05);
+
+            vst1q_f32(outbuf + 6*64, s10);
+            vst1q_f32(outbuf + 7*64, s11);
+            vst1q_f32(outbuf + 8*64, s12);
+            vst1q_f32(outbuf + 9*64, s13);
+            vst1q_f32(outbuf + 10*64, s14);
+            vst1q_f32(outbuf + 11*64, s15);
+
+            vst1q_f32(outbuf + 12*64, s20);
+            vst1q_f32(outbuf + 13*64, s21);
+            vst1q_f32(outbuf + 14*64, s22);
+            vst1q_f32(outbuf + 15*64, s23);
+            vst1q_f32(outbuf + 16*64, s24);
+            vst1q_f32(outbuf + 17*64, s25);
+
+            vst1q_f32(outbuf + 18*64, s30);
+            vst1q_f32(outbuf + 19*64, s31);
+            vst1q_f32(outbuf + 20*64, s32);
+            vst1q_f32(outbuf + 21*64, s33);
+            vst1q_f32(outbuf + 22*64, s34);
+            vst1q_f32(outbuf + 23*64, s35);
+        }
+    }
+    else
+    {
+        for (int atom_id = 0; atom_id < winoNatomF32; atom_id++,
+                outbuf += winoAtomF32)
+        {
+            float32x4_t s00 = vdupq_n_f32(0.f), s01 = s00, s02 = s00;
+            float32x4_t s10 = vdupq_n_f32(0.f), s11 = s00, s12 = s00;
+            float32x4_t s20 = vdupq_n_f32(0.f), s21 = s00, s22 = s00;
+            float32x4_t s30 = vdupq_n_f32(0.f), s31 = s00, s32 = s00;
+            for (int c = 0; c < Cg; c++, inwptr += winoIblock*winoAtomF32,
+                                         wptr += winoKblock*winoAtomF32) {
+                float32x4_t w0 = vld1q_f32(wptr), w1 = vld1q_f32(wptr + 4);
+                float32x4_t w2 = vld1q_f32(wptr + 8), w3 = vld1q_f32(wptr + 12);
+                float32x4_t x0, x1, x2;
+                x0 = vld1q_f32(inwptr);
+                x1 = vld1q_f32(inwptr + 4);
+                x2 = vld1q_f32(inwptr + 8);
+                s00 = vfmaq_f32(s00, w0, x0);
+                s01 = vfmaq_f32(s01, w0, x1);
+                s02 = vfmaq_f32(s02, w0, x2);
+                s10 = vfmaq_f32(s10, w1, x0);
+                s11 = vfmaq_f32(s11, w1, x1);
+                s12 = vfmaq_f32(s12, w1, x2);
+                s20 = vfmaq_f32(s20, w2, x0);
+                s21 = vfmaq_f32(s21, w2, x1);
+                s22 = vfmaq_f32(s22, w2, x2);
+                s30 = vfmaq_f32(s30, w3, x0);
+                s31 = vfmaq_f32(s31, w3, x1);
+                s32 = vfmaq_f32(s32, w3, x2);
+            }
+
+            vst1q_f32(outbuf, s00);
+            vst1q_f32(outbuf + 1*64, s01);
+            vst1q_f32(outbuf + 2*64, s02);
+            vst1q_f32(outbuf + 6*64, s10);
+            vst1q_f32(outbuf + 7*64, s11);
+            vst1q_f32(outbuf + 8*64, s12);
+            vst1q_f32(outbuf + 12*64, s20);
+            vst1q_f32(outbuf + 13*64, s21);
+            vst1q_f32(outbuf + 14*64, s22);
+            vst1q_f32(outbuf + 18*64, s30);
+            vst1q_f32(outbuf + 19*64, s31);
+            vst1q_f32(outbuf + 20*64, s32);
+        }
+    }
+}
+
+#define T4x4(a, b, c, d, tr0, tr1) \
+    tr0 = vtrnq_f32(a, b); \
+    tr1 = vtrnq_f32(c, d); \
+    a = vcombine_f32(vget_low_f32(tr0.val[0]), vget_low_f32(tr1.val[0])); \
+    b = vcombine_f32(vget_low_f32(tr0.val[1]), vget_low_f32(tr1.val[1])); \
+    c = vcombine_f32(vget_high_f32(tr0.val[0]), vget_high_f32(tr1.val[0])); \
+    d = vcombine_f32(vget_high_f32(tr0.val[1]), vget_high_f32(tr1.val[1]))
+
+/*Input transform*/
+void winofunc_BtXB_8x8_f32(const float* inptr, int inpstep,
+                          float* outptr, int Cg, const int winoIblock, const int winoAtomF32)
+{
+    float32x4_t x00 = vld1q_f32(inptr), x01 = vld1q_f32(inptr + 4);
+    float32x4_t x10 = vld1q_f32(inptr + inpstep), x11 = vld1q_f32(inptr + inpstep + 4);
+    float32x4_t x20 = vld1q_f32(inptr + inpstep*2), x21 = vld1q_f32(inptr + inpstep*2 + 4);
+    float32x4_t x30 = vld1q_f32(inptr + inpstep*3), x31 = vld1q_f32(inptr + inpstep*3 + 4);
+    float32x4_t x40 = vld1q_f32(inptr + inpstep*4), x41 = vld1q_f32(inptr + inpstep*4 + 4);
+    float32x4_t x50 = vld1q_f32(inptr + inpstep*5), x51 = vld1q_f32(inptr + inpstep*5 + 4);
+    float32x4_t x60 = vld1q_f32(inptr + inpstep*6), x61 = vld1q_f32(inptr + inpstep*6 + 4);
+    float32x4_t x70 = vld1q_f32(inptr + inpstep*7), x71 = vld1q_f32(inptr + inpstep*7 + 4);
+
+    float32x4_t z00, z01, z10, z11, z20, z21, z30, z31, z40, z41, z50, z51, z60, z61, z70, z71;
+
+    {
+        /* Y[0] = [1.f, 0.f, -5.25f, 0.f, 5.25f, 0.f, -1.f, 0.f]*X */
+        /* Y[7] = [0.f, -1.f, 0.f, 5.25f, 0.f, -5.25f, 0.f, 1.f]*X */
+        float32x4_t q5_25 = vdupq_n_f32(5.25f), t00, t01, t10, t11;
+        t00 = vsubq_f32(x40, x20);
+        t01 = vsubq_f32(x41, x21);
+        t10 = vsubq_f32(x30, x50);
+        t11 = vsubq_f32(x31, x51);
+        float32x4_t y00 = vfmaq_f32(vsubq_f32(x00, x60), t00, q5_25);
+        float32x4_t y01 = vfmaq_f32(vsubq_f32(x01, x61), t01, q5_25);
+        float32x4_t y70 = vfmaq_f32(vsubq_f32(x70, x10), t10, q5_25);
+        float32x4_t y71 = vfmaq_f32(vsubq_f32(x71, x11), t11, q5_25);
+
+        /* Y[1] = [0.f, 1.f, 1.f, -4.25f, -4.25f, 1.f, 1.f, 0.f]*X */
+        /* Y[2] = [0.f, -1.f, 1.f, 4.25f, -4.25f, -1.f, 1.f, 0.f]*X */
+        float32x4_t qm4_25 = vdupq_n_f32(-4.25f);
+        t00 = vfmaq_f32(vaddq_f32(x10, x50), x30, qm4_25);
+        t01 = vfmaq_f32(vaddq_f32(x11, x51), x31, qm4_25);
+        t10 = vfmaq_f32(vaddq_f32(x20, x60), x40, qm4_25);
+        t11 = vfmaq_f32(vaddq_f32(x21, x61), x41, qm4_25);
+
+        float32x4_t y10 = vaddq_f32(t00, t10), y11 = vaddq_f32(t01, t11);
+        float32x4_t y20 = vsubq_f32(t10, t00), y21 = vsubq_f32(t11, t01);
+
+        /* Y[3] = [0.f, 0.5f, 0.25f, -2.5f, -1.25f, 2.f, 1.f, 0.f]*X */
+        /* Y[4] = [0.f, -0.5f, 0.25f, 2.5f, -1.25f, -2.f, 1.f, 0.f]*X */
+        float32x4_t q0_5 = vdupq_n_f32(0.5f), q0_25 = vdupq_n_f32(0.25f);
+        float32x4_t qm2_5 = vdupq_n_f32(-2.5f), qm1_25 = vdupq_n_f32(-1.25f);
+        t00 = vfmaq_f32(vaddq_f32(x50, x50), x10, q0_5);
+        t01 = vfmaq_f32(vaddq_f32(x51, x51), x11, q0_5);
+        t10 = vfmaq_f32(x60, x20, q0_25);
+        t11 = vfmaq_f32(x61, x21, q0_25);
+        t00 = vfmaq_f32(t00, x30, qm2_5);
+        t01 = vfmaq_f32(t01, x31, qm2_5);
+        t10 = vfmaq_f32(t10, x40, qm1_25);
+        t11 = vfmaq_f32(t11, x41, qm1_25);
+
+        float32x4_t y30 = vaddq_f32(t00, t10), y31 = vaddq_f32(t01, t11);
+        float32x4_t y40 = vsubq_f32(t10, t00), y41 = vsubq_f32(t11, t01);
+
+        /* Y[5] = [0.f, 2.f, 4.f, -2.5f, -5.f, 0.5f, 1.f, 0.f]*X */
+        /* Y[6] = [0.f, -2.f, 4.f, 2.5f, -5.f, -0.5f, 1.f, 0.f]*X */
+        float32x4_t q4 = vdupq_n_f32(4.f), qm5 = vdupq_n_f32(-5.f);
+        t00 = vfmaq_f32(vaddq_f32(x10, x10), x50, q0_5);
+        t01 = vfmaq_f32(vaddq_f32(x11, x11), x51, q0_5);
+        t10 = vfmaq_f32(x60, x20, q4);
+        t11 = vfmaq_f32(x61, x21, q4);
+        t00 = vfmaq_f32(t00, x30, qm2_5);
+        t01 = vfmaq_f32(t01, x31, qm2_5);
+        t10 = vfmaq_f32(t10, x40, qm5);
+        t11 = vfmaq_f32(t11, x41, qm5);
+
+        float32x4_t y50 = vaddq_f32(t00, t10), y51 = vaddq_f32(t01, t11);
+        float32x4_t y60 = vsubq_f32(t10, t00), y61 = vsubq_f32(t11, t01);
+
+        /* transpose 8x8 matrix in-place with some renumeration of the elements: */
+        /* Y:              */
+        /*        y00 y01  */
+        /*        y10 y11  */
+        /*        ...      */
+        /*        y70 y71  */
+        /*   Y':           */
+        /*        y00 y40  */
+        /*        y10 y50  */
+        /*        y20 y60  */
+        /*        y30 y70  */
+        /*        y01 y41  */
+        /*        y11 y51  */
+        /*        y21 y61  */
+        /*        y31 y71  */
+        /*    in other words, y40 <-> y01, y50 <-> y11, y60 <-> y21, y70 <-> y31 */
+        float32x4x2_t tr0, tr1;
+
+        T4x4(y00, y10, y20, y30, tr0, tr1);
+        T4x4(y01, y11, y21, y31, tr0, tr1);
+        T4x4(y40, y50, y60, y70, tr0, tr1);
+        T4x4(y41, y51, y61, y71, tr0, tr1);
+
+        /* Z[0] = [1.f, 0.f, -5.25f, 0.f, 5.25f, 0.f, -1.f, 0.f]*Y */
+        /* Z[7] = [0.f, -1.f, 0.f, 5.25f, 0.f, -5.25f, 0.f, 1.f]*Y */
+        t00 = vsubq_f32(y01, y20);
+        t01 = vsubq_f32(y41, y60);
+        t10 = vsubq_f32(y30, y11);
+        t11 = vsubq_f32(y70, y51);
+        z00 = vfmaq_f32(vsubq_f32(y00, y21), t00, q5_25);
+        z01 = vfmaq_f32(vsubq_f32(y40, y61), t01, q5_25);
+        z70 = vfmaq_f32(vsubq_f32(y31, y10), t10, q5_25);
+        z71 = vfmaq_f32(vsubq_f32(y71, y50), t11, q5_25);
+
+        /* Z[1] = [0.f, 1.f, 1.f, -4.25f, -4.25f, 1.f, 1.f, 0.f]*Y */
+        /* Z[2] = [0.f, -1.f, 1.f, 4.25f, -4.25f, -1.f, 1.f, 0.f]*Y */
+        t00 = vfmaq_f32(vaddq_f32(y10, y11), y30, qm4_25);
+        t01 = vfmaq_f32(vaddq_f32(y50, y51), y70, qm4_25);
+        t10 = vfmaq_f32(vaddq_f32(y20, y21), y01, qm4_25);
+        t11 = vfmaq_f32(vaddq_f32(y60, y61), y41, qm4_25);
+
+        z10 = vaddq_f32(t00, t10); z11 = vaddq_f32(t01, t11);
+        z20 = vsubq_f32(t10, t00); z21 = vsubq_f32(t11, t01);
+
+        /* Z[3] = [0.f, 0.5f, 0.25f, -2.5f, -1.25f, 2.f, 1.f, 0.f]*Y */
+        /* Z[4] = [0.f, -0.5f, 0.25f, 2.5f, -1.25f, -2.f, 1.f, 0.f]*Y */
+        t00 = vfmaq_f32(vaddq_f32(y11, y11), y10, q0_5);
+        t01 = vfmaq_f32(vaddq_f32(y51, y51), y50, q0_5);
+        t10 = vfmaq_f32(y21, y20, q0_25);
+        t11 = vfmaq_f32(y61, y60, q0_25);
+        t00 = vfmaq_f32(t00, y30, qm2_5);
+        t01 = vfmaq_f32(t01, y70, qm2_5);
+        t10 = vfmaq_f32(t10, y01, qm1_25);
+        t11 = vfmaq_f32(t11, y41, qm1_25);
+
+        z30 = vaddq_f32(t00, t10); z31 = vaddq_f32(t01, t11);
+        z40 = vsubq_f32(t10, t00); z41 = vsubq_f32(t11, t01);
+
+        /* Z[5] = [0.f, 2.f, 4.f, -2.5f, -5.f, 0.5f, 1.f, 0.f]*Y */
+        /* Z[6] = [0.f, -2.f, 4.f, 2.5f, -5.f, -0.5f, 1.f, 0.f]*Y */
+        t00 = vfmaq_f32(vaddq_f32(y10, y10), y11, q0_5);
+        t01 = vfmaq_f32(vaddq_f32(y50, y50), y51, q0_5);
+        t10 = vfmaq_f32(y21, y20, q4);
+        t11 = vfmaq_f32(y61, y60, q4);
+        t00 = vfmaq_f32(t00, y30, qm2_5);
+        t01 = vfmaq_f32(t01, y70, qm2_5);
+        t10 = vfmaq_f32(t10, y01, qm5);
+        t11 = vfmaq_f32(t11, y41, qm5);
+
+        z50 = vaddq_f32(t00, t10); z51 = vaddq_f32(t01, t11);
+        z60 = vsubq_f32(t10, t00); z61 = vsubq_f32(t11, t01);
+    }
+
+    const int outstep = winoIblock*winoAtomF32*Cg;
+
+    vst1q_f32(outptr, z00);
+    vst1q_f32(outptr + outstep, z01);
+    vst1q_f32(outptr + outstep*2, z10);
+    vst1q_f32(outptr + outstep*3, z11);
+    vst1q_f32(outptr + outstep*4, z20);
+    vst1q_f32(outptr + outstep*5, z21);
+    vst1q_f32(outptr + outstep*6, z30);
+    vst1q_f32(outptr + outstep*7, z31);
+    vst1q_f32(outptr + outstep*8, z40);
+    vst1q_f32(outptr + outstep*9, z41);
+    vst1q_f32(outptr + outstep*10, z50);
+    vst1q_f32(outptr + outstep*11, z51);
+    vst1q_f32(outptr + outstep*12, z60);
+    vst1q_f32(outptr + outstep*13, z61);
+    vst1q_f32(outptr + outstep*14, z70);
+    vst1q_f32(outptr + outstep*15, z71);
+}
+
+/*Output transform*/
+void winofunc_AtXA_8x8_f32(const float* inptr, int inpstep,
+                          float* bpptr, int bpstep, float* outptr, int outstep,
+                          float bias, float minval, float maxval, bool ifMinMaxAct)
+{
+    float32x4_t x00 = vld1q_f32(inptr), x01 = vld1q_f32(inptr + 4);
+    float32x4_t x10 = vld1q_f32(inptr + inpstep), x11 = vld1q_f32(inptr + inpstep + 4);
+    float32x4_t x20 = vld1q_f32(inptr + inpstep*2), x21 = vld1q_f32(inptr + inpstep*2 + 4);
+    float32x4_t x30 = vld1q_f32(inptr + inpstep*3), x31 = vld1q_f32(inptr + inpstep*3 + 4);
+    float32x4_t x40 = vld1q_f32(inptr + inpstep*4), x41 = vld1q_f32(inptr + inpstep*4 + 4);
+    float32x4_t x50 = vld1q_f32(inptr + inpstep*5), x51 = vld1q_f32(inptr + inpstep*5 + 4);
+    float32x4_t x60 = vld1q_f32(inptr + inpstep*6), x61 = vld1q_f32(inptr + inpstep*6 + 4);
+    float32x4_t x70 = vld1q_f32(inptr + inpstep*7), x71 = vld1q_f32(inptr + inpstep*7 + 4);
+    float32x4_t z00, z01, z10, z11, z20, z21, z30, z31, z40, z41, z50, z51;
+
+    {
+        float32x4_t s12_0, s12_1, s34_0, s34_1, s56_0, s56_1;
+        s12_0 = vaddq_f32(x10, x20); s12_1 = vaddq_f32(x11, x21);
+        s34_0 = vaddq_f32(x30, x40); s34_1 = vaddq_f32(x31, x41);
+        s56_0 = vaddq_f32(x50, x60); s56_1 = vaddq_f32(x51, x61);
+
+        float32x4_t y00 = vaddq_f32(vaddq_f32(vaddq_f32(x00, s12_0), s34_0), s56_0);
+        float32x4_t y01 = vaddq_f32(vaddq_f32(vaddq_f32(x01, s12_1), s34_1), s56_1);
+        float32x4_t y20 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 4.0f), s56_0, 0.25f);
+        float32x4_t y21 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 4.0f), s56_1, 0.25f);
+        float32x4_t y40 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 16.0f), s56_0, 1.f/16);
+        float32x4_t y41 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 16.0f), s56_1, 1.f/16);
+
+        s12_0 = vsubq_f32(x10, x20); s12_1 = vsubq_f32(x11, x21);
+        s34_0 = vsubq_f32(x30, x40); s34_1 = vsubq_f32(x31, x41);
+        s56_0 = vsubq_f32(x50, x60); s56_1 = vsubq_f32(x51, x61);
+
+        float32x4_t y50 = vfmaq_n_f32(vfmaq_n_f32(vaddq_f32(x70, s12_0),
+                                      s34_0, 32.f), s56_0, 1.f/32);
+        float32x4_t y51 = vfmaq_n_f32(vfmaq_n_f32(vaddq_f32(x71, s12_1),
+                                      s34_1, 32.f), s56_1, 1.f/32);
+        float32x4_t y10 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 2.0f), s56_0, 0.5f);
+        float32x4_t y11 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 2.0f), s56_1, 0.5f);
+        float32x4_t y30 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 8.0f), s56_0, 0.125f);
+        float32x4_t y31 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 8.0f), s56_1, 0.125f);
+        float32x4_t y60 = vdupq_n_f32(0.f), y61 = y60, y70 = y60, y71 = y60;
+
+        /* transpose 8x8 matrix in-place with some renumeration of the elements: */
+        /*  Y: */
+        /*        y00 y01 */
+        /*        y10 y11 */
+        /*        ... */
+        /*        y50 y51 */
+        /*        0   0 */
+        /*        0   0 */
+        /*   Y': */
+        /*        y00 y40 */
+        /*        y10 y50 */
+        /*        y20 y60 */
+        /*        y30 y70 */
+        /*        y01 y41 */
+        /*        y11 y51 */
+        /*        y21 y61 */
+        /*        y31 y71 */
+        /*    in other words, y40 <-> y01, y50 <-> y11, y60 <-> y21, y70 <-> y31 */
+        float32x4x2_t tr0, tr1;
+
+        T4x4(y00, y10, y20, y30, tr0, tr1);
+        T4x4(y01, y11, y21, y31, tr0, tr1);
+        T4x4(y40, y50, y60, y70, tr0, tr1);
+        T4x4(y41, y51, y61, y71, tr0, tr1);
+
+        s12_0 = vaddq_f32(y10, y20); s12_1 = vaddq_f32(y50, y60);
+        s34_0 = vaddq_f32(y30, y01); s34_1 = vaddq_f32(y70, y41);
+        s56_0 = vaddq_f32(y11, y21); s56_1 = vaddq_f32(y51, y61);
+
+        z00 = vaddq_f32(vaddq_f32(vaddq_f32(y00, s12_0), s34_0), s56_0);
+        z01 = vaddq_f32(vaddq_f32(vaddq_f32(y40, s12_1), s34_1), s56_1);
+        z20 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 4.0f), s56_0, 0.25f);
+        z21 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 4.0f), s56_1, 0.25f);
+        z40 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 16.0f), s56_0, 1.f/16);
+        z41 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 16.0f), s56_1, 1.f/16);
+
+        s12_0 = vsubq_f32(y10, y20); s12_1 = vsubq_f32(y50, y60);
+        s34_0 = vsubq_f32(y30, y01); s34_1 = vsubq_f32(y70, y41);
+        s56_0 = vsubq_f32(y11, y21); s56_1 = vsubq_f32(y51, y61);
+
+        z50 = vfmaq_n_f32(vfmaq_n_f32(vaddq_f32(y31, s12_0),
+                          s34_0, 32.f), s56_0, 1.f/32);
+        z51 = vfmaq_n_f32(vfmaq_n_f32(vaddq_f32(y71, s12_1),
+                          s34_1, 32.f), s56_1, 1.f/32);
+        z10 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 2.0f), s56_0, 0.5f);
+        z11 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 2.0f), s56_1, 0.5f);
+        z30 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 8.0f), s56_0, 0.125f);
+        z31 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 8.0f), s56_1, 0.125f);
+        float32x4_t vbias = vdupq_n_f32(bias);
+
+        z00 = vaddq_f32(z00, vbias);
+        z01 = vaddq_f32(z01, vbias);
+        z10 = vaddq_f32(z10, vbias);
+        z11 = vaddq_f32(z11, vbias);
+        z20 = vaddq_f32(z20, vbias);
+        z21 = vaddq_f32(z21, vbias);
+        z30 = vaddq_f32(z30, vbias);
+        z31 = vaddq_f32(z31, vbias);
+        z40 = vaddq_f32(z40, vbias);
+        z41 = vaddq_f32(z41, vbias);
+        z50 = vaddq_f32(z50, vbias);
+        z51 = vaddq_f32(z51, vbias);
+    }
+
+    if (bpptr)
+    {
+        float32x2_t zhalf = vdup_n_f32(0.f);
+        z00 = vaddq_f32(z00, vld1q_f32(bpptr));
+        z01 = vaddq_f32(z01, vcombine_f32(vld1_f32(bpptr + 4), zhalf));
+        z10 = vaddq_f32(z10, vld1q_f32(bpptr + bpstep));
+        z11 = vaddq_f32(z11, vcombine_f32(vld1_f32(bpptr + bpstep + 4), zhalf));
+        z20 = vaddq_f32(z20, vld1q_f32(bpptr + bpstep*2));
+        z21 = vaddq_f32(z21, vcombine_f32(vld1_f32(bpptr + bpstep*2 + 4), zhalf));
+        z30 = vaddq_f32(z30, vld1q_f32(bpptr + bpstep*3));
+        z31 = vaddq_f32(z31, vcombine_f32(vld1_f32(bpptr + bpstep*3 + 4), zhalf));
+        z40 = vaddq_f32(z40, vld1q_f32(bpptr + bpstep*4));
+        z41 = vaddq_f32(z41, vcombine_f32(vld1_f32(bpptr + bpstep*4 + 4), zhalf));
+        z50 = vaddq_f32(z50, vld1q_f32(bpptr + bpstep*5));
+        z51 = vaddq_f32(z51, vcombine_f32(vld1_f32(bpptr + bpstep*5 + 4), zhalf));
+    }
+
+    if (ifMinMaxAct)
+    {
+        float32x4_t vmax = vdupq_n_f32(maxval);
+        float32x4_t vmin = vdupq_n_f32(minval);
+
+        z00 = vminq_f32(vmaxq_f32(z00, vmin), vmax);
+        z01 = vminq_f32(vmaxq_f32(z01, vmin), vmax);
+        z10 = vminq_f32(vmaxq_f32(z10, vmin), vmax);
+        z11 = vminq_f32(vmaxq_f32(z11, vmin), vmax);
+        z20 = vminq_f32(vmaxq_f32(z20, vmin), vmax);
+        z21 = vminq_f32(vmaxq_f32(z21, vmin), vmax);
+        z30 = vminq_f32(vmaxq_f32(z30, vmin), vmax);
+        z31 = vminq_f32(vmaxq_f32(z31, vmin), vmax);
+        z40 = vminq_f32(vmaxq_f32(z40, vmin), vmax);
+        z41 = vminq_f32(vmaxq_f32(z41, vmin), vmax);
+        z50 = vminq_f32(vmaxq_f32(z50, vmin), vmax);
+        z51 = vminq_f32(vmaxq_f32(z51, vmin), vmax);
+    }
+
+    vst1q_f32(outptr, z00);
+    vst1_f32(outptr + 4, vget_low_f32(z01));
+    vst1q_f32(outptr + outstep, z10);
+    vst1_f32(outptr + outstep + 4, vget_low_f32(z11));
+    vst1q_f32(outptr + outstep*2, z20);
+    vst1_f32(outptr + outstep*2 + 4, vget_low_f32(z21));
+    vst1q_f32(outptr + outstep*3, z30);
+    vst1_f32(outptr + outstep*3 + 4, vget_low_f32(z31));
+    vst1q_f32(outptr + outstep*4, z40);
+    vst1_f32(outptr + outstep*4 + 4, vget_low_f32(z41));
+    vst1q_f32(outptr + outstep*5, z50);
+    vst1_f32(outptr + outstep*5 + 4, vget_low_f32(z51));
+}
+
+#endif
+}
 #if CV_NEON || CV_SIMD128 || CV_TRY_AVX2
 enum { VEC_ALIGN = 32, DFT_TYPE = CV_32F }; // Memory alignment.
 
Index: opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/convolution.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/convolution.cpp b/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/convolution.cpp
--- a/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/convolution.cpp	(revision 5199850039ad23f1f0e6cccea5061a9fea5efca6)
+++ b/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/convolution.cpp	(date 1701848687872)
@@ -16,6 +16,638 @@
 #include "layers/cpu_kernels/conv_block.simd_declarations.hpp" // defines CV_CPU_DISPATCH_MODES_ALL=AVX2,...,BASELINE based on CMakeLists.txt content
 
 namespace cv { namespace dnn {
+
+// NEON code work around.
+namespace opt_NEON
+{
+#if CV_NEON
+
+void convBlock(int np, const float* a, const float* b, float* c, int ldc, bool init_c, int width, const int convMR, const int convNR)
+{
+#if CV_NEON_AARCH64
+    if (convMR == 4 && convNR == 28) // AARCH64
+    {
+        float32x4_t c00 = vdupq_n_f32(0.f), c01 = c00, c02 = c00, c03 = c00, c04 = c00, c05 = c00, c06 = c00;
+        float32x4_t c10 = vdupq_n_f32(0.f), c11 = c10, c12 = c10, c13 = c10, c14 = c10, c15 = c10, c16 = c10;
+        float32x4_t c20 = vdupq_n_f32(0.f), c21 = c20, c22 = c20, c23 = c20, c24 = c20, c25 = c20, c26 = c20;
+        float32x4_t c30 = vdupq_n_f32(0.f), c31 = c30, c32 = c30, c33 = c30, c34 = c30, c35 = c30, c36 = c30;
+
+        if (width > 16)
+        {
+            for( int p = 0; p < np; p++, a += convMR, b += convNR )
+            {
+                float32x4_t a0 = vld1q_f32(a), b0, b1, b2;
+                b0 = vld1q_f32(b); b1 = vld1q_f32(b + 4); b2 = vld1q_f32(b + 8);
+
+                c00 = vfmaq_laneq_f32(c00, b0, a0, 0);
+                c01 = vfmaq_laneq_f32(c01, b1, a0, 0);
+                c02 = vfmaq_laneq_f32(c02, b2, a0, 0);
+                c10 = vfmaq_laneq_f32(c10, b0, a0, 1);
+                c11 = vfmaq_laneq_f32(c11, b1, a0, 1);
+                c12 = vfmaq_laneq_f32(c12, b2, a0, 1);
+                c20 = vfmaq_laneq_f32(c20, b0, a0, 2);
+                c21 = vfmaq_laneq_f32(c21, b1, a0, 2);
+                c22 = vfmaq_laneq_f32(c22, b2, a0, 2);
+                c30 = vfmaq_laneq_f32(c30, b0, a0, 3);
+                c31 = vfmaq_laneq_f32(c31, b1, a0, 3);
+                c32 = vfmaq_laneq_f32(c32, b2, a0, 3);
+
+                b0 = vld1q_f32(b + 12); b1 = vld1q_f32(b + 16); b2 = vld1q_f32(b + 20);
+
+                c03 = vfmaq_laneq_f32(c03, b0, a0, 0);
+                c04 = vfmaq_laneq_f32(c04, b1, a0, 0);
+                c05 = vfmaq_laneq_f32(c05, b2, a0, 0);
+                c13 = vfmaq_laneq_f32(c13, b0, a0, 1);
+                c14 = vfmaq_laneq_f32(c14, b1, a0, 1);
+                c15 = vfmaq_laneq_f32(c15, b2, a0, 1);
+                c23 = vfmaq_laneq_f32(c23, b0, a0, 2);
+                c24 = vfmaq_laneq_f32(c24, b1, a0, 2);
+                c25 = vfmaq_laneq_f32(c25, b2, a0, 2);
+                c33 = vfmaq_laneq_f32(c33, b0, a0, 3);
+                c34 = vfmaq_laneq_f32(c34, b1, a0, 3);
+                c35 = vfmaq_laneq_f32(c35, b2, a0, 3);
+
+                b0 = vld1q_f32(b + 24);
+                c06 = vfmaq_laneq_f32(c06, b0, a0, 0);
+                c16 = vfmaq_laneq_f32(c16, b0, a0, 1);
+                c26 = vfmaq_laneq_f32(c26, b0, a0, 2);
+                c36 = vfmaq_laneq_f32(c36, b0, a0, 3);
+            }
+        }
+        else if (width > 8)
+        {
+            for( int p = 0; p < np; p++, a += convMR, b += convNR )
+            {
+                float32x4_t a0 = vld1q_f32(a), b0, b1, b2;
+                b0 = vld1q_f32(b); b1 = vld1q_f32(b + 4); b2 = vld1q_f32(b + 8);
+
+                c00 = vfmaq_laneq_f32(c00, b0, a0, 0);
+                c01 = vfmaq_laneq_f32(c01, b1, a0, 0);
+                c02 = vfmaq_laneq_f32(c02, b2, a0, 0);
+                c10 = vfmaq_laneq_f32(c10, b0, a0, 1);
+                c11 = vfmaq_laneq_f32(c11, b1, a0, 1);
+                c12 = vfmaq_laneq_f32(c12, b2, a0, 1);
+                c20 = vfmaq_laneq_f32(c20, b0, a0, 2);
+                c21 = vfmaq_laneq_f32(c21, b1, a0, 2);
+                c22 = vfmaq_laneq_f32(c22, b2, a0, 2);
+                c30 = vfmaq_laneq_f32(c30, b0, a0, 3);
+                c31 = vfmaq_laneq_f32(c31, b1, a0, 3);
+                c32 = vfmaq_laneq_f32(c32, b2, a0, 3);
+
+                b0 = vld1q_f32(b + 12);
+
+                c03 = vfmaq_laneq_f32(c03, b0, a0, 0);
+                c13 = vfmaq_laneq_f32(c13, b0, a0, 1);
+                c23 = vfmaq_laneq_f32(c23, b0, a0, 2);
+                c33 = vfmaq_laneq_f32(c33, b0, a0, 3);
+            }
+        }
+        else if (width > 4)
+        {
+            for( int p = 0; p < np; p++, a += convMR, b += convNR )
+            {
+                float32x4_t a0 = vld1q_f32(a), b0, b1;
+                b0 = vld1q_f32(b); b1 = vld1q_f32(b + 4);
+
+                c00 = vfmaq_laneq_f32(c00, b0, a0, 0);
+                c01 = vfmaq_laneq_f32(c01, b1, a0, 0);
+                c10 = vfmaq_laneq_f32(c10, b0, a0, 1);
+                c11 = vfmaq_laneq_f32(c11, b1, a0, 1);
+                c20 = vfmaq_laneq_f32(c20, b0, a0, 2);
+                c21 = vfmaq_laneq_f32(c21, b1, a0, 2);
+                c30 = vfmaq_laneq_f32(c30, b0, a0, 3);
+                c31 = vfmaq_laneq_f32(c31, b1, a0, 3);
+            }
+        }
+        else
+        {
+            for( int p = 0; p < np; p++, a += convMR, b += convNR )
+            {
+                float32x4_t a0 = vld1q_f32(a), b0;
+                b0 = vld1q_f32(b);
+
+                c00 = vfmaq_laneq_f32(c00, b0, a0, 0);
+                c10 = vfmaq_laneq_f32(c10, b0, a0, 1);
+                c20 = vfmaq_laneq_f32(c20, b0, a0, 2);
+                c30 = vfmaq_laneq_f32(c30, b0, a0, 3);
+            }
+        }
+
+        if (!init_c)
+        {
+            c00 = vaddq_f32(c00, vld1q_f32(c));
+            c01 = vaddq_f32(c01, vld1q_f32(c + 4));
+            c02 = vaddq_f32(c02, vld1q_f32(c + 8));
+            c03 = vaddq_f32(c03, vld1q_f32(c + 12));
+            c04 = vaddq_f32(c04, vld1q_f32(c + 16));
+            c05 = vaddq_f32(c05, vld1q_f32(c + 20));
+            c06 = vaddq_f32(c06, vld1q_f32(c + 24));
+
+            c10 = vaddq_f32(c10, vld1q_f32(c + ldc));
+            c11 = vaddq_f32(c11, vld1q_f32(c + ldc + 4));
+            c12 = vaddq_f32(c12, vld1q_f32(c + ldc + 8));
+            c13 = vaddq_f32(c13, vld1q_f32(c + ldc + 12));
+            c14 = vaddq_f32(c14, vld1q_f32(c + ldc + 16));
+            c15 = vaddq_f32(c15, vld1q_f32(c + ldc + 20));
+            c16 = vaddq_f32(c16, vld1q_f32(c + ldc + 24));
+
+            c20 = vaddq_f32(c20, vld1q_f32(c + ldc*2));
+            c21 = vaddq_f32(c21, vld1q_f32(c + ldc*2 + 4));
+            c22 = vaddq_f32(c22, vld1q_f32(c + ldc*2 + 8));
+            c23 = vaddq_f32(c23, vld1q_f32(c + ldc*2 + 12));
+            c24 = vaddq_f32(c24, vld1q_f32(c + ldc*2 + 16));
+            c25 = vaddq_f32(c25, vld1q_f32(c + ldc*2 + 20));
+            c26 = vaddq_f32(c26, vld1q_f32(c + ldc*2 + 24));
+
+            c30 = vaddq_f32(c30, vld1q_f32(c + ldc*3));
+            c31 = vaddq_f32(c31, vld1q_f32(c + ldc*3 + 4));
+            c32 = vaddq_f32(c32, vld1q_f32(c + ldc*3 + 8));
+            c33 = vaddq_f32(c33, vld1q_f32(c + ldc*3 + 12));
+            c34 = vaddq_f32(c34, vld1q_f32(c + ldc*3 + 16));
+            c35 = vaddq_f32(c35, vld1q_f32(c + ldc*3 + 20));
+            c36 = vaddq_f32(c36, vld1q_f32(c + ldc*3 + 24));
+        }
+
+        vst1q_f32(c, c00); vst1q_f32(c+4, c01);
+        vst1q_f32(c+8, c02); vst1q_f32(c+12, c03);
+        vst1q_f32(c+16, c04); vst1q_f32(c+20, c05);
+        vst1q_f32(c+24, c06);
+
+        vst1q_f32(c+ldc, c10); vst1q_f32(c+ldc+4, c11);
+        vst1q_f32(c+ldc+8, c12); vst1q_f32(c+ldc+12, c13);
+        vst1q_f32(c+ldc+16, c14); vst1q_f32(c+ldc+20, c15);
+        vst1q_f32(c+ldc+24, c16);
+
+        vst1q_f32(c+ldc*2, c20); vst1q_f32(c+ldc*2+4, c21);
+        vst1q_f32(c+ldc*2+8, c22); vst1q_f32(c+ldc*2+12, c23);
+        vst1q_f32(c+ldc*2+16, c24); vst1q_f32(c+ldc*2+20, c25);
+        vst1q_f32(c+ldc*2+24, c26);
+
+        vst1q_f32(c+ldc*3, c30); vst1q_f32(c+ldc*3+4, c31);
+        vst1q_f32(c+ldc*3+8, c32); vst1q_f32(c+ldc*3+12, c33);
+        vst1q_f32(c+ldc*3+16, c34); vst1q_f32(c+ldc*3+20, c35);
+        vst1q_f32(c+ldc*3+24, c36);
+    }
+    else
+#endif
+    if (convMR == 4 && convNR == 12) // ARMv7
+    {
+        float32x4_t c0 = vdupq_n_f32(0.f), c1 = c0, c2 = c0;
+        float32x4_t c3 = vdupq_n_f32(0.f), c4 = c3, c5 = c3;
+        float32x4_t c6 = vdupq_n_f32(0.f), c7 = c6, c8 = c6;
+        float32x4_t c9 = vdupq_n_f32(0.f), c10 = c9, c11 = c9;
+
+        float32x2_t a0 = vdup_n_f32(0.0f), a1 = a0;
+        float32x4_t b0 = vdupq_n_f32(0.0f), b1 = vdupq_n_f32(0.0f), b2 = vdupq_n_f32(0.0f);
+
+        if (width > 8)
+        {
+            for (int p = 0; p < np; p++, a += convMR, b += convNR)
+            {
+                a0 = vld1_f32(a), a1 = vld1_f32(a+2);
+                b0 = vld1q_f32(b), b1 = vld1q_f32(b + 4), b2 = vld1q_f32(b + 8);
+
+                c0 = vmlaq_lane_f32(c0, b0, a0, 0);
+                c1 = vmlaq_lane_f32(c1, b1, a0, 0);
+                c2 = vmlaq_lane_f32(c2, b2, a0, 0);
+
+                c3 = vmlaq_lane_f32(c3, b0, a0, 1);
+                c4 = vmlaq_lane_f32(c4, b1, a0, 1);
+                c5 = vmlaq_lane_f32(c5, b2, a0, 1);
+
+                c6 = vmlaq_lane_f32(c6, b0, a1, 0);
+                c7 = vmlaq_lane_f32(c7, b1, a1, 0);
+                c8 = vmlaq_lane_f32(c8, b2, a1, 0);
+
+                c9  = vmlaq_lane_f32(c9 , b0, a1, 1);
+                c10 = vmlaq_lane_f32(c10, b1, a1, 1);
+                c11 = vmlaq_lane_f32(c11, b2, a1, 1);
+            }
+        }
+        else if (width > 4)
+        {
+            for (int p = 0; p < np; p++, a += convMR, b += convNR)
+            {
+                a0 = vld1_f32(a), a1 = vld1_f32(a+2);
+                b0 = vld1q_f32(b), b1 = vld1q_f32(b + 4);
+
+                c0 = vmlaq_lane_f32(c0, b0, a0, 0);
+                c1 = vmlaq_lane_f32(c1, b1, a0, 0);
+
+                c3 = vmlaq_lane_f32(c3, b0, a0, 1);
+                c4 = vmlaq_lane_f32(c4, b1, a0, 1);
+
+                c6 = vmlaq_lane_f32(c6, b0, a1, 0);
+                c7 = vmlaq_lane_f32(c7, b1, a1, 0);
+
+                c9  = vmlaq_lane_f32(c9 , b0, a1, 1);
+                c10 = vmlaq_lane_f32(c10, b1, a1, 1);
+            }
+        }
+        else
+        {
+            for (int p = 0; p < np; p++, a += convMR, b += convNR)
+            {
+                a0 = vld1_f32(a), a1 = vld1_f32(a+2);
+                b0 = vld1q_f32(b);
+
+                c0 = vmlaq_lane_f32(c0, b0, a0, 0);
+                c3 = vmlaq_lane_f32(c3, b0, a0, 1);
+                c6 = vmlaq_lane_f32(c6, b0, a1, 0);
+                c9  = vmlaq_lane_f32(c9 , b0, a1, 1);
+            }
+        }
+
+        if (!init_c)
+        {
+            c0 = vaddq_f32(c0, vld1q_f32(c));
+            c1 = vaddq_f32(c1, vld1q_f32(c + 4));
+            c2 = vaddq_f32(c2, vld1q_f32(c + 8));
+
+            c3 = vaddq_f32(c3, vld1q_f32(c + ldc));
+            c4 = vaddq_f32(c4, vld1q_f32(c + ldc + 4));
+            c5 = vaddq_f32(c5, vld1q_f32(c + ldc + 8));
+
+            c6 = vaddq_f32(c6, vld1q_f32(c + ldc * 2));
+            c7 = vaddq_f32(c7, vld1q_f32(c + ldc * 2 + 4));
+            c8 = vaddq_f32(c8, vld1q_f32(c + ldc * 2 + 8));
+
+            c9  = vaddq_f32(c9 , vld1q_f32(c + ldc * 3));
+            c10 = vaddq_f32(c10, vld1q_f32(c + ldc * 3 + 4));
+            c11 = vaddq_f32(c11, vld1q_f32(c + ldc * 3 + 8));
+        }
+
+        vst1q_f32(c, c0), vst1q_f32(c+4, c1), vst1q_f32(c+8, c2);
+        vst1q_f32(c + ldc, c3), vst1q_f32(c + ldc + 4, c4), vst1q_f32(c + ldc + 8, c5);
+        vst1q_f32(c + ldc*2, c6), vst1q_f32(c + ldc*2 + 4, c7), vst1q_f32(c + ldc*2 + 8, c8);
+        vst1q_f32(c + ldc*3, c9), vst1q_f32(c + ldc*3 + 4, c10), vst1q_f32(c + ldc*3 + 8, c11);
+    }
+    else
+        CV_Error(Error::StsNotImplemented, "Unsupported convMR and/or convNR in opt_NEON::convBlock");
+}
+
+void convBlockMR1_F32(int np, const float * a, const float * b, float *c, const float bias, bool init_c,
+                  const float minval, const float maxval, bool ifMinMaxAct, const int width, const int convNR)
+{
+    CV_Assert(convNR == 28);
+    float32x4_t c0 = vdupq_n_f32(bias), c1 = c0, c2 = c0;
+    float32x4_t c3 = c0, c4 = c0, c5 = c0, c6 = c0;
+
+    if (width > 16)
+    {
+        for (int p = 0; p < np; p++, a++, b += convNR)
+        {
+            float32x4_t b0 = vld1q_f32(b), b1 = vld1q_f32(b + 4), b2 = vld1q_f32(b + 8);
+            float32x4_t b3 = vld1q_f32(b + 12), b4 = vld1q_f32(b + 16), b5 = vld1q_f32(b + 20);
+            float32x4_t b6 = vld1q_f32(b + 24);
+
+            c0 = vmlaq_n_f32(c0, b0, a[0]);
+            c1 = vmlaq_n_f32(c1, b1, a[0]);
+            c2 = vmlaq_n_f32(c2, b2, a[0]);
+            c3 = vmlaq_n_f32(c3, b3, a[0]);
+            c4 = vmlaq_n_f32(c4, b4, a[0]);
+            c5 = vmlaq_n_f32(c5, b5, a[0]);
+            c6 = vmlaq_n_f32(c6, b6, a[0]);
+        }
+    }
+    else if (width > 8)
+    {
+        for (int p = 0; p < np; p++, a++, b += convNR)
+        {
+            float32x4_t b0 = vld1q_f32(b), b1 = vld1q_f32(b + 4), b2 = vld1q_f32(b + 8);
+            float32x4_t b3 = vld1q_f32(b + 12);
+
+            c0 = vmlaq_n_f32(c0, b0, a[0]);
+            c1 = vmlaq_n_f32(c1, b1, a[0]);
+            c2 = vmlaq_n_f32(c2, b2, a[0]);
+            c3 = vmlaq_n_f32(c3, b3, a[0]);
+        }
+    }
+    else if (width > 4)
+    {
+        for (int p = 0; p < np; p++, a++, b += convNR)
+        {
+            float32x4_t b0 = vld1q_f32(b), b1 = vld1q_f32(b + 4);
+
+            c0 = vmlaq_n_f32(c0, b0, a[0]);
+            c1 = vmlaq_n_f32(c1, b1, a[0]);
+        }
+    }
+    else
+    {
+        for (int p = 0; p < np; p++, a++, b += convNR)
+        {
+            float32x4_t b0 = vld1q_f32(b);
+            c0 = vmlaq_n_f32(c0, b0, a[0]);
+        }
+    }
+
+    if (init_c)
+    {
+        c0 += vld1q_f32(c);
+        c1 += vld1q_f32(c + 4);
+        c2 += vld1q_f32(c + 8);
+        c3 += vld1q_f32(c + 12);
+        c4 += vld1q_f32(c + 16);
+        c5 += vld1q_f32(c + 20);
+        c6 += vld1q_f32(c + 24);
+    }
+
+    if (ifMinMaxAct)
+    {
+        float32x4_t v_minval = vdupq_n_f32(minval), v_maxval = vdupq_n_f32(maxval);
+
+        c0 = vminq_f32(vmaxq_f32(c0, v_minval), v_maxval);
+        c1 = vminq_f32(vmaxq_f32(c1, v_minval), v_maxval);
+        c2 = vminq_f32(vmaxq_f32(c2, v_minval), v_maxval);
+        c3 = vminq_f32(vmaxq_f32(c3, v_minval), v_maxval);
+        c4 = vminq_f32(vmaxq_f32(c4, v_minval), v_maxval);
+        c5 = vminq_f32(vmaxq_f32(c5, v_minval), v_maxval);
+        c6 = vminq_f32(vmaxq_f32(c6, v_minval), v_maxval);
+    }
+
+    vst1q_f32(c, c0);
+    vst1q_f32(c + 4, c1);
+    vst1q_f32(c + 8, c2);
+    vst1q_f32(c + 12, c3);
+    vst1q_f32(c + 16, c4);
+    vst1q_f32(c + 20, c5);
+    vst1q_f32(c + 24, c6);
+}
+
+#if CV_NEON_AARCH64 && defined(__ARM_FEATURE_FP16_VECTOR_ARITHMETIC)
+// Fix conflict between float16_t in arm_neon.h and float16_t in cvdef.h.
+typedef __fp16 float16_t;
+
+#ifndef __ARM_FEATURE_FMA // Work around without FMA support.
+#define vfmaq_f16(a, b, c) (a + b * c)
+#endif
+void convBlock_FP16(int np, const char * _a, const char * _b, char * _c, int ldc, bool init_c, int width,
+                    const int convMR_fp16, const int convNR_fp16)
+{
+#if 1
+    const float16_t* a = (const float16_t*)_a;
+    const float16_t* b = (const float16_t*)_b;
+    float16_t* c = (float16_t*)_c;
+
+    CV_Assert(convMR_fp16 == 8 && convNR_fp16 == 24);
+
+    float16x8_t c00 = vdupq_n_f16(0), c01 = c00, c02 = c00;
+    float16x8_t c10 = c00, c11 = c00, c12 = c00;
+    float16x8_t c20 = c00, c21 = c00, c22 = c00;
+    float16x8_t c30 = c00, c31 = c00, c32 = c00;
+    float16x8_t c40 = c00, c41 = c00, c42 = c00;
+    float16x8_t c50 = c00, c51 = c00, c52 = c00;
+    float16x8_t c60 = c00, c61 = c00, c62 = c00;
+    float16x8_t c70 = c00, c71 = c00, c72 = c00;
+
+    float16x8_t b0 = c00, b1 = c00, b2 = c00;
+
+    if (width > 16)
+    {
+        for (int p = 0; p < np; p++, a += convMR_fp16, b += convNR_fp16)
+        {
+            float16x4_t a0 = vld1_f16(a), a1 = vld1_f16(a + 4);
+            b0 = vld1q_f16(b), b1 = vld1q_f16(b + 8), b2 = vld1q_f16(b + 16);
+
+            c00 = vfmaq_lane_f16(c00, b0, a0, 0);
+            c01 = vfmaq_lane_f16(c01, b1, a0, 0);
+            c02 = vfmaq_lane_f16(c02, b2, a0, 0);
+
+            c10 = vfmaq_lane_f16(c10, b0, a0, 1);
+            c11 = vfmaq_lane_f16(c11, b1, a0, 1);
+            c12 = vfmaq_lane_f16(c12, b2, a0, 1);
+
+            c20 = vfmaq_lane_f16(c20, b0, a0, 2);
+            c21 = vfmaq_lane_f16(c21, b1, a0, 2);
+            c22 = vfmaq_lane_f16(c22, b2, a0, 2);
+
+            c30 = vfmaq_lane_f16(c30, b0, a0, 3);
+            c31 = vfmaq_lane_f16(c31, b1, a0, 3);
+            c32 = vfmaq_lane_f16(c32, b2, a0, 3);
+
+            c40 = vfmaq_lane_f16(c40, b0, a1, 0);
+            c41 = vfmaq_lane_f16(c41, b1, a1, 0);
+            c42 = vfmaq_lane_f16(c42, b2, a1, 0);
+
+            c50 = vfmaq_lane_f16(c50, b0, a1, 1);
+            c51 = vfmaq_lane_f16(c51, b1, a1, 1);
+            c52 = vfmaq_lane_f16(c52, b2, a1, 1);
+
+            c60 = vfmaq_lane_f16(c60, b0, a1, 2);
+            c61 = vfmaq_lane_f16(c61, b1, a1, 2);
+            c62 = vfmaq_lane_f16(c62, b2, a1, 2);
+
+            c70 = vfmaq_lane_f16(c70, b0, a1, 3);
+            c71 = vfmaq_lane_f16(c71, b1, a1, 3);
+            c72 = vfmaq_lane_f16(c72, b2, a1, 3);
+        }
+    }
+    else if (width > 8)
+    {
+        for( int p = 0; p < np; p++, a += convMR_fp16, b += convNR_fp16)
+        {
+            float16x4_t a0 = vld1_f16(a), a1 = vld1_f16(a + 4);
+            float16x8_t b0 = vld1q_f16(b), b1 = vld1q_f16(b + 8);
+
+            c00 = vfmaq_lane_f16(c00, b0, a0, 0);
+            c01 = vfmaq_lane_f16(c01, b1, a0, 0);
+
+            c10 = vfmaq_lane_f16(c10, b0, a0, 1);
+            c11 = vfmaq_lane_f16(c11, b1, a0, 1);
+
+            c20 = vfmaq_lane_f16(c20, b0, a0, 2);
+            c21 = vfmaq_lane_f16(c21, b1, a0, 2);
+
+            c30 = vfmaq_lane_f16(c30, b0, a0, 3);
+            c31 = vfmaq_lane_f16(c31, b1, a0, 3);
+
+            c40 = vfmaq_lane_f16(c40, b0, a1, 0);
+            c41 = vfmaq_lane_f16(c41, b1, a1, 0);
+
+            c50 = vfmaq_lane_f16(c50, b0, a1, 1);
+            c51 = vfmaq_lane_f16(c51, b1, a1, 1);
+
+            c60 = vfmaq_lane_f16(c60, b0, a1, 2);
+            c61 = vfmaq_lane_f16(c61, b1, a1, 2);
+
+            c70 = vfmaq_lane_f16(c70, b0, a1, 3);
+            c71 = vfmaq_lane_f16(c71, b1, a1, 3);
+        }
+    }
+    else
+    {
+        for( int p = 0; p < np; p++, a += convMR_fp16, b += convNR_fp16)
+        {
+            float16x4_t a0 = vld1_f16(a), a1 = vld1_f16(a + 4);
+            float16x8_t b0 = vld1q_f16(b);
+
+            c00 = vfmaq_lane_f16(c00, b0, a0, 0);
+            c10 = vfmaq_lane_f16(c10, b0, a0, 1);
+            c20 = vfmaq_lane_f16(c20, b0, a0, 2);
+            c30 = vfmaq_lane_f16(c30, b0, a0, 3);
+            c40 = vfmaq_lane_f16(c40, b0, a1, 0);
+            c50 = vfmaq_lane_f16(c50, b0, a1, 1);
+            c60 = vfmaq_lane_f16(c60, b0, a1, 2);
+            c70 = vfmaq_lane_f16(c70, b0, a1, 3);
+        }
+    }
+
+    if (!init_c)
+    {
+#undef _FX_UPDATE_CBUF_ROW
+#define _FX_UPDATE_CBUF_ROW(row) \
+        c##row##0 = c##row##0 + vld1q_f16(c + row*ldc); \
+        c##row##1 = c##row##1 + vld1q_f16(c + row*ldc + 8); \
+        c##row##2 = c##row##2 + vld1q_f16(c + row*ldc + 16)
+
+        _FX_UPDATE_CBUF_ROW(0);
+        _FX_UPDATE_CBUF_ROW(1);
+        _FX_UPDATE_CBUF_ROW(2);
+        _FX_UPDATE_CBUF_ROW(3);
+        _FX_UPDATE_CBUF_ROW(4);
+        _FX_UPDATE_CBUF_ROW(5);
+        _FX_UPDATE_CBUF_ROW(6);
+        _FX_UPDATE_CBUF_ROW(7);
+    }
+
+#undef _FX_STORE_CBUF_ROW
+#define _FX_STORE_CBUF_ROW(row) \
+    vst1q_f16(c + row*ldc, c##row##0); \
+    vst1q_f16(c + row*ldc + 8, c##row##1); \
+    vst1q_f16(c + row*ldc + 16, c##row##2)
+
+    _FX_STORE_CBUF_ROW(0);
+    _FX_STORE_CBUF_ROW(1);
+    _FX_STORE_CBUF_ROW(2);
+    _FX_STORE_CBUF_ROW(3);
+    _FX_STORE_CBUF_ROW(4);
+    _FX_STORE_CBUF_ROW(5);
+    _FX_STORE_CBUF_ROW(6);
+    _FX_STORE_CBUF_ROW(7);
+#else
+    // reference only.
+    const float16_t* a = (const float16_t*)_a;
+    const float16_t* b = (const float16_t*)_b;
+    float16_t* c = (float16_t*)_c;
+    float cbuf[convMR_fp16*convNR_fp16];
+    memset(cbuf, 0, sizeof(cbuf));
+
+    for( int p = 0; p < np; p++ )
+    {
+        for( int i = 0; i < convMR_fp16; i++ )
+        {
+            float ai = float(a[convMR_fp16*p + i]);
+                for( int j = 0; j < convNR_fp16; j++ )
+                    cbuf[i*convNR_fp16+j] += float(b[convNR_fp16*p + j]) * ai;
+        }
+    }
+
+    if (!init_c)
+    {
+    for(int i = 0; i < convMR_fp16; i++)
+        {
+            for(int j = 0; j < convNR_fp16; j++)
+                c[i*ldc + j] = float16_t(float(c[i*ldc + j]) + cbuf[i*convNR_fp16 + j]);
+        }
+    }
+    else
+    {
+        for(int i = 0; i < convMR_fp16; i++)
+        {
+            for(int j = 0; j < convNR_fp16; j++)
+                c[i*ldc + j] = (float16_t)(cbuf[i*convNR_fp16 + j]);
+        }
+    }
+#endif
+}
+
+void convBlockMR1_FP16(int np, const char* _a, const char* _b, float *c, const float _bias, bool init_c,
+                            const float minval, const float maxval, bool ifMinMaxAct, const int width, const int convNR_FP16)
+{
+    CV_Assert(convNR_FP16 == 24); // CONV_NR_FP16 = 24
+    const float16_t* a = (const float16_t*)_a;
+    const float16_t* b = (const float16_t*)_b;
+
+    const float16_t bias = (float16_t)_bias;
+
+    float16x8_t c0 = vdupq_n_f16(bias), c1 = c0, c2 = c0;
+
+    if (width > 16)
+    {
+        for (int p = 0; p < np; p++, a++, b += convNR_FP16)
+        {
+            float16x8_t a0= vdupq_n_f16(a[0]);
+            float16x8_t b0 = vld1q_f16(b), b1 = vld1q_f16(b + 8), b2 = vld1q_f16(b + 16);
+
+            c0 = vfmaq_f16(c0, a0, b0);
+            c1 = vfmaq_f16(c1, a0, b1);
+            c2 = vfmaq_f16(c2, a0, b2);
+        }
+    }
+    else if (width > 8)
+    {
+        for (int p = 0; p < np; p++, a++, b += convNR_FP16)
+        {
+            float16x8_t a0= vdupq_n_f16(a[0]);
+            float16x8_t b0 = vld1q_f16(b), b1 = vld1q_f16(b + 8);
+
+            c0 = vfmaq_f16(c0, a0, b0);
+            c1 = vfmaq_f16(c1, a0, b1);
+        }
+    }
+    else
+    {
+        for (int p = 0; p < np; p++, a++, b += convNR_FP16)
+        {
+            float16x8_t a0= vdupq_n_f16(a[0]);
+            float16x8_t b0 = vld1q_f16(b);
+
+            c0 = vfmaq_f16(c0, a0, b0);
+        }
+    }
+
+    // convert FP 16 to FP 32.
+    float32x4_t c00 = vcvt_f32_f16(vget_low_f16(c0));
+    float32x4_t c01 = vcvt_f32_f16(vget_high_f16(c0));
+    float32x4_t c10 = vcvt_f32_f16(vget_low_f16(c1));
+    float32x4_t c11 = vcvt_f32_f16(vget_high_f16(c1));
+    float32x4_t c20 = vcvt_f32_f16(vget_low_f16(c2));
+    float32x4_t c21 = vcvt_f32_f16(vget_high_f16(c2));
+
+    if (init_c)
+    {
+        c00 += vld1q_f32(c);
+        c01 += vld1q_f32(c + 4);
+        c10 += vld1q_f32(c + 8);
+        c11 += vld1q_f32(c + 12);
+        c20 += vld1q_f32(c + 16);
+        c21 += vld1q_f32(c + 20);
+    }
+
+    if (ifMinMaxAct)
+    {
+        float32x4_t v_minval = vdupq_n_f32(minval), v_maxval = vdupq_n_f32(maxval);
+
+        c00 = vminq_f32(vmaxq_f32(c00, v_minval), v_maxval);
+        c01 = vminq_f32(vmaxq_f32(c01, v_minval), v_maxval);
+        c10 = vminq_f32(vmaxq_f32(c10, v_minval), v_maxval);
+        c11 = vminq_f32(vmaxq_f32(c11, v_minval), v_maxval);
+        c20 = vminq_f32(vmaxq_f32(c20, v_minval), v_maxval);
+        c21 = vminq_f32(vmaxq_f32(c21, v_minval), v_maxval);
+    }
+
+    vst1q_f32(c, c00);
+    vst1q_f32(c + 4, c01);
+    vst1q_f32(c + 8, c10);
+    vst1q_f32(c + 12, c11);
+    vst1q_f32(c + 16, c20);
+    vst1q_f32(c + 20, c21);
+}
+#endif
+
+#endif
+}
 enum { VEC_ALIGN = 32, DFT_TYPE = CV_32F }; // Memory alignment.
 
 void convBlock(int np, const float* a, const float* b, float* c, int ldc, bool init_c, const int outLen,
Index: indigo-src/indigo/api/c/indigo/indigo.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/indigo.h b/indigo-src/indigo/api/c/indigo/indigo.h
--- a/indigo-src/indigo/api/c/indigo/indigo.h	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/indigo.h	(date 1701847562419)
@@ -20,36 +20,22 @@
 #define __indigo__
 
 #include <stdint.h>
+#include "indigo_export.h"
 
 #if defined(_WIN32) && !defined(__MINGW32__)
 #define qword unsigned __int64
 #else
 #define qword unsigned long long
 #endif
-
-#ifndef EXPORT_SYMBOL
-#ifdef _WIN32
-#define EXPORT_SYMBOL __declspec(dllexport)
-#elif (defined __GNUC__ || defined __APPLE__)
-#define EXPORT_SYMBOL __attribute__((visibility("default")))
-#else
-#define EXPORT_SYMBOL
-#endif
-#endif
-
-#ifndef CEXPORT
-#ifndef __cplusplus
-#define CEXPORT EXPORT_SYMBOL
-#else
-#define CEXPORT extern "C" EXPORT_SYMBOL
-#endif
-#endif
 
 #ifndef __byte_typedef__
 #define __byte_typedef__
 typedef unsigned char byte;
 #endif
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 /* All integer and float functions return -1 on error. */
 /* All string functions return zero pointer on error. */
 
@@ -58,55 +44,55 @@
 
 /* System */
 
-CEXPORT const char* indigoVersion();
-CEXPORT const char* indigoVersionInfo();
+INDIGO_EXPORT const char* indigoVersion();
+INDIGO_EXPORT const char* indigoVersionInfo();
 
 // Allocate a new session. Each session has its own
 // set of objects created and options set up.
-CEXPORT qword indigoAllocSessionId();
+INDIGO_EXPORT qword indigoAllocSessionId();
 // Switch to another session. The session, if was not allocated
 // previously, is allocated automatically and initialized with
 // empty set of objects and default options.
-CEXPORT void indigoSetSessionId(qword id);
+INDIGO_EXPORT void indigoSetSessionId(qword id);
 // Release session. The memory used by the released session
 // is not freed, but the number will be reused on
 // further allocations.
-CEXPORT void indigoReleaseSessionId(qword id);
+INDIGO_EXPORT void indigoReleaseSessionId(qword id);
 
 // Get the last error message
-CEXPORT const char* indigoGetLastError(void);
+INDIGO_EXPORT const char *indigoGetLastError(void);
 
-typedef void (*INDIGO_ERROR_HANDLER)(const char* message, void* context);
-CEXPORT void indigoSetErrorHandler(INDIGO_ERROR_HANDLER handler, void* context);
+typedef void (*INDIGO_ERROR_HANDLER)(const char *message, void *context);
+INDIGO_EXPORT void indigoSetErrorHandler(INDIGO_ERROR_HANDLER handler, void *context);
 
 // Free an object
-CEXPORT int indigoFree(int handle);
+INDIGO_EXPORT int indigoFree(int handle);
 // Clone an object
-CEXPORT int indigoClone(int object);
+INDIGO_EXPORT int indigoClone(int object);
 // Count object currently allocated
-CEXPORT int indigoCountReferences(void);
+INDIGO_EXPORT int indigoCountReferences(void);
 
 // Deallocate all the objects in the current session
-CEXPORT int indigoFreeAllObjects();
+INDIGO_EXPORT int indigoFreeAllObjects();
 
 /* Options */
 
-CEXPORT int indigoSetOption(const char* name, const char* value);
-CEXPORT int indigoSetOptionInt(const char* name, int value);
-CEXPORT int indigoSetOptionBool(const char* name, int value);
-CEXPORT int indigoSetOptionFloat(const char* name, float value);
-CEXPORT int indigoSetOptionColor(const char* name, float r, float g, float b);
-CEXPORT int indigoSetOptionXY(const char* name, int x, int y);
-CEXPORT int indigoResetOptions();
+INDIGO_EXPORT int indigoSetOption(const char *name, const char *value);
+INDIGO_EXPORT int indigoSetOptionInt(const char *name, int value);
+INDIGO_EXPORT int indigoSetOptionBool(const char *name, int value);
+INDIGO_EXPORT int indigoSetOptionFloat(const char *name, float value);
+INDIGO_EXPORT int indigoSetOptionColor(const char *name, float r, float g, float b);
+INDIGO_EXPORT int indigoSetOptionXY(const char *name, int x, int y);
+INDIGO_EXPORT int indigoResetOptions();
 
-CEXPORT const char* indigoGetOption(const char* name);
-CEXPORT int indigoGetOptionInt(const char* name, int* value);
-CEXPORT int indigoGetOptionBool(const char* name, int* value);
-CEXPORT int indigoGetOptionFloat(const char* name, float* value);
-CEXPORT int indigoGetOptionColor(const char* name, float* r, float* g, float* b);
-CEXPORT int indigoGetOptionXY(const char* name, int* x, int* y);
+INDIGO_EXPORT const char *indigoGetOption(const char *name);
+INDIGO_EXPORT int indigoGetOptionInt(const char *name, int *value);
+INDIGO_EXPORT int indigoGetOptionBool(const char *name, int *value);
+INDIGO_EXPORT int indigoGetOptionFloat(const char *name, float *value);
+INDIGO_EXPORT int indigoGetOptionColor(const char *name, float *r, float *g, float *b);
+INDIGO_EXPORT int indigoGetOptionXY(const char *name, int *x, int *y);
 
-CEXPORT const char* indigoGetOptionType(const char* name);
+INDIGO_EXPORT const char *indigoGetOptionType(const char *name);
 
 /* Basic input-output */
 
@@ -116,19 +102,19 @@
 // string/buffer. All these functions are low-level and
 // rarely needed to anyone.
 
-CEXPORT int indigoReadFile(const char* filename);
-CEXPORT int indigoReadString(const char* str);
-CEXPORT int indigoLoadString(const char* str);
-CEXPORT int indigoReadBuffer(const char* buffer, int size);
-CEXPORT int indigoLoadBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoReadFile(const char *filename);
+INDIGO_EXPORT int indigoReadString(const char *str);
+INDIGO_EXPORT int indigoLoadString(const char *str);
+INDIGO_EXPORT int indigoReadBuffer(const char *buffer, int size);
+INDIGO_EXPORT int indigoLoadBuffer(const char *buffer, int size);
 
 // indigoWrite*** return a new writer object.
 
-CEXPORT int indigoWriteFile(const char* filename);
-CEXPORT int indigoWriteBuffer(void);
+INDIGO_EXPORT int indigoWriteFile(const char *filename);
+INDIGO_EXPORT int indigoWriteBuffer(void);
 
 // Closes the file output stream but does not delete the object
-CEXPORT int indigoClose(int output);
+INDIGO_EXPORT int indigoClose(int output);
 
 /* Iterators */
 
@@ -160,68 +146,68 @@
  */
 
 // Obtains the next element, returns zero if there is no next element
-CEXPORT int indigoNext(int iter);
+INDIGO_EXPORT int indigoNext(int iter);
 // Does not obtain the next element, just tells if there is one
-CEXPORT int indigoHasNext(int iter);
+INDIGO_EXPORT int indigoHasNext(int iter);
 // Returns the index of the element
-CEXPORT int indigoIndex(int item);
+INDIGO_EXPORT int indigoIndex(int item);
 
 // Removes the item from its container (usually a molecule)
-CEXPORT int indigoRemove(int item);
+INDIGO_EXPORT int indigoRemove(int item);
 
 /* Molecules, query molecules, SMARTS */
 
-CEXPORT int indigoCreateMolecule(void);
-CEXPORT int indigoCreateQueryMolecule(void);
+INDIGO_EXPORT int indigoCreateMolecule(void);
+INDIGO_EXPORT int indigoCreateQueryMolecule(void);
 
-CEXPORT int indigoLoadStructureFromString(const char* string, const char* params);
-CEXPORT int indigoLoadStructureFromBuffer(const byte* string, int bufferSize, const char* params);
-CEXPORT int indigoLoadStructureFromFile(const char* filename, const char* params);
+INDIGO_EXPORT int indigoLoadStructureFromString(const char *string, const char *params);
+INDIGO_EXPORT int indigoLoadStructureFromBuffer(const byte *string, int bufferSize, const char *params);
+INDIGO_EXPORT int indigoLoadStructureFromFile(const char *filename, const char *params);
 
-CEXPORT int indigoLoadMolecule(int source);
-CEXPORT int indigoLoadMoleculeFromString(const char* string);
-CEXPORT int indigoLoadMoleculeFromFile(const char* filename);
-CEXPORT int indigoLoadMoleculeFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadMolecule(int source);
+INDIGO_EXPORT int indigoLoadMoleculeFromString(const char *string);
+INDIGO_EXPORT int indigoLoadMoleculeFromFile(const char *filename);
+INDIGO_EXPORT int indigoLoadMoleculeFromBuffer(const char *buffer, int size);
 
-CEXPORT int indigoLoadQueryMolecule(int source);
-CEXPORT int indigoLoadQueryMoleculeFromString(const char* string);
-CEXPORT int indigoLoadQueryMoleculeFromFile(const char* filename);
-CEXPORT int indigoLoadQueryMoleculeFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadQueryMolecule(int source);
+INDIGO_EXPORT int indigoLoadQueryMoleculeFromString(const char *string);
+INDIGO_EXPORT int indigoLoadQueryMoleculeFromFile(const char *filename);
+INDIGO_EXPORT int indigoLoadQueryMoleculeFromBuffer(const char *buffer, int size);
 
-CEXPORT int indigoLoadSmarts(int source);
-CEXPORT int indigoLoadSmartsFromString(const char* string);
-CEXPORT int indigoLoadSmartsFromFile(const char* filename);
-CEXPORT int indigoLoadSmartsFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadSmarts(int source);
+INDIGO_EXPORT int indigoLoadSmartsFromString(const char *string);
+INDIGO_EXPORT int indigoLoadSmartsFromFile(const char *filename);
+INDIGO_EXPORT int indigoLoadSmartsFromBuffer(const char *buffer, int size);
 
-CEXPORT int indigoSaveMolfile(int molecule, int output);
-CEXPORT int indigoSaveMolfileToFile(int molecule, const char* filename);
-CEXPORT const char* indigoMolfile(int molecule);
+INDIGO_EXPORT int indigoSaveMolfile(int molecule, int output);
+INDIGO_EXPORT int indigoSaveMolfileToFile(int molecule, const char *filename);
+INDIGO_EXPORT const char *indigoMolfile(int molecule);
 
-CEXPORT int indigoSaveJsonToFile(int item, const char* filename);
-CEXPORT int indigoSaveJson(int item, int output);
+INDIGO_EXPORT int indigoSaveJsonToFile(int item, const char *filename);
+INDIGO_EXPORT int indigoSaveJson(int item, int output);
 
 // accepts molecules and reactions (but not query ones)
-CEXPORT int indigoSaveCml(int object, int output);
-CEXPORT int indigoSaveCmlToFile(int object, const char* filename);
-CEXPORT const char* indigoCml(int object);
-CEXPORT const char* indigoCdxBase64(int object);
+INDIGO_EXPORT int indigoSaveCml(int object, int output);
+INDIGO_EXPORT int indigoSaveCmlToFile(int object, const char *filename);
+INDIGO_EXPORT const char *indigoCml(int object);
+INDIGO_EXPORT const char *indigoCdxBase64(int object);
 
 // accepts molecules and reactions
-CEXPORT int indigoSaveCdxml(int object, int output);
-CEXPORT int indigoSaveCdx(int item, int output);
+INDIGO_EXPORT int indigoSaveCdxml(int object, int output);
+INDIGO_EXPORT int indigoSaveCdx(int item, int output);
 
-CEXPORT const char* indigoCdxml(int item);
+INDIGO_EXPORT const char *indigoCdxml(int item);
 
-CEXPORT int indigoSaveCdxmlToFile(int object, const char* filename);
-CEXPORT int indigoSaveCdxToFile(int item, const char* filename);
+INDIGO_EXPORT int indigoSaveCdxmlToFile(int object, const char *filename);
+INDIGO_EXPORT int indigoSaveCdxToFile(int item, const char *filename);
 
-CEXPORT const char* indigoCdxml(int object);
+INDIGO_EXPORT const char *indigoCdxml(int object);
 
 // the output must be a file or a buffer, but not a string
 // (because MDLCT data usually contains zeroes)
-CEXPORT int indigoSaveMDLCT(int item, int output);
+INDIGO_EXPORT int indigoSaveMDLCT(int item, int output);
 
-CEXPORT const char* indigoJson(int object);
+INDIGO_EXPORT const char *indigoJson(int object);
 
 /*
 Converts a chemical name into a corresponding structure
@@ -230,14 +216,13 @@
    name - a name to parse
    params - a string containing parsing options or nullptr if no options are changed
 */
-CEXPORT int indigoNameToStructure(const char* name, const char* params);
+INDIGO_EXPORT int indigoNameToStructure(const char *name, const char *params);
 
 /* Reactions, query reactions */
 /*
  * Reaction centers
  */
-enum
-{
+enum {
     INDIGO_RC_NOT_CENTER = -1,
     INDIGO_RC_UNMARKED = 0,
     INDIGO_RC_CENTER = 1,
@@ -245,66 +230,66 @@
     INDIGO_RC_MADE_OR_BROKEN = 4,
     INDIGO_RC_ORDER_CHANGED = 8
 };
-CEXPORT int indigoLoadReaction(int source);
-CEXPORT int indigoLoadReactionFromString(const char* string);
-CEXPORT int indigoLoadReactionFromFile(const char* filename);
-CEXPORT int indigoLoadReactionFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadReaction(int source);
+INDIGO_EXPORT int indigoLoadReactionFromString(const char *string);
+INDIGO_EXPORT int indigoLoadReactionFromFile(const char *filename);
+INDIGO_EXPORT int indigoLoadReactionFromBuffer(const char *buffer, int size);
 
-CEXPORT int indigoLoadQueryReaction(int source);
-CEXPORT int indigoLoadQueryReactionFromString(const char* string);
-CEXPORT int indigoLoadQueryReactionFromFile(const char* filename);
-CEXPORT int indigoLoadQueryReactionFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadQueryReaction(int source);
+INDIGO_EXPORT int indigoLoadQueryReactionFromString(const char *string);
+INDIGO_EXPORT int indigoLoadQueryReactionFromFile(const char *filename);
+INDIGO_EXPORT int indigoLoadQueryReactionFromBuffer(const char *buffer, int size);
 
-CEXPORT int indigoLoadReactionSmarts(int source);
-CEXPORT int indigoLoadReactionSmartsFromString(const char* string);
-CEXPORT int indigoLoadReactionSmartsFromFile(const char* filename);
-CEXPORT int indigoLoadReactionSmartsFromBuffer(const char* buffer, int size);
+INDIGO_EXPORT int indigoLoadReactionSmarts(int source);
+INDIGO_EXPORT int indigoLoadReactionSmartsFromString(const char *string);
+INDIGO_EXPORT int indigoLoadReactionSmartsFromFile(const char *filename);
+INDIGO_EXPORT int indigoLoadReactionSmartsFromBuffer(const char *buffer, int size);
 
-CEXPORT int indigoCreateReaction(void);
-CEXPORT int indigoCreateQueryReaction(void);
+INDIGO_EXPORT int indigoCreateReaction(void);
+INDIGO_EXPORT int indigoCreateQueryReaction(void);
 
-CEXPORT int indigoAddReactant(int reaction, int molecule);
-CEXPORT int indigoAddProduct(int reaction, int molecule);
-CEXPORT int indigoAddCatalyst(int reaction, int molecule);
+INDIGO_EXPORT int indigoAddReactant(int reaction, int molecule);
+INDIGO_EXPORT int indigoAddProduct(int reaction, int molecule);
+INDIGO_EXPORT int indigoAddCatalyst(int reaction, int molecule);
 
-CEXPORT int indigoCountReactants(int reaction);
-CEXPORT int indigoCountProducts(int reaction);
-CEXPORT int indigoCountCatalysts(int reaction);
+INDIGO_EXPORT int indigoCountReactants(int reaction);
+INDIGO_EXPORT int indigoCountProducts(int reaction);
+INDIGO_EXPORT int indigoCountCatalysts(int reaction);
 // Counts reactants, products, and catalysts.
-CEXPORT int indigoCountMolecules(int reaction);
-CEXPORT int indigoGetMolecule(int reaction, int index);
+INDIGO_EXPORT int indigoCountMolecules(int reaction);
+INDIGO_EXPORT int indigoGetMolecule(int reaction, int index);
 
-CEXPORT int indigoIterateReactants(int reaction);
-CEXPORT int indigoIterateProducts(int reaction);
-CEXPORT int indigoIterateCatalysts(int reaction);
+INDIGO_EXPORT int indigoIterateReactants(int reaction);
+INDIGO_EXPORT int indigoIterateProducts(int reaction);
+INDIGO_EXPORT int indigoIterateCatalysts(int reaction);
 // Returns an iterator for reactants, products, and catalysts.
-CEXPORT int indigoIterateMolecules(int reaction);
+INDIGO_EXPORT int indigoIterateMolecules(int reaction);
 
-CEXPORT int indigoSaveRxnfile(int reaction, int output);
-CEXPORT int indigoSaveRxnfileToFile(int reaction, const char* filename);
-CEXPORT const char* indigoRxnfile(int reaction);
+INDIGO_EXPORT int indigoSaveRxnfile(int reaction, int output);
+INDIGO_EXPORT int indigoSaveRxnfileToFile(int reaction, const char *filename);
+INDIGO_EXPORT const char *indigoRxnfile(int reaction);
 
 // Method for query optimizations for faster substructure search
 // (works for both query molecules and query reactions)
-CEXPORT int indigoOptimize(int query, const char* options);
+INDIGO_EXPORT int indigoOptimize(int query, const char *options);
 
 // Methods for structure normalization
 // It neutrailzes charges, resolves 5-valence Nitrogen, removes hydrogens and etc.
 // Default options is empty.
-CEXPORT int indigoNormalize(int structure, const char* options);
+INDIGO_EXPORT int indigoNormalize(int structure, const char *options);
 
 // Method for molecule and query standardizing
 // It stadrdize charges, stereo and etc.
-CEXPORT int indigoStandardize(int item);
+INDIGO_EXPORT int indigoStandardize(int item);
 
 // Method for structure ionization at specified pH and pH tollerance
-CEXPORT int indigoIonize(int item, float pH, float pH_toll);
+INDIGO_EXPORT int indigoIonize(int item, float pH, float pH_toll);
 
 // Method for building PKA model
-CEXPORT int indigoBuildPkaModel(int max_level, float threshold, const char* filename);
+INDIGO_EXPORT int indigoBuildPkaModel(int max_level, float threshold, const char *filename);
 
-CEXPORT float* indigoGetAcidPkaValue(int item, int atom, int level, int min_level);
-CEXPORT float* indigoGetBasicPkaValue(int item, int atom, int level, int min_level);
+INDIGO_EXPORT float *indigoGetAcidPkaValue(int item, int atom, int level, int min_level);
+INDIGO_EXPORT float *indigoGetBasicPkaValue(int item, int atom, int level, int min_level);
 
 // Automatic reaction atom-to-atom mapping
 // mode is one of the following (separated by a space):
@@ -319,28 +304,27 @@
 //    "ignore_isotopes" : do not consider atom isotopes while searching
 //    "ignore_valence" : do not consider atom valence while searching
 //    "ignore_radicals" : do not consider atom radicals while searching
-CEXPORT int indigoAutomap(int reaction, const char* mode);
+INDIGO_EXPORT int indigoAutomap(int reaction, const char *mode);
 
 // Returns mapping number. It might appear that there is more them
 // one atom with the same number in AAM
 // Value 0 means no mapping number has been specified.
-CEXPORT int indigoGetAtomMappingNumber(int reaction, int reaction_atom);
-CEXPORT int indigoSetAtomMappingNumber(int reaction, int reaction_atom, int number);
+INDIGO_EXPORT int indigoGetAtomMappingNumber(int reaction, int reaction_atom);
+INDIGO_EXPORT int indigoSetAtomMappingNumber(int reaction, int reaction_atom, int number);
 
 // Getters and setters for reacting centers
-CEXPORT int indigoGetReactingCenter(int reaction, int reaction_bond, int* rc);
-CEXPORT int indigoSetReactingCenter(int reaction, int reaction_bond, int rc);
+INDIGO_EXPORT int indigoGetReactingCenter(int reaction, int reaction_bond, int *rc);
+INDIGO_EXPORT int indigoSetReactingCenter(int reaction, int reaction_bond, int rc);
 
 // Clears all reaction AAM information
-CEXPORT int indigoClearAAM(int reaction);
+INDIGO_EXPORT int indigoClearAAM(int reaction);
 
 // Corrects reacting centers according to AAM
-CEXPORT int indigoCorrectReactingCenters(int reaction);
+INDIGO_EXPORT int indigoCorrectReactingCenters(int reaction);
 
 /* Accessing a molecule */
 
-enum
-{
+enum {
     INDIGO_ABS = 1,
     INDIGO_OR = 2,
     INDIGO_AND = 3,
@@ -360,61 +344,61 @@
 
 // Returns an iterator for all atoms of the given
 // molecule, including r-sites and pseudoatoms.
-CEXPORT int indigoIterateAtoms(int molecule);
-CEXPORT int indigoIteratePseudoatoms(int molecule);
-CEXPORT int indigoIterateRSites(int molecule);
-CEXPORT int indigoIterateStereocenters(int molecule);
-CEXPORT int indigoIterateAlleneCenters(int molecule);
-CEXPORT int indigoIterateRGroups(int molecule);
+INDIGO_EXPORT int indigoIterateAtoms(int molecule);
+INDIGO_EXPORT int indigoIteratePseudoatoms(int molecule);
+INDIGO_EXPORT int indigoIterateRSites(int molecule);
+INDIGO_EXPORT int indigoIterateStereocenters(int molecule);
+INDIGO_EXPORT int indigoIterateAlleneCenters(int molecule);
+INDIGO_EXPORT int indigoIterateRGroups(int molecule);
 
-CEXPORT int indigoCountRGroups(int molecule);
-CEXPORT int indigoCopyRGroups(int molecule_from, int molecule_to);
+INDIGO_EXPORT int indigoCountRGroups(int molecule);
+INDIGO_EXPORT int indigoCopyRGroups(int molecule_from, int molecule_to);
 
-CEXPORT int indigoIsPseudoatom(int atom);
-CEXPORT int indigoIsRSite(int atom);
-CEXPORT int indigoIsTemplateAtom(int atom);
+INDIGO_EXPORT int indigoIsPseudoatom(int atom);
+INDIGO_EXPORT int indigoIsRSite(int atom);
+INDIGO_EXPORT int indigoIsTemplateAtom(int atom);
 
 // returns INDIGO_{ABS,OR,AND,EITHER}
 // or zero if the atom is not a stereoatom
-CEXPORT int indigoStereocenterType(int atom);
-CEXPORT int indigoChangeStereocenterType(int atom, int type);
+INDIGO_EXPORT int indigoStereocenterType(int atom);
+INDIGO_EXPORT int indigoChangeStereocenterType(int atom, int type);
 
-CEXPORT int indigoStereocenterGroup(int atom);
-CEXPORT int indigoSetStereocenterGroup(int atom, int group);
+INDIGO_EXPORT int indigoStereocenterGroup(int atom);
+INDIGO_EXPORT int indigoSetStereocenterGroup(int atom, int group);
 
 // returns 4 integers with atom indices that defines stereocenter pyramid
-CEXPORT const int* indigoStereocenterPyramid(int atom);
+INDIGO_EXPORT const int *indigoStereocenterPyramid(int atom);
 
-CEXPORT int indigoSingleAllowedRGroup(int rsite);
+INDIGO_EXPORT int indigoSingleAllowedRGroup(int rsite);
 
-CEXPORT int indigoAddStereocenter(int atom, int type, int v1, int v2, int v3, int v4);
+INDIGO_EXPORT int indigoAddStereocenter(int atom, int type, int v1, int v2, int v3, int v4);
 
 // Applicable to an R-Group, but not to a molecule
-CEXPORT int indigoIterateRGroupFragments(int rgroup);
+INDIGO_EXPORT int indigoIterateRGroupFragments(int rgroup);
 // Applicable to an R-Group and to a molecule
 // Returns maximal order of attachment points
-CEXPORT int indigoCountAttachmentPoints(int item);
-CEXPORT int indigoIterateAttachmentPoints(int item, int order);
+INDIGO_EXPORT int indigoCountAttachmentPoints(int item);
+INDIGO_EXPORT int indigoIterateAttachmentPoints(int item, int order);
 
-CEXPORT const char* indigoSymbol(int atom);
-CEXPORT int indigoDegree(int atom);
+INDIGO_EXPORT const char *indigoSymbol(int atom);
+INDIGO_EXPORT int indigoDegree(int atom);
 
 // Returns zero if the charge is ambiguous
 // If the charge is nonambiguous, returns 1 and writes *charge
-CEXPORT int indigoGetCharge(int atom, int* charge);
+INDIGO_EXPORT int indigoGetCharge(int atom, int *charge);
 // Same as indigoGetCharge
-CEXPORT int indigoGetExplicitValence(int atom, int* valence);
+INDIGO_EXPORT int indigoGetExplicitValence(int atom, int *valence);
 
-CEXPORT int indigoSetExplicitValence(int atom, int valence);
+INDIGO_EXPORT int indigoSetExplicitValence(int atom, int valence);
 
 // Returns a number of element from the periodic table.
 // Returns zero on ambiguous atom.
 // Can not be applied to pseudo-atoms and R-sites.
-CEXPORT int indigoAtomicNumber(int atom);
+INDIGO_EXPORT int indigoAtomicNumber(int atom);
 // Returns zero on unspecified or ambiguous isotope
-CEXPORT int indigoIsotope(int atom);
+INDIGO_EXPORT int indigoIsotope(int atom);
 // Not applicable to query molecules.
-CEXPORT int indigoValence(int atom);
+INDIGO_EXPORT int indigoValence(int atom);
 // Return atom hybridization
 // S = 1,
 // SP = 2,
@@ -425,324 +409,328 @@
 // SP3D3 = 7,
 // SP3D4 = 8,
 // SP2D = 9
-CEXPORT int indigoGetHybridization(int atom);
+INDIGO_EXPORT int indigoGetHybridization(int atom);
 // Returns zero if valence of the atom is wrong
-CEXPORT int indigoCheckValence(int atom);
+INDIGO_EXPORT int indigoCheckValence(int atom);
 
 // Returns one if atom or bond belongs Query or has any query feature
-CEXPORT int indigoCheckQuery(int item);
+INDIGO_EXPORT int indigoCheckQuery(int item);
 
 // Returns one if structure contains RGroup features (RSites, RGroups or attachment points
-CEXPORT int indigoCheckRGroups(int item);
+INDIGO_EXPORT int indigoCheckRGroups(int item);
 
 // Returns check result for Indigo object as text file for requested properties as JSON
-CEXPORT const char* indigoCheck(const char* item, const char* check_flags, const char* load_params);
+INDIGO_EXPORT const char *indigoCheck(const char *item, const char *check_flags, const char *load_params);
 
 // Returns check result for Indigo object for requested properties as JSON
-CEXPORT const char* indigoCheckObj(int item, const char* check_flags);
+INDIGO_EXPORT const char *indigoCheckObj(int item, const char *check_flags);
 
 // Returns check result for structure against requested properties
-CEXPORT const char* indigoCheckStructure(const char* structure, const char* props);
+INDIGO_EXPORT const char *indigoCheckStructure(const char *structure, const char *props);
 
 // Applicable to atoms, query atoms, and molecules. Can fail
 // (return zero) on query atoms where the number of hydrogens
 // is not definitely known. Otherwise, returns one and writes *hydro.
-CEXPORT int indigoCountHydrogens(int item, int* hydro);
+INDIGO_EXPORT int indigoCountHydrogens(int item, int *hydro);
 
 // Applicable to non-query molecules and atoms.
-CEXPORT int indigoCountImplicitHydrogens(int item);
+INDIGO_EXPORT int indigoCountImplicitHydrogens(int item);
 
 // On success, returns always the same pointer to a 3-element array;
 // you should not free() it, but rather memcpy() it if you want to keep it.
-CEXPORT float* indigoXYZ(int atom);
+INDIGO_EXPORT float *indigoXYZ(int atom);
 
-CEXPORT int indigoSetXYZ(int atom, float x, float y, float z);
+INDIGO_EXPORT int indigoSetXYZ(int atom, float x, float y, float z);
 
-CEXPORT int indigoCountSuperatoms(int molecule);
-CEXPORT int indigoCountDataSGroups(int molecule);
-CEXPORT int indigoCountRepeatingUnits(int molecule);
-CEXPORT int indigoCountMultipleGroups(int molecule);
-CEXPORT int indigoCountGenericSGroups(int molecule);
-CEXPORT int indigoIterateDataSGroups(int molecule);
-CEXPORT int indigoIterateSuperatoms(int molecule);
-CEXPORT int indigoIterateGenericSGroups(int molecule);
-CEXPORT int indigoIterateRepeatingUnits(int molecule);
-CEXPORT int indigoIterateMultipleGroups(int molecule);
+INDIGO_EXPORT int indigoCountSuperatoms(int molecule);
+INDIGO_EXPORT int indigoCountDataSGroups(int molecule);
+INDIGO_EXPORT int indigoCountRepeatingUnits(int molecule);
+INDIGO_EXPORT int indigoCountMultipleGroups(int molecule);
+INDIGO_EXPORT int indigoCountGenericSGroups(int molecule);
+INDIGO_EXPORT int indigoIterateDataSGroups(int molecule);
+INDIGO_EXPORT int indigoIterateSuperatoms(int molecule);
+INDIGO_EXPORT int indigoIterateGenericSGroups(int molecule);
+INDIGO_EXPORT int indigoIterateRepeatingUnits(int molecule);
+INDIGO_EXPORT int indigoIterateMultipleGroups(int molecule);
 
-CEXPORT int indigoIterateTGroups(int molecule);
-CEXPORT int indigoIterateSGroups(int molecule);
+INDIGO_EXPORT int indigoIterateTGroups(int molecule);
+INDIGO_EXPORT int indigoIterateSGroups(int molecule);
 
-CEXPORT int indigoGetSuperatom(int molecule, int index);
-CEXPORT int indigoGetDataSGroup(int molecule, int index);
-CEXPORT int indigoGetGenericSGroup(int molecule, int index);
-CEXPORT int indigoGetMultipleGroup(int molecule, int index);
-CEXPORT int indigoGetRepeatingUnit(int molecule, int index);
+INDIGO_EXPORT int indigoGetSuperatom(int molecule, int index);
+INDIGO_EXPORT int indigoGetDataSGroup(int molecule, int index);
+INDIGO_EXPORT int indigoGetGenericSGroup(int molecule, int index);
+INDIGO_EXPORT int indigoGetMultipleGroup(int molecule, int index);
+INDIGO_EXPORT int indigoGetRepeatingUnit(int molecule, int index);
 
-CEXPORT const char* indigoDescription(int data_sgroup);
-CEXPORT const char* indigoData(int data_sgroup);
+INDIGO_EXPORT const char *indigoDescription(int data_sgroup);
+INDIGO_EXPORT const char *indigoData(int data_sgroup);
 
-CEXPORT int indigoAddDataSGroup(int molecule, int natoms, int* atoms, int nbonds, int* bonds, const char* description, const char* data);
+INDIGO_EXPORT int
+indigoAddDataSGroup(int molecule, int natoms, int *atoms, int nbonds, int *bonds, const char *description,
+                    const char *data);
 
-CEXPORT int indigoAddSuperatom(int molecule, int natoms, int* atoms, const char* name);
+INDIGO_EXPORT int indigoAddSuperatom(int molecule, int natoms, int *atoms, const char *name);
 
-CEXPORT int indigoSetDataSGroupXY(int sgroup, float x, float y, const char* options);
+INDIGO_EXPORT int indigoSetDataSGroupXY(int sgroup, float x, float y, const char *options);
 
-CEXPORT int indigoSetSGroupData(int sgroup, const char* data);
-CEXPORT int indigoSetSGroupCoords(int sgroup, float x, float y);
-CEXPORT int indigoSetSGroupDescription(int sgroup, const char* description);
-CEXPORT int indigoSetSGroupFieldName(int sgroup, const char* name);
-CEXPORT int indigoSetSGroupQueryCode(int sgroup, const char* querycode);
-CEXPORT int indigoSetSGroupQueryOper(int sgroup, const char* queryoper);
-CEXPORT int indigoSetSGroupDisplay(int sgroup, const char* option);
-CEXPORT int indigoSetSGroupLocation(int sgroup, const char* option);
-CEXPORT int indigoSetSGroupTag(int sgroup, const char* tag);
-CEXPORT int indigoSetSGroupTagAlign(int sgroup, int tag_align);
-CEXPORT int indigoSetSGroupDataType(int sgroup, const char* type);
-CEXPORT int indigoSetSGroupXCoord(int sgroup, float x);
-CEXPORT int indigoSetSGroupYCoord(int sgroup, float y);
+INDIGO_EXPORT int indigoSetSGroupData(int sgroup, const char *data);
+INDIGO_EXPORT int indigoSetSGroupCoords(int sgroup, float x, float y);
+INDIGO_EXPORT int indigoSetSGroupDescription(int sgroup, const char *description);
+INDIGO_EXPORT int indigoSetSGroupFieldName(int sgroup, const char *name);
+INDIGO_EXPORT int indigoSetSGroupQueryCode(int sgroup, const char *querycode);
+INDIGO_EXPORT int indigoSetSGroupQueryOper(int sgroup, const char *queryoper);
+INDIGO_EXPORT int indigoSetSGroupDisplay(int sgroup, const char *option);
+INDIGO_EXPORT int indigoSetSGroupLocation(int sgroup, const char *option);
+INDIGO_EXPORT int indigoSetSGroupTag(int sgroup, const char *tag);
+INDIGO_EXPORT int indigoSetSGroupTagAlign(int sgroup, int tag_align);
+INDIGO_EXPORT int indigoSetSGroupDataType(int sgroup, const char *type);
+INDIGO_EXPORT int indigoSetSGroupXCoord(int sgroup, float x);
+INDIGO_EXPORT int indigoSetSGroupYCoord(int sgroup, float y);
 
-CEXPORT int indigoCreateSGroup(const char* type, int mapping, const char* name);
-CEXPORT const char* indigoGetSGroupClass(int sgroup);
-CEXPORT const char* indigoGetSGroupName(int sgroup);
-CEXPORT int indigoSetSGroupClass(int sgroup, const char* sgclass);
-CEXPORT int indigoSetSGroupName(int sgroup, const char* sgname);
-CEXPORT int indigoGetSGroupNumCrossBonds(int sgroup);
+INDIGO_EXPORT int indigoCreateSGroup(const char *type, int mapping, const char *name);
+INDIGO_EXPORT const char *indigoGetSGroupClass(int sgroup);
+INDIGO_EXPORT const char *indigoGetSGroupName(int sgroup);
+INDIGO_EXPORT int indigoSetSGroupClass(int sgroup, const char *sgclass);
+INDIGO_EXPORT int indigoSetSGroupName(int sgroup, const char *sgname);
+INDIGO_EXPORT int indigoGetSGroupNumCrossBonds(int sgroup);
 
-CEXPORT int indigoAddSGroupAttachmentPoint(int sgroup, int aidx, int lvidx, const char* apid);
-CEXPORT int indigoDeleteSGroupAttachmentPoint(int sgroup, int index);
-CEXPORT int indigoGetSGroupDisplayOption(int sgroup);
-CEXPORT int indigoSetSGroupDisplayOption(int sgroup, int option);
-CEXPORT int indigoGetSGroupSeqId(int sgroup);
-CEXPORT float* indigoGetSGroupCoords(int sgroup);
+INDIGO_EXPORT int indigoAddSGroupAttachmentPoint(int sgroup, int aidx, int lvidx, const char *apid);
+INDIGO_EXPORT int indigoDeleteSGroupAttachmentPoint(int sgroup, int index);
+INDIGO_EXPORT int indigoGetSGroupDisplayOption(int sgroup);
+INDIGO_EXPORT int indigoSetSGroupDisplayOption(int sgroup, int option);
+INDIGO_EXPORT int indigoGetSGroupSeqId(int sgroup);
+INDIGO_EXPORT float *indigoGetSGroupCoords(int sgroup);
 
-CEXPORT int indigoGetSGroupMultiplier(int sgroup);
-CEXPORT int indigoSetSGroupMultiplier(int sgroup, int multiplier);
+INDIGO_EXPORT int indigoGetSGroupMultiplier(int sgroup);
+INDIGO_EXPORT int indigoSetSGroupMultiplier(int sgroup, int multiplier);
 
-CEXPORT const char* indigoGetRepeatingUnitSubscript(int sgroup);
-CEXPORT int indigoGetRepeatingUnitConnectivity(int sgroup);
+INDIGO_EXPORT const char *indigoGetRepeatingUnitSubscript(int sgroup);
+INDIGO_EXPORT int indigoGetRepeatingUnitConnectivity(int sgroup);
 
-CEXPORT int indigoSetSGroupBrackets(int sgroup, int brk_style, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);
+INDIGO_EXPORT int
+indigoSetSGroupBrackets(int sgroup, int brk_style, float x1, float y1, float x2, float y2, float x3, float y3, float x4,
+                        float y4);
 
-CEXPORT int indigoFindSGroups(int item, const char* property, const char* value);
+INDIGO_EXPORT int indigoFindSGroups(int item, const char *property, const char *value);
 
-CEXPORT int indigoGetSGroupType(int item);
-CEXPORT int indigoGetSGroupIndex(int item);
+INDIGO_EXPORT int indigoGetSGroupType(int item);
+INDIGO_EXPORT int indigoGetSGroupIndex(int item);
 
-CEXPORT int indigoGetSGroupOriginalId(int sgroup);
-CEXPORT int indigoSetSGroupOriginalId(int sgroup, int original);
-CEXPORT int indigoGetSGroupParentId(int sgroup);
-CEXPORT int indigoSetSGroupParentId(int sgroup, int parent);
+INDIGO_EXPORT int indigoGetSGroupOriginalId(int sgroup);
+INDIGO_EXPORT int indigoSetSGroupOriginalId(int sgroup, int original);
+INDIGO_EXPORT int indigoGetSGroupParentId(int sgroup);
+INDIGO_EXPORT int indigoSetSGroupParentId(int sgroup, int parent);
 
-CEXPORT int indigoAddTemplate(int molecule, int templates, const char* tname);
-CEXPORT int indigoRemoveTemplate(int molecule, const char* tname);
-CEXPORT int indigoFindTemplate(int molecule, const char* tname);
+INDIGO_EXPORT int indigoAddTemplate(int molecule, int templates, const char *tname);
+INDIGO_EXPORT int indigoRemoveTemplate(int molecule, const char *tname);
+INDIGO_EXPORT int indigoFindTemplate(int molecule, const char *tname);
 
-CEXPORT const char* indigoGetTGroupClass(int tgroup);
-CEXPORT const char* indigoGetTGroupName(int tgroup);
-CEXPORT const char* indigoGetTGroupAlias(int tgroup);
+INDIGO_EXPORT const char *indigoGetTGroupClass(int tgroup);
+INDIGO_EXPORT const char *indigoGetTGroupName(int tgroup);
+INDIGO_EXPORT const char *indigoGetTGroupAlias(int tgroup);
 
-CEXPORT int indigoTransformSCSRtoCTAB(int item);
-CEXPORT int indigoTransformCTABtoSCSR(int molecule, int templates);
+INDIGO_EXPORT int indigoTransformSCSRtoCTAB(int item);
+INDIGO_EXPORT int indigoTransformCTABtoSCSR(int molecule, int templates);
 
-CEXPORT int indigoResetCharge(int atom);
-CEXPORT int indigoResetExplicitValence(int atom);
-CEXPORT int indigoResetIsotope(int atom);
+INDIGO_EXPORT int indigoResetCharge(int atom);
+INDIGO_EXPORT int indigoResetExplicitValence(int atom);
+INDIGO_EXPORT int indigoResetIsotope(int atom);
 
-CEXPORT int indigoSetAttachmentPoint(int atom, int order);
-CEXPORT int indigoClearAttachmentPoints(int item);
+INDIGO_EXPORT int indigoSetAttachmentPoint(int atom, int order);
+INDIGO_EXPORT int indigoClearAttachmentPoints(int item);
 
-CEXPORT int indigoRemoveConstraints(int item, const char* type);
-CEXPORT int indigoAddConstraint(int item, const char* type, const char* value);
-CEXPORT int indigoAddConstraintNot(int item, const char* type, const char* value);
-CEXPORT int indigoAddConstraintOr(int atom, const char* type, const char* value);
+INDIGO_EXPORT int indigoRemoveConstraints(int item, const char *type);
+INDIGO_EXPORT int indigoAddConstraint(int item, const char *type, const char *value);
+INDIGO_EXPORT int indigoAddConstraintNot(int item, const char *type, const char *value);
+INDIGO_EXPORT int indigoAddConstraintOr(int atom, const char *type, const char *value);
 
-CEXPORT int indigoResetStereo(int item);
-CEXPORT int indigoInvertStereo(int item);
+INDIGO_EXPORT int indigoResetStereo(int item);
+INDIGO_EXPORT int indigoInvertStereo(int item);
 
-CEXPORT int indigoCountAtoms(int molecule);
-CEXPORT int indigoCountBonds(int molecule);
-CEXPORT int indigoCountPseudoatoms(int molecule);
-CEXPORT int indigoCountRSites(int molecule);
+INDIGO_EXPORT int indigoCountAtoms(int molecule);
+INDIGO_EXPORT int indigoCountBonds(int molecule);
+INDIGO_EXPORT int indigoCountPseudoatoms(int molecule);
+INDIGO_EXPORT int indigoCountRSites(int molecule);
 
-CEXPORT int indigoIterateBonds(int molecule);
+INDIGO_EXPORT int indigoIterateBonds(int molecule);
 // Returns 1/2/3 if the bond is a single/double/triple bond
 // Returns 4 if the bond is an aromatic bond
 // Returns zero if the bond is ambiguous (query bond)
-CEXPORT int indigoBondOrder(int bond);
+INDIGO_EXPORT int indigoBondOrder(int bond);
 
 // Returns INDIGO_{UP/DOWN/EITHER/CIS/TRANS},
 // or zero if the bond is not a stereobond
-CEXPORT int indigoBondStereo(int bond);
+INDIGO_EXPORT int indigoBondStereo(int bond);
 
 // Returns INDIGO_{CHAIN/RING},
-CEXPORT int indigoTopology(int bond);
+INDIGO_EXPORT int indigoTopology(int bond);
 
 // Returns an iterator whose elements can be treated as atoms.
 // At the same time, they support indigoBond() call.
-CEXPORT int indigoIterateNeighbors(int atom);
+INDIGO_EXPORT int indigoIterateNeighbors(int atom);
 
 // Applicable exclusively to the "atom neighbors iterator".
 // Returns a bond to the neighbor atom.
-CEXPORT int indigoBond(int nei);
+INDIGO_EXPORT int indigoBond(int nei);
 
 // Accessing atoms and bonds by index
-CEXPORT int indigoGetAtom(int molecule, int idx);
-CEXPORT int indigoGetBond(int molecule, int idx);
+INDIGO_EXPORT int indigoGetAtom(int molecule, int idx);
+INDIGO_EXPORT int indigoGetBond(int molecule, int idx);
 
-CEXPORT int indigoSource(int bond);
-CEXPORT int indigoDestination(int bond);
+INDIGO_EXPORT int indigoSource(int bond);
+INDIGO_EXPORT int indigoDestination(int bond);
 
-CEXPORT int indigoClearCisTrans(int handle);
-CEXPORT int indigoClearStereocenters(int handle);
-CEXPORT int indigoCountStereocenters(int molecule);
-CEXPORT int indigoClearAlleneCenters(int molecule);
-CEXPORT int indigoCountAlleneCenters(int molecule);
+INDIGO_EXPORT int indigoClearCisTrans(int handle);
+INDIGO_EXPORT int indigoClearStereocenters(int handle);
+INDIGO_EXPORT int indigoCountStereocenters(int molecule);
+INDIGO_EXPORT int indigoClearAlleneCenters(int molecule);
+INDIGO_EXPORT int indigoCountAlleneCenters(int molecule);
 
-CEXPORT int indigoResetSymmetricCisTrans(int handle);
-CEXPORT int indigoResetSymmetricStereocenters(int handle);
-CEXPORT int indigoMarkEitherCisTrans(int handle);
-CEXPORT int indigoMarkStereobonds(int handle);
+INDIGO_EXPORT int indigoResetSymmetricCisTrans(int handle);
+INDIGO_EXPORT int indigoResetSymmetricStereocenters(int handle);
+INDIGO_EXPORT int indigoMarkEitherCisTrans(int handle);
+INDIGO_EXPORT int indigoMarkStereobonds(int handle);
 
-CEXPORT int indigoValidateChirality(int handle);
+INDIGO_EXPORT int indigoValidateChirality(int handle);
 
 // Accepts a symbol from the periodic table (like "C" or "Br"),
 // or a pseudoatom symbol, like "Pol". Returns the added atom.
-CEXPORT int indigoAddAtom(int molecule, const char* symbol);
+INDIGO_EXPORT int indigoAddAtom(int molecule, const char *symbol);
 // Set a new atom instead of specified
-CEXPORT int indigoResetAtom(int atom, const char* symbol);
+INDIGO_EXPORT int indigoResetAtom(int atom, const char *symbol);
 
-CEXPORT const char* indigoGetTemplateAtomClass(int atom);
-CEXPORT int indigoSetTemplateAtomClass(int atom, const char* name);
+INDIGO_EXPORT const char *indigoGetTemplateAtomClass(int atom);
+INDIGO_EXPORT int indigoSetTemplateAtomClass(int atom, const char *name);
 
 // Accepts Rsite name "R" (or just ""), "R1", "R2" or list with names "R1 R3"
-CEXPORT int indigoAddRSite(int molecule, const char* name);
-CEXPORT int indigoSetRSite(int atom, const char* name);
+INDIGO_EXPORT int indigoAddRSite(int molecule, const char *name);
+INDIGO_EXPORT int indigoSetRSite(int atom, const char *name);
 
-CEXPORT int indigoSetCharge(int atom, int charge);
-CEXPORT int indigoSetIsotope(int atom, int isotope);
+INDIGO_EXPORT int indigoSetCharge(int atom, int charge);
+INDIGO_EXPORT int indigoSetIsotope(int atom, int isotope);
 
 // If the radical is nonambiguous, returns 1 and writes *electrons
-CEXPORT int indigoGetRadicalElectrons(int atom, int* electrons);
+INDIGO_EXPORT int indigoGetRadicalElectrons(int atom, int *electrons);
 // If the radical is nonambiguous, returns 1 and writes *radical
-CEXPORT int indigoGetRadical(int atom, int* radical);
-CEXPORT int indigoSetRadical(int atom, int radical);
-CEXPORT int indigoResetRadical(int atom);
+INDIGO_EXPORT int indigoGetRadical(int atom, int *radical);
+INDIGO_EXPORT int indigoSetRadical(int atom, int radical);
+INDIGO_EXPORT int indigoResetRadical(int atom);
 
 // Used for hacks with aromatic molecules; not recommended to use
 // in other situations
-CEXPORT int indigoSetImplicitHCount(int atom, int impl_h);
+INDIGO_EXPORT int indigoSetImplicitHCount(int atom, int impl_h);
 
 // Accepts two atoms (source and destination) and the order of the new bond
 // (1/2/3/4 = single/double/triple/aromatic). Returns the added bond.
-CEXPORT int indigoAddBond(int source, int destination, int order);
+INDIGO_EXPORT int indigoAddBond(int source, int destination, int order);
 
-CEXPORT int indigoSetBondOrder(int bond, int order);
+INDIGO_EXPORT int indigoSetBondOrder(int bond, int order);
 
-CEXPORT int indigoMerge(int where_to, int what);
+INDIGO_EXPORT int indigoMerge(int where_to, int what);
 
 /* Highlighting */
 
 // Access atoms and bonds
-CEXPORT int indigoHighlight(int item);
+INDIGO_EXPORT int indigoHighlight(int item);
 
 // Access atoms, bonds, molecules, and reactions
-CEXPORT int indigoUnhighlight(int item);
+INDIGO_EXPORT int indigoUnhighlight(int item);
 
 // Access atoms and bonds
-CEXPORT int indigoIsHighlighted(int item);
+INDIGO_EXPORT int indigoIsHighlighted(int item);
 
 /* Selection */
 
 // Access atoms and bonds
-CEXPORT int indigoSelect(int item);
+INDIGO_EXPORT int indigoSelect(int item);
 
 // Access atoms, bonds, molecules, and reactions
-CEXPORT int indigoUnselect(int item);
+INDIGO_EXPORT int indigoUnselect(int item);
 
 // Access atoms and bonds
-CEXPORT int indigoIsSelected(int item);
+INDIGO_EXPORT int indigoIsSelected(int item);
 
 /* Connected components of molecules */
 
-CEXPORT int indigoCountComponents(int molecule);
-CEXPORT int indigoComponentIndex(int atom);
-CEXPORT int indigoIterateComponents(int molecule);
+INDIGO_EXPORT int indigoCountComponents(int molecule);
+INDIGO_EXPORT int indigoComponentIndex(int atom);
+INDIGO_EXPORT int indigoIterateComponents(int molecule);
 
 // Returns a 'molecule component' object, which can not be used as a
 // [query] molecule, but supports the indigo{Count,Iterate}{Atoms,Bonds} calls,
 // and also the indigoClone() call, which returns a [query] molecule.
-CEXPORT int indigoComponent(int molecule, int index);
+INDIGO_EXPORT int indigoComponent(int molecule, int index);
 
 /* Smallest Set of Smallest Rings */
 
-CEXPORT int indigoCountSSSR(int molecule);
-CEXPORT int indigoIterateSSSR(int molecule);
+INDIGO_EXPORT int indigoCountSSSR(int molecule);
+INDIGO_EXPORT int indigoIterateSSSR(int molecule);
 
-CEXPORT int indigoIterateSubtrees(int molecule, int min_atoms, int max_atoms);
-CEXPORT int indigoIterateRings(int molecule, int min_atoms, int max_atoms);
-CEXPORT int indigoIterateEdgeSubmolecules(int molecule, int min_bonds, int max_bonds);
+INDIGO_EXPORT int indigoIterateSubtrees(int molecule, int min_atoms, int max_atoms);
+INDIGO_EXPORT int indigoIterateRings(int molecule, int min_atoms, int max_atoms);
+INDIGO_EXPORT int indigoIterateEdgeSubmolecules(int molecule, int min_bonds, int max_bonds);
 
 /* Calculation on molecules */
 
-CEXPORT int indigoCountHeavyAtoms(int molecule);
-CEXPORT int indigoGrossFormula(int molecule);
-CEXPORT double indigoMolecularWeight(int molecule);
-CEXPORT double indigoMostAbundantMass(int molecule);
-CEXPORT double indigoMonoisotopicMass(int molecule);
-CEXPORT const char* indigoMassComposition(int molecule);
-CEXPORT double indigoTPSA(int molecule, int includeSP);
-CEXPORT int indigoNumRotatableBonds(int molecule);
-CEXPORT int indigoNumHydrogenBondAcceptors(int molecule);
-CEXPORT int indigoNumHydrogenBondDonors(int molecule);
-CEXPORT double indigoLogP(int molecule);
-CEXPORT double indigoMolarRefractivity(int molecule);
-CEXPORT double indigoPka(int molecule);
+INDIGO_EXPORT int indigoCountHeavyAtoms(int molecule);
+INDIGO_EXPORT int indigoGrossFormula(int molecule);
+INDIGO_EXPORT double indigoMolecularWeight(int molecule);
+INDIGO_EXPORT double indigoMostAbundantMass(int molecule);
+INDIGO_EXPORT double indigoMonoisotopicMass(int molecule);
+INDIGO_EXPORT const char *indigoMassComposition(int molecule);
+INDIGO_EXPORT double indigoTPSA(int molecule, int includeSP);
+INDIGO_EXPORT int indigoNumRotatableBonds(int molecule);
+INDIGO_EXPORT int indigoNumHydrogenBondAcceptors(int molecule);
+INDIGO_EXPORT int indigoNumHydrogenBondDonors(int molecule);
+INDIGO_EXPORT double indigoLogP(int molecule);
+INDIGO_EXPORT double indigoMolarRefractivity(int molecule);
+INDIGO_EXPORT double indigoPka(int molecule);
 
-CEXPORT const char* indigoCanonicalSmiles(int molecule);
-CEXPORT const char* indigoLayeredCode(int molecule);
+INDIGO_EXPORT const char *indigoCanonicalSmiles(int molecule);
+INDIGO_EXPORT const char *indigoLayeredCode(int molecule);
 
-CEXPORT int64_t indigoHash(int chemicalObject);
+INDIGO_EXPORT int64_t indigoHash(int chemicalObject);
 
-CEXPORT const int* indigoSymmetryClasses(int molecule, int* count_out);
+INDIGO_EXPORT const int *indigoSymmetryClasses(int molecule, int *count_out);
 
-CEXPORT int indigoHasCoord(int molecule);
-CEXPORT int indigoHasZCoord(int molecule);
-CEXPORT int indigoIsChiral(int molecule);
-CEXPORT int indigoCheckChirality(int molecule);
-CEXPORT int indigoCheck3DStereo(int molecule);
-CEXPORT int indigoCheckStereo(int molecule);
+INDIGO_EXPORT int indigoHasCoord(int molecule);
+INDIGO_EXPORT int indigoHasZCoord(int molecule);
+INDIGO_EXPORT int indigoIsChiral(int molecule);
+INDIGO_EXPORT int indigoCheckChirality(int molecule);
+INDIGO_EXPORT int indigoCheck3DStereo(int molecule);
+INDIGO_EXPORT int indigoCheckStereo(int molecule);
 
-CEXPORT int indigoIsPossibleFischerProjection(int molecule, const char* options);
+INDIGO_EXPORT int indigoIsPossibleFischerProjection(int molecule, const char *options);
 
-CEXPORT int indigoCreateSubmolecule(int molecule, int nvertices, int* vertices);
-CEXPORT int indigoCreateEdgeSubmolecule(int molecule, int nvertices, int* vertices, int nedges, int* edges);
+INDIGO_EXPORT int indigoCreateSubmolecule(int molecule, int nvertices, int *vertices);
+INDIGO_EXPORT int indigoCreateEdgeSubmolecule(int molecule, int nvertices, int *vertices, int nedges, int *edges);
 
-CEXPORT int indigoGetSubmolecule(int molecule, int nvertices, int* vertices);
+INDIGO_EXPORT int indigoGetSubmolecule(int molecule, int nvertices, int *vertices);
 
-CEXPORT int indigoRemoveAtoms(int molecule, int nvertices, int* vertices);
-CEXPORT int indigoRemoveBonds(int molecule, int nbonds, int* bonds);
+INDIGO_EXPORT int indigoRemoveAtoms(int molecule, int nvertices, int *vertices);
+INDIGO_EXPORT int indigoRemoveBonds(int molecule, int nbonds, int *bonds);
 
 // Determines and applies the best transformation to the given molecule
 // so that the specified atoms move as close as possible to the desired
 // positions. The size of desired_xyz is equal to 3 * natoms.
 // The return value is the root-mean-square measure of the difference
 // between the desired and obtained positions.
-CEXPORT float indigoAlignAtoms(int molecule, int natoms, int* atom_ids, float* desired_xyz);
+INDIGO_EXPORT float indigoAlignAtoms(int molecule, int natoms, int *atom_ids, float *desired_xyz);
 
 /* Things that work for both molecules and reactions */
 
-CEXPORT int indigoAromatize(int item);
-CEXPORT int indigoDearomatize(int item);
+INDIGO_EXPORT int indigoAromatize(int item);
+INDIGO_EXPORT int indigoDearomatize(int item);
 
-CEXPORT int indigoFoldHydrogens(int item);
-CEXPORT int indigoUnfoldHydrogens(int item);
+INDIGO_EXPORT int indigoFoldHydrogens(int item);
+INDIGO_EXPORT int indigoUnfoldHydrogens(int item);
 
-CEXPORT int indigoLayout(int object);
-CEXPORT int indigoClean2d(int object);
+INDIGO_EXPORT int indigoLayout(int object);
+INDIGO_EXPORT int indigoClean2d(int object);
 
-CEXPORT const char* indigoSmiles(int item);
-CEXPORT const char* indigoSmarts(int item);
-CEXPORT const char* indigoCanonicalSmarts(int item);
+INDIGO_EXPORT const char *indigoSmiles(int item);
+INDIGO_EXPORT const char *indigoSmarts(int item);
+INDIGO_EXPORT const char *indigoCanonicalSmarts(int item);
 
 // Returns a "mapping" if there is an exact match, zero otherwise
 // The flags string consists of space-separated flags.
@@ -753,55 +741,55 @@
 // "FRA": Connected fragments: disallows match of separate ions in salts
 // "ALL": All of the above
 // By default (with null or empty flags string) all flags are on.
-CEXPORT int indigoExactMatch(int item1, int item2, const char* flags);
+INDIGO_EXPORT int indigoExactMatch(int item1, int item2, const char *flags);
 
 // "beg" and "end" refer to the two ends of the tautomeric chain. Allowed
 // elements are separated by commas. '1' at the beginning means an aromatic
 // atom, while '0' means an aliphatic atom.
-CEXPORT int indigoSetTautomerRule(int id, const char* beg, const char* end);
+INDIGO_EXPORT int indigoSetTautomerRule(int id, const char *beg, const char *end);
 
-CEXPORT int indigoRemoveTautomerRule(int id);
+INDIGO_EXPORT int indigoRemoveTautomerRule(int id);
 
-CEXPORT int indigoClearTautomerRules();
+INDIGO_EXPORT int indigoClearTautomerRules();
 
-CEXPORT const char* indigoName(int handle);
-CEXPORT int indigoSetName(int handle, const char* name);
+INDIGO_EXPORT const char *indigoName(int handle);
+INDIGO_EXPORT int indigoSetName(int handle, const char *name);
 
 // You should not free() the obtained buffer, but rather memcpy() it if you want to keep it
-CEXPORT int indigoSerialize(int handle, byte** buf, int* size);
+INDIGO_EXPORT int indigoSerialize(int handle, byte **buf, int *size);
 
-CEXPORT int indigoUnserialize(const byte* buf, int size);
+INDIGO_EXPORT int indigoUnserialize(const byte *buf, int size);
 
 // Applicable to molecules/reactions obtained from SDF or RDF files,
 // and to their clones, and to their R-Group deconvolutions.
-CEXPORT int indigoHasProperty(int handle, const char* prop);
-CEXPORT const char* indigoGetProperty(int handle, const char* prop);
+INDIGO_EXPORT int indigoHasProperty(int handle, const char *prop);
+INDIGO_EXPORT const char *indigoGetProperty(int handle, const char *prop);
 
 // Applicable to newly created or cloned molecules/reactions,
 // and also to molecules/reactions obtained from SDF or RDF files.
 // If the property with the given name does not exist, it is created automatically.
-CEXPORT int indigoSetProperty(int item, const char* prop, const char* value);
+INDIGO_EXPORT int indigoSetProperty(int item, const char *prop, const char *value);
 
 // Does not raise an error if the given property does not exist
-CEXPORT int indigoRemoveProperty(int item, const char* prop);
+INDIGO_EXPORT int indigoRemoveProperty(int item, const char *prop);
 
 // Returns an iterator that one can pass to indigoName() to
 // know the name of the property. The value of the property can be
 // obtained via indigoGetProperty() call to the object
-CEXPORT int indigoIterateProperties(int handle);
+INDIGO_EXPORT int indigoIterateProperties(int handle);
 
 // Clears all properties of the molecule
-CEXPORT int indigoClearProperties(int handle);
+INDIGO_EXPORT int indigoClearProperties(int handle);
 
 // Accepts a molecule or reaction (but not query molecule or query reaction).
 // Returns a string describing the first encountered mistake with valence.
 // Returns an empty string if the input molecule/reaction is fine.
-CEXPORT const char* indigoCheckBadValence(int handle);
+INDIGO_EXPORT const char *indigoCheckBadValence(int handle);
 
 // Accepts a molecule or reaction (but not query molecule or query reaction).
 // Returns a string describing the first encountered mistake with ambiguous H counter.
 // Returns an empty string if the input molecule/reaction is fine.
-CEXPORT const char* indigoCheckAmbiguousH(int handle);
+INDIGO_EXPORT const char *indigoCheckAmbiguousH(int handle);
 
 /* Fingerprints */
 
@@ -819,119 +807,119 @@
 //                 substructure screening
 //   "full"    -- "Full fingerprint", which has all the mentioned
 //                 fingerprint types included
-CEXPORT int indigoFingerprint(int item, const char* type);
+INDIGO_EXPORT int indigoFingerprint(int item, const char *type);
 
 // Counts the nonzero (i.e. one) bits in a fingerprint
-CEXPORT int indigoCountBits(int fingerprint);
+INDIGO_EXPORT int indigoCountBits(int fingerprint);
 
 // Counts the number of the coinincident in two fingerprints
-CEXPORT int indigoCommonBits(int fingerprint1, int fingerprint2);
+INDIGO_EXPORT int indigoCommonBits(int fingerprint1, int fingerprint2);
 
 // Return one bits string for the fingerprint object
-CEXPORT const char* indigoOneBitsList(int fingerprint);
+INDIGO_EXPORT const char *indigoOneBitsList(int fingerprint);
 
 // Returns a 'fingerprint' object with data from 'buffer'
-CEXPORT int indigoLoadFingerprintFromBuffer(const byte* buffer, int size);
+INDIGO_EXPORT int indigoLoadFingerprintFromBuffer(const byte *buffer, int size);
 
 // Constructs a 'fingerprint' object from a normalized array of double descriptors
-CEXPORT int indigoLoadFingerprintFromDescriptors(const double* arr, int arr_len, int size, double density);
+INDIGO_EXPORT int indigoLoadFingerprintFromDescriptors(const double *arr, int arr_len, int size, double density);
 
 // Accepts two molecules, two reactions, or two fingerprints.
 // Returns the similarity measure between them.
 // Metrics: "tanimoto", "tversky", "tversky <alpha> <beta>", "euclid-sub" or "normalized-edit"
 // Zero pointer or empty string defaults to "tanimoto".
 // "tversky" without numbers defaults to alpha = beta = 0.5
-CEXPORT float indigoSimilarity(int item1, int item2, const char* metrics);
+INDIGO_EXPORT float indigoSimilarity(int item1, int item2, const char *metrics);
 
 /* Working with SDF/RDF/SMILES/CML/CDX files  */
 
-CEXPORT int indigoIterateSDF(int reader);
-CEXPORT int indigoIterateRDF(int reader);
-CEXPORT int indigoIterateSmiles(int reader);
-CEXPORT int indigoIterateCML(int reader);
-CEXPORT int indigoIterateCDX(int reader);
+INDIGO_EXPORT int indigoIterateSDF(int reader);
+INDIGO_EXPORT int indigoIterateRDF(int reader);
+INDIGO_EXPORT int indigoIterateSmiles(int reader);
+INDIGO_EXPORT int indigoIterateCML(int reader);
+INDIGO_EXPORT int indigoIterateCDX(int reader);
 
-CEXPORT int indigoIterateSDFile(const char* filename);
-CEXPORT int indigoIterateRDFile(const char* filename);
-CEXPORT int indigoIterateSmilesFile(const char* filename);
-CEXPORT int indigoIterateCMLFile(const char* filename);
-CEXPORT int indigoIterateCDXFile(const char* filename);
+INDIGO_EXPORT int indigoIterateSDFile(const char *filename);
+INDIGO_EXPORT int indigoIterateRDFile(const char *filename);
+INDIGO_EXPORT int indigoIterateSmilesFile(const char *filename);
+INDIGO_EXPORT int indigoIterateCMLFile(const char *filename);
+INDIGO_EXPORT int indigoIterateCDXFile(const char *filename);
 
 // Applicable to items returned by SDF/RDF iterators.
 // Returns the content of SDF/RDF item.
-CEXPORT const char* indigoRawData(int item);
+INDIGO_EXPORT const char *indigoRawData(int item);
 
 // Applicable to items returned by SDF/RDF iterators.
 // Returns the offset in the SDF/RDF file.
-CEXPORT int indigoTell(int handle);
-CEXPORT long long indigoTell64(int handle);
+INDIGO_EXPORT int indigoTell(int handle);
+INDIGO_EXPORT long long indigoTell64(int handle);
 
 // Saves the molecule to an SDF output stream
-CEXPORT int indigoSdfAppend(int output, int item);
+INDIGO_EXPORT int indigoSdfAppend(int output, int item);
 // Saves the molecule to a multiline SMILES output stream
-CEXPORT int indigoSmilesAppend(int output, int item);
+INDIGO_EXPORT int indigoSmilesAppend(int output, int item);
 
 // Similarly for RDF files, except that the header should be written first
-CEXPORT int indigoRdfHeader(int output);
-CEXPORT int indigoRdfAppend(int output, int item);
+INDIGO_EXPORT int indigoRdfHeader(int output);
+INDIGO_EXPORT int indigoRdfAppend(int output, int item);
 
 // Similarly for CML files, except that they have both header and footer
-CEXPORT int indigoCmlHeader(int output);
-CEXPORT int indigoCmlAppend(int output, int item);
-CEXPORT int indigoCmlFooter(int output);
+INDIGO_EXPORT int indigoCmlHeader(int output);
+INDIGO_EXPORT int indigoCmlAppend(int output, int item);
+INDIGO_EXPORT int indigoCmlFooter(int output);
 
 // Create saver objects that can be used to save molecules or reactions
 // Supported formats: 'sdf', 'smi' or 'smiles', 'cml', 'rdf'
 // Format argument is case-insensitive
 // Saver should be closed with indigoClose function
-CEXPORT int indigoCreateSaver(int output, const char* format);
-CEXPORT int indigoCreateFileSaver(const char* filename, const char* format);
+INDIGO_EXPORT int indigoCreateSaver(int output, const char *format);
+INDIGO_EXPORT int indigoCreateFileSaver(const char *filename, const char *format);
 
 // Append object to a specified saver stream
-CEXPORT int indigoAppend(int saver, int object);
+INDIGO_EXPORT int indigoAppend(int saver, int object);
 
 /* Arrays */
 
-CEXPORT int indigoCreateArray();
+INDIGO_EXPORT int indigoCreateArray();
 // Note: a clone of the object is added, not the object itself
-CEXPORT int indigoArrayAdd(int arr, int object);
-CEXPORT int indigoAt(int item, int index);
-CEXPORT int indigoCount(int item);
-CEXPORT int indigoClear(int arr);
-CEXPORT int indigoIterateArray(int arr);
+INDIGO_EXPORT int indigoArrayAdd(int arr, int object);
+INDIGO_EXPORT int indigoAt(int item, int index);
+INDIGO_EXPORT int indigoCount(int item);
+INDIGO_EXPORT int indigoClear(int arr);
+INDIGO_EXPORT int indigoIterateArray(int arr);
 
 /* Substructure matching */
 
 // Returns a new 'matcher' object
 // 'mode' is reserved for future use; currently its value is ignored
-CEXPORT int indigoSubstructureMatcher(int target, const char* mode);
+INDIGO_EXPORT int indigoSubstructureMatcher(int target, const char *mode);
 
 // Ignore target atom in the substructure matcher
-CEXPORT int indigoIgnoreAtom(int matcher, int atom_object);
+INDIGO_EXPORT int indigoIgnoreAtom(int matcher, int atom_object);
 
 // Ignore target atom in the substructure matcher
-CEXPORT int indigoUnignoreAtom(int matcher, int atom_object);
+INDIGO_EXPORT int indigoUnignoreAtom(int matcher, int atom_object);
 
 // Clear list of ignored target atoms in the substructure matcher
-CEXPORT int indigoUnignoreAllAtoms(int matcher);
+INDIGO_EXPORT int indigoUnignoreAllAtoms(int matcher);
 
 // Returns a new 'match' object on success, zero on fail
 //    matcher is an matcher object returned by indigoSubstructureMatcher
-CEXPORT int indigoMatch(int matcher, int query);
+INDIGO_EXPORT int indigoMatch(int matcher, int query);
 
 // Counts the number of embeddings of the query structure into the target
-CEXPORT int indigoCountMatches(int matcher, int query);
+INDIGO_EXPORT int indigoCountMatches(int matcher, int query);
 
 // Counts the number of embeddings of the query structure into the target
 // If number of embeddings is more then limit then limit is returned
-CEXPORT int indigoCountMatchesWithLimit(int matcher, int query, int embeddings_limit);
+INDIGO_EXPORT int indigoCountMatchesWithLimit(int matcher, int query, int embeddings_limit);
 
 // Returns substructure matches iterator
-CEXPORT int indigoIterateMatches(int matcher, int query);
+INDIGO_EXPORT int indigoIterateMatches(int matcher, int query);
 
 // Accepts a 'match' object obtained from indigoMatchSubstructure.
 // Returns a new molecule which has the query highlighted.
-CEXPORT int indigoHighlightedTarget(int match);
+INDIGO_EXPORT int indigoHighlightedTarget(int match);
 
 // Accepts an atom from the query, not an atom index.
 //   You can use indigoGetAtom() to obtain the atom by its index.
@@ -939,7 +927,7 @@
 // atom doesn't match particular atom in the target (R-group or explicit
 // hydrogen) then return value is zero.
 //   You can use indigoIndex() to obtain the index of the returned atom.
-CEXPORT int indigoMapAtom(int handle, int atom);
+INDIGO_EXPORT int indigoMapAtom(int handle, int atom);
 
 // Accepts a bond from the query, not a bond index.
 //   You can use indigoGetBond() to obtain the bond by its index.
@@ -947,7 +935,7 @@
 // bond doesn't match particular bond in the target (R-group or explicit
 // hydrogen) then return value is zero.
 //   You can use indigoIndex() to obtain the index of the returned bond.
-CEXPORT int indigoMapBond(int handle, int bond);
+INDIGO_EXPORT int indigoMapBond(int handle, int bond);
 
 // Accepts a molecule from the query reaction, not a molecule index.
 //   You can use indigoGetMolecule() to obtain the bond by its index.
@@ -955,11 +943,11 @@
 // molecule doesn't match particular molecule in the target then return
 // value is zero.
 //   You can use indigoIndex() to obtain the index of the returned molecule.
-CEXPORT int indigoMapMolecule(int handle, int molecule);
+INDIGO_EXPORT int indigoMapMolecule(int handle, int molecule);
 
 // Accepts a molecule and options for tautomer enumeration algorithms
 // Returns an iterator object over the molecules that are tautomers of this molecule.
-CEXPORT int indigoIterateTautomers(int molecule, const char* options);
+INDIGO_EXPORT int indigoIterateTautomers(int molecule, const char *options);
 
 /* Scaffold detection */
 
@@ -968,91 +956,93 @@
 //   (i) treated as a structure: the maximum (by the number of rings) common
 //       substructure of the given structures.
 //  (ii) passed to indigoAllScaffolds()
-CEXPORT int indigoExtractCommonScaffold(int structures, const char* options);
+INDIGO_EXPORT int indigoExtractCommonScaffold(int structures, const char *options);
 
 // Returns an array of all possible scaffolds.
 // The input parameter is the value returned by indigoExtractCommonScaffold().
-CEXPORT int indigoAllScaffolds(int extracted);
+INDIGO_EXPORT int indigoAllScaffolds(int extracted);
 
 /* R-Group deconvolution */
 
 // Returns a ``decomposition'' object that can be passed to
 // indigoDecomposedMoleculeScaffold() and
 // indigoIterateDecomposedMolecules()
-CEXPORT int indigoDecomposeMolecules(int scaffold, int structures);
+INDIGO_EXPORT int indigoDecomposeMolecules(int scaffold, int structures);
 
 // Returns a scaffold molecule with r-sites marking the place
 // for substituents to add to form the structures given above.
-CEXPORT int indigoDecomposedMoleculeScaffold(int decomp);
+INDIGO_EXPORT int indigoDecomposedMoleculeScaffold(int decomp);
 
 // Returns an iterator which corresponds to the given collection of structures.
 // indigoDecomposedMoleculeHighlighted() and
 // indigoDecomposedMoleculeWithRGroups() are applicable to the
 // values returned by the iterator.
-CEXPORT int indigoIterateDecomposedMolecules(int decomp);
+INDIGO_EXPORT int indigoIterateDecomposedMolecules(int decomp);
 
 // Returns a molecule with highlighted scaffold
-CEXPORT int indigoDecomposedMoleculeHighlighted(int decomp);
+INDIGO_EXPORT int indigoDecomposedMoleculeHighlighted(int decomp);
 
 // Returns a query molecule with r-sites and "R1=...", "R2=..."
 // substituents defined. The 'scaffold' part of the molecule
 // is identical to the indigoDecomposedMoleculeScaffold()
-CEXPORT int indigoDecomposedMoleculeWithRGroups(int decomp);
+INDIGO_EXPORT int indigoDecomposedMoleculeWithRGroups(int decomp);
 
 /*
  * Decomposition Iteration API
  */
 // Returns a 'decomposition' object
-CEXPORT int indigoCreateDecomposer(int scaffold);
+INDIGO_EXPORT int indigoCreateDecomposer(int scaffold);
 // Returns a 'decomposition' item
-CEXPORT int indigoDecomposeMolecule(int decomp, int mol);
+INDIGO_EXPORT int indigoDecomposeMolecule(int decomp, int mol);
 // Returns decomposition iterator
-CEXPORT int indigoIterateDecompositions(int deco_item);
+INDIGO_EXPORT int indigoIterateDecompositions(int deco_item);
 // Adds the input decomposition to a full scaffold
-CEXPORT int indigoAddDecomposition(int decomp, int q_match);
+INDIGO_EXPORT int indigoAddDecomposition(int decomp, int q_match);
 
 /* R-Group convolution */
 
-CEXPORT int indigoGetFragmentedMolecule(int elem, const char* options);
-CEXPORT int indigoRGroupComposition(int molecule, const char* options);
+INDIGO_EXPORT int indigoGetFragmentedMolecule(int elem, const char *options);
+INDIGO_EXPORT int indigoRGroupComposition(int molecule, const char *options);
 
 /*
  * Abbreviations
  */
-CEXPORT int indigoExpandAbbreviations(int molecule);
+INDIGO_EXPORT int indigoExpandAbbreviations(int molecule);
 
 /* Other */
 
-CEXPORT const char* indigoToString(int handle);
-CEXPORT const char* indigoToBase64String(int handle);
-CEXPORT int indigoToBuffer(int handle, char** buf, int* size);
+INDIGO_EXPORT const char *indigoToString(int handle);
+INDIGO_EXPORT const char *indigoToBase64String(int handle);
+INDIGO_EXPORT int indigoToBuffer(int handle, char **buf, int *size);
 
 /* Reaction products enumeration */
 
 // Accepts a query reaction with markd R-sites, and array of arrays
 // of substituents corresponding to the R-Sites. Returns an array of
 // reactions with R-Sites replaced by the actual substituents.
-CEXPORT int indigoReactionProductEnumerate(int reaction, int monomers);
+INDIGO_EXPORT int indigoReactionProductEnumerate(int reaction, int monomers);
 
-CEXPORT int indigoTransform(int reaction, int monomers);
+INDIGO_EXPORT int indigoTransform(int reaction, int monomers);
 
-CEXPORT int indigoTransformHELMtoSCSR(int monomer);
+INDIGO_EXPORT int indigoTransformHELMtoSCSR(int monomer);
 
 /* Debug functionality */
 
 // Returns internal type of an object
-CEXPORT const char* indigoDbgInternalType(int object);
+INDIGO_EXPORT const char *indigoDbgInternalType(int object);
 
 // Internal breakpoint
-CEXPORT void indigoDbgBreakpoint(void);
+INDIGO_EXPORT void indigoDbgBreakpoint(void);
 
 // Methods that returns profiling infromation in a human readable format
-CEXPORT const char* indigoDbgProfiling(int /*bool*/ whole_session);
+INDIGO_EXPORT const char *indigoDbgProfiling(int /*bool*/ whole_session);
 
 // Reset profiling counters either for the current state or for the whole session
-CEXPORT int indigoDbgResetProfiling(int /*bool*/ whole_session);
+INDIGO_EXPORT int indigoDbgResetProfiling(int /*bool*/ whole_session);
 
 // Methods that returns profiling counter value for a particular counter
-CEXPORT qword indigoDbgProfilingGetCounter(const char* name, int /*bool*/ whole_session);
-
+INDIGO_EXPORT qword indigoDbgProfilingGetCounter(const char *name, int /*bool*/ whole_session);
+#ifdef __cplusplus
+}
+#endif
 #endif
Index: opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_block.simd.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_block.simd.hpp b/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_block.simd.hpp
--- a/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_block.simd.hpp	(revision 5199850039ad23f1f0e6cccea5061a9fea5efca6)
+++ b/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_block.simd.hpp	(date 1701848687871)
@@ -125,635 +125,4 @@
 
 CV_CPU_OPTIMIZATION_NAMESPACE_END
 
-// NEON code work around.
-namespace opt_NEON
-{
-#if !defined(CV_CPU_OPTIMIZATION_DECLARATIONS_ONLY) && CV_NEON
-
-void convBlock(int np, const float* a, const float* b, float* c, int ldc, bool init_c, int width, const int convMR, const int convNR)
-{
-#if CV_NEON_AARCH64
-    if (convMR == 4 && convNR == 28) // AARCH64
-    {
-        float32x4_t c00 = vdupq_n_f32(0.f), c01 = c00, c02 = c00, c03 = c00, c04 = c00, c05 = c00, c06 = c00;
-        float32x4_t c10 = vdupq_n_f32(0.f), c11 = c10, c12 = c10, c13 = c10, c14 = c10, c15 = c10, c16 = c10;
-        float32x4_t c20 = vdupq_n_f32(0.f), c21 = c20, c22 = c20, c23 = c20, c24 = c20, c25 = c20, c26 = c20;
-        float32x4_t c30 = vdupq_n_f32(0.f), c31 = c30, c32 = c30, c33 = c30, c34 = c30, c35 = c30, c36 = c30;
-
-        if (width > 16)
-        {
-            for( int p = 0; p < np; p++, a += convMR, b += convNR )
-            {
-                float32x4_t a0 = vld1q_f32(a), b0, b1, b2;
-                b0 = vld1q_f32(b); b1 = vld1q_f32(b + 4); b2 = vld1q_f32(b + 8);
-
-                c00 = vfmaq_laneq_f32(c00, b0, a0, 0);
-                c01 = vfmaq_laneq_f32(c01, b1, a0, 0);
-                c02 = vfmaq_laneq_f32(c02, b2, a0, 0);
-                c10 = vfmaq_laneq_f32(c10, b0, a0, 1);
-                c11 = vfmaq_laneq_f32(c11, b1, a0, 1);
-                c12 = vfmaq_laneq_f32(c12, b2, a0, 1);
-                c20 = vfmaq_laneq_f32(c20, b0, a0, 2);
-                c21 = vfmaq_laneq_f32(c21, b1, a0, 2);
-                c22 = vfmaq_laneq_f32(c22, b2, a0, 2);
-                c30 = vfmaq_laneq_f32(c30, b0, a0, 3);
-                c31 = vfmaq_laneq_f32(c31, b1, a0, 3);
-                c32 = vfmaq_laneq_f32(c32, b2, a0, 3);
-
-                b0 = vld1q_f32(b + 12); b1 = vld1q_f32(b + 16); b2 = vld1q_f32(b + 20);
-
-                c03 = vfmaq_laneq_f32(c03, b0, a0, 0);
-                c04 = vfmaq_laneq_f32(c04, b1, a0, 0);
-                c05 = vfmaq_laneq_f32(c05, b2, a0, 0);
-                c13 = vfmaq_laneq_f32(c13, b0, a0, 1);
-                c14 = vfmaq_laneq_f32(c14, b1, a0, 1);
-                c15 = vfmaq_laneq_f32(c15, b2, a0, 1);
-                c23 = vfmaq_laneq_f32(c23, b0, a0, 2);
-                c24 = vfmaq_laneq_f32(c24, b1, a0, 2);
-                c25 = vfmaq_laneq_f32(c25, b2, a0, 2);
-                c33 = vfmaq_laneq_f32(c33, b0, a0, 3);
-                c34 = vfmaq_laneq_f32(c34, b1, a0, 3);
-                c35 = vfmaq_laneq_f32(c35, b2, a0, 3);
-
-                b0 = vld1q_f32(b + 24);
-                c06 = vfmaq_laneq_f32(c06, b0, a0, 0);
-                c16 = vfmaq_laneq_f32(c16, b0, a0, 1);
-                c26 = vfmaq_laneq_f32(c26, b0, a0, 2);
-                c36 = vfmaq_laneq_f32(c36, b0, a0, 3);
-            }
-        }
-        else if (width > 8)
-        {
-            for( int p = 0; p < np; p++, a += convMR, b += convNR )
-            {
-                float32x4_t a0 = vld1q_f32(a), b0, b1, b2;
-                b0 = vld1q_f32(b); b1 = vld1q_f32(b + 4); b2 = vld1q_f32(b + 8);
-
-                c00 = vfmaq_laneq_f32(c00, b0, a0, 0);
-                c01 = vfmaq_laneq_f32(c01, b1, a0, 0);
-                c02 = vfmaq_laneq_f32(c02, b2, a0, 0);
-                c10 = vfmaq_laneq_f32(c10, b0, a0, 1);
-                c11 = vfmaq_laneq_f32(c11, b1, a0, 1);
-                c12 = vfmaq_laneq_f32(c12, b2, a0, 1);
-                c20 = vfmaq_laneq_f32(c20, b0, a0, 2);
-                c21 = vfmaq_laneq_f32(c21, b1, a0, 2);
-                c22 = vfmaq_laneq_f32(c22, b2, a0, 2);
-                c30 = vfmaq_laneq_f32(c30, b0, a0, 3);
-                c31 = vfmaq_laneq_f32(c31, b1, a0, 3);
-                c32 = vfmaq_laneq_f32(c32, b2, a0, 3);
-
-                b0 = vld1q_f32(b + 12);
-
-                c03 = vfmaq_laneq_f32(c03, b0, a0, 0);
-                c13 = vfmaq_laneq_f32(c13, b0, a0, 1);
-                c23 = vfmaq_laneq_f32(c23, b0, a0, 2);
-                c33 = vfmaq_laneq_f32(c33, b0, a0, 3);
-            }
-        }
-        else if (width > 4)
-        {
-            for( int p = 0; p < np; p++, a += convMR, b += convNR )
-            {
-                float32x4_t a0 = vld1q_f32(a), b0, b1;
-                b0 = vld1q_f32(b); b1 = vld1q_f32(b + 4);
-
-                c00 = vfmaq_laneq_f32(c00, b0, a0, 0);
-                c01 = vfmaq_laneq_f32(c01, b1, a0, 0);
-                c10 = vfmaq_laneq_f32(c10, b0, a0, 1);
-                c11 = vfmaq_laneq_f32(c11, b1, a0, 1);
-                c20 = vfmaq_laneq_f32(c20, b0, a0, 2);
-                c21 = vfmaq_laneq_f32(c21, b1, a0, 2);
-                c30 = vfmaq_laneq_f32(c30, b0, a0, 3);
-                c31 = vfmaq_laneq_f32(c31, b1, a0, 3);
-            }
-        }
-        else
-        {
-            for( int p = 0; p < np; p++, a += convMR, b += convNR )
-            {
-                float32x4_t a0 = vld1q_f32(a), b0;
-                b0 = vld1q_f32(b);
-
-                c00 = vfmaq_laneq_f32(c00, b0, a0, 0);
-                c10 = vfmaq_laneq_f32(c10, b0, a0, 1);
-                c20 = vfmaq_laneq_f32(c20, b0, a0, 2);
-                c30 = vfmaq_laneq_f32(c30, b0, a0, 3);
-            }
-        }
-
-        if (!init_c)
-        {
-            c00 = vaddq_f32(c00, vld1q_f32(c));
-            c01 = vaddq_f32(c01, vld1q_f32(c + 4));
-            c02 = vaddq_f32(c02, vld1q_f32(c + 8));
-            c03 = vaddq_f32(c03, vld1q_f32(c + 12));
-            c04 = vaddq_f32(c04, vld1q_f32(c + 16));
-            c05 = vaddq_f32(c05, vld1q_f32(c + 20));
-            c06 = vaddq_f32(c06, vld1q_f32(c + 24));
-
-            c10 = vaddq_f32(c10, vld1q_f32(c + ldc));
-            c11 = vaddq_f32(c11, vld1q_f32(c + ldc + 4));
-            c12 = vaddq_f32(c12, vld1q_f32(c + ldc + 8));
-            c13 = vaddq_f32(c13, vld1q_f32(c + ldc + 12));
-            c14 = vaddq_f32(c14, vld1q_f32(c + ldc + 16));
-            c15 = vaddq_f32(c15, vld1q_f32(c + ldc + 20));
-            c16 = vaddq_f32(c16, vld1q_f32(c + ldc + 24));
-
-            c20 = vaddq_f32(c20, vld1q_f32(c + ldc*2));
-            c21 = vaddq_f32(c21, vld1q_f32(c + ldc*2 + 4));
-            c22 = vaddq_f32(c22, vld1q_f32(c + ldc*2 + 8));
-            c23 = vaddq_f32(c23, vld1q_f32(c + ldc*2 + 12));
-            c24 = vaddq_f32(c24, vld1q_f32(c + ldc*2 + 16));
-            c25 = vaddq_f32(c25, vld1q_f32(c + ldc*2 + 20));
-            c26 = vaddq_f32(c26, vld1q_f32(c + ldc*2 + 24));
-
-            c30 = vaddq_f32(c30, vld1q_f32(c + ldc*3));
-            c31 = vaddq_f32(c31, vld1q_f32(c + ldc*3 + 4));
-            c32 = vaddq_f32(c32, vld1q_f32(c + ldc*3 + 8));
-            c33 = vaddq_f32(c33, vld1q_f32(c + ldc*3 + 12));
-            c34 = vaddq_f32(c34, vld1q_f32(c + ldc*3 + 16));
-            c35 = vaddq_f32(c35, vld1q_f32(c + ldc*3 + 20));
-            c36 = vaddq_f32(c36, vld1q_f32(c + ldc*3 + 24));
-        }
-
-        vst1q_f32(c, c00); vst1q_f32(c+4, c01);
-        vst1q_f32(c+8, c02); vst1q_f32(c+12, c03);
-        vst1q_f32(c+16, c04); vst1q_f32(c+20, c05);
-        vst1q_f32(c+24, c06);
-
-        vst1q_f32(c+ldc, c10); vst1q_f32(c+ldc+4, c11);
-        vst1q_f32(c+ldc+8, c12); vst1q_f32(c+ldc+12, c13);
-        vst1q_f32(c+ldc+16, c14); vst1q_f32(c+ldc+20, c15);
-        vst1q_f32(c+ldc+24, c16);
-
-        vst1q_f32(c+ldc*2, c20); vst1q_f32(c+ldc*2+4, c21);
-        vst1q_f32(c+ldc*2+8, c22); vst1q_f32(c+ldc*2+12, c23);
-        vst1q_f32(c+ldc*2+16, c24); vst1q_f32(c+ldc*2+20, c25);
-        vst1q_f32(c+ldc*2+24, c26);
-
-        vst1q_f32(c+ldc*3, c30); vst1q_f32(c+ldc*3+4, c31);
-        vst1q_f32(c+ldc*3+8, c32); vst1q_f32(c+ldc*3+12, c33);
-        vst1q_f32(c+ldc*3+16, c34); vst1q_f32(c+ldc*3+20, c35);
-        vst1q_f32(c+ldc*3+24, c36);
-    }
-    else
-#endif
-    if (convMR == 4 && convNR == 12) // ARMv7
-    {
-        float32x4_t c0 = vdupq_n_f32(0.f), c1 = c0, c2 = c0;
-        float32x4_t c3 = vdupq_n_f32(0.f), c4 = c3, c5 = c3;
-        float32x4_t c6 = vdupq_n_f32(0.f), c7 = c6, c8 = c6;
-        float32x4_t c9 = vdupq_n_f32(0.f), c10 = c9, c11 = c9;
-
-        float32x2_t a0 = vdup_n_f32(0.0f), a1 = a0;
-        float32x4_t b0 = vdupq_n_f32(0.0f), b1 = vdupq_n_f32(0.0f), b2 = vdupq_n_f32(0.0f);
-
-        if (width > 8)
-        {
-            for (int p = 0; p < np; p++, a += convMR, b += convNR)
-            {
-                a0 = vld1_f32(a), a1 = vld1_f32(a+2);
-                b0 = vld1q_f32(b), b1 = vld1q_f32(b + 4), b2 = vld1q_f32(b + 8);
-
-                c0 = vmlaq_lane_f32(c0, b0, a0, 0);
-                c1 = vmlaq_lane_f32(c1, b1, a0, 0);
-                c2 = vmlaq_lane_f32(c2, b2, a0, 0);
-
-                c3 = vmlaq_lane_f32(c3, b0, a0, 1);
-                c4 = vmlaq_lane_f32(c4, b1, a0, 1);
-                c5 = vmlaq_lane_f32(c5, b2, a0, 1);
-
-                c6 = vmlaq_lane_f32(c6, b0, a1, 0);
-                c7 = vmlaq_lane_f32(c7, b1, a1, 0);
-                c8 = vmlaq_lane_f32(c8, b2, a1, 0);
-
-                c9  = vmlaq_lane_f32(c9 , b0, a1, 1);
-                c10 = vmlaq_lane_f32(c10, b1, a1, 1);
-                c11 = vmlaq_lane_f32(c11, b2, a1, 1);
-            }
-        }
-        else if (width > 4)
-        {
-            for (int p = 0; p < np; p++, a += convMR, b += convNR)
-            {
-                a0 = vld1_f32(a), a1 = vld1_f32(a+2);
-                b0 = vld1q_f32(b), b1 = vld1q_f32(b + 4);
-
-                c0 = vmlaq_lane_f32(c0, b0, a0, 0);
-                c1 = vmlaq_lane_f32(c1, b1, a0, 0);
-
-                c3 = vmlaq_lane_f32(c3, b0, a0, 1);
-                c4 = vmlaq_lane_f32(c4, b1, a0, 1);
-
-                c6 = vmlaq_lane_f32(c6, b0, a1, 0);
-                c7 = vmlaq_lane_f32(c7, b1, a1, 0);
-
-                c9  = vmlaq_lane_f32(c9 , b0, a1, 1);
-                c10 = vmlaq_lane_f32(c10, b1, a1, 1);
-            }
-        }
-        else
-        {
-            for (int p = 0; p < np; p++, a += convMR, b += convNR)
-            {
-                a0 = vld1_f32(a), a1 = vld1_f32(a+2);
-                b0 = vld1q_f32(b);
-
-                c0 = vmlaq_lane_f32(c0, b0, a0, 0);
-                c3 = vmlaq_lane_f32(c3, b0, a0, 1);
-                c6 = vmlaq_lane_f32(c6, b0, a1, 0);
-                c9  = vmlaq_lane_f32(c9 , b0, a1, 1);
-            }
-        }
-
-        if (!init_c)
-        {
-            c0 = vaddq_f32(c0, vld1q_f32(c));
-            c1 = vaddq_f32(c1, vld1q_f32(c + 4));
-            c2 = vaddq_f32(c2, vld1q_f32(c + 8));
-
-            c3 = vaddq_f32(c3, vld1q_f32(c + ldc));
-            c4 = vaddq_f32(c4, vld1q_f32(c + ldc + 4));
-            c5 = vaddq_f32(c5, vld1q_f32(c + ldc + 8));
-
-            c6 = vaddq_f32(c6, vld1q_f32(c + ldc * 2));
-            c7 = vaddq_f32(c7, vld1q_f32(c + ldc * 2 + 4));
-            c8 = vaddq_f32(c8, vld1q_f32(c + ldc * 2 + 8));
-
-            c9  = vaddq_f32(c9 , vld1q_f32(c + ldc * 3));
-            c10 = vaddq_f32(c10, vld1q_f32(c + ldc * 3 + 4));
-            c11 = vaddq_f32(c11, vld1q_f32(c + ldc * 3 + 8));
-        }
-
-        vst1q_f32(c, c0), vst1q_f32(c+4, c1), vst1q_f32(c+8, c2);
-        vst1q_f32(c + ldc, c3), vst1q_f32(c + ldc + 4, c4), vst1q_f32(c + ldc + 8, c5);
-        vst1q_f32(c + ldc*2, c6), vst1q_f32(c + ldc*2 + 4, c7), vst1q_f32(c + ldc*2 + 8, c8);
-        vst1q_f32(c + ldc*3, c9), vst1q_f32(c + ldc*3 + 4, c10), vst1q_f32(c + ldc*3 + 8, c11);
-    }
-    else
-        CV_Error(Error::StsNotImplemented, "Unsupported convMR and/or convNR in opt_NEON::convBlock");
-}
-
-void convBlockMR1_F32(int np, const float * a, const float * b, float *c, const float bias, bool init_c,
-                  const float minval, const float maxval, bool ifMinMaxAct, const int width, const int convNR)
-{
-    CV_Assert(convNR == 28);
-    float32x4_t c0 = vdupq_n_f32(bias), c1 = c0, c2 = c0;
-    float32x4_t c3 = c0, c4 = c0, c5 = c0, c6 = c0;
-
-    if (width > 16)
-    {
-        for (int p = 0; p < np; p++, a++, b += convNR)
-        {
-            float32x4_t b0 = vld1q_f32(b), b1 = vld1q_f32(b + 4), b2 = vld1q_f32(b + 8);
-            float32x4_t b3 = vld1q_f32(b + 12), b4 = vld1q_f32(b + 16), b5 = vld1q_f32(b + 20);
-            float32x4_t b6 = vld1q_f32(b + 24);
-
-            c0 = vmlaq_n_f32(c0, b0, a[0]);
-            c1 = vmlaq_n_f32(c1, b1, a[0]);
-            c2 = vmlaq_n_f32(c2, b2, a[0]);
-            c3 = vmlaq_n_f32(c3, b3, a[0]);
-            c4 = vmlaq_n_f32(c4, b4, a[0]);
-            c5 = vmlaq_n_f32(c5, b5, a[0]);
-            c6 = vmlaq_n_f32(c6, b6, a[0]);
-        }
-    }
-    else if (width > 8)
-    {
-        for (int p = 0; p < np; p++, a++, b += convNR)
-        {
-            float32x4_t b0 = vld1q_f32(b), b1 = vld1q_f32(b + 4), b2 = vld1q_f32(b + 8);
-            float32x4_t b3 = vld1q_f32(b + 12);
-
-            c0 = vmlaq_n_f32(c0, b0, a[0]);
-            c1 = vmlaq_n_f32(c1, b1, a[0]);
-            c2 = vmlaq_n_f32(c2, b2, a[0]);
-            c3 = vmlaq_n_f32(c3, b3, a[0]);
-        }
-    }
-    else if (width > 4)
-    {
-        for (int p = 0; p < np; p++, a++, b += convNR)
-        {
-            float32x4_t b0 = vld1q_f32(b), b1 = vld1q_f32(b + 4);
-
-            c0 = vmlaq_n_f32(c0, b0, a[0]);
-            c1 = vmlaq_n_f32(c1, b1, a[0]);
-        }
-    }
-    else
-    {
-        for (int p = 0; p < np; p++, a++, b += convNR)
-        {
-            float32x4_t b0 = vld1q_f32(b);
-            c0 = vmlaq_n_f32(c0, b0, a[0]);
-        }
-    }
-
-    if (init_c)
-    {
-        c0 += vld1q_f32(c);
-        c1 += vld1q_f32(c + 4);
-        c2 += vld1q_f32(c + 8);
-        c3 += vld1q_f32(c + 12);
-        c4 += vld1q_f32(c + 16);
-        c5 += vld1q_f32(c + 20);
-        c6 += vld1q_f32(c + 24);
-    }
-
-    if (ifMinMaxAct)
-    {
-        float32x4_t v_minval = vdupq_n_f32(minval), v_maxval = vdupq_n_f32(maxval);
-
-        c0 = vminq_f32(vmaxq_f32(c0, v_minval), v_maxval);
-        c1 = vminq_f32(vmaxq_f32(c1, v_minval), v_maxval);
-        c2 = vminq_f32(vmaxq_f32(c2, v_minval), v_maxval);
-        c3 = vminq_f32(vmaxq_f32(c3, v_minval), v_maxval);
-        c4 = vminq_f32(vmaxq_f32(c4, v_minval), v_maxval);
-        c5 = vminq_f32(vmaxq_f32(c5, v_minval), v_maxval);
-        c6 = vminq_f32(vmaxq_f32(c6, v_minval), v_maxval);
-    }
-
-    vst1q_f32(c, c0);
-    vst1q_f32(c + 4, c1);
-    vst1q_f32(c + 8, c2);
-    vst1q_f32(c + 12, c3);
-    vst1q_f32(c + 16, c4);
-    vst1q_f32(c + 20, c5);
-    vst1q_f32(c + 24, c6);
-}
-
-#if CV_NEON_AARCH64 && defined(__ARM_FEATURE_FP16_VECTOR_ARITHMETIC)
-// Fix conflict between float16_t in arm_neon.h and float16_t in cvdef.h.
-typedef __fp16 float16_t;
-
-#ifndef __ARM_FEATURE_FMA // Work around without FMA support.
-#define vfmaq_f16(a, b, c) (a + b * c)
-#endif
-void convBlock_FP16(int np, const char * _a, const char * _b, char * _c, int ldc, bool init_c, int width,
-                    const int convMR_fp16, const int convNR_fp16)
-{
-#if 1
-    const float16_t* a = (const float16_t*)_a;
-    const float16_t* b = (const float16_t*)_b;
-    float16_t* c = (float16_t*)_c;
-
-    CV_Assert(convMR_fp16 == 8 && convNR_fp16 == 24);
-
-    float16x8_t c00 = vdupq_n_f16(0), c01 = c00, c02 = c00;
-    float16x8_t c10 = c00, c11 = c00, c12 = c00;
-    float16x8_t c20 = c00, c21 = c00, c22 = c00;
-    float16x8_t c30 = c00, c31 = c00, c32 = c00;
-    float16x8_t c40 = c00, c41 = c00, c42 = c00;
-    float16x8_t c50 = c00, c51 = c00, c52 = c00;
-    float16x8_t c60 = c00, c61 = c00, c62 = c00;
-    float16x8_t c70 = c00, c71 = c00, c72 = c00;
-
-    float16x8_t b0 = c00, b1 = c00, b2 = c00;
-
-    if (width > 16)
-    {
-        for (int p = 0; p < np; p++, a += convMR_fp16, b += convNR_fp16)
-        {
-            float16x4_t a0 = vld1_f16(a), a1 = vld1_f16(a + 4);
-            b0 = vld1q_f16(b), b1 = vld1q_f16(b + 8), b2 = vld1q_f16(b + 16);
-
-            c00 = vfmaq_lane_f16(c00, b0, a0, 0);
-            c01 = vfmaq_lane_f16(c01, b1, a0, 0);
-            c02 = vfmaq_lane_f16(c02, b2, a0, 0);
-
-            c10 = vfmaq_lane_f16(c10, b0, a0, 1);
-            c11 = vfmaq_lane_f16(c11, b1, a0, 1);
-            c12 = vfmaq_lane_f16(c12, b2, a0, 1);
-
-            c20 = vfmaq_lane_f16(c20, b0, a0, 2);
-            c21 = vfmaq_lane_f16(c21, b1, a0, 2);
-            c22 = vfmaq_lane_f16(c22, b2, a0, 2);
-
-            c30 = vfmaq_lane_f16(c30, b0, a0, 3);
-            c31 = vfmaq_lane_f16(c31, b1, a0, 3);
-            c32 = vfmaq_lane_f16(c32, b2, a0, 3);
-
-            c40 = vfmaq_lane_f16(c40, b0, a1, 0);
-            c41 = vfmaq_lane_f16(c41, b1, a1, 0);
-            c42 = vfmaq_lane_f16(c42, b2, a1, 0);
-
-            c50 = vfmaq_lane_f16(c50, b0, a1, 1);
-            c51 = vfmaq_lane_f16(c51, b1, a1, 1);
-            c52 = vfmaq_lane_f16(c52, b2, a1, 1);
-
-            c60 = vfmaq_lane_f16(c60, b0, a1, 2);
-            c61 = vfmaq_lane_f16(c61, b1, a1, 2);
-            c62 = vfmaq_lane_f16(c62, b2, a1, 2);
-
-            c70 = vfmaq_lane_f16(c70, b0, a1, 3);
-            c71 = vfmaq_lane_f16(c71, b1, a1, 3);
-            c72 = vfmaq_lane_f16(c72, b2, a1, 3);
-        }
-    }
-    else if (width > 8)
-    {
-        for( int p = 0; p < np; p++, a += convMR_fp16, b += convNR_fp16)
-        {
-            float16x4_t a0 = vld1_f16(a), a1 = vld1_f16(a + 4);
-            float16x8_t b0 = vld1q_f16(b), b1 = vld1q_f16(b + 8);
-
-            c00 = vfmaq_lane_f16(c00, b0, a0, 0);
-            c01 = vfmaq_lane_f16(c01, b1, a0, 0);
-
-            c10 = vfmaq_lane_f16(c10, b0, a0, 1);
-            c11 = vfmaq_lane_f16(c11, b1, a0, 1);
-
-            c20 = vfmaq_lane_f16(c20, b0, a0, 2);
-            c21 = vfmaq_lane_f16(c21, b1, a0, 2);
-
-            c30 = vfmaq_lane_f16(c30, b0, a0, 3);
-            c31 = vfmaq_lane_f16(c31, b1, a0, 3);
-
-            c40 = vfmaq_lane_f16(c40, b0, a1, 0);
-            c41 = vfmaq_lane_f16(c41, b1, a1, 0);
-
-            c50 = vfmaq_lane_f16(c50, b0, a1, 1);
-            c51 = vfmaq_lane_f16(c51, b1, a1, 1);
-
-            c60 = vfmaq_lane_f16(c60, b0, a1, 2);
-            c61 = vfmaq_lane_f16(c61, b1, a1, 2);
-
-            c70 = vfmaq_lane_f16(c70, b0, a1, 3);
-            c71 = vfmaq_lane_f16(c71, b1, a1, 3);
-        }
-    }
-    else
-    {
-        for( int p = 0; p < np; p++, a += convMR_fp16, b += convNR_fp16)
-        {
-            float16x4_t a0 = vld1_f16(a), a1 = vld1_f16(a + 4);
-            float16x8_t b0 = vld1q_f16(b);
-
-            c00 = vfmaq_lane_f16(c00, b0, a0, 0);
-            c10 = vfmaq_lane_f16(c10, b0, a0, 1);
-            c20 = vfmaq_lane_f16(c20, b0, a0, 2);
-            c30 = vfmaq_lane_f16(c30, b0, a0, 3);
-            c40 = vfmaq_lane_f16(c40, b0, a1, 0);
-            c50 = vfmaq_lane_f16(c50, b0, a1, 1);
-            c60 = vfmaq_lane_f16(c60, b0, a1, 2);
-            c70 = vfmaq_lane_f16(c70, b0, a1, 3);
-        }
-    }
-
-    if (!init_c)
-    {
-#undef _FX_UPDATE_CBUF_ROW
-#define _FX_UPDATE_CBUF_ROW(row) \
-        c##row##0 = c##row##0 + vld1q_f16(c + row*ldc); \
-        c##row##1 = c##row##1 + vld1q_f16(c + row*ldc + 8); \
-        c##row##2 = c##row##2 + vld1q_f16(c + row*ldc + 16)
-
-        _FX_UPDATE_CBUF_ROW(0);
-        _FX_UPDATE_CBUF_ROW(1);
-        _FX_UPDATE_CBUF_ROW(2);
-        _FX_UPDATE_CBUF_ROW(3);
-        _FX_UPDATE_CBUF_ROW(4);
-        _FX_UPDATE_CBUF_ROW(5);
-        _FX_UPDATE_CBUF_ROW(6);
-        _FX_UPDATE_CBUF_ROW(7);
-    }
-
-#undef _FX_STORE_CBUF_ROW
-#define _FX_STORE_CBUF_ROW(row) \
-    vst1q_f16(c + row*ldc, c##row##0); \
-    vst1q_f16(c + row*ldc + 8, c##row##1); \
-    vst1q_f16(c + row*ldc + 16, c##row##2)
-
-    _FX_STORE_CBUF_ROW(0);
-    _FX_STORE_CBUF_ROW(1);
-    _FX_STORE_CBUF_ROW(2);
-    _FX_STORE_CBUF_ROW(3);
-    _FX_STORE_CBUF_ROW(4);
-    _FX_STORE_CBUF_ROW(5);
-    _FX_STORE_CBUF_ROW(6);
-    _FX_STORE_CBUF_ROW(7);
-#else
-    // reference only.
-    const float16_t* a = (const float16_t*)_a;
-    const float16_t* b = (const float16_t*)_b;
-    float16_t* c = (float16_t*)_c;
-    float cbuf[convMR_fp16*convNR_fp16];
-    memset(cbuf, 0, sizeof(cbuf));
-
-    for( int p = 0; p < np; p++ )
-    {
-        for( int i = 0; i < convMR_fp16; i++ )
-        {
-            float ai = float(a[convMR_fp16*p + i]);
-                for( int j = 0; j < convNR_fp16; j++ )
-                    cbuf[i*convNR_fp16+j] += float(b[convNR_fp16*p + j]) * ai;
-        }
-    }
-
-    if (!init_c)
-    {
-    for(int i = 0; i < convMR_fp16; i++)
-        {
-            for(int j = 0; j < convNR_fp16; j++)
-                c[i*ldc + j] = float16_t(float(c[i*ldc + j]) + cbuf[i*convNR_fp16 + j]);
-        }
-    }
-    else
-    {
-        for(int i = 0; i < convMR_fp16; i++)
-        {
-            for(int j = 0; j < convNR_fp16; j++)
-                c[i*ldc + j] = (float16_t)(cbuf[i*convNR_fp16 + j]);
-        }
-    }
-#endif
-}
-
-void convBlockMR1_FP16(int np, const char* _a, const char* _b, float *c, const float _bias, bool init_c,
-                            const float minval, const float maxval, bool ifMinMaxAct, const int width, const int convNR_FP16)
-{
-    CV_Assert(convNR_FP16 == 24); // CONV_NR_FP16 = 24
-    const float16_t* a = (const float16_t*)_a;
-    const float16_t* b = (const float16_t*)_b;
-
-    const float16_t bias = (float16_t)_bias;
-
-    float16x8_t c0 = vdupq_n_f16(bias), c1 = c0, c2 = c0;
-
-    if (width > 16)
-    {
-        for (int p = 0; p < np; p++, a++, b += convNR_FP16)
-        {
-            float16x8_t a0= vdupq_n_f16(a[0]);
-            float16x8_t b0 = vld1q_f16(b), b1 = vld1q_f16(b + 8), b2 = vld1q_f16(b + 16);
-
-            c0 = vfmaq_f16(c0, a0, b0);
-            c1 = vfmaq_f16(c1, a0, b1);
-            c2 = vfmaq_f16(c2, a0, b2);
-        }
-    }
-    else if (width > 8)
-    {
-        for (int p = 0; p < np; p++, a++, b += convNR_FP16)
-        {
-            float16x8_t a0= vdupq_n_f16(a[0]);
-            float16x8_t b0 = vld1q_f16(b), b1 = vld1q_f16(b + 8);
-
-            c0 = vfmaq_f16(c0, a0, b0);
-            c1 = vfmaq_f16(c1, a0, b1);
-        }
-    }
-    else
-    {
-        for (int p = 0; p < np; p++, a++, b += convNR_FP16)
-        {
-            float16x8_t a0= vdupq_n_f16(a[0]);
-            float16x8_t b0 = vld1q_f16(b);
-
-            c0 = vfmaq_f16(c0, a0, b0);
-        }
-    }
-
-    // convert FP 16 to FP 32.
-    float32x4_t c00 = vcvt_f32_f16(vget_low_f16(c0));
-    float32x4_t c01 = vcvt_f32_f16(vget_high_f16(c0));
-    float32x4_t c10 = vcvt_f32_f16(vget_low_f16(c1));
-    float32x4_t c11 = vcvt_f32_f16(vget_high_f16(c1));
-    float32x4_t c20 = vcvt_f32_f16(vget_low_f16(c2));
-    float32x4_t c21 = vcvt_f32_f16(vget_high_f16(c2));
-
-    if (init_c)
-    {
-        c00 += vld1q_f32(c);
-        c01 += vld1q_f32(c + 4);
-        c10 += vld1q_f32(c + 8);
-        c11 += vld1q_f32(c + 12);
-        c20 += vld1q_f32(c + 16);
-        c21 += vld1q_f32(c + 20);
-    }
-
-    if (ifMinMaxAct)
-    {
-        float32x4_t v_minval = vdupq_n_f32(minval), v_maxval = vdupq_n_f32(maxval);
-
-        c00 = vminq_f32(vmaxq_f32(c00, v_minval), v_maxval);
-        c01 = vminq_f32(vmaxq_f32(c01, v_minval), v_maxval);
-        c10 = vminq_f32(vmaxq_f32(c10, v_minval), v_maxval);
-        c11 = vminq_f32(vmaxq_f32(c11, v_minval), v_maxval);
-        c20 = vminq_f32(vmaxq_f32(c20, v_minval), v_maxval);
-        c21 = vminq_f32(vmaxq_f32(c21, v_minval), v_maxval);
-    }
-
-    vst1q_f32(c, c00);
-    vst1q_f32(c + 4, c01);
-    vst1q_f32(c + 8, c10);
-    vst1q_f32(c + 12, c11);
-    vst1q_f32(c + 16, c20);
-    vst1q_f32(c + 20, c21);
-}
-#endif
-
-#endif
-}
 }} // namespace cv::dnn
Index: opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_winograd_f63.simd.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_winograd_f63.simd.hpp b/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_winograd_f63.simd.hpp
--- a/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_winograd_f63.simd.hpp	(revision 5199850039ad23f1f0e6cccea5061a9fea5efca6)
+++ b/opencv-src/opencv/modules/dnn/src/layers/cpu_kernels/conv_winograd_f63.simd.hpp	(date 1701848687871)
@@ -409,478 +409,5 @@
 
 CV_CPU_OPTIMIZATION_NAMESPACE_END
 
-// NEON code work around.
-namespace opt_NEON
-{
-
-#if !defined(CV_CPU_OPTIMIZATION_DECLARATIONS_ONLY) && CV_NEON && CV_NEON_AARCH64
-/* Accumulate */
-void winofunc_accum_f32(const float* inwptr, const float* wptr, float* outbuf, int Cg, int iblock,
-                        const int winoIblock, const int winoKblock, const int winoAtomF32, const int winoNatomF32);
-
-/*Input transform*/
-void winofunc_BtXB_8x8_f32(const float* inptr, int inpstep,
-                            float* outptr, int Cg, const int winoIblock, const int winoAtomF32);
-
-/*Output transform*/
-void winofunc_AtXA_8x8_f32(const float* inptr, int inpstep,
-                            float* bpptr, int bpstep, float* outptr, int outstep,
-                            float bias, float minval, float maxval, bool ifMinMaxAct);
-
-void winofunc_accum_f32(const float* inwptr, const float* wptr, float* outbuf, int Cg, int iblock,
-                            const int winoIblock, const int winoKblock, const int winoAtomF32, const int winoNatomF32)
-{
-    CV_Assert(winoIblock == 6 && winoKblock == 4 && winoAtomF32 == 4);
-    if (iblock > 3)
-    {
-        for (int atom_id = 0; atom_id < winoNatomF32; atom_id++,
-                outbuf += winoAtomF32)
-        {
-            float32x4_t s00 = vdupq_n_f32(0.f), s01 = s00, s02 = s00, s03 = s00, s04 = s00, s05 = s00;
-            float32x4_t s10 = vdupq_n_f32(0.f), s11 = s00, s12 = s00, s13 = s00, s14 = s00, s15 = s00;
-            float32x4_t s20 = vdupq_n_f32(0.f), s21 = s00, s22 = s00, s23 = s00, s24 = s00, s25 = s00;
-            float32x4_t s30 = vdupq_n_f32(0.f), s31 = s00, s32 = s00, s33 = s00, s34 = s00, s35 = s00;
-            for (int c = 0; c < Cg; c++, inwptr += winoIblock*winoAtomF32,
-                                         wptr += winoKblock*winoAtomF32) {
-                float32x4_t w0 = vld1q_f32(wptr), w1 = vld1q_f32(wptr + 4);
-                float32x4_t w2 = vld1q_f32(wptr + 8), w3 = vld1q_f32(wptr + 12);
-                float32x4_t x0, x1;
-                x0 = vld1q_f32(inwptr);
-                x1 = vld1q_f32(inwptr + 4);
-                s00 = vfmaq_f32(s00, w0, x0);
-                s01 = vfmaq_f32(s01, w0, x1);
-                s10 = vfmaq_f32(s10, w1, x0);
-                s11 = vfmaq_f32(s11, w1, x1);
-                s20 = vfmaq_f32(s20, w2, x0);
-                s21 = vfmaq_f32(s21, w2, x1);
-                s30 = vfmaq_f32(s30, w3, x0);
-                s31 = vfmaq_f32(s31, w3, x1);
-                x0 = vld1q_f32(inwptr + 8);
-                x1 = vld1q_f32(inwptr + 12);
-                s02 = vfmaq_f32(s02, w0, x0);
-                s03 = vfmaq_f32(s03, w0, x1);
-                s12 = vfmaq_f32(s12, w1, x0);
-                s13 = vfmaq_f32(s13, w1, x1);
-                s22 = vfmaq_f32(s22, w2, x0);
-                s23 = vfmaq_f32(s23, w2, x1);
-                s32 = vfmaq_f32(s32, w3, x0);
-                s33 = vfmaq_f32(s33, w3, x1);
-                x0 = vld1q_f32(inwptr + 16);
-                x1 = vld1q_f32(inwptr + 20);
-                s04 = vfmaq_f32(s04, w0, x0);
-                s05 = vfmaq_f32(s05, w0, x1);
-                s14 = vfmaq_f32(s14, w1, x0);
-                s15 = vfmaq_f32(s15, w1, x1);
-                s24 = vfmaq_f32(s24, w2, x0);
-                s25 = vfmaq_f32(s25, w2, x1);
-                s34 = vfmaq_f32(s34, w3, x0);
-                s35 = vfmaq_f32(s35, w3, x1);
-            }
-
-            vst1q_f32(outbuf, s00);
-            vst1q_f32(outbuf + 1*64, s01);
-            vst1q_f32(outbuf + 2*64, s02);
-            vst1q_f32(outbuf + 3*64, s03);
-            vst1q_f32(outbuf + 4*64, s04);
-            vst1q_f32(outbuf + 5*64, s05);
-
-            vst1q_f32(outbuf + 6*64, s10);
-            vst1q_f32(outbuf + 7*64, s11);
-            vst1q_f32(outbuf + 8*64, s12);
-            vst1q_f32(outbuf + 9*64, s13);
-            vst1q_f32(outbuf + 10*64, s14);
-            vst1q_f32(outbuf + 11*64, s15);
-
-            vst1q_f32(outbuf + 12*64, s20);
-            vst1q_f32(outbuf + 13*64, s21);
-            vst1q_f32(outbuf + 14*64, s22);
-            vst1q_f32(outbuf + 15*64, s23);
-            vst1q_f32(outbuf + 16*64, s24);
-            vst1q_f32(outbuf + 17*64, s25);
-
-            vst1q_f32(outbuf + 18*64, s30);
-            vst1q_f32(outbuf + 19*64, s31);
-            vst1q_f32(outbuf + 20*64, s32);
-            vst1q_f32(outbuf + 21*64, s33);
-            vst1q_f32(outbuf + 22*64, s34);
-            vst1q_f32(outbuf + 23*64, s35);
-        }
-    }
-    else
-    {
-        for (int atom_id = 0; atom_id < winoNatomF32; atom_id++,
-                outbuf += winoAtomF32)
-        {
-            float32x4_t s00 = vdupq_n_f32(0.f), s01 = s00, s02 = s00;
-            float32x4_t s10 = vdupq_n_f32(0.f), s11 = s00, s12 = s00;
-            float32x4_t s20 = vdupq_n_f32(0.f), s21 = s00, s22 = s00;
-            float32x4_t s30 = vdupq_n_f32(0.f), s31 = s00, s32 = s00;
-            for (int c = 0; c < Cg; c++, inwptr += winoIblock*winoAtomF32,
-                                         wptr += winoKblock*winoAtomF32) {
-                float32x4_t w0 = vld1q_f32(wptr), w1 = vld1q_f32(wptr + 4);
-                float32x4_t w2 = vld1q_f32(wptr + 8), w3 = vld1q_f32(wptr + 12);
-                float32x4_t x0, x1, x2;
-                x0 = vld1q_f32(inwptr);
-                x1 = vld1q_f32(inwptr + 4);
-                x2 = vld1q_f32(inwptr + 8);
-                s00 = vfmaq_f32(s00, w0, x0);
-                s01 = vfmaq_f32(s01, w0, x1);
-                s02 = vfmaq_f32(s02, w0, x2);
-                s10 = vfmaq_f32(s10, w1, x0);
-                s11 = vfmaq_f32(s11, w1, x1);
-                s12 = vfmaq_f32(s12, w1, x2);
-                s20 = vfmaq_f32(s20, w2, x0);
-                s21 = vfmaq_f32(s21, w2, x1);
-                s22 = vfmaq_f32(s22, w2, x2);
-                s30 = vfmaq_f32(s30, w3, x0);
-                s31 = vfmaq_f32(s31, w3, x1);
-                s32 = vfmaq_f32(s32, w3, x2);
-            }
-
-            vst1q_f32(outbuf, s00);
-            vst1q_f32(outbuf + 1*64, s01);
-            vst1q_f32(outbuf + 2*64, s02);
-            vst1q_f32(outbuf + 6*64, s10);
-            vst1q_f32(outbuf + 7*64, s11);
-            vst1q_f32(outbuf + 8*64, s12);
-            vst1q_f32(outbuf + 12*64, s20);
-            vst1q_f32(outbuf + 13*64, s21);
-            vst1q_f32(outbuf + 14*64, s22);
-            vst1q_f32(outbuf + 18*64, s30);
-            vst1q_f32(outbuf + 19*64, s31);
-            vst1q_f32(outbuf + 20*64, s32);
-        }
-    }
-}
-
-#define T4x4(a, b, c, d, tr0, tr1) \
-    tr0 = vtrnq_f32(a, b); \
-    tr1 = vtrnq_f32(c, d); \
-    a = vcombine_f32(vget_low_f32(tr0.val[0]), vget_low_f32(tr1.val[0])); \
-    b = vcombine_f32(vget_low_f32(tr0.val[1]), vget_low_f32(tr1.val[1])); \
-    c = vcombine_f32(vget_high_f32(tr0.val[0]), vget_high_f32(tr1.val[0])); \
-    d = vcombine_f32(vget_high_f32(tr0.val[1]), vget_high_f32(tr1.val[1]))
-
-/*Input transform*/
-void winofunc_BtXB_8x8_f32(const float* inptr, int inpstep,
-                          float* outptr, int Cg, const int winoIblock, const int winoAtomF32)
-{
-    float32x4_t x00 = vld1q_f32(inptr), x01 = vld1q_f32(inptr + 4);
-    float32x4_t x10 = vld1q_f32(inptr + inpstep), x11 = vld1q_f32(inptr + inpstep + 4);
-    float32x4_t x20 = vld1q_f32(inptr + inpstep*2), x21 = vld1q_f32(inptr + inpstep*2 + 4);
-    float32x4_t x30 = vld1q_f32(inptr + inpstep*3), x31 = vld1q_f32(inptr + inpstep*3 + 4);
-    float32x4_t x40 = vld1q_f32(inptr + inpstep*4), x41 = vld1q_f32(inptr + inpstep*4 + 4);
-    float32x4_t x50 = vld1q_f32(inptr + inpstep*5), x51 = vld1q_f32(inptr + inpstep*5 + 4);
-    float32x4_t x60 = vld1q_f32(inptr + inpstep*6), x61 = vld1q_f32(inptr + inpstep*6 + 4);
-    float32x4_t x70 = vld1q_f32(inptr + inpstep*7), x71 = vld1q_f32(inptr + inpstep*7 + 4);
-
-    float32x4_t z00, z01, z10, z11, z20, z21, z30, z31, z40, z41, z50, z51, z60, z61, z70, z71;
-
-    {
-        /* Y[0] = [1.f, 0.f, -5.25f, 0.f, 5.25f, 0.f, -1.f, 0.f]*X */
-        /* Y[7] = [0.f, -1.f, 0.f, 5.25f, 0.f, -5.25f, 0.f, 1.f]*X */
-        float32x4_t q5_25 = vdupq_n_f32(5.25f), t00, t01, t10, t11;
-        t00 = vsubq_f32(x40, x20);
-        t01 = vsubq_f32(x41, x21);
-        t10 = vsubq_f32(x30, x50);
-        t11 = vsubq_f32(x31, x51);
-        float32x4_t y00 = vfmaq_f32(vsubq_f32(x00, x60), t00, q5_25);
-        float32x4_t y01 = vfmaq_f32(vsubq_f32(x01, x61), t01, q5_25);
-        float32x4_t y70 = vfmaq_f32(vsubq_f32(x70, x10), t10, q5_25);
-        float32x4_t y71 = vfmaq_f32(vsubq_f32(x71, x11), t11, q5_25);
-
-        /* Y[1] = [0.f, 1.f, 1.f, -4.25f, -4.25f, 1.f, 1.f, 0.f]*X */
-        /* Y[2] = [0.f, -1.f, 1.f, 4.25f, -4.25f, -1.f, 1.f, 0.f]*X */
-        float32x4_t qm4_25 = vdupq_n_f32(-4.25f);
-        t00 = vfmaq_f32(vaddq_f32(x10, x50), x30, qm4_25);
-        t01 = vfmaq_f32(vaddq_f32(x11, x51), x31, qm4_25);
-        t10 = vfmaq_f32(vaddq_f32(x20, x60), x40, qm4_25);
-        t11 = vfmaq_f32(vaddq_f32(x21, x61), x41, qm4_25);
-
-        float32x4_t y10 = vaddq_f32(t00, t10), y11 = vaddq_f32(t01, t11);
-        float32x4_t y20 = vsubq_f32(t10, t00), y21 = vsubq_f32(t11, t01);
-
-        /* Y[3] = [0.f, 0.5f, 0.25f, -2.5f, -1.25f, 2.f, 1.f, 0.f]*X */
-        /* Y[4] = [0.f, -0.5f, 0.25f, 2.5f, -1.25f, -2.f, 1.f, 0.f]*X */
-        float32x4_t q0_5 = vdupq_n_f32(0.5f), q0_25 = vdupq_n_f32(0.25f);
-        float32x4_t qm2_5 = vdupq_n_f32(-2.5f), qm1_25 = vdupq_n_f32(-1.25f);
-        t00 = vfmaq_f32(vaddq_f32(x50, x50), x10, q0_5);
-        t01 = vfmaq_f32(vaddq_f32(x51, x51), x11, q0_5);
-        t10 = vfmaq_f32(x60, x20, q0_25);
-        t11 = vfmaq_f32(x61, x21, q0_25);
-        t00 = vfmaq_f32(t00, x30, qm2_5);
-        t01 = vfmaq_f32(t01, x31, qm2_5);
-        t10 = vfmaq_f32(t10, x40, qm1_25);
-        t11 = vfmaq_f32(t11, x41, qm1_25);
-
-        float32x4_t y30 = vaddq_f32(t00, t10), y31 = vaddq_f32(t01, t11);
-        float32x4_t y40 = vsubq_f32(t10, t00), y41 = vsubq_f32(t11, t01);
-
-        /* Y[5] = [0.f, 2.f, 4.f, -2.5f, -5.f, 0.5f, 1.f, 0.f]*X */
-        /* Y[6] = [0.f, -2.f, 4.f, 2.5f, -5.f, -0.5f, 1.f, 0.f]*X */
-        float32x4_t q4 = vdupq_n_f32(4.f), qm5 = vdupq_n_f32(-5.f);
-        t00 = vfmaq_f32(vaddq_f32(x10, x10), x50, q0_5);
-        t01 = vfmaq_f32(vaddq_f32(x11, x11), x51, q0_5);
-        t10 = vfmaq_f32(x60, x20, q4);
-        t11 = vfmaq_f32(x61, x21, q4);
-        t00 = vfmaq_f32(t00, x30, qm2_5);
-        t01 = vfmaq_f32(t01, x31, qm2_5);
-        t10 = vfmaq_f32(t10, x40, qm5);
-        t11 = vfmaq_f32(t11, x41, qm5);
-
-        float32x4_t y50 = vaddq_f32(t00, t10), y51 = vaddq_f32(t01, t11);
-        float32x4_t y60 = vsubq_f32(t10, t00), y61 = vsubq_f32(t11, t01);
-
-        /* transpose 8x8 matrix in-place with some renumeration of the elements: */
-        /* Y:              */
-        /*        y00 y01  */
-        /*        y10 y11  */
-        /*        ...      */
-        /*        y70 y71  */
-        /*   Y':           */
-        /*        y00 y40  */
-        /*        y10 y50  */
-        /*        y20 y60  */
-        /*        y30 y70  */
-        /*        y01 y41  */
-        /*        y11 y51  */
-        /*        y21 y61  */
-        /*        y31 y71  */
-        /*    in other words, y40 <-> y01, y50 <-> y11, y60 <-> y21, y70 <-> y31 */
-        float32x4x2_t tr0, tr1;
-
-        T4x4(y00, y10, y20, y30, tr0, tr1);
-        T4x4(y01, y11, y21, y31, tr0, tr1);
-        T4x4(y40, y50, y60, y70, tr0, tr1);
-        T4x4(y41, y51, y61, y71, tr0, tr1);
-
-        /* Z[0] = [1.f, 0.f, -5.25f, 0.f, 5.25f, 0.f, -1.f, 0.f]*Y */
-        /* Z[7] = [0.f, -1.f, 0.f, 5.25f, 0.f, -5.25f, 0.f, 1.f]*Y */
-        t00 = vsubq_f32(y01, y20);
-        t01 = vsubq_f32(y41, y60);
-        t10 = vsubq_f32(y30, y11);
-        t11 = vsubq_f32(y70, y51);
-        z00 = vfmaq_f32(vsubq_f32(y00, y21), t00, q5_25);
-        z01 = vfmaq_f32(vsubq_f32(y40, y61), t01, q5_25);
-        z70 = vfmaq_f32(vsubq_f32(y31, y10), t10, q5_25);
-        z71 = vfmaq_f32(vsubq_f32(y71, y50), t11, q5_25);
-
-        /* Z[1] = [0.f, 1.f, 1.f, -4.25f, -4.25f, 1.f, 1.f, 0.f]*Y */
-        /* Z[2] = [0.f, -1.f, 1.f, 4.25f, -4.25f, -1.f, 1.f, 0.f]*Y */
-        t00 = vfmaq_f32(vaddq_f32(y10, y11), y30, qm4_25);
-        t01 = vfmaq_f32(vaddq_f32(y50, y51), y70, qm4_25);
-        t10 = vfmaq_f32(vaddq_f32(y20, y21), y01, qm4_25);
-        t11 = vfmaq_f32(vaddq_f32(y60, y61), y41, qm4_25);
-
-        z10 = vaddq_f32(t00, t10); z11 = vaddq_f32(t01, t11);
-        z20 = vsubq_f32(t10, t00); z21 = vsubq_f32(t11, t01);
-
-        /* Z[3] = [0.f, 0.5f, 0.25f, -2.5f, -1.25f, 2.f, 1.f, 0.f]*Y */
-        /* Z[4] = [0.f, -0.5f, 0.25f, 2.5f, -1.25f, -2.f, 1.f, 0.f]*Y */
-        t00 = vfmaq_f32(vaddq_f32(y11, y11), y10, q0_5);
-        t01 = vfmaq_f32(vaddq_f32(y51, y51), y50, q0_5);
-        t10 = vfmaq_f32(y21, y20, q0_25);
-        t11 = vfmaq_f32(y61, y60, q0_25);
-        t00 = vfmaq_f32(t00, y30, qm2_5);
-        t01 = vfmaq_f32(t01, y70, qm2_5);
-        t10 = vfmaq_f32(t10, y01, qm1_25);
-        t11 = vfmaq_f32(t11, y41, qm1_25);
-
-        z30 = vaddq_f32(t00, t10); z31 = vaddq_f32(t01, t11);
-        z40 = vsubq_f32(t10, t00); z41 = vsubq_f32(t11, t01);
-
-        /* Z[5] = [0.f, 2.f, 4.f, -2.5f, -5.f, 0.5f, 1.f, 0.f]*Y */
-        /* Z[6] = [0.f, -2.f, 4.f, 2.5f, -5.f, -0.5f, 1.f, 0.f]*Y */
-        t00 = vfmaq_f32(vaddq_f32(y10, y10), y11, q0_5);
-        t01 = vfmaq_f32(vaddq_f32(y50, y50), y51, q0_5);
-        t10 = vfmaq_f32(y21, y20, q4);
-        t11 = vfmaq_f32(y61, y60, q4);
-        t00 = vfmaq_f32(t00, y30, qm2_5);
-        t01 = vfmaq_f32(t01, y70, qm2_5);
-        t10 = vfmaq_f32(t10, y01, qm5);
-        t11 = vfmaq_f32(t11, y41, qm5);
-
-        z50 = vaddq_f32(t00, t10); z51 = vaddq_f32(t01, t11);
-        z60 = vsubq_f32(t10, t00); z61 = vsubq_f32(t11, t01);
-    }
-
-    const int outstep = winoIblock*winoAtomF32*Cg;
-
-    vst1q_f32(outptr, z00);
-    vst1q_f32(outptr + outstep, z01);
-    vst1q_f32(outptr + outstep*2, z10);
-    vst1q_f32(outptr + outstep*3, z11);
-    vst1q_f32(outptr + outstep*4, z20);
-    vst1q_f32(outptr + outstep*5, z21);
-    vst1q_f32(outptr + outstep*6, z30);
-    vst1q_f32(outptr + outstep*7, z31);
-    vst1q_f32(outptr + outstep*8, z40);
-    vst1q_f32(outptr + outstep*9, z41);
-    vst1q_f32(outptr + outstep*10, z50);
-    vst1q_f32(outptr + outstep*11, z51);
-    vst1q_f32(outptr + outstep*12, z60);
-    vst1q_f32(outptr + outstep*13, z61);
-    vst1q_f32(outptr + outstep*14, z70);
-    vst1q_f32(outptr + outstep*15, z71);
-}
-
-/*Output transform*/
-void winofunc_AtXA_8x8_f32(const float* inptr, int inpstep,
-                          float* bpptr, int bpstep, float* outptr, int outstep,
-                          float bias, float minval, float maxval, bool ifMinMaxAct)
-{
-    float32x4_t x00 = vld1q_f32(inptr), x01 = vld1q_f32(inptr + 4);
-    float32x4_t x10 = vld1q_f32(inptr + inpstep), x11 = vld1q_f32(inptr + inpstep + 4);
-    float32x4_t x20 = vld1q_f32(inptr + inpstep*2), x21 = vld1q_f32(inptr + inpstep*2 + 4);
-    float32x4_t x30 = vld1q_f32(inptr + inpstep*3), x31 = vld1q_f32(inptr + inpstep*3 + 4);
-    float32x4_t x40 = vld1q_f32(inptr + inpstep*4), x41 = vld1q_f32(inptr + inpstep*4 + 4);
-    float32x4_t x50 = vld1q_f32(inptr + inpstep*5), x51 = vld1q_f32(inptr + inpstep*5 + 4);
-    float32x4_t x60 = vld1q_f32(inptr + inpstep*6), x61 = vld1q_f32(inptr + inpstep*6 + 4);
-    float32x4_t x70 = vld1q_f32(inptr + inpstep*7), x71 = vld1q_f32(inptr + inpstep*7 + 4);
-    float32x4_t z00, z01, z10, z11, z20, z21, z30, z31, z40, z41, z50, z51;
-
-    {
-        float32x4_t s12_0, s12_1, s34_0, s34_1, s56_0, s56_1;
-        s12_0 = vaddq_f32(x10, x20); s12_1 = vaddq_f32(x11, x21);
-        s34_0 = vaddq_f32(x30, x40); s34_1 = vaddq_f32(x31, x41);
-        s56_0 = vaddq_f32(x50, x60); s56_1 = vaddq_f32(x51, x61);
-
-        float32x4_t y00 = vaddq_f32(vaddq_f32(vaddq_f32(x00, s12_0), s34_0), s56_0);
-        float32x4_t y01 = vaddq_f32(vaddq_f32(vaddq_f32(x01, s12_1), s34_1), s56_1);
-        float32x4_t y20 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 4.0f), s56_0, 0.25f);
-        float32x4_t y21 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 4.0f), s56_1, 0.25f);
-        float32x4_t y40 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 16.0f), s56_0, 1.f/16);
-        float32x4_t y41 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 16.0f), s56_1, 1.f/16);
-
-        s12_0 = vsubq_f32(x10, x20); s12_1 = vsubq_f32(x11, x21);
-        s34_0 = vsubq_f32(x30, x40); s34_1 = vsubq_f32(x31, x41);
-        s56_0 = vsubq_f32(x50, x60); s56_1 = vsubq_f32(x51, x61);
-
-        float32x4_t y50 = vfmaq_n_f32(vfmaq_n_f32(vaddq_f32(x70, s12_0),
-                                      s34_0, 32.f), s56_0, 1.f/32);
-        float32x4_t y51 = vfmaq_n_f32(vfmaq_n_f32(vaddq_f32(x71, s12_1),
-                                      s34_1, 32.f), s56_1, 1.f/32);
-        float32x4_t y10 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 2.0f), s56_0, 0.5f);
-        float32x4_t y11 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 2.0f), s56_1, 0.5f);
-        float32x4_t y30 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 8.0f), s56_0, 0.125f);
-        float32x4_t y31 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 8.0f), s56_1, 0.125f);
-        float32x4_t y60 = vdupq_n_f32(0.f), y61 = y60, y70 = y60, y71 = y60;
-
-        /* transpose 8x8 matrix in-place with some renumeration of the elements: */
-        /*  Y: */
-        /*        y00 y01 */
-        /*        y10 y11 */
-        /*        ... */
-        /*        y50 y51 */
-        /*        0   0 */
-        /*        0   0 */
-        /*   Y': */
-        /*        y00 y40 */
-        /*        y10 y50 */
-        /*        y20 y60 */
-        /*        y30 y70 */
-        /*        y01 y41 */
-        /*        y11 y51 */
-        /*        y21 y61 */
-        /*        y31 y71 */
-        /*    in other words, y40 <-> y01, y50 <-> y11, y60 <-> y21, y70 <-> y31 */
-        float32x4x2_t tr0, tr1;
-
-        T4x4(y00, y10, y20, y30, tr0, tr1);
-        T4x4(y01, y11, y21, y31, tr0, tr1);
-        T4x4(y40, y50, y60, y70, tr0, tr1);
-        T4x4(y41, y51, y61, y71, tr0, tr1);
-
-        s12_0 = vaddq_f32(y10, y20); s12_1 = vaddq_f32(y50, y60);
-        s34_0 = vaddq_f32(y30, y01); s34_1 = vaddq_f32(y70, y41);
-        s56_0 = vaddq_f32(y11, y21); s56_1 = vaddq_f32(y51, y61);
-
-        z00 = vaddq_f32(vaddq_f32(vaddq_f32(y00, s12_0), s34_0), s56_0);
-        z01 = vaddq_f32(vaddq_f32(vaddq_f32(y40, s12_1), s34_1), s56_1);
-        z20 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 4.0f), s56_0, 0.25f);
-        z21 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 4.0f), s56_1, 0.25f);
-        z40 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 16.0f), s56_0, 1.f/16);
-        z41 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 16.0f), s56_1, 1.f/16);
-
-        s12_0 = vsubq_f32(y10, y20); s12_1 = vsubq_f32(y50, y60);
-        s34_0 = vsubq_f32(y30, y01); s34_1 = vsubq_f32(y70, y41);
-        s56_0 = vsubq_f32(y11, y21); s56_1 = vsubq_f32(y51, y61);
-
-        z50 = vfmaq_n_f32(vfmaq_n_f32(vaddq_f32(y31, s12_0),
-                          s34_0, 32.f), s56_0, 1.f/32);
-        z51 = vfmaq_n_f32(vfmaq_n_f32(vaddq_f32(y71, s12_1),
-                          s34_1, 32.f), s56_1, 1.f/32);
-        z10 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 2.0f), s56_0, 0.5f);
-        z11 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 2.0f), s56_1, 0.5f);
-        z30 = vfmaq_n_f32(vfmaq_n_f32(s12_0, s34_0, 8.0f), s56_0, 0.125f);
-        z31 = vfmaq_n_f32(vfmaq_n_f32(s12_1, s34_1, 8.0f), s56_1, 0.125f);
-        float32x4_t vbias = vdupq_n_f32(bias);
-
-        z00 = vaddq_f32(z00, vbias);
-        z01 = vaddq_f32(z01, vbias);
-        z10 = vaddq_f32(z10, vbias);
-        z11 = vaddq_f32(z11, vbias);
-        z20 = vaddq_f32(z20, vbias);
-        z21 = vaddq_f32(z21, vbias);
-        z30 = vaddq_f32(z30, vbias);
-        z31 = vaddq_f32(z31, vbias);
-        z40 = vaddq_f32(z40, vbias);
-        z41 = vaddq_f32(z41, vbias);
-        z50 = vaddq_f32(z50, vbias);
-        z51 = vaddq_f32(z51, vbias);
-    }
-
-    if (bpptr)
-    {
-        float32x2_t zhalf = vdup_n_f32(0.f);
-        z00 = vaddq_f32(z00, vld1q_f32(bpptr));
-        z01 = vaddq_f32(z01, vcombine_f32(vld1_f32(bpptr + 4), zhalf));
-        z10 = vaddq_f32(z10, vld1q_f32(bpptr + bpstep));
-        z11 = vaddq_f32(z11, vcombine_f32(vld1_f32(bpptr + bpstep + 4), zhalf));
-        z20 = vaddq_f32(z20, vld1q_f32(bpptr + bpstep*2));
-        z21 = vaddq_f32(z21, vcombine_f32(vld1_f32(bpptr + bpstep*2 + 4), zhalf));
-        z30 = vaddq_f32(z30, vld1q_f32(bpptr + bpstep*3));
-        z31 = vaddq_f32(z31, vcombine_f32(vld1_f32(bpptr + bpstep*3 + 4), zhalf));
-        z40 = vaddq_f32(z40, vld1q_f32(bpptr + bpstep*4));
-        z41 = vaddq_f32(z41, vcombine_f32(vld1_f32(bpptr + bpstep*4 + 4), zhalf));
-        z50 = vaddq_f32(z50, vld1q_f32(bpptr + bpstep*5));
-        z51 = vaddq_f32(z51, vcombine_f32(vld1_f32(bpptr + bpstep*5 + 4), zhalf));
-    }
-
-    if (ifMinMaxAct)
-    {
-        float32x4_t vmax = vdupq_n_f32(maxval);
-        float32x4_t vmin = vdupq_n_f32(minval);
-
-        z00 = vminq_f32(vmaxq_f32(z00, vmin), vmax);
-        z01 = vminq_f32(vmaxq_f32(z01, vmin), vmax);
-        z10 = vminq_f32(vmaxq_f32(z10, vmin), vmax);
-        z11 = vminq_f32(vmaxq_f32(z11, vmin), vmax);
-        z20 = vminq_f32(vmaxq_f32(z20, vmin), vmax);
-        z21 = vminq_f32(vmaxq_f32(z21, vmin), vmax);
-        z30 = vminq_f32(vmaxq_f32(z30, vmin), vmax);
-        z31 = vminq_f32(vmaxq_f32(z31, vmin), vmax);
-        z40 = vminq_f32(vmaxq_f32(z40, vmin), vmax);
-        z41 = vminq_f32(vmaxq_f32(z41, vmin), vmax);
-        z50 = vminq_f32(vmaxq_f32(z50, vmin), vmax);
-        z51 = vminq_f32(vmaxq_f32(z51, vmin), vmax);
-    }
-
-    vst1q_f32(outptr, z00);
-    vst1_f32(outptr + 4, vget_low_f32(z01));
-    vst1q_f32(outptr + outstep, z10);
-    vst1_f32(outptr + outstep + 4, vget_low_f32(z11));
-    vst1q_f32(outptr + outstep*2, z20);
-    vst1_f32(outptr + outstep*2 + 4, vget_low_f32(z21));
-    vst1q_f32(outptr + outstep*3, z30);
-    vst1_f32(outptr + outstep*3 + 4, vget_low_f32(z31));
-    vst1q_f32(outptr + outstep*4, z40);
-    vst1_f32(outptr + outstep*4 + 4, vget_low_f32(z41));
-    vst1q_f32(outptr + outstep*5, z50);
-    vst1_f32(outptr + outstep*5 + 4, vget_low_f32(z51));
-}
-
-#endif
-}
 
 }} // namespace
Index: rdkit-src/rdkit/Code/ML/Cluster/Murtagh/f2c.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/ML/Cluster/Murtagh/f2c.h b/rdkit-src/rdkit/Code/ML/Cluster/Murtagh/f2c.h
--- a/rdkit-src/rdkit/Code/ML/Cluster/Murtagh/f2c.h	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/Code/ML/Cluster/Murtagh/f2c.h	(date 1701849536985)
@@ -4,7 +4,6 @@
 
         - From The Shogakukan DICTIONARY OF NEW ENGLISH (Second edition) */
 
-#include <RDGeneral/export.h>
 #ifndef F2C_INCLUDE
 #define F2C_INCLUDE
 
Index: indigo-src/indigo/api/c/indigo/src/indigo_io.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_io.h b/indigo-src/indigo/api/c/indigo/src/indigo_io.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_io.h	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_io.h	(date 1701847510199)
@@ -27,7 +27,7 @@
 #pragma warning(disable : 4251)
 #endif
 
-class DLLEXPORT IndigoScanner : public IndigoObject
+class INDIGO_EXPORT IndigoScanner : public IndigoObject
 {
 public:
     IndigoScanner(Scanner* scanner);
@@ -44,7 +44,7 @@
     Array<char> _buf;
 };
 
-class DLLEXPORT IndigoOutput : public IndigoObject
+class INDIGO_EXPORT IndigoOutput : public IndigoObject
 {
 public:
     IndigoOutput();
Index: openbabel-src/openbabel/include/openbabel/typer.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/typer.h b/openbabel-src/openbabel/include/openbabel/typer.h
--- a/openbabel-src/openbabel/include/openbabel/typer.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/typer.h	(date 1696647929171)
@@ -67,7 +67,7 @@
 #endif
 //! Global OBAtomTyper for marking internal valence, hybridization,
 //!  and atom types (for internal and external use)
-THREAD_LOCAL OB_EXTERN OBAtomTyper      atomtyper;
+THREAD_LOCAL extern OBAtomTyper      atomtyper;
 
 // class introduction in typer.cpp
 class OBAPI OBAromaticTyper
@@ -81,7 +81,7 @@
 };
 
 //! Global OBAromaticTyper for detecting aromatic atoms and bonds
-THREAD_LOCAL OB_EXTERN OBAromaticTyper  aromtyper;
+THREAD_LOCAL extern OBAromaticTyper  aromtyper;
 
 // class introduction in typer.cpp
 class OBAPI OBRingTyper : public OBGlobalDataBase
Index: indigo-src/indigo/api/c/indigo/src/indigo_savers.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_savers.h b/indigo-src/indigo/api/c/indigo/src/indigo_savers.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_savers.h	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_savers.h	(date 1701847510203)
@@ -26,7 +26,7 @@
 
 #include "indigo_internal.h"
 
-class DLLEXPORT IndigoSaver : public IndigoObject
+class INDIGO_EXPORT IndigoSaver : public IndigoObject
 {
 public:
     IndigoSaver(Output& output);
Index: indigo-src/indigo/api/c/indigo/src/indigo_properties.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_properties.h b/indigo-src/indigo/api/c/indigo/src/indigo_properties.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_properties.h	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_properties.h	(date 1701847510202)
@@ -25,7 +25,7 @@
     class PropertiesMap;
 }
 
-class DLLEXPORT IndigoProperty : public IndigoObject
+class INDIGO_EXPORT IndigoProperty : public IndigoObject
 {
 public:
     IndigoProperty(indigo::PropertiesMap& props, int idx);
Index: indigo-src/indigo/api/c/indigo/src/indigo_product_enumerator.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_product_enumerator.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_product_enumerator.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_product_enumerator.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_product_enumerator.cpp	(date 1701847510201)
@@ -66,7 +66,7 @@
     indices.copy(monomers_indices);
 }
 
-CEXPORT int indigoReactionProductEnumerate(int reaction, int monomers)
+int indigoReactionProductEnumerate(int reaction, int monomers)
 {
     INDIGO_BEGIN
     {
@@ -155,7 +155,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoTransform(int reaction, int monomers)
+int indigoTransform(int reaction, int monomers)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_match.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_match.h b/indigo-src/indigo/api/c/indigo/src/indigo_match.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_match.h	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_match.h	(date 1701847510200)
@@ -101,7 +101,7 @@
 };
 
 // Matcher class for matching queries on a specified target molecule
-class DLLEXPORT IndigoMoleculeSubstructureMatcher : public IndigoObject
+class INDIGO_EXPORT IndigoMoleculeSubstructureMatcher : public IndigoObject
 {
 public:
     enum
@@ -145,7 +145,7 @@
     MoleculeAtomNeighbourhoodCounters _nei_counters, _nei_counters_h_unfolded;
 };
 
-class DLLEXPORT IndigoReactionSubstructureMatcher : public IndigoObject
+class INDIGO_EXPORT IndigoReactionSubstructureMatcher : public IndigoObject
 {
 public:
     IndigoReactionSubstructureMatcher(Reaction& target);
@@ -164,8 +164,8 @@
     Array<int> mol_mapping;
 };
 
-DLLEXPORT bool _indigoParseTautomerFlags(const char* flags, IndigoTautomerParams& params);
-DLLEXPORT int _indigoParseExactFlags(const char* flags, bool reaction, float* rms_threshold);
+INDIGO_EXPORT bool _indigoParseTautomerFlags(const char* flags, IndigoTautomerParams& params);
+INDIGO_EXPORT int _indigoParseExactFlags(const char* flags, bool reaction, float* rms_threshold);
 
 #ifdef _WIN32
 #pragma warning(pop)
Index: indigo-src/indigo/api/c/indigo/src/indigo_savers.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_savers.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_savers.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_savers.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_savers.cpp	(date 1701847510202)
@@ -146,7 +146,7 @@
     append(_output, object);
 }
 
-CEXPORT int indigoSdfAppend(int output, int molecule)
+int indigoSdfAppend(int output, int molecule)
 {
     INDIGO_BEGIN
     {
@@ -274,7 +274,7 @@
     append(_output, object);
 }
 
-CEXPORT int indigoSmilesAppend(int output, int item)
+int indigoSmilesAppend(int output, int item)
 {
     INDIGO_BEGIN
     {
@@ -419,7 +419,7 @@
     appendFooter(_output);
 }
 
-CEXPORT int indigoCmlHeader(int output)
+int indigoCmlHeader(int output)
 {
     INDIGO_BEGIN
     {
@@ -430,7 +430,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCmlFooter(int output)
+int indigoCmlFooter(int output)
 {
     INDIGO_BEGIN
     {
@@ -441,7 +441,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCmlAppend(int output, int item)
+int indigoCmlAppend(int output, int item)
 {
     INDIGO_BEGIN
     {
@@ -520,7 +520,7 @@
     appendHeader(_output);
 }
 
-CEXPORT int indigoRdfHeader(int output)
+int indigoRdfHeader(int output)
 {
     INDIGO_BEGIN
     {
@@ -531,7 +531,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRdfAppend(int output, int item)
+int indigoRdfAppend(int output, int item)
 {
     INDIGO_BEGIN
     {
@@ -546,7 +546,7 @@
 //
 // Saving functions
 //
-CEXPORT int indigoCreateSaver(int output, const char* format)
+int indigoCreateSaver(int output, const char* format)
 {
     INDIGO_BEGIN
     {
@@ -556,7 +556,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateFileSaver(const char* filename, const char* format)
+int indigoCreateFileSaver(const char* filename, const char* format)
 {
     INDIGO_BEGIN
     {
@@ -568,7 +568,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveMolfile(int molecule, int output)
+int indigoSaveMolfile(int molecule, int output)
 {
     INDIGO_BEGIN
     {
@@ -581,7 +581,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveJson(int item, int output)
+int indigoSaveJson(int item, int output)
 {
     INDIGO_BEGIN
     {
@@ -610,7 +610,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveCml(int item, int output)
+int indigoSaveCml(int item, int output)
 {
     INDIGO_BEGIN
     {
@@ -643,7 +643,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveMDLCT(int item, int output)
+int indigoSaveMDLCT(int item, int output)
 {
     INDIGO_BEGIN
     {
@@ -671,7 +671,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveRxnfile(int reaction, int output)
+int indigoSaveRxnfile(int reaction, int output)
 {
     INDIGO_BEGIN
     {
@@ -689,7 +689,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAppend(int saver_id, int object)
+int indigoAppend(int saver_id, int object)
 {
     INDIGO_BEGIN
     {
@@ -704,7 +704,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveCdxml(int item, int output)
+int indigoSaveCdxml(int item, int output)
 {
     INDIGO_BEGIN
     {
@@ -748,7 +748,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSaveCdx(int item, int output)
+int indigoSaveCdx(int item, int output)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_molecule.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_molecule.h b/indigo-src/indigo/api/c/indigo/src/indigo_molecule.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_molecule.h	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_molecule.h	(date 1701847510201)
@@ -33,7 +33,7 @@
 #include "molecule/molecule_neighbourhood_counters.h"
 #include "molecule/query_molecule.h"
 
-class DLLEXPORT IndigoBaseMolecule : public IndigoObject
+class INDIGO_EXPORT IndigoBaseMolecule : public IndigoObject
 {
 public:
     explicit IndigoBaseMolecule(int type_);
@@ -52,7 +52,7 @@
     indigo::PropertiesMap _properties;
 };
 
-class DLLEXPORT IndigoQueryMolecule : public IndigoBaseMolecule
+class INDIGO_EXPORT IndigoQueryMolecule : public IndigoBaseMolecule
 {
 public:
     IndigoQueryMolecule();
@@ -80,7 +80,7 @@
     int _nei_counters_edit_revision;
 };
 
-class DLLEXPORT IndigoMolecule : public IndigoBaseMolecule
+class INDIGO_EXPORT IndigoMolecule : public IndigoBaseMolecule
 {
 public:
     IndigoMolecule();
@@ -102,7 +102,7 @@
     Molecule mol;
 };
 
-class DLLEXPORT IndigoAtom : public IndigoObject
+class INDIGO_EXPORT IndigoAtom : public IndigoObject
 {
 public:
     IndigoAtom(BaseMolecule& mol_, int idx_);
@@ -122,7 +122,7 @@
     const char* debugInfo() const override;
 };
 
-class DLLEXPORT IndigoRGroup : public IndigoObject
+class INDIGO_EXPORT IndigoRGroup : public IndigoObject
 {
 public:
     IndigoRGroup();
@@ -136,7 +136,7 @@
     int idx;
 };
 
-class DLLEXPORT IndigoRGroupFragment : public IndigoObject
+class INDIGO_EXPORT IndigoRGroupFragment : public IndigoObject
 {
 public:
     IndigoRGroupFragment(IndigoRGroup& rgp, int idx);
@@ -156,7 +156,7 @@
     int frag_idx;
 };
 
-class DLLEXPORT IndigoBond : public IndigoObject
+class INDIGO_EXPORT IndigoBond : public IndigoObject
 {
 public:
     IndigoBond(BaseMolecule& mol_, int idx_);
Index: indigo-src/indigo/api/c/indigo/src/indigo_reaction.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_reaction.h b/indigo-src/indigo/api/c/indigo/src/indigo_reaction.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_reaction.h	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_reaction.h	(date 1701847510202)
@@ -29,7 +29,7 @@
 #pragma warning(disable : 4251)
 #endif
 
-class DLLEXPORT IndigoBaseReaction : public IndigoObject
+class INDIGO_EXPORT IndigoBaseReaction : public IndigoObject
 {
 public:
     explicit IndigoBaseReaction(int type_);
@@ -59,7 +59,7 @@
     indigo::PropertiesMap _properties;
 };
 
-class DLLEXPORT IndigoReaction : public IndigoBaseReaction
+class INDIGO_EXPORT IndigoReaction : public IndigoBaseReaction
 {
 public:
     IndigoReaction();
@@ -78,7 +78,7 @@
     Reaction rxn;
 };
 
-class DLLEXPORT IndigoQueryReaction : public IndigoBaseReaction
+class INDIGO_EXPORT IndigoQueryReaction : public IndigoBaseReaction
 {
 public:
     IndigoQueryReaction();
Index: indigo-src/indigo/api/c/indigo/src/indigo_scaffold.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_scaffold.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_scaffold.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_scaffold.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_scaffold.cpp	(date 1701847510203)
@@ -31,7 +31,7 @@
 {
 }
 
-CEXPORT int indigoExtractCommonScaffold(int structures, const char* options)
+int indigoExtractCommonScaffold(int structures, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -104,7 +104,7 @@
     return max_scaffold;
 }
 
-CEXPORT int indigoAllScaffolds(int extracted)
+int indigoAllScaffolds(int extracted)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/option_manager.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/option_manager.cpp b/indigo-src/indigo/api/c/indigo/src/option_manager.cpp
--- a/indigo-src/indigo/api/c/indigo/src/option_manager.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/option_manager.cpp	(date 1701847510203)
@@ -29,7 +29,7 @@
     return mgr;
 }
 
-DLLEXPORT sf::safe_shared_hide_obj<IndigoOptionManager>& indigoGetOptionManager(const qword id)
+sf::safe_shared_hide_obj<IndigoOptionManager>& indigoGetOptionManager(const qword id)
 {
     return IndigoOptionManager::getIndigoOptionManager().getLocalCopy(id);
 }
Index: indigo-src/indigo/api/c/indigo/src/indigo_reaction.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_reaction.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_reaction.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_reaction.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_reaction.cpp	(date 1701847510202)
@@ -352,7 +352,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadReaction(int source)
+int indigoLoadReaction(int source)
 {
     INDIGO_BEGIN
     {
@@ -374,7 +374,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadQueryReaction(int source)
+int indigoLoadQueryReaction(int source)
 {
     INDIGO_BEGIN
     {
@@ -395,27 +395,27 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateReactants(int reaction)
+int indigoIterateReactants(int reaction)
 {
     return _indigoIterateReaction(reaction, IndigoReactionIter::REACTANTS);
 }
 
-CEXPORT int indigoIterateProducts(int reaction)
+int indigoIterateProducts(int reaction)
 {
     return _indigoIterateReaction(reaction, IndigoReactionIter::PRODUCTS);
 }
 
-CEXPORT int indigoIterateCatalysts(int reaction)
+int indigoIterateCatalysts(int reaction)
 {
     return _indigoIterateReaction(reaction, IndigoReactionIter::CATALYSTS);
 }
 
-CEXPORT int indigoIterateMolecules(int reaction)
+int indigoIterateMolecules(int reaction)
 {
     return _indigoIterateReaction(reaction, IndigoReactionIter::MOLECULES);
 }
 
-CEXPORT int indigoCreateReaction(void)
+int indigoCreateReaction(void)
 {
     INDIGO_BEGIN
     {
@@ -424,7 +424,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateQueryReaction(void)
+int indigoCreateQueryReaction(void)
 {
     INDIGO_BEGIN
     {
@@ -433,7 +433,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddReactant(int reaction, int molecule)
+int indigoAddReactant(int reaction, int molecule)
 {
     INDIGO_BEGIN
     {
@@ -445,7 +445,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddProduct(int reaction, int molecule)
+int indigoAddProduct(int reaction, int molecule)
 {
     INDIGO_BEGIN
     {
@@ -457,7 +457,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddCatalyst(int reaction, int molecule)
+int indigoAddCatalyst(int reaction, int molecule)
 {
     INDIGO_BEGIN
     {
@@ -469,7 +469,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountReactants(int reaction)
+int indigoCountReactants(int reaction)
 {
     INDIGO_BEGIN
     {
@@ -478,7 +478,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountProducts(int reaction)
+int indigoCountProducts(int reaction)
 {
     INDIGO_BEGIN
     {
@@ -487,7 +487,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountCatalysts(int reaction)
+int indigoCountCatalysts(int reaction)
 {
     INDIGO_BEGIN
     {
@@ -496,7 +496,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountMolecules(int handle)
+int indigoCountMolecules(int handle)
 {
     INDIGO_BEGIN
     {
@@ -510,7 +510,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetMolecule(int reaction, int index)
+int indigoGetMolecule(int reaction, int index)
 {
     INDIGO_BEGIN
     {
@@ -530,7 +530,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoMapMolecule(int handle, int molecule)
+int indigoMapMolecule(int handle, int molecule)
 {
     INDIGO_BEGIN
     {
@@ -596,7 +596,7 @@
     return nmode;
 }
 
-CEXPORT int indigoAutomap(int reaction, const char* mode)
+int indigoAutomap(int reaction, const char* mode)
 {
     INDIGO_BEGIN
     {
@@ -639,7 +639,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetAtomMappingNumber(int reaction, int reaction_atom)
+int indigoGetAtomMappingNumber(int reaction, int reaction_atom)
 {
     INDIGO_BEGIN
     {
@@ -656,7 +656,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetAtomMappingNumber(int reaction, int reaction_atom, int number)
+int indigoSetAtomMappingNumber(int reaction, int reaction_atom, int number)
 {
     INDIGO_BEGIN
     {
@@ -676,7 +676,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetReactingCenter(int reaction, int reaction_bond, int* rc)
+int indigoGetReactingCenter(int reaction, int reaction_bond, int* rc)
 {
     INDIGO_BEGIN
     {
@@ -694,7 +694,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetReactingCenter(int reaction, int reaction_bond, int rc)
+int indigoSetReactingCenter(int reaction, int reaction_bond, int rc)
 {
     INDIGO_BEGIN
     {
@@ -714,7 +714,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearAAM(int reaction)
+int indigoClearAAM(int reaction)
 {
     INDIGO_BEGIN
     {
@@ -725,7 +725,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCorrectReactingCenters(int reaction)
+int indigoCorrectReactingCenters(int reaction)
 {
     INDIGO_BEGIN
     {
@@ -738,7 +738,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadReactionSmarts(int source)
+int indigoLoadReactionSmarts(int source)
 {
     INDIGO_BEGIN
     {
@@ -756,7 +756,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoCanonicalRSmiles(int reaction)
+const char* indigoCanonicalRSmiles(int reaction)
 {
     INDIGO_BEGIN
     {
Index: skia-src/skia/src/core/SkTaskGroup.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/src/core/SkTaskGroup.cpp b/skia-src/skia/src/core/SkTaskGroup.cpp
--- a/skia-src/skia/src/core/SkTaskGroup.cpp	(revision 5f54e9f84cff8c42fd645ec53c1727857bdb12ab)
+++ b/skia-src/skia/src/core/SkTaskGroup.cpp	(date 1701851934715)
@@ -24,7 +24,7 @@
     // TODO: I really thought we had some sort of more clever chunking logic.
     fPending.fetch_add(+N, std::memory_order_relaxed);
     for (int i = 0; i < N; i++) {
-        fExecutor.add([=] {
+        fExecutor.add([=, this] {
             fn(i);
             fPending.fetch_add(-1, std::memory_order_release);
         });
Index: indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.h b/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.h	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_deconvolution.h	(date 1701847510198)
@@ -37,7 +37,7 @@
 class IndigoDeconvolutionElem;
 class IndigoDecompositionMatch;
 
-class DLLEXPORT IndigoDeconvolution : public IndigoObject
+class INDIGO_EXPORT IndigoDeconvolution : public IndigoObject
 {
 private:
     enum
@@ -143,7 +143,7 @@
     ObjArray<IndigoDeconvolutionElem> _deconvolutionElems;
 };
 
-class DLLEXPORT IndigoDeconvolutionElem : public IndigoObject
+class INDIGO_EXPORT IndigoDeconvolutionElem : public IndigoObject
 {
 public:
     IndigoDeconvolutionElem(Molecule& mol);
@@ -169,7 +169,7 @@
     indigo::PropertiesMap _properties;
 };
 
-class DLLEXPORT IndigoDecompositionMatch : public IndigoObject
+class INDIGO_EXPORT IndigoDecompositionMatch : public IndigoObject
 {
 public:
     IndigoDecompositionMatch();
@@ -205,7 +205,7 @@
     bool _completeScaffold;
 };
 
-class DLLEXPORT IndigoDeconvolutionIter : public IndigoObject
+class INDIGO_EXPORT IndigoDeconvolutionIter : public IndigoObject
 {
 public:
     IndigoDeconvolutionIter(ObjArray<IndigoDeconvolutionElem>& items);
@@ -218,7 +218,7 @@
     int _index;
     ObjArray<IndigoDeconvolutionElem>& _items;
 };
-class DLLEXPORT IndigoDecompositionMatchIter : public IndigoObject
+class INDIGO_EXPORT IndigoDecompositionMatchIter : public IndigoObject
 {
 public:
     IndigoDecompositionMatchIter(ObjArray<IndigoDecompositionMatch>& matches);
Index: openbabel-src/openbabel/include/openbabel/obutil.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/obutil.h b/openbabel-src/openbabel/include/openbabel/obutil.h
--- a/openbabel-src/openbabel/include/openbabel/obutil.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/obutil.h	(date 1696647929168)
@@ -24,6 +24,7 @@
 
 #include <string>
 #include <iosfwd>
+#include <fstream>
 
 #if TIME_WITH_SYS_TIME
 #include <sys/time.h>
Index: indigo-src/indigo/api/c/indigo/src/indigo_macros.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_macros.c b/indigo-src/indigo/api/c/indigo/src/indigo_macros.c
--- a/indigo-src/indigo/api/c/indigo/src/indigo_macros.c	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_macros.c	(date 1701847510200)
@@ -19,7 +19,7 @@
 #include "indigo.h"
 
 #define WRAPPER_LOAD_FROM_STRING(name)                                                                                                                         \
-    CEXPORT int name##FromString(const char* string)                                                                                                           \
+    INDIGO_EXPORT int name##FromString(const char* string)                                                                                                           \
     {                                                                                                                                                          \
         int source = indigoReadString(string);                                                                                                                 \
         int result;                                                                                                                                            \
@@ -33,7 +33,7 @@
     }
 
 #define WRAPPER_LOAD_FROM_FILE(name)                                                                                                                           \
-    CEXPORT int name##FromFile(const char* filename)                                                                                                           \
+    INDIGO_EXPORT int name##FromFile(const char* filename)                                                                                                           \
     {                                                                                                                                                          \
         int source = indigoReadFile(filename);                                                                                                                 \
         int result;                                                                                                                                            \
@@ -47,7 +47,7 @@
     }
 
 #define WRAPPER_LOAD_FROM_BUFFER(name)                                                                                                                         \
-    CEXPORT int name##FromBuffer(const char* buf, int size)                                                                                                    \
+    INDIGO_EXPORT int name##FromBuffer(const char* buf, int size)                                                                                                    \
     {                                                                                                                                                          \
         int source = indigoReadBuffer(buf, size);                                                                                                              \
         int result;                                                                                                                                            \
@@ -84,7 +84,7 @@
 WRAPPER_LOAD_FROM_FILE(indigoLoadReactionSmarts)
 WRAPPER_LOAD_FROM_BUFFER(indigoLoadReactionSmarts)
 
-CEXPORT int indigoSaveMolfileToFile(int molecule, const char* filename)
+INDIGO_EXPORT int indigoSaveMolfileToFile(int molecule, const char* filename)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -98,7 +98,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveJsonToFile(int item, const char* filename)
+INDIGO_EXPORT int indigoSaveJsonToFile(int item, const char* filename)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -112,7 +112,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveCmlToFile(int molecule, const char* filename)
+INDIGO_EXPORT int indigoSaveCmlToFile(int molecule, const char* filename)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -126,7 +126,7 @@
     return res;
 }
 
-CEXPORT const char* indigoMolfile(int molecule)
+INDIGO_EXPORT const char* indigoMolfile(int molecule)
 {
     int b = indigoWriteBuffer();
     const char* res;
@@ -142,7 +142,7 @@
     return res;
 }
 
-CEXPORT const char* indigoCdxBase64(int object)
+INDIGO_EXPORT const char* indigoCdxBase64(int object)
 {
     int b = indigoWriteBuffer();
     const char* res;
@@ -158,7 +158,7 @@
     return res;
 }
 
-CEXPORT const char* indigoCml(int molecule)
+INDIGO_EXPORT const char* indigoCml(int molecule)
 {
     int b = indigoWriteBuffer();
     const char* res;
@@ -174,7 +174,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveRxnfileToFile(int reaction, const char* filename)
+INDIGO_EXPORT int indigoSaveRxnfileToFile(int reaction, const char* filename)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -188,7 +188,7 @@
     return res;
 }
 
-CEXPORT const char* indigoRxnfile(int molecule)
+INDIGO_EXPORT const char* indigoRxnfile(int molecule)
 {
     int b = indigoWriteBuffer();
     const char* res;
@@ -204,7 +204,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveCdxmlToFile(int item, const char* filename)
+INDIGO_EXPORT int indigoSaveCdxmlToFile(int item, const char* filename)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -218,7 +218,7 @@
     return res;
 }
 
-CEXPORT int indigoSaveCdxToFile(int item, const char* filename)
+INDIGO_EXPORT int indigoSaveCdxToFile(int item, const char* filename)
 {
     int f = indigoWriteFile(filename);
     int res;
@@ -232,7 +232,7 @@
     return res;
 }
 
-CEXPORT const char* indigoCdxml(int item)
+INDIGO_EXPORT const char* indigoCdxml(int item)
 {
     int b = indigoWriteBuffer();
     const char* res;
Index: indigo-src/indigo/api/c/indigo/src/indigo_mapping.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_mapping.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_mapping.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_mapping.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_mapping.cpp	(date 1701847510200)
@@ -62,7 +62,7 @@
     return res_ptr.release();
 }
 
-CEXPORT int indigoMapAtom(int handle, int atom)
+int indigoMapAtom(int handle, int atom)
 {
     INDIGO_BEGIN
     {
@@ -105,7 +105,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoMapBond(int handle, int bond)
+int indigoMapBond(int handle, int bond)
 {
     INDIGO_BEGIN
     {
@@ -190,7 +190,7 @@
     }
 }
 
-CEXPORT int indigoHighlightedTarget(int item)
+int indigoHighlightedTarget(int item)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_io.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_io.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_io.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_io.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_io.cpp	(date 1701847510199)
@@ -86,7 +86,7 @@
     throw IndigoError("%s is not an output", obj.debugInfo());
 }
 
-CEXPORT int indigoReadFile(const char* filename)
+int indigoReadFile(const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -95,7 +95,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoReadString(const char* str)
+int indigoReadString(const char* str)
 {
     INDIGO_BEGIN
     {
@@ -104,7 +104,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoReadBuffer(const char* buffer, int size)
+int indigoReadBuffer(const char* buffer, int size)
 {
     INDIGO_BEGIN
     {
@@ -113,7 +113,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadString(const char* str)
+int indigoLoadString(const char* str)
 {
     INDIGO_BEGIN
     {
@@ -122,7 +122,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadBuffer(const char* buffer, int size)
+int indigoLoadBuffer(const char* buffer, int size)
 {
     INDIGO_BEGIN
     {
@@ -131,7 +131,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoWriteFile(const char* filename)
+int indigoWriteFile(const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -140,7 +140,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClose(int output)
+int indigoClose(int output)
 {
     INDIGO_BEGIN
     {
@@ -163,7 +163,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoWriteBuffer(void)
+int indigoWriteBuffer(void)
 {
     INDIGO_BEGIN
     {
@@ -172,7 +172,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoToString(int handle)
+const char* indigoToString(int handle)
 {
     INDIGO_BEGIN
     {
@@ -187,7 +187,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoToBase64String(int handle)
+const char* indigoToBase64String(int handle)
 {
     INDIGO_BEGIN
     {
@@ -200,7 +200,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoToBuffer(int handle, char** buf, int* size)
+int indigoToBuffer(int handle, char** buf, int* size)
 {
     INDIGO_BEGIN
     {
Index: skia-src/skia/modules/skcms/skcms.cc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/modules/skcms/skcms.cc b/skia-src/skia/modules/skcms/skcms.cc
--- a/skia-src/skia/modules/skcms/skcms.cc	(revision 5f54e9f84cff8c42fd645ec53c1727857bdb12ab)
+++ b/skia-src/skia/modules/skcms/skcms.cc	(date 1701851934715)
@@ -19,7 +19,7 @@
 #elif defined(__SSE__)
     #include <immintrin.h>
 
-    #if defined(__clang__)
+    #if defined(__clang__) && !defined(__EMSCRIPTEN__)
         // That #include <immintrin.h> is usually enough, but Clang's headers
         // "helpfully" skip including the whole kitchen sink when _MSC_VER is
         // defined, because lots of programs on Windows would include that and
Index: openbabel-src/openbabel/include/openbabel/obmolecformat.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/obmolecformat.h b/openbabel-src/openbabel/include/openbabel/obmolecformat.h
--- a/openbabel-src/openbabel/include/openbabel/obmolecformat.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/obmolecformat.h	(date 1696647929168)
@@ -142,7 +142,7 @@
 #endif
 
 #ifdef _MSC_VER
-  typedef std::tr1::unordered_map<std::string, unsigned> NameIndexType;
+  typedef std::unordered_map<std::string, unsigned> NameIndexType;
 #elif defined(_LIBCPP_VERSION)
   typedef std::unordered_map<std::string, unsigned> NameIndexType;
 #elif (__GNUC__ == 4 && __GNUC_MINOR__ >= 1 && !defined(__APPLE_CC__)) || defined (USE_BOOST)
Index: indigo-src/indigo/api/c/indigo/src/indigo_molecule.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_molecule.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_molecule.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_molecule.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_molecule.cpp	(date 1701847510201)
@@ -470,7 +470,7 @@
     return new IndigoBond(_mol, _idx);
 }
 
-CEXPORT int indigoLoadMolecule(int source)
+int indigoLoadMolecule(int source)
 {
     INDIGO_BEGIN
     {
@@ -501,7 +501,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadQueryMolecule(int source)
+int indigoLoadQueryMolecule(int source)
 {
     INDIGO_BEGIN
     {
@@ -525,7 +525,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadSmarts(int source)
+int indigoLoadSmarts(int source)
 {
     INDIGO_BEGIN
     {
@@ -551,7 +551,7 @@
     return isIn(string, ">>") || startWith(string, "$RXN") || isIn(string, "<reactantList>");
 }
 
-CEXPORT int indigoLoadStructureFromString(const char* string, const char* params)
+int indigoLoadStructureFromString(const char* string, const char* params)
 {
     INDIGO_BEGIN
     {
@@ -604,7 +604,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoLoadStructureFromBuffer(const byte* buff, int bufferSize, const char* params)
+int indigoLoadStructureFromBuffer(const byte* buff, int bufferSize, const char* params)
 {
     BufferScanner scanner(buff, bufferSize);
     Array<char> arr;
@@ -613,7 +613,7 @@
     return indigoLoadStructureFromString(arr.ptr(), params);
 }
 
-CEXPORT int indigoLoadStructureFromFile(const char* filename, const char* params)
+int indigoLoadStructureFromFile(const char* filename, const char* params)
 {
     INDIGO_BEGIN
     {
@@ -741,7 +741,7 @@
     return self.addObject(new IndigoAtomsIter(&self.getObject(molecule).getBaseMolecule(), type));
 }
 
-CEXPORT int indigoIterateAtoms(int molecule)
+int indigoIterateAtoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -788,7 +788,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateBonds(int molecule)
+int indigoIterateBonds(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -835,7 +835,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountAtoms(int molecule)
+int indigoCountAtoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -869,7 +869,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountBonds(int molecule)
+int indigoCountBonds(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -903,7 +903,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountPseudoatoms(int molecule)
+int indigoCountPseudoatoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -919,7 +919,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountRSites(int molecule)
+int indigoCountRSites(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -935,7 +935,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIteratePseudoatoms(int molecule)
+int indigoIteratePseudoatoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -944,7 +944,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateRSites(int molecule)
+int indigoIterateRSites(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -953,7 +953,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateStereocenters(int molecule)
+int indigoIterateStereocenters(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -962,7 +962,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateAlleneCenters(int molecule)
+int indigoIterateAlleneCenters(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -971,7 +971,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoSymbol(int atom)
+const char* indigoSymbol(int atom)
 {
     INDIGO_BEGIN
     {
@@ -984,7 +984,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoIsPseudoatom(int atom)
+int indigoIsPseudoatom(int atom)
 {
     INDIGO_BEGIN
     {
@@ -997,7 +997,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIsRSite(int atom)
+int indigoIsRSite(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1010,7 +1010,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIsTemplateAtom(int atom)
+int indigoIsTemplateAtom(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1023,7 +1023,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSingleAllowedRGroup(int rsite)
+int indigoSingleAllowedRGroup(int rsite)
 {
     INDIGO_BEGIN
     {
@@ -1064,7 +1064,7 @@
 {
 }
 
-CEXPORT int indigoIterateRGroups(int molecule)
+int indigoIterateRGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1179,7 +1179,7 @@
     return new IndigoRGroupFragment(_mol, _rgroup_idx, _frag_idx);
 }
 
-CEXPORT int indigoIterateRGroupFragments(int rgroup)
+int indigoIterateRGroupFragments(int rgroup)
 {
     INDIGO_BEGIN
     {
@@ -1189,7 +1189,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountRGroups(int molecule)
+int indigoCountRGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1241,7 +1241,7 @@
     return rgroup.release();
 }
 
-CEXPORT int indigoCountAttachmentPoints(int rgroup)
+int indigoCountAttachmentPoints(int rgroup)
 {
     INDIGO_BEGIN
     {
@@ -1256,7 +1256,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDegree(int atom)
+int indigoDegree(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1267,7 +1267,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetCharge(int atom, int* charge)
+int indigoGetCharge(int atom, int* charge)
 {
     INDIGO_BEGIN
     {
@@ -1284,7 +1284,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoValence(int atom)
+int indigoValence(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1294,7 +1294,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetHybridization(int atom)
+int indigoGetHybridization(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1305,7 +1305,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCheckValence(int atom)
+int indigoCheckValence(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1321,7 +1321,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetExplicitValence(int atom, int* valence)
+int indigoGetExplicitValence(int atom, int* valence)
 {
     INDIGO_BEGIN
     {
@@ -1338,7 +1338,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetExplicitValence(int atom, int valence)
+int indigoSetExplicitValence(int atom, int valence)
 {
     INDIGO_BEGIN
     {
@@ -1349,7 +1349,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIsotope(int atom)
+int indigoIsotope(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1360,7 +1360,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAtomicNumber(int atom)
+int indigoAtomicNumber(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1377,7 +1377,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetRadicalElectrons(int atom, int* electrons)
+int indigoGetRadicalElectrons(int atom, int* electrons)
 {
     INDIGO_BEGIN
     {
@@ -1429,7 +1429,7 @@
     }
 }
 
-CEXPORT int indigoGetRadical(int atom, int* radical)
+int indigoGetRadical(int atom, int* radical)
 {
     INDIGO_BEGIN
     {
@@ -1447,7 +1447,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetRadical(int atom, int radical)
+int indigoSetRadical(int atom, int radical)
 {
     INDIGO_BEGIN
     {
@@ -1458,7 +1458,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT float* indigoXYZ(int atom)
+float* indigoXYZ(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1475,7 +1475,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoSetXYZ(int atom, float x, float y, float z)
+int indigoSetXYZ(int atom, float x, float y, float z)
 {
     INDIGO_BEGIN
     {
@@ -1489,7 +1489,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoResetCharge(int atom)
+int indigoResetCharge(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1505,7 +1505,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetExplicitValence(int atom)
+int indigoResetExplicitValence(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1521,7 +1521,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetRadical(int atom)
+int indigoResetRadical(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1537,7 +1537,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetIsotope(int atom)
+int indigoResetIsotope(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1553,7 +1553,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetRsite(int atom)
+int indigoResetRsite(int atom)
 {
     INDIGO_BEGIN
     {
@@ -1566,7 +1566,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetAttachmentPoint(int atom, int order)
+int indigoSetAttachmentPoint(int atom, int order)
 {
     INDIGO_BEGIN
     {
@@ -1578,7 +1578,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearAttachmentPoints(int item)
+int indigoClearAttachmentPoints(int item)
 {
     INDIGO_BEGIN
     {
@@ -1589,7 +1589,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRemoveConstraints(int item, const char* str_type)
+int indigoRemoveConstraints(int item, const char* str_type)
 {
     INDIGO_BEGIN
     {
@@ -1613,7 +1613,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddConstraint(int atom, const char* type, const char* value)
+int indigoAddConstraint(int atom, const char* type, const char* value)
 {
     INDIGO_BEGIN
     {
@@ -1632,7 +1632,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddConstraintNot(int atom, const char* type, const char* value)
+int indigoAddConstraintNot(int atom, const char* type, const char* value)
 {
     INDIGO_BEGIN
     {
@@ -1651,7 +1651,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddConstraintOr(int atom, const char* type, const char* value)
+int indigoAddConstraintOr(int atom, const char* type, const char* value)
 {
     INDIGO_BEGIN
     {
@@ -1671,7 +1671,7 @@
 }
 
 /*
-CEXPORT int indigoAddConstraintOrNot(int atom, const char* type, const char* value)
+int indigoAddConstraintOrNot(int atom, const char* type, const char* value)
 {
    INDIGO_BEGIN
    {
@@ -1691,7 +1691,7 @@
 }
  * */
 
-CEXPORT const int* indigoSymmetryClasses(int molecule, int* count_out)
+const int* indigoSymmetryClasses(int molecule, int* count_out)
 {
     INDIGO_BEGIN
     {
@@ -1729,7 +1729,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoLayeredCode(int molecule)
+const char* indigoLayeredCode(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1747,7 +1747,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoCreateSubmolecule(int molecule, int nvertices, int* vertices)
+int indigoCreateSubmolecule(int molecule, int nvertices, int* vertices)
 {
     INDIGO_BEGIN
     {
@@ -1775,7 +1775,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSubmolecule(int molecule, int nvertices, int* vertices)
+int indigoGetSubmolecule(int molecule, int nvertices, int* vertices)
 {
     INDIGO_BEGIN
     {
@@ -1804,7 +1804,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateEdgeSubmolecule(int molecule, int nvertices, int* vertices, int nedges, int* edges)
+int indigoCreateEdgeSubmolecule(int molecule, int nvertices, int* vertices, int nedges, int* edges)
 {
     INDIGO_BEGIN
     {
@@ -1834,7 +1834,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRemoveAtoms(int molecule, int nvertices, int* vertices)
+int indigoRemoveAtoms(int molecule, int nvertices, int* vertices)
 {
     INDIGO_BEGIN
     {
@@ -1849,7 +1849,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRemoveBonds(int molecule, int nbonds, int* bonds)
+int indigoRemoveBonds(int molecule, int nbonds, int* bonds)
 {
     INDIGO_BEGIN
     {
@@ -1897,7 +1897,7 @@
     return _nei_counters;
 }
 
-CEXPORT int indigoIsChiral(int molecule)
+int indigoIsChiral(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -1907,7 +1907,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoBondOrder(int bond)
+int indigoBondOrder(int bond)
 {
     INDIGO_BEGIN
     {
@@ -1919,7 +1919,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoTopology(int bond)
+int indigoTopology(int bond)
 {
     INDIGO_BEGIN
     {
@@ -1935,7 +1935,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetAtom(int molecule, int idx)
+int indigoGetAtom(int molecule, int idx)
 {
     INDIGO_BEGIN
     {
@@ -1946,7 +1946,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetBond(int molecule, int idx)
+int indigoGetBond(int molecule, int idx)
 {
     INDIGO_BEGIN
     {
@@ -1957,7 +1957,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSource(int bond)
+int indigoSource(int bond)
 {
     INDIGO_BEGIN
     {
@@ -1967,7 +1967,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDestination(int bond)
+int indigoDestination(int bond)
 {
     INDIGO_BEGIN
     {
@@ -2026,7 +2026,7 @@
     return vertex.neiNext(_nei_idx) != vertex.neiEnd();
 }
 
-CEXPORT int indigoIterateNeighbors(int atom)
+int indigoIterateNeighbors(int atom)
 {
     INDIGO_BEGIN
     {
@@ -2037,7 +2037,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoBond(int nei)
+int indigoBond(int nei)
 {
     INDIGO_BEGIN
     {
@@ -2053,7 +2053,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT float indigoAlignAtoms(int molecule, int natoms, int* atom_ids, float* desired_xyz)
+float indigoAlignAtoms(int molecule, int natoms, int* atom_ids, float* desired_xyz)
 {
     INDIGO_BEGIN
     {
@@ -2094,7 +2094,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountSuperatoms(int molecule)
+int indigoCountSuperatoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2104,7 +2104,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountDataSGroups(int molecule)
+int indigoCountDataSGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2114,7 +2114,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountRepeatingUnits(int molecule)
+int indigoCountRepeatingUnits(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2124,7 +2124,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountMultipleGroups(int molecule)
+int indigoCountMultipleGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2134,7 +2134,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountGenericSGroups(int molecule)
+int indigoCountGenericSGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2175,7 +2175,7 @@
     return sgroup.release();
 }
 
-CEXPORT int indigoIterateDataSGroups(int molecule)
+int indigoIterateDataSGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2476,7 +2476,7 @@
     return sgroup.release();
 }
 
-CEXPORT int indigoIterateGenericSGroups(int molecule)
+int indigoIterateGenericSGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2562,7 +2562,7 @@
     return sgroup.release();
 }
 
-CEXPORT int indigoIterateSGroups(int molecule)
+int indigoIterateSGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2650,7 +2650,7 @@
     return tgroup.release();
 }
 
-CEXPORT int indigoIterateTGroups(int molecule)
+int indigoIterateTGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2660,7 +2660,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateRepeatingUnits(int molecule)
+int indigoIterateRepeatingUnits(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2673,7 +2673,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateMultipleGroups(int molecule)
+int indigoIterateMultipleGroups(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2686,7 +2686,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateSuperatoms(int molecule)
+int indigoIterateSuperatoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -2699,7 +2699,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSuperatom(int molecule, int index)
+int indigoGetSuperatom(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -2716,7 +2716,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetDataSGroup(int molecule, int index)
+int indigoGetDataSGroup(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -2733,7 +2733,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetGenericSGroup(int molecule, int index)
+int indigoGetGenericSGroup(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -2750,7 +2750,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetMultipleGroup(int molecule, int index)
+int indigoGetMultipleGroup(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -2767,7 +2767,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetRepeatingUnit(int molecule, int index)
+int indigoGetRepeatingUnit(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -2784,7 +2784,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoDescription(int data_sgroup)
+const char* indigoDescription(int data_sgroup)
 {
     INDIGO_BEGIN
     {
@@ -2796,7 +2796,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoData(int data_sgroup)
+const char* indigoData(int data_sgroup)
 {
     INDIGO_BEGIN
     {
@@ -2808,7 +2808,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoAddDataSGroup(int molecule, int natoms, int* atoms, int nbonds, int* bonds, const char* name, const char* data)
+int indigoAddDataSGroup(int molecule, int natoms, int* atoms, int nbonds, int* bonds, const char* name, const char* data)
 {
     INDIGO_BEGIN
     {
@@ -2832,7 +2832,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddSuperatom(int molecule, int natoms, int* atoms, const char* name)
+int indigoAddSuperatom(int molecule, int natoms, int* atoms, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -2851,7 +2851,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetDataSGroupXY(int sgroup, float x, float y, const char* options)
+int indigoSetDataSGroupXY(int sgroup, float x, float y, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -2876,7 +2876,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupData(int sgroup, const char* data)
+int indigoSetSGroupData(int sgroup, const char* data)
 {
     INDIGO_BEGIN
     {
@@ -2890,7 +2890,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupCoords(int sgroup, float x, float y)
+int indigoSetSGroupCoords(int sgroup, float x, float y)
 {
     INDIGO_BEGIN
     {
@@ -2904,7 +2904,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupDescription(int sgroup, const char* description)
+int indigoSetSGroupDescription(int sgroup, const char* description)
 {
     INDIGO_BEGIN
     {
@@ -2918,7 +2918,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupFieldName(int sgroup, const char* name)
+int indigoSetSGroupFieldName(int sgroup, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -2932,7 +2932,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupQueryCode(int sgroup, const char* querycode)
+int indigoSetSGroupQueryCode(int sgroup, const char* querycode)
 {
     INDIGO_BEGIN
     {
@@ -2946,7 +2946,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupQueryOper(int sgroup, const char* queryoper)
+int indigoSetSGroupQueryOper(int sgroup, const char* queryoper)
 {
     INDIGO_BEGIN
     {
@@ -2960,7 +2960,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupDisplay(int sgroup, const char* option)
+int indigoSetSGroupDisplay(int sgroup, const char* option)
 {
     INDIGO_BEGIN
     {
@@ -2981,7 +2981,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupLocation(int sgroup, const char* option)
+int indigoSetSGroupLocation(int sgroup, const char* option)
 {
     INDIGO_BEGIN
     {
@@ -3002,7 +3002,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupTag(int sgroup, const char* tag)
+int indigoSetSGroupTag(int sgroup, const char* tag)
 {
     INDIGO_BEGIN
     {
@@ -3018,7 +3018,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupTagAlign(int sgroup, int tag_align)
+int indigoSetSGroupTagAlign(int sgroup, int tag_align)
 {
     INDIGO_BEGIN
     {
@@ -3034,7 +3034,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupDataType(int sgroup, const char* data_type)
+int indigoSetSGroupDataType(int sgroup, const char* data_type)
 {
     INDIGO_BEGIN
     {
@@ -3050,7 +3050,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupXCoord(int sgroup, float x)
+int indigoSetSGroupXCoord(int sgroup, float x)
 {
     INDIGO_BEGIN
     {
@@ -3063,7 +3063,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupYCoord(int sgroup, float y)
+int indigoSetSGroupYCoord(int sgroup, float y)
 {
     INDIGO_BEGIN
     {
@@ -3076,7 +3076,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateSGroup(const char* type, int mapping, const char* name)
+int indigoCreateSGroup(const char* type, int mapping, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -3133,7 +3133,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupClass(int sgroup, const char* sgclass)
+int indigoSetSGroupClass(int sgroup, const char* sgclass)
 {
     INDIGO_BEGIN
     {
@@ -3145,7 +3145,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetSGroupClass(int sgroup)
+const char* indigoGetSGroupClass(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3157,7 +3157,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoSetSGroupName(int sgroup, const char* sgname)
+int indigoSetSGroupName(int sgroup, const char* sgname)
 {
     INDIGO_BEGIN
     {
@@ -3169,7 +3169,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetSGroupName(int sgroup)
+const char* indigoGetSGroupName(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3181,7 +3181,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoGetSGroupNumCrossBonds(int sgroup)
+int indigoGetSGroupNumCrossBonds(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3191,7 +3191,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddSGroupAttachmentPoint(int sgroup, int aidx, int lvidx, const char* apid)
+int indigoAddSGroupAttachmentPoint(int sgroup, int aidx, int lvidx, const char* apid)
 {
     INDIGO_BEGIN
     {
@@ -3206,7 +3206,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoDeleteSGroupAttachmentPoint(int sgroup, int ap_idx)
+int indigoDeleteSGroupAttachmentPoint(int sgroup, int ap_idx)
 {
     INDIGO_BEGIN
     {
@@ -3217,7 +3217,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSGroupDisplayOption(int sgroup)
+int indigoGetSGroupDisplayOption(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3230,7 +3230,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupDisplayOption(int sgroup, int option)
+int indigoSetSGroupDisplayOption(int sgroup, int option)
 {
     INDIGO_BEGIN
     {
@@ -3242,7 +3242,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSGroupSeqId(int sgroup)
+int indigoGetSGroupSeqId(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3254,7 +3254,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT float* indigoGetSGroupCoords(int sgroup)
+float* indigoGetSGroupCoords(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3270,7 +3270,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoGetSGroupMultiplier(int sgroup)
+int indigoGetSGroupMultiplier(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3280,7 +3280,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetRepeatingUnitSubscript(int sgroup)
+const char* indigoGetRepeatingUnitSubscript(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3290,7 +3290,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoGetRepeatingUnitConnectivity(int sgroup)
+int indigoGetRepeatingUnitConnectivity(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3300,7 +3300,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupMultiplier(int sgroup, int multiplier)
+int indigoSetSGroupMultiplier(int sgroup, int multiplier)
 {
     INDIGO_BEGIN
     {
@@ -3312,7 +3312,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupBrackets(int sgroup, int brk_style, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4)
+int indigoSetSGroupBrackets(int sgroup, int brk_style, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4)
 {
     INDIGO_BEGIN
     {
@@ -3341,7 +3341,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoFindSGroups(int item, const char* property, const char* value)
+int indigoFindSGroups(int item, const char* property, const char* value)
 {
     INDIGO_BEGIN
     {
@@ -3356,7 +3356,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSGroupType(int sgroup)
+int indigoGetSGroupType(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3366,7 +3366,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSGroupIndex(int sgroup)
+int indigoGetSGroupIndex(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3376,7 +3376,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSGroupOriginalId(int sgroup)
+int indigoGetSGroupOriginalId(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3386,7 +3386,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupOriginalId(int sgroup, int new_original)
+int indigoSetSGroupOriginalId(int sgroup, int new_original)
 {
     INDIGO_BEGIN
     {
@@ -3416,7 +3416,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoGetSGroupParentId(int sgroup)
+int indigoGetSGroupParentId(int sgroup)
 {
     INDIGO_BEGIN
     {
@@ -3426,7 +3426,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetSGroupParentId(int sgroup, int parent)
+int indigoSetSGroupParentId(int sgroup, int parent)
 {
     INDIGO_BEGIN
     {
@@ -3449,7 +3449,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddTemplate(int molecule, int templates, const char* tname)
+int indigoAddTemplate(int molecule, int templates, const char* tname)
 {
     INDIGO_BEGIN
     {
@@ -3467,7 +3467,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRemoveTemplate(int molecule, const char* tname)
+int indigoRemoveTemplate(int molecule, const char* tname)
 {
     INDIGO_BEGIN
     {
@@ -3482,7 +3482,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoFindTemplate(int molecule, const char* tname)
+int indigoFindTemplate(int molecule, const char* tname)
 {
     INDIGO_BEGIN
     {
@@ -3497,7 +3497,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetTGroupClass(int tgroup)
+const char* indigoGetTGroupClass(int tgroup)
 {
     INDIGO_BEGIN
     {
@@ -3509,7 +3509,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoGetTGroupName(int tgroup)
+const char* indigoGetTGroupName(int tgroup)
 {
     INDIGO_BEGIN
     {
@@ -3521,7 +3521,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoGetTGroupAlias(int tgroup)
+const char* indigoGetTGroupAlias(int tgroup)
 {
     INDIGO_BEGIN
     {
@@ -3533,7 +3533,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoTransformSCSRtoCTAB(int molecule)
+int indigoTransformSCSRtoCTAB(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -3546,7 +3546,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoTransformCTABtoSCSR(int molecule, int templates)
+int indigoTransformCTABtoSCSR(int molecule, int templates)
 {
     INDIGO_BEGIN
     {
@@ -3568,7 +3568,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountHeavyAtoms(int molecule)
+int indigoCountHeavyAtoms(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -3584,7 +3584,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountComponents(int molecule)
+int indigoCountComponents(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -3595,7 +3595,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCloneComponent(int molecule, int index)
+int indigoCloneComponent(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -3611,7 +3611,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoComponentIndex(int atom)
+int indigoComponentIndex(int atom)
 {
     INDIGO_BEGIN
     {
@@ -3622,7 +3622,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoComponent(int molecule, int index)
+int indigoComponent(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -3729,7 +3729,7 @@
     return idx;
 }
 
-CEXPORT int indigoIterateComponents(int molecule)
+int indigoIterateComponents(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -3740,7 +3740,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateComponentAtoms(int molecule, int index)
+int indigoIterateComponentAtoms(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -3751,7 +3751,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateComponentBonds(int molecule, int index)
+int indigoIterateComponentBonds(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -3762,7 +3762,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountComponentAtoms(int molecule, int index)
+int indigoCountComponentAtoms(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -3773,7 +3773,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountComponentBonds(int molecule, int index)
+int indigoCountComponentBonds(int molecule, int index)
 {
     INDIGO_BEGIN
     {
@@ -3784,7 +3784,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateMolecule()
+int indigoCreateMolecule()
 {
     INDIGO_BEGIN
     {
@@ -3794,7 +3794,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCreateQueryMolecule()
+int indigoCreateQueryMolecule()
 {
     INDIGO_BEGIN
     {
@@ -3803,7 +3803,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoMerge(int where, int what)
+int indigoMerge(int where, int what)
 {
     INDIGO_BEGIN
     {
@@ -3819,7 +3819,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddAtom(int molecule, const char* symbol)
+int indigoAddAtom(int molecule, const char* symbol)
 {
     INDIGO_BEGIN
     {
@@ -3851,7 +3851,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetAtom(int atom, const char* symbol)
+int indigoResetAtom(int atom, const char* symbol)
 {
     INDIGO_BEGIN
     {
@@ -3889,7 +3889,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetTemplateAtomClass(int atom)
+const char* indigoGetTemplateAtomClass(int atom)
 {
     INDIGO_BEGIN
     {
@@ -3910,7 +3910,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoSetTemplateAtomClass(int atom, const char* name)
+int indigoSetTemplateAtomClass(int atom, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -3966,7 +3966,7 @@
         mol.allowRGroupOnRSite(atom_index, rsites[i]);
 }
 
-CEXPORT int indigoAddRSite(int molecule, const char* name)
+int indigoAddRSite(int molecule, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -3989,7 +3989,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetRSite(int atom, const char* name)
+int indigoSetRSite(int atom, const char* name)
 {
     INDIGO_BEGIN
     {
@@ -4003,7 +4003,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetCharge(int atom, int charge)
+int indigoSetCharge(int atom, int charge)
 {
     INDIGO_BEGIN
     {
@@ -4015,7 +4015,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetIsotope(int atom, int isotope)
+int indigoSetIsotope(int atom, int isotope)
 {
     INDIGO_BEGIN
     {
@@ -4027,7 +4027,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetImplicitHCount(int atom, int impl_h)
+int indigoSetImplicitHCount(int atom, int impl_h)
 {
     INDIGO_BEGIN
     {
@@ -4039,7 +4039,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddBond(int source, int destination, int order)
+int indigoAddBond(int source, int destination, int order)
 {
     INDIGO_BEGIN
     {
@@ -4060,7 +4060,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetBondOrder(int bond, int order)
+int indigoSetBondOrder(int bond, int order)
 {
     INDIGO_BEGIN
     {
@@ -4199,7 +4199,7 @@
     return new IndigoBond(_submol.getOriginalMolecule(), _submol.edges[_idx]);
 }
 
-CEXPORT int indigoCountSSSR(int molecule)
+int indigoCountSSSR(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -4210,7 +4210,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateSSSR(int molecule)
+int indigoIterateSSSR(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -4289,7 +4289,7 @@
     return res.release();
 }
 
-CEXPORT int indigoIterateSubtrees(int molecule, int min_atoms, int max_atoms)
+int indigoIterateSubtrees(int molecule, int min_atoms, int max_atoms)
 {
     INDIGO_BEGIN
     {
@@ -4339,7 +4339,7 @@
     return res.release();
 }
 
-CEXPORT int indigoIterateRings(int molecule, int min_atoms, int max_atoms)
+int indigoIterateRings(int molecule, int min_atoms, int max_atoms)
 {
     INDIGO_BEGIN
     {
@@ -4392,7 +4392,7 @@
     return res.release();
 }
 
-CEXPORT int indigoIterateEdgeSubmolecules(int molecule, int min_bonds, int max_bonds)
+int indigoIterateEdgeSubmolecules(int molecule, int min_bonds, int max_bonds)
 {
     INDIGO_BEGIN
     {
@@ -4403,7 +4403,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountHydrogens(int item, int* hydro)
+int indigoCountHydrogens(int item, int* hydro)
 {
     INDIGO_BEGIN
     {
@@ -4441,7 +4441,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountImplicitHydrogens(int item)
+int indigoCountImplicitHydrogens(int item)
 {
     INDIGO_BEGIN
     {
@@ -4494,7 +4494,7 @@
     return _mol.getAttachmentPoint(_order, _index + 1) != -1;
 }
 
-CEXPORT int indigoIterateAttachmentPoints(int molecule, int order)
+int indigoIterateAttachmentPoints(int molecule, int order)
 {
     INDIGO_BEGIN
     {
@@ -4512,7 +4512,7 @@
 name - a name to parse
 params - a string containing parsing options or nullptr if no options are changed
 */
-CEXPORT int indigoNameToStructure(const char* name, const char* params)
+int indigoNameToStructure(const char* name, const char* params)
 {
     INDIGO_BEGIN
     {
@@ -4546,7 +4546,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCheckRGroups(int item)
+int indigoCheckRGroups(int item)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_stereo.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_stereo.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_stereo.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_stereo.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_stereo.cpp	(date 1701847510203)
@@ -22,7 +22,7 @@
 #include "molecule/molecule_exact_matcher.h"
 #include "reaction/reaction.h"
 
-CEXPORT int indigoStereocenterType(int atom)
+int indigoStereocenterType(int atom)
 {
     INDIGO_BEGIN
     {
@@ -65,7 +65,7 @@
     }
 }
 
-CEXPORT int indigoStereocenterGroup(int atom)
+int indigoStereocenterGroup(int atom)
 {
     INDIGO_BEGIN
     {
@@ -79,7 +79,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoSetStereocenterGroup(int atom, int group)
+int indigoSetStereocenterGroup(int atom, int group)
 {
     INDIGO_BEGIN
     {
@@ -94,7 +94,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoChangeStereocenterType(int atom, int type)
+int indigoChangeStereocenterType(int atom, int type)
 {
     INDIGO_BEGIN
     {
@@ -113,7 +113,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoAddStereocenter(int atom, int type, int v1, int v2, int v3, int v4)
+int indigoAddStereocenter(int atom, int type, int v1, int v2, int v3, int v4)
 {
     INDIGO_BEGIN
     {
@@ -145,7 +145,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const int* indigoStereocenterPyramid(int atom)
+const int* indigoStereocenterPyramid(int atom)
 {
     INDIGO_BEGIN
     {
@@ -159,7 +159,7 @@
     INDIGO_END(NULL);
 }
 
-CEXPORT int indigoCountStereocenters(int molecule)
+int indigoCountStereocenters(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -170,7 +170,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearAlleneCenters(int molecule)
+int indigoClearAlleneCenters(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -182,7 +182,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoCountAlleneCenters(int molecule)
+int indigoCountAlleneCenters(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -193,7 +193,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoBondStereo(int bond)
+int indigoBondStereo(int bond)
 {
     INDIGO_BEGIN
     {
@@ -220,7 +220,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoInvertStereo(int item)
+int indigoInvertStereo(int item)
 {
     INDIGO_BEGIN
     {
@@ -261,7 +261,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetStereo(int item)
+int indigoResetStereo(int item)
 {
     INDIGO_BEGIN
     {
@@ -290,7 +290,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearStereocenters(int object)
+int indigoClearStereocenters(int object)
 {
     INDIGO_BEGIN
     {
@@ -319,7 +319,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearCisTrans(int object)
+int indigoClearCisTrans(int object)
 {
     INDIGO_BEGIN
     {
@@ -433,7 +433,7 @@
     return sum;
 }
 
-CEXPORT int indigoResetSymmetricCisTrans(int handle)
+int indigoResetSymmetricCisTrans(int handle)
 {
     INDIGO_BEGIN
     {
@@ -455,7 +455,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoResetSymmetricStereocenters(int handle)
+int indigoResetSymmetricStereocenters(int handle)
 {
     INDIGO_BEGIN
     {
@@ -477,7 +477,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoMarkEitherCisTrans(int handle)
+int indigoMarkEitherCisTrans(int handle)
 {
     INDIGO_BEGIN
     {
@@ -499,7 +499,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoMarkStereobonds(int handle)
+int indigoMarkStereobonds(int handle)
 {
     INDIGO_BEGIN
     {
@@ -552,7 +552,7 @@
     }
 }
 
-CEXPORT int indigoValidateChirality(int handle)
+int indigoValidateChirality(int handle)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo.cpp b/indigo-src/indigo/api/c/indigo/src/indigo.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo.cpp	(date 1701847510197)
@@ -41,12 +41,12 @@
 
 static _SessionLocalContainer<Indigo> indigo_self;
 
-DLLEXPORT Indigo& indigoGetInstance()
+Indigo& indigoGetInstance()
 {
     return indigo_self.getLocalCopy();
 }
 
-CEXPORT const char* indigoVersion()
+const char* indigoVersion()
 {
     return INDIGO_VERSION "-" INDIGO_PLATFORM;
 }
@@ -291,7 +291,7 @@
     };
 }
 
-CEXPORT qword indigoAllocSessionId()
+qword indigoAllocSessionId()
 {
     qword id = TL_ALLOC_SESSION_ID();
     TL_SET_SESSION_ID(id);
@@ -308,12 +308,12 @@
     return id;
 }
 
-CEXPORT void indigoSetSessionId(qword id)
+void indigoSetSessionId(qword id)
 {
     TL_SET_SESSION_ID(id);
 }
 
-CEXPORT void indigoReleaseSessionId(qword id)
+void indigoReleaseSessionId(qword id)
 {
     TL_SET_SESSION_ID(id);
     indigoGetInstance().removeAllObjects();
@@ -327,17 +327,17 @@
 #endif
 }
 
-CEXPORT const char* indigoGetLastError(void)
+const char* indigoGetLastError(void)
 {
     return Indigo::getErrorMessage().ptr();
 }
 
-CEXPORT void indigoSetErrorHandler(INDIGO_ERROR_HANDLER handler, void* context)
+void indigoSetErrorHandler(INDIGO_ERROR_HANDLER handler, void* context)
 {
     Indigo::setErrorHandler(handler, context);
 }
 
-CEXPORT int indigoFree(int handle)
+int indigoFree(int handle)
 {
     // In some runtimes (e.g. Python) session could be removed before objects during resource releasing stage)
     if (indigo_self.hasLocalCopy())
@@ -354,13 +354,13 @@
     return 1;
 }
 
-CEXPORT int indigoFreeAllObjects()
+int indigoFreeAllObjects()
 {
     indigoGetInstance().removeAllObjects();
     return 1;
 }
 
-CEXPORT int indigoCountReferences(void)
+int indigoCountReferences(void)
 {
     INDIGO_BEGIN
     {
@@ -369,7 +369,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT void indigoSetErrorMessage(const char* message)
+void indigoSetErrorMessage(const char* message)
 {
     Indigo& self = indigoGetInstance();
     self.setErrorMessage(message);
@@ -489,9 +489,9 @@
 // Debug methods
 //
 
-#ifdef _WIN32
+#if defined(_WIN32) && !defined(__MINGW32__)
 #include <Windows.h>
-#elif defined(__linux__)
+#elif defined(__linux__) || defined(__MINGW32__)
 #include <fcntl.h>
 #include <unistd.h>
 #elif defined(__APPLE__)
@@ -505,7 +505,7 @@
 {
     void sleepMs(int ms)
     {
-#ifdef _WIN32
+#if defined(_WIN32) && !defined(__MINGW32__)
         Sleep(ms);
 #else
         sleep(ms * 1e-3);
@@ -514,7 +514,7 @@
 
     bool debuggerIsAttached()
     {
-#ifdef _WIN32
+#if defined(_WIN32) && !defined(__MINGW32__)
         return IsDebuggerPresent();
 #elif defined(__APPLE__)
         int mib[4];
@@ -547,9 +547,9 @@
     }
 }
 
-CEXPORT void indigoDbgBreakpoint(void)
+void indigoDbgBreakpoint(void)
 {
-#ifdef _WIN32
+#if defined(_WIN32) && !defined(__MINGW32__)
     if (!IsDebuggerPresent())
     {
         char msg[200];
@@ -572,7 +572,7 @@
 #endif
 }
 
-CEXPORT const char* indigoDbgProfiling(int whole_session)
+const char* indigoDbgProfiling(int whole_session)
 {
     INDIGO_BEGIN
     {
@@ -586,7 +586,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoDbgResetProfiling(int whole_session)
+int indigoDbgResetProfiling(int whole_session)
 {
     INDIGO_BEGIN
     {
@@ -600,7 +600,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT qword indigoDbgProfilingGetCounter(const char* name, int whole_session)
+qword indigoDbgProfilingGetCounter(const char* name, int whole_session)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_abbreviations_expand.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_abbreviations_expand.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_abbreviations_expand.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_abbreviations_expand.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_abbreviations_expand.cpp	(date 1701847510197)
@@ -769,7 +769,7 @@
         //
         // Interface functions
         //
-        CEXPORT int indigoExpandAbbreviations(int molecule)
+        int indigoExpandAbbreviations(int molecule)
         {
             INDIGO_BEGIN
             {
Index: indigo-src/indigo/api/c/indigo/src/indigo_composition.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_composition.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_composition.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_composition.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_composition.cpp	(date 1701847510198)
@@ -23,7 +23,7 @@
 
 using MoleculeIter = MoleculeRGroupsComposition::MoleculeIter;
 
-class DLLEXPORT IndigoCompositionElem : public IndigoObject
+class IndigoCompositionElem : public IndigoObject
 {
 public:
     IndigoCompositionElem() : IndigoObject(COMPOSITION_ELEM)
@@ -37,7 +37,7 @@
     MoleculeRGroups variants[RGCOMP_OPT_COUNT];
 };
 
-CEXPORT int indigoGetFragmentedMolecule(int elem, const char* options)
+int indigoGetFragmentedMolecule(int elem, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -72,7 +72,7 @@
     INDIGO_END(-1);
 }
 
-class DLLEXPORT IndigoCompositionIter : public IndigoObject
+class IndigoCompositionIter : public IndigoObject
 {
 public:
     IndigoCompositionIter(BaseMolecule& mol) : IndigoObject(COMPOSITION_ITER), _composition(mol), _it(_composition.begin()), _end(_composition.end())
@@ -112,7 +112,7 @@
     bool _hasNext = true;
 };
 
-CEXPORT int indigoRGroupComposition(int molecule, const char* options)
+int indigoRGroupComposition(int molecule, const char* options)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_structure_checker.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_structure_checker.h b/indigo-src/indigo/api/c/indigo/src/indigo_structure_checker.h
--- a/indigo-src/indigo/api/c/indigo/src/indigo_structure_checker.h	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_structure_checker.h	(date 1701847510203)
@@ -28,7 +28,7 @@
 namespace indigo
 {
 
-    class DLLEXPORT IndigoStructureChecker : public StructureChecker
+    class INDIGO_EXPORT IndigoStructureChecker : public StructureChecker
     {
     public:
         IndigoStructureChecker();
Index: indigo-src/indigo/api/c/indigo/src/indigo_properties.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_properties.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_properties.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_properties.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_properties.cpp	(date 1701847510202)
@@ -19,7 +19,7 @@
 #include "indigo_properties.h"
 #include "base_cpp/properties_map.h"
 
-CEXPORT int indigoHasProperty(int handle, const char* prop)
+int indigoHasProperty(int handle, const char* prop)
 {
     INDIGO_BEGIN
     {
@@ -35,7 +35,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoGetProperty(int handle, const char* prop)
+const char* indigoGetProperty(int handle, const char* prop)
 {
     INDIGO_BEGIN
     {
@@ -52,7 +52,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT int indigoSetProperty(int handle, const char* prop, const char* value)
+int indigoSetProperty(int handle, const char* prop, const char* value)
 {
     INDIGO_BEGIN
     {
@@ -70,7 +70,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRemoveProperty(int handle, const char* prop)
+int indigoRemoveProperty(int handle, const char* prop)
 {
     INDIGO_BEGIN
     {
@@ -138,7 +138,7 @@
     return new IndigoProperty(_props, _idx);
 }
 
-CEXPORT int indigoIterateProperties(int handle)
+int indigoIterateProperties(int handle)
 {
     INDIGO_BEGIN
     {
@@ -150,7 +150,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClearProperties(int handle)
+int indigoClearProperties(int handle)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_tautomer_enumerator.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_tautomer_enumerator.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_tautomer_enumerator.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_tautomer_enumerator.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_tautomer_enumerator.cpp	(date 1701847510203)
@@ -19,7 +19,7 @@
 #include "indigo_tautomer_enumerator.h"
 #include "indigo_molecule.h"
 
-CEXPORT int indigoIterateTautomers(int molecule, const char* options)
+int indigoIterateTautomers(int molecule, const char* options)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_array.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_array.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_array.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_array.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_array.cpp	(date 1701847510197)
@@ -139,7 +139,7 @@
     return _idx + 1 < _arr->objects.size();
 }
 
-CEXPORT int indigoCreateArray()
+int indigoCreateArray()
 {
     INDIGO_BEGIN
     {
@@ -148,7 +148,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoArrayAdd(int arr, int handle)
+int indigoArrayAdd(int arr, int handle)
 {
     INDIGO_BEGIN
     {
@@ -163,7 +163,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateArray(int arr)
+int indigoIterateArray(int arr)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_layout.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_layout.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_layout.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_layout.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_layout.cpp	(date 1701847510199)
@@ -27,7 +27,7 @@
 #include <algorithm>
 #include <vector>
 
-CEXPORT int indigoLayout(int object)
+int indigoLayout(int object)
 {
     INDIGO_BEGIN
     {
@@ -126,7 +126,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoClean2d(int object)
+int indigoClean2d(int object)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo/src/indigo_loaders.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo/src/indigo_loaders.cpp b/indigo-src/indigo/api/c/indigo/src/indigo_loaders.cpp
--- a/indigo-src/indigo/api/c/indigo/src/indigo_loaders.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo/src/indigo_loaders.cpp	(date 1701847510200)
@@ -511,7 +511,7 @@
     return next();
 }
 
-CEXPORT int indigoIterateSDF(int reader)
+int indigoIterateSDF(int reader)
 {
     INDIGO_BEGIN
     {
@@ -522,7 +522,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateRDF(int reader)
+int indigoIterateRDF(int reader)
 {
     INDIGO_BEGIN
     {
@@ -533,7 +533,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateSmiles(int reader)
+int indigoIterateSmiles(int reader)
 {
     INDIGO_BEGIN
     {
@@ -544,7 +544,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoTell(int handle)
+int indigoTell(int handle)
 {
     INDIGO_BEGIN
     {
@@ -585,7 +585,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT long long indigoTell64(int handle)
+long long indigoTell64(int handle)
 {
     INDIGO_BEGIN
     {
@@ -618,7 +618,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateSDFile(const char* filename)
+int indigoIterateSDFile(const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -627,7 +627,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateRDFile(const char* filename)
+int indigoIterateRDFile(const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -636,7 +636,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateSmilesFile(const char* filename)
+int indigoIterateSmilesFile(const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -775,7 +775,7 @@
         return new IndigoCmlMolecule(loader->data, counter, offset);
 }
 
-CEXPORT int indigoIterateCML(int reader)
+int indigoIterateCML(int reader)
 {
     INDIGO_BEGIN
     {
@@ -786,7 +786,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateCMLFile(const char* filename)
+int indigoIterateCMLFile(const char* filename)
 {
     INDIGO_BEGIN
     {
@@ -937,7 +937,7 @@
         return new IndigoCdxMolecule(loader->data, loader->properties, index, 0);
 }
 
-CEXPORT int indigoIterateCDX(int reader)
+int indigoIterateCDX(int reader)
 {
     INDIGO_BEGIN
     {
@@ -948,7 +948,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoIterateCDXFile(const char* filename)
+int indigoIterateCDXFile(const char* filename)
 {
     INDIGO_BEGIN
     {
Index: openbabel-src/openbabel/include/openbabel/tree/tree.hh
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/tree/tree.hh b/openbabel-src/openbabel/include/openbabel/tree/tree.hh
--- a/openbabel-src/openbabel/include/openbabel/tree/tree.hh	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/tree/tree.hh	(date 1696647929171)
@@ -542,8 +542,8 @@
 template <class T, class tree_node_allocator>
 void tree<T, tree_node_allocator>::head_initialise_()
    {
-   head = alloc_.allocate(1,nullptr); // MSVC does not have default second argument
-	feet = alloc_.allocate(1,nullptr);
+   head = alloc_.allocate(1);
+   feet = alloc_.allocate(1);
 
    head->parent=nullptr;
    head->first_child=nullptr;
@@ -869,7 +869,7 @@
 	assert(position.node!=head);
 	assert(position.node);
 
-	tree_node *tmp=alloc_.allocate(1,0);
+	tree_node *tmp=alloc_.allocate(1);
 	kp::constructor(&tmp->data);
 	tmp->first_child=0;
 	tmp->last_child=0;
@@ -894,7 +894,7 @@
 	assert(position.node!=head);
 	assert(position.node);
 
-	tree_node *tmp=alloc_.allocate(1,0);
+	tree_node *tmp=alloc_.allocate(1);
 	kp::constructor(&tmp->data);
 	tmp->first_child=0;
 	tmp->last_child=0;
@@ -923,7 +923,7 @@
 	assert(position.node!=head);
 	assert(position.node);
 
-	tree_node* tmp = alloc_.allocate(1,nullptr);
+	tree_node* tmp = alloc_.allocate(1);
 	kp::constructor(&tmp->data, x);
 	tmp->first_child=nullptr;
 	tmp->last_child=nullptr;
@@ -948,7 +948,7 @@
 	assert(position.node!=head);
 	assert(position.node);
 
-	tree_node* tmp = alloc_.allocate(1,0);
+	tree_node* tmp = alloc_.allocate(1);
 	kp::constructor(&tmp->data, x);
 	tmp->first_child=0;
 	tmp->last_child=0;
@@ -1035,7 +1035,7 @@
 		position.node=feet; // Backward compatibility: when calling insert on a null node,
 		                    // insert before the feet.
 		}
-	tree_node* tmp = alloc_.allocate(1,nullptr);
+	tree_node* tmp = alloc_.allocate(1);
 	kp::constructor(&tmp->data, x);
 	tmp->first_child=nullptr;
 	tmp->last_child=nullptr;
@@ -1057,7 +1057,7 @@
 template <class T, class tree_node_allocator>
 typename tree<T, tree_node_allocator>::sibling_iterator tree<T, tree_node_allocator>::insert(sibling_iterator position, const T& x)
 	{
-	tree_node* tmp = alloc_.allocate(1,0);
+	tree_node* tmp = alloc_.allocate(1);
 	kp::constructor(&tmp->data, x);
 	tmp->first_child=0;
 	tmp->last_child=0;
@@ -1087,7 +1087,7 @@
 template <class iter>
 iter tree<T, tree_node_allocator>::insert_after(iter position, const T& x)
 	{
-	tree_node* tmp = alloc_.allocate(1,0);
+	tree_node* tmp = alloc_.allocate(1);
 	kp::constructor(&tmp->data, x);
 	tmp->first_child=0;
 	tmp->last_child=0;
@@ -1159,7 +1159,7 @@
 //	std::cout << "warning!" << position.node << std::endl;
 	erase_children(position);
 //	std::cout << "no warning!" << std::endl;
-	tree_node* tmp = alloc_.allocate(1,0);
+	tree_node* tmp = alloc_.allocate(1);
 	kp::constructor(&tmp->data, (*from));
 	tmp->first_child=0;
 	tmp->last_child=0;
Index: boost-src/boost/libs/serialization/src/basic_text_wiprimitive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/basic_text_wiprimitive.cpp b/boost-src/boost/libs/serialization/src/basic_text_wiprimitive.cpp
--- a/boost-src/boost/libs/serialization/src/basic_text_wiprimitive.cpp	(revision 0ca603daf99888bf059c01ae1bab1b27dbc35ebe)
+++ b/boost-src/boost/libs/serialization/src/basic_text_wiprimitive.cpp	(date 1696647928129)
@@ -20,6 +20,7 @@
 #  pragma warning (disable : 4786) // too long name, harmless warning
 #endif
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/detail/auto_link_warchive.hpp>
Index: openbabel-src/openbabel/include/openbabel/math/matrix3x3.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/math/matrix3x3.h b/openbabel-src/openbabel/include/openbabel/math/matrix3x3.h
--- a/openbabel-src/openbabel/include/openbabel/math/matrix3x3.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/math/matrix3x3.h	(date 1696647929167)
@@ -281,7 +281,7 @@
       friend OBAPI std::ostream& operator<< ( std::ostream&, const matrix3x3 & ) ;
 
       //! Eigenvalue calculation
-      static void jacobi(unsigned int n, double *a, double *d, double *v);
+      static void jacobi(int n, double *a, double *d, double *v);
     };
 
 #ifndef SWIG
Index: indigo-src/indigo/api/c/bingo-nosql/src/bingo-nosql.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/bingo-nosql/src/bingo-nosql.cpp b/indigo-src/indigo/api/c/bingo-nosql/src/bingo-nosql.cpp
--- a/indigo-src/indigo/api/c/bingo-nosql/src/bingo-nosql.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/bingo-nosql/src/bingo-nosql.cpp	(date 1701847510195)
@@ -349,12 +349,12 @@
     auto matcher_ptr = sf::xlock_safe_ptr(searches_data->searches.at(id));                                                                                     \
     auto& matcher = **matcher_ptr;
 
-CEXPORT const char* bingoVersion()
+const char* bingoVersion()
 {
     return BINGO_VERSION;
 }
 
-CEXPORT int bingoCreateDatabaseFile(const char* location, const char* type, const char* options)
+int bingoCreateDatabaseFile(const char* location, const char* type, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -363,7 +363,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int bingoLoadDatabaseFile(const char* location, const char* options)
+int bingoLoadDatabaseFile(const char* location, const char* options)
 {
     INDIGO_BEGIN
     {
@@ -372,7 +372,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int bingoCloseDatabase(int db)
+int bingoCloseDatabase(int db)
 {
 #ifdef INDIGO_DEBUG
     std::stringstream ss;
@@ -389,7 +389,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoInsertRecordObj(int db, int obj)
+int bingoInsertRecordObj(int db, int obj)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -414,7 +414,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoInsertIteratorObj(int db, int iterator_obj_id)
+int bingoInsertIteratorObj(int db, int iterator_obj_id)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -437,7 +437,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoInsertRecordObjWithId(int db, int obj, int id)
+int bingoInsertRecordObjWithId(int db, int obj, int id)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -447,7 +447,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoInsertRecordObjWithExtFP(int db, int obj, int fp)
+int bingoInsertRecordObjWithExtFP(int db, int obj, int fp)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -473,7 +473,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoInsertRecordObjWithIdAndExtFP(int db, int obj, int id, int fp)
+int bingoInsertRecordObjWithIdAndExtFP(int db, int obj, int id, int fp)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -484,7 +484,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoDeleteRecord(int db, int id)
+int bingoDeleteRecord(int db, int id)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -496,7 +496,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoGetRecordObj(int db, int id)
+int bingoGetRecordObj(int db, int id)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -538,7 +538,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoOptimize(int db)
+int bingoOptimize(int db)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -550,7 +550,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchSub(int db, int query_obj, const char* options)
+int bingoSearchSub(int db, int query_obj, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -601,7 +601,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchExact(int db, int query_obj, const char* options)
+int bingoSearchExact(int db, int query_obj, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -650,7 +650,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchMolFormula(int db, const char* query, const char* options)
+int bingoSearchMolFormula(int db, const char* query, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -674,7 +674,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchSim(int db, int query_obj, float min, float max, const char* options)
+int bingoSearchSim(int db, int query_obj, float min, float max, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -725,7 +725,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchSimWithExtFP(int db, int query_obj, float min, float max, int fp, const char* options)
+int bingoSearchSimWithExtFP(int db, int query_obj, float min, float max, int fp, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -777,7 +777,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchSimTopN(int db, int query_obj, int limit, float min, const char* options)
+int bingoSearchSimTopN(int db, int query_obj, int limit, float min, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -828,7 +828,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoSearchSimTopNWithExtFP(int db, int query_obj, int limit, float min, int fp, const char* options)
+int bingoSearchSimTopNWithExtFP(int db, int query_obj, int limit, float min, int fp, const char* options)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -880,7 +880,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoEnumerateId(int db)
+int bingoEnumerateId(int db)
 {
     BINGO_BEGIN_DB(db)
     {
@@ -900,7 +900,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoEndSearch(int search_obj)
+int bingoEndSearch(int search_obj)
 {
 #ifdef INDIGO_DEBUG
     std::stringstream ss;
@@ -916,7 +916,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoNext(int search_obj)
+int bingoNext(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -926,7 +926,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoGetCurrentId(int search_obj)
+int bingoGetCurrentId(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -936,7 +936,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT float bingoGetCurrentSimilarityValue(int search_obj)
+float bingoGetCurrentSimilarityValue(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -946,7 +946,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoEstimateRemainingResultsCount(int search_obj)
+int bingoEstimateRemainingResultsCount(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -957,7 +957,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoContainersCount(int search_obj)
+int bingoContainersCount(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -967,7 +967,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoCellsCount(int search_obj)
+int bingoCellsCount(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -977,7 +977,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoCurrentCell(int search_obj)
+int bingoCurrentCell(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -987,7 +987,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoMinCell(int search_obj)
+int bingoMinCell(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -997,7 +997,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoMaxCell(int search_obj)
+int bingoMaxCell(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -1007,7 +1007,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoEstimateRemainingResultsCountError(int search_obj)
+int bingoEstimateRemainingResultsCountError(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -1019,7 +1019,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoEstimateRemainingTime(int search_obj, float* time_sec)
+int bingoEstimateRemainingTime(int search_obj, float* time_sec)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -1031,7 +1031,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT int bingoGetObject(int search_obj)
+int bingoGetObject(int search_obj)
 {
     BINGO_BEGIN_SEARCH(search_obj)
     {
@@ -1042,7 +1042,7 @@
     BINGO_END(-1);
 }
 
-CEXPORT const char* bingoProfilingGetStatistics(int for_session)
+const char* bingoProfilingGetStatistics(int for_session)
 {
     INDIGO_BEGIN
     {
Index: cairo-src/cairo/src/cairo-ps-surface.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cairo-src/cairo/src/cairo-ps-surface.c b/cairo-src/cairo/src/cairo-ps-surface.c
--- a/cairo-src/cairo/src/cairo-ps-surface.c	(revision 3909090108bb2db55330e3eb148aebe664735363)
+++ b/cairo-src/cairo/src/cairo-ps-surface.c	(date 1701837435166)
@@ -102,7 +102,7 @@
 #define DEBUG_FALLBACK(s)
 #endif
 
-#ifndef HAVE_CTIME_R
+#if !defined(HAVE_CTIME_R) && !defined(unix)
 static char *ctime_r(const time_t *timep, char *buf)
 {
     (void)buf;
Index: openbabel-src/openbabel/include/openbabel/tokenst.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openbabel-src/openbabel/include/openbabel/tokenst.h b/openbabel-src/openbabel/include/openbabel/tokenst.h
--- a/openbabel-src/openbabel/include/openbabel/tokenst.h	(revision cbd4db43f8908b874864280fdc03bf92569eebc1)
+++ b/openbabel-src/openbabel/include/openbabel/tokenst.h	(date 1696647929170)
@@ -25,7 +25,6 @@
 #include <vector>
 #include <sstream>
 #include <string>
-#include <fstream>
 
 namespace OpenBabel
 {
@@ -56,7 +55,7 @@
 
   //! Opens a datafile in a directory where OpenBabel expects to find it.
   // full documentation in tokenst.cpp
-  OBERROR std::string OpenDatafile(std::ifstream& fs,
+  OBERROR std::string OpenDatafile(std::istringstream& iss,
                                  const std::string& filename,
                                  const std::string& envvar = "BABEL_DATADIR");
 
Index: indigo-src/indigo/api/c/bingo-nosql/bingo-nosql.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/bingo-nosql/bingo-nosql.h b/indigo-src/indigo/api/c/bingo-nosql/bingo-nosql.h
--- a/indigo-src/indigo/api/c/bingo-nosql/bingo-nosql.h	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/bingo-nosql/bingo-nosql.h	(date 1701847510195)
@@ -20,63 +20,64 @@
 #define __indigo_bingo__
 
 #include "indigo.h"
+#include "bingo_nosql_export.h"
 
-CEXPORT const char* bingoVersion();
+BINGO_NOSQL_EXPORT const char* bingoVersion();
 
 // options = "id: <property-name>"
-CEXPORT int bingoCreateDatabaseFile(const char* location, const char* type, const char* options);
-CEXPORT int bingoLoadDatabaseFile(const char* location, const char* options);
-CEXPORT int bingoCloseDatabase(int db);
+BINGO_NOSQL_EXPORT int bingoCreateDatabaseFile(const char* location, const char* type, const char* options);
+BINGO_NOSQL_EXPORT int bingoLoadDatabaseFile(const char* location, const char* options);
+BINGO_NOSQL_EXPORT int bingoCloseDatabase(int db);
 
 //
 // Record insertion/deletion
 //
-CEXPORT int bingoInsertRecordObj(int db, int obj);
-CEXPORT int bingoInsertIteratorObj(int db, int iterator_obj_id);
-CEXPORT int bingoInsertRecordObjWithId(int db, int obj, int id);
-CEXPORT int bingoInsertRecordObjWithExtFP(int db, int obj, int fp);
-CEXPORT int bingoInsertRecordObjWithIdAndExtFP(int db, int obj, int id, int fp);
-CEXPORT int bingoDeleteRecord(int db, int id);
-CEXPORT int bingoGetRecordObj(int db, int id);
+BINGO_NOSQL_EXPORT int bingoInsertRecordObj(int db, int obj);
+BINGO_NOSQL_EXPORT int bingoInsertIteratorObj(int db, int iterator_obj_id);
+BINGO_NOSQL_EXPORT int bingoInsertRecordObjWithId(int db, int obj, int id);
+BINGO_NOSQL_EXPORT int bingoInsertRecordObjWithExtFP(int db, int obj, int fp);
+BINGO_NOSQL_EXPORT int bingoInsertRecordObjWithIdAndExtFP(int db, int obj, int id, int fp);
+BINGO_NOSQL_EXPORT int bingoDeleteRecord(int db, int id);
+BINGO_NOSQL_EXPORT int bingoGetRecordObj(int db, int id);
 
-CEXPORT int bingoOptimize(int db);
+BINGO_NOSQL_EXPORT int bingoOptimize(int db);
 
 // Search methods that returns search object
 // Search object is an iterator
-CEXPORT int bingoSearchSub(int db, int query_obj, const char* options);
-CEXPORT int bingoSearchExact(int db, int query_obj, const char* options);
-CEXPORT int bingoSearchMolFormula(int db, const char* query, const char* options);
-CEXPORT int bingoSearchSim(int db, int query_obj, float min, float max, const char* options);
-CEXPORT int bingoSearchSimWithExtFP(int db, int query_obj, float min, float max, int fp, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchSub(int db, int query_obj, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchExact(int db, int query_obj, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchMolFormula(int db, const char* query, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchSim(int db, int query_obj, float min, float max, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchSimWithExtFP(int db, int query_obj, float min, float max, int fp, const char* options);
 
-CEXPORT int bingoSearchSimTopN(int db, int query_obj, int limit, float min, const char* options);
-CEXPORT int bingoSearchSimTopNWithExtFP(int db, int query_obj, int limit, float min, int fp, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchSimTopN(int db, int query_obj, int limit, float min, const char* options);
+BINGO_NOSQL_EXPORT int bingoSearchSimTopNWithExtFP(int db, int query_obj, int limit, float min, int fp, const char* options);
 
-CEXPORT int bingoEnumerateId(int db);
+BINGO_NOSQL_EXPORT int bingoEnumerateId(int db);
 
 //
 // Search object methods
 //
-CEXPORT int bingoNext(int search_obj);
-CEXPORT int bingoGetCurrentId(int search_obj);
-CEXPORT float bingoGetCurrentSimilarityValue(int search_obj);
+BINGO_NOSQL_EXPORT int bingoNext(int search_obj);
+BINGO_NOSQL_EXPORT int bingoGetCurrentId(int search_obj);
+BINGO_NOSQL_EXPORT float bingoGetCurrentSimilarityValue(int search_obj);
 
 // Estimation methods
-CEXPORT int bingoEstimateRemainingResultsCount(int search_obj);
-CEXPORT int bingoEstimateRemainingResultsCountError(int search_obj);
-CEXPORT int bingoEstimateRemainingTime(int search_obj, float* time_sec);
-CEXPORT int bingoContainersCount(int search_obj);
-CEXPORT int bingoCellsCount(int search_obj);
-CEXPORT int bingoCurrentCell(int search_obj);
-CEXPORT int bingoMinCell(int search_obj);
-CEXPORT int bingoMaxCell(int search_obj);
+BINGO_NOSQL_EXPORT int bingoEstimateRemainingResultsCount(int search_obj);
+BINGO_NOSQL_EXPORT int bingoEstimateRemainingResultsCountError(int search_obj);
+BINGO_NOSQL_EXPORT int bingoEstimateRemainingTime(int search_obj, float* time_sec);
+BINGO_NOSQL_EXPORT int bingoContainersCount(int search_obj);
+BINGO_NOSQL_EXPORT int bingoCellsCount(int search_obj);
+BINGO_NOSQL_EXPORT int bingoCurrentCell(int search_obj);
+BINGO_NOSQL_EXPORT int bingoMinCell(int search_obj);
+BINGO_NOSQL_EXPORT int bingoMaxCell(int search_obj);
 
 // This method return IndigoObject that represents current object.
 // After calling bingoNext this object automatically points to the next found result
-CEXPORT int bingoGetObject(int search_obj);
+BINGO_NOSQL_EXPORT int bingoGetObject(int search_obj);
 
-CEXPORT int bingoEndSearch(int search_obj);
+BINGO_NOSQL_EXPORT int bingoEndSearch(int search_obj);
 
-CEXPORT const char* bingoProfilingGetStatistics(int for_session);
+BINGO_NOSQL_EXPORT const char* bingoProfilingGetStatistics(int for_session);
 
 #endif // __indigo_bingo__
Index: boost-src/boost/libs/serialization/src/xml_wgrammar.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/xml_wgrammar.cpp b/boost-src/boost/libs/serialization/src/xml_wgrammar.cpp
--- a/boost-src/boost/libs/serialization/src/xml_wgrammar.cpp	(revision 0ca603daf99888bf059c01ae1bab1b27dbc35ebe)
+++ b/boost-src/boost/libs/serialization/src/xml_wgrammar.cpp	(date 1696647928131)
@@ -14,6 +14,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/impl/basic_xml_grammar.hpp>
Index: boost-src/boost/libs/serialization/src/binary_woarchive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/binary_woarchive.cpp b/boost-src/boost/libs/serialization/src/binary_woarchive.cpp
--- a/boost-src/boost/libs/serialization/src/binary_woarchive.cpp	(revision 0ca603daf99888bf059c01ae1bab1b27dbc35ebe)
+++ b/boost-src/boost/libs/serialization/src/binary_woarchive.cpp	(date 1696647928129)
@@ -14,6 +14,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/archive/binary_woarchive.hpp>
 
Index: boost-src/boost/libs/serialization/src/text_wiarchive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/text_wiarchive.cpp b/boost-src/boost/libs/serialization/src/text_wiarchive.cpp
--- a/boost-src/boost/libs/serialization/src/text_wiarchive.cpp	(revision 0ca603daf99888bf059c01ae1bab1b27dbc35ebe)
+++ b/boost-src/boost/libs/serialization/src/text_wiarchive.cpp	(date 1696647928131)
@@ -14,6 +14,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/text_wiarchive.hpp>
Index: boost-src/boost/libs/serialization/src/codecvt_null.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/codecvt_null.cpp b/boost-src/boost/libs/serialization/src/codecvt_null.cpp
--- a/boost-src/boost/libs/serialization/src/codecvt_null.cpp	(revision 0ca603daf99888bf059c01ae1bab1b27dbc35ebe)
+++ b/boost-src/boost/libs/serialization/src/codecvt_null.cpp	(date 1696647928129)
@@ -7,6 +7,7 @@
 // License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
 // http://www.boost.org/LICENSE_1_0.txt)
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/codecvt_null.hpp>
Index: boost-src/boost/libs/serialization/src/basic_text_woprimitive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/basic_text_woprimitive.cpp b/boost-src/boost/libs/serialization/src/basic_text_woprimitive.cpp
--- a/boost-src/boost/libs/serialization/src/basic_text_woprimitive.cpp	(revision 0ca603daf99888bf059c01ae1bab1b27dbc35ebe)
+++ b/boost-src/boost/libs/serialization/src/basic_text_woprimitive.cpp	(date 1696647928129)
@@ -20,6 +20,7 @@
 #  pragma warning (disable : 4786) // too long name, harmless warning
 #endif
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/detail/auto_link_warchive.hpp>
Index: boost-src/boost/libs/serialization/src/xml_wiarchive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/xml_wiarchive.cpp b/boost-src/boost/libs/serialization/src/xml_wiarchive.cpp
--- a/boost-src/boost/libs/serialization/src/xml_wiarchive.cpp	(revision 0ca603daf99888bf059c01ae1bab1b27dbc35ebe)
+++ b/boost-src/boost/libs/serialization/src/xml_wiarchive.cpp	(date 1696647928131)
@@ -17,6 +17,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/xml_wiarchive.hpp>
Index: indigo-src/indigo/api/c/indigo-inchi/src/indigo_inchi_api.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo-inchi/src/indigo_inchi_api.cpp b/indigo-src/indigo/api/c/indigo-inchi/src/indigo_inchi_api.cpp
--- a/indigo-src/indigo/api/c/indigo-inchi/src/indigo_inchi_api.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo-inchi/src/indigo_inchi_api.cpp	(date 1701847510196)
@@ -29,7 +29,7 @@
 
 using namespace indigo;
 
-CEXPORT const char* indigoInchiVersion()
+const char* indigoInchiVersion()
 {
     return InchiWrapper::version();
 }
@@ -74,7 +74,7 @@
 // C interface functions
 //
 
-CEXPORT int indigoInchiInit(qword id)
+int indigoInchiInit(qword id)
 {
 #ifdef INDIGO_DEBUG
     std::stringstream ss;
@@ -89,7 +89,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoInchiDispose(qword id)
+int indigoInchiDispose(qword id)
 {
 #ifdef INDIGO_DEBUG
     std::stringstream ss;
@@ -104,14 +104,14 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoInchiResetOptions(void)
+int indigoInchiResetOptions(void)
 {
     IndigoInchiContext& inchi_context = indigoInchiGetInstance();
     inchi_context.init();
     return 0;
 }
 
-CEXPORT int indigoInchiLoadMolecule(const char* inchi_string)
+int indigoInchiLoadMolecule(const char* inchi_string)
 {
     INDIGO_BEGIN
     {
@@ -152,7 +152,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT const char* indigoInchiGetInchi(int molecule)
+const char* indigoInchiGetInchi(int molecule)
 {
     INDIGO_BEGIN
     {
@@ -166,7 +166,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoInchiGetInchiKey(const char* inchi_string)
+const char* indigoInchiGetInchiKey(const char* inchi_string)
 {
     INDIGO_BEGIN
     {
@@ -177,7 +177,7 @@
     INDIGO_END(0);
 }
 
-CEXPORT const char* indigoInchiGetWarning()
+const char* indigoInchiGetWarning()
 {
     InchiWrapper& inchi_wrapper = indigoInchiGetInstance().inchi;
     if (inchi_wrapper.warning.size() != 0)
@@ -185,7 +185,7 @@
     return "";
 }
 
-CEXPORT const char* indigoInchiGetLog()
+const char* indigoInchiGetLog()
 {
     InchiWrapper& inchi_wrapper = indigoInchiGetInstance().inchi;
     if (inchi_wrapper.log.size() != 0)
@@ -193,7 +193,7 @@
     return "";
 }
 
-CEXPORT const char* indigoInchiGetAuxInfo()
+const char* indigoInchiGetAuxInfo()
 {
     InchiWrapper& inchi_wrapper = indigoInchiGetInstance().inchi;
     if (inchi_wrapper.auxInfo.size() != 0)
Index: indigo-src/indigo/api/c/indigo-inchi/indigo-inchi.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo-inchi/indigo-inchi.h b/indigo-src/indigo/api/c/indigo-inchi/indigo-inchi.h
--- a/indigo-src/indigo/api/c/indigo-inchi/indigo-inchi.h	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo-inchi/indigo-inchi.h	(date 1701847510196)
@@ -20,24 +20,25 @@
 #define __indigo_inchi__
 
 #include "indigo.h"
+#include "indigo_inchi_export.h"
 
-CEXPORT const char* indigoInchiVersion();
+INDIGO_INCHI_EXPORT const char *indigoInchiVersion();
 
-CEXPORT int indigoInchiInit(qword id);
-CEXPORT int indigoInchiDispose(qword id);
+INDIGO_INCHI_EXPORT int indigoInchiInit(qword id);
+INDIGO_INCHI_EXPORT int indigoInchiDispose(qword id);
 
-CEXPORT int indigoInchiResetOptions();
+INDIGO_INCHI_EXPORT int indigoInchiResetOptions();
 
-CEXPORT int indigoInchiLoadMolecule(const char* inchi_string);
+INDIGO_INCHI_EXPORT int indigoInchiLoadMolecule(const char *inchi_string);
 
-CEXPORT const char* indigoInchiGetInchi(int molecule);
+INDIGO_INCHI_EXPORT const char *indigoInchiGetInchi(int molecule);
 
-CEXPORT const char* indigoInchiGetInchiKey(const char* inchi_string);
+INDIGO_INCHI_EXPORT const char *indigoInchiGetInchiKey(const char *inchi_string);
 
-CEXPORT const char* indigoInchiGetWarning();
+INDIGO_INCHI_EXPORT const char *indigoInchiGetWarning();
 
-CEXPORT const char* indigoInchiGetLog();
+INDIGO_INCHI_EXPORT const char *indigoInchiGetLog();
 
-CEXPORT const char* indigoInchiGetAuxInfo();
+INDIGO_INCHI_EXPORT const char *indigoInchiGetAuxInfo();
 
 #endif // __indigo_inchi__
Index: indigo-src/indigo/api/c/indigo-renderer/src/indigo_render2d.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo-renderer/src/indigo_render2d.cpp b/indigo-src/indigo/api/c/indigo-renderer/src/indigo_render2d.cpp
--- a/indigo-src/indigo/api/c/indigo-renderer/src/indigo_render2d.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo-renderer/src/indigo_render2d.cpp	(date 1701847510196)
@@ -413,7 +413,7 @@
         value.readString("right", true);
 }
 
-CEXPORT int indigoRendererInit(qword id)
+int indigoRendererInit(qword id)
 {
 #ifdef INDIGO_DEBUG
     std::stringstream ss;
@@ -429,7 +429,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRendererDispose(const qword id)
+int indigoRendererDispose(const qword id)
 {
 #ifdef INDIGO_DEBUG
     std::stringstream ss;
@@ -444,7 +444,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRender(int object, int output)
+int indigoRender(int object, int output)
 {
     INDIGO_BEGIN
     {
@@ -500,7 +500,7 @@
     INDIGO_END(-1);
 }
 
-CEXPORT int indigoRenderGrid(int objects, int* refAtoms, int nColumns, int output)
+int indigoRenderGrid(int objects, int* refAtoms, int nColumns, int output)
 {
     INDIGO_BEGIN
     {
@@ -624,7 +624,7 @@
     return indigoRenderMapOutputFormat(ext + 1);
 }
 
-CEXPORT int indigoRenderToFile(int object, const char* filename)
+int indigoRenderToFile(int object, const char* filename)
 {
     int f = indigoWriteFile(filename);
 
@@ -641,7 +641,7 @@
     return res;
 }
 
-CEXPORT int indigoRenderGridToFile(int objects, int* refAtoms, int nColumns, const char* filename)
+int indigoRenderGridToFile(int objects, int* refAtoms, int nColumns, const char* filename)
 {
     int f = indigoWriteFile(filename);
 
@@ -658,7 +658,7 @@
     return res;
 }
 
-CEXPORT int indigoRenderReset()
+int indigoRenderReset()
 {
     INDIGO_BEGIN
     {
@@ -669,13 +669,13 @@
     INDIGO_END(-1);
 }
 
-CEXPORT void indigoRenderResetOptions()
+void indigoRenderResetOptions()
 {
     indigoRendererGetInstance().init();
     getCdxmlContext().clear();
 }
 
-CEXPORT int indigoRenderWriteHDC(void* hdc, int printingHdc)
+int indigoRenderWriteHDC(void* hdc, int printingHdc)
 {
     INDIGO_BEGIN
     {
Index: indigo-src/indigo/api/c/indigo-renderer/indigo-renderer.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/api/c/indigo-renderer/indigo-renderer.h b/indigo-src/indigo/api/c/indigo-renderer/indigo-renderer.h
--- a/indigo-src/indigo/api/c/indigo-renderer/indigo-renderer.h	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/api/c/indigo-renderer/indigo-renderer.h	(date 1701847510196)
@@ -20,34 +20,35 @@
 #define __indigo_render__
 
 #include "indigo.h"
+#include "indigo_renderer_export.h"
 
-CEXPORT int indigoRendererInit(qword id);
-CEXPORT int indigoRendererDispose(qword id);
+INDIGO_RENDERER_EXPORT int indigoRendererInit(qword id);
+INDIGO_RENDERER_EXPORT int indigoRendererDispose(qword id);
 
 /* Rendering */
 
 // Returns an 'output' object for the given HDC
-CEXPORT int indigoRenderWriteHDC(void* hdc, int printingHdc);
+INDIGO_RENDERER_EXPORT int indigoRenderWriteHDC(void* hdc, int printingHdc);
 
 // output is either a file output obtained via indigoWriteFile(), or
 //        a buffer obtained via indigoWriteBuffer(), or
 //        an HDC obtained via indigoRenderWriteHDC
-CEXPORT int indigoRender(int object, int output);
+INDIGO_RENDERER_EXPORT int indigoRender(int object, int output);
 
 // objects  is an array of molecules created with indigoCreateArray)
 // refAtoms is an array of integers, whose size must be equal to the number
 //          of molecules if the array
 // nColumns is the number of columns in the grid
 // output -- see the comment for indigoRender
-CEXPORT int indigoRenderGrid(int objects, int* refAtoms, int nColumns, int output);
+INDIGO_RENDERER_EXPORT int indigoRenderGrid(int objects, int* refAtoms, int nColumns, int output);
 
 // Works like indigoRender(), but renders directly to file
-CEXPORT int indigoRenderToFile(int object, const char* filename);
+INDIGO_RENDERER_EXPORT int indigoRenderToFile(int object, const char* filename);
 
 // Works like indigoRenderGrid(), but renders directly to file
-CEXPORT int indigoRenderGridToFile(int objects, int* refAtoms, int nColumns, const char* filename);
+INDIGO_RENDERER_EXPORT int indigoRenderGridToFile(int objects, int* refAtoms, int nColumns, const char* filename);
 
 // Resets all the rendering settings
-CEXPORT int indigoRenderReset();
+INDIGO_RENDERER_EXPORT int indigoRenderReset();
 
 #endif
Index: boost-src/boost/libs/serialization/src/xml_woarchive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/xml_woarchive.cpp b/boost-src/boost/libs/serialization/src/xml_woarchive.cpp
--- a/boost-src/boost/libs/serialization/src/xml_woarchive.cpp	(revision 0ca603daf99888bf059c01ae1bab1b27dbc35ebe)
+++ b/boost-src/boost/libs/serialization/src/xml_woarchive.cpp	(date 1696647928131)
@@ -17,6 +17,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/xml_woarchive.hpp>
Index: boost-src/boost/libs/serialization/src/text_woarchive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/text_woarchive.cpp b/boost-src/boost/libs/serialization/src/text_woarchive.cpp
--- a/boost-src/boost/libs/serialization/src/text_woarchive.cpp	(revision 0ca603daf99888bf059c01ae1bab1b27dbc35ebe)
+++ b/boost-src/boost/libs/serialization/src/text_woarchive.cpp	(date 1696647928131)
@@ -13,6 +13,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/serialization/config.hpp>
 #include <boost/archive/text_woarchive.hpp>
Index: boost-src/boost/libs/serialization/src/binary_wiarchive.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/serialization/src/binary_wiarchive.cpp b/boost-src/boost/libs/serialization/src/binary_wiarchive.cpp
--- a/boost-src/boost/libs/serialization/src/binary_wiarchive.cpp	(revision 0ca603daf99888bf059c01ae1bab1b27dbc35ebe)
+++ b/boost-src/boost/libs/serialization/src/binary_wiarchive.cpp	(date 1696647928129)
@@ -14,6 +14,7 @@
 #error "wide char i/o not supported on this platform"
 #else
 
+#define BOOST_ARCHIVE_SOURCE
 #define BOOST_WARCHIVE_SOURCE
 #include <boost/archive/binary_wiarchive.hpp>
 #include <boost/archive/detail/archive_serializer_map.hpp>
Index: fluentui-src/fluentui/src/FluTreeModel.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/FluTreeModel.h b/fluentui-src/fluentui/src/FluTreeModel.h
--- a/fluentui-src/fluentui/src/FluTreeModel.h	(revision 7a1776407f72eb2fda567ab3e8a53b5687208da9)
+++ b/fluentui-src/fluentui/src/FluTreeModel.h	(date 1701846975321)
@@ -4,7 +4,7 @@
 #include <QObject>
 #include <QAbstractTableModel>
 #include <QJsonArray>
-#include <QtQml/qqml.h>
+#include <qqml.h>
 #include "stdafx.h"
 
 class Node : public QObject{
@@ -35,7 +35,7 @@
         if(!hasChildren()){
             return _checked;
         }
-        foreach (auto item, _children) {
+        Q_FOREACH (auto item, _children) {
             if(!item->checked()){
 
                 return false;
Index: fluentui-src/fluentui/src/FluEventBus.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/FluEventBus.h b/fluentui-src/fluentui/src/FluEventBus.h
--- a/fluentui-src/fluentui/src/FluEventBus.h	(revision 7a1776407f72eb2fda567ab3e8a53b5687208da9)
+++ b/fluentui-src/fluentui/src/FluEventBus.h	(date 1701846975319)
@@ -2,7 +2,7 @@
 #define FLUEVENTBUS_H
 
 #include <QObject>
-#include <QtQml/qqml.h>
+#include <qqml.h>
 #include "stdafx.h"
 #include "singleton.h"
 
Index: rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.h b/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.h
--- a/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.h	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.h	(date 1701849536983)
@@ -36,10 +36,7 @@
 class RDKIT_MOLSTANDARDIZE_EXPORT TautomerCatalogParams
     : public RDCatalog::CatalogParams {
  public:
-  TautomerCatalogParams() {
-    d_typeStr = "Tautomer Catalog Parameters";
-    d_transforms.clear();
-  }
+  TautomerCatalogParams();
 
   TautomerCatalogParams(const std::string &tautomerFile);
   TautomerCatalogParams(const TautomerTransformDefs &data);
Index: fluentui-src/fluentui/src/FluHttp.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/FluHttp.cpp b/fluentui-src/fluentui/src/FluHttp.cpp
--- a/fluentui-src/fluentui/src/FluHttp.cpp	(revision 7a1776407f72eb2fda567ab3e8a53b5687208da9)
+++ b/fluentui-src/fluentui/src/FluHttp.cpp	(date 1701847135599)
@@ -69,7 +69,7 @@
 }
 
 void FluHttp::cancel(){
-    foreach (QPointer<QNetworkReply> item, _cacheReply) {
+    Q_FOREACH (QPointer<QNetworkReply> item, _cacheReply) {
         if(item){
             item->abort();
         }
Index: rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.cpp b/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.cpp	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/Code/GraphMol/MolStandardize/TautomerCatalog/TautomerCatalogParams.cpp	(date 1701849536983)
@@ -45,6 +45,11 @@
 
 TautomerCatalogParams::~TautomerCatalogParams() {}
 
+TautomerCatalogParams::TautomerCatalogParams() {
+    d_typeStr = "Tautomer Catalog Parameters";
+    d_transforms.clear();
+}
+
 const std::vector<TautomerTransform> &TautomerCatalogParams::getTransforms()
     const {
   return d_transforms;
Index: libxml2-src/libxml2/include/libxml/xmlexports.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libxml2-src/libxml2/include/libxml/xmlexports.h b/libxml2-src/libxml2/include/libxml/xmlexports.h
--- a/libxml2-src/libxml2/include/libxml/xmlexports.h	(revision 4d8fa5b292fc902268217fa0f7031e77e5437b5a)
+++ b/libxml2-src/libxml2/include/libxml/xmlexports.h	(date 1696647929007)
@@ -8,18 +8,11 @@
 #ifndef __XML_EXPORTS_H__
 #define __XML_EXPORTS_H__
 
-/** DOC_DISABLE */
-#if defined(_WIN32) || defined(__CYGWIN__)
-  #ifdef LIBXML_STATIC
-    #define XMLPUBLIC
-  #elif defined(IN_LIBXML)
-    #define XMLPUBLIC __declspec(dllexport)
-  #else
-    #define XMLPUBLIC __declspec(dllimport)
-  #endif
-#else /* not Windows */
-  #define XMLPUBLIC
-#endif /* platform switch */
+#include "xml2_export.h"
+#ifndef XMLPUBLIC
+#define XMLPUBLIC XML2_EXPORT
+#endif
+
 /** DOC_ENABLE */
 
 /*
Index: yaehmop-src/yaehmop/tightbind/cboris.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/yaehmop-src/yaehmop/tightbind/cboris.c b/yaehmop-src/yaehmop/tightbind/cboris.c
--- a/yaehmop-src/yaehmop/tightbind/cboris.c	(revision c81f41694bcffccf38e17a63627a862628294613)
+++ b/yaehmop-src/yaehmop/tightbind/cboris.c	(date 1696647929795)
@@ -2,7 +2,7 @@
 Produced by gmFortran V30.59(10/26/17) on 9/18/18 at 9:02:32
 */
 #define LPROTOTYPE
-#include "fortran.h"
+#include <math.h>
 void cboris(int *n,int *nd,double *a,double *b,double *c,double *d,double *e,
     double *f,int *fail)
 {
Index: yaehmop-src/yaehmop/tightbind/abfns.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/yaehmop-src/yaehmop/tightbind/abfns.c b/yaehmop-src/yaehmop/tightbind/abfns.c
--- a/yaehmop-src/yaehmop/tightbind/abfns.c	(revision c81f41694bcffccf38e17a63627a862628294613)
+++ b/yaehmop-src/yaehmop/tightbind/abfns.c	(date 1696647929795)
@@ -2,7 +2,15 @@
 Produced by gmFortran V30.59(10/26/17) on 9/17/18 at 9:45:37
 */
 #define LPROTOTYPE
-#include "fortran.h"
+#include <math.h>
+#include <stdlib.h>
+#ifndef min
+#define min(x, y) ({				\
+	typeof(x) _min1 = (x);			\
+	typeof(y) _min2 = (y);			\
+	(void) (&_min1 == &_min2);		\
+	_min1 < _min2 ? _min1 : _min2; })
+#endif
 /*
 */
 void abfns(double *a,double *b,double *sk1,double *sk2,double *rr,int *l1,
@@ -55,7 +63,7 @@
     }
     ix = j;
     ir = fabs(2.e0*rho2);
-    is = fifmin0(ir+1,19);
+    is = min(ir+1,19);
     if(rho2 == 0) goto S35;
     d = exp(rho2);
     h = 1.e0/d;
Index: yaehmop-src/yaehmop/tightbind/postprocess.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/yaehmop-src/yaehmop/tightbind/postprocess.c b/yaehmop-src/yaehmop/tightbind/postprocess.c
--- a/yaehmop-src/yaehmop/tightbind/postprocess.c	(revision c81f41694bcffccf38e17a63627a862628294613)
+++ b/yaehmop-src/yaehmop/tightbind/postprocess.c	(date 1696647929799)
@@ -739,7 +739,7 @@
 
     /* this stores the reduced charge matrix */
     if( details->Rchg_mat_PRT ){
-      reduced_charge_mat(cell->num_atoms,num_orbs,orbital_lookup_table,
+      reduced_charge_matrix(cell->num_atoms,num_orbs,orbital_lookup_table,
                        properties->chg_mat,properties->Rchg_mat);
     }
 
Index: yaehmop-src/yaehmop/tightbind/prototypes.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/yaehmop-src/yaehmop/tightbind/prototypes.h b/yaehmop-src/yaehmop/tightbind/prototypes.h
--- a/yaehmop-src/yaehmop/tightbind/prototypes.h	(revision c81f41694bcffccf38e17a63627a862628294613)
+++ b/yaehmop-src/yaehmop/tightbind/prototypes.h	(date 1696647929799)
@@ -136,7 +136,7 @@
 extern void eval_charge_matrix PROTO((cell_type *, eigenset_type,
                                       hermetian_matrix_type, int, int *, real *,
                                       real *));
-extern void reduced_charge_mat PROTO((int, int, int *, real *, real *));
+extern void reduced_charge_matrix PROTO((int, int, int *, real *, real *));
 extern void check_a_cell PROTO((atom_type *, point_type, int, real, char *));
 extern void check_nn_contacts PROTO((cell_type *, detail_type *details));
 extern void build_distance_matrix PROTO((cell_type *, detail_type *details));
Index: fluentui-src/fluentui/src/FluViewModel.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/FluViewModel.h b/fluentui-src/fluentui/src/FluViewModel.h
--- a/fluentui-src/fluentui/src/FluViewModel.h	(revision 7a1776407f72eb2fda567ab3e8a53b5687208da9)
+++ b/fluentui-src/fluentui/src/FluViewModel.h	(date 1701846975321)
@@ -2,7 +2,7 @@
 #define FLUVIEWMODEL_H
 
 #include <QQuickItem>
-#include <QtQml/qqml.h>
+#include <qqml.h>
 #include <QQuickWindow>
 #include <QQmlProperty>
 #include "stdafx.h"
Index: ncnn-src/ncnn/src/modelbin.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/src/modelbin.cpp b/ncnn-src/ncnn/src/modelbin.cpp
--- a/ncnn-src/ncnn/src/modelbin.cpp	(revision 3116e028d28e08a48b21d667af8dd051ecf09c4b)
+++ b/ncnn-src/ncnn/src/modelbin.cpp	(date 1701848218974)
@@ -92,7 +92,6 @@
 
 Mat ModelBinFromDataReader::load(int w, int type) const
 {
-    Mat m;
 
     if (type == 0)
     {
@@ -124,15 +123,6 @@
             // half-precision data
             size_t align_data_size = alignSize(w * sizeof(unsigned short), 4);
 
-            // try reference data
-            const void* refbuf = 0;
-            nread = d->dr.reference(align_data_size, &refbuf);
-            if (nread == align_data_size)
-            {
-                m = Mat::from_float16((const unsigned short*)refbuf, w);
-            }
-            else
-            {
                 std::vector<unsigned short> float16_weights;
                 float16_weights.resize(align_data_size);
                 nread = d->dr.read(&float16_weights[0], align_data_size);
@@ -142,25 +132,12 @@
                     return Mat();
                 }
 
-                m = Mat::from_float16(&float16_weights[0], w);
-            }
-
-            return m;
+                return Mat::from_float16(float16_weights.data(), w);
         }
         else if (flag_struct.tag == 0x000D4B38)
         {
             // int8 data
             size_t align_data_size = alignSize(w, 4);
-
-            // try reference data
-            const void* refbuf = 0;
-            nread = d->dr.reference(align_data_size, &refbuf);
-            if (nread == align_data_size)
-            {
-                m = Mat(w, (void*)refbuf, (size_t)1u);
-            }
-            else
-            {
                 std::vector<signed char> int8_weights;
                 int8_weights.resize(align_data_size);
                 nread = d->dr.read(&int8_weights[0], align_data_size);
@@ -170,27 +147,17 @@
                     return Mat();
                 }
 
-                m.create(w, (size_t)1u);
+                Mat m(w, (size_t)1u);
                 if (m.empty())
                     return m;
 
                 memcpy(m.data, &int8_weights[0], w);
-            }
 
             return m;
         }
         else if (flag_struct.tag == 0x0002C056)
         {
-            // try reference data
-            const void* refbuf = 0;
-            nread = d->dr.reference(w * sizeof(float), &refbuf);
-            if (nread == w * sizeof(float))
-            {
-                m = Mat(w, (void*)refbuf);
-            }
-            else
-            {
-                m.create(w);
+            Mat m(w);
                 if (m.empty())
                     return m;
 
@@ -201,17 +168,14 @@
                     NCNN_LOGE("ModelBin read weight_data failed %zd", nread);
                     return Mat();
                 }
-            }
 
             return m;
         }
-
-        if (flag != 0)
-        {
-            m.create(w);
+        Mat m(w);
             if (m.empty())
                 return m;
-
+        if (flag != 0)
+        {
             // quantized data
             float quantization_value[256];
             nread = d->dr.read(quantization_value, 256 * sizeof(float));
@@ -239,19 +203,6 @@
         }
         else if (flag_struct.f0 == 0)
         {
-            // try reference data
-            const void* refbuf = 0;
-            nread = d->dr.reference(w * sizeof(float), &refbuf);
-            if (nread == w * sizeof(float))
-            {
-                m = Mat(w, (void*)refbuf);
-            }
-            else
-            {
-                m.create(w);
-                if (m.empty())
-                    return m;
-
                 // raw data
                 nread = d->dr.read(m, w * sizeof(float));
                 if (nread != w * sizeof(float))
@@ -260,22 +211,11 @@
                     return Mat();
                 }
             }
-        }
-
         return m;
     }
     else if (type == 1)
     {
-        // try reference data
-        const void* refbuf = 0;
-        size_t nread = d->dr.reference(w * sizeof(float), &refbuf);
-        if (nread == w * sizeof(float))
-        {
-            m = Mat(w, (void*)refbuf);
-        }
-        else
-        {
-            m.create(w);
+            Mat m(w);
             if (m.empty())
                 return m;
 
@@ -286,8 +226,6 @@
                 NCNN_LOGE("ModelBin read weight_data failed %zd", nread);
                 return Mat();
             }
-        }
-
         return m;
     }
     else
Index: fluentui-src/fluentui/src/FluEventBus.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/FluEventBus.cpp b/fluentui-src/fluentui/src/FluEventBus.cpp
--- a/fluentui-src/fluentui/src/FluEventBus.cpp	(revision 7a1776407f72eb2fda567ab3e8a53b5687208da9)
+++ b/fluentui-src/fluentui/src/FluEventBus.cpp	(date 1701846975319)
@@ -15,7 +15,7 @@
 }
 
 void FluEventBus::post(const QString& name,const QMap<QString, QVariant>& data){
-    foreach (auto event, _eventData) {
+    Q_FOREACH (auto event, _eventData) {
         if(event->name()==name){
             Q_EMIT event->triggered(data);
         }
Index: fluentui-src/fluentui/src/FluentUI.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/FluentUI.cpp b/fluentui-src/fluentui/src/FluentUI.cpp
--- a/fluentui-src/fluentui/src/FluentUI.cpp	(revision 7a1776407f72eb2fda567ab3e8a53b5687208da9)
+++ b/fluentui-src/fluentui/src/FluentUI.cpp	(date 1701847215271)
@@ -19,10 +19,6 @@
 #include "FluRectangle.h"
 #include "QRCode.h"
 
-int major = 1;
-int minor = 0;
-auto uri = "FluentUI";
-
 FluentUI* FluentUI::m_instance = nullptr;
 
 FluentUI *FluentUI::getInstance()
@@ -34,11 +30,14 @@
 }
 
 void FluentUI::registerTypes(QQmlEngine *engine){
+    auto uri = "FluentUI";
     initializeEngine(engine,uri);
     registerTypes(uri);
 }
 
 void FluentUI::registerTypes(const char *uri){
+    int major = 1;
+    int minor = 0;
 #if (QT_VERSION < QT_VERSION_CHECK(6, 2, 0))
     Q_INIT_RESOURCE(fluentui);
 #endif
Index: fluentui-src/fluentui/src/FluTreeModel.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/FluTreeModel.cpp b/fluentui-src/fluentui/src/FluTreeModel.cpp
--- a/fluentui-src/fluentui/src/FluTreeModel.cpp	(revision 7a1776407f72eb2fda567ab3e8a53b5687208da9)
+++ b/fluentui-src/fluentui/src/FluTreeModel.cpp	(date 1701846975320)
@@ -90,7 +90,7 @@
             QList<Node*> children = item->_children;
             if(!children.isEmpty()){
                 std::reverse(children.begin(), children.end());
-                foreach (auto c, children) {
+                Q_FOREACH (auto c, children) {
                     stack.append(c);
                 }
             }
@@ -103,7 +103,7 @@
     }
     Q_EMIT layoutChanged(QList<QPersistentModelIndex>(),QAbstractItemModel::VerticalSortHint);
     QList<Node*> data;
-    foreach (auto item, _dataSource) {
+    Q_FOREACH (auto item, _dataSource) {
         if(!item->hasChildren()){
             if(item->_checked){
                 data.append(item);
@@ -193,7 +193,7 @@
         QList<Node*> children = item->_children;
         if(!children.isEmpty()){
             std::reverse(children.begin(), children.end());
-            foreach (auto c, children) {
+            Q_FOREACH (auto c, children) {
                 stack.append(c);
             }
         }
@@ -268,7 +268,7 @@
         dragItem->_parent = dropItem->_parent;
         if(dragItem->hasChildren()){
             QList<Node*> stack = dragItem->_children;
-            foreach (auto node, stack) {
+            Q_FOREACH (auto node, stack) {
                 node->_depth = dragItem->_depth+1;
             }
             std::reverse(stack.begin(), stack.end());
@@ -278,7 +278,7 @@
                 QList<Node*> children = item->_children;
                 if(!children.isEmpty()){
                     std::reverse(children.begin(), children.end());
-                    foreach (auto c, children) {
+                    Q_FOREACH (auto c, children) {
                         c->_depth = item->_depth+1;
                         stack.append(c);
                     }
@@ -337,7 +337,7 @@
         QList<Node*> children = item->_children;
         if(!children.isEmpty()){
             std::reverse(children.begin(), children.end());
-            foreach (auto c, children) {
+            Q_FOREACH (auto c, children) {
                 stack.append(c);
             }
         }
@@ -358,7 +358,7 @@
         QList<Node*> children = item->_children;
         if(!children.isEmpty()){
             std::reverse(children.begin(), children.end());
-            foreach (auto c, children) {
+            Q_FOREACH (auto c, children) {
                 stack.append(c);
             }
         }
Index: fluentui-src/fluentui/src/FluViewModel.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/FluViewModel.cpp b/fluentui-src/fluentui/src/FluViewModel.cpp
--- a/fluentui-src/fluentui/src/FluViewModel.cpp	(revision 7a1776407f72eb2fda567ab3e8a53b5687208da9)
+++ b/fluentui-src/fluentui/src/FluViewModel.cpp	(date 1701846975321)
@@ -33,7 +33,7 @@
 }
 
 void ViewModelManager::refreshViewModel(FluViewModel* viewModel,QString key,QVariant value){
-    foreach (auto item, _viewmodel) {
+    Q_FOREACH (auto item, _viewmodel) {
         if(item->getKey() == viewModel->getKey()){
             item->setProperty(key.toStdString().c_str(),value);
         }
@@ -105,7 +105,7 @@
             new PropertyObserver(propertyName,model,this);
         }
     }
-    foreach (auto key, model->dynamicPropertyNames()) {
+    Q_FOREACH (auto key, model->dynamicPropertyNames()) {
         setProperty(key,model->property(key));
     }
 }
Index: yaehmop-src/yaehmop/tightbind/charge_mat.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/yaehmop-src/yaehmop/tightbind/charge_mat.c b/yaehmop-src/yaehmop/tightbind/charge_mat.c
--- a/yaehmop-src/yaehmop/tightbind/charge_mat.c	(revision c81f41694bcffccf38e17a63627a862628294613)
+++ b/yaehmop-src/yaehmop/tightbind/charge_mat.c	(date 1696647929795)
@@ -159,7 +159,7 @@
  *     num_atoms * num_orbs
  *
  ****************************************************************************/
-void reduced_charge_mat(num_atoms,num_orbs,orbital_lookup_table,Chg_matrix,RChg_matrix)
+void reduced_charge_matrix(num_atoms,num_orbs,orbital_lookup_table,Chg_matrix,RChg_matrix)
   int num_atoms,num_orbs,*orbital_lookup_table;
   real *Chg_matrix;
   real *RChg_matrix;
Index: ncnn-src/ncnn/src/datareader.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/src/datareader.h b/ncnn-src/ncnn/src/datareader.h
--- a/ncnn-src/ncnn/src/datareader.h	(revision 3116e028d28e08a48b21d667af8dd051ecf09c4b)
+++ b/ncnn-src/ncnn/src/datareader.h	(date 1701848218974)
@@ -44,10 +44,6 @@
     // read binary param and model data
     // return bytes read
     virtual size_t read(void* buf, size_t size) const;
-
-    // get model data reference
-    // return bytes referenced
-    virtual size_t reference(size_t size, const void** buf) const;
 };
 
 #if NCNN_STDIO
@@ -83,7 +79,6 @@
     virtual int scan(const char* format, void* p) const;
 #endif // NCNN_STRING
     virtual size_t read(void* buf, size_t size) const;
-    virtual size_t reference(size_t size, const void** buf) const;
 
 private:
     DataReaderFromMemory(const DataReaderFromMemory&);
Index: ncnn-src/ncnn/src/gpu.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/src/gpu.h b/ncnn-src/ncnn/src/gpu.h
--- a/ncnn-src/ncnn/src/gpu.h	(revision 3116e028d28e08a48b21d667af8dd051ecf09c4b)
+++ b/ncnn-src/ncnn/src/gpu.h	(date 1701848218974)
@@ -220,7 +220,7 @@
     GpuInfo& operator=(const GpuInfo&);
 
 private:
-    friend int create_gpu_instance();
+    friend NCNN_EXPORT int create_gpu_instance();
     GpuInfoPrivate* const d;
 };
 
Index: yaehmop-src/yaehmop/tightbind/diag.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/yaehmop-src/yaehmop/tightbind/diag.c b/yaehmop-src/yaehmop/tightbind/diag.c
--- a/yaehmop-src/yaehmop/tightbind/diag.c	(revision c81f41694bcffccf38e17a63627a862628294613)
+++ b/yaehmop-src/yaehmop/tightbind/diag.c	(date 1696647929796)
@@ -2,7 +2,9 @@
 Produced by gmFortran V30.59(10/26/17) on 9/18/18 at 9:02:32
 */
 #define LPROTOTYPE
-#include "fortran.h"
+#include "bind.h"
+#include <math.h>
+
 void cchol(int *n,int *nd,double *a,int *fail)
 {
 static int i,ia,j,k,ka;
@@ -431,7 +433,7 @@
 */
         p = (d[l]-d[l-1])/(2.0e0*e[l-1]);
         r = sqrt(1.0e0+p*p);
-        h = d[l-1]-e[l-1]/(p+fdsign(r,p));
+        h = d[l-1]-e[l-1]/(p+d_sign(r,p));
 /*
 */
         for(i=l; i<=*n; i++) {
Index: yaehmop-src/yaehmop/tightbind/Zmat.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/yaehmop-src/yaehmop/tightbind/Zmat.c b/yaehmop-src/yaehmop/tightbind/Zmat.c
--- a/yaehmop-src/yaehmop/tightbind/Zmat.c	(revision c81f41694bcffccf38e17a63627a862628294613)
+++ b/yaehmop-src/yaehmop/tightbind/Zmat.c	(date 1696647929795)
@@ -60,6 +60,7 @@
   sprintf(err_string,"Can't find atom %d (of %d) in find_atom.\n",
           which,num_atoms);
   FATAL_BUG(err_string);
+  return -1;
 }
 
 
Index: yaehmop-src/yaehmop/tightbind/lovlap.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/yaehmop-src/yaehmop/tightbind/lovlap.c b/yaehmop-src/yaehmop/tightbind/lovlap.c
--- a/yaehmop-src/yaehmop/tightbind/lovlap.c	(revision c81f41694bcffccf38e17a63627a862628294613)
+++ b/yaehmop-src/yaehmop/tightbind/lovlap.c	(date 1696647929798)
@@ -2,7 +2,7 @@
 Produced by gmFortran V30.59(10/26/17) on 9/17/18 at 9:45:37
 */
 #define LPROTOTYPE
-#include "fortran.h"
+#include <math.h>
 /*
 */
 void lovlap(double *strad,double *a,double *b,double *sk1,double *sk2,double *r,
Index: ncnn-src/ncnn/src/datareader.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ncnn-src/ncnn/src/datareader.cpp b/ncnn-src/ncnn/src/datareader.cpp
--- a/ncnn-src/ncnn/src/datareader.cpp	(revision 3116e028d28e08a48b21d667af8dd051ecf09c4b)
+++ b/ncnn-src/ncnn/src/datareader.cpp	(date 1701848218974)
@@ -38,11 +38,6 @@
     return 0;
 }
 
-size_t DataReader::reference(size_t /*size*/, const void** /*buf*/) const
-{
-    return 0;
-}
-
 #if NCNN_STDIO
 class DataReaderFromStdioPrivate
 {
@@ -141,13 +136,6 @@
     d->mem += size;
     return size;
 }
-
-size_t DataReaderFromMemory::reference(size_t size, const void** buf) const
-{
-    *buf = d->mem;
-    d->mem += size;
-    return size;
-}
 
 #if NCNN_PLATFORM_API
 #if __ANDROID_API__ >= 9
Index: openssl-src/openssl/opensslconf.h.cmake
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/openssl-src/openssl/opensslconf.h.cmake b/openssl-src/openssl/opensslconf.h.cmake
new file mode 100644
--- /dev/null	(date 1696647929489)
+++ b/openssl-src/openssl/opensslconf.h.cmake	(date 1696647929489)
@@ -0,0 +1,203 @@
+/*
+ * Copyright 2016-2020 The OpenSSL Project Authors. All Rights Reserved.
+ *
+ * Licensed under the OpenSSL license (the "License").  You may not use
+ * this file except in compliance with the License.  You can obtain a copy
+ * in the file LICENSE in the source distribution or at
+ * https://www.openssl.org/source/license.html
+ */
+
+#include <openssl/opensslv.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#ifdef OPENSSL_ALGORITHM_DEFINES
+# error OPENSSL_ALGORITHM_DEFINES no longer supported
+#endif
+
+/*
+ * OpenSSL was configured with the following options:
+ */
+
+#ifndef OPENSSL_NO_MD2
+# define OPENSSL_NO_MD2
+#endif
+#ifndef OPENSSL_NO_RC5
+# define OPENSSL_NO_RC5
+#endif
+#ifndef OPENSSL_THREADS
+# define OPENSSL_THREADS
+#endif
+#ifndef OPENSSL_RAND_SEED_OS
+# define OPENSSL_RAND_SEED_OS
+#endif
+#ifndef OPENSSL_NO_ASAN
+# define OPENSSL_NO_ASAN
+#endif
+#ifndef OPENSSL_NO_ASM
+# define OPENSSL_NO_ASM
+#endif
+#ifndef OPENSSL_NO_CRYPTO_MDEBUG
+# define OPENSSL_NO_CRYPTO_MDEBUG
+#endif
+#ifndef OPENSSL_NO_CRYPTO_MDEBUG_BACKTRACE
+# define OPENSSL_NO_CRYPTO_MDEBUG_BACKTRACE
+#endif
+#ifndef OPENSSL_NO_DEVCRYPTOENG
+# define OPENSSL_NO_DEVCRYPTOENG
+#endif
+#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128
+# define OPENSSL_NO_EC_NISTP_64_GCC_128
+#endif
+#ifndef OPENSSL_NO_EGD
+# define OPENSSL_NO_EGD
+#endif
+#ifndef OPENSSL_NO_EXTERNAL_TESTS
+# define OPENSSL_NO_EXTERNAL_TESTS
+#endif
+#ifndef OPENSSL_NO_FUZZ_AFL
+# define OPENSSL_NO_FUZZ_AFL
+#endif
+#ifndef OPENSSL_NO_FUZZ_LIBFUZZER
+# define OPENSSL_NO_FUZZ_LIBFUZZER
+#endif
+#ifndef OPENSSL_NO_HEARTBEATS
+# define OPENSSL_NO_HEARTBEATS
+#endif
+#ifndef OPENSSL_NO_MSAN
+# define OPENSSL_NO_MSAN
+#endif
+#ifndef OPENSSL_NO_SCTP
+# define OPENSSL_NO_SCTP
+#endif
+#ifndef OPENSSL_NO_SSL_TRACE
+# define OPENSSL_NO_SSL_TRACE
+#endif
+#ifndef OPENSSL_NO_SSL3
+# define OPENSSL_NO_SSL3
+#endif
+#ifndef OPENSSL_NO_SSL3_METHOD
+# define OPENSSL_NO_SSL3_METHOD
+#endif
+#ifndef OPENSSL_NO_UBSAN
+# define OPENSSL_NO_UBSAN
+#endif
+#ifndef OPENSSL_NO_UNIT_TEST
+# define OPENSSL_NO_UNIT_TEST
+#endif
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
+# define OPENSSL_NO_WEAK_SSL_CIPHERS
+#endif
+#ifndef OPENSSL_NO_STATIC_ENGINE
+# define OPENSSL_NO_STATIC_ENGINE
+#endif
+#ifndef OPENSSL_NO_AFALGENG
+# define OPENSSL_NO_AFALGENG
+#endif
+
+/*
+ * Sometimes OPENSSSL_NO_xxx ends up with an empty file and some compilers
+ * don't like that.  This will hopefully silence them.
+ */
+#define NON_EMPTY_TRANSLATION_UNIT static void *dummy = &dummy;
+
+/*
+ * Applications should use -DOPENSSL_API_COMPAT=<version> to suppress the
+ * declarations of functions deprecated in or before <version>. Otherwise, they
+ * still won't see them if the library has been built to disable deprecated
+ * functions.
+ */
+#ifndef DECLARE_DEPRECATED
+# define DECLARE_DEPRECATED(f)   f;
+# ifdef __GNUC__
+#  if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ > 0)
+#   undef DECLARE_DEPRECATED
+#   define DECLARE_DEPRECATED(f)    f __attribute__ ((deprecated));
+#  endif
+# elif defined(__SUNPRO_C)
+#  if (__SUNPRO_C >= 0x5130)
+#   undef DECLARE_DEPRECATED
+#   define DECLARE_DEPRECATED(f)    f __attribute__ ((deprecated));
+#  endif
+# endif
+#endif
+
+#ifndef OPENSSL_FILE
+# ifdef OPENSSL_NO_FILENAMES
+#  define OPENSSL_FILE ""
+#  define OPENSSL_LINE 0
+# else
+#  define OPENSSL_FILE __FILE__
+#  define OPENSSL_LINE __LINE__
+# endif
+#endif
+
+#ifndef OPENSSL_MIN_API
+# define OPENSSL_MIN_API 0
+#endif
+
+#if !defined(OPENSSL_API_COMPAT) || OPENSSL_API_COMPAT < OPENSSL_MIN_API
+# undef OPENSSL_API_COMPAT
+# define OPENSSL_API_COMPAT OPENSSL_MIN_API
+#endif
+
+/*
+ * Do not deprecate things to be deprecated in version 1.2.0 before the
+ * OpenSSL version number matches.
+ */
+#if OPENSSL_VERSION_NUMBER < 0x10200000L
+# define DEPRECATEDIN_1_2_0(f)   f;
+#elif OPENSSL_API_COMPAT < 0x10200000L
+# define DEPRECATEDIN_1_2_0(f)   DECLARE_DEPRECATED(f)
+#else
+# define DEPRECATEDIN_1_2_0(f)
+#endif
+
+#if OPENSSL_API_COMPAT < 0x10100000L
+# define DEPRECATEDIN_1_1_0(f)   DECLARE_DEPRECATED(f)
+#else
+# define DEPRECATEDIN_1_1_0(f)
+#endif
+
+#if OPENSSL_API_COMPAT < 0x10000000L
+# define DEPRECATEDIN_1_0_0(f)   DECLARE_DEPRECATED(f)
+#else
+# define DEPRECATEDIN_1_0_0(f)
+#endif
+
+#if OPENSSL_API_COMPAT < 0x00908000L
+# define DEPRECATEDIN_0_9_8(f)   DECLARE_DEPRECATED(f)
+#else
+# define DEPRECATEDIN_0_9_8(f)
+#endif
+
+/* Generate 80386 code? */
+#undef I386_ONLY
+
+#undef OPENSSL_UNISTD
+#define OPENSSL_UNISTD <unistd.h>
+
+#undef OPENSSL_EXPORT_VAR_AS_FUNCTION
+#cmakedefine OPENSSL_EXPORT_VAR_AS_FUNCTION
+
+/*
+ * The following are cipher-specific, but are part of the public API.
+ */
+#if !defined(OPENSSL_SYS_UEFI)
+#undef BN_LLONG
+/* Only one for the following should be defined */
+#undef SIXTY_FOUR_BIT_LONG
+#cmakedefine SIXTY_FOUR_BIT_LONG
+#undef SIXTY_FOUR_BIT
+#cmakedefine SIXTY_FOUR_BIT
+#undef THIRTY_TWO_BIT
+#cmakedefine THIRTY_TWO_BIT
+#endif
+
+#define RC4_INT unsigned int
+
+#ifdef  __cplusplus
+}
+#endif
Index: rdkit-src/rdkit/Code/GraphMol/SubstructLibrary/SubstructLibrary.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/SubstructLibrary/SubstructLibrary.h b/rdkit-src/rdkit/Code/GraphMol/SubstructLibrary/SubstructLibrary.h
--- a/rdkit-src/rdkit/Code/GraphMol/SubstructLibrary/SubstructLibrary.h	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/Code/GraphMol/SubstructLibrary/SubstructLibrary.h	(date 1701849536985)
@@ -415,7 +415,7 @@
       const std::vector<unsigned int> &indices) const override {
     std::vector<std::string> res;
     std::transform(indices.begin(), indices.end(), std::back_inserter(res),
-                   [=](unsigned idx) { return keys.at(idx); });
+                   [=, this](unsigned idx) { return keys.at(idx); });
     return res;
   }
   unsigned int size() const override { return keys.size(); }
Index: libpng-src/libpng/pngconf.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/pngconf.h b/libpng-src/libpng/pngconf.h
--- a/libpng-src/libpng/pngconf.h	(revision f135775ad4e5d4408d2e12ffcc71bb36e6b48551)
+++ b/libpng-src/libpng/pngconf.h	(date 1696647928996)
@@ -21,6 +21,7 @@
 #ifndef PNGCONF_H
 #define PNGCONF_H
 
+#include "libpng_export.h"
 #ifndef PNG_BUILDING_SYMBOL_TABLE /* else includes may cause problems */
 
 /* From libpng 1.6.0 libpng requires an ANSI X3.159-1989 ("ISOC90") compliant C
@@ -162,14 +163,6 @@
  * PNG_EXPORT_TYPE(type) A macro that pre or appends PNG_IMPEXP to
  *                       'type', compiler specific.
  *
- * PNG_DLL_EXPORT Set to the magic to use during a libpng build to
- *                make a symbol exported from the DLL.  Not used in the
- *                public header files; see pngpriv.h for how it is used
- *                in the libpng build.
- *
- * PNG_DLL_IMPORT Set to the magic to force the libpng symbols to come
- *                from a DLL - used to define PNG_IMPEXP when
- *                PNG_USE_DLL is set.
  */
 
 /* System specific discovery.
@@ -180,6 +173,7 @@
  * compiler-specific macros to the values required to change the calling
  * conventions of the various functions.
  */
+
 #if defined(_WIN32) || defined(__WIN32__) || defined(__NT__) || \
     defined(__CYGWIN__)
   /* Windows system (DOS doesn't support DLLs).  Includes builds under Cygwin or
@@ -222,23 +216,6 @@
 #  if defined(PNGAPI) && !defined(PNG_USER_PRIVATEBUILD)
 #     error "PNG_USER_PRIVATEBUILD must be defined if PNGAPI is changed"
 #  endif
-
-#  if (defined(_MSC_VER) && _MSC_VER < 800) ||\
-      (defined(__BORLANDC__) && __BORLANDC__ < 0x500)
-   /* older Borland and MSC
-    * compilers used '__export' and required this to be after
-    * the type.
-    */
-#    ifndef PNG_EXPORT_TYPE
-#      define PNG_EXPORT_TYPE(type) type PNG_IMPEXP
-#    endif
-#    define PNG_DLL_EXPORT __export
-#  else /* newer compiler */
-#    define PNG_DLL_EXPORT __declspec(dllexport)
-#    ifndef PNG_DLL_IMPORT
-#      define PNG_DLL_IMPORT __declspec(dllimport)
-#    endif
-#  endif /* compiler */
 
 #else /* !Windows */
 #  if (defined(__IBMC__) || defined(__IBMCPP__)) && defined(__OS2__)
@@ -265,16 +242,9 @@
  * then in an internal header file when building the library, otherwise (when
  * using the library) it is set here.
  */
-#ifndef PNG_IMPEXP
-#  if defined(PNG_USE_DLL) && defined(PNG_DLL_IMPORT)
-   /* This forces use of a DLL, disallowing static linking */
-#    define PNG_IMPEXP PNG_DLL_IMPORT
-#  endif
-
 #  ifndef PNG_IMPEXP
-#    define PNG_IMPEXP
+#    define PNG_IMPEXP LIBPNG_EXPORT
 #  endif
-#endif
 
 /* In 1.5.2 the definition of PNG_FUNCTION has been changed to always treat
  * 'attributes' as a storage class - the attributes go at the start of the
Index: pixman-src/pixman/pixman/pixman-compiler.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pixman-src/pixman/pixman/pixman-compiler.h b/pixman-src/pixman/pixman/pixman-compiler.h
--- a/pixman-src/pixman/pixman/pixman-compiler.h	(revision 37216a32839f59e8dcaa4c3951b3fcfc3f07852c)
+++ b/pixman-src/pixman/pixman/pixman-compiler.h	(date 1696647929500)
@@ -4,8 +4,6 @@
  * The features are:
  *
  *    FUNC	     must be defined to expand to the current function
- *    PIXMAN_EXPORT  should be defined to whatever is required to
- *                   export functions from a shared library
  *    limits	     limits for various types must be defined
  *    inline         must be defined
  *    force_inline   must be defined
@@ -88,18 +86,6 @@
 #      define noinline
 #   endif
 #endif
-
-/* GCC visibility */
-#if defined(__GNUC__) && __GNUC__ >= 4 && !defined(_WIN32)
-#   define PIXMAN_EXPORT __attribute__ ((visibility("default")))
-/* Sun Studio 8 visibility */
-#elif defined(__SUNPRO_C) && (__SUNPRO_C >= 0x550)
-#   define PIXMAN_EXPORT __global
-#elif defined (_MSC_VER) || defined(__MINGW32__)
-#   define PIXMAN_EXPORT PIXMAN_API
-#else
-#   define PIXMAN_EXPORT
-#endif
 
 /* member offsets */
 #define CONTAINER_OF(type, member, data)				\
Index: libpng-src/libpng/pngpriv.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libpng-src/libpng/pngpriv.h b/libpng-src/libpng/pngpriv.h
--- a/libpng-src/libpng/pngpriv.h	(revision f135775ad4e5d4408d2e12ffcc71bb36e6b48551)
+++ b/libpng-src/libpng/pngpriv.h	(date 1696647928997)
@@ -322,16 +322,9 @@
  * PNG_IMPEXP must be set here when building the library to prevent pngconf.h
  * setting it to the "import" setting for a DLL build.
  */
-#ifndef PNG_IMPEXP
-#  ifdef PNG_BUILD_DLL
-#     define PNG_IMPEXP PNG_DLL_EXPORT
-#  else
-      /* Not building a DLL, or the DLL doesn't require specific export
-       * definitions.
-       */
-#     define PNG_IMPEXP
+#  ifndef PNG_IMPEXP
+#    define PNG_IMPEXP LIBPNG_EXPORT
 #  endif
-#endif
 
 /* No warnings for private or deprecated functions in the build: */
 #ifndef PNG_DEPRECATED
@@ -391,11 +384,6 @@
 
 #include "png.h"
 
-/* pngconf.h does not set PNG_DLL_EXPORT unless it is required, so: */
-#ifndef PNG_DLL_EXPORT
-#  define PNG_DLL_EXPORT
-#endif
-
 /* This is a global switch to set the compilation for an installed system
  * (a release build).  It can be set for testing debug builds to ensure that
  * they will compile when the build type is switched to RC or STABLE, the
Index: rdkit-src/rdkit/Code/GraphMol/FileParsers/PNGParser.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/FileParsers/PNGParser.cpp b/rdkit-src/rdkit/Code/GraphMol/FileParsers/PNGParser.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/FileParsers/PNGParser.cpp	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/Code/GraphMol/FileParsers/PNGParser.cpp	(date 1701849536982)
@@ -22,7 +22,6 @@
 
 #include "FileParsers.h"
 #ifdef RDK_USE_BOOST_IOSTREAMS
-#include <zlib.h>
 #include <boost/iostreams/filtering_streambuf.hpp>
 #include <boost/iostreams/copy.hpp>
 #include <boost/iostreams/filter/zlib.hpp>
Index: rdkit-src/rdkit/Contrib/PBF/PBFRDKit.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Contrib/PBF/PBFRDKit.cpp b/rdkit-src/rdkit/Contrib/PBF/PBFRDKit.cpp
--- a/rdkit-src/rdkit/Contrib/PBF/PBFRDKit.cpp	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/Contrib/PBF/PBFRDKit.cpp	(date 1701849536985)
@@ -114,7 +114,7 @@
   if (eigensolver.info() != Eigen::Success) {
     BOOST_LOG(rdErrorLog) << "eigenvalue calculation did not converge"
                           << std::endl;
-    return 0.0;
+    return false;
   }
   RDGeom::Point3D normal;
   normal.x = eigensolver.eigenvectors()(0, 0);
@@ -125,6 +125,7 @@
   plane[1] = normal.y;
   plane[2] = normal.z;
   plane[3] = -1 * normal.dotProduct(origin);
+  return true;
 }
 
 double PBFRD(ROMol &mol, int confId) {
Index: coordgen-src/coordgen/CoordgenConfig.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/coordgen-src/coordgen/CoordgenConfig.hpp b/coordgen-src/coordgen/CoordgenConfig.hpp
--- a/coordgen-src/coordgen/CoordgenConfig.hpp	(revision c4dd5b0e1f1971c06c7ab85725c185e47211814e)
+++ b/coordgen-src/coordgen/CoordgenConfig.hpp	(date 1696647928400)
@@ -1,22 +1,7 @@
 #pragma once
 
-#ifndef STATIC_COORDGEN
-
-#ifdef WIN32
-#ifdef IN_COORDGEN
-#define EXPORT_COORDGEN __declspec(dllexport)
-#else
-#define EXPORT_COORDGEN __declspec(dllimport)
-#endif // IN_COORDGEN
-
-#else
-
-#define EXPORT_COORDGEN __attribute__((visibility("default")))
-
-#endif // WIN32
+#include <coordgenlibs_export.hpp>
 
-#else
-
-#define EXPORT_COORDGEN
-
-#endif // STATIC_COORDGEN
+#ifndef EXPORT_COORDGEN
+#define EXPORT_COORDGEN COORDGENLIBS_EXPORT
+#endif
Index: pixman-src/pixman/pixman/pixman-version.h.in
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pixman-src/pixman/pixman/pixman-version.h.in b/pixman-src/pixman/pixman/pixman-version.h.in
--- a/pixman-src/pixman/pixman/pixman-version.h.in	(revision 37216a32839f59e8dcaa4c3951b3fcfc3f07852c)
+++ b/pixman-src/pixman/pixman/pixman-version.h.in	(date 1696647929523)
@@ -27,6 +27,7 @@
 #ifndef PIXMAN_VERSION_H__
 #define PIXMAN_VERSION_H__
 
+#include "pixman_export.h"
 #ifndef PIXMAN_H__
 #  error pixman-version.h should only be included by pixman.h
 #endif
@@ -48,7 +49,7 @@
 	PIXMAN_VERSION_MICRO)
 
 #ifndef PIXMAN_API
-# define PIXMAN_API
+# define PIXMAN_API PIXMAN_EXPORT
 #endif
 
 #endif /* PIXMAN_VERSION_H__ */
Index: indigo-src/indigo/core/indigo-core/common/base_c/defs.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/common/base_c/defs.h b/indigo-src/indigo/core/indigo-core/common/base_c/defs.h
--- a/indigo-src/indigo/core/indigo-core/common/base_c/defs.h	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/core/indigo-core/common/base_c/defs.h	(date 1701847510204)
@@ -19,9 +19,7 @@
 #ifndef __defs_h__
 #define __defs_h__
 
-#if !defined(__sign)
-#define __sign(a) (a > 0 ? 1 : (a < 0 ? -1 : 0))
-#endif
+#include "indigo_core_export.h"
 
 #if defined(_WIN32) && !defined(__MINGW32__)
 // #define vsnprintf _vsnprintf
@@ -67,26 +65,12 @@
 #endif
 
 #ifndef EXPORT_SYMBOL
-#ifdef _WIN32
-#define EXPORT_SYMBOL __declspec(dllexport)
-#elif (defined __GNUC__ || defined __APPLE__)
-#define EXPORT_SYMBOL __attribute__((visibility("default")))
-#else
-#define EXPORT_SYMBOL
-#endif
+#define EXPORT_SYMBOL INDIGO_CORE_EXPORT
 #endif
 
 #ifndef DLLEXPORT
-#ifdef _WIN32
-#ifdef INDIGO_PLUGIN
-#define DLLEXPORT __declspec(dllimport)
-#else
-#define DLLEXPORT EXPORT_SYMBOL
-#endif
-#else
 #define DLLEXPORT EXPORT_SYMBOL
 #endif
-#endif
 
 #ifndef CEXPORT
 #ifndef __cplusplus
Index: boost-src/boost/libs/gil/include/boost/gil/extension/rasterization/ellipse.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/gil/include/boost/gil/extension/rasterization/ellipse.hpp b/boost-src/boost/libs/gil/include/boost/gil/extension/rasterization/ellipse.hpp
--- a/boost-src/boost/libs/gil/include/boost/gil/extension/rasterization/ellipse.hpp	(revision 8994c2ff8ed8b88e0ffef9658a4c603c4a001fad)
+++ b/boost-src/boost/libs/gil/include/boost/gil/extension/rasterization/ellipse.hpp	(date 1696647927463)
@@ -37,8 +37,8 @@
     /// center respectively.
     /// \param semi_axes - Point containing positive integer lengths of horizontal semi-axis
     /// and vertical semi-axis respectively.
-    midpoint_ellipse_rasterizer(point<unsigned int> center_point,
-        point<unsigned int> semi_axes_values)
+    midpoint_ellipse_rasterizer(point_t center_point,
+        point_t semi_axes_values)
         : center(center_point)
         , semi_axes(semi_axes_values)
     {}
@@ -130,7 +130,7 @@
         }
 
         // mutable center copy
-        point<unsigned int> center2(center);
+        point_t center2(center);
         --center2[0], --center2[1]; // For converting center co-ordinate values to zero based indexing.
         for (point_t pnt : trajectory_points)
         {
@@ -186,8 +186,8 @@
         draw_curve(view, pixel, obtain_trajectory());
     }
 
-    point<unsigned int> center;
-    point<unsigned int> semi_axes;
+    point_t center;
+    point_t semi_axes;
 };
 
 namespace detail {
Index: opencv-src/opencv/modules/gapi/src/backends/common/serialization.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/opencv-src/opencv/modules/gapi/src/backends/common/serialization.cpp b/opencv-src/opencv/modules/gapi/src/backends/common/serialization.cpp
--- a/opencv-src/opencv/modules/gapi/src/backends/common/serialization.cpp	(revision 5199850039ad23f1f0e6cccea5061a9fea5efca6)
+++ b/opencv-src/opencv/modules/gapi/src/backends/common/serialization.cpp	(date 1701848687872)
@@ -8,7 +8,9 @@
 #include <map> // map
 #include <ade/util/zip_range.hpp> // indexed
 
+#ifndef NOMINMAX
 #define NOMINMAX
+#endif
 
 #ifdef _WIN32
 #include <winsock.h>      // htonl, ntohl
Index: boost-src/boost/libs/phoenix/include/boost/phoenix/stl/tuple.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/boost-src/boost/libs/phoenix/include/boost/phoenix/stl/tuple.hpp b/boost-src/boost/libs/phoenix/include/boost/phoenix/stl/tuple.hpp
--- a/boost-src/boost/libs/phoenix/include/boost/phoenix/stl/tuple.hpp	(revision faadf7577e9adeb30b3f1c31533225d95350a7bb)
+++ b/boost-src/boost/libs/phoenix/include/boost/phoenix/stl/tuple.hpp	(date 1696647927956)
@@ -110,7 +110,7 @@
     namespace placeholders {
         #define BOOST_PP_LOCAL_LIMITS (1, BOOST_PHOENIX_ARG_LIMIT)
         #define BOOST_PP_LOCAL_MACRO(N)                                                \
-            auto uarg##N =                                                             \
+            const auto uarg##N =                                                             \
             boost::phoenix::get_<(N)-1>(boost::phoenix::placeholders::arg1);
         #include BOOST_PP_LOCAL_ITERATE()
     }
Index: indigo-src/indigo/core/indigo-core/common/base_cpp/output.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/common/base_cpp/output.h b/indigo-src/indigo/core/indigo-core/common/base_cpp/output.h
--- a/indigo-src/indigo/core/indigo-core/common/base_cpp/output.h	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/core/indigo-core/common/base_cpp/output.h	(date 1701847510204)
@@ -24,6 +24,7 @@
 #include "base_cpp/array.h"
 #include "base_cpp/exception.h"
 #include "base_cpp/io_base.h"
+#include <cstdint>
 
 namespace indigo
 {
@@ -47,7 +48,7 @@
         void writeChar(char value);
         void writeBinaryInt(int value);
         void writeBinaryWord(word value);
-        void writeBinaryUInt16(uint16_t value);
+        void writeBinaryUInt16(std::uint16_t value);
 
         void writeBinaryFloat(float value);
         void writePackedShort(short value);
Index: indigo-src/indigo/core/indigo-core/common/base_cpp/output.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/common/base_cpp/output.cpp b/indigo-src/indigo/core/indigo-core/common/base_cpp/output.cpp
--- a/indigo-src/indigo/core/indigo-core/common/base_cpp/output.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/core/indigo-core/common/base_cpp/output.cpp	(date 1701847510204)
@@ -61,7 +61,7 @@
     write(&value, sizeof(word));
 }
 
-void Output::writeBinaryUInt16(uint16_t value)
+void Output::writeBinaryUInt16(std::uint16_t value)
 {
     // value = htons(value);
     write(&value, sizeof(value));
Index: rdkit-src/rdkit/Code/GraphMol/FileParsers/MolSGroupParsing.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/FileParsers/MolSGroupParsing.h b/rdkit-src/rdkit/Code/GraphMol/FileParsers/MolSGroupParsing.h
--- a/rdkit-src/rdkit/Code/GraphMol/FileParsers/MolSGroupParsing.h	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/Code/GraphMol/FileParsers/MolSGroupParsing.h	(date 1701849536982)
@@ -131,7 +131,7 @@
 template <class T>
 RDKIT_FILEPARSERS_EXPORT std::vector<T> ParseV3000Array(
     std::stringstream &stream, int maxV = -1, bool strictParsing = false);
-#if defined(_MSC_VER) && defined(RDKIT_DYN_LINK)
+#if defined(_MSC_VER)
 template RDKIT_FILEPARSERS_EXPORT std::vector<int> ParseV3000Array(
     std::stringstream &, int, bool);
 template RDKIT_FILEPARSERS_EXPORT std::vector<unsigned int> ParseV3000Array(
Index: rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.h b/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.h
--- a/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.h	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.h	(date 1701849536983)
@@ -16,11 +16,11 @@
 #include <map>
 #include <chrono>
 
-#include "../../../External/GA/ga/StringChromosome.h"
-#include "../../../External/GA/ga/GaBase.h"
-#include "../../../External/GA/ga/GaOperation.h"
-#include "../../../External/GA/ga/LinkedPopLinearSel.h"
-#include "../../../External/GA/ga/IntegerStringChromosomePolicy.h"
+#include "GA/ga/StringChromosome.h"
+#include "GA/ga/GaBase.h"
+#include "GA/ga/GaOperation.h"
+#include "GA/ga/LinkedPopLinearSel.h"
+#include "GA/ga/IntegerStringChromosomePolicy.h"
 #include "RGroupFingerprintScore.h"
 #include "RGroupScore.h"
 
Index: indigo-src/indigo/core/indigo-core/layout/molecule_layout_macrocycles.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/layout/molecule_layout_macrocycles.h b/indigo-src/indigo/core/indigo-core/layout/molecule_layout_macrocycles.h
--- a/indigo-src/indigo/core/indigo-core/layout/molecule_layout_macrocycles.h	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/core/indigo-core/layout/molecule_layout_macrocycles.h	(date 1701847510204)
@@ -283,9 +283,9 @@
     public:
         TriangleLattice();
 
-        TriangleLattice(rectangle rec, int rem, byte* data_link);
+        TriangleLattice(rectangle rec, int rem, ::byte* data_link);
 
-        void init(rectangle rec, int rem, byte* data_link);
+        void init(rectangle rec, int rem, ::byte* data_link);
         void init_void();
 
         unsigned short& getCell(int x, int y);
@@ -337,7 +337,7 @@
 
         int length;
 
-        byte* _hidden_data_field;
+        ::byte* _hidden_data_field;
         ObjArray<Array<rectangle>> border_array;
         Array<rectangle*> border;
 
@@ -347,7 +347,7 @@
         TL_CP_DECL(Array<int>, _rotation_parity);
         TL_CP_DECL(Array<int>, _coord_diff_reminder); // (x - y) % 3
         TL_CP_DECL(ObjArray<ObjArray<ObjArray<TriangleLattice>>>, _lattices);
-        TL_CP_DECL(Array<byte>, _hidden_data_field_array);
+        TL_CP_DECL(Array<::byte>, _hidden_data_field_array);
 
         TriangleLattice _sink_lattice;
     };
Index: skia-src/skia/src/core/SkPath.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/skia-src/skia/src/core/SkPath.cpp b/skia-src/skia/src/core/SkPath.cpp
--- a/skia-src/skia/src/core/SkPath.cpp	(revision 5f54e9f84cff8c42fd645ec53c1727857bdb12ab)
+++ b/skia-src/skia/src/core/SkPath.cpp	(date 1701851934715)
@@ -2263,7 +2263,7 @@
 };
 
 SkPathConvexity SkPath::computeConvexity() const {
-    auto setComputedConvexity = [=](SkPathConvexity convexity){
+    auto setComputedConvexity = [=, this](SkPathConvexity convexity){
         SkASSERT(SkPathConvexity::kUnknown != convexity);
         this->setConvexity(convexity);
         return convexity;
Index: rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.cpp b/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.cpp	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupGa.cpp	(date 1701849536983)
@@ -7,7 +7,7 @@
 //  which is included in the file license.txt, found at the root
 //  of the RDKit source tree.
 //
-
+#include <RDGeneral/export.h>
 #include <ctime>
 #include <limits>
 #ifdef RDK_BUILD_THREADSAFE_SSS
@@ -18,7 +18,7 @@
 #include "RGroupDecompData.h"
 #include "RGroupDecomp.h"
 #include "RGroupFingerprintScore.h"
-#include "../../../External/GA/util/Util.h"
+#include "GA/util/Util.h"
 
 // #define DEBUG
 
Index: rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupFingerprintScore.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupFingerprintScore.cpp b/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupFingerprintScore.cpp
--- a/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupFingerprintScore.cpp	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/Code/GraphMol/RGroupDecomposition/RGroupFingerprintScore.cpp	(date 1701849536983)
@@ -12,7 +12,7 @@
 #include "GraphMol/Fingerprints/Fingerprints.h"
 #include "GraphMol//Fingerprints/MorganFingerprints.h"
 #include <GraphMol/SmilesParse/SmilesParse.h>
-#include "../../../External/GA/util/Util.h"
+#include "GA/util/Util.h"
 #include <memory>
 #include <utility>
 #include <vector>
Index: eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h b/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h
--- a/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	(revision 3147391d946bb4b6c68edd901f2add6ac1f31f8c)
+++ b/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorDeviceThreadPool.h	(date 1701843801259)
@@ -207,7 +207,11 @@
     // block_count leaves that do actual computations.
     Barrier barrier(static_cast<unsigned int>(block.count));
     std::function<void(Index, Index)> handleRange;
+#if __cplusplus >= 202002L
+    handleRange = [=, &handleRange, &barrier, &f, this](Index firstIdx,
+#else
     handleRange = [=, &handleRange, &barrier, &f](Index firstIdx,
+#endif
                                                   Index lastIdx) {
       while (lastIdx - firstIdx > block.size) {
         // Split into halves and schedule the second half on a different thread.
Index: fluentui-src/fluentui/src/FluTools.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/FluTools.h b/fluentui-src/fluentui/src/FluTools.h
--- a/fluentui-src/fluentui/src/FluTools.h	(revision 7a1776407f72eb2fda567ab3e8a53b5687208da9)
+++ b/fluentui-src/fluentui/src/FluTools.h	(date 1701846975320)
@@ -4,7 +4,7 @@
 #include <QObject>
 #include <QFile>
 #include <QColor>
-#include <QtQml/qqml.h>
+#include <qqml.h>
 #include "singleton.h"
 
 /**
Index: eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h b/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h
--- a/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	(revision 3147391d946bb4b6c68edd901f2add6ac1f31f8c)
+++ b/eigen-src/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorContractionThreadPool.h	(date 1701843801259)
@@ -1006,7 +1006,11 @@
       } else {
         eigen_assert(!use_thread_local);
         device_.enqueueNoNotification(
+#if __cplusplus >= 202002L
+            [=, this]() { kernel(m, n, k, use_thread_local); });
+#else
             [=]() { kernel(m, n, k, use_thread_local); });
+#endif
       }
     }
 
@@ -1060,7 +1064,11 @@
         while (end - start > 1) {
           Index mid = (start + end) / 2;
           device_.enqueueNoNotification(
+#if __cplusplus >= 202002L
+              [=, this]() { enqueue_packing_helper(mid, end, k, rhs); });
+#else
               [=]() { enqueue_packing_helper(mid, end, k, rhs); });
+#endif
           end = mid;
         }
 
@@ -1079,7 +1087,11 @@
 
         if (pack_async) {
           device_.enqueueNoNotification(
+#if __cplusplus >= 202002L
+              [=, this]() { enqueue_packing_helper(start, end, k, rhs); });
+#else
               [=]() { enqueue_packing_helper(start, end, k, rhs); });
+#endif
         } else {
           enqueue_packing_helper(start, end, k, rhs);
         }
Index: fluentui-src/fluentui/src/Screenshot.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/Screenshot.cpp b/fluentui-src/fluentui/src/Screenshot.cpp
--- a/fluentui-src/fluentui/src/Screenshot.cpp	(revision 7a1776407f72eb2fda567ab3e8a53b5687208da9)
+++ b/fluentui-src/fluentui/src/Screenshot.cpp	(date 1701846975322)
@@ -31,7 +31,7 @@
     _desktopPixmap = qApp->primaryScreen()->grabWindow(0, _desktopGeometry.x(), _desktopGeometry.y(), _desktopGeometry.width(), _desktopGeometry.height());
     int w = qApp->primaryScreen()->geometry().width();
     int h = qApp->primaryScreen()->geometry().height();
-    foreach (auto item, qApp->screens()) {
+    Q_FOREACH (auto item, qApp->screens()) {
         if(item != qApp->primaryScreen()){
             w = w + item->geometry().width()/qApp->primaryScreen()->devicePixelRatio();
         }
Index: indigo-src/indigo/core/indigo-core/layout/src/molecule_layout_macrocycle_lattice.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/layout/src/molecule_layout_macrocycle_lattice.cpp b/indigo-src/indigo/core/indigo-core/layout/src/molecule_layout_macrocycle_lattice.cpp
--- a/indigo-src/indigo/core/indigo-core/layout/src/molecule_layout_macrocycle_lattice.cpp	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/core/indigo-core/layout/src/molecule_layout_macrocycle_lattice.cpp	(date 1701847510205)
@@ -395,12 +395,12 @@
     _BORDER.set_empty();
 }
 
-TriangleLattice::TriangleLattice(rectangle rec, int rem, byte* data_link)
+TriangleLattice::TriangleLattice(rectangle rec, int rem, ::byte* data_link)
 {
     init(rec, rem, data_link);
 }
 
-void TriangleLattice::init(rectangle rec, int rem, byte* data_link)
+void TriangleLattice::init(rectangle rec, int rem, ::byte* data_link)
 {
     _BORDER = rec;
 
@@ -617,7 +617,7 @@
 
     _hidden_data_field_array.clear_resize(global_size);
 
-    byte* free_area = _hidden_data_field_array.ptr();
+    ::byte* free_area = _hidden_data_field_array.ptr();
 
     _lattices.clear();
 
Index: fluentui-src/fluentui/src/MainThread.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/MainThread.h b/fluentui-src/fluentui/src/MainThread.h
--- a/fluentui-src/fluentui/src/MainThread.h	(revision 7a1776407f72eb2fda567ab3e8a53b5687208da9)
+++ b/fluentui-src/fluentui/src/MainThread.h	(date 1701846975321)
@@ -13,7 +13,7 @@
     ~MainThread();
 private:
     static std::shared_ptr<MainThread> createShared(QObject* bindObject = nullptr);
-private slots:
+private Q_SLOTS:
     void mainThreadSlot(std::function<void()> func);
 private:
     MainThread(QObject* bindObject = nullptr);
Index: fluentui-src/fluentui/src/FluApp.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/FluApp.h b/fluentui-src/fluentui/src/FluApp.h
--- a/fluentui-src/fluentui/src/FluApp.h	(revision 7a1776407f72eb2fda567ab3e8a53b5687208da9)
+++ b/fluentui-src/fluentui/src/FluApp.h	(date 1701846975319)
@@ -3,7 +3,7 @@
 
 #include <QObject>
 #include <QWindow>
-#include <QtQml/qqml.h>
+#include <qqml.h>
 #include <QJsonArray>
 #include <QQmlContext>
 #include <QJsonObject>
Index: fluentui-src/fluentui/src/FluTextStyle.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/FluTextStyle.h b/fluentui-src/fluentui/src/FluTextStyle.h
--- a/fluentui-src/fluentui/src/FluTextStyle.h	(revision 7a1776407f72eb2fda567ab3e8a53b5687208da9)
+++ b/fluentui-src/fluentui/src/FluTextStyle.h	(date 1701846975320)
@@ -2,7 +2,7 @@
 #define FLUTEXTSTYLE_H
 
 #include <QObject>
-#include <QtQml/qqml.h>
+#include <qqml.h>
 #include <QFont>
 #include "stdafx.h"
 #include "singleton.h"
Index: maeparser-src/maeparser/MaeParserConfig.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/maeparser-src/maeparser/MaeParserConfig.hpp b/maeparser-src/maeparser/MaeParserConfig.hpp
--- a/maeparser-src/maeparser/MaeParserConfig.hpp	(revision bfa41f087a92b72370893c9b36758487a18dc6a0)
+++ b/maeparser-src/maeparser/MaeParserConfig.hpp	(date 1696647929026)
@@ -1,21 +1,7 @@
 #pragma once
 
-#ifndef STATIC_MAEPARSER
-
-#ifdef WIN32
-#ifdef IN_MAEPARSER
-#define EXPORT_MAEPARSER __declspec(dllexport)
-#else
-#define EXPORT_MAEPARSER __declspec(dllimport)
-#endif // IN_MAEPARSER
+#include <maeparser_export.hpp>
 
-#else
-
-#define EXPORT_MAEPARSER __attribute__((visibility("default")))
-#endif // WIN32
-
-#else
-
-#define EXPORT_MAEPARSER
-
-#endif // STATIC_MAEPARSER
+#ifndef EXPORT_MAEPARSER
+#define EXPORT_MAEPARSER MAEPARSER_EXPORT
+#endif
Index: fluentui-src/fluentui/src/Def.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/Def.h b/fluentui-src/fluentui/src/Def.h
--- a/fluentui-src/fluentui/src/Def.h	(revision 7a1776407f72eb2fda567ab3e8a53b5687208da9)
+++ b/fluentui-src/fluentui/src/Def.h	(date 1701846975318)
@@ -2,7 +2,7 @@
 #define DEF_H
 
 #include <QObject>
-#include <QtQml/qqml.h>
+#include <qqml.h>
 
 namespace FluViewModelType {
 Q_NAMESPACE
Index: fluentui-src/fluentui/src/FluColors.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/fluentui-src/fluentui/src/FluColors.h b/fluentui-src/fluentui/src/FluColors.h
--- a/fluentui-src/fluentui/src/FluColors.h	(revision 7a1776407f72eb2fda567ab3e8a53b5687208da9)
+++ b/fluentui-src/fluentui/src/FluColors.h	(date 1701846975319)
@@ -2,7 +2,7 @@
 #define FLUCOLORS_H
 
 #include <QObject>
-#include <QtQml/qqml.h>
+#include <qqml.h>
 #include "FluColorSet.h"
 #include "stdafx.h"
 #include "singleton.h"
Index: rdkit-src/rdkit/Code/RDGeneral/export.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/RDGeneral/export.h b/rdkit-src/rdkit/Code/RDGeneral/export.h
new file mode 100644
--- /dev/null	(date 1701851018129)
+++ b/rdkit-src/rdkit/Code/RDGeneral/export.h	(date 1701851018129)
@@ -0,0 +1,78 @@
+#pragma once
+
+#include <Abbreviations/rdkit_export.hpp>
+#include <Alignment/rdkit_export.hpp>
+#include <AvalonLib/rdkit_export.hpp>
+#include <Catalogs/rdkit_export.hpp>
+#include <ChemicalFeatures/rdkit_export.hpp>
+#include <ChemReactions/rdkit_export.hpp>
+#include <ChemTransforms/rdkit_export.hpp>
+#include <CIPLabeler/rdkit_export.hpp>
+#include <ConformerParser/rdkit_export.hpp>
+#include <DataStructs/rdkit_export.hpp>
+#include <Depictor/rdkit_export.hpp>
+#include <Deprotect/rdkit_export.hpp>
+#include <Descriptors/rdkit_export.hpp>
+#include <DetermineBonds/rdkit_export.hpp>
+#include <DistGeometry/rdkit_export.hpp>
+#include <DistGeomHelpers/rdkit_export.hpp>
+#include <EHTLIB/rdkit_export.hpp>
+#include <EigenSolvers/rdkit_export.hpp>
+#include <Features/rdkit_export.hpp>
+#include <FileParsers/rdkit_export.hpp>
+#include <FilterCatalog/rdkit_export.hpp>
+#include <Fingerprints/rdkit_export.hpp>
+#include <FMCS/rdkit_export.hpp>
+#include <ForceField/rdkit_export.hpp>
+#include <ForceFieldHelpers/rdkit_export.hpp>
+#include <FragCatalog/rdkit_export.hpp>
+#include <GeneralizedSubstruct/rdkit_export.hpp>
+#include <FreeSASALib/rdkit_export.hpp>
+#include <ga/rdkit_export.hpp>
+#include <GenericGroups/rdkit_export.hpp>
+#include <GraphMol/rdkit_export.hpp>
+#include <InfoTheory/rdkit_export.hpp>
+#include <MMPA/rdkit_export.hpp>
+#include <MolAlign/rdkit_export.hpp>
+#include <MolCatalog/rdkit_export.hpp>
+#include <MolChemicalFeatures/rdkit_export.hpp>
+#include <MolDraw2D/rdkit_export.hpp>
+#include <MolEnumerator/rdkit_export.hpp>
+#include <MolHash/rdkit_export.hpp>
+#include <MolInterchange/rdkit_export.hpp>
+#include <MolStandardize/rdkit_export.hpp>
+#include <MolTransforms/rdkit_export.hpp>
+#include <O3AAlign/rdkit_export.hpp>
+#include <Optimizer/rdkit_export.hpp>
+#include <PartialCharges/rdkit_export.hpp>
+#include <PBF/rdkit_export.hpp>
+#include <RDGeneral/rdkit_export.hpp>
+#include <RDGeometryLib/rdkit_export.hpp>
+#include <RDInchiLib/rdkit_export.hpp>
+#include <RDStreams/rdkit_export.hpp>
+#include <ReducedGraphs/rdkit_export.hpp>
+#include <RGroupDecomposition/rdkit_export.hpp>
+#include <ScaffoldNetwork/rdkit_export.hpp>
+#include <ShapeHelpers/rdkit_export.hpp>
+#include <SimDivPickers/rdkit_export.hpp>
+#include <SLNParse/rdkit_export.hpp>
+#include <SmilesParse/rdkit_export.hpp>
+#include <StructChecker/rdkit_export.hpp>
+#include <Subgraphs/rdkit_export.hpp>
+#include <SubstructLibrary/rdkit_export.hpp>
+#include <SubstructMatch/rdkit_export.hpp>
+#include <TautomerQuery/rdkit_export.hpp>
+#include <Trajectory/rdkit_export.hpp>
+
+#include <RDGeneral/RDConfig.h>
+
+#define RDKIT_EXPORT // unused
+
+#define RDKIT_INCHI_EXPORT RDKIT_EXPORT
+#define RDKIT_RDBOOST_EXPORT RDKIT_EXPORT
+#define RDKIT_RINGDECOMPOSERLIB_EXPORT RDKIT_EXPORT
+#define RDKIT_AVALON_CLIB_EXPORT RDKIT_EXPORT
+#define RDKIT_COORDGEN_EXPORT RDKIT_EXPORT
+#define RDKIT_FREESASA_CLIB_EXPORT RDKIT_EXPORT
+#define RDKIT_MAEPARSER_EXPORT RDKIT_EXPORT
+#define RDKIT_QUERY_EXPORT RDKIT_EXPORT
Index: svgpp-src/svgpp/include/svgpp/parser/number.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/parser/number.hpp b/svgpp-src/svgpp/include/svgpp/parser/number.hpp
--- a/svgpp-src/svgpp/include/svgpp/parser/number.hpp	(revision f460b2c7ceba92a875c0ba5c333826652863b396)
+++ b/svgpp-src/svgpp/include/svgpp/parser/number.hpp	(date 1696647929780)
@@ -15,7 +15,7 @@
 #include <svgpp/parser/detail/value_parser_parameters.hpp>
 #include <svgpp/parser/value_parser_fwd.hpp>
 #include <boost/spirit/include/qi.hpp>
-#include <boost/spirit/include/phoenix.hpp>
+#include <boost/phoenix.hpp>
 
 namespace svgpp { 
 
@@ -105,7 +105,7 @@
           number [phx::ref(value1) = _1] 
           >> -(
               comma_wsp 
-              >> number [phx::ref(value2) = _1, phx::ref(two_values) = true]
+              >> number [(phx::ref(value2) = _1, phx::ref(two_values) = true)]
               )
       ) && it == end)
     {
Index: svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_presentation_attributes.inc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_presentation_attributes.inc b/svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_presentation_attributes.inc
--- a/svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_presentation_attributes.inc	(revision f460b2c7ceba92a875c0ba5c333826652863b396)
+++ b/svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_presentation_attributes.inc	(date 1699257749241)
@@ -16,6 +16,9 @@
 SVGPP_ON(color_rendering)
 SVGPP_ON(color)
 SVGPP_ON(cursor)
+SVGPP_ON(data_c)
+SVGPP_ON(data_mjx_texclass)
+SVGPP_ON(data_mml_node)
 SVGPP_ON(direction)
 SVGPP_ON(display)
 SVGPP_ON(dominant_baseline)
Index: rdkit-src/rdkit/Code/RDGeneral/RDLog.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/rdkit-src/rdkit/Code/RDGeneral/RDLog.cpp b/rdkit-src/rdkit/Code/RDGeneral/RDLog.cpp
--- a/rdkit-src/rdkit/Code/RDGeneral/RDLog.cpp	(revision 068441957858f786c227825d90eb2c43f4f2b000)
+++ b/rdkit-src/rdkit/Code/RDGeneral/RDLog.cpp	(date 1701849536985)
@@ -25,9 +25,7 @@
 namespace RDLog {
 
 namespace {
-const std::vector<RDLogger *> allLogs = {&rdAppLog,     &rdDebugLog,
-                                         &rdInfoLog,    &rdErrorLog,
-                                         &rdWarningLog, &rdStatusLog};
+std::vector<RDLogger *> allLogs;
 }
 
 LogStateSetter::LogStateSetter() {
@@ -147,13 +145,18 @@
   rdInfoLog->df_enabled = false;
   rdWarningLog = std::make_shared<boost::logging::rdLogger>(&std::cerr);
   rdErrorLog = std::make_shared<boost::logging::rdLogger>(&std::cerr);
+  rdAppLog = rdInfoLog;
+  rdStatusLog = rdInfoLog;
+  allLogs = {&rdAppLog,     &rdDebugLog,
+             &rdInfoLog,    &rdErrorLog,
+             &rdWarningLog, &rdStatusLog};
 }
 
 std::ostream &toStream(std::ostream &logstrm) {
   char buffer[16];
   time_t t = time(nullptr);
 // localtime() is thread safe on windows, but not on *nix
-#ifdef WIN32
+#if defined(WIN32) || defined(__MINGW32__)
   strftime(buffer, 16, "[%T] ", localtime(&t));
 #else
   struct tm buf;
Index: protobuf-src/protobuf/src/google/protobuf/repeated_ptr_field.cc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/protobuf-src/protobuf/src/google/protobuf/repeated_ptr_field.cc b/protobuf-src/protobuf/src/google/protobuf/repeated_ptr_field.cc
--- a/protobuf-src/protobuf/src/google/protobuf/repeated_ptr_field.cc	(revision 7f94235e552599141950d7a4a3eaf93bc87d1b22)
+++ b/protobuf-src/protobuf/src/google/protobuf/repeated_ptr_field.cc	(date 1701960563055)
@@ -184,7 +184,7 @@
     char* PROTOBUF_RESTRICT, char* PROTOBUF_RESTRICT);

 template <>
-void RepeatedPtrFieldBase::MergeFrom<std::string>(
+PROTOBUF_EXPORT_TEMPLATE_DEFINE void RepeatedPtrFieldBase::MergeFrom<std::string>(
     const RepeatedPtrFieldBase& from) {
   ABSL_DCHECK_NE(&from, this);
   int new_size = current_size_ + from.current_size_;
Index: protobuf-src/protobuf/third_party/utf8_range/range2-sse.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/protobuf-src/protobuf/third_party/utf8_range/range2-sse.c b/protobuf-src/protobuf/third_party/utf8_range/range2-sse.c
--- a/protobuf-src/protobuf/third_party/utf8_range/range2-sse.c	(revision 7f94235e552599141950d7a4a3eaf93bc87d1b22)
+++ b/protobuf-src/protobuf/third_party/utf8_range/range2-sse.c	(date 1696647929595)
@@ -6,7 +6,7 @@

 #include <stdio.h>
 #include <stdint.h>
-#include <x86intrin.h>
+#include <smmintrin.h>

 int utf8_naive(const unsigned char *data, int len);

Index: protobuf-src/protobuf/src/google/protobuf/map_field.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/protobuf-src/protobuf/src/google/protobuf/map_field.h b/protobuf-src/protobuf/src/google/protobuf/map_field.h
--- a/protobuf-src/protobuf/src/google/protobuf/map_field.h	(revision 7f94235e552599141950d7a4a3eaf93bc87d1b22)
+++ b/protobuf-src/protobuf/src/google/protobuf/map_field.h	(date 1701951638974)
@@ -678,7 +678,7 @@
 template <typename Derived, typename Key, typename T,
           WireFormatLite::FieldType kKeyFieldType_,
           WireFormatLite::FieldType kValueFieldType_>
-constexpr MapFieldBase::VTable
+PROTOBUF_CONSTINIT const MapFieldBase::VTable
     MapField<Derived, Key, T, kKeyFieldType_, kValueFieldType_>::kVTable =
         MapField::template MakeVTable<MapField>();


Index: svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_all_attributes.inc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_all_attributes.inc b/svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_all_attributes.inc
--- a/svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_all_attributes.inc	(revision f460b2c7ceba92a875c0ba5c333826652863b396)
+++ b/svgpp-src/svgpp/include/svgpp/detail/dict/enumerate_all_attributes.inc	(date 1699257749241)
@@ -43,6 +43,9 @@
 SVGPP_ON      (cx                                 , cx)
 SVGPP_ON      (cy                                 , cy)
 SVGPP_ON      (d                                  , d)
+SVGPP_ON_STYLE(data_c                             , data-c)
+SVGPP_ON_STYLE(data_mjx_texclass                  , data-mjx-texclass)
+SVGPP_ON_STYLE(data_mml_node                      , data-mml-node)
 SVGPP_ON      (descent                            , descent)
 SVGPP_ON      (diffuseConstant                    , diffuseConstant)
 SVGPP_ON_STYLE(direction                          , direction)
Index: indigo-src/indigo/core/indigo-core/molecule/metadata_storage.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/indigo-src/indigo/core/indigo-core/molecule/metadata_storage.h b/indigo-src/indigo/core/indigo-core/molecule/metadata_storage.h
--- a/indigo-src/indigo/core/indigo-core/molecule/metadata_storage.h	(revision afaea530d740e666543510a1799bd9265d70385e)
+++ b/indigo-src/indigo/core/indigo-core/molecule/metadata_storage.h	(date 1701847510205)
@@ -21,13 +21,14 @@
 #include <cstdint>
 
 #include "base_cpp/ptr_array.h"
+#include <cstdint>
 
 namespace indigo
 {
     class MetaObject
     {
     public:
-        explicit MetaObject(uint32_t class_id) : _class_id(class_id)
+        explicit MetaObject(std::uint32_t class_id) : _class_id(class_id)
         {
         }
         uint32_t _class_id;
diff --git a/nodeeditor-src/nodeeditor/src/NodeDelegateModelRegistry.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeDelegateModelRegistry.cpp
rename from nodeeditor-src/nodeeditor/src/NodeDelegateModelRegistry.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeDelegateModelRegistry.cpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeState.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeState.cpp
rename from nodeeditor-src/nodeeditor/src/NodeState.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeState.cpp
diff --git a/nodeeditor-src/nodeeditor/src/DefaultHorizontalNodeGeometry.hpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultHorizontalNodeGeometry.hpp
rename from nodeeditor-src/nodeeditor/src/DefaultHorizontalNodeGeometry.hpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultHorizontalNodeGeometry.hpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeConnectionInteraction.hpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeConnectionInteraction.hpp
rename from nodeeditor-src/nodeeditor/src/NodeConnectionInteraction.hpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeConnectionInteraction.hpp
diff --git a/nodeeditor-src/nodeeditor/src/ConnectionStyle.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionStyle.cpp
rename from nodeeditor-src/nodeeditor/src/ConnectionStyle.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionStyle.cpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeConnectionInteraction.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeConnectionInteraction.cpp
rename from nodeeditor-src/nodeeditor/src/NodeConnectionInteraction.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeConnectionInteraction.cpp
diff --git a/nodeeditor-src/nodeeditor/src/ConnectionGraphicsObject.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionGraphicsObject.cpp
rename from nodeeditor-src/nodeeditor/src/ConnectionGraphicsObject.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionGraphicsObject.cpp
diff --git a/nodeeditor-src/nodeeditor/src/DefaultVerticalNodeGeometry.hpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultVerticalNodeGeometry.hpp
rename from nodeeditor-src/nodeeditor/src/DefaultVerticalNodeGeometry.hpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultVerticalNodeGeometry.hpp
diff --git a/nodeeditor-src/nodeeditor/src/StyleCollection.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/StyleCollection.cpp
rename from nodeeditor-src/nodeeditor/src/StyleCollection.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/StyleCollection.cpp
diff --git a/nodeeditor-src/nodeeditor/src/AbstractGraphModel.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/AbstractGraphModel.cpp
rename from nodeeditor-src/nodeeditor/src/AbstractGraphModel.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/AbstractGraphModel.cpp
diff --git a/nodeeditor-src/nodeeditor/src/AbstractNodeGeometry.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/AbstractNodeGeometry.cpp
rename from nodeeditor-src/nodeeditor/src/AbstractNodeGeometry.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/AbstractNodeGeometry.cpp
diff --git a/nodeeditor-src/nodeeditor/src/GraphicsViewStyle.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/GraphicsViewStyle.cpp
rename from nodeeditor-src/nodeeditor/src/GraphicsViewStyle.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/GraphicsViewStyle.cpp
diff --git a/nodeeditor-src/nodeeditor/src/DefaultVerticalNodeGeometry.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultVerticalNodeGeometry.cpp
rename from nodeeditor-src/nodeeditor/src/DefaultVerticalNodeGeometry.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultVerticalNodeGeometry.cpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeStyle.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeStyle.cpp
rename from nodeeditor-src/nodeeditor/src/NodeStyle.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeStyle.cpp
diff --git a/nodeeditor-src/nodeeditor/src/GraphicsView.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/GraphicsView.cpp
rename from nodeeditor-src/nodeeditor/src/GraphicsView.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/GraphicsView.cpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeGraphicsObject.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeGraphicsObject.cpp
rename from nodeeditor-src/nodeeditor/src/NodeGraphicsObject.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeGraphicsObject.cpp
diff --git a/nodeeditor-src/nodeeditor/src/Definitions.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/Definitions.cpp
rename from nodeeditor-src/nodeeditor/src/Definitions.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/Definitions.cpp
diff --git a/nodeeditor-src/nodeeditor/src/DefaultHorizontalNodeGeometry.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultHorizontalNodeGeometry.cpp
rename from nodeeditor-src/nodeeditor/src/DefaultHorizontalNodeGeometry.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultHorizontalNodeGeometry.cpp
diff --git a/nodeeditor-src/nodeeditor/src/ConnectionPainter.hpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionPainter.hpp
rename from nodeeditor-src/nodeeditor/src/ConnectionPainter.hpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionPainter.hpp
diff --git a/nodeeditor-src/nodeeditor/src/locateNode.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/locateNode.cpp
rename from nodeeditor-src/nodeeditor/src/locateNode.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/locateNode.cpp
diff --git a/nodeeditor-src/nodeeditor/src/ConnectionPainter.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionPainter.cpp
rename from nodeeditor-src/nodeeditor/src/ConnectionPainter.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionPainter.cpp
diff --git a/nodeeditor-src/nodeeditor/src/UndoCommands.hpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/UndoCommands.hpp
rename from nodeeditor-src/nodeeditor/src/UndoCommands.hpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/UndoCommands.hpp
diff --git a/nodeeditor-src/nodeeditor/src/BasicGraphicsScene.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/BasicGraphicsScene.cpp
rename from nodeeditor-src/nodeeditor/src/BasicGraphicsScene.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/BasicGraphicsScene.cpp
diff --git a/nodeeditor-src/nodeeditor/src/DefaultNodePainter.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultNodePainter.cpp
rename from nodeeditor-src/nodeeditor/src/DefaultNodePainter.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DefaultNodePainter.cpp
diff --git a/nodeeditor-src/nodeeditor/src/ConnectionState.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionState.cpp
rename from nodeeditor-src/nodeeditor/src/ConnectionState.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/ConnectionState.cpp
diff --git a/nodeeditor-src/nodeeditor/src/UndoCommands.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/UndoCommands.cpp
rename from nodeeditor-src/nodeeditor/src/UndoCommands.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/UndoCommands.cpp
diff --git a/nodeeditor-src/nodeeditor/src/NodeDelegateModel.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeDelegateModel.cpp
rename from nodeeditor-src/nodeeditor/src/NodeDelegateModel.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/NodeDelegateModel.cpp
diff --git a/nodeeditor-src/nodeeditor/src/DataFlowGraphicsScene.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DataFlowGraphicsScene.cpp
rename from nodeeditor-src/nodeeditor/src/DataFlowGraphicsScene.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DataFlowGraphicsScene.cpp
diff --git a/nodeeditor-src/nodeeditor/src/DataFlowGraphModel.cpp b/nodeeditor-src/nodeeditor/include/QtNodes/internal/DataFlowGraphModel.cpp
rename from nodeeditor-src/nodeeditor/src/DataFlowGraphModel.cpp
rename to nodeeditor-src/nodeeditor/include/QtNodes/internal/DataFlowGraphModel.cpp
