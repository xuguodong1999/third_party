// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: opencv-onnx.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_opencv_2donnx_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_opencv_2donnx_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_opencv_2donnx_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_opencv_2donnx_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_opencv_2donnx_2eproto;
namespace opencv_onnx {
class AttributeProto;
struct AttributeProtoDefaultTypeInternal;
extern AttributeProtoDefaultTypeInternal _AttributeProto_default_instance_;
class GraphProto;
struct GraphProtoDefaultTypeInternal;
extern GraphProtoDefaultTypeInternal _GraphProto_default_instance_;
class ModelProto;
struct ModelProtoDefaultTypeInternal;
extern ModelProtoDefaultTypeInternal _ModelProto_default_instance_;
class NodeProto;
struct NodeProtoDefaultTypeInternal;
extern NodeProtoDefaultTypeInternal _NodeProto_default_instance_;
class OperatorSetIdProto;
struct OperatorSetIdProtoDefaultTypeInternal;
extern OperatorSetIdProtoDefaultTypeInternal _OperatorSetIdProto_default_instance_;
class StringStringEntryProto;
struct StringStringEntryProtoDefaultTypeInternal;
extern StringStringEntryProtoDefaultTypeInternal _StringStringEntryProto_default_instance_;
class TensorProto;
struct TensorProtoDefaultTypeInternal;
extern TensorProtoDefaultTypeInternal _TensorProto_default_instance_;
class TensorProto_Segment;
struct TensorProto_SegmentDefaultTypeInternal;
extern TensorProto_SegmentDefaultTypeInternal _TensorProto_Segment_default_instance_;
class TensorShapeProto;
struct TensorShapeProtoDefaultTypeInternal;
extern TensorShapeProtoDefaultTypeInternal _TensorShapeProto_default_instance_;
class TensorShapeProto_Dimension;
struct TensorShapeProto_DimensionDefaultTypeInternal;
extern TensorShapeProto_DimensionDefaultTypeInternal _TensorShapeProto_Dimension_default_instance_;
class TypeProto;
struct TypeProtoDefaultTypeInternal;
extern TypeProtoDefaultTypeInternal _TypeProto_default_instance_;
class TypeProto_Tensor;
struct TypeProto_TensorDefaultTypeInternal;
extern TypeProto_TensorDefaultTypeInternal _TypeProto_Tensor_default_instance_;
class ValueInfoProto;
struct ValueInfoProtoDefaultTypeInternal;
extern ValueInfoProtoDefaultTypeInternal _ValueInfoProto_default_instance_;
}  // namespace opencv_onnx
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace opencv_onnx {
enum AttributeProto_AttributeType : int {
  AttributeProto_AttributeType_UNDEFINED = 0,
  AttributeProto_AttributeType_FLOAT = 1,
  AttributeProto_AttributeType_INT = 2,
  AttributeProto_AttributeType_STRING = 3,
  AttributeProto_AttributeType_TENSOR = 4,
  AttributeProto_AttributeType_GRAPH = 5,
  AttributeProto_AttributeType_FLOATS = 6,
  AttributeProto_AttributeType_INTS = 7,
  AttributeProto_AttributeType_STRINGS = 8,
  AttributeProto_AttributeType_TENSORS = 9,
  AttributeProto_AttributeType_GRAPHS = 10,
};

bool AttributeProto_AttributeType_IsValid(int value);
extern const uint32_t AttributeProto_AttributeType_internal_data_[];
constexpr AttributeProto_AttributeType AttributeProto_AttributeType_AttributeType_MIN = static_cast<AttributeProto_AttributeType>(0);
constexpr AttributeProto_AttributeType AttributeProto_AttributeType_AttributeType_MAX = static_cast<AttributeProto_AttributeType>(10);
constexpr int AttributeProto_AttributeType_AttributeType_ARRAYSIZE = 10 + 1;
const ::google::protobuf::EnumDescriptor*
AttributeProto_AttributeType_descriptor();
template <typename T>
const std::string& AttributeProto_AttributeType_Name(T value) {
  static_assert(std::is_same<T, AttributeProto_AttributeType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AttributeType_Name().");
  return AttributeProto_AttributeType_Name(static_cast<AttributeProto_AttributeType>(value));
}
template <>
inline const std::string& AttributeProto_AttributeType_Name(AttributeProto_AttributeType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AttributeProto_AttributeType_descriptor,
                                                 0, 10>(
      static_cast<int>(value));
}
inline bool AttributeProto_AttributeType_Parse(absl::string_view name, AttributeProto_AttributeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AttributeProto_AttributeType>(
      AttributeProto_AttributeType_descriptor(), name, value);
}
enum TensorProto_DataType : int {
  TensorProto_DataType_UNDEFINED = 0,
  TensorProto_DataType_FLOAT = 1,
  TensorProto_DataType_UINT8 = 2,
  TensorProto_DataType_INT8 = 3,
  TensorProto_DataType_UINT16 = 4,
  TensorProto_DataType_INT16 = 5,
  TensorProto_DataType_INT32 = 6,
  TensorProto_DataType_INT64 = 7,
  TensorProto_DataType_STRING = 8,
  TensorProto_DataType_BOOL = 9,
  TensorProto_DataType_FLOAT16 = 10,
  TensorProto_DataType_DOUBLE = 11,
  TensorProto_DataType_UINT32 = 12,
  TensorProto_DataType_UINT64 = 13,
  TensorProto_DataType_COMPLEX64 = 14,
  TensorProto_DataType_COMPLEX128 = 15,
};

bool TensorProto_DataType_IsValid(int value);
extern const uint32_t TensorProto_DataType_internal_data_[];
constexpr TensorProto_DataType TensorProto_DataType_DataType_MIN = static_cast<TensorProto_DataType>(0);
constexpr TensorProto_DataType TensorProto_DataType_DataType_MAX = static_cast<TensorProto_DataType>(15);
constexpr int TensorProto_DataType_DataType_ARRAYSIZE = 15 + 1;
const ::google::protobuf::EnumDescriptor*
TensorProto_DataType_descriptor();
template <typename T>
const std::string& TensorProto_DataType_Name(T value) {
  static_assert(std::is_same<T, TensorProto_DataType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to DataType_Name().");
  return TensorProto_DataType_Name(static_cast<TensorProto_DataType>(value));
}
template <>
inline const std::string& TensorProto_DataType_Name(TensorProto_DataType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<TensorProto_DataType_descriptor,
                                                 0, 15>(
      static_cast<int>(value));
}
inline bool TensorProto_DataType_Parse(absl::string_view name, TensorProto_DataType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TensorProto_DataType>(
      TensorProto_DataType_descriptor(), name, value);
}
enum Version : int {
  _START_VERSION = 0,
  IR_VERSION_2017_10_10 = 1,
  IR_VERSION_2017_10_30 = 2,
  IR_VERSION = 3,
};

bool Version_IsValid(int value);
extern const uint32_t Version_internal_data_[];
constexpr Version Version_MIN = static_cast<Version>(0);
constexpr Version Version_MAX = static_cast<Version>(3);
constexpr int Version_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Version_descriptor();
template <typename T>
const std::string& Version_Name(T value) {
  static_assert(std::is_same<T, Version>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Version_Name().");
  return Version_Name(static_cast<Version>(value));
}
template <>
inline const std::string& Version_Name(Version value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Version_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Version_Parse(absl::string_view name, Version* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Version>(
      Version_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class TensorShapeProto_Dimension final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:opencv_onnx.TensorShapeProto.Dimension) */ {
 public:
  inline TensorShapeProto_Dimension() : TensorShapeProto_Dimension(nullptr) {}
  ~TensorShapeProto_Dimension() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TensorShapeProto_Dimension(::google::protobuf::internal::ConstantInitialized);

  inline TensorShapeProto_Dimension(const TensorShapeProto_Dimension& from)
      : TensorShapeProto_Dimension(nullptr, from) {}
  TensorShapeProto_Dimension(TensorShapeProto_Dimension&& from) noexcept
    : TensorShapeProto_Dimension() {
    *this = ::std::move(from);
  }

  inline TensorShapeProto_Dimension& operator=(const TensorShapeProto_Dimension& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorShapeProto_Dimension& operator=(TensorShapeProto_Dimension&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TensorShapeProto_Dimension& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kDimValue = 1,
    kDimParam = 2,
    VALUE_NOT_SET = 0,
  };

  static inline const TensorShapeProto_Dimension* internal_default_instance() {
    return reinterpret_cast<const TensorShapeProto_Dimension*>(
               &_TensorShapeProto_Dimension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TensorShapeProto_Dimension& a, TensorShapeProto_Dimension& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorShapeProto_Dimension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TensorShapeProto_Dimension* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TensorShapeProto_Dimension* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TensorShapeProto_Dimension>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TensorShapeProto_Dimension& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TensorShapeProto_Dimension& from) {
    TensorShapeProto_Dimension::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TensorShapeProto_Dimension* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "opencv_onnx.TensorShapeProto.Dimension";
  }
  protected:
  explicit TensorShapeProto_Dimension(::google::protobuf::Arena* arena);
  TensorShapeProto_Dimension(::google::protobuf::Arena* arena, const TensorShapeProto_Dimension& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDenotationFieldNumber = 3,
    kDimValueFieldNumber = 1,
    kDimParamFieldNumber = 2,
  };
  // optional string denotation = 3;
  bool has_denotation() const;
  void clear_denotation() ;
  const std::string& denotation() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_denotation(Arg_&& arg, Args_... args);
  std::string* mutable_denotation();
  PROTOBUF_NODISCARD std::string* release_denotation();
  void set_allocated_denotation(std::string* value);

  private:
  const std::string& _internal_denotation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denotation(
      const std::string& value);
  std::string* _internal_mutable_denotation();

  public:
  // int64 dim_value = 1;
  bool has_dim_value() const;
  void clear_dim_value() ;
  ::int64_t dim_value() const;
  void set_dim_value(::int64_t value);

  private:
  ::int64_t _internal_dim_value() const;
  void _internal_set_dim_value(::int64_t value);

  public:
  // string dim_param = 2;
  bool has_dim_param() const;
  void clear_dim_param() ;
  const std::string& dim_param() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_dim_param(Arg_&& arg, Args_... args);
  std::string* mutable_dim_param();
  PROTOBUF_NODISCARD std::string* release_dim_param();
  void set_allocated_dim_param(std::string* value);

  private:
  const std::string& _internal_dim_param() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dim_param(
      const std::string& value);
  std::string* _internal_mutable_dim_param();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:opencv_onnx.TensorShapeProto.Dimension)
 private:
  class _Internal;
  void set_has_dim_value();
  void set_has_dim_param();

  inline bool has_value() const;
  inline void clear_has_value();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 0,
      66, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr denotation_;
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int64_t dim_value_;
      ::google::protobuf::internal::ArenaStringPtr dim_param_;
    } value_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_opencv_2donnx_2eproto;
};// -------------------------------------------------------------------

class TensorProto_Segment final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:opencv_onnx.TensorProto.Segment) */ {
 public:
  inline TensorProto_Segment() : TensorProto_Segment(nullptr) {}
  ~TensorProto_Segment() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TensorProto_Segment(::google::protobuf::internal::ConstantInitialized);

  inline TensorProto_Segment(const TensorProto_Segment& from)
      : TensorProto_Segment(nullptr, from) {}
  TensorProto_Segment(TensorProto_Segment&& from) noexcept
    : TensorProto_Segment() {
    *this = ::std::move(from);
  }

  inline TensorProto_Segment& operator=(const TensorProto_Segment& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorProto_Segment& operator=(TensorProto_Segment&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TensorProto_Segment& default_instance() {
    return *internal_default_instance();
  }
  static inline const TensorProto_Segment* internal_default_instance() {
    return reinterpret_cast<const TensorProto_Segment*>(
               &_TensorProto_Segment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TensorProto_Segment& a, TensorProto_Segment& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorProto_Segment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TensorProto_Segment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TensorProto_Segment* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TensorProto_Segment>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TensorProto_Segment& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TensorProto_Segment& from) {
    TensorProto_Segment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TensorProto_Segment* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "opencv_onnx.TensorProto.Segment";
  }
  protected:
  explicit TensorProto_Segment(::google::protobuf::Arena* arena);
  TensorProto_Segment(::google::protobuf::Arena* arena, const TensorProto_Segment& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBeginFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // optional int64 begin = 1;
  bool has_begin() const;
  void clear_begin() ;
  ::int64_t begin() const;
  void set_begin(::int64_t value);

  private:
  ::int64_t _internal_begin() const;
  void _internal_set_begin(::int64_t value);

  public:
  // optional int64 end = 2;
  bool has_end() const;
  void clear_end() ;
  ::int64_t end() const;
  void set_end(::int64_t value);

  private:
  ::int64_t _internal_end() const;
  void _internal_set_end(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:opencv_onnx.TensorProto.Segment)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t begin_;
    ::int64_t end_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_opencv_2donnx_2eproto;
};// -------------------------------------------------------------------

class StringStringEntryProto final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:opencv_onnx.StringStringEntryProto) */ {
 public:
  inline StringStringEntryProto() : StringStringEntryProto(nullptr) {}
  ~StringStringEntryProto() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR StringStringEntryProto(::google::protobuf::internal::ConstantInitialized);

  inline StringStringEntryProto(const StringStringEntryProto& from)
      : StringStringEntryProto(nullptr, from) {}
  StringStringEntryProto(StringStringEntryProto&& from) noexcept
    : StringStringEntryProto() {
    *this = ::std::move(from);
  }

  inline StringStringEntryProto& operator=(const StringStringEntryProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringStringEntryProto& operator=(StringStringEntryProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringStringEntryProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringStringEntryProto* internal_default_instance() {
    return reinterpret_cast<const StringStringEntryProto*>(
               &_StringStringEntryProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StringStringEntryProto& a, StringStringEntryProto& b) {
    a.Swap(&b);
  }
  inline void Swap(StringStringEntryProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringStringEntryProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringStringEntryProto* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringStringEntryProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StringStringEntryProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const StringStringEntryProto& from) {
    StringStringEntryProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StringStringEntryProto* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "opencv_onnx.StringStringEntryProto";
  }
  protected:
  explicit StringStringEntryProto(::google::protobuf::Arena* arena);
  StringStringEntryProto(::google::protobuf::Arena* arena, const StringStringEntryProto& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // optional string key = 1;
  bool has_key() const;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // optional string value = 2;
  bool has_value() const;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:opencv_onnx.StringStringEntryProto)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      51, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_opencv_2donnx_2eproto;
};// -------------------------------------------------------------------

class OperatorSetIdProto final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:opencv_onnx.OperatorSetIdProto) */ {
 public:
  inline OperatorSetIdProto() : OperatorSetIdProto(nullptr) {}
  ~OperatorSetIdProto() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OperatorSetIdProto(::google::protobuf::internal::ConstantInitialized);

  inline OperatorSetIdProto(const OperatorSetIdProto& from)
      : OperatorSetIdProto(nullptr, from) {}
  OperatorSetIdProto(OperatorSetIdProto&& from) noexcept
    : OperatorSetIdProto() {
    *this = ::std::move(from);
  }

  inline OperatorSetIdProto& operator=(const OperatorSetIdProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperatorSetIdProto& operator=(OperatorSetIdProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OperatorSetIdProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const OperatorSetIdProto* internal_default_instance() {
    return reinterpret_cast<const OperatorSetIdProto*>(
               &_OperatorSetIdProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(OperatorSetIdProto& a, OperatorSetIdProto& b) {
    a.Swap(&b);
  }
  inline void Swap(OperatorSetIdProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OperatorSetIdProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OperatorSetIdProto* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OperatorSetIdProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OperatorSetIdProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const OperatorSetIdProto& from) {
    OperatorSetIdProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OperatorSetIdProto* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "opencv_onnx.OperatorSetIdProto";
  }
  protected:
  explicit OperatorSetIdProto(::google::protobuf::Arena* arena);
  OperatorSetIdProto(::google::protobuf::Arena* arena, const OperatorSetIdProto& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDomainFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // optional string domain = 1;
  bool has_domain() const;
  void clear_domain() ;
  const std::string& domain() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_domain(Arg_&& arg, Args_... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* value);

  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(
      const std::string& value);
  std::string* _internal_mutable_domain();

  public:
  // optional int64 version = 2;
  bool has_version() const;
  void clear_version() ;
  ::int64_t version() const;
  void set_version(::int64_t value);

  private:
  ::int64_t _internal_version() const;
  void _internal_set_version(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:opencv_onnx.OperatorSetIdProto)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr domain_;
    ::int64_t version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_opencv_2donnx_2eproto;
};// -------------------------------------------------------------------

class TensorShapeProto final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:opencv_onnx.TensorShapeProto) */ {
 public:
  inline TensorShapeProto() : TensorShapeProto(nullptr) {}
  ~TensorShapeProto() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TensorShapeProto(::google::protobuf::internal::ConstantInitialized);

  inline TensorShapeProto(const TensorShapeProto& from)
      : TensorShapeProto(nullptr, from) {}
  TensorShapeProto(TensorShapeProto&& from) noexcept
    : TensorShapeProto() {
    *this = ::std::move(from);
  }

  inline TensorShapeProto& operator=(const TensorShapeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorShapeProto& operator=(TensorShapeProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TensorShapeProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const TensorShapeProto* internal_default_instance() {
    return reinterpret_cast<const TensorShapeProto*>(
               &_TensorShapeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TensorShapeProto& a, TensorShapeProto& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorShapeProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TensorShapeProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TensorShapeProto* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TensorShapeProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TensorShapeProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TensorShapeProto& from) {
    TensorShapeProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TensorShapeProto* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "opencv_onnx.TensorShapeProto";
  }
  protected:
  explicit TensorShapeProto(::google::protobuf::Arena* arena);
  TensorShapeProto(::google::protobuf::Arena* arena, const TensorShapeProto& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Dimension = TensorShapeProto_Dimension;

  // accessors -------------------------------------------------------

  enum : int {
    kDimFieldNumber = 1,
  };
  // repeated .opencv_onnx.TensorShapeProto.Dimension dim = 1;
  int dim_size() const;
  private:
  int _internal_dim_size() const;

  public:
  void clear_dim() ;
  ::opencv_onnx::TensorShapeProto_Dimension* mutable_dim(int index);
  ::google::protobuf::RepeatedPtrField< ::opencv_onnx::TensorShapeProto_Dimension >*
      mutable_dim();
  private:
  const ::google::protobuf::RepeatedPtrField<::opencv_onnx::TensorShapeProto_Dimension>& _internal_dim() const;
  ::google::protobuf::RepeatedPtrField<::opencv_onnx::TensorShapeProto_Dimension>* _internal_mutable_dim();
  public:
  const ::opencv_onnx::TensorShapeProto_Dimension& dim(int index) const;
  ::opencv_onnx::TensorShapeProto_Dimension* add_dim();
  const ::google::protobuf::RepeatedPtrField< ::opencv_onnx::TensorShapeProto_Dimension >&
      dim() const;
  // @@protoc_insertion_point(class_scope:opencv_onnx.TensorShapeProto)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::opencv_onnx::TensorShapeProto_Dimension > dim_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_opencv_2donnx_2eproto;
};// -------------------------------------------------------------------

class TensorProto final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:opencv_onnx.TensorProto) */ {
 public:
  inline TensorProto() : TensorProto(nullptr) {}
  ~TensorProto() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TensorProto(::google::protobuf::internal::ConstantInitialized);

  inline TensorProto(const TensorProto& from)
      : TensorProto(nullptr, from) {}
  TensorProto(TensorProto&& from) noexcept
    : TensorProto() {
    *this = ::std::move(from);
  }

  inline TensorProto& operator=(const TensorProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorProto& operator=(TensorProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TensorProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const TensorProto* internal_default_instance() {
    return reinterpret_cast<const TensorProto*>(
               &_TensorProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TensorProto& a, TensorProto& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TensorProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TensorProto* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TensorProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TensorProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TensorProto& from) {
    TensorProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TensorProto* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "opencv_onnx.TensorProto";
  }
  protected:
  explicit TensorProto(::google::protobuf::Arena* arena);
  TensorProto(::google::protobuf::Arena* arena, const TensorProto& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Segment = TensorProto_Segment;

  using DataType = TensorProto_DataType;
  static constexpr DataType UNDEFINED = TensorProto_DataType_UNDEFINED;
  static constexpr DataType FLOAT = TensorProto_DataType_FLOAT;
  static constexpr DataType UINT8 = TensorProto_DataType_UINT8;
  static constexpr DataType INT8 = TensorProto_DataType_INT8;
  static constexpr DataType UINT16 = TensorProto_DataType_UINT16;
  static constexpr DataType INT16 = TensorProto_DataType_INT16;
  static constexpr DataType INT32 = TensorProto_DataType_INT32;
  static constexpr DataType INT64 = TensorProto_DataType_INT64;
  static constexpr DataType STRING = TensorProto_DataType_STRING;
  static constexpr DataType BOOL = TensorProto_DataType_BOOL;
  static constexpr DataType FLOAT16 = TensorProto_DataType_FLOAT16;
  static constexpr DataType DOUBLE = TensorProto_DataType_DOUBLE;
  static constexpr DataType UINT32 = TensorProto_DataType_UINT32;
  static constexpr DataType UINT64 = TensorProto_DataType_UINT64;
  static constexpr DataType COMPLEX64 = TensorProto_DataType_COMPLEX64;
  static constexpr DataType COMPLEX128 = TensorProto_DataType_COMPLEX128;
  static inline bool DataType_IsValid(int value) {
    return TensorProto_DataType_IsValid(value);
  }
  static constexpr DataType DataType_MIN = TensorProto_DataType_DataType_MIN;
  static constexpr DataType DataType_MAX = TensorProto_DataType_DataType_MAX;
  static constexpr int DataType_ARRAYSIZE = TensorProto_DataType_DataType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* DataType_descriptor() {
    return TensorProto_DataType_descriptor();
  }
  template <typename T>
  static inline const std::string& DataType_Name(T value) {
    return TensorProto_DataType_Name(value);
  }
  static inline bool DataType_Parse(absl::string_view name, DataType* value) {
    return TensorProto_DataType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDimsFieldNumber = 1,
    kFloatDataFieldNumber = 4,
    kInt32DataFieldNumber = 5,
    kStringDataFieldNumber = 6,
    kInt64DataFieldNumber = 7,
    kDoubleDataFieldNumber = 10,
    kUint64DataFieldNumber = 11,
    kNameFieldNumber = 8,
    kRawDataFieldNumber = 9,
    kDocStringFieldNumber = 12,
    kSegmentFieldNumber = 3,
    kDataTypeFieldNumber = 2,
  };
  // repeated int64 dims = 1;
  int dims_size() const;
  private:
  int _internal_dims_size() const;

  public:
  void clear_dims() ;
  ::int64_t dims(int index) const;
  void set_dims(int index, ::int64_t value);
  void add_dims(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& dims() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_dims();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_dims() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_dims();

  public:
  // repeated float float_data = 4 [packed = true];
  int float_data_size() const;
  private:
  int _internal_float_data_size() const;

  public:
  void clear_float_data() ;
  float float_data(int index) const;
  void set_float_data(int index, float value);
  void add_float_data(float value);
  const ::google::protobuf::RepeatedField<float>& float_data() const;
  ::google::protobuf::RepeatedField<float>* mutable_float_data();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_float_data() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_float_data();

  public:
  // repeated int32 int32_data = 5 [packed = true];
  int int32_data_size() const;
  private:
  int _internal_int32_data_size() const;

  public:
  void clear_int32_data() ;
  ::int32_t int32_data(int index) const;
  void set_int32_data(int index, ::int32_t value);
  void add_int32_data(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& int32_data() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_int32_data();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_int32_data() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_int32_data();

  public:
  // repeated bytes string_data = 6;
  int string_data_size() const;
  private:
  int _internal_string_data_size() const;

  public:
  void clear_string_data() ;
  const std::string& string_data(int index) const;
  std::string* mutable_string_data(int index);
  void set_string_data(int index, const std::string& value);
  void set_string_data(int index, std::string&& value);
  void set_string_data(int index, const char* value);
  void set_string_data(int index, const void* value, std::size_t size);
  void set_string_data(int index, absl::string_view value);
  std::string* add_string_data();
  void add_string_data(const std::string& value);
  void add_string_data(std::string&& value);
  void add_string_data(const char* value);
  void add_string_data(const void* value, std::size_t size);
  void add_string_data(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& string_data() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_string_data();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_string_data() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_string_data();

  public:
  // repeated int64 int64_data = 7 [packed = true];
  int int64_data_size() const;
  private:
  int _internal_int64_data_size() const;

  public:
  void clear_int64_data() ;
  ::int64_t int64_data(int index) const;
  void set_int64_data(int index, ::int64_t value);
  void add_int64_data(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& int64_data() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_int64_data();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_int64_data() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_int64_data();

  public:
  // repeated double double_data = 10 [packed = true];
  int double_data_size() const;
  private:
  int _internal_double_data_size() const;

  public:
  void clear_double_data() ;
  double double_data(int index) const;
  void set_double_data(int index, double value);
  void add_double_data(double value);
  const ::google::protobuf::RepeatedField<double>& double_data() const;
  ::google::protobuf::RepeatedField<double>* mutable_double_data();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_double_data() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_double_data();

  public:
  // repeated uint64 uint64_data = 11 [packed = true];
  int uint64_data_size() const;
  private:
  int _internal_uint64_data_size() const;

  public:
  void clear_uint64_data() ;
  ::uint64_t uint64_data(int index) const;
  void set_uint64_data(int index, ::uint64_t value);
  void add_uint64_data(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& uint64_data() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_uint64_data();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_uint64_data() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_uint64_data();

  public:
  // optional string name = 8;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional bytes raw_data = 9;
  bool has_raw_data() const;
  void clear_raw_data() ;
  const std::string& raw_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_raw_data(Arg_&& arg, Args_... args);
  std::string* mutable_raw_data();
  PROTOBUF_NODISCARD std::string* release_raw_data();
  void set_allocated_raw_data(std::string* value);

  private:
  const std::string& _internal_raw_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_data(
      const std::string& value);
  std::string* _internal_mutable_raw_data();

  public:
  // optional string doc_string = 12;
  bool has_doc_string() const;
  void clear_doc_string() ;
  const std::string& doc_string() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_doc_string(Arg_&& arg, Args_... args);
  std::string* mutable_doc_string();
  PROTOBUF_NODISCARD std::string* release_doc_string();
  void set_allocated_doc_string(std::string* value);

  private:
  const std::string& _internal_doc_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_doc_string(
      const std::string& value);
  std::string* _internal_mutable_doc_string();

  public:
  // optional .opencv_onnx.TensorProto.Segment segment = 3;
  bool has_segment() const;
  void clear_segment() ;
  const ::opencv_onnx::TensorProto_Segment& segment() const;
  PROTOBUF_NODISCARD ::opencv_onnx::TensorProto_Segment* release_segment();
  ::opencv_onnx::TensorProto_Segment* mutable_segment();
  void set_allocated_segment(::opencv_onnx::TensorProto_Segment* value);
  void unsafe_arena_set_allocated_segment(::opencv_onnx::TensorProto_Segment* value);
  ::opencv_onnx::TensorProto_Segment* unsafe_arena_release_segment();

  private:
  const ::opencv_onnx::TensorProto_Segment& _internal_segment() const;
  ::opencv_onnx::TensorProto_Segment* _internal_mutable_segment();

  public:
  // optional .opencv_onnx.TensorProto.DataType data_type = 2;
  bool has_data_type() const;
  void clear_data_type() ;
  ::opencv_onnx::TensorProto_DataType data_type() const;
  void set_data_type(::opencv_onnx::TensorProto_DataType value);

  private:
  ::opencv_onnx::TensorProto_DataType _internal_data_type() const;
  void _internal_set_data_type(::opencv_onnx::TensorProto_DataType value);

  public:
  // @@protoc_insertion_point(class_scope:opencv_onnx.TensorProto)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 12, 2,
      54, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> dims_;
    ::google::protobuf::RepeatedField<float> float_data_;
    ::google::protobuf::RepeatedField<::int32_t> int32_data_;
    mutable ::google::protobuf::internal::CachedSize _int32_data_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField<std::string> string_data_;
    ::google::protobuf::RepeatedField<::int64_t> int64_data_;
    mutable ::google::protobuf::internal::CachedSize _int64_data_cached_byte_size_;
    ::google::protobuf::RepeatedField<double> double_data_;
    ::google::protobuf::RepeatedField<::uint64_t> uint64_data_;
    mutable ::google::protobuf::internal::CachedSize _uint64_data_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr raw_data_;
    ::google::protobuf::internal::ArenaStringPtr doc_string_;
    ::opencv_onnx::TensorProto_Segment* segment_;
    int data_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_opencv_2donnx_2eproto;
};// -------------------------------------------------------------------

class TypeProto_Tensor final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:opencv_onnx.TypeProto.Tensor) */ {
 public:
  inline TypeProto_Tensor() : TypeProto_Tensor(nullptr) {}
  ~TypeProto_Tensor() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TypeProto_Tensor(::google::protobuf::internal::ConstantInitialized);

  inline TypeProto_Tensor(const TypeProto_Tensor& from)
      : TypeProto_Tensor(nullptr, from) {}
  TypeProto_Tensor(TypeProto_Tensor&& from) noexcept
    : TypeProto_Tensor() {
    *this = ::std::move(from);
  }

  inline TypeProto_Tensor& operator=(const TypeProto_Tensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeProto_Tensor& operator=(TypeProto_Tensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeProto_Tensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const TypeProto_Tensor* internal_default_instance() {
    return reinterpret_cast<const TypeProto_Tensor*>(
               &_TypeProto_Tensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TypeProto_Tensor& a, TypeProto_Tensor& b) {
    a.Swap(&b);
  }
  inline void Swap(TypeProto_Tensor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeProto_Tensor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeProto_Tensor* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TypeProto_Tensor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TypeProto_Tensor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TypeProto_Tensor& from) {
    TypeProto_Tensor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TypeProto_Tensor* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "opencv_onnx.TypeProto.Tensor";
  }
  protected:
  explicit TypeProto_Tensor(::google::protobuf::Arena* arena);
  TypeProto_Tensor(::google::protobuf::Arena* arena, const TypeProto_Tensor& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapeFieldNumber = 2,
    kElemTypeFieldNumber = 1,
  };
  // optional .opencv_onnx.TensorShapeProto shape = 2;
  bool has_shape() const;
  void clear_shape() ;
  const ::opencv_onnx::TensorShapeProto& shape() const;
  PROTOBUF_NODISCARD ::opencv_onnx::TensorShapeProto* release_shape();
  ::opencv_onnx::TensorShapeProto* mutable_shape();
  void set_allocated_shape(::opencv_onnx::TensorShapeProto* value);
  void unsafe_arena_set_allocated_shape(::opencv_onnx::TensorShapeProto* value);
  ::opencv_onnx::TensorShapeProto* unsafe_arena_release_shape();

  private:
  const ::opencv_onnx::TensorShapeProto& _internal_shape() const;
  ::opencv_onnx::TensorShapeProto* _internal_mutable_shape();

  public:
  // optional .opencv_onnx.TensorProto.DataType elem_type = 1;
  bool has_elem_type() const;
  void clear_elem_type() ;
  ::opencv_onnx::TensorProto_DataType elem_type() const;
  void set_elem_type(::opencv_onnx::TensorProto_DataType value);

  private:
  ::opencv_onnx::TensorProto_DataType _internal_elem_type() const;
  void _internal_set_elem_type(::opencv_onnx::TensorProto_DataType value);

  public:
  // @@protoc_insertion_point(class_scope:opencv_onnx.TypeProto.Tensor)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::opencv_onnx::TensorShapeProto* shape_;
    int elem_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_opencv_2donnx_2eproto;
};// -------------------------------------------------------------------

class TypeProto final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:opencv_onnx.TypeProto) */ {
 public:
  inline TypeProto() : TypeProto(nullptr) {}
  ~TypeProto() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TypeProto(::google::protobuf::internal::ConstantInitialized);

  inline TypeProto(const TypeProto& from)
      : TypeProto(nullptr, from) {}
  TypeProto(TypeProto&& from) noexcept
    : TypeProto() {
    *this = ::std::move(from);
  }

  inline TypeProto& operator=(const TypeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TypeProto& operator=(TypeProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TypeProto& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kTensorType = 1,
    VALUE_NOT_SET = 0,
  };

  static inline const TypeProto* internal_default_instance() {
    return reinterpret_cast<const TypeProto*>(
               &_TypeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TypeProto& a, TypeProto& b) {
    a.Swap(&b);
  }
  inline void Swap(TypeProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TypeProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TypeProto* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TypeProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TypeProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TypeProto& from) {
    TypeProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TypeProto* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "opencv_onnx.TypeProto";
  }
  protected:
  explicit TypeProto(::google::protobuf::Arena* arena);
  TypeProto(::google::protobuf::Arena* arena, const TypeProto& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Tensor = TypeProto_Tensor;

  // accessors -------------------------------------------------------

  enum : int {
    kDenotationFieldNumber = 6,
    kTensorTypeFieldNumber = 1,
  };
  // optional string denotation = 6;
  bool has_denotation() const;
  void clear_denotation() ;
  const std::string& denotation() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_denotation(Arg_&& arg, Args_... args);
  std::string* mutable_denotation();
  PROTOBUF_NODISCARD std::string* release_denotation();
  void set_allocated_denotation(std::string* value);

  private:
  const std::string& _internal_denotation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_denotation(
      const std::string& value);
  std::string* _internal_mutable_denotation();

  public:
  // .opencv_onnx.TypeProto.Tensor tensor_type = 1;
  bool has_tensor_type() const;
  private:
  bool _internal_has_tensor_type() const;

  public:
  void clear_tensor_type() ;
  const ::opencv_onnx::TypeProto_Tensor& tensor_type() const;
  PROTOBUF_NODISCARD ::opencv_onnx::TypeProto_Tensor* release_tensor_type();
  ::opencv_onnx::TypeProto_Tensor* mutable_tensor_type();
  void set_allocated_tensor_type(::opencv_onnx::TypeProto_Tensor* value);
  void unsafe_arena_set_allocated_tensor_type(::opencv_onnx::TypeProto_Tensor* value);
  ::opencv_onnx::TypeProto_Tensor* unsafe_arena_release_tensor_type();

  private:
  const ::opencv_onnx::TypeProto_Tensor& _internal_tensor_type() const;
  ::opencv_onnx::TypeProto_Tensor* _internal_mutable_tensor_type();

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:opencv_onnx.TypeProto)
 private:
  class _Internal;
  void set_has_tensor_type();

  inline bool has_value() const;
  inline void clear_has_value();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 1,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr denotation_;
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::opencv_onnx::TypeProto_Tensor* tensor_type_;
    } value_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_opencv_2donnx_2eproto;
};// -------------------------------------------------------------------

class ValueInfoProto final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:opencv_onnx.ValueInfoProto) */ {
 public:
  inline ValueInfoProto() : ValueInfoProto(nullptr) {}
  ~ValueInfoProto() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ValueInfoProto(::google::protobuf::internal::ConstantInitialized);

  inline ValueInfoProto(const ValueInfoProto& from)
      : ValueInfoProto(nullptr, from) {}
  ValueInfoProto(ValueInfoProto&& from) noexcept
    : ValueInfoProto() {
    *this = ::std::move(from);
  }

  inline ValueInfoProto& operator=(const ValueInfoProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValueInfoProto& operator=(ValueInfoProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValueInfoProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValueInfoProto* internal_default_instance() {
    return reinterpret_cast<const ValueInfoProto*>(
               &_ValueInfoProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ValueInfoProto& a, ValueInfoProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ValueInfoProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValueInfoProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValueInfoProto* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValueInfoProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ValueInfoProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ValueInfoProto& from) {
    ValueInfoProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ValueInfoProto* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "opencv_onnx.ValueInfoProto";
  }
  protected:
  explicit ValueInfoProto(::google::protobuf::Arena* arena);
  ValueInfoProto(::google::protobuf::Arena* arena, const ValueInfoProto& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDocStringFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional string doc_string = 3;
  bool has_doc_string() const;
  void clear_doc_string() ;
  const std::string& doc_string() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_doc_string(Arg_&& arg, Args_... args);
  std::string* mutable_doc_string();
  PROTOBUF_NODISCARD std::string* release_doc_string();
  void set_allocated_doc_string(std::string* value);

  private:
  const std::string& _internal_doc_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_doc_string(
      const std::string& value);
  std::string* _internal_mutable_doc_string();

  public:
  // optional .opencv_onnx.TypeProto type = 2;
  bool has_type() const;
  void clear_type() ;
  const ::opencv_onnx::TypeProto& type() const;
  PROTOBUF_NODISCARD ::opencv_onnx::TypeProto* release_type();
  ::opencv_onnx::TypeProto* mutable_type();
  void set_allocated_type(::opencv_onnx::TypeProto* value);
  void unsafe_arena_set_allocated_type(::opencv_onnx::TypeProto* value);
  ::opencv_onnx::TypeProto* unsafe_arena_release_type();

  private:
  const ::opencv_onnx::TypeProto& _internal_type() const;
  ::opencv_onnx::TypeProto* _internal_mutable_type();

  public:
  // @@protoc_insertion_point(class_scope:opencv_onnx.ValueInfoProto)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr doc_string_;
    ::opencv_onnx::TypeProto* type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_opencv_2donnx_2eproto;
};// -------------------------------------------------------------------

class AttributeProto final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:opencv_onnx.AttributeProto) */ {
 public:
  inline AttributeProto() : AttributeProto(nullptr) {}
  ~AttributeProto() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AttributeProto(::google::protobuf::internal::ConstantInitialized);

  inline AttributeProto(const AttributeProto& from)
      : AttributeProto(nullptr, from) {}
  AttributeProto(AttributeProto&& from) noexcept
    : AttributeProto() {
    *this = ::std::move(from);
  }

  inline AttributeProto& operator=(const AttributeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttributeProto& operator=(AttributeProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttributeProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const AttributeProto* internal_default_instance() {
    return reinterpret_cast<const AttributeProto*>(
               &_AttributeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AttributeProto& a, AttributeProto& b) {
    a.Swap(&b);
  }
  inline void Swap(AttributeProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttributeProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttributeProto* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AttributeProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AttributeProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AttributeProto& from) {
    AttributeProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AttributeProto* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "opencv_onnx.AttributeProto";
  }
  protected:
  explicit AttributeProto(::google::protobuf::Arena* arena);
  AttributeProto(::google::protobuf::Arena* arena, const AttributeProto& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using AttributeType = AttributeProto_AttributeType;
  static constexpr AttributeType UNDEFINED = AttributeProto_AttributeType_UNDEFINED;
  static constexpr AttributeType FLOAT = AttributeProto_AttributeType_FLOAT;
  static constexpr AttributeType INT = AttributeProto_AttributeType_INT;
  static constexpr AttributeType STRING = AttributeProto_AttributeType_STRING;
  static constexpr AttributeType TENSOR = AttributeProto_AttributeType_TENSOR;
  static constexpr AttributeType GRAPH = AttributeProto_AttributeType_GRAPH;
  static constexpr AttributeType FLOATS = AttributeProto_AttributeType_FLOATS;
  static constexpr AttributeType INTS = AttributeProto_AttributeType_INTS;
  static constexpr AttributeType STRINGS = AttributeProto_AttributeType_STRINGS;
  static constexpr AttributeType TENSORS = AttributeProto_AttributeType_TENSORS;
  static constexpr AttributeType GRAPHS = AttributeProto_AttributeType_GRAPHS;
  static inline bool AttributeType_IsValid(int value) {
    return AttributeProto_AttributeType_IsValid(value);
  }
  static constexpr AttributeType AttributeType_MIN = AttributeProto_AttributeType_AttributeType_MIN;
  static constexpr AttributeType AttributeType_MAX = AttributeProto_AttributeType_AttributeType_MAX;
  static constexpr int AttributeType_ARRAYSIZE = AttributeProto_AttributeType_AttributeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* AttributeType_descriptor() {
    return AttributeProto_AttributeType_descriptor();
  }
  template <typename T>
  static inline const std::string& AttributeType_Name(T value) {
    return AttributeProto_AttributeType_Name(value);
  }
  static inline bool AttributeType_Parse(absl::string_view name, AttributeType* value) {
    return AttributeProto_AttributeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFloatsFieldNumber = 7,
    kIntsFieldNumber = 8,
    kStringsFieldNumber = 9,
    kTensorsFieldNumber = 10,
    kGraphsFieldNumber = 11,
    kNameFieldNumber = 1,
    kSFieldNumber = 4,
    kDocStringFieldNumber = 13,
    kRefAttrNameFieldNumber = 21,
    kTFieldNumber = 5,
    kGFieldNumber = 6,
    kIFieldNumber = 3,
    kFFieldNumber = 2,
    kTypeFieldNumber = 20,
  };
  // repeated float floats = 7;
  int floats_size() const;
  private:
  int _internal_floats_size() const;

  public:
  void clear_floats() ;
  float floats(int index) const;
  void set_floats(int index, float value);
  void add_floats(float value);
  const ::google::protobuf::RepeatedField<float>& floats() const;
  ::google::protobuf::RepeatedField<float>* mutable_floats();

  private:
  const ::google::protobuf::RepeatedField<float>& _internal_floats() const;
  ::google::protobuf::RepeatedField<float>* _internal_mutable_floats();

  public:
  // repeated int64 ints = 8;
  int ints_size() const;
  private:
  int _internal_ints_size() const;

  public:
  void clear_ints() ;
  ::int64_t ints(int index) const;
  void set_ints(int index, ::int64_t value);
  void add_ints(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& ints() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_ints();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_ints() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_ints();

  public:
  // repeated bytes strings = 9;
  int strings_size() const;
  private:
  int _internal_strings_size() const;

  public:
  void clear_strings() ;
  const std::string& strings(int index) const;
  std::string* mutable_strings(int index);
  void set_strings(int index, const std::string& value);
  void set_strings(int index, std::string&& value);
  void set_strings(int index, const char* value);
  void set_strings(int index, const void* value, std::size_t size);
  void set_strings(int index, absl::string_view value);
  std::string* add_strings();
  void add_strings(const std::string& value);
  void add_strings(std::string&& value);
  void add_strings(const char* value);
  void add_strings(const void* value, std::size_t size);
  void add_strings(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& strings() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_strings();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_strings() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_strings();

  public:
  // repeated .opencv_onnx.TensorProto tensors = 10;
  int tensors_size() const;
  private:
  int _internal_tensors_size() const;

  public:
  void clear_tensors() ;
  ::opencv_onnx::TensorProto* mutable_tensors(int index);
  ::google::protobuf::RepeatedPtrField< ::opencv_onnx::TensorProto >*
      mutable_tensors();
  private:
  const ::google::protobuf::RepeatedPtrField<::opencv_onnx::TensorProto>& _internal_tensors() const;
  ::google::protobuf::RepeatedPtrField<::opencv_onnx::TensorProto>* _internal_mutable_tensors();
  public:
  const ::opencv_onnx::TensorProto& tensors(int index) const;
  ::opencv_onnx::TensorProto* add_tensors();
  const ::google::protobuf::RepeatedPtrField< ::opencv_onnx::TensorProto >&
      tensors() const;
  // repeated .opencv_onnx.GraphProto graphs = 11;
  int graphs_size() const;
  private:
  int _internal_graphs_size() const;

  public:
  void clear_graphs() ;
  ::opencv_onnx::GraphProto* mutable_graphs(int index);
  ::google::protobuf::RepeatedPtrField< ::opencv_onnx::GraphProto >*
      mutable_graphs();
  private:
  const ::google::protobuf::RepeatedPtrField<::opencv_onnx::GraphProto>& _internal_graphs() const;
  ::google::protobuf::RepeatedPtrField<::opencv_onnx::GraphProto>* _internal_mutable_graphs();
  public:
  const ::opencv_onnx::GraphProto& graphs(int index) const;
  ::opencv_onnx::GraphProto* add_graphs();
  const ::google::protobuf::RepeatedPtrField< ::opencv_onnx::GraphProto >&
      graphs() const;
  // optional string name = 1;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional bytes s = 4;
  bool has_s() const;
  void clear_s() ;
  const std::string& s() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_s(Arg_&& arg, Args_... args);
  std::string* mutable_s();
  PROTOBUF_NODISCARD std::string* release_s();
  void set_allocated_s(std::string* value);

  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(
      const std::string& value);
  std::string* _internal_mutable_s();

  public:
  // optional string doc_string = 13;
  bool has_doc_string() const;
  void clear_doc_string() ;
  const std::string& doc_string() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_doc_string(Arg_&& arg, Args_... args);
  std::string* mutable_doc_string();
  PROTOBUF_NODISCARD std::string* release_doc_string();
  void set_allocated_doc_string(std::string* value);

  private:
  const std::string& _internal_doc_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_doc_string(
      const std::string& value);
  std::string* _internal_mutable_doc_string();

  public:
  // optional string ref_attr_name = 21;
  bool has_ref_attr_name() const;
  void clear_ref_attr_name() ;
  const std::string& ref_attr_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ref_attr_name(Arg_&& arg, Args_... args);
  std::string* mutable_ref_attr_name();
  PROTOBUF_NODISCARD std::string* release_ref_attr_name();
  void set_allocated_ref_attr_name(std::string* value);

  private:
  const std::string& _internal_ref_attr_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ref_attr_name(
      const std::string& value);
  std::string* _internal_mutable_ref_attr_name();

  public:
  // optional .opencv_onnx.TensorProto t = 5;
  bool has_t() const;
  void clear_t() ;
  const ::opencv_onnx::TensorProto& t() const;
  PROTOBUF_NODISCARD ::opencv_onnx::TensorProto* release_t();
  ::opencv_onnx::TensorProto* mutable_t();
  void set_allocated_t(::opencv_onnx::TensorProto* value);
  void unsafe_arena_set_allocated_t(::opencv_onnx::TensorProto* value);
  ::opencv_onnx::TensorProto* unsafe_arena_release_t();

  private:
  const ::opencv_onnx::TensorProto& _internal_t() const;
  ::opencv_onnx::TensorProto* _internal_mutable_t();

  public:
  // optional .opencv_onnx.GraphProto g = 6;
  bool has_g() const;
  void clear_g() ;
  const ::opencv_onnx::GraphProto& g() const;
  PROTOBUF_NODISCARD ::opencv_onnx::GraphProto* release_g();
  ::opencv_onnx::GraphProto* mutable_g();
  void set_allocated_g(::opencv_onnx::GraphProto* value);
  void unsafe_arena_set_allocated_g(::opencv_onnx::GraphProto* value);
  ::opencv_onnx::GraphProto* unsafe_arena_release_g();

  private:
  const ::opencv_onnx::GraphProto& _internal_g() const;
  ::opencv_onnx::GraphProto* _internal_mutable_g();

  public:
  // optional int64 i = 3;
  bool has_i() const;
  void clear_i() ;
  ::int64_t i() const;
  void set_i(::int64_t value);

  private:
  ::int64_t _internal_i() const;
  void _internal_set_i(::int64_t value);

  public:
  // optional float f = 2;
  bool has_f() const;
  void clear_f() ;
  float f() const;
  void set_f(float value);

  private:
  float _internal_f() const;
  void _internal_set_f(float value);

  public:
  // optional .opencv_onnx.AttributeProto.AttributeType type = 20;
  bool has_type() const;
  void clear_type() ;
  ::opencv_onnx::AttributeProto_AttributeType type() const;
  void set_type(::opencv_onnx::AttributeProto_AttributeType value);

  private:
  ::opencv_onnx::AttributeProto_AttributeType _internal_type() const;
  void _internal_set_type(::opencv_onnx::AttributeProto_AttributeType value);

  public:
  // @@protoc_insertion_point(class_scope:opencv_onnx.AttributeProto)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 14, 5,
      70, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<float> floats_;
    ::google::protobuf::RepeatedField<::int64_t> ints_;
    ::google::protobuf::RepeatedPtrField<std::string> strings_;
    ::google::protobuf::RepeatedPtrField< ::opencv_onnx::TensorProto > tensors_;
    ::google::protobuf::RepeatedPtrField< ::opencv_onnx::GraphProto > graphs_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr s_;
    ::google::protobuf::internal::ArenaStringPtr doc_string_;
    ::google::protobuf::internal::ArenaStringPtr ref_attr_name_;
    ::opencv_onnx::TensorProto* t_;
    ::opencv_onnx::GraphProto* g_;
    ::int64_t i_;
    float f_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_opencv_2donnx_2eproto;
};// -------------------------------------------------------------------

class GraphProto final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:opencv_onnx.GraphProto) */ {
 public:
  inline GraphProto() : GraphProto(nullptr) {}
  ~GraphProto() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GraphProto(::google::protobuf::internal::ConstantInitialized);

  inline GraphProto(const GraphProto& from)
      : GraphProto(nullptr, from) {}
  GraphProto(GraphProto&& from) noexcept
    : GraphProto() {
    *this = ::std::move(from);
  }

  inline GraphProto& operator=(const GraphProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphProto& operator=(GraphProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GraphProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const GraphProto* internal_default_instance() {
    return reinterpret_cast<const GraphProto*>(
               &_GraphProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GraphProto& a, GraphProto& b) {
    a.Swap(&b);
  }
  inline void Swap(GraphProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraphProto* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GraphProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GraphProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GraphProto& from) {
    GraphProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GraphProto* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "opencv_onnx.GraphProto";
  }
  protected:
  explicit GraphProto(::google::protobuf::Arena* arena);
  GraphProto(::google::protobuf::Arena* arena, const GraphProto& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeFieldNumber = 1,
    kInitializerFieldNumber = 5,
    kInputFieldNumber = 11,
    kOutputFieldNumber = 12,
    kValueInfoFieldNumber = 13,
    kNameFieldNumber = 2,
    kDocStringFieldNumber = 10,
  };
  // repeated .opencv_onnx.NodeProto node = 1;
  int node_size() const;
  private:
  int _internal_node_size() const;

  public:
  void clear_node() ;
  ::opencv_onnx::NodeProto* mutable_node(int index);
  ::google::protobuf::RepeatedPtrField< ::opencv_onnx::NodeProto >*
      mutable_node();
  private:
  const ::google::protobuf::RepeatedPtrField<::opencv_onnx::NodeProto>& _internal_node() const;
  ::google::protobuf::RepeatedPtrField<::opencv_onnx::NodeProto>* _internal_mutable_node();
  public:
  const ::opencv_onnx::NodeProto& node(int index) const;
  ::opencv_onnx::NodeProto* add_node();
  const ::google::protobuf::RepeatedPtrField< ::opencv_onnx::NodeProto >&
      node() const;
  // repeated .opencv_onnx.TensorProto initializer = 5;
  int initializer_size() const;
  private:
  int _internal_initializer_size() const;

  public:
  void clear_initializer() ;
  ::opencv_onnx::TensorProto* mutable_initializer(int index);
  ::google::protobuf::RepeatedPtrField< ::opencv_onnx::TensorProto >*
      mutable_initializer();
  private:
  const ::google::protobuf::RepeatedPtrField<::opencv_onnx::TensorProto>& _internal_initializer() const;
  ::google::protobuf::RepeatedPtrField<::opencv_onnx::TensorProto>* _internal_mutable_initializer();
  public:
  const ::opencv_onnx::TensorProto& initializer(int index) const;
  ::opencv_onnx::TensorProto* add_initializer();
  const ::google::protobuf::RepeatedPtrField< ::opencv_onnx::TensorProto >&
      initializer() const;
  // repeated .opencv_onnx.ValueInfoProto input = 11;
  int input_size() const;
  private:
  int _internal_input_size() const;

  public:
  void clear_input() ;
  ::opencv_onnx::ValueInfoProto* mutable_input(int index);
  ::google::protobuf::RepeatedPtrField< ::opencv_onnx::ValueInfoProto >*
      mutable_input();
  private:
  const ::google::protobuf::RepeatedPtrField<::opencv_onnx::ValueInfoProto>& _internal_input() const;
  ::google::protobuf::RepeatedPtrField<::opencv_onnx::ValueInfoProto>* _internal_mutable_input();
  public:
  const ::opencv_onnx::ValueInfoProto& input(int index) const;
  ::opencv_onnx::ValueInfoProto* add_input();
  const ::google::protobuf::RepeatedPtrField< ::opencv_onnx::ValueInfoProto >&
      input() const;
  // repeated .opencv_onnx.ValueInfoProto output = 12;
  int output_size() const;
  private:
  int _internal_output_size() const;

  public:
  void clear_output() ;
  ::opencv_onnx::ValueInfoProto* mutable_output(int index);
  ::google::protobuf::RepeatedPtrField< ::opencv_onnx::ValueInfoProto >*
      mutable_output();
  private:
  const ::google::protobuf::RepeatedPtrField<::opencv_onnx::ValueInfoProto>& _internal_output() const;
  ::google::protobuf::RepeatedPtrField<::opencv_onnx::ValueInfoProto>* _internal_mutable_output();
  public:
  const ::opencv_onnx::ValueInfoProto& output(int index) const;
  ::opencv_onnx::ValueInfoProto* add_output();
  const ::google::protobuf::RepeatedPtrField< ::opencv_onnx::ValueInfoProto >&
      output() const;
  // repeated .opencv_onnx.ValueInfoProto value_info = 13;
  int value_info_size() const;
  private:
  int _internal_value_info_size() const;

  public:
  void clear_value_info() ;
  ::opencv_onnx::ValueInfoProto* mutable_value_info(int index);
  ::google::protobuf::RepeatedPtrField< ::opencv_onnx::ValueInfoProto >*
      mutable_value_info();
  private:
  const ::google::protobuf::RepeatedPtrField<::opencv_onnx::ValueInfoProto>& _internal_value_info() const;
  ::google::protobuf::RepeatedPtrField<::opencv_onnx::ValueInfoProto>* _internal_mutable_value_info();
  public:
  const ::opencv_onnx::ValueInfoProto& value_info(int index) const;
  ::opencv_onnx::ValueInfoProto* add_value_info();
  const ::google::protobuf::RepeatedPtrField< ::opencv_onnx::ValueInfoProto >&
      value_info() const;
  // optional string name = 2;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional string doc_string = 10;
  bool has_doc_string() const;
  void clear_doc_string() ;
  const std::string& doc_string() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_doc_string(Arg_&& arg, Args_... args);
  std::string* mutable_doc_string();
  PROTOBUF_NODISCARD std::string* release_doc_string();
  void set_allocated_doc_string(std::string* value);

  private:
  const std::string& _internal_doc_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_doc_string(
      const std::string& value);
  std::string* _internal_mutable_doc_string();

  public:
  // @@protoc_insertion_point(class_scope:opencv_onnx.GraphProto)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 5,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::opencv_onnx::NodeProto > node_;
    ::google::protobuf::RepeatedPtrField< ::opencv_onnx::TensorProto > initializer_;
    ::google::protobuf::RepeatedPtrField< ::opencv_onnx::ValueInfoProto > input_;
    ::google::protobuf::RepeatedPtrField< ::opencv_onnx::ValueInfoProto > output_;
    ::google::protobuf::RepeatedPtrField< ::opencv_onnx::ValueInfoProto > value_info_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr doc_string_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_opencv_2donnx_2eproto;
};// -------------------------------------------------------------------

class NodeProto final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:opencv_onnx.NodeProto) */ {
 public:
  inline NodeProto() : NodeProto(nullptr) {}
  ~NodeProto() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NodeProto(::google::protobuf::internal::ConstantInitialized);

  inline NodeProto(const NodeProto& from)
      : NodeProto(nullptr, from) {}
  NodeProto(NodeProto&& from) noexcept
    : NodeProto() {
    *this = ::std::move(from);
  }

  inline NodeProto& operator=(const NodeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeProto& operator=(NodeProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeProto* internal_default_instance() {
    return reinterpret_cast<const NodeProto*>(
               &_NodeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NodeProto& a, NodeProto& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeProto* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NodeProto& from) {
    NodeProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeProto* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "opencv_onnx.NodeProto";
  }
  protected:
  explicit NodeProto(::google::protobuf::Arena* arena);
  NodeProto(::google::protobuf::Arena* arena, const NodeProto& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputFieldNumber = 1,
    kOutputFieldNumber = 2,
    kAttributeFieldNumber = 5,
    kNameFieldNumber = 3,
    kOpTypeFieldNumber = 4,
    kDocStringFieldNumber = 6,
    kDomainFieldNumber = 7,
  };
  // repeated string input = 1;
  int input_size() const;
  private:
  int _internal_input_size() const;

  public:
  void clear_input() ;
  const std::string& input(int index) const;
  std::string* mutable_input(int index);
  void set_input(int index, const std::string& value);
  void set_input(int index, std::string&& value);
  void set_input(int index, const char* value);
  void set_input(int index, const char* value, std::size_t size);
  void set_input(int index, absl::string_view value);
  std::string* add_input();
  void add_input(const std::string& value);
  void add_input(std::string&& value);
  void add_input(const char* value);
  void add_input(const char* value, std::size_t size);
  void add_input(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& input() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_input();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_input() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_input();

  public:
  // repeated string output = 2;
  int output_size() const;
  private:
  int _internal_output_size() const;

  public:
  void clear_output() ;
  const std::string& output(int index) const;
  std::string* mutable_output(int index);
  void set_output(int index, const std::string& value);
  void set_output(int index, std::string&& value);
  void set_output(int index, const char* value);
  void set_output(int index, const char* value, std::size_t size);
  void set_output(int index, absl::string_view value);
  std::string* add_output();
  void add_output(const std::string& value);
  void add_output(std::string&& value);
  void add_output(const char* value);
  void add_output(const char* value, std::size_t size);
  void add_output(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& output() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_output();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_output() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_output();

  public:
  // repeated .opencv_onnx.AttributeProto attribute = 5;
  int attribute_size() const;
  private:
  int _internal_attribute_size() const;

  public:
  void clear_attribute() ;
  ::opencv_onnx::AttributeProto* mutable_attribute(int index);
  ::google::protobuf::RepeatedPtrField< ::opencv_onnx::AttributeProto >*
      mutable_attribute();
  private:
  const ::google::protobuf::RepeatedPtrField<::opencv_onnx::AttributeProto>& _internal_attribute() const;
  ::google::protobuf::RepeatedPtrField<::opencv_onnx::AttributeProto>* _internal_mutable_attribute();
  public:
  const ::opencv_onnx::AttributeProto& attribute(int index) const;
  ::opencv_onnx::AttributeProto* add_attribute();
  const ::google::protobuf::RepeatedPtrField< ::opencv_onnx::AttributeProto >&
      attribute() const;
  // optional string name = 3;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional string op_type = 4;
  bool has_op_type() const;
  void clear_op_type() ;
  const std::string& op_type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_op_type(Arg_&& arg, Args_... args);
  std::string* mutable_op_type();
  PROTOBUF_NODISCARD std::string* release_op_type();
  void set_allocated_op_type(std::string* value);

  private:
  const std::string& _internal_op_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_op_type(
      const std::string& value);
  std::string* _internal_mutable_op_type();

  public:
  // optional string doc_string = 6;
  bool has_doc_string() const;
  void clear_doc_string() ;
  const std::string& doc_string() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_doc_string(Arg_&& arg, Args_... args);
  std::string* mutable_doc_string();
  PROTOBUF_NODISCARD std::string* release_doc_string();
  void set_allocated_doc_string(std::string* value);

  private:
  const std::string& _internal_doc_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_doc_string(
      const std::string& value);
  std::string* _internal_mutable_doc_string();

  public:
  // optional string domain = 7;
  bool has_domain() const;
  void clear_domain() ;
  const std::string& domain() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_domain(Arg_&& arg, Args_... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* value);

  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(
      const std::string& value);
  std::string* _internal_mutable_domain();

  public:
  // @@protoc_insertion_point(class_scope:opencv_onnx.NodeProto)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      68, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> input_;
    ::google::protobuf::RepeatedPtrField<std::string> output_;
    ::google::protobuf::RepeatedPtrField< ::opencv_onnx::AttributeProto > attribute_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr op_type_;
    ::google::protobuf::internal::ArenaStringPtr doc_string_;
    ::google::protobuf::internal::ArenaStringPtr domain_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_opencv_2donnx_2eproto;
};// -------------------------------------------------------------------

class ModelProto final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:opencv_onnx.ModelProto) */ {
 public:
  inline ModelProto() : ModelProto(nullptr) {}
  ~ModelProto() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ModelProto(::google::protobuf::internal::ConstantInitialized);

  inline ModelProto(const ModelProto& from)
      : ModelProto(nullptr, from) {}
  ModelProto(ModelProto&& from) noexcept
    : ModelProto() {
    *this = ::std::move(from);
  }

  inline ModelProto& operator=(const ModelProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelProto& operator=(ModelProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModelProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelProto* internal_default_instance() {
    return reinterpret_cast<const ModelProto*>(
               &_ModelProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ModelProto& a, ModelProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelProto* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelProto* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelProto>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ModelProto& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ModelProto& from) {
    ModelProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ModelProto* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "opencv_onnx.ModelProto";
  }
  protected:
  explicit ModelProto(::google::protobuf::Arena* arena);
  ModelProto(::google::protobuf::Arena* arena, const ModelProto& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpsetImportFieldNumber = 8,
    kMetadataPropsFieldNumber = 14,
    kProducerNameFieldNumber = 2,
    kProducerVersionFieldNumber = 3,
    kDomainFieldNumber = 4,
    kDocStringFieldNumber = 6,
    kGraphFieldNumber = 7,
    kIrVersionFieldNumber = 1,
    kModelVersionFieldNumber = 5,
  };
  // repeated .opencv_onnx.OperatorSetIdProto opset_import = 8;
  int opset_import_size() const;
  private:
  int _internal_opset_import_size() const;

  public:
  void clear_opset_import() ;
  ::opencv_onnx::OperatorSetIdProto* mutable_opset_import(int index);
  ::google::protobuf::RepeatedPtrField< ::opencv_onnx::OperatorSetIdProto >*
      mutable_opset_import();
  private:
  const ::google::protobuf::RepeatedPtrField<::opencv_onnx::OperatorSetIdProto>& _internal_opset_import() const;
  ::google::protobuf::RepeatedPtrField<::opencv_onnx::OperatorSetIdProto>* _internal_mutable_opset_import();
  public:
  const ::opencv_onnx::OperatorSetIdProto& opset_import(int index) const;
  ::opencv_onnx::OperatorSetIdProto* add_opset_import();
  const ::google::protobuf::RepeatedPtrField< ::opencv_onnx::OperatorSetIdProto >&
      opset_import() const;
  // repeated .opencv_onnx.StringStringEntryProto metadata_props = 14;
  int metadata_props_size() const;
  private:
  int _internal_metadata_props_size() const;

  public:
  void clear_metadata_props() ;
  ::opencv_onnx::StringStringEntryProto* mutable_metadata_props(int index);
  ::google::protobuf::RepeatedPtrField< ::opencv_onnx::StringStringEntryProto >*
      mutable_metadata_props();
  private:
  const ::google::protobuf::RepeatedPtrField<::opencv_onnx::StringStringEntryProto>& _internal_metadata_props() const;
  ::google::protobuf::RepeatedPtrField<::opencv_onnx::StringStringEntryProto>* _internal_mutable_metadata_props();
  public:
  const ::opencv_onnx::StringStringEntryProto& metadata_props(int index) const;
  ::opencv_onnx::StringStringEntryProto* add_metadata_props();
  const ::google::protobuf::RepeatedPtrField< ::opencv_onnx::StringStringEntryProto >&
      metadata_props() const;
  // optional string producer_name = 2;
  bool has_producer_name() const;
  void clear_producer_name() ;
  const std::string& producer_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_producer_name(Arg_&& arg, Args_... args);
  std::string* mutable_producer_name();
  PROTOBUF_NODISCARD std::string* release_producer_name();
  void set_allocated_producer_name(std::string* value);

  private:
  const std::string& _internal_producer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_producer_name(
      const std::string& value);
  std::string* _internal_mutable_producer_name();

  public:
  // optional string producer_version = 3;
  bool has_producer_version() const;
  void clear_producer_version() ;
  const std::string& producer_version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_producer_version(Arg_&& arg, Args_... args);
  std::string* mutable_producer_version();
  PROTOBUF_NODISCARD std::string* release_producer_version();
  void set_allocated_producer_version(std::string* value);

  private:
  const std::string& _internal_producer_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_producer_version(
      const std::string& value);
  std::string* _internal_mutable_producer_version();

  public:
  // optional string domain = 4;
  bool has_domain() const;
  void clear_domain() ;
  const std::string& domain() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_domain(Arg_&& arg, Args_... args);
  std::string* mutable_domain();
  PROTOBUF_NODISCARD std::string* release_domain();
  void set_allocated_domain(std::string* value);

  private:
  const std::string& _internal_domain() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(
      const std::string& value);
  std::string* _internal_mutable_domain();

  public:
  // optional string doc_string = 6;
  bool has_doc_string() const;
  void clear_doc_string() ;
  const std::string& doc_string() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_doc_string(Arg_&& arg, Args_... args);
  std::string* mutable_doc_string();
  PROTOBUF_NODISCARD std::string* release_doc_string();
  void set_allocated_doc_string(std::string* value);

  private:
  const std::string& _internal_doc_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_doc_string(
      const std::string& value);
  std::string* _internal_mutable_doc_string();

  public:
  // optional .opencv_onnx.GraphProto graph = 7;
  bool has_graph() const;
  void clear_graph() ;
  const ::opencv_onnx::GraphProto& graph() const;
  PROTOBUF_NODISCARD ::opencv_onnx::GraphProto* release_graph();
  ::opencv_onnx::GraphProto* mutable_graph();
  void set_allocated_graph(::opencv_onnx::GraphProto* value);
  void unsafe_arena_set_allocated_graph(::opencv_onnx::GraphProto* value);
  ::opencv_onnx::GraphProto* unsafe_arena_release_graph();

  private:
  const ::opencv_onnx::GraphProto& _internal_graph() const;
  ::opencv_onnx::GraphProto* _internal_mutable_graph();

  public:
  // optional int64 ir_version = 1;
  bool has_ir_version() const;
  void clear_ir_version() ;
  ::int64_t ir_version() const;
  void set_ir_version(::int64_t value);

  private:
  ::int64_t _internal_ir_version() const;
  void _internal_set_ir_version(::int64_t value);

  public:
  // optional int64 model_version = 5;
  bool has_model_version() const;
  void clear_model_version() ;
  ::int64_t model_version() const;
  void set_model_version(::int64_t value);

  private:
  ::int64_t _internal_model_version() const;
  void _internal_set_model_version(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:opencv_onnx.ModelProto)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 3,
      84, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::opencv_onnx::OperatorSetIdProto > opset_import_;
    ::google::protobuf::RepeatedPtrField< ::opencv_onnx::StringStringEntryProto > metadata_props_;
    ::google::protobuf::internal::ArenaStringPtr producer_name_;
    ::google::protobuf::internal::ArenaStringPtr producer_version_;
    ::google::protobuf::internal::ArenaStringPtr domain_;
    ::google::protobuf::internal::ArenaStringPtr doc_string_;
    ::opencv_onnx::GraphProto* graph_;
    ::int64_t ir_version_;
    ::int64_t model_version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_opencv_2donnx_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// AttributeProto

// optional string name = 1;
inline bool AttributeProto::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AttributeProto::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AttributeProto::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.AttributeProto.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AttributeProto::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:opencv_onnx.AttributeProto.name)
}
inline std::string* AttributeProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.AttributeProto.name)
  return _s;
}
inline const std::string& AttributeProto::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void AttributeProto::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* AttributeProto::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* AttributeProto::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.AttributeProto.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AttributeProto::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.AttributeProto.name)
}

// optional string ref_attr_name = 21;
inline bool AttributeProto::has_ref_attr_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void AttributeProto::clear_ref_attr_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ref_attr_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AttributeProto::ref_attr_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.AttributeProto.ref_attr_name)
  return _internal_ref_attr_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AttributeProto::set_ref_attr_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.ref_attr_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:opencv_onnx.AttributeProto.ref_attr_name)
}
inline std::string* AttributeProto::mutable_ref_attr_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ref_attr_name();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.AttributeProto.ref_attr_name)
  return _s;
}
inline const std::string& AttributeProto::_internal_ref_attr_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ref_attr_name_.Get();
}
inline void AttributeProto::_internal_set_ref_attr_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.ref_attr_name_.Set(value, GetArena());
}
inline std::string* AttributeProto::_internal_mutable_ref_attr_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.ref_attr_name_.Mutable( GetArena());
}
inline std::string* AttributeProto::release_ref_attr_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.AttributeProto.ref_attr_name)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.ref_attr_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ref_attr_name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AttributeProto::set_allocated_ref_attr_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.ref_attr_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ref_attr_name_.IsDefault()) {
          _impl_.ref_attr_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.AttributeProto.ref_attr_name)
}

// optional string doc_string = 13;
inline bool AttributeProto::has_doc_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AttributeProto::clear_doc_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.doc_string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AttributeProto::doc_string() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.AttributeProto.doc_string)
  return _internal_doc_string();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AttributeProto::set_doc_string(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.doc_string_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:opencv_onnx.AttributeProto.doc_string)
}
inline std::string* AttributeProto::mutable_doc_string() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_doc_string();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.AttributeProto.doc_string)
  return _s;
}
inline const std::string& AttributeProto::_internal_doc_string() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.doc_string_.Get();
}
inline void AttributeProto::_internal_set_doc_string(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.doc_string_.Set(value, GetArena());
}
inline std::string* AttributeProto::_internal_mutable_doc_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.doc_string_.Mutable( GetArena());
}
inline std::string* AttributeProto::release_doc_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.AttributeProto.doc_string)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.doc_string_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.doc_string_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AttributeProto::set_allocated_doc_string(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.doc_string_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.doc_string_.IsDefault()) {
          _impl_.doc_string_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.AttributeProto.doc_string)
}

// optional .opencv_onnx.AttributeProto.AttributeType type = 20;
inline bool AttributeProto::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void AttributeProto::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::opencv_onnx::AttributeProto_AttributeType AttributeProto::type() const {
  // @@protoc_insertion_point(field_get:opencv_onnx.AttributeProto.type)
  return _internal_type();
}
inline void AttributeProto::set_type(::opencv_onnx::AttributeProto_AttributeType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:opencv_onnx.AttributeProto.type)
}
inline ::opencv_onnx::AttributeProto_AttributeType AttributeProto::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::opencv_onnx::AttributeProto_AttributeType>(_impl_.type_);
}
inline void AttributeProto::_internal_set_type(::opencv_onnx::AttributeProto_AttributeType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::opencv_onnx::AttributeProto_AttributeType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.type_ = value;
}

// optional float f = 2;
inline bool AttributeProto::has_f() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void AttributeProto::clear_f() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.f_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline float AttributeProto::f() const {
  // @@protoc_insertion_point(field_get:opencv_onnx.AttributeProto.f)
  return _internal_f();
}
inline void AttributeProto::set_f(float value) {
  _internal_set_f(value);
  // @@protoc_insertion_point(field_set:opencv_onnx.AttributeProto.f)
}
inline float AttributeProto::_internal_f() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.f_;
}
inline void AttributeProto::_internal_set_f(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.f_ = value;
}

// optional int64 i = 3;
inline bool AttributeProto::has_i() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void AttributeProto::clear_i() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.i_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int64_t AttributeProto::i() const {
  // @@protoc_insertion_point(field_get:opencv_onnx.AttributeProto.i)
  return _internal_i();
}
inline void AttributeProto::set_i(::int64_t value) {
  _internal_set_i(value);
  // @@protoc_insertion_point(field_set:opencv_onnx.AttributeProto.i)
}
inline ::int64_t AttributeProto::_internal_i() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.i_;
}
inline void AttributeProto::_internal_set_i(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.i_ = value;
}

// optional bytes s = 4;
inline bool AttributeProto::has_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AttributeProto::clear_s() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.s_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AttributeProto::s() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.AttributeProto.s)
  return _internal_s();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AttributeProto::set_s(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.s_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:opencv_onnx.AttributeProto.s)
}
inline std::string* AttributeProto::mutable_s() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.AttributeProto.s)
  return _s;
}
inline const std::string& AttributeProto::_internal_s() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.s_.Get();
}
inline void AttributeProto::_internal_set_s(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.s_.Set(value, GetArena());
}
inline std::string* AttributeProto::_internal_mutable_s() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.s_.Mutable( GetArena());
}
inline std::string* AttributeProto::release_s() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.AttributeProto.s)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.s_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.s_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AttributeProto::set_allocated_s(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.s_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.s_.IsDefault()) {
          _impl_.s_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.AttributeProto.s)
}

// optional .opencv_onnx.TensorProto t = 5;
inline bool AttributeProto::has_t() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.t_ != nullptr);
  return value;
}
inline void AttributeProto::clear_t() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.t_ != nullptr) _impl_.t_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::opencv_onnx::TensorProto& AttributeProto::_internal_t() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::opencv_onnx::TensorProto* p = _impl_.t_;
  return p != nullptr ? *p : reinterpret_cast<const ::opencv_onnx::TensorProto&>(::opencv_onnx::_TensorProto_default_instance_);
}
inline const ::opencv_onnx::TensorProto& AttributeProto::t() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.AttributeProto.t)
  return _internal_t();
}
inline void AttributeProto::unsafe_arena_set_allocated_t(::opencv_onnx::TensorProto* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.t_);
  }
  _impl_.t_ = reinterpret_cast<::opencv_onnx::TensorProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opencv_onnx.AttributeProto.t)
}
inline ::opencv_onnx::TensorProto* AttributeProto::release_t() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::opencv_onnx::TensorProto* released = _impl_.t_;
  _impl_.t_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::opencv_onnx::TensorProto* AttributeProto::unsafe_arena_release_t() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.AttributeProto.t)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::opencv_onnx::TensorProto* temp = _impl_.t_;
  _impl_.t_ = nullptr;
  return temp;
}
inline ::opencv_onnx::TensorProto* AttributeProto::_internal_mutable_t() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.t_ == nullptr) {
    auto* p = CreateMaybeMessage<::opencv_onnx::TensorProto>(GetArena());
    _impl_.t_ = reinterpret_cast<::opencv_onnx::TensorProto*>(p);
  }
  return _impl_.t_;
}
inline ::opencv_onnx::TensorProto* AttributeProto::mutable_t() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::opencv_onnx::TensorProto* _msg = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.AttributeProto.t)
  return _msg;
}
inline void AttributeProto::set_allocated_t(::opencv_onnx::TensorProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::opencv_onnx::TensorProto*>(_impl_.t_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::opencv_onnx::TensorProto*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.t_ = reinterpret_cast<::opencv_onnx::TensorProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.AttributeProto.t)
}

// optional .opencv_onnx.GraphProto g = 6;
inline bool AttributeProto::has_g() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.g_ != nullptr);
  return value;
}
inline void AttributeProto::clear_g() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.g_ != nullptr) _impl_.g_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::opencv_onnx::GraphProto& AttributeProto::_internal_g() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::opencv_onnx::GraphProto* p = _impl_.g_;
  return p != nullptr ? *p : reinterpret_cast<const ::opencv_onnx::GraphProto&>(::opencv_onnx::_GraphProto_default_instance_);
}
inline const ::opencv_onnx::GraphProto& AttributeProto::g() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.AttributeProto.g)
  return _internal_g();
}
inline void AttributeProto::unsafe_arena_set_allocated_g(::opencv_onnx::GraphProto* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.g_);
  }
  _impl_.g_ = reinterpret_cast<::opencv_onnx::GraphProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opencv_onnx.AttributeProto.g)
}
inline ::opencv_onnx::GraphProto* AttributeProto::release_g() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::opencv_onnx::GraphProto* released = _impl_.g_;
  _impl_.g_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::opencv_onnx::GraphProto* AttributeProto::unsafe_arena_release_g() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.AttributeProto.g)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::opencv_onnx::GraphProto* temp = _impl_.g_;
  _impl_.g_ = nullptr;
  return temp;
}
inline ::opencv_onnx::GraphProto* AttributeProto::_internal_mutable_g() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.g_ == nullptr) {
    auto* p = CreateMaybeMessage<::opencv_onnx::GraphProto>(GetArena());
    _impl_.g_ = reinterpret_cast<::opencv_onnx::GraphProto*>(p);
  }
  return _impl_.g_;
}
inline ::opencv_onnx::GraphProto* AttributeProto::mutable_g() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::opencv_onnx::GraphProto* _msg = _internal_mutable_g();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.AttributeProto.g)
  return _msg;
}
inline void AttributeProto::set_allocated_g(::opencv_onnx::GraphProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::opencv_onnx::GraphProto*>(_impl_.g_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::opencv_onnx::GraphProto*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.g_ = reinterpret_cast<::opencv_onnx::GraphProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.AttributeProto.g)
}

// repeated float floats = 7;
inline int AttributeProto::_internal_floats_size() const {
  return _internal_floats().size();
}
inline int AttributeProto::floats_size() const {
  return _internal_floats_size();
}
inline void AttributeProto::clear_floats() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.floats_.Clear();
}
inline float AttributeProto::floats(int index) const {
  // @@protoc_insertion_point(field_get:opencv_onnx.AttributeProto.floats)
  return _internal_floats().Get(index);
}
inline void AttributeProto::set_floats(int index, float value) {
  _internal_mutable_floats()->Set(index, value);
  // @@protoc_insertion_point(field_set:opencv_onnx.AttributeProto.floats)
}
inline void AttributeProto::add_floats(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_floats()->Add(value);
  // @@protoc_insertion_point(field_add:opencv_onnx.AttributeProto.floats)
}
inline const ::google::protobuf::RepeatedField<float>& AttributeProto::floats() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:opencv_onnx.AttributeProto.floats)
  return _internal_floats();
}
inline ::google::protobuf::RepeatedField<float>* AttributeProto::mutable_floats()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:opencv_onnx.AttributeProto.floats)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_floats();
}
inline const ::google::protobuf::RepeatedField<float>& AttributeProto::_internal_floats()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.floats_;
}
inline ::google::protobuf::RepeatedField<float>* AttributeProto::_internal_mutable_floats() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.floats_;
}

// repeated int64 ints = 8;
inline int AttributeProto::_internal_ints_size() const {
  return _internal_ints().size();
}
inline int AttributeProto::ints_size() const {
  return _internal_ints_size();
}
inline void AttributeProto::clear_ints() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ints_.Clear();
}
inline ::int64_t AttributeProto::ints(int index) const {
  // @@protoc_insertion_point(field_get:opencv_onnx.AttributeProto.ints)
  return _internal_ints().Get(index);
}
inline void AttributeProto::set_ints(int index, ::int64_t value) {
  _internal_mutable_ints()->Set(index, value);
  // @@protoc_insertion_point(field_set:opencv_onnx.AttributeProto.ints)
}
inline void AttributeProto::add_ints(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_ints()->Add(value);
  // @@protoc_insertion_point(field_add:opencv_onnx.AttributeProto.ints)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& AttributeProto::ints() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:opencv_onnx.AttributeProto.ints)
  return _internal_ints();
}
inline ::google::protobuf::RepeatedField<::int64_t>* AttributeProto::mutable_ints()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:opencv_onnx.AttributeProto.ints)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_ints();
}
inline const ::google::protobuf::RepeatedField<::int64_t>& AttributeProto::_internal_ints()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ints_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* AttributeProto::_internal_mutable_ints() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.ints_;
}

// repeated bytes strings = 9;
inline int AttributeProto::_internal_strings_size() const {
  return _internal_strings().size();
}
inline int AttributeProto::strings_size() const {
  return _internal_strings_size();
}
inline void AttributeProto::clear_strings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.strings_.Clear();
}
inline std::string* AttributeProto::add_strings()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_strings()->Add();
  // @@protoc_insertion_point(field_add_mutable:opencv_onnx.AttributeProto.strings)
  return _s;
}
inline const std::string& AttributeProto::strings(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.AttributeProto.strings)
  return _internal_strings().Get(index);
}
inline std::string* AttributeProto::mutable_strings(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:opencv_onnx.AttributeProto.strings)
  return _internal_mutable_strings()->Mutable(index);
}
inline void AttributeProto::set_strings(int index, const std::string& value) {
  _internal_mutable_strings()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:opencv_onnx.AttributeProto.strings)
}
inline void AttributeProto::set_strings(int index, std::string&& value) {
  _internal_mutable_strings()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:opencv_onnx.AttributeProto.strings)
}
inline void AttributeProto::set_strings(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_strings()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:opencv_onnx.AttributeProto.strings)
}
inline void AttributeProto::set_strings(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_strings()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opencv_onnx.AttributeProto.strings)
}
inline void AttributeProto::set_strings(int index, absl::string_view value) {
  _internal_mutable_strings()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:opencv_onnx.AttributeProto.strings)
}
inline void AttributeProto::add_strings(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_strings()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:opencv_onnx.AttributeProto.strings)
}
inline void AttributeProto::add_strings(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_strings()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:opencv_onnx.AttributeProto.strings)
}
inline void AttributeProto::add_strings(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_strings()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:opencv_onnx.AttributeProto.strings)
}
inline void AttributeProto::add_strings(const void* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_strings()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:opencv_onnx.AttributeProto.strings)
}
inline void AttributeProto::add_strings(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_strings()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:opencv_onnx.AttributeProto.strings)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AttributeProto::strings() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:opencv_onnx.AttributeProto.strings)
  return _internal_strings();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AttributeProto::mutable_strings() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:opencv_onnx.AttributeProto.strings)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_strings();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AttributeProto::_internal_strings() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.strings_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AttributeProto::_internal_mutable_strings() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.strings_;
}

// repeated .opencv_onnx.TensorProto tensors = 10;
inline int AttributeProto::_internal_tensors_size() const {
  return _internal_tensors().size();
}
inline int AttributeProto::tensors_size() const {
  return _internal_tensors_size();
}
inline void AttributeProto::clear_tensors() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tensors_.Clear();
}
inline ::opencv_onnx::TensorProto* AttributeProto::mutable_tensors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:opencv_onnx.AttributeProto.tensors)
  return _internal_mutable_tensors()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::opencv_onnx::TensorProto>* AttributeProto::mutable_tensors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:opencv_onnx.AttributeProto.tensors)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tensors();
}
inline const ::opencv_onnx::TensorProto& AttributeProto::tensors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.AttributeProto.tensors)
  return _internal_tensors().Get(index);
}
inline ::opencv_onnx::TensorProto* AttributeProto::add_tensors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::opencv_onnx::TensorProto* _add = _internal_mutable_tensors()->Add();
  // @@protoc_insertion_point(field_add:opencv_onnx.AttributeProto.tensors)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::opencv_onnx::TensorProto>& AttributeProto::tensors() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:opencv_onnx.AttributeProto.tensors)
  return _internal_tensors();
}
inline const ::google::protobuf::RepeatedPtrField<::opencv_onnx::TensorProto>&
AttributeProto::_internal_tensors() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tensors_;
}
inline ::google::protobuf::RepeatedPtrField<::opencv_onnx::TensorProto>*
AttributeProto::_internal_mutable_tensors() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tensors_;
}

// repeated .opencv_onnx.GraphProto graphs = 11;
inline int AttributeProto::_internal_graphs_size() const {
  return _internal_graphs().size();
}
inline int AttributeProto::graphs_size() const {
  return _internal_graphs_size();
}
inline void AttributeProto::clear_graphs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.graphs_.Clear();
}
inline ::opencv_onnx::GraphProto* AttributeProto::mutable_graphs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:opencv_onnx.AttributeProto.graphs)
  return _internal_mutable_graphs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::opencv_onnx::GraphProto>* AttributeProto::mutable_graphs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:opencv_onnx.AttributeProto.graphs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_graphs();
}
inline const ::opencv_onnx::GraphProto& AttributeProto::graphs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.AttributeProto.graphs)
  return _internal_graphs().Get(index);
}
inline ::opencv_onnx::GraphProto* AttributeProto::add_graphs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::opencv_onnx::GraphProto* _add = _internal_mutable_graphs()->Add();
  // @@protoc_insertion_point(field_add:opencv_onnx.AttributeProto.graphs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::opencv_onnx::GraphProto>& AttributeProto::graphs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:opencv_onnx.AttributeProto.graphs)
  return _internal_graphs();
}
inline const ::google::protobuf::RepeatedPtrField<::opencv_onnx::GraphProto>&
AttributeProto::_internal_graphs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.graphs_;
}
inline ::google::protobuf::RepeatedPtrField<::opencv_onnx::GraphProto>*
AttributeProto::_internal_mutable_graphs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.graphs_;
}

// -------------------------------------------------------------------

// ValueInfoProto

// optional string name = 1;
inline bool ValueInfoProto::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ValueInfoProto::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ValueInfoProto::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.ValueInfoProto.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ValueInfoProto::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:opencv_onnx.ValueInfoProto.name)
}
inline std::string* ValueInfoProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.ValueInfoProto.name)
  return _s;
}
inline const std::string& ValueInfoProto::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void ValueInfoProto::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ValueInfoProto::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ValueInfoProto::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.ValueInfoProto.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ValueInfoProto::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.ValueInfoProto.name)
}

// optional .opencv_onnx.TypeProto type = 2;
inline bool ValueInfoProto::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_ != nullptr);
  return value;
}
inline void ValueInfoProto::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.type_ != nullptr) _impl_.type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::opencv_onnx::TypeProto& ValueInfoProto::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::opencv_onnx::TypeProto* p = _impl_.type_;
  return p != nullptr ? *p : reinterpret_cast<const ::opencv_onnx::TypeProto&>(::opencv_onnx::_TypeProto_default_instance_);
}
inline const ::opencv_onnx::TypeProto& ValueInfoProto::type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.ValueInfoProto.type)
  return _internal_type();
}
inline void ValueInfoProto::unsafe_arena_set_allocated_type(::opencv_onnx::TypeProto* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_);
  }
  _impl_.type_ = reinterpret_cast<::opencv_onnx::TypeProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opencv_onnx.ValueInfoProto.type)
}
inline ::opencv_onnx::TypeProto* ValueInfoProto::release_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::opencv_onnx::TypeProto* released = _impl_.type_;
  _impl_.type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::opencv_onnx::TypeProto* ValueInfoProto::unsafe_arena_release_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.ValueInfoProto.type)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::opencv_onnx::TypeProto* temp = _impl_.type_;
  _impl_.type_ = nullptr;
  return temp;
}
inline ::opencv_onnx::TypeProto* ValueInfoProto::_internal_mutable_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.type_ == nullptr) {
    auto* p = CreateMaybeMessage<::opencv_onnx::TypeProto>(GetArena());
    _impl_.type_ = reinterpret_cast<::opencv_onnx::TypeProto*>(p);
  }
  return _impl_.type_;
}
inline ::opencv_onnx::TypeProto* ValueInfoProto::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::opencv_onnx::TypeProto* _msg = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.ValueInfoProto.type)
  return _msg;
}
inline void ValueInfoProto::set_allocated_type(::opencv_onnx::TypeProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::opencv_onnx::TypeProto*>(_impl_.type_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::opencv_onnx::TypeProto*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.type_ = reinterpret_cast<::opencv_onnx::TypeProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.ValueInfoProto.type)
}

// optional string doc_string = 3;
inline bool ValueInfoProto::has_doc_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ValueInfoProto::clear_doc_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.doc_string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ValueInfoProto::doc_string() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.ValueInfoProto.doc_string)
  return _internal_doc_string();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ValueInfoProto::set_doc_string(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.doc_string_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:opencv_onnx.ValueInfoProto.doc_string)
}
inline std::string* ValueInfoProto::mutable_doc_string() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_doc_string();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.ValueInfoProto.doc_string)
  return _s;
}
inline const std::string& ValueInfoProto::_internal_doc_string() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.doc_string_.Get();
}
inline void ValueInfoProto::_internal_set_doc_string(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.doc_string_.Set(value, GetArena());
}
inline std::string* ValueInfoProto::_internal_mutable_doc_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.doc_string_.Mutable( GetArena());
}
inline std::string* ValueInfoProto::release_doc_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.ValueInfoProto.doc_string)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.doc_string_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.doc_string_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ValueInfoProto::set_allocated_doc_string(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.doc_string_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.doc_string_.IsDefault()) {
          _impl_.doc_string_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.ValueInfoProto.doc_string)
}

// -------------------------------------------------------------------

// NodeProto

// repeated string input = 1;
inline int NodeProto::_internal_input_size() const {
  return _internal_input().size();
}
inline int NodeProto::input_size() const {
  return _internal_input_size();
}
inline void NodeProto::clear_input() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.input_.Clear();
}
inline std::string* NodeProto::add_input()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_input()->Add();
  // @@protoc_insertion_point(field_add_mutable:opencv_onnx.NodeProto.input)
  return _s;
}
inline const std::string& NodeProto::input(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.NodeProto.input)
  return _internal_input().Get(index);
}
inline std::string* NodeProto::mutable_input(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:opencv_onnx.NodeProto.input)
  return _internal_mutable_input()->Mutable(index);
}
inline void NodeProto::set_input(int index, const std::string& value) {
  _internal_mutable_input()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:opencv_onnx.NodeProto.input)
}
inline void NodeProto::set_input(int index, std::string&& value) {
  _internal_mutable_input()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:opencv_onnx.NodeProto.input)
}
inline void NodeProto::set_input(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_input()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:opencv_onnx.NodeProto.input)
}
inline void NodeProto::set_input(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_input()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opencv_onnx.NodeProto.input)
}
inline void NodeProto::set_input(int index, absl::string_view value) {
  _internal_mutable_input()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:opencv_onnx.NodeProto.input)
}
inline void NodeProto::add_input(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_input()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:opencv_onnx.NodeProto.input)
}
inline void NodeProto::add_input(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_input()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:opencv_onnx.NodeProto.input)
}
inline void NodeProto::add_input(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_input()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:opencv_onnx.NodeProto.input)
}
inline void NodeProto::add_input(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_input()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:opencv_onnx.NodeProto.input)
}
inline void NodeProto::add_input(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_input()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:opencv_onnx.NodeProto.input)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
NodeProto::input() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:opencv_onnx.NodeProto.input)
  return _internal_input();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
NodeProto::mutable_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:opencv_onnx.NodeProto.input)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_input();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
NodeProto::_internal_input() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.input_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
NodeProto::_internal_mutable_input() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.input_;
}

// repeated string output = 2;
inline int NodeProto::_internal_output_size() const {
  return _internal_output().size();
}
inline int NodeProto::output_size() const {
  return _internal_output_size();
}
inline void NodeProto::clear_output() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.output_.Clear();
}
inline std::string* NodeProto::add_output()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_output()->Add();
  // @@protoc_insertion_point(field_add_mutable:opencv_onnx.NodeProto.output)
  return _s;
}
inline const std::string& NodeProto::output(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.NodeProto.output)
  return _internal_output().Get(index);
}
inline std::string* NodeProto::mutable_output(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:opencv_onnx.NodeProto.output)
  return _internal_mutable_output()->Mutable(index);
}
inline void NodeProto::set_output(int index, const std::string& value) {
  _internal_mutable_output()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:opencv_onnx.NodeProto.output)
}
inline void NodeProto::set_output(int index, std::string&& value) {
  _internal_mutable_output()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:opencv_onnx.NodeProto.output)
}
inline void NodeProto::set_output(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_output()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:opencv_onnx.NodeProto.output)
}
inline void NodeProto::set_output(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_output()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opencv_onnx.NodeProto.output)
}
inline void NodeProto::set_output(int index, absl::string_view value) {
  _internal_mutable_output()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:opencv_onnx.NodeProto.output)
}
inline void NodeProto::add_output(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_output()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:opencv_onnx.NodeProto.output)
}
inline void NodeProto::add_output(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_output()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:opencv_onnx.NodeProto.output)
}
inline void NodeProto::add_output(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_output()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:opencv_onnx.NodeProto.output)
}
inline void NodeProto::add_output(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_output()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:opencv_onnx.NodeProto.output)
}
inline void NodeProto::add_output(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_output()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:opencv_onnx.NodeProto.output)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
NodeProto::output() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:opencv_onnx.NodeProto.output)
  return _internal_output();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
NodeProto::mutable_output() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:opencv_onnx.NodeProto.output)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_output();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
NodeProto::_internal_output() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.output_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
NodeProto::_internal_mutable_output() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.output_;
}

// optional string name = 3;
inline bool NodeProto::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NodeProto::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NodeProto::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.NodeProto.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeProto::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:opencv_onnx.NodeProto.name)
}
inline std::string* NodeProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.NodeProto.name)
  return _s;
}
inline const std::string& NodeProto::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void NodeProto::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* NodeProto::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* NodeProto::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.NodeProto.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NodeProto::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.NodeProto.name)
}

// optional string op_type = 4;
inline bool NodeProto::has_op_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NodeProto::clear_op_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.op_type_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NodeProto::op_type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.NodeProto.op_type)
  return _internal_op_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeProto::set_op_type(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.op_type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:opencv_onnx.NodeProto.op_type)
}
inline std::string* NodeProto::mutable_op_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_op_type();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.NodeProto.op_type)
  return _s;
}
inline const std::string& NodeProto::_internal_op_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.op_type_.Get();
}
inline void NodeProto::_internal_set_op_type(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.op_type_.Set(value, GetArena());
}
inline std::string* NodeProto::_internal_mutable_op_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.op_type_.Mutable( GetArena());
}
inline std::string* NodeProto::release_op_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.NodeProto.op_type)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.op_type_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.op_type_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NodeProto::set_allocated_op_type(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.op_type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.op_type_.IsDefault()) {
          _impl_.op_type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.NodeProto.op_type)
}

// optional string domain = 7;
inline bool NodeProto::has_domain() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NodeProto::clear_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domain_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& NodeProto::domain() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.NodeProto.domain)
  return _internal_domain();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeProto::set_domain(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.domain_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:opencv_onnx.NodeProto.domain)
}
inline std::string* NodeProto::mutable_domain() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.NodeProto.domain)
  return _s;
}
inline const std::string& NodeProto::_internal_domain() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.domain_.Get();
}
inline void NodeProto::_internal_set_domain(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.domain_.Set(value, GetArena());
}
inline std::string* NodeProto::_internal_mutable_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.domain_.Mutable( GetArena());
}
inline std::string* NodeProto::release_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.NodeProto.domain)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.domain_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.domain_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NodeProto::set_allocated_domain(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.domain_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.domain_.IsDefault()) {
          _impl_.domain_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.NodeProto.domain)
}

// repeated .opencv_onnx.AttributeProto attribute = 5;
inline int NodeProto::_internal_attribute_size() const {
  return _internal_attribute().size();
}
inline int NodeProto::attribute_size() const {
  return _internal_attribute_size();
}
inline void NodeProto::clear_attribute() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.attribute_.Clear();
}
inline ::opencv_onnx::AttributeProto* NodeProto::mutable_attribute(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:opencv_onnx.NodeProto.attribute)
  return _internal_mutable_attribute()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::opencv_onnx::AttributeProto>* NodeProto::mutable_attribute()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:opencv_onnx.NodeProto.attribute)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_attribute();
}
inline const ::opencv_onnx::AttributeProto& NodeProto::attribute(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.NodeProto.attribute)
  return _internal_attribute().Get(index);
}
inline ::opencv_onnx::AttributeProto* NodeProto::add_attribute() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::opencv_onnx::AttributeProto* _add = _internal_mutable_attribute()->Add();
  // @@protoc_insertion_point(field_add:opencv_onnx.NodeProto.attribute)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::opencv_onnx::AttributeProto>& NodeProto::attribute() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:opencv_onnx.NodeProto.attribute)
  return _internal_attribute();
}
inline const ::google::protobuf::RepeatedPtrField<::opencv_onnx::AttributeProto>&
NodeProto::_internal_attribute() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attribute_;
}
inline ::google::protobuf::RepeatedPtrField<::opencv_onnx::AttributeProto>*
NodeProto::_internal_mutable_attribute() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.attribute_;
}

// optional string doc_string = 6;
inline bool NodeProto::has_doc_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NodeProto::clear_doc_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.doc_string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& NodeProto::doc_string() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.NodeProto.doc_string)
  return _internal_doc_string();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeProto::set_doc_string(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.doc_string_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:opencv_onnx.NodeProto.doc_string)
}
inline std::string* NodeProto::mutable_doc_string() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_doc_string();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.NodeProto.doc_string)
  return _s;
}
inline const std::string& NodeProto::_internal_doc_string() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.doc_string_.Get();
}
inline void NodeProto::_internal_set_doc_string(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.doc_string_.Set(value, GetArena());
}
inline std::string* NodeProto::_internal_mutable_doc_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.doc_string_.Mutable( GetArena());
}
inline std::string* NodeProto::release_doc_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.NodeProto.doc_string)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.doc_string_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.doc_string_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NodeProto::set_allocated_doc_string(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.doc_string_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.doc_string_.IsDefault()) {
          _impl_.doc_string_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.NodeProto.doc_string)
}

// -------------------------------------------------------------------

// ModelProto

// optional int64 ir_version = 1;
inline bool ModelProto::has_ir_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void ModelProto::clear_ir_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ir_version_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int64_t ModelProto::ir_version() const {
  // @@protoc_insertion_point(field_get:opencv_onnx.ModelProto.ir_version)
  return _internal_ir_version();
}
inline void ModelProto::set_ir_version(::int64_t value) {
  _internal_set_ir_version(value);
  // @@protoc_insertion_point(field_set:opencv_onnx.ModelProto.ir_version)
}
inline ::int64_t ModelProto::_internal_ir_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ir_version_;
}
inline void ModelProto::_internal_set_ir_version(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.ir_version_ = value;
}

// repeated .opencv_onnx.OperatorSetIdProto opset_import = 8;
inline int ModelProto::_internal_opset_import_size() const {
  return _internal_opset_import().size();
}
inline int ModelProto::opset_import_size() const {
  return _internal_opset_import_size();
}
inline void ModelProto::clear_opset_import() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.opset_import_.Clear();
}
inline ::opencv_onnx::OperatorSetIdProto* ModelProto::mutable_opset_import(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:opencv_onnx.ModelProto.opset_import)
  return _internal_mutable_opset_import()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::opencv_onnx::OperatorSetIdProto>* ModelProto::mutable_opset_import()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:opencv_onnx.ModelProto.opset_import)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_opset_import();
}
inline const ::opencv_onnx::OperatorSetIdProto& ModelProto::opset_import(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.ModelProto.opset_import)
  return _internal_opset_import().Get(index);
}
inline ::opencv_onnx::OperatorSetIdProto* ModelProto::add_opset_import() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::opencv_onnx::OperatorSetIdProto* _add = _internal_mutable_opset_import()->Add();
  // @@protoc_insertion_point(field_add:opencv_onnx.ModelProto.opset_import)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::opencv_onnx::OperatorSetIdProto>& ModelProto::opset_import() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:opencv_onnx.ModelProto.opset_import)
  return _internal_opset_import();
}
inline const ::google::protobuf::RepeatedPtrField<::opencv_onnx::OperatorSetIdProto>&
ModelProto::_internal_opset_import() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.opset_import_;
}
inline ::google::protobuf::RepeatedPtrField<::opencv_onnx::OperatorSetIdProto>*
ModelProto::_internal_mutable_opset_import() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.opset_import_;
}

// optional string producer_name = 2;
inline bool ModelProto::has_producer_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ModelProto::clear_producer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.producer_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ModelProto::producer_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.ModelProto.producer_name)
  return _internal_producer_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelProto::set_producer_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.producer_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:opencv_onnx.ModelProto.producer_name)
}
inline std::string* ModelProto::mutable_producer_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_producer_name();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.ModelProto.producer_name)
  return _s;
}
inline const std::string& ModelProto::_internal_producer_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.producer_name_.Get();
}
inline void ModelProto::_internal_set_producer_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.producer_name_.Set(value, GetArena());
}
inline std::string* ModelProto::_internal_mutable_producer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.producer_name_.Mutable( GetArena());
}
inline std::string* ModelProto::release_producer_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.ModelProto.producer_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.producer_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.producer_name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ModelProto::set_allocated_producer_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.producer_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.producer_name_.IsDefault()) {
          _impl_.producer_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.ModelProto.producer_name)
}

// optional string producer_version = 3;
inline bool ModelProto::has_producer_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ModelProto::clear_producer_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.producer_version_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ModelProto::producer_version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.ModelProto.producer_version)
  return _internal_producer_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelProto::set_producer_version(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.producer_version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:opencv_onnx.ModelProto.producer_version)
}
inline std::string* ModelProto::mutable_producer_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_producer_version();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.ModelProto.producer_version)
  return _s;
}
inline const std::string& ModelProto::_internal_producer_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.producer_version_.Get();
}
inline void ModelProto::_internal_set_producer_version(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.producer_version_.Set(value, GetArena());
}
inline std::string* ModelProto::_internal_mutable_producer_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.producer_version_.Mutable( GetArena());
}
inline std::string* ModelProto::release_producer_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.ModelProto.producer_version)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.producer_version_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.producer_version_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ModelProto::set_allocated_producer_version(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.producer_version_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.producer_version_.IsDefault()) {
          _impl_.producer_version_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.ModelProto.producer_version)
}

// optional string domain = 4;
inline bool ModelProto::has_domain() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ModelProto::clear_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domain_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ModelProto::domain() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.ModelProto.domain)
  return _internal_domain();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelProto::set_domain(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.domain_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:opencv_onnx.ModelProto.domain)
}
inline std::string* ModelProto::mutable_domain() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.ModelProto.domain)
  return _s;
}
inline const std::string& ModelProto::_internal_domain() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.domain_.Get();
}
inline void ModelProto::_internal_set_domain(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.domain_.Set(value, GetArena());
}
inline std::string* ModelProto::_internal_mutable_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.domain_.Mutable( GetArena());
}
inline std::string* ModelProto::release_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.ModelProto.domain)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.domain_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.domain_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ModelProto::set_allocated_domain(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.domain_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.domain_.IsDefault()) {
          _impl_.domain_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.ModelProto.domain)
}

// optional int64 model_version = 5;
inline bool ModelProto::has_model_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void ModelProto::clear_model_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.model_version_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int64_t ModelProto::model_version() const {
  // @@protoc_insertion_point(field_get:opencv_onnx.ModelProto.model_version)
  return _internal_model_version();
}
inline void ModelProto::set_model_version(::int64_t value) {
  _internal_set_model_version(value);
  // @@protoc_insertion_point(field_set:opencv_onnx.ModelProto.model_version)
}
inline ::int64_t ModelProto::_internal_model_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.model_version_;
}
inline void ModelProto::_internal_set_model_version(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.model_version_ = value;
}

// optional string doc_string = 6;
inline bool ModelProto::has_doc_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ModelProto::clear_doc_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.doc_string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ModelProto::doc_string() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.ModelProto.doc_string)
  return _internal_doc_string();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ModelProto::set_doc_string(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.doc_string_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:opencv_onnx.ModelProto.doc_string)
}
inline std::string* ModelProto::mutable_doc_string() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_doc_string();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.ModelProto.doc_string)
  return _s;
}
inline const std::string& ModelProto::_internal_doc_string() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.doc_string_.Get();
}
inline void ModelProto::_internal_set_doc_string(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.doc_string_.Set(value, GetArena());
}
inline std::string* ModelProto::_internal_mutable_doc_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.doc_string_.Mutable( GetArena());
}
inline std::string* ModelProto::release_doc_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.ModelProto.doc_string)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.doc_string_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.doc_string_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ModelProto::set_allocated_doc_string(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.doc_string_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.doc_string_.IsDefault()) {
          _impl_.doc_string_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.ModelProto.doc_string)
}

// optional .opencv_onnx.GraphProto graph = 7;
inline bool ModelProto::has_graph() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.graph_ != nullptr);
  return value;
}
inline void ModelProto::clear_graph() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.graph_ != nullptr) _impl_.graph_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::opencv_onnx::GraphProto& ModelProto::_internal_graph() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::opencv_onnx::GraphProto* p = _impl_.graph_;
  return p != nullptr ? *p : reinterpret_cast<const ::opencv_onnx::GraphProto&>(::opencv_onnx::_GraphProto_default_instance_);
}
inline const ::opencv_onnx::GraphProto& ModelProto::graph() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.ModelProto.graph)
  return _internal_graph();
}
inline void ModelProto::unsafe_arena_set_allocated_graph(::opencv_onnx::GraphProto* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.graph_);
  }
  _impl_.graph_ = reinterpret_cast<::opencv_onnx::GraphProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opencv_onnx.ModelProto.graph)
}
inline ::opencv_onnx::GraphProto* ModelProto::release_graph() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::opencv_onnx::GraphProto* released = _impl_.graph_;
  _impl_.graph_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::opencv_onnx::GraphProto* ModelProto::unsafe_arena_release_graph() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.ModelProto.graph)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::opencv_onnx::GraphProto* temp = _impl_.graph_;
  _impl_.graph_ = nullptr;
  return temp;
}
inline ::opencv_onnx::GraphProto* ModelProto::_internal_mutable_graph() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.graph_ == nullptr) {
    auto* p = CreateMaybeMessage<::opencv_onnx::GraphProto>(GetArena());
    _impl_.graph_ = reinterpret_cast<::opencv_onnx::GraphProto*>(p);
  }
  return _impl_.graph_;
}
inline ::opencv_onnx::GraphProto* ModelProto::mutable_graph() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::opencv_onnx::GraphProto* _msg = _internal_mutable_graph();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.ModelProto.graph)
  return _msg;
}
inline void ModelProto::set_allocated_graph(::opencv_onnx::GraphProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::opencv_onnx::GraphProto*>(_impl_.graph_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::opencv_onnx::GraphProto*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.graph_ = reinterpret_cast<::opencv_onnx::GraphProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.ModelProto.graph)
}

// repeated .opencv_onnx.StringStringEntryProto metadata_props = 14;
inline int ModelProto::_internal_metadata_props_size() const {
  return _internal_metadata_props().size();
}
inline int ModelProto::metadata_props_size() const {
  return _internal_metadata_props_size();
}
inline void ModelProto::clear_metadata_props() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.metadata_props_.Clear();
}
inline ::opencv_onnx::StringStringEntryProto* ModelProto::mutable_metadata_props(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:opencv_onnx.ModelProto.metadata_props)
  return _internal_mutable_metadata_props()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::opencv_onnx::StringStringEntryProto>* ModelProto::mutable_metadata_props()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:opencv_onnx.ModelProto.metadata_props)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_metadata_props();
}
inline const ::opencv_onnx::StringStringEntryProto& ModelProto::metadata_props(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.ModelProto.metadata_props)
  return _internal_metadata_props().Get(index);
}
inline ::opencv_onnx::StringStringEntryProto* ModelProto::add_metadata_props() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::opencv_onnx::StringStringEntryProto* _add = _internal_mutable_metadata_props()->Add();
  // @@protoc_insertion_point(field_add:opencv_onnx.ModelProto.metadata_props)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::opencv_onnx::StringStringEntryProto>& ModelProto::metadata_props() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:opencv_onnx.ModelProto.metadata_props)
  return _internal_metadata_props();
}
inline const ::google::protobuf::RepeatedPtrField<::opencv_onnx::StringStringEntryProto>&
ModelProto::_internal_metadata_props() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.metadata_props_;
}
inline ::google::protobuf::RepeatedPtrField<::opencv_onnx::StringStringEntryProto>*
ModelProto::_internal_mutable_metadata_props() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.metadata_props_;
}

// -------------------------------------------------------------------

// StringStringEntryProto

// optional string key = 1;
inline bool StringStringEntryProto::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void StringStringEntryProto::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StringStringEntryProto::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.StringStringEntryProto.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StringStringEntryProto::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:opencv_onnx.StringStringEntryProto.key)
}
inline std::string* StringStringEntryProto::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.StringStringEntryProto.key)
  return _s;
}
inline const std::string& StringStringEntryProto::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void StringStringEntryProto::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* StringStringEntryProto::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* StringStringEntryProto::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.StringStringEntryProto.key)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.key_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.key_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StringStringEntryProto::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.StringStringEntryProto.key)
}

// optional string value = 2;
inline bool StringStringEntryProto::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void StringStringEntryProto::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StringStringEntryProto::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.StringStringEntryProto.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StringStringEntryProto::set_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:opencv_onnx.StringStringEntryProto.value)
}
inline std::string* StringStringEntryProto::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.StringStringEntryProto.value)
  return _s;
}
inline const std::string& StringStringEntryProto::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_.Get();
}
inline void StringStringEntryProto::_internal_set_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_.Set(value, GetArena());
}
inline std::string* StringStringEntryProto::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* StringStringEntryProto::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.StringStringEntryProto.value)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.value_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StringStringEntryProto::set_allocated_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.value_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.StringStringEntryProto.value)
}

// -------------------------------------------------------------------

// GraphProto

// repeated .opencv_onnx.NodeProto node = 1;
inline int GraphProto::_internal_node_size() const {
  return _internal_node().size();
}
inline int GraphProto::node_size() const {
  return _internal_node_size();
}
inline void GraphProto::clear_node() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.node_.Clear();
}
inline ::opencv_onnx::NodeProto* GraphProto::mutable_node(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:opencv_onnx.GraphProto.node)
  return _internal_mutable_node()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::opencv_onnx::NodeProto>* GraphProto::mutable_node()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:opencv_onnx.GraphProto.node)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_node();
}
inline const ::opencv_onnx::NodeProto& GraphProto::node(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.GraphProto.node)
  return _internal_node().Get(index);
}
inline ::opencv_onnx::NodeProto* GraphProto::add_node() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::opencv_onnx::NodeProto* _add = _internal_mutable_node()->Add();
  // @@protoc_insertion_point(field_add:opencv_onnx.GraphProto.node)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::opencv_onnx::NodeProto>& GraphProto::node() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:opencv_onnx.GraphProto.node)
  return _internal_node();
}
inline const ::google::protobuf::RepeatedPtrField<::opencv_onnx::NodeProto>&
GraphProto::_internal_node() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.node_;
}
inline ::google::protobuf::RepeatedPtrField<::opencv_onnx::NodeProto>*
GraphProto::_internal_mutable_node() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.node_;
}

// optional string name = 2;
inline bool GraphProto::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GraphProto::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GraphProto::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.GraphProto.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GraphProto::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:opencv_onnx.GraphProto.name)
}
inline std::string* GraphProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.GraphProto.name)
  return _s;
}
inline const std::string& GraphProto::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void GraphProto::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* GraphProto::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* GraphProto::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.GraphProto.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GraphProto::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.GraphProto.name)
}

// repeated .opencv_onnx.TensorProto initializer = 5;
inline int GraphProto::_internal_initializer_size() const {
  return _internal_initializer().size();
}
inline int GraphProto::initializer_size() const {
  return _internal_initializer_size();
}
inline void GraphProto::clear_initializer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.initializer_.Clear();
}
inline ::opencv_onnx::TensorProto* GraphProto::mutable_initializer(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:opencv_onnx.GraphProto.initializer)
  return _internal_mutable_initializer()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::opencv_onnx::TensorProto>* GraphProto::mutable_initializer()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:opencv_onnx.GraphProto.initializer)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_initializer();
}
inline const ::opencv_onnx::TensorProto& GraphProto::initializer(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.GraphProto.initializer)
  return _internal_initializer().Get(index);
}
inline ::opencv_onnx::TensorProto* GraphProto::add_initializer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::opencv_onnx::TensorProto* _add = _internal_mutable_initializer()->Add();
  // @@protoc_insertion_point(field_add:opencv_onnx.GraphProto.initializer)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::opencv_onnx::TensorProto>& GraphProto::initializer() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:opencv_onnx.GraphProto.initializer)
  return _internal_initializer();
}
inline const ::google::protobuf::RepeatedPtrField<::opencv_onnx::TensorProto>&
GraphProto::_internal_initializer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.initializer_;
}
inline ::google::protobuf::RepeatedPtrField<::opencv_onnx::TensorProto>*
GraphProto::_internal_mutable_initializer() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.initializer_;
}

// optional string doc_string = 10;
inline bool GraphProto::has_doc_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GraphProto::clear_doc_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.doc_string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GraphProto::doc_string() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.GraphProto.doc_string)
  return _internal_doc_string();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GraphProto::set_doc_string(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.doc_string_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:opencv_onnx.GraphProto.doc_string)
}
inline std::string* GraphProto::mutable_doc_string() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_doc_string();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.GraphProto.doc_string)
  return _s;
}
inline const std::string& GraphProto::_internal_doc_string() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.doc_string_.Get();
}
inline void GraphProto::_internal_set_doc_string(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.doc_string_.Set(value, GetArena());
}
inline std::string* GraphProto::_internal_mutable_doc_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.doc_string_.Mutable( GetArena());
}
inline std::string* GraphProto::release_doc_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.GraphProto.doc_string)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.doc_string_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.doc_string_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GraphProto::set_allocated_doc_string(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.doc_string_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.doc_string_.IsDefault()) {
          _impl_.doc_string_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.GraphProto.doc_string)
}

// repeated .opencv_onnx.ValueInfoProto input = 11;
inline int GraphProto::_internal_input_size() const {
  return _internal_input().size();
}
inline int GraphProto::input_size() const {
  return _internal_input_size();
}
inline void GraphProto::clear_input() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.input_.Clear();
}
inline ::opencv_onnx::ValueInfoProto* GraphProto::mutable_input(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:opencv_onnx.GraphProto.input)
  return _internal_mutable_input()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::opencv_onnx::ValueInfoProto>* GraphProto::mutable_input()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:opencv_onnx.GraphProto.input)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_input();
}
inline const ::opencv_onnx::ValueInfoProto& GraphProto::input(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.GraphProto.input)
  return _internal_input().Get(index);
}
inline ::opencv_onnx::ValueInfoProto* GraphProto::add_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::opencv_onnx::ValueInfoProto* _add = _internal_mutable_input()->Add();
  // @@protoc_insertion_point(field_add:opencv_onnx.GraphProto.input)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::opencv_onnx::ValueInfoProto>& GraphProto::input() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:opencv_onnx.GraphProto.input)
  return _internal_input();
}
inline const ::google::protobuf::RepeatedPtrField<::opencv_onnx::ValueInfoProto>&
GraphProto::_internal_input() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.input_;
}
inline ::google::protobuf::RepeatedPtrField<::opencv_onnx::ValueInfoProto>*
GraphProto::_internal_mutable_input() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.input_;
}

// repeated .opencv_onnx.ValueInfoProto output = 12;
inline int GraphProto::_internal_output_size() const {
  return _internal_output().size();
}
inline int GraphProto::output_size() const {
  return _internal_output_size();
}
inline void GraphProto::clear_output() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.output_.Clear();
}
inline ::opencv_onnx::ValueInfoProto* GraphProto::mutable_output(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:opencv_onnx.GraphProto.output)
  return _internal_mutable_output()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::opencv_onnx::ValueInfoProto>* GraphProto::mutable_output()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:opencv_onnx.GraphProto.output)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_output();
}
inline const ::opencv_onnx::ValueInfoProto& GraphProto::output(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.GraphProto.output)
  return _internal_output().Get(index);
}
inline ::opencv_onnx::ValueInfoProto* GraphProto::add_output() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::opencv_onnx::ValueInfoProto* _add = _internal_mutable_output()->Add();
  // @@protoc_insertion_point(field_add:opencv_onnx.GraphProto.output)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::opencv_onnx::ValueInfoProto>& GraphProto::output() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:opencv_onnx.GraphProto.output)
  return _internal_output();
}
inline const ::google::protobuf::RepeatedPtrField<::opencv_onnx::ValueInfoProto>&
GraphProto::_internal_output() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.output_;
}
inline ::google::protobuf::RepeatedPtrField<::opencv_onnx::ValueInfoProto>*
GraphProto::_internal_mutable_output() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.output_;
}

// repeated .opencv_onnx.ValueInfoProto value_info = 13;
inline int GraphProto::_internal_value_info_size() const {
  return _internal_value_info().size();
}
inline int GraphProto::value_info_size() const {
  return _internal_value_info_size();
}
inline void GraphProto::clear_value_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_info_.Clear();
}
inline ::opencv_onnx::ValueInfoProto* GraphProto::mutable_value_info(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:opencv_onnx.GraphProto.value_info)
  return _internal_mutable_value_info()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::opencv_onnx::ValueInfoProto>* GraphProto::mutable_value_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:opencv_onnx.GraphProto.value_info)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_value_info();
}
inline const ::opencv_onnx::ValueInfoProto& GraphProto::value_info(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.GraphProto.value_info)
  return _internal_value_info().Get(index);
}
inline ::opencv_onnx::ValueInfoProto* GraphProto::add_value_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::opencv_onnx::ValueInfoProto* _add = _internal_mutable_value_info()->Add();
  // @@protoc_insertion_point(field_add:opencv_onnx.GraphProto.value_info)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::opencv_onnx::ValueInfoProto>& GraphProto::value_info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:opencv_onnx.GraphProto.value_info)
  return _internal_value_info();
}
inline const ::google::protobuf::RepeatedPtrField<::opencv_onnx::ValueInfoProto>&
GraphProto::_internal_value_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_info_;
}
inline ::google::protobuf::RepeatedPtrField<::opencv_onnx::ValueInfoProto>*
GraphProto::_internal_mutable_value_info() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.value_info_;
}

// -------------------------------------------------------------------

// TensorProto_Segment

// optional int64 begin = 1;
inline bool TensorProto_Segment::has_begin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TensorProto_Segment::clear_begin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.begin_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t TensorProto_Segment::begin() const {
  // @@protoc_insertion_point(field_get:opencv_onnx.TensorProto.Segment.begin)
  return _internal_begin();
}
inline void TensorProto_Segment::set_begin(::int64_t value) {
  _internal_set_begin(value);
  // @@protoc_insertion_point(field_set:opencv_onnx.TensorProto.Segment.begin)
}
inline ::int64_t TensorProto_Segment::_internal_begin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.begin_;
}
inline void TensorProto_Segment::_internal_set_begin(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.begin_ = value;
}

// optional int64 end = 2;
inline bool TensorProto_Segment::has_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TensorProto_Segment::clear_end() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t TensorProto_Segment::end() const {
  // @@protoc_insertion_point(field_get:opencv_onnx.TensorProto.Segment.end)
  return _internal_end();
}
inline void TensorProto_Segment::set_end(::int64_t value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:opencv_onnx.TensorProto.Segment.end)
}
inline ::int64_t TensorProto_Segment::_internal_end() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_;
}
inline void TensorProto_Segment::_internal_set_end(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.end_ = value;
}

// -------------------------------------------------------------------

// TensorProto

// repeated int64 dims = 1;
inline int TensorProto::_internal_dims_size() const {
  return _internal_dims().size();
}
inline int TensorProto::dims_size() const {
  return _internal_dims_size();
}
inline void TensorProto::clear_dims() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dims_.Clear();
}
inline ::int64_t TensorProto::dims(int index) const {
  // @@protoc_insertion_point(field_get:opencv_onnx.TensorProto.dims)
  return _internal_dims().Get(index);
}
inline void TensorProto::set_dims(int index, ::int64_t value) {
  _internal_mutable_dims()->Set(index, value);
  // @@protoc_insertion_point(field_set:opencv_onnx.TensorProto.dims)
}
inline void TensorProto::add_dims(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_dims()->Add(value);
  // @@protoc_insertion_point(field_add:opencv_onnx.TensorProto.dims)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& TensorProto::dims() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:opencv_onnx.TensorProto.dims)
  return _internal_dims();
}
inline ::google::protobuf::RepeatedField<::int64_t>* TensorProto::mutable_dims()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:opencv_onnx.TensorProto.dims)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_dims();
}
inline const ::google::protobuf::RepeatedField<::int64_t>& TensorProto::_internal_dims()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dims_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* TensorProto::_internal_mutable_dims() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.dims_;
}

// optional .opencv_onnx.TensorProto.DataType data_type = 2;
inline bool TensorProto::has_data_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void TensorProto::clear_data_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.data_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::opencv_onnx::TensorProto_DataType TensorProto::data_type() const {
  // @@protoc_insertion_point(field_get:opencv_onnx.TensorProto.data_type)
  return _internal_data_type();
}
inline void TensorProto::set_data_type(::opencv_onnx::TensorProto_DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:opencv_onnx.TensorProto.data_type)
}
inline ::opencv_onnx::TensorProto_DataType TensorProto::_internal_data_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::opencv_onnx::TensorProto_DataType>(_impl_.data_type_);
}
inline void TensorProto::_internal_set_data_type(::opencv_onnx::TensorProto_DataType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::opencv_onnx::TensorProto_DataType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.data_type_ = value;
}

// optional .opencv_onnx.TensorProto.Segment segment = 3;
inline bool TensorProto::has_segment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.segment_ != nullptr);
  return value;
}
inline void TensorProto::clear_segment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.segment_ != nullptr) _impl_.segment_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::opencv_onnx::TensorProto_Segment& TensorProto::_internal_segment() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::opencv_onnx::TensorProto_Segment* p = _impl_.segment_;
  return p != nullptr ? *p : reinterpret_cast<const ::opencv_onnx::TensorProto_Segment&>(::opencv_onnx::_TensorProto_Segment_default_instance_);
}
inline const ::opencv_onnx::TensorProto_Segment& TensorProto::segment() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.TensorProto.segment)
  return _internal_segment();
}
inline void TensorProto::unsafe_arena_set_allocated_segment(::opencv_onnx::TensorProto_Segment* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.segment_);
  }
  _impl_.segment_ = reinterpret_cast<::opencv_onnx::TensorProto_Segment*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opencv_onnx.TensorProto.segment)
}
inline ::opencv_onnx::TensorProto_Segment* TensorProto::release_segment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::opencv_onnx::TensorProto_Segment* released = _impl_.segment_;
  _impl_.segment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::opencv_onnx::TensorProto_Segment* TensorProto::unsafe_arena_release_segment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.TensorProto.segment)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::opencv_onnx::TensorProto_Segment* temp = _impl_.segment_;
  _impl_.segment_ = nullptr;
  return temp;
}
inline ::opencv_onnx::TensorProto_Segment* TensorProto::_internal_mutable_segment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.segment_ == nullptr) {
    auto* p = CreateMaybeMessage<::opencv_onnx::TensorProto_Segment>(GetArena());
    _impl_.segment_ = reinterpret_cast<::opencv_onnx::TensorProto_Segment*>(p);
  }
  return _impl_.segment_;
}
inline ::opencv_onnx::TensorProto_Segment* TensorProto::mutable_segment() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::opencv_onnx::TensorProto_Segment* _msg = _internal_mutable_segment();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.TensorProto.segment)
  return _msg;
}
inline void TensorProto::set_allocated_segment(::opencv_onnx::TensorProto_Segment* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::opencv_onnx::TensorProto_Segment*>(_impl_.segment_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::opencv_onnx::TensorProto_Segment*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.segment_ = reinterpret_cast<::opencv_onnx::TensorProto_Segment*>(value);
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.TensorProto.segment)
}

// repeated float float_data = 4 [packed = true];
inline int TensorProto::_internal_float_data_size() const {
  return _internal_float_data().size();
}
inline int TensorProto::float_data_size() const {
  return _internal_float_data_size();
}
inline void TensorProto::clear_float_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.float_data_.Clear();
}
inline float TensorProto::float_data(int index) const {
  // @@protoc_insertion_point(field_get:opencv_onnx.TensorProto.float_data)
  return _internal_float_data().Get(index);
}
inline void TensorProto::set_float_data(int index, float value) {
  _internal_mutable_float_data()->Set(index, value);
  // @@protoc_insertion_point(field_set:opencv_onnx.TensorProto.float_data)
}
inline void TensorProto::add_float_data(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_float_data()->Add(value);
  // @@protoc_insertion_point(field_add:opencv_onnx.TensorProto.float_data)
}
inline const ::google::protobuf::RepeatedField<float>& TensorProto::float_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:opencv_onnx.TensorProto.float_data)
  return _internal_float_data();
}
inline ::google::protobuf::RepeatedField<float>* TensorProto::mutable_float_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:opencv_onnx.TensorProto.float_data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_float_data();
}
inline const ::google::protobuf::RepeatedField<float>& TensorProto::_internal_float_data()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.float_data_;
}
inline ::google::protobuf::RepeatedField<float>* TensorProto::_internal_mutable_float_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.float_data_;
}

// repeated int32 int32_data = 5 [packed = true];
inline int TensorProto::_internal_int32_data_size() const {
  return _internal_int32_data().size();
}
inline int TensorProto::int32_data_size() const {
  return _internal_int32_data_size();
}
inline void TensorProto::clear_int32_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.int32_data_.Clear();
}
inline ::int32_t TensorProto::int32_data(int index) const {
  // @@protoc_insertion_point(field_get:opencv_onnx.TensorProto.int32_data)
  return _internal_int32_data().Get(index);
}
inline void TensorProto::set_int32_data(int index, ::int32_t value) {
  _internal_mutable_int32_data()->Set(index, value);
  // @@protoc_insertion_point(field_set:opencv_onnx.TensorProto.int32_data)
}
inline void TensorProto::add_int32_data(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_int32_data()->Add(value);
  // @@protoc_insertion_point(field_add:opencv_onnx.TensorProto.int32_data)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TensorProto::int32_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:opencv_onnx.TensorProto.int32_data)
  return _internal_int32_data();
}
inline ::google::protobuf::RepeatedField<::int32_t>* TensorProto::mutable_int32_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:opencv_onnx.TensorProto.int32_data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_int32_data();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& TensorProto::_internal_int32_data()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.int32_data_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* TensorProto::_internal_mutable_int32_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.int32_data_;
}

// repeated bytes string_data = 6;
inline int TensorProto::_internal_string_data_size() const {
  return _internal_string_data().size();
}
inline int TensorProto::string_data_size() const {
  return _internal_string_data_size();
}
inline void TensorProto::clear_string_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.string_data_.Clear();
}
inline std::string* TensorProto::add_string_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_string_data()->Add();
  // @@protoc_insertion_point(field_add_mutable:opencv_onnx.TensorProto.string_data)
  return _s;
}
inline const std::string& TensorProto::string_data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.TensorProto.string_data)
  return _internal_string_data().Get(index);
}
inline std::string* TensorProto::mutable_string_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:opencv_onnx.TensorProto.string_data)
  return _internal_mutable_string_data()->Mutable(index);
}
inline void TensorProto::set_string_data(int index, const std::string& value) {
  _internal_mutable_string_data()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:opencv_onnx.TensorProto.string_data)
}
inline void TensorProto::set_string_data(int index, std::string&& value) {
  _internal_mutable_string_data()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:opencv_onnx.TensorProto.string_data)
}
inline void TensorProto::set_string_data(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_string_data()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:opencv_onnx.TensorProto.string_data)
}
inline void TensorProto::set_string_data(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_string_data()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:opencv_onnx.TensorProto.string_data)
}
inline void TensorProto::set_string_data(int index, absl::string_view value) {
  _internal_mutable_string_data()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:opencv_onnx.TensorProto.string_data)
}
inline void TensorProto::add_string_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_string_data()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:opencv_onnx.TensorProto.string_data)
}
inline void TensorProto::add_string_data(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_string_data()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:opencv_onnx.TensorProto.string_data)
}
inline void TensorProto::add_string_data(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_string_data()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:opencv_onnx.TensorProto.string_data)
}
inline void TensorProto::add_string_data(const void* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_string_data()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:opencv_onnx.TensorProto.string_data)
}
inline void TensorProto::add_string_data(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_string_data()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:opencv_onnx.TensorProto.string_data)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TensorProto::string_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:opencv_onnx.TensorProto.string_data)
  return _internal_string_data();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TensorProto::mutable_string_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:opencv_onnx.TensorProto.string_data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_string_data();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
TensorProto::_internal_string_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.string_data_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
TensorProto::_internal_mutable_string_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.string_data_;
}

// repeated int64 int64_data = 7 [packed = true];
inline int TensorProto::_internal_int64_data_size() const {
  return _internal_int64_data().size();
}
inline int TensorProto::int64_data_size() const {
  return _internal_int64_data_size();
}
inline void TensorProto::clear_int64_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.int64_data_.Clear();
}
inline ::int64_t TensorProto::int64_data(int index) const {
  // @@protoc_insertion_point(field_get:opencv_onnx.TensorProto.int64_data)
  return _internal_int64_data().Get(index);
}
inline void TensorProto::set_int64_data(int index, ::int64_t value) {
  _internal_mutable_int64_data()->Set(index, value);
  // @@protoc_insertion_point(field_set:opencv_onnx.TensorProto.int64_data)
}
inline void TensorProto::add_int64_data(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_int64_data()->Add(value);
  // @@protoc_insertion_point(field_add:opencv_onnx.TensorProto.int64_data)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& TensorProto::int64_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:opencv_onnx.TensorProto.int64_data)
  return _internal_int64_data();
}
inline ::google::protobuf::RepeatedField<::int64_t>* TensorProto::mutable_int64_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:opencv_onnx.TensorProto.int64_data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_int64_data();
}
inline const ::google::protobuf::RepeatedField<::int64_t>& TensorProto::_internal_int64_data()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.int64_data_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* TensorProto::_internal_mutable_int64_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.int64_data_;
}

// optional string name = 8;
inline bool TensorProto::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TensorProto::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TensorProto::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.TensorProto.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TensorProto::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:opencv_onnx.TensorProto.name)
}
inline std::string* TensorProto::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.TensorProto.name)
  return _s;
}
inline const std::string& TensorProto::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void TensorProto::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* TensorProto::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* TensorProto::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.TensorProto.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TensorProto::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.TensorProto.name)
}

// optional string doc_string = 12;
inline bool TensorProto::has_doc_string() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TensorProto::clear_doc_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.doc_string_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TensorProto::doc_string() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.TensorProto.doc_string)
  return _internal_doc_string();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TensorProto::set_doc_string(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.doc_string_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:opencv_onnx.TensorProto.doc_string)
}
inline std::string* TensorProto::mutable_doc_string() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_doc_string();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.TensorProto.doc_string)
  return _s;
}
inline const std::string& TensorProto::_internal_doc_string() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.doc_string_.Get();
}
inline void TensorProto::_internal_set_doc_string(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.doc_string_.Set(value, GetArena());
}
inline std::string* TensorProto::_internal_mutable_doc_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.doc_string_.Mutable( GetArena());
}
inline std::string* TensorProto::release_doc_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.TensorProto.doc_string)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.doc_string_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.doc_string_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TensorProto::set_allocated_doc_string(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.doc_string_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.doc_string_.IsDefault()) {
          _impl_.doc_string_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.TensorProto.doc_string)
}

// optional bytes raw_data = 9;
inline bool TensorProto::has_raw_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TensorProto::clear_raw_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.raw_data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TensorProto::raw_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.TensorProto.raw_data)
  return _internal_raw_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TensorProto::set_raw_data(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.raw_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:opencv_onnx.TensorProto.raw_data)
}
inline std::string* TensorProto::mutable_raw_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_raw_data();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.TensorProto.raw_data)
  return _s;
}
inline const std::string& TensorProto::_internal_raw_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.raw_data_.Get();
}
inline void TensorProto::_internal_set_raw_data(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.raw_data_.Set(value, GetArena());
}
inline std::string* TensorProto::_internal_mutable_raw_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.raw_data_.Mutable( GetArena());
}
inline std::string* TensorProto::release_raw_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.TensorProto.raw_data)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.raw_data_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.raw_data_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TensorProto::set_allocated_raw_data(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.raw_data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.raw_data_.IsDefault()) {
          _impl_.raw_data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.TensorProto.raw_data)
}

// repeated double double_data = 10 [packed = true];
inline int TensorProto::_internal_double_data_size() const {
  return _internal_double_data().size();
}
inline int TensorProto::double_data_size() const {
  return _internal_double_data_size();
}
inline void TensorProto::clear_double_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.double_data_.Clear();
}
inline double TensorProto::double_data(int index) const {
  // @@protoc_insertion_point(field_get:opencv_onnx.TensorProto.double_data)
  return _internal_double_data().Get(index);
}
inline void TensorProto::set_double_data(int index, double value) {
  _internal_mutable_double_data()->Set(index, value);
  // @@protoc_insertion_point(field_set:opencv_onnx.TensorProto.double_data)
}
inline void TensorProto::add_double_data(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_double_data()->Add(value);
  // @@protoc_insertion_point(field_add:opencv_onnx.TensorProto.double_data)
}
inline const ::google::protobuf::RepeatedField<double>& TensorProto::double_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:opencv_onnx.TensorProto.double_data)
  return _internal_double_data();
}
inline ::google::protobuf::RepeatedField<double>* TensorProto::mutable_double_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:opencv_onnx.TensorProto.double_data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_double_data();
}
inline const ::google::protobuf::RepeatedField<double>& TensorProto::_internal_double_data()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.double_data_;
}
inline ::google::protobuf::RepeatedField<double>* TensorProto::_internal_mutable_double_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.double_data_;
}

// repeated uint64 uint64_data = 11 [packed = true];
inline int TensorProto::_internal_uint64_data_size() const {
  return _internal_uint64_data().size();
}
inline int TensorProto::uint64_data_size() const {
  return _internal_uint64_data_size();
}
inline void TensorProto::clear_uint64_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uint64_data_.Clear();
}
inline ::uint64_t TensorProto::uint64_data(int index) const {
  // @@protoc_insertion_point(field_get:opencv_onnx.TensorProto.uint64_data)
  return _internal_uint64_data().Get(index);
}
inline void TensorProto::set_uint64_data(int index, ::uint64_t value) {
  _internal_mutable_uint64_data()->Set(index, value);
  // @@protoc_insertion_point(field_set:opencv_onnx.TensorProto.uint64_data)
}
inline void TensorProto::add_uint64_data(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_uint64_data()->Add(value);
  // @@protoc_insertion_point(field_add:opencv_onnx.TensorProto.uint64_data)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& TensorProto::uint64_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:opencv_onnx.TensorProto.uint64_data)
  return _internal_uint64_data();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* TensorProto::mutable_uint64_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:opencv_onnx.TensorProto.uint64_data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_uint64_data();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& TensorProto::_internal_uint64_data()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uint64_data_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* TensorProto::_internal_mutable_uint64_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.uint64_data_;
}

// -------------------------------------------------------------------

// TensorShapeProto_Dimension

// int64 dim_value = 1;
inline bool TensorShapeProto_Dimension::has_dim_value() const {
  return value_case() == kDimValue;
}
inline void TensorShapeProto_Dimension::set_has_dim_value() {
  _impl_._oneof_case_[0] = kDimValue;
}
inline void TensorShapeProto_Dimension::clear_dim_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kDimValue) {
    _impl_.value_.dim_value_ = ::int64_t{0};
    clear_has_value();
  }
}
inline ::int64_t TensorShapeProto_Dimension::dim_value() const {
  // @@protoc_insertion_point(field_get:opencv_onnx.TensorShapeProto.Dimension.dim_value)
  return _internal_dim_value();
}
inline void TensorShapeProto_Dimension::set_dim_value(::int64_t value) {
  _internal_set_dim_value(value);
  // @@protoc_insertion_point(field_set:opencv_onnx.TensorShapeProto.Dimension.dim_value)
}
inline ::int64_t TensorShapeProto_Dimension::_internal_dim_value() const {
  if (value_case() == kDimValue) {
    return _impl_.value_.dim_value_;
  }
  return ::int64_t{0};
}
inline void TensorShapeProto_Dimension::_internal_set_dim_value(::int64_t value) {
  if (value_case() != kDimValue) {
    clear_value();
    set_has_dim_value();
  }
  _impl_.value_.dim_value_ = value;
}

// string dim_param = 2;
inline bool TensorShapeProto_Dimension::has_dim_param() const {
  return value_case() == kDimParam;
}
inline void TensorShapeProto_Dimension::set_has_dim_param() {
  _impl_._oneof_case_[0] = kDimParam;
}
inline void TensorShapeProto_Dimension::clear_dim_param() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kDimParam) {
    _impl_.value_.dim_param_.Destroy();
    clear_has_value();
  }
}
inline const std::string& TensorShapeProto_Dimension::dim_param() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.TensorShapeProto.Dimension.dim_param)
  return _internal_dim_param();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TensorShapeProto_Dimension::set_dim_param(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() != kDimParam) {
    clear_value();

    set_has_dim_param();
    _impl_.value_.dim_param_.InitDefault();
  }
  _impl_.value_.dim_param_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:opencv_onnx.TensorShapeProto.Dimension.dim_param)
}
inline std::string* TensorShapeProto_Dimension::mutable_dim_param() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_dim_param();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.TensorShapeProto.Dimension.dim_param)
  return _s;
}
inline const std::string& TensorShapeProto_Dimension::_internal_dim_param() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (value_case() != kDimParam) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.value_.dim_param_.Get();
}
inline void TensorShapeProto_Dimension::_internal_set_dim_param(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() != kDimParam) {
    clear_value();

    set_has_dim_param();
    _impl_.value_.dim_param_.InitDefault();
  }
  _impl_.value_.dim_param_.Set(value, GetArena());
}
inline std::string* TensorShapeProto_Dimension::_internal_mutable_dim_param() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() != kDimParam) {
    clear_value();

    set_has_dim_param();
    _impl_.value_.dim_param_.InitDefault();
  }
  return _impl_.value_.dim_param_.Mutable( GetArena());
}
inline std::string* TensorShapeProto_Dimension::release_dim_param() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.TensorShapeProto.Dimension.dim_param)
  if (value_case() != kDimParam) {
    return nullptr;
  }
  clear_has_value();
  return _impl_.value_.dim_param_.Release();
}
inline void TensorShapeProto_Dimension::set_allocated_dim_param(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_value()) {
    clear_value();
  }
  if (value != nullptr) {
    set_has_dim_param();
    _impl_.value_.dim_param_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.TensorShapeProto.Dimension.dim_param)
}

// optional string denotation = 3;
inline bool TensorShapeProto_Dimension::has_denotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TensorShapeProto_Dimension::clear_denotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.denotation_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TensorShapeProto_Dimension::denotation() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.TensorShapeProto.Dimension.denotation)
  return _internal_denotation();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TensorShapeProto_Dimension::set_denotation(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.denotation_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:opencv_onnx.TensorShapeProto.Dimension.denotation)
}
inline std::string* TensorShapeProto_Dimension::mutable_denotation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_denotation();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.TensorShapeProto.Dimension.denotation)
  return _s;
}
inline const std::string& TensorShapeProto_Dimension::_internal_denotation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.denotation_.Get();
}
inline void TensorShapeProto_Dimension::_internal_set_denotation(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.denotation_.Set(value, GetArena());
}
inline std::string* TensorShapeProto_Dimension::_internal_mutable_denotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.denotation_.Mutable( GetArena());
}
inline std::string* TensorShapeProto_Dimension::release_denotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.TensorShapeProto.Dimension.denotation)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.denotation_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.denotation_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TensorShapeProto_Dimension::set_allocated_denotation(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.denotation_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.denotation_.IsDefault()) {
          _impl_.denotation_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.TensorShapeProto.Dimension.denotation)
}

inline bool TensorShapeProto_Dimension::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void TensorShapeProto_Dimension::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline TensorShapeProto_Dimension::ValueCase TensorShapeProto_Dimension::value_case() const {
  return TensorShapeProto_Dimension::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TensorShapeProto

// repeated .opencv_onnx.TensorShapeProto.Dimension dim = 1;
inline int TensorShapeProto::_internal_dim_size() const {
  return _internal_dim().size();
}
inline int TensorShapeProto::dim_size() const {
  return _internal_dim_size();
}
inline void TensorShapeProto::clear_dim() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dim_.Clear();
}
inline ::opencv_onnx::TensorShapeProto_Dimension* TensorShapeProto::mutable_dim(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:opencv_onnx.TensorShapeProto.dim)
  return _internal_mutable_dim()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::opencv_onnx::TensorShapeProto_Dimension>* TensorShapeProto::mutable_dim()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:opencv_onnx.TensorShapeProto.dim)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_dim();
}
inline const ::opencv_onnx::TensorShapeProto_Dimension& TensorShapeProto::dim(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.TensorShapeProto.dim)
  return _internal_dim().Get(index);
}
inline ::opencv_onnx::TensorShapeProto_Dimension* TensorShapeProto::add_dim() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::opencv_onnx::TensorShapeProto_Dimension* _add = _internal_mutable_dim()->Add();
  // @@protoc_insertion_point(field_add:opencv_onnx.TensorShapeProto.dim)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::opencv_onnx::TensorShapeProto_Dimension>& TensorShapeProto::dim() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:opencv_onnx.TensorShapeProto.dim)
  return _internal_dim();
}
inline const ::google::protobuf::RepeatedPtrField<::opencv_onnx::TensorShapeProto_Dimension>&
TensorShapeProto::_internal_dim() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dim_;
}
inline ::google::protobuf::RepeatedPtrField<::opencv_onnx::TensorShapeProto_Dimension>*
TensorShapeProto::_internal_mutable_dim() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.dim_;
}

// -------------------------------------------------------------------

// TypeProto_Tensor

// optional .opencv_onnx.TensorProto.DataType elem_type = 1;
inline bool TypeProto_Tensor::has_elem_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TypeProto_Tensor::clear_elem_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.elem_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::opencv_onnx::TensorProto_DataType TypeProto_Tensor::elem_type() const {
  // @@protoc_insertion_point(field_get:opencv_onnx.TypeProto.Tensor.elem_type)
  return _internal_elem_type();
}
inline void TypeProto_Tensor::set_elem_type(::opencv_onnx::TensorProto_DataType value) {
  _internal_set_elem_type(value);
  // @@protoc_insertion_point(field_set:opencv_onnx.TypeProto.Tensor.elem_type)
}
inline ::opencv_onnx::TensorProto_DataType TypeProto_Tensor::_internal_elem_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::opencv_onnx::TensorProto_DataType>(_impl_.elem_type_);
}
inline void TypeProto_Tensor::_internal_set_elem_type(::opencv_onnx::TensorProto_DataType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::opencv_onnx::TensorProto_DataType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.elem_type_ = value;
}

// optional .opencv_onnx.TensorShapeProto shape = 2;
inline bool TypeProto_Tensor::has_shape() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.shape_ != nullptr);
  return value;
}
inline void TypeProto_Tensor::clear_shape() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.shape_ != nullptr) _impl_.shape_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::opencv_onnx::TensorShapeProto& TypeProto_Tensor::_internal_shape() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::opencv_onnx::TensorShapeProto* p = _impl_.shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::opencv_onnx::TensorShapeProto&>(::opencv_onnx::_TensorShapeProto_default_instance_);
}
inline const ::opencv_onnx::TensorShapeProto& TypeProto_Tensor::shape() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.TypeProto.Tensor.shape)
  return _internal_shape();
}
inline void TypeProto_Tensor::unsafe_arena_set_allocated_shape(::opencv_onnx::TensorShapeProto* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.shape_);
  }
  _impl_.shape_ = reinterpret_cast<::opencv_onnx::TensorShapeProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opencv_onnx.TypeProto.Tensor.shape)
}
inline ::opencv_onnx::TensorShapeProto* TypeProto_Tensor::release_shape() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::opencv_onnx::TensorShapeProto* released = _impl_.shape_;
  _impl_.shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::opencv_onnx::TensorShapeProto* TypeProto_Tensor::unsafe_arena_release_shape() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.TypeProto.Tensor.shape)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::opencv_onnx::TensorShapeProto* temp = _impl_.shape_;
  _impl_.shape_ = nullptr;
  return temp;
}
inline ::opencv_onnx::TensorShapeProto* TypeProto_Tensor::_internal_mutable_shape() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.shape_ == nullptr) {
    auto* p = CreateMaybeMessage<::opencv_onnx::TensorShapeProto>(GetArena());
    _impl_.shape_ = reinterpret_cast<::opencv_onnx::TensorShapeProto*>(p);
  }
  return _impl_.shape_;
}
inline ::opencv_onnx::TensorShapeProto* TypeProto_Tensor::mutable_shape() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::opencv_onnx::TensorShapeProto* _msg = _internal_mutable_shape();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.TypeProto.Tensor.shape)
  return _msg;
}
inline void TypeProto_Tensor::set_allocated_shape(::opencv_onnx::TensorShapeProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::opencv_onnx::TensorShapeProto*>(_impl_.shape_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::opencv_onnx::TensorShapeProto*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.shape_ = reinterpret_cast<::opencv_onnx::TensorShapeProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.TypeProto.Tensor.shape)
}

// -------------------------------------------------------------------

// TypeProto

// .opencv_onnx.TypeProto.Tensor tensor_type = 1;
inline bool TypeProto::has_tensor_type() const {
  return value_case() == kTensorType;
}
inline bool TypeProto::_internal_has_tensor_type() const {
  return value_case() == kTensorType;
}
inline void TypeProto::set_has_tensor_type() {
  _impl_._oneof_case_[0] = kTensorType;
}
inline void TypeProto::clear_tensor_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kTensorType) {
    if (GetArena() == nullptr) {
      delete _impl_.value_.tensor_type_;
    }
    clear_has_value();
  }
}
inline ::opencv_onnx::TypeProto_Tensor* TypeProto::release_tensor_type() {
  // @@protoc_insertion_point(field_release:opencv_onnx.TypeProto.tensor_type)
  if (value_case() == kTensorType) {
    clear_has_value();
    auto* temp = _impl_.value_.tensor_type_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.tensor_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::opencv_onnx::TypeProto_Tensor& TypeProto::_internal_tensor_type() const {
  return value_case() == kTensorType ? *_impl_.value_.tensor_type_ : reinterpret_cast<::opencv_onnx::TypeProto_Tensor&>(::opencv_onnx::_TypeProto_Tensor_default_instance_);
}
inline const ::opencv_onnx::TypeProto_Tensor& TypeProto::tensor_type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.TypeProto.tensor_type)
  return _internal_tensor_type();
}
inline ::opencv_onnx::TypeProto_Tensor* TypeProto::unsafe_arena_release_tensor_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:opencv_onnx.TypeProto.tensor_type)
  if (value_case() == kTensorType) {
    clear_has_value();
    auto* temp = _impl_.value_.tensor_type_;
    _impl_.value_.tensor_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TypeProto::unsafe_arena_set_allocated_tensor_type(::opencv_onnx::TypeProto_Tensor* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_value();
  if (value) {
    set_has_tensor_type();
    _impl_.value_.tensor_type_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:opencv_onnx.TypeProto.tensor_type)
}
inline ::opencv_onnx::TypeProto_Tensor* TypeProto::_internal_mutable_tensor_type() {
  if (value_case() != kTensorType) {
    clear_value();
    set_has_tensor_type();
    _impl_.value_.tensor_type_ = CreateMaybeMessage<::opencv_onnx::TypeProto_Tensor>(GetArena());
  }
  return _impl_.value_.tensor_type_;
}
inline ::opencv_onnx::TypeProto_Tensor* TypeProto::mutable_tensor_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::opencv_onnx::TypeProto_Tensor* _msg = _internal_mutable_tensor_type();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.TypeProto.tensor_type)
  return _msg;
}

// optional string denotation = 6;
inline bool TypeProto::has_denotation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TypeProto::clear_denotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.denotation_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TypeProto::denotation() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.TypeProto.denotation)
  return _internal_denotation();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TypeProto::set_denotation(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.denotation_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:opencv_onnx.TypeProto.denotation)
}
inline std::string* TypeProto::mutable_denotation() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_denotation();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.TypeProto.denotation)
  return _s;
}
inline const std::string& TypeProto::_internal_denotation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.denotation_.Get();
}
inline void TypeProto::_internal_set_denotation(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.denotation_.Set(value, GetArena());
}
inline std::string* TypeProto::_internal_mutable_denotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.denotation_.Mutable( GetArena());
}
inline std::string* TypeProto::release_denotation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.TypeProto.denotation)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.denotation_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.denotation_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void TypeProto::set_allocated_denotation(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.denotation_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.denotation_.IsDefault()) {
          _impl_.denotation_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.TypeProto.denotation)
}

inline bool TypeProto::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void TypeProto::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline TypeProto::ValueCase TypeProto::value_case() const {
  return TypeProto::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// OperatorSetIdProto

// optional string domain = 1;
inline bool OperatorSetIdProto::has_domain() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void OperatorSetIdProto::clear_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.domain_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OperatorSetIdProto::domain() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:opencv_onnx.OperatorSetIdProto.domain)
  return _internal_domain();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void OperatorSetIdProto::set_domain(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.domain_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:opencv_onnx.OperatorSetIdProto.domain)
}
inline std::string* OperatorSetIdProto::mutable_domain() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_domain();
  // @@protoc_insertion_point(field_mutable:opencv_onnx.OperatorSetIdProto.domain)
  return _s;
}
inline const std::string& OperatorSetIdProto::_internal_domain() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.domain_.Get();
}
inline void OperatorSetIdProto::_internal_set_domain(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.domain_.Set(value, GetArena());
}
inline std::string* OperatorSetIdProto::_internal_mutable_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.domain_.Mutable( GetArena());
}
inline std::string* OperatorSetIdProto::release_domain() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:opencv_onnx.OperatorSetIdProto.domain)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.domain_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.domain_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void OperatorSetIdProto::set_allocated_domain(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.domain_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.domain_.IsDefault()) {
          _impl_.domain_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:opencv_onnx.OperatorSetIdProto.domain)
}

// optional int64 version = 2;
inline bool OperatorSetIdProto::has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void OperatorSetIdProto::clear_version() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.version_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t OperatorSetIdProto::version() const {
  // @@protoc_insertion_point(field_get:opencv_onnx.OperatorSetIdProto.version)
  return _internal_version();
}
inline void OperatorSetIdProto::set_version(::int64_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:opencv_onnx.OperatorSetIdProto.version)
}
inline ::int64_t OperatorSetIdProto::_internal_version() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.version_;
}
inline void OperatorSetIdProto::_internal_set_version(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.version_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace opencv_onnx


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::opencv_onnx::AttributeProto_AttributeType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::opencv_onnx::AttributeProto_AttributeType>() {
  return ::opencv_onnx::AttributeProto_AttributeType_descriptor();
}
template <>
struct is_proto_enum<::opencv_onnx::TensorProto_DataType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::opencv_onnx::TensorProto_DataType>() {
  return ::opencv_onnx::TensorProto_DataType_descriptor();
}
template <>
struct is_proto_enum<::opencv_onnx::Version> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::opencv_onnx::Version>() {
  return ::opencv_onnx::Version_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_opencv_2donnx_2eproto_2epb_2eh
